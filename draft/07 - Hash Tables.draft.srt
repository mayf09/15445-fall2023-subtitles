1
00:00:42,640 --> 00:00:51,075
0,400 1530,1775 1775,1865 1865,2110 8160,8435
{She,was} trying to {find,you,where}.| So
她想找到你在哪里。|所以，很快，

2
00:00:51,075 --> 00:00:53,400
0,165 165,405 405,755 1375,1775 2005,2325
real quick,| actually, the facilities
|事实上，设施的人刚刚来找我，

3
00:00:53,400 --> 00:00:54,300
0,285 285,480 480,585 585,765 765,900
people actually just came to

4
00:00:54,300 --> 00:00:55,245
0,150 150,315 315,480 480,720 720,945
me| and they said that
|他们说州长在这里， Shapiro ，

5
00:00:55,245 --> 00:00:58,610
0,285 285,645 645,915 915,1205 2695,3365
the governor is here, Shapiro,|
|

6
00:00:59,800 --> 00:01:00,360
0,400
{I,support,him},
我支持他，他不是 Trump 的支持者，

7
00:01:00,360 --> 00:01:01,070
0,105 105,165 165,255 255,360 360,710
he's not a Trump supporter,|
|

8
00:01:01,900 --> 00:01:03,315
0,400 480,755 755,1025 1025,1265 1265,1415
but the main entrance is
但主入口被封锁了，

9
00:01:03,315 --> 00:01:04,560
0,225 225,545 685,930 930,1080 1080,1245
blocked off,| so when the
|所以当课程结束时，

10
00:01:04,560 --> 00:01:05,445
0,135 135,270 270,435 435,630 630,885
class is over,| you can't
|你不能通过那个入口，

11
00:01:05,445 --> 00:01:06,315
0,180 180,330 330,510 510,735 735,870
go through that entrance,| you
|你得乘电梯上楼，

12
00:01:06,315 --> 00:01:07,065
0,90 90,210 210,330 330,420 420,750
got to take the elevator

13
00:01:07,065 --> 00:01:08,960
0,165 165,255 255,635
and go upstairs,|
|

14
00:01:09,090 --> 00:01:10,415
0,320 320,425 425,650 650,875 875,1325
that's why all the fedies
所以联邦探员和警察都在外面。

15
00:01:10,415 --> 00:01:10,970
0,90 90,195 195,375 375,450 450,555
and the cops are out

16
00:01:10,970 --> 00:01:15,935
0,260 460,705 705,950 3820,4220 4660,4965
there.| All right, so again
|好的，对于课程，

17
00:01:15,935 --> 00:01:17,300
0,135 135,255 255,545 985,1245 1245,1365
for the class,| again, we
|我们在星期一有一次复习课，

18
00:01:17,300 --> 00:01:20,050
0,260 1120,1520 1690,2265 2265,2475 2475,2750
had the recitation on Monday,|
|

19
00:01:20,160 --> 00:01:21,380
0,320 320,410 410,605 605,815 815,1220
that's been posted on piazza
作为一个视频发布在了 Piazza 上，

20
00:01:21,380 --> 00:01:23,570
0,105 105,210 210,470 1660,1995 1995,2190
as a video,| project #1
|项目一截止 10 月 2 日，

21
00:01:23,570 --> 00:01:24,665
0,135 135,300 300,540 540,825 825,1095
is still due on October

22
00:01:24,665 --> 00:01:27,245
0,335 835,1235 1405,1805 2185,2445 2445,2580
7th, October 2nd,| and then
|然后，我们将在 10 月 1 日星期六有特殊办公时间，

23
00:01:27,245 --> 00:01:28,130
0,120 120,225 225,480 480,750 750,885
we will have again the

24
00:01:28,130 --> 00:01:29,120
0,225 225,435 435,585 585,765 765,990
special office hours on Saturday

25
00:01:29,120 --> 00:01:30,305
0,180 180,270 270,530 790,1050 1050,1185
on October 1st,| and then
|然后作业二推迟到 10 月 4 日，

26
00:01:30,305 --> 00:01:31,610
0,240 240,600 600,855 855,1005 1005,1305
homework #1 has been bumped

27
00:01:31,610 --> 00:01:32,975
0,105 105,240 240,495 495,860 1000,1365
to be due on October

28
00:01:32,975 --> 00:01:33,905
0,270 270,420 420,570 570,660 660,930
4th,| and that's a Wednesday,
|那是星期三，而不是星期天。

29
00:01:33,905 --> 00:01:36,120
0,240 240,360 360,635
not a Sunday.|
|

30
00:01:37,210 --> 00:01:39,180
0,320 320,640 1350,1670 1670,1835 1835,1970
Any questions about the homework
关于作业和项目有什么问题吗？

31
00:01:39,180 --> 00:01:43,960
0,120 120,195 195,440
and the projects?|
|

32
00:01:44,180 --> 00:01:45,610
0,245 245,470 470,755 755,1100 1100,1430
All right, so it's, it's
好的，它是星期天截止，

33
00:01:45,610 --> 00:01:47,095
0,225 225,480 480,800 1000,1320 1320,1485
due on the, it's due

34
00:01:47,095 --> 00:01:48,685
0,195 195,360 360,635 1165,1425 1425,1590
on the Sunday| and then
|然后办公时间在星期六，

35
00:01:48,685 --> 00:01:50,365
0,305 865,1110 1110,1290 1290,1515 1515,1680
the office hours are on

36
00:01:50,365 --> 00:01:52,720
0,135 135,395 505,905 2035,2280 2280,2355
the Saturday,| so {whatever -}
|所以不论真正的日期是什么？

37
00:01:52,720 --> 00:01:54,240
0,120 120,285 285,435 435,710 1120,1520
those real dates are?| Yes.|
|是的。|

38
00:01:56,160 --> 00:01:57,725
0,320 320,640 840,1160 1160,1385 1385,1565
The website and {GradeScope -}
网站和 GradeScope 应该是正确的，不是我。

39
00:01:57,725 --> 00:01:58,840
0,105 105,210 210,485
should be correct,

40
00:01:59,215 --> 00:02:00,120
0,90 90,335
I'm not.|
|

41
00:02:00,370 --> 00:02:01,780
0,290 290,580
Other questions?|
还有其他问题吗？|

42
00:02:02,850 --> 00:02:04,835
0,230 230,365 365,670 750,1150 1740,1985
All right, cool.| {} So
好的，酷。|所以，有一个有趣的事情，

43
00:02:04,835 --> 00:02:06,830
0,245 265,585 585,750 750,995 1705,1995
then two sort of, one

44
00:02:06,830 --> 00:02:07,595
0,120 120,210 210,375 375,600 600,765
sort of fun thing to

45
00:02:07,595 --> 00:02:09,185
0,105 105,315 315,665 1045,1365 1365,1590
bring up,| {} someone said
|有人说，嘿，实习怎么样，这些公司在招人吗，

46
00:02:09,185 --> 00:02:10,295
0,210 210,390 390,615 615,1020 1020,1110
hey, what about internships, are

47
00:02:10,295 --> 00:02:11,600
0,105 105,300 300,635 955,1185 1185,1305
these companies hiring,| the answer
|答案是肯定的，

48
00:02:11,600 --> 00:02:13,990
0,180 180,470 1180,1575 1575,1970 1990,2390
is yes,| and actually somebody
|事实上，有人在推特上发帖说，

49
00:02:14,670 --> 00:02:17,650
0,335 335,650 650,950 950,1270 2580,2980
posted out on Twitter,| that
|你知道如果你上我的课，他们就会招人，

50
00:02:18,180 --> 00:02:18,935
0,245 245,350 350,470 470,590 590,755
you know if you take

51
00:02:18,935 --> 00:02:20,950
0,195 195,485 535,930 930,1175 1615,2015
my class they're hiring, {}|
|

52
00:02:22,230 --> 00:02:23,500
0,305 305,485 485,830 830,1010 1010,1270
{spacetime_db - -} is a
spacetime_db ，我想它是另一个时间序列数据库系统，

53
00:02:23,940 --> 00:02:24,995
0,335 335,515 515,590 590,770 770,1055
I I think it's time,

54
00:02:24,995 --> 00:02:26,315
0,315 315,540 540,750 750,1035 1035,1320
another time series database system,|
|

55
00:02:26,315 --> 00:02:27,310
0,165 165,255 255,465 465,690 690,995
I think it's at Europe,|
我想是在欧洲，|

56
00:02:27,900 --> 00:02:28,780
0,245 245,380 380,470 470,605 605,880
I don't know this dude,|
我不认识这家伙，|

57
00:02:29,100 --> 00:02:30,305
0,260 260,380 380,620 620,965 965,1205
you can contact him if
如果你愿意，你可以联系他，

58
00:02:30,305 --> 00:02:32,000
0,135 135,395 865,1170 1170,1515 1515,1695
you want,| but we'll post
|但我们会在 Piazza 上张贴，

59
00:02:32,000 --> 00:02:34,835
0,195 195,860 1810,2210 2440,2700 2700,2835
on Piazza,| how you know
|如何给我你的简历，

60
00:02:34,835 --> 00:02:36,695
0,275 1345,1605 1605,1695 1695,1770 1770,1860
how, how you can give

61
00:02:36,695 --> 00:02:37,700
0,90 90,255 255,450 450,810 810,1005
me your your CV| and
|然后我们可以把它发送给我们认识的各种数据库公司，

62
00:02:37,700 --> 00:02:38,330
0,135 135,255 255,375 375,495 495,630
then we can send it

63
00:02:38,330 --> 00:02:39,905
0,290 580,825 825,990 990,1275 1275,1575
to the various database companies

64
00:02:39,905 --> 00:02:40,550
0,180 180,285 285,435 435,570 570,645
that we know| and that
|以及与我们是朋友的公司，

65
00:02:40,550 --> 00:02:41,510
0,75 75,195 195,330 330,590 700,960
are friends with us,| and
|如果你还没有，请向 SingleStore 申请，

66
00:02:41,510 --> 00:02:42,470
0,210 210,420 420,540 540,780 780,960
again if you haven't yet,

67
00:02:42,470 --> 00:02:43,630
0,255 255,480 480,645 645,840 840,1160
please apply to {SingleStore -}|
|

68
00:02:44,010 --> 00:02:45,080
0,275 275,440 440,560 560,815 815,1070
and there's that special email
那里有一个专门针对 CMU 学生的特殊电子邮件地址，

69
00:02:45,080 --> 00:02:46,040
0,180 180,390 390,510 510,660 660,960
address that's just for CMU

70
00:02:46,040 --> 00:02:47,945
0,290 1030,1290 1290,1530 1530,1665 1665,1905
students| and that'll go directly
|它会直接发给招聘者，而不是招聘人员。

71
00:02:47,945 --> 00:02:48,860
0,180 180,270 270,450 450,720 720,915
to the hiring people and

72
00:02:48,860 --> 00:02:51,545
0,180 180,500 610,1100 2350,2595 2595,2685
not the recruiters.| So if
|如果你不想做实习，

73
00:02:51,545 --> 00:02:52,025
0,90 90,255 255,315 315,390 390,480
you don't want to do

74
00:02:52,025 --> 00:02:53,750
0,150 150,635 1225,1530 1530,1665 1665,1725
an internship,| another way to
|另一种通过数据库赚钱的方法是，

75
00:02:53,750 --> 00:02:55,130
0,120 120,390 390,645 645,1185 1185,1380
make money through databases is

76
00:02:55,130 --> 00:02:56,765
0,290 580,975 975,1230 1230,1425 1425,1635
that,| somebody actually posted an
|有人在 upwork 上发布，这是真实的，

77
00:02:56,765 --> 00:02:58,330
0,455 775,1035 1035,1155 1155,1290 1290,1565
upwork and this is real,|
|

78
00:02:58,620 --> 00:02:59,930
0,350 350,635 635,830 830,1070 1070,1310
that they're looking for someone
他们正在寻找人来设计数据库项目，

79
00:02:59,930 --> 00:03:02,620
0,350 370,770 1420,1820 1870,2270 2290,2690
to basically design database projects,|
|

80
00:03:02,790 --> 00:03:03,260
0,400
that
基本上就是 BusTub 和课程项目，

81
00:03:03,260 --> 00:03:05,525
0,260 880,1280 1330,1650 1650,1970 2020,2265
are basically {ButTub -} and

82
00:03:05,525 --> 00:03:07,595
0,120 120,300 300,605 1735,1980 1980,2070
the class projects,| so if
|所以，如果你喜欢你正在做的事情，

83
00:03:07,595 --> 00:03:08,240
0,105 105,240 240,360 360,465 465,645
you like the stuff you're

84
00:03:08,240 --> 00:03:09,230
0,230 400,630 630,705 705,825 825,990
doing,| you can get paid
|你可以从这个人那里得到 100 美元的报酬，

85
00:03:09,230 --> 00:03:10,145
0,135 135,255 255,495 495,735 735,915
a hundred dollars by this

86
00:03:10,145 --> 00:03:13,490
0,305 1975,2375 2545,2880 2880,3105 3105,3345
guy| to go {re-implement -}
|让你去重新实现它。

87
00:03:13,490 --> 00:03:15,695
0,350 1570,1845 1845,1950 1950,2055 2055,2205
that.| And the way we
|我们发现这件事的方式是，

88
00:03:15,695 --> 00:03:17,330
0,180 180,405 405,660 660,995 1255,1635
found this was| somebody actually
|有人给我和 TA Chi 发了电子邮件，

89
00:03:17,330 --> 00:03:19,115
0,420 420,770 1000,1290 1290,1560 1560,1785
emailed Chi the TA and

90
00:03:19,115 --> 00:03:20,090
0,150 150,345 345,585 585,825 825,975
me,| like, hey, I can
|说，嘿，我可以为你做这份工作，

91
00:03:20,090 --> 00:03:20,960
0,120 120,270 270,510 510,735 735,870
do this job for you|
|

92
00:03:20,960 --> 00:03:21,500
0,120 120,255 255,345 345,465 465,540
and he's like what are
他就像是，你在说什么，

93
00:03:21,500 --> 00:03:22,850
0,90 90,330 330,710 970,1215 1215,1350
you talking about,| because they
|因为他们以为我们发了这个，

94
00:03:22,850 --> 00:03:24,260
0,195 195,405 405,675 675,1040 1150,1410
thought we posted this,| this
|这不是我们，这是[]，

95
00:03:24,260 --> 00:03:25,100
0,120 120,270 270,465 465,630 630,840
is not us, this is

96
00:03:25,100 --> 00:03:31,775
0,350 2050,2450 2770,3060 3060,3350 6400,6675
[],| {hundred,dollars} not enough,| hundred
|一百美元肯定不够，|每小时一百美元在数据库上，

97
00:03:31,775 --> 00:03:32,880
0,165 165,300 300,545
dollars an hour,

98
00:03:32,920 --> 00:03:34,430
0,275 275,815 815,1070 1070,1235 1235,1510
in databases,| if not more.|
|如果不是更多的话。|

99
00:03:36,620 --> 00:03:39,280
0,230 230,410 410,760 2280,2555 2555,2660
All right, so where we
好的，我们课程的哪里，

100
00:03:39,280 --> 00:03:40,540
0,75 75,135 135,210 210,470
at in the class,|
|

101
00:03:40,940 --> 00:03:42,060
0,305 305,545 545,755 755,875 875,1120
we, we spent the last
我们花了大约一周的时间讨论了存储层，

102
00:03:42,200 --> 00:03:44,250
0,400 750,1025 1025,1160 1160,1420 1650,2050
{} week or so talking

103
00:03:44,360 --> 00:03:45,510
0,260 260,395 395,560 560,800 800,1150
again about the storage layer|
|

104
00:03:45,740 --> 00:03:47,200
0,275 275,550 720,1040 1040,1220 1220,1460
and then putting the buffer
然后将缓冲池放在它的上面，

105
00:03:47,200 --> 00:03:47,815
0,105 105,225 225,360 360,465 465,615
pool on top of it|
|

106
00:03:47,815 --> 00:03:49,090
0,195 195,360 360,570 570,905 1015,1275
to actually manage memory as
以便在我们将页面传入和传出磁盘时管理内存，

107
00:03:49,090 --> 00:03:49,885
0,135 135,300 300,525 525,705 705,795
we get pages in and

108
00:03:49,885 --> 00:03:51,670
0,210 210,525 525,780 780,1295 1495,1785
out of of disk,| and
|所以，现在我们继续向上，

109
00:03:51,670 --> 00:03:53,275
0,165 165,440 490,975 975,1335 1335,1605
so now we're continuing up

110
00:03:53,275 --> 00:03:55,150
0,240 240,575 985,1380 1380,1680 1680,1875
the stack| and are now
|现在将讨论系统的不同部分，

111
00:03:55,150 --> 00:03:56,110
0,120 120,345 345,615 615,780 780,960
going to talk about different

112
00:03:56,110 --> 00:03:57,340
0,165 165,285 285,405 405,680 940,1230
parts of the system,| that
|这些部分可以操作、执行和处理这些页面，

113
00:03:57,340 --> 00:03:59,305
0,290 730,1050 1050,1370 1390,1695 1695,1965
can operate and execute and

114
00:03:59,305 --> 00:04:01,540
0,365 955,1355 1375,1775 1825,2070 2070,2235
process those pages,| that we've
|我们从磁盘检索到的缓冲池中的（页面）。

115
00:04:01,540 --> 00:04:02,290
0,105 105,255 255,390 390,615 615,750
brought into our buffer pool

116
00:04:02,290 --> 00:04:04,020
0,290 490,765 765,1125 1125,1245 1245,1730
that we retrieved from disk.|
|

117
00:04:04,440 --> 00:04:05,175
0,255 255,390 390,555 555,645 645,735
And so we're sort of
所以，我们处于中间层，在访问方法，

118
00:04:05,175 --> 00:04:06,090
0,105 105,285 285,510 510,735 735,915
in this middle layer here,

119
00:04:06,090 --> 00:04:07,560
0,105 105,315 315,555 555,830 1210,1470
in the Access Methods,| and
|现在我们将开始讨论，

120
00:04:07,560 --> 00:04:08,235
0,135 135,315 315,360 360,480 480,675
now we're going start talking

121
00:04:08,235 --> 00:04:09,255
0,210 210,390 390,495 495,720 720,1020
about| how do we construct
|如何构建执行引擎，

122
00:04:09,255 --> 00:04:11,085
0,305 415,750 750,1085 1375,1740 1740,1830
the execution engine,| that's going
|负责执行这些查询。

123
00:04:11,085 --> 00:04:13,110
0,75 75,225 225,540 540,935 1615,2025
to be responsible for executing

124
00:04:13,110 --> 00:04:14,745
0,180 180,650 1120,1380 1380,1485 1485,1635
these queries.| And so the
|访问方法是访问数据的机制，

125
00:04:14,745 --> 00:04:15,435
0,180 180,360 360,510 510,600 600,690
access method is going to

126
00:04:15,435 --> 00:04:18,735
0,165 165,390 390,960 960,1265 2905,3300
be the mechanisms for accessing

127
00:04:18,735 --> 00:04:20,055
0,135 135,395 925,1170 1170,1245 1245,1320
the data,| and it could
|它可以通过索引或通过表本身，

128
00:04:20,055 --> 00:04:21,360
0,135 135,345 345,630 630,975 975,1305
either be through an index

129
00:04:21,360 --> 00:04:23,270
0,350 370,770 970,1245 1245,1515 1515,1910
or through the tables themselves|
|

130
00:04:23,530 --> 00:04:25,560
0,400 480,785 785,995 995,1600
and potentially other mechanisms.|
也可以通过其他机制。|

131
00:04:25,870 --> 00:04:27,080
0,305 305,485 485,665 665,890 890,1210
So to do that, we
要做到这个，我们需要讨论，

132
00:04:27,280 --> 00:04:27,945
0,245 245,335 335,440 440,560 560,665
need to talk about| what
|我们将在系统的这一部分拥有什么样的数据结构，

133
00:04:27,945 --> 00:04:28,905
0,90 90,210 210,450 450,765 765,960
kind of data structures we

134
00:04:28,905 --> 00:04:31,725
0,105 105,365 2275,2580 2580,2730 2730,2820
would have, this part of

135
00:04:31,725 --> 00:04:34,155
0,120 120,395 1795,2055 2055,2205 2205,2430
the system,| and so this
|所以这节课将是哈希表，

136
00:04:34,155 --> 00:04:35,040
0,255 255,420 420,495 495,615 615,885
class will be on hash

137
00:04:35,040 --> 00:04:37,725
0,260 610,870 870,975 975,1080 1080,2685
tables,| which is an unordered
|这是一种无序数据结构，

138
00:04:37,725 --> 00:04:39,255
0,165 165,485 805,1080 1080,1275 1275,1530
data structure,| and then we'll
|然后我们将在整个下周讨论树形数据结构，

139
00:04:39,255 --> 00:04:40,725
0,275 655,945 945,1080 1080,1245 1245,1470
spend all of next week

140
00:04:40,725 --> 00:04:42,050
0,270 270,585 585,810 810,1005 1005,1325
talking about tree data structures,|
|

141
00:04:42,460 --> 00:04:43,700
0,380 380,620 620,740 740,845 845,1240
which will give you ordering,
它会给你排序，给你自己的键排序。

142
00:04:44,620 --> 00:04:45,450
0,260 260,380 380,665 665,710 710,830
give you ordering your own

143
00:04:45,450 --> 00:04:46,300
0,290
keys.|
|

144
00:04:46,490 --> 00:04:47,665
0,275 275,365 365,470 470,700 810,1175
And so we're just slowly
所以，我们是在慢慢地积累，

145
00:04:47,665 --> 00:04:49,105
0,270 270,575 895,1185 1185,1320 1320,1440
building up,| making our way
|通过我们的方式达到顶端，

146
00:04:49,105 --> 00:04:49,810
0,120 120,210 210,345 345,510 510,705
to the top| to actually
|为我们的查询产生结果。

147
00:04:49,810 --> 00:04:52,170
0,240 240,560 1270,1605 1605,1875 1875,2360
produce results for our queries.|
|

148
00:04:54,160 --> 00:04:55,420
0,400
So,
所以，我的意思是，

149
00:04:55,550 --> 00:04:56,455
0,245 245,380 380,590 590,785 785,905
I mean, it goes with

150
00:04:56,455 --> 00:04:57,265
0,105 105,240 240,420 420,630 630,810
sort out saying,| I'm assuming
|我假设这里的每个人都学习了数据结构课程或算法课程，

151
00:04:57,265 --> 00:04:57,895
0,195 195,285 285,360 360,495 495,630
everyone here is taken a

152
00:04:57,895 --> 00:04:59,080
0,150 150,375 375,615 615,885 885,1185
data structure class or algorithms

153
00:04:59,080 --> 00:05:00,415
0,290 520,870 870,1125 1125,1275 1275,1335
class,| data structures are going
|数据结构将在整个系统中使用，

154
00:05:00,415 --> 00:05:01,320
0,45 45,105 105,300 300,585 585,905
to be used all throughout

155
00:05:01,700 --> 00:05:03,070
0,290 290,580 870,1100 1100,1250 1250,1370
the system,| and we've already
|到目前为止，我们已经在某些方面涵盖了系统的一些部分，

156
00:05:03,070 --> 00:05:04,140
0,180 180,345 345,480 480,705 705,1070
covered in some ways and

157
00:05:04,160 --> 00:05:05,140
0,400 450,710 710,830 830,920 920,980
some, some parts of the

158
00:05:05,140 --> 00:05:05,920
0,150 150,345 345,495 495,645 645,780
system so far| are where
|我们将在哪里使用这些东西。

159
00:05:05,920 --> 00:05:06,580
0,165 165,210 210,270 270,390 390,660
we're going to use these,

160
00:05:06,580 --> 00:05:08,875
0,270 270,560 1750,2040 2040,2220 2220,2295
these things.| But there be
|但还有其他方面的原因，

161
00:05:08,875 --> 00:05:10,375
0,245 685,960 960,1080 1080,1275 1275,1500
other parts of it,| we
|我们需要有高性能，安全和正确的数据结构，

162
00:05:10,375 --> 00:05:12,000
0,135 135,255 255,515 895,1260 1260,1625
need to have high performance,

163
00:05:12,230 --> 00:05:13,740
0,320 320,605 605,970
safe and correct

164
00:05:13,750 --> 00:05:16,040
0,335 335,670 840,1175 1175,1510 1890,2290
data structures| to represent state
|来表示系统状态或系统数据。

165
00:05:16,090 --> 00:05:16,905
0,275 275,395 395,545 545,710 710,815
of the system or the

166
00:05:16,905 --> 00:05:18,220
0,135 135,255 255,375 375,665
data of the system.|
|

167
00:05:18,410 --> 00:05:19,375
0,290 290,515 515,680 680,860 860,965
So we've already seen how
我们已经了解了如何将其用于内部元数据，

168
00:05:19,375 --> 00:05:19,990
0,90 90,180 180,300 300,450 450,615
we can use this for

169
00:05:19,990 --> 00:05:21,880
0,195 195,860 1360,1605 1605,1740 1740,1890
internal metadata,| we talked about
|我们谈到了页目录或页表，

170
00:05:21,880 --> 00:05:23,050
0,135 135,360 360,870 870,1050 1050,1170
the page directory or the

171
00:05:23,050 --> 00:05:25,090
0,210 210,560 1510,1860 1860,1965 1965,2040
page table,| that's more or
|这或多或少是一个哈希表，

172
00:05:25,090 --> 00:05:25,945
0,105 105,225 225,450 450,630 630,855
less a hash table| being
|用于将页面 ID 映射到磁盘上的某个位置或内存中的某个位置。

173
00:05:25,945 --> 00:05:27,610
0,225 225,405 405,665 925,1215 1215,1665
used to map page IDs

174
00:05:27,610 --> 00:05:28,840
0,225 225,510 510,750 750,915 915,1230
to some location on disk

175
00:05:28,840 --> 00:05:31,050
0,90 90,300 300,650 1630,1920 1920,2210
or some location in memory.|
|

176
00:05:31,980 --> 00:05:33,080
0,245 245,365 365,620 620,890 890,1100
We could use the data
我们可以将数据结构用于表本身的核心存储，

177
00:05:33,080 --> 00:05:34,355
0,270 270,495 495,660 660,915 915,1275
structures for the core storage

178
00:05:34,355 --> 00:05:36,335
0,255 255,375 375,635 655,1055 1675,1980
of the tables themselves,| remember,
|我们谈到了索引组织的表，

179
00:05:36,335 --> 00:05:38,315
0,165 165,375 375,725 775,1175 1675,1980
we talked about the the

180
00:05:38,315 --> 00:05:40,000
0,270 270,525 525,815 925,1305 1305,1685
{index-organized -} tables,| where the
|其中 tuple 本身将位于 B+ 树的叶节点中，

181
00:05:40,350 --> 00:05:41,615
0,290 290,680 680,980 980,1175 1175,1265
actual tuples themselves would be

182
00:05:41,615 --> 00:05:42,590
0,90 90,210 210,405 405,780 780,975
in the leaf nodes of

183
00:05:42,590 --> 00:05:44,000
0,180 180,315 315,495 495,800 1180,1410
the {B+ -} tree,| so
|所以，你可以将表直接表示在数据结构中，

184
00:05:44,000 --> 00:05:44,855
0,75 75,195 195,420 420,645 645,855
you could have your tables

185
00:05:44,855 --> 00:05:46,460
0,195 195,315 315,575 715,1115 1255,1605
actually just be represented directly

186
00:05:46,460 --> 00:05:47,680
0,240 240,480 480,690 690,885 885,1220
in in a data structure|
|

187
00:05:48,060 --> 00:05:50,200
0,365 365,680 680,1390 1590,1865 1865,2140
rather than unordered [] files.|
而不是无序的[]文件中。|

188
00:05:51,280 --> 00:05:52,065
0,245 245,395 395,545 545,650 650,785
We could also use these
我们还可以将这些数据结构用于查询执行，

189
00:05:52,065 --> 00:05:54,140
0,195 195,515 595,995 1285,1695 1695,2075
data structures for query execution|
|

190
00:05:54,160 --> 00:05:56,150
0,400 450,845 845,1490 1490,1670 1670,1990
to generate ephemeral or temporary
以生成临时数据集合，

191
00:05:56,770 --> 00:05:58,830
0,400 810,1190 1190,1325 1325,1600 1800,2060
{} collections of data,| that
|允许更高效地执行查询，

192
00:05:58,830 --> 00:05:59,955
0,180 180,420 420,645 645,975 975,1125
allows to execute queries more

193
00:05:59,955 --> 00:06:01,920
0,515 955,1215 1215,1365 1365,1655 1705,1965
efficiently,| this is basically how
|这就是我们将如何实现 hash join 很快，

194
00:06:01,920 --> 00:06:02,910
0,165 165,210 210,405 405,705 705,990
we're going to implement hash

195
00:06:02,910 --> 00:06:04,530
0,240 240,405 405,705 705,1100 1240,1620
join very fast| or how
|或者如何使用 hash join 实现 join 很快，

196
00:06:04,530 --> 00:06:05,625
0,285 285,555 555,675 675,870 870,1095
implement joins very quickly using

197
00:06:05,625 --> 00:06:06,825
0,255 255,635 715,945 945,1065 1065,1200
hash joins,| so we build
|我们动态构建一个哈希表，

198
00:06:06,825 --> 00:06:07,620
0,135 135,375 375,525 525,660 660,795
a hash table on the

199
00:06:07,620 --> 00:06:09,630
0,290 610,1095 1095,1335 1335,1680 1680,2010
fly,| populate with the data
|使用表或扫描中的数据进行填充，

200
00:06:09,630 --> 00:06:10,910
0,225 225,360 360,555 555,795 795,1280
from the tables or scanning,|
|

201
00:06:11,320 --> 00:06:12,615
0,320 320,515 515,790 840,1085 1085,1295
do the join and then
执行 join ，然后丢弃哈希表，

202
00:06:12,615 --> 00:06:13,760
0,270 270,420 420,615 615,810 810,1145
throw the hash table away,|
|

203
00:06:15,250 --> 00:06:16,170
0,245 245,395 395,620 620,770 770,920
so just because, you know
所以，因为们构建哈希[]，

204
00:06:16,170 --> 00:06:16,830
0,210 210,330 330,525 525,600 600,660
we're building hash [],| it
|不意味着它会长期存在，

205
00:06:16,830 --> 00:06:17,355
0,150 150,240 240,390 390,450 450,525
doesn't mean it's going to

206
00:06:17,355 --> 00:06:18,200
0,120 120,285 285,450 450,585 585,845
stick around for a long,

207
00:06:18,250 --> 00:06:19,820
0,245 245,380 380,670 1050,1310 1310,1570
a long time,| and then
|然后，你最熟悉的可能是，

208
00:06:19,900 --> 00:06:20,610
0,275 275,395 395,485 485,605 605,710
probably the one you're most

209
00:06:20,610 --> 00:06:22,170
0,195 195,465 465,720 720,1010 1240,1560
familiar with is| using these
|将这些数据结构用于表索引，

210
00:06:22,170 --> 00:06:24,080
0,240 240,560 610,1010 1060,1395 1395,1910
data structures for table indexes,|
|

211
00:06:24,430 --> 00:06:25,520
0,245 245,335 335,485 485,740 740,1090
when you call CREATE INDEX,|
当调用 CREATE INDEX 时，|

212
00:06:25,540 --> 00:06:26,690
0,380 380,590 590,770 770,890 890,1150
that's essentially going to create
实质上将创建一个这样的数据结构，

213
00:06:26,980 --> 00:06:27,860
0,245 245,320 320,395 395,560 560,880
one of these data structures,|
|

214
00:06:28,600 --> 00:06:30,100
0,320 820,1245 1245,1320 1320,1395 1395,1500
and populate it with the
然后用键填充它，

215
00:06:30,100 --> 00:06:31,150
0,195 195,405 405,585 585,795 795,1050
keys| and map them to
|并将它们映射到 tuple ，

216
00:06:31,150 --> 00:06:32,080
0,225 225,570 570,750 750,825 825,930
the tuples,| so you do
|这样你就可以更快地进行查找，

217
00:06:32,080 --> 00:06:33,805
0,210 210,770 850,1110 1110,1260 1260,1725
faster lookups,| like a glossary
|就像教科书中的词汇表一样。

218
00:06:33,805 --> 00:06:35,240
0,285 285,525 525,995
in a textbook.|
|

219
00:06:36,050 --> 00:06:38,785
0,290 290,440 440,650 650,940 2370,2735
So again, we'll see, we'll
所以，我们将看到这些数据结构被使用，

220
00:06:38,785 --> 00:06:39,850
0,210 210,450 450,645 645,855 855,1065
see these data structures being

221
00:06:39,850 --> 00:06:41,050
0,290 550,855 855,990 990,1095 1095,1200
used| throughout the rest of
|在本学期余下的时间里，

222
00:06:41,050 --> 00:06:42,715
0,90 90,390 390,770 880,1215 1215,1665
the semester| in different scenarios
|在这个列表中涵盖的不同场景中。

223
00:06:42,715 --> 00:06:43,735
0,105 105,210 210,485 655,900 900,1020
that are covered in this

224
00:06:43,735 --> 00:06:44,720
0,165 165,455
list here.|
|

225
00:06:45,820 --> 00:06:46,560
0,275 275,440 440,560 560,620 620,740
So now what do we
那么，当我们设计数据结构时，我们关心的是什么，

226
00:06:46,560 --> 00:06:47,535
0,210 210,435 435,585 585,750 750,975
care about when we design

227
00:06:47,535 --> 00:06:48,555
0,150 150,300 300,605 655,915 915,1020
our data structures,| what are
|我们需要认识到什么，

228
00:06:48,555 --> 00:06:49,170
0,105 105,270 270,420 420,525 525,615
the things we need to

229
00:06:49,170 --> 00:06:50,550
0,105 105,525 525,770 1000,1230 1230,1380
be cognitive of,| to make
|以确保我们拥有一个有效的数据库系统，

230
00:06:50,550 --> 00:06:51,810
0,225 225,465 465,690 690,960 960,1260
sure that we have an

231
00:06:51,810 --> 00:06:53,775
0,320 460,795 795,1130 1360,1740 1740,1965
efficient database system,| that actually
|而且也是正确的，这是非常重要的。

232
00:06:53,775 --> 00:06:55,380
0,195 195,545 625,1025 1255,1500 1500,1605
is also correct, which is

233
00:06:55,380 --> 00:06:56,420
0,165 165,470
very important,

234
00:06:56,460 --> 00:06:57,890
0,400 870,1115 1115,1205 1205,1325 1325,1430
right.| So the first thing
|所以你要担心的第一件事是，

235
00:06:57,890 --> 00:06:58,460
0,105 105,150 150,225 225,360 360,570
you've got to worry about

236
00:06:58,460 --> 00:06:59,630
0,320 550,810 810,1005 1005,1110 1110,1170
is,| how we're actually going
|我们如何组织数据本身，

237
00:06:59,630 --> 00:07:02,045
0,180 180,590 700,1100 1390,1790 2080,2415
to organize the, the, the

238
00:07:02,045 --> 00:07:03,545
0,240 240,480 480,815 1015,1290 1290,1500
data structure itself,| in either
|无论在内存中，

239
00:07:03,545 --> 00:07:05,770
0,225 225,515 925,1290 1290,1655 1825,2225
in memory| or pages that
|或者在内存中但由缓冲池中的磁盘支持的页面。

240
00:07:06,090 --> 00:07:06,950
0,290 290,410 410,500 500,665 665,860
will be in memory but

241
00:07:06,950 --> 00:07:08,525
0,330 330,590 970,1260 1260,1500 1500,1575
backed by by disk in

242
00:07:08,525 --> 00:07:09,680
0,90 90,315 315,575
the buffer pool.|
|

243
00:07:09,680 --> 00:07:10,280
0,135 135,255 255,405 405,525 525,600
And remember, I said in
我在一开始就说过，

244
00:07:10,280 --> 00:07:11,120
0,120 120,375 375,600 600,720 720,840
the beginning,| we want to
|我们希望在如何实现我们的系统做出设计选择，

245
00:07:11,120 --> 00:07:13,325
0,225 225,540 540,890 1270,1670 1870,2205
make design choices in how

246
00:07:13,325 --> 00:07:15,950
0,335 385,720 720,945 945,1235 2305,2625
we implement our system,| if
|如果我们知道它将由磁盘上的页面支持，

247
00:07:15,950 --> 00:07:16,625
0,195 195,360 360,570 570,630 630,675
we know it's going to

248
00:07:16,625 --> 00:07:17,870
0,90 90,360 360,635 715,1035 1035,1245
be backed by pages on

249
00:07:17,870 --> 00:07:19,835
0,530 640,975 975,1215 1215,1800 1800,1965
disk,| that we maximize the
|我们就会最大限度地增加顺序 I/O 的数量。

250
00:07:19,835 --> 00:07:21,400
0,105 105,225 225,510 510,905
amount of sequential I/O,|
|

251
00:07:21,400 --> 00:07:22,375
0,195 195,360 360,615 615,750 750,975
So maybe we'll lay out
所以，我们可能会以这样一种方式布局页面，

252
00:07:22,375 --> 00:07:23,560
0,335 505,840 840,1020 1020,1110 1110,1185
the pages in such a

253
00:07:23,560 --> 00:07:24,175
0,75 75,165 165,315 315,495 495,615
way,| the data structure, in
|这种方式的数据结构，

254
00:07:24,175 --> 00:07:25,225
0,90 90,195 195,375 375,695 775,1050
such a way,| that we
|这样我们就可以通过多个页面读取和写入数据，

255
00:07:25,225 --> 00:07:26,455
0,225 225,555 555,870 870,1035 1035,1230
have long strides of data

256
00:07:26,455 --> 00:07:27,340
0,195 195,315 315,450 450,570 570,885
that we can read {and,write}

257
00:07:27,340 --> 00:07:28,810
0,210 210,420 420,770 1120,1365 1365,1470
through multiple pages| instead of
|而不是进行随机 I/O 。

258
00:07:28,810 --> 00:07:31,060
0,260 940,1260 1260,1440 1440,1700
doing random {I/O -}.|
|

259
00:07:32,170 --> 00:07:32,970
0,260 260,380 380,530 530,635 635,800
And then we'll talk about
然后我们将讨论如何使我们的数据结构是线程安全的，

260
00:07:32,970 --> 00:07:33,795
0,150 150,240 240,375 375,555 555,825
how do we actually make

261
00:07:33,795 --> 00:07:35,270
0,300 300,525 525,840 840,1155 1155,1475
our data structures thread safe,|
|

262
00:07:35,740 --> 00:07:36,705
0,260 260,395 395,515 515,665 665,965
and so for this class,
在这节课上，我们不用担心这个问题，

263
00:07:36,705 --> 00:07:37,785
0,255 255,435 435,660 660,945 945,1080
we won't really worry about

264
00:07:37,785 --> 00:07:38,235
0,75 75,150 150,300 300,375 375,450
it,| but we'll spend a
|但我们会在下周的周四或周三花一整节课的时间，

265
00:07:38,235 --> 00:07:40,605
0,245 1465,1815 1815,2070 2070,2235 2235,2370
whole lecture next week on

266
00:07:40,605 --> 00:07:42,380
0,240 240,510 510,815 1195,1485 1485,1775
Thursday or Wednesday next week,|
|

267
00:07:42,610 --> 00:07:43,580
0,305 305,500 500,650 650,740 740,970
talk about how do we
讨论如何确保数据结构是正确的，

268
00:07:43,930 --> 00:07:45,135
0,350 350,620 620,830 830,995 995,1205
make sure that the data

269
00:07:45,135 --> 00:07:47,235
0,335 385,785 1285,1635 1635,1875 1875,2100
structure is, is correct in

270
00:07:47,235 --> 00:07:48,765
0,335 595,900 900,1065 1065,1230 1230,1530
[sound],| if we have multiple
|如果我们有多个工作线程或进程进来，

271
00:07:48,765 --> 00:07:51,135
0,375 375,995 1105,1380 1380,1655 2065,2370
worker threads or processes coming

272
00:07:51,135 --> 00:07:52,860
0,270 270,600 600,915 915,1265 1465,1725
in| and reading, writing or
|同时读取，写入或修改数据结构。

273
00:07:52,860 --> 00:07:54,645
0,405 405,540 540,705 705,1040 1420,1785
modifying the data structure at

274
00:07:54,645 --> 00:07:55,860
0,240 240,375 375,540 540,845
at the same time,

275
00:07:56,100 --> 00:07:57,800
0,400 990,1235 1235,1370 1370,1565 1565,1700
right.| And this last one
|最后一个比较棘手，

276
00:07:57,800 --> 00:07:58,520
0,75 75,150 150,210 210,330 330,720
is going to be tricky,|
|

277
00:07:58,520 --> 00:08:00,005
0,350 910,1200 1200,1260 1260,1335 1335,1485
because we're going to care
因为我们要关注数据结构中两种类型的正确性，

278
00:08:00,005 --> 00:08:01,760
0,150 150,300 300,605 1105,1455 1455,1755
sort of two kinds of

279
00:08:01,760 --> 00:08:03,430
0,530 790,1050 1050,1155 1155,1335 1335,1670
correctness in our data structures,|
|

280
00:08:03,840 --> 00:08:04,370
0,245 245,335 335,410 410,455 455,530
if you want to make
如果你想让它们成为多线程的，

281
00:08:04,370 --> 00:08:06,110
0,105 105,285 285,770 970,1470 1470,1740
them multi threaded,| there's obviously
|很明显，物理的正确性，

282
00:08:06,110 --> 00:08:08,375
0,165 165,440 730,1245 1245,1550 1900,2265
the physical correctness of| making
|确保我们没有一个无处可去的指针，

283
00:08:08,375 --> 00:08:09,080
0,255 255,390 390,525 525,585 585,705
sure we don't have a

284
00:08:09,080 --> 00:08:10,595
0,440 490,750 750,1005 1005,1320 1320,1515
pointer that goes nowhere| or
|或者一个不存在的页面 ID ，

285
00:08:10,595 --> 00:08:11,705
0,150 150,315 315,540 540,810 810,1110
a page ID that that

286
00:08:11,705 --> 00:08:13,670
0,270 270,615 615,935 1405,1755 1755,1965
that doesn't exist, right,| if
|如果我们有一个线程访问一个页面，

287
00:08:13,670 --> 00:08:15,280
0,105 105,285 285,620 880,1245 1245,1610
we have one one thread

288
00:08:15,750 --> 00:08:17,270
0,365 365,485 485,760 1080,1370 1370,1520
accessing a page,| another thread
|另一个线程正在更新它，

289
00:08:17,270 --> 00:08:18,140
0,180 180,465 465,570 570,690 690,870
is updating it| and that
|并且访问线程读取了这个写的东西，

290
00:08:18,140 --> 00:08:19,925
0,255 255,690 690,1070 1270,1635 1635,1785
the accessing thread reads something

291
00:08:19,925 --> 00:08:21,220
0,165 165,255 255,390 390,695
that the guy wrote,|
|

292
00:08:21,220 --> 00:08:22,360
0,150 150,255 255,540 540,800 910,1140
but it hasn't been, you
但它还没有安全地提交或它没有正确保存，

293
00:08:22,360 --> 00:08:23,680
0,225 225,585 585,830 970,1215 1215,1320
know, it's not, you know,

294
00:08:23,680 --> 00:08:24,520
0,210 210,465 465,630 630,720 720,840
safely committed yet or it's

295
00:08:24,520 --> 00:08:25,840
0,150 150,390 390,710 940,1200 1200,1320
not saved correctly,| then we
|然后我们可能会结束到一个无处可去的指针，

296
00:08:25,840 --> 00:08:26,725
0,150 150,300 300,495 495,675 675,885
may end up, you know,

297
00:08:26,725 --> 00:08:27,930
0,285 285,450 450,705 705,885 885,1205
falling a pointer to nowhere|
|

298
00:08:28,100 --> 00:08:29,160
0,290 290,440 440,590 590,770 770,1060
and the system would crash,|
系统将崩溃，|

299
00:08:29,240 --> 00:08:30,145
0,230 230,395 395,575 575,710 710,905
so we have to avoid
所以我们必须避免这种情况。

300
00:08:30,145 --> 00:08:31,080
0,305
that.|
|

301
00:08:31,330 --> 00:08:32,460
0,260 260,395 395,635 635,905 905,1130
But then there's another kind
但是还有另一种正确性，

302
00:08:32,460 --> 00:08:33,360
0,135 135,480 480,600 600,750 750,900
of correctness,| that we'll get
|我们将在期中考试后进行讨论，

303
00:08:33,360 --> 00:08:35,550
0,195 195,405 405,720 720,1310 1900,2190
to after the midterm,| at
|在逻辑层面上，

304
00:08:35,550 --> 00:08:36,620
0,135 135,225 225,345 345,795 795,1070
sort of the logical level|
|

305
00:08:36,970 --> 00:08:39,105
0,245 245,425 425,760 960,1360 1770,2135
to make sure that if
以确保如果我们对数据结构进行更改，

306
00:08:39,105 --> 00:08:40,950
0,330 330,675 675,1055 1195,1575 1575,1845
we make changes to our

307
00:08:40,950 --> 00:08:43,095
0,225 225,560 940,1340 1600,1890 1890,2145
data structures,| that our own
|我们自己的线程可以看到这些更改，

308
00:08:43,095 --> 00:08:44,270
0,270 270,480 480,660 660,855 855,1175
thread can see those changes,|
|

309
00:08:44,890 --> 00:08:46,515
0,400 720,980 980,1205 1205,1475 1475,1625
that it looks correct to
它看起来是正确的，

310
00:08:46,515 --> 00:08:48,075
0,245 265,570 570,875 955,1275 1275,1560
it,| meaning like if my
|这意味着如果我的线程从索引中删除了一个键，

311
00:08:48,075 --> 00:08:49,185
0,300 300,690 690,810 810,975 975,1110
thread deletes a key from

312
00:08:49,185 --> 00:08:50,520
0,180 180,515 805,1050 1050,1170 1170,1335
an index,| if I then
|如果我回到同一个线程，

313
00:08:50,520 --> 00:08:51,330
0,165 165,345 345,480 480,600 600,810
go back in that same

314
00:08:51,330 --> 00:08:52,485
0,195 195,405 405,740 820,1065 1065,1155
thread| and read, try to
|尝试读取该索引中的键，

315
00:08:52,485 --> 00:08:53,430
0,135 135,345 345,585 585,750 750,945
read that key in that

316
00:08:53,430 --> 00:08:55,065
0,350 670,975 975,1275 1275,1470 1470,1635
index,| I shouldn't still see
|我不应该还看到它，

317
00:08:55,065 --> 00:08:55,620
0,245
it,|
|

318
00:08:56,020 --> 00:08:57,380
0,320 320,575 575,845 845,1070 1070,1360
the bits may still physically
这些比特可能还在，

319
00:08:57,400 --> 00:08:59,295
0,305 305,610 900,1220 1220,1540 1650,1895
be there, right,| because we
|因为我们还没有运行垃圾收集，

320
00:08:59,295 --> 00:09:00,210
0,180 180,255 255,375 375,705 705,915
haven't to run garbage collection|
|

321
00:09:00,210 --> 00:09:01,155
0,210 210,390 390,570 570,705 705,945
and maybe there's a little
也许有一个小标记，表明这个东西已经被删除了，

322
00:09:01,155 --> 00:09:02,040
0,240 240,405 405,540 540,690 690,885
flag that says this thing's

323
00:09:02,040 --> 00:09:03,660
0,165 165,680 760,1050 1050,1320 1320,1620
been deleted,| so physically it's
|所以物理上它还在，但逻辑上它不在了，

324
00:09:03,660 --> 00:09:04,725
0,135 135,285 285,435 435,900 900,1065
still there, but logically it's

325
00:09:04,725 --> 00:09:05,640
0,245 355,585 585,660 660,765 765,915
not,| we need to make
|我们要确保我们不会看到不该看到的东西。

326
00:09:05,640 --> 00:09:06,735
0,165 165,330 330,600 600,945 945,1095
sure that we don't see

327
00:09:06,735 --> 00:09:07,610
0,150 150,300 300,480 480,600 600,875
things we shouldn't be seeing,

328
00:09:08,150 --> 00:09:09,925
0,400 810,1130 1130,1295 1295,1400 1400,1775
right.| Again, so we won't
|再说一次，本周我们不会太关注并发的事情，

329
00:09:09,925 --> 00:09:11,170
0,345 345,555 555,705 705,825 825,1245
focus too much on concurrency

330
00:09:11,170 --> 00:09:13,350
0,350 400,720 720,1040 1240,1640 1780,2180
in this week,| {} but
|但我们将在下周更详细地讨论这一点，

331
00:09:13,430 --> 00:09:14,665
0,305 305,455 455,760 780,1040 1040,1235
we'll cover this in more

332
00:09:14,665 --> 00:09:15,655
0,210 210,375 375,525 525,765 765,990
detail next week| and this
|当我们讨论并发控制时，这将是一个大问题，

333
00:09:15,655 --> 00:09:16,945
0,90 90,335 535,825 825,1005 1005,1290
will be a big issue

334
00:09:16,945 --> 00:09:17,965
0,285 285,495 495,675 675,825 825,1020
also too when we talk

335
00:09:17,965 --> 00:09:20,005
0,305 535,1035 1035,1295 1435,1815 1815,2040
about concurrency control,| at again
|在逻辑层面上，使用事务，

336
00:09:20,005 --> 00:09:20,830
0,90 90,195 195,495 495,615 615,825
at the logical level, having

337
00:09:20,830 --> 00:09:22,890
0,320 1060,1305 1305,1455 1455,1710 1710,2060
transactions| and making sure we
|并确保我们提供 ACID 保证，

338
00:09:22,940 --> 00:09:24,880
0,395 395,680 680,935 935,1570 1680,1940
we provide ACID guarantees,| but
|但是，这将在期中之后。

339
00:09:24,880 --> 00:09:25,900
0,165 165,690 690,765 765,900 900,1020
again, that'll be after the

340
00:09:25,900 --> 00:09:26,660
0,105 105,380
{midterm -}.|
|

341
00:09:28,240 --> 00:09:30,330
0,365 365,730 1350,1775 1775,1895 1895,2090
{All,right}, so today's class,| we're
好的，所以今天的课程，|我们将重点放在哈希表上，

342
00:09:30,330 --> 00:09:32,115
0,180 180,525 525,870 870,1130 1510,1785
focusing on hash tables| and
|因为它是一个低级别的构建块，

343
00:09:32,115 --> 00:09:34,365
0,275 445,845 1705,2040 2040,2115 2115,2250
again, because it's a low

344
00:09:34,365 --> 00:09:35,490
0,195 195,450 450,690 690,930 930,1125
level building blocks| that we
|我们可以在系统的其余部分中重复使用，

345
00:09:35,490 --> 00:09:37,395
0,120 120,540 540,920 1540,1785 1785,1905
can reuse throughout the rest

346
00:09:37,395 --> 00:09:38,940
0,105 105,195 195,455 1045,1335 1335,1545
of the system,| and again,
|再次，这对这里的任何人来说都不是什么新闻，

347
00:09:38,940 --> 00:09:40,110
0,210 210,465 465,705 705,990 990,1170
this shouldn't be news to

348
00:09:40,110 --> 00:09:41,340
0,150 150,410 610,870 870,1110 1110,1230
anyone here,| a hash table
|哈希表只是一个关联数组，

349
00:09:41,340 --> 00:09:42,075
0,150 150,330 330,465 465,555 555,735
is just going to be

350
00:09:42,075 --> 00:09:43,740
0,240 240,525 525,905 1165,1470 1470,1665
an associated array,| that can
|可以将键映射到值。

351
00:09:43,740 --> 00:09:46,040
0,285 285,680 1060,1305 1305,1550
map keys to values.|
|

352
00:09:46,560 --> 00:09:47,560
0,245 245,395 395,590 590,740 740,1000
You guys, okay, {you,guys} good?|
你们还好吗？|

353
00:09:50,190 --> 00:09:51,460
0,275 275,550
Was that?|
那是什么？|

354
00:09:52,640 --> 00:09:55,470
0,260 260,760 2130,2405 2405,2555 2555,2830

355
00:10:01,910 --> 00:10:02,710
0,245 245,320 320,410 410,575 575,800

356
00:10:02,710 --> 00:10:04,560
0,150 150,420 420,710

357
00:10:04,560 --> 00:10:05,760
0,255 255,405 405,615 615,860 910,1200

358
00:10:05,760 --> 00:10:06,480
0,150 150,270 270,420 420,585 585,720

359
00:10:06,480 --> 00:10:09,180
0,120 120,375 375,770 1540,1940 2440,2700

360
00:10:09,180 --> 00:10:11,220
0,105 105,255 255,710

361
00:10:11,320 --> 00:10:12,090
0,245 245,380 380,500 500,665 665,770
The way the hash table
哈希表的工作方式是，

362
00:10:12,090 --> 00:10:12,705
0,90 90,150 150,225 225,405 405,615
is going to work is

363
00:10:12,705 --> 00:10:13,670
0,210 210,480 480,570 570,690 690,965
that,| there's going to be,
|它将是键到值的映射，

364
00:10:14,410 --> 00:10:15,195
0,365 365,470 470,530 530,620 620,785
it's going to be this

365
00:10:15,195 --> 00:10:16,280
0,390 390,555 555,720 720,840 840,1085
mapping from keys to values|
|

366
00:10:16,660 --> 00:10:17,510
0,275 275,425 425,470 470,575 575,850
and we're going to use
我们将使用哈希函数，

367
00:10:17,590 --> 00:10:19,080
0,400 480,905 905,1130 1130,1430 1430,1490
a hash function,| that's going
|它将允许我们计算数组中的一些偏移量，

368
00:10:19,080 --> 00:10:20,400
0,90 90,240 240,435 435,740 970,1320
to allow us to essentially

369
00:10:20,400 --> 00:10:22,485
0,560 640,1040 1240,1575 1575,1845 1845,2085
compute some offset within an

370
00:10:22,485 --> 00:10:26,330
0,305 1765,2040 2040,2315 3175,3585 3585,3845
array| and then it's basically
|然后基本上减少这个整型域的任意键，

371
00:10:26,710 --> 00:10:28,470
0,380 380,740 740,1120 1140,1520 1520,1760
reducing down the, the an

372
00:10:28,470 --> 00:10:30,180
0,450 450,735 735,960 960,1215 1215,1710
arbitrary key to this integer

373
00:10:30,180 --> 00:10:31,380
0,260 520,795 795,930 930,1035 1035,1200
domain,| that we can then
|然后我们可以跳到哈希表中的某个位置，

374
00:10:31,380 --> 00:10:32,900
0,240 240,450 450,735 735,1125 1125,1520
jump to some, some location

375
00:10:32,920 --> 00:10:34,380
0,290 290,580 840,1205 1205,1310 1310,1460
in our hash table| to
|以找到我们寻找的东西。

376
00:10:34,380 --> 00:10:35,025
0,135 135,270 270,405 405,510 510,645
find the thing that we're

377
00:10:35,025 --> 00:10:35,900
0,165 165,515
looking for,

378
00:10:35,940 --> 00:10:37,080
0,400
right.|
|

379
00:10:37,120 --> 00:10:39,015
0,395 395,790 1260,1535 1535,1745 1745,1895
And the, this hash function
这个哈希函数必须能够接受任何可能的键，

380
00:10:39,015 --> 00:10:39,405
0,150 150,210 210,255 255,315 315,390
has to be able to

381
00:10:39,405 --> 00:10:40,890
0,135 135,425 505,900 900,1245 1245,1485
take any possible key,| because
|因为，考虑到你可以在数据库系统中定义的任何列类型，

382
00:10:40,890 --> 00:10:41,775
0,180 180,315 315,405 405,570 570,885
again, think of any column

383
00:10:41,775 --> 00:10:42,855
0,285 285,420 420,585 585,870 870,1080
type you can define in

384
00:10:42,855 --> 00:10:44,535
0,105 105,300 300,635 1255,1500 1500,1680
your database system,| also any,
|还有任何我们在系统本身中拥有的内部元数据，

385
00:10:44,535 --> 00:10:45,920
0,285 285,555 555,1005 1005,1140 1140,1385
any internal metadata we have

386
00:10:45,940 --> 00:10:47,775
0,400 480,725 725,935 935,1300 1590,1835
in the system itself,| and
|我们需要能够，

387
00:10:47,775 --> 00:10:48,150
0,90 90,180 180,255 255,315 315,375
we need to be able

388
00:10:48,150 --> 00:10:49,485
0,75 75,285 285,650 850,1095 1095,1335
to take that,| you know,
|哈希函数需要把它降低到一个整数。

389
00:10:49,485 --> 00:10:50,400
0,330 330,465 465,615 615,765 765,915
hash function needs to reduce

390
00:10:50,400 --> 00:10:51,530
0,150 150,375 375,555 555,645 645,1130
that down to an integer.|
|

391
00:10:52,570 --> 00:10:53,565
0,245 245,365 365,650 650,815 815,995
So in hash table, the
所以在哈希表中，空间复杂性将大致为 O(n) ，

392
00:10:53,565 --> 00:10:54,735
0,225 225,780 780,960 960,1080 1080,1170
space complexity is going to

393
00:10:54,735 --> 00:10:56,420
0,245 385,735 735,960 960,1235 1285,1685
be roughly big n or

394
00:10:56,560 --> 00:10:58,440
0,245 245,335 335,580 930,1330 1560,1880
big O n,| because we're
|因为我们必须为我们想要的每个可能的键存储一个槽，

395
00:10:58,440 --> 00:10:59,175
0,45 45,105 105,240 240,435 435,735
going to have to store

396
00:10:59,175 --> 00:11:01,860
0,395 1165,1590 1590,1955 2245,2505 2505,2685
a slot for for every

397
00:11:01,860 --> 00:11:02,895
0,285 285,615 615,840 840,945 945,1035
possible key we want to

398
00:11:02,895 --> 00:11:03,720
0,245
have,

399
00:11:03,720 --> 00:11:05,700
0,290 940,1215 1215,1455 1455,1890 1890,1980
right,| the time complexity is
|时间复杂性很好，

400
00:11:05,700 --> 00:11:06,765
0,210 210,420 420,555 555,810 810,1065
nice,| because on average we're
|因为平均而言，我们只需要 O(1) 查找，

401
00:11:06,765 --> 00:11:07,290
0,30 30,90 90,195 195,345 345,525
going to get {O(1) -}

402
00:11:07,290 --> 00:11:09,120
0,410 760,1125 1125,1380 1380,1680 1680,1830
lookups,| meaning we hash a
|这意味着我们对一个键做哈希，跳转到这个哈希表数组中的某个位置，

403
00:11:09,120 --> 00:11:10,730
0,290 550,840 840,990 990,1230 1230,1610
key, jump to some location

404
00:11:10,810 --> 00:11:12,470
0,350 350,700 810,1130 1130,1325 1325,1660
in this hash table array|
|

405
00:11:12,730 --> 00:11:14,385
0,275 275,500 500,1190 1190,1505 1505,1655
and then ideally there the
然后理想地，在那里找到仍然在那里的东西。

406
00:11:14,385 --> 00:11:16,920
0,150 150,425 1285,1560 1560,1835
thing that still there.|
|

407
00:11:16,920 --> 00:11:18,540
0,105 105,225 225,345 345,590
Or just kill it,|
或者干脆杀了它，|

408
00:11:18,540 --> 00:11:19,540
0,350

409
00:11:19,970 --> 00:11:21,240
0,245 245,335 335,580
there you go.|
这就对了。|

410
00:11:21,420 --> 00:11:23,000
0,255 255,530 760,990 990,1260 1260,1580
All right, so that's two
好的，那么这学期就是两次击杀，这还不错。

411
00:11:23,050 --> 00:11:24,465
0,290 290,545 545,755 755,1060 1110,1415
kills per this semester, that's

412
00:11:24,465 --> 00:11:26,120
0,60 60,305
not bad.|
|

413
00:11:26,580 --> 00:11:28,655
0,400 840,1240 1500,1745 1745,1910 1910,2075
So again, an average is
再说一次，平均是 1 ，

414
00:11:28,655 --> 00:11:29,480
0,75 75,120 120,225 225,515 565,825
going to be 1,| because
|因为这就像是哈希，

415
00:11:29,480 --> 00:11:31,090
0,150 150,210 210,270 270,375 375,1610
it's going to be {like,hash},|
|

416
00:11:31,740 --> 00:11:32,825
0,260 260,395 395,670 690,1010 1010,1085
take your key, hash to
使用你的键，哈希到某个位置，

417
00:11:32,825 --> 00:11:33,935
0,180 180,480 480,705 705,900 900,1110
some location| and then you
|然后你找到一个东西，就是你要找的东西，

418
00:11:33,935 --> 00:11:35,045
0,165 165,315 315,575 685,975 975,1110
land a thing, exactly what

419
00:11:35,045 --> 00:11:36,220
0,135 135,285 285,605
you're looking for,|
|

420
00:11:36,320 --> 00:11:37,675
0,350 350,700 840,1100 1100,1220 1220,1355
worst case will be big
最坏的情况会是 O(n) ，

421
00:11:37,675 --> 00:11:39,700
0,165 165,455 655,1055
O n,| because,
|因为我们将不得不处理冲突，

422
00:11:39,860 --> 00:11:40,840
0,400 420,695 695,755 755,860 860,980
because we'll have to deal

423
00:11:40,840 --> 00:11:41,965
0,135 135,500 520,795 795,975 975,1125
with collisions,| it may be
|这可能是这样的情况，

424
00:11:41,965 --> 00:11:43,170
0,135 135,360 360,555 555,690 690,1205
the case,| that we hash
|我们对键的哈希在某个位置，

425
00:11:43,880 --> 00:11:45,310
0,305 305,610 660,995 995,1205 1205,1430
our key land in some

426
00:11:45,310 --> 00:11:46,345
0,350 370,630 630,750 750,885 885,1035
location| and then the thing
|然后我们要寻找的东西不在那里，

427
00:11:46,345 --> 00:11:47,005
0,150 150,270 270,420 420,510 510,660
we're looking for is not

428
00:11:47,005 --> 00:11:48,100
0,305 475,735 735,855 855,930 930,1095
there| and we got to
|我们必须扫描我们的哈希表，

429
00:11:48,100 --> 00:11:49,090
0,240 240,480 480,630 630,735 735,990
scan along on our hash

430
00:11:49,090 --> 00:11:50,485
0,260 730,1005 1005,1155 1155,1290 1290,1395
table,| we find the thing
|找到我们要找的东西，

431
00:11:50,485 --> 00:11:51,415
0,165 165,330 330,645 645,855 855,930
we're looking for| and it
|可能是哈希表中的所有槽都满了，

432
00:11:51,415 --> 00:11:52,090
0,120 120,240 240,345 345,510 510,675
may be the case that

433
00:11:52,090 --> 00:11:53,035
0,210 210,450 450,690 690,855 855,945
all the slots in our

434
00:11:53,035 --> 00:11:54,145
0,180 180,315 315,480 480,755 865,1110
hash table are full| and
|我们必须绕过一个又一个，

435
00:11:54,145 --> 00:11:54,930
0,75 75,150 150,255 255,450 450,785
we have to wrap around

436
00:11:54,980 --> 00:11:57,670
0,1910 1910,2090 2090,2315 2315,2480 2480,2690
basically one above the one|
|

437
00:11:57,670 --> 00:11:58,540
0,210 210,330 330,555 555,660 660,870
where we landed the hash
我们位于哈希函数上，

438
00:11:58,540 --> 00:11:59,575
0,260 490,735 735,825 825,930 930,1035
function,| but we had to
|但我们必须循环才能找到它。

439
00:11:59,575 --> 00:12:00,660
0,225 225,495 495,630 630,780 780,1085
loop around to find it,

440
00:12:01,070 --> 00:12:02,120
0,400
right.|
|

441
00:12:02,360 --> 00:12:03,190
0,275 275,395 395,500 500,665 665,830
And so the way you
所以你处理这个问题的方式，

442
00:12:03,190 --> 00:12:04,015
0,105 105,195 195,390 390,660 660,825
sort of handle this,| and
|我们会在接下来的过程中看到，

443
00:12:04,015 --> 00:12:04,495
0,135 135,195 195,270 270,360 360,480
we'll see as we go

444
00:12:04,495 --> 00:12:05,830
0,165 165,375 375,695 745,1110 1110,1335
along,| is you size the
|你将哈希表的大小调整为大约是你期望的键数量的 2n 。

445
00:12:05,830 --> 00:12:06,730
0,240 240,405 405,540 540,645 645,900
hash table to be roughly

446
00:12:06,730 --> 00:12:07,960
0,240 240,500 730,975 975,1095 1095,1230
{2n -} the number of

447
00:12:07,960 --> 00:12:09,280
0,150 150,375 375,710
keys you expect.|
|

448
00:12:09,280 --> 00:12:10,015
0,225 225,315 315,435 435,600 600,735
Now, you may say, okay,
现在，你可能会说，好吧， Andy ，

449
00:12:10,015 --> 00:12:10,690
0,135 135,345 345,525 525,615 615,675
and Andy,| how do you
|你怎么知道 n 是什么，

450
00:12:10,690 --> 00:12:11,335
0,225 225,450 450,510 510,570 570,645
know, how do you know

451
00:12:11,335 --> 00:12:13,000
0,90 90,225 225,515 1075,1380 1380,1665
what n is,| well, this
|这是，我们会度过整个学期，

452
00:12:13,000 --> 00:12:14,035
0,380 430,720 720,795 795,900 900,1035
is, we'll get through that

453
00:12:14,035 --> 00:12:15,160
0,390 390,645 645,780 780,930 930,1125
semester,| like the database system
|数据库系统会试图做出决定，

454
00:12:15,160 --> 00:12:15,715
0,135 135,225 225,345 345,465 465,555
is going to try to

455
00:12:15,715 --> 00:12:16,435
0,90 90,240 240,450 450,615 615,720
make a decision| or try
|或者试图预测你将拥有多少键，

456
00:12:16,435 --> 00:12:17,695
0,75 75,305 715,960 960,1095 1095,1260
to predict how many keys

457
00:12:17,695 --> 00:12:18,205
0,150 150,240 240,360 360,435 435,510
you're going actually going to

458
00:12:18,205 --> 00:12:20,130
0,245 535,935 955,1245 1245,1425 1425,1925
have| and size it accordingly.|
|并相应地调整大小。|

459
00:12:21,420 --> 00:12:23,520
0,365 365,830 830,1040 1040,1360
So O(1) sounds great,|
所以 O(1) 听起来很棒，|

460
00:12:23,520 --> 00:12:24,285
0,165 165,270 270,525 525,675 675,765
And if you're going to
如果你要上一门算法课，

461
00:12:24,285 --> 00:12:25,320
0,90 90,270 270,570 570,810 810,1035
take an algorithms class,| this
|这就是圣杯，你想要这个，

462
00:12:25,320 --> 00:12:26,175
0,135 135,255 255,435 435,690 690,855
is the holy grail, you

463
00:12:26,175 --> 00:12:27,105
0,180 180,450 450,675 675,810 810,930
want this,| you want {O(1)
|你想要 O(1) ，因为它是恒定的时间，

464
00:12:27,105 --> 00:12:28,520
0,180 180,485 535,870 870,1065 1065,1415
-}, because it's constant time,|
|

465
00:12:29,050 --> 00:12:31,050
0,350 350,650 650,1280 1280,1630 1740,2000
but in actuality, again, in
但事实上，在一个真实的系统中，

466
00:12:31,050 --> 00:12:34,545
0,120 120,285 285,590 2620,2940 2940,3495
a real system,| the constants
|常量实际上很重要，

467
00:12:34,545 --> 00:12:35,850
0,270 270,450 450,615 615,875 1045,1305
actually matter a lot,| so
|所以即使它是 O(1) ，

468
00:12:35,850 --> 00:12:36,770
0,150 150,285 285,450 450,600 600,920
even though it's {O(1) -},|
|

469
00:12:37,270 --> 00:12:38,415
0,260 260,395 395,590 590,830 830,1145
you could have one hash
你可以有一个哈希函数，它可能需要 10 毫秒的计算时间，

470
00:12:38,415 --> 00:12:39,450
0,195 195,360 360,525 525,795 795,1035
function that maybe takes 10

471
00:12:39,450 --> 00:12:40,905
0,510 510,600 600,900 900,1140 1140,1455
milliseconds to compute,| another hash
|另一个哈希函数的计算时间为 1 毫秒，

472
00:12:40,905 --> 00:12:42,150
0,300 300,570 570,780 780,1140 1140,1245
function takes 1 millisecond to

473
00:12:42,150 --> 00:12:44,010
0,320 400,720 720,1040 1480,1740 1740,1860
compute,| and obviously the 1
|显然，1 毫秒的速度要快得多，

474
00:12:44,010 --> 00:12:44,955
0,360 360,495 495,600 600,780 780,945
millisecond one is meet a

475
00:12:44,955 --> 00:12:45,885
0,120 120,395 415,675 675,810 810,930
lot faster,| if you think
|如果你在数十亿个键这样的大规模表中思考。

476
00:12:45,885 --> 00:12:47,775
0,105 105,315 315,665 1255,1590 1590,1890
in large scale tables like

477
00:12:47,775 --> 00:12:49,060
0,360 360,465 465,725
billions of keys.|
|

478
00:12:49,340 --> 00:12:50,815
0,400 480,755 755,980 980,1250 1250,1475
So again, just because the
所以，仅仅因为算法的复杂度是理想的，平均为 1 ，

479
00:12:50,815 --> 00:12:52,800
0,270 270,675 675,960 960,1355 1585,1985
algorithm complexity is, is ideal

480
00:12:53,540 --> 00:12:55,330
0,260 260,620 620,910 1380,1640 1640,1790
on averages 1,| we had
|我们仍然必须关心实现，

481
00:12:55,330 --> 00:12:56,125
0,165 165,330 330,480 480,630 630,795
to still care about the

482
00:12:56,125 --> 00:12:57,280
0,275 325,570 570,690 690,915 915,1155
implementation| and make sure we're
|并确保我们尽可能地高效。

483
00:12:57,280 --> 00:12:58,840
0,150 150,405 405,630 630,920
as efficient as possible.|
|

484
00:13:00,260 --> 00:13:01,285
0,245 245,410 410,500 500,725 725,1025
So let's look at the,
让我们来看看这个玩具例子，

485
00:13:01,285 --> 00:13:04,105
0,335 1915,2280 2280,2580 2580,2745 2745,2820
the toy example,| what a
|哈希表是什么样子的，

486
00:13:04,105 --> 00:13:05,365
0,150 150,285 285,480 480,785 1015,1260
hash table looks like,| and
|我们会看到你可能会遇到的所有问题，

487
00:13:05,365 --> 00:13:06,130
0,195 195,315 315,435 435,570 570,765
we'll see all the problems

488
00:13:06,130 --> 00:13:06,790
0,150 150,225 225,330 330,495 495,660
that you can have with

489
00:13:06,790 --> 00:13:07,480
0,165 165,330 330,435 435,585 585,690
it,| and then we'll build
|然后我们将介绍更复杂的方案，

490
00:13:07,480 --> 00:13:08,430
0,135 135,360 360,570 570,690 690,950
up this look at more

491
00:13:08,660 --> 00:13:10,510
0,665 665,1150 1380,1595 1595,1700 1700,1850
sophisticated schemes,| but are actually
|但实际上在现实世界的数据库系统中使用。

492
00:13:10,510 --> 00:13:11,695
0,195 195,530 550,855 855,1035 1035,1185
used in, in real world

493
00:13:11,695 --> 00:13:12,900
0,225 225,575
database systems.|
|

494
00:13:13,610 --> 00:13:14,575
0,260 260,350 350,635 635,845 845,965
So the easiest hash table
所以最容易构建的哈希表是一个静态哈希表，

495
00:13:14,575 --> 00:13:15,370
0,135 135,300 300,465 465,585 585,795
to build is a static

496
00:13:15,370 --> 00:13:16,735
0,270 270,530 940,1170 1170,1245 1245,1365
hash table,| where you just
|你只需要调用 malloc 生成一个巨大的数组，

497
00:13:16,735 --> 00:13:18,840
0,165 165,695 1255,1530 1530,1755 1755,2105
call malloc a giant array,|
|

498
00:13:19,070 --> 00:13:20,890
0,260 260,380 380,640 1260,1565 1565,1820
where you have one slot
对于我可能拥有的每个键，你都有一个槽在数组中，

499
00:13:20,890 --> 00:13:23,080
0,315 315,600 600,890 1060,1460 1960,2190
in your array for for

500
00:13:23,080 --> 00:13:23,800
0,150 150,330 330,450 450,540 540,720
every key I could possibly

501
00:13:23,800 --> 00:13:24,720
0,350
have,|
|

502
00:13:24,840 --> 00:13:26,320
0,275 275,455 455,665 665,970 1080,1480
and then to find an
然后要找到给定键的条目，

503
00:13:26,340 --> 00:13:27,340
0,305 305,425 425,485 485,665 665,1000
entry for a given key,|
|

504
00:13:27,660 --> 00:13:29,120
0,260 260,520 720,1040 1040,1280 1280,1460
you just take the, you
你可以根据你拥有的元素的数量来获得键，

505
00:13:29,120 --> 00:13:29,600
0,105 105,195 195,285 285,390 390,480
might have the key by

506
00:13:29,600 --> 00:13:30,140
0,60 60,135 135,210 210,360 360,540
the number of elements you

507
00:13:30,140 --> 00:13:32,030
0,260 610,1010 1300,1575 1575,1740 1740,1890
have| and you land in
|然后你落在数组中的某个偏移量上，

508
00:13:32,030 --> 00:13:32,860
0,195 195,390 390,480 480,570 570,830
some offset in the array,

509
00:13:33,490 --> 00:13:34,910
0,395 395,650 650,845 845,935 935,1420
right,| so here's my offsets,|
|这是我的偏移量，|

510
00:13:35,260 --> 00:13:36,240
0,245 245,365 365,575 575,800 800,980
and then any key shows
然后任何键出现，我知道到哪里去找它，

511
00:13:36,240 --> 00:13:37,620
0,270 270,615 615,885 885,1155 1155,1380
up, I know exactly where

512
00:13:37,620 --> 00:13:39,320
0,105 105,350 640,930 930,1220
to go find it,|
|

513
00:13:39,900 --> 00:13:40,685
0,260 260,350 350,530 530,650 650,785
and you don't store the
你没有把键存储在这个数组中，

514
00:13:40,685 --> 00:13:41,960
0,275 295,555 555,735 735,990 990,1275
keys in this array,| it's
|它本质上只是一个指向其他位置的指针，

515
00:13:41,960 --> 00:13:44,440
0,210 210,530 970,1275 1275,1790 2080,2480
essentially just a pointer to

516
00:13:44,820 --> 00:13:45,980
0,245 245,470 470,815 815,1100 1100,1160
some other location,| that's going
|将键和值放在一起，

517
00:13:45,980 --> 00:13:47,315
0,90 90,350 700,990 990,1185 1185,1335
to have the key and

518
00:13:47,315 --> 00:13:48,660
0,105 105,365 415,815
the value together,

519
00:13:49,940 --> 00:13:51,220
0,400
right.|
|

520
00:13:51,770 --> 00:13:52,495
0,245 245,320 320,470 470,635 635,725
and the reason why you
你需要存储原始键的原因是，

521
00:13:52,495 --> 00:13:53,230
0,90 90,195 195,375 375,540 540,735
need to store the original

522
00:13:53,230 --> 00:13:56,695
0,345 345,740 2650,2955 2955,3120 3120,3465
key,| because since the hash
|因为哈希可能，你可能会有冲突，

523
00:13:56,695 --> 00:13:58,225
0,335 715,990 990,1125 1125,1260 1260,1530
may, you could have collisions,|
|

524
00:13:58,225 --> 00:13:58,735
0,195 195,330 330,375 375,435 435,510
which we'll get in a
我们稍后会了解到，

525
00:13:58,735 --> 00:14:00,460
0,245 1045,1290 1290,1395 1395,1545 1545,1725
second,| you need to check
|你需要检查你通过哈希表查找的键

526
00:14:00,460 --> 00:14:01,410
0,195 195,375 375,525 525,675 675,950
whether the key you looking

527
00:14:01,520 --> 00:14:02,545
0,260 260,395 395,590 590,845 845,1025
that you land on through

528
00:14:02,545 --> 00:14:03,760
0,105 105,360 360,600 600,915 915,1215
your hash table| is actually
|是否真的是你想要找到的键，

529
00:14:03,760 --> 00:14:04,510
0,225 225,375 375,555 555,630 630,750
the key you're trying to

530
00:14:04,510 --> 00:14:05,240
0,260
find,|
|

531
00:14:05,610 --> 00:14:06,680
0,260 260,380 380,620 620,890 890,1070
and the value here could
这里的值可以是指向 tuple ，指向一个记录 ID 的指针，

532
00:14:06,680 --> 00:14:07,940
0,290 370,660 660,1020 1020,1155 1155,1260
be a pointer to the

533
00:14:07,940 --> 00:14:08,705
0,105 105,210 210,420 420,615 615,765
{tuple -} to a record

534
00:14:08,705 --> 00:14:10,010
0,305 625,915 915,1035 1035,1155 1155,1305
ID,| or could there actually
|或者可能有一些额外的值，

535
00:14:10,010 --> 00:14:12,220
0,120 120,380 640,975 975,1310 1810,2210
be some additional values,| for
|对于我们今天的目的，我们其实并不关心。

536
00:14:12,480 --> 00:14:13,535
0,260 260,425 425,635 635,800 800,1055
our purpose today, we don't

537
00:14:13,535 --> 00:14:14,520
0,180 180,455
actually care.|
|

538
00:14:16,560 --> 00:14:17,320
0,245 245,320 320,380 380,485 485,760
So what are some problems
那么，这种方法有哪些问题呢？

539
00:14:17,400 --> 00:14:19,080
0,380 380,680 680,1000
with this approach?|
|

540
00:14:20,430 --> 00:14:21,800
0,400
Yes.|
是的。|

541
00:14:26,160 --> 00:14:26,780
0,245 245,365 365,485 485,560 560,620
He says, what if you
他说，如果你有，

542
00:14:26,780 --> 00:14:27,670
0,225 225,465 465,540 540,630 630,890
have, what do you have,|
|

543
00:14:28,770 --> 00:14:30,095
0,395 395,740 740,875 875,1055 1055,1325
well, I'm assuming it's static,|
好的，我假设它是静态的，|

544
00:14:30,095 --> 00:14:30,755
0,225 225,300 300,390 390,465 465,660
so what if you have
那么，如果你有 n+1 个键，

545
00:14:30,755 --> 00:14:32,735
0,270 270,480 480,705 705,1025 1705,1980
{n+1 - -} keys,| how
|你怎么调整这个东西的大小，

546
00:14:32,735 --> 00:14:33,610
0,90 90,150 150,435 435,600 600,875
do you resize this thing,|
|

547
00:14:34,200 --> 00:14:35,285
0,245 245,395 395,665 665,890 890,1085
and {you,know} basically, in this
基本上，在这种情况下，

548
00:14:35,285 --> 00:14:36,190
0,255 255,405 405,465 465,540 540,905
scenario,| you have to rehash
|你必须重新计算所有东西，

549
00:14:36,210 --> 00:14:38,640
0,400 900,1235 1235,1475 1475,1900
everything,| so that sucks.|
|所以这太糟糕了。|

550
00:14:39,360 --> 00:14:41,260
0,290 290,410 410,635 635,970
What other problems?| Yes.|
还有其他什么问题吗？|是的。|

551
00:14:41,690 --> 00:14:42,610
0,245 245,320 320,455 455,755 755,920
Does it handle collision, What
它能处理碰撞吗，什么是碰撞？

552
00:14:42,610 --> 00:14:44,460
0,105 105,470
is collision?|
|

553
00:14:46,810 --> 00:14:48,915
0,400 660,995 995,1130 1130,1420 1800,2105
Yes, that's correct, yes,| two
是的，没错，|两个具有相同值的键，

554
00:14:48,915 --> 00:14:49,590
0,210 210,360 360,450 450,540 540,675
keys that have the same

555
00:14:49,590 --> 00:14:50,310
0,240 240,495 495,525 525,585 585,720
value,| they're going to land
|它们将落在我们数组中的相同位置，

556
00:14:50,310 --> 00:14:51,380
0,120 120,195 195,390 390,705 705,1070
in the same location in,

557
00:14:52,000 --> 00:14:53,760
0,400 510,755 755,905 905,1210 1440,1760
in, in our array,| even
|尽管它们不是相同的，

558
00:14:53,760 --> 00:14:54,620
0,180 180,345 345,450 450,600 600,860
though they're not the same,|
|

559
00:14:54,670 --> 00:14:56,145
0,245 245,440 440,680 680,1030 1230,1475
but I'm assuming that you
但我假设每个都必须是独一无二的，你不能有冲突，

560
00:14:56,145 --> 00:14:57,435
0,240 240,635 655,1020 1020,1230 1230,1290
know that everyone has to

561
00:14:57,435 --> 00:14:58,170
0,60 60,255 255,450 450,555 555,735
be unique and you can't

562
00:14:58,170 --> 00:14:59,715
0,105 105,440 670,1050 1050,1335 1335,1545
have collisions,| and this example
|这个例子不能处理这个。

563
00:14:59,715 --> 00:15:00,860
0,225 225,390 390,695
doesn't handle that.|
|

564
00:15:02,190 --> 00:15:03,460
0,75 75,180 180,285 285,530
There's one more problem.|
还有一个问题。|

565
00:15:07,800 --> 00:15:09,500
0,425 425,680 680,1030 1140,1430 1430,1700
I'm assuming that the keys
我假设键是唯一的，

566
00:15:09,500 --> 00:15:11,720
0,255 255,530 1210,1610 1840,2100 2100,2220
are unique, right,| I can
|我的键值可以等于 1 ，

567
00:15:11,720 --> 00:15:13,150
0,210 210,525 525,870 870,1140 1140,1430
have key value equals one|
|

568
00:15:13,290 --> 00:15:14,860
0,320 320,590 590,940 960,1265 1265,1570
and key value equals two|
键值可以等于 2 ，|

569
00:15:15,060 --> 00:15:16,210
0,320 320,545 545,695 695,845 845,1150
same key but different values,|
相同的键，但值不同，|

570
00:15:16,620 --> 00:15:18,890
0,260 260,520 1530,1865 1865,2045 2045,2270
in my, my sort of
我的玩具例子，不能处理这个。

571
00:15:18,890 --> 00:15:20,015
0,300 300,510 510,705 705,960 960,1125
toy example here, doesn't handle

572
00:15:20,015 --> 00:15:20,880
0,305
this,

573
00:15:21,400 --> 00:15:23,205
0,400 870,1130 1130,1250 1250,1415 1415,1805
right.| So this is unrealistic
|所以，对于这三个假设，这是不现实的。

574
00:15:23,205 --> 00:15:24,225
0,255 255,465 465,615 615,780 780,1020
again for these three assumptions.|
|

575
00:15:24,225 --> 00:15:25,010
0,195 195,270 270,405 405,540 540,785
So the first one is,|
所以第一个是，|

576
00:15:25,030 --> 00:15:25,725
0,245 245,335 335,425 425,545 545,695
you have to know all
你必须提前知道所有的键，

577
00:15:25,725 --> 00:15:26,540
0,135 135,300 300,450 450,555 555,815
the keys ahead of time,|
|

578
00:15:27,220 --> 00:15:28,370
0,275 275,440 440,665 665,875 875,1150
in some cases, you do
在某些情况下，你知道，其他情况下，你不知道，

579
00:15:28,570 --> 00:15:29,715
0,275 275,395 395,575 575,770 770,1145
{other -} cases, you don't,|
|

580
00:15:29,715 --> 00:15:30,390
0,225 225,330 330,450 450,570 570,675
in the case of the
在缓冲池的情况下，

581
00:15:30,390 --> 00:15:31,620
0,285 285,560 730,1005 1005,1125 1125,1230
buffer pool,| and then we
|我们上一节课讨论的，

582
00:15:31,620 --> 00:15:32,840
0,165 165,345 345,540 540,840 840,1220
talked about last class,| that
|如果假设缓冲池的大小是固定的，

583
00:15:33,220 --> 00:15:34,700
0,290 290,515 515,830 830,1145 1145,1480
if you assume that the,

584
00:15:35,320 --> 00:15:36,705
0,400 420,755 755,980 980,1205 1205,1385
you know, the size of

585
00:15:36,705 --> 00:15:37,550
0,105 105,300 300,405 405,555 555,845
your buffer pool is fixed,|
|

586
00:15:37,750 --> 00:15:38,340
0,275 275,320 320,365 365,440 440,590
you're going to have a
那么缓冲池中将有固定数量的帧，

587
00:15:38,340 --> 00:15:39,585
0,180 180,390 390,675 675,1035 1035,1245
fixed number of frames in

588
00:15:39,585 --> 00:15:40,725
0,90 90,315 315,575 805,1050 1050,1140
your buffer pool,| therefore, you
|这样，你直到你的哈希表中需要的确切槽数，

589
00:15:40,725 --> 00:15:41,750
0,105 105,255 255,465 465,705 705,1025
know the exact number of

590
00:15:42,310 --> 00:15:43,710
0,430 690,965 965,1145 1145,1295 1295,1400
slots you need in your

591
00:15:43,710 --> 00:15:44,560
0,180 180,440
hash table,|
|

592
00:15:44,930 --> 00:15:46,915
0,320 320,500 500,760 1620,1865 1865,1985
but if I if I
但是，如果我构建了一个哈希表索引，

593
00:15:46,915 --> 00:15:48,030
0,135 135,255 255,465 465,720 720,1115
build a hash table index|
|

594
00:15:48,290 --> 00:15:49,530
0,245 245,350 350,470 470,830 830,1240
and I keep inserting tuples,|
我一直插入 tuple ，|

595
00:15:49,640 --> 00:15:50,965
0,400 660,905 905,995 995,1100 1100,1325
now the number of keys
那么当我插入新的 tuple 时，键的数量就会增加。

596
00:15:50,965 --> 00:15:52,030
0,270 270,510 510,705 705,825 825,1065
is growing, as I insert

597
00:15:52,030 --> 00:15:53,300
0,135 135,530
new tuples.|
|

598
00:15:54,010 --> 00:15:55,425
0,350 350,545 545,635 635,880 1170,1415
Every key is unique in
在这个场景中，每个键都是唯一的，

599
00:15:55,425 --> 00:15:56,535
0,120 120,330 330,630 630,930 930,1110
this scenario,| here again, how
|同样，我们需要一种方法来处理具有重复键的键，

600
00:15:56,535 --> 00:15:57,030
0,90 90,195 195,300 300,390 390,495
do we need a way

601
00:15:57,030 --> 00:16:00,885
0,120 120,380 1840,2175 2175,2510 3580,3855
to handle keys that have

602
00:16:00,885 --> 00:16:01,905
0,345 345,555 555,750 750,855 855,1020
duplicate keys,| we have different
|我们有不同的值，

603
00:16:01,905 --> 00:16:03,080
0,305 415,645 645,720 720,870 870,1175
values,| got to handle that.|
|得处理好这件事。|

604
00:16:03,820 --> 00:16:05,635
0,225 225,500 550,950 1390,1680 1680,1815
And then the thing the
然后他提出的事情是，

605
00:16:05,635 --> 00:16:06,340
0,120 120,255 255,375 375,495 495,705
he brought up is that,|
|

606
00:16:06,340 --> 00:16:07,315
0,315 315,510 510,705 705,840 840,975
we're assuming here we have
我们假设我们这里有一个所谓的完美散列函数，

607
00:16:07,315 --> 00:16:07,960
0,90 90,195 195,285 285,435 435,645
what it's called a perfect

608
00:16:07,960 --> 00:16:10,075
0,300 300,560 1000,1350 1350,1920 1920,2115
hash function,| that guarantees no
|它保证不会发生碰撞，

609
00:16:10,075 --> 00:16:11,700
0,345 345,705 705,990 990,1260 1260,1625
collisions,| which does not exist
|这在现实世界中是不存在的，

610
00:16:11,780 --> 00:16:14,095
0,260 260,395 395,590 590,910 2040,2315
in the real world| and
|在现实世界中，

611
00:16:14,095 --> 00:16:14,695
0,150 150,255 255,315 315,420 420,600
this in the real world,|
|

612
00:16:14,695 --> 00:16:15,930
0,135 135,285 285,510 510,780 780,1235
but it's basically toy [],|
但这基本上是玩具[]，|

613
00:16:15,950 --> 00:16:17,230
0,320 320,605 605,905 905,1130 1130,1280
no database system can actually
没有数据库系统可以真正做到这一点，

614
00:16:17,230 --> 00:16:18,070
0,120 120,330 330,540 540,675 675,840
do this,| because again, you
|因为同样，你需要提前知道键的域，

615
00:16:18,070 --> 00:16:19,420
0,165 165,300 300,560 910,1185 1185,1350
need to know the key

616
00:16:19,420 --> 00:16:21,120
0,285 285,525 525,630 630,890 1300,1700
domain ahead of time, right,|
|

617
00:16:21,260 --> 00:16:22,750
0,320 320,500 500,1010 1010,1295 1295,1490
there's no magical hash function
没有神奇的哈希函数可以保证，

618
00:16:22,750 --> 00:16:24,130
0,195 195,735 735,945 945,1110 1110,1380
that guarantees,| for any given
|任何给定的键，你可以生成唯一的哈希值，

619
00:16:24,130 --> 00:16:25,710
0,350 550,795 795,945 945,1215 1215,1580
key, you can generate a

620
00:16:26,150 --> 00:16:28,220
0,400 660,1010 1010,1310 1310,1570
unique, unique hash value,|
|

621
00:16:29,520 --> 00:16:30,520
0,230 230,350 350,530 530,710 710,1000
the way to actually implement
实际实现其中之一的方法是通过哈希表，

622
00:16:31,200 --> 00:16:32,135
0,260 260,365 365,575 575,815 815,935
one of those is through

623
00:16:32,135 --> 00:16:33,245
0,90 90,285 285,545 835,1050 1050,1110
a hash table,| so you
|所以你的哈希表基本上需要一个哈希表来实现这个，

624
00:16:33,245 --> 00:16:34,040
0,165 165,345 345,450 450,645 645,795
basically need a hash table

625
00:16:34,040 --> 00:16:35,195
0,135 135,240 240,435 435,680 790,1155
for your hash table to

626
00:16:35,195 --> 00:16:37,140
0,240 240,515
do this,|
|

627
00:16:38,230 --> 00:16:40,395
0,400 1170,1460 1460,1730 1730,2000 2000,2165
for some systems do do
有些系统确实会这样做，

628
00:16:40,395 --> 00:16:41,430
0,165 165,330 330,510 510,750 750,1035
that,| but not for a
|但不会对哈希函数。

629
00:16:41,430 --> 00:16:42,560
0,270 270,560
hash function.|
|

630
00:16:44,820 --> 00:16:45,335
0,230 230,335 335,365 365,410 410,515
So we've got to be
所以我们必须变得更聪明，

631
00:16:45,335 --> 00:16:46,115
0,305 385,600 600,675 675,735 735,780
smarter,| and we got to
|我们必须确保，

632
00:16:46,115 --> 00:16:47,060
0,105 105,285 285,570 570,825 825,945
make sure that,| we deal
|我们与使用数据库操作的环境打交道。

633
00:16:47,060 --> 00:16:48,170
0,105 105,240 240,530 580,855 855,1110
with the environment that we're

634
00:16:48,170 --> 00:16:50,160
0,180 180,470 550,825 825,1400
operating in with databases.|
|

635
00:16:50,680 --> 00:16:51,525
0,260 260,410 410,545 545,695 695,845
All right, so there's two
好的，所以我们必须做出两个决定，

636
00:16:51,525 --> 00:16:52,215
0,210 210,345 345,420 420,510 510,690
decisions we have to make|
|

637
00:16:52,215 --> 00:16:53,070
0,315 315,555 555,675 675,765 765,855
when we run a about
当我们运行关于哈希表时，

638
00:16:53,070 --> 00:16:54,225
0,90 90,255 255,500 730,990 990,1155
a hash table,| so someone
|有人说哈希表有两个部分，

639
00:16:54,225 --> 00:16:55,110
0,210 210,465 465,645 645,720 720,885
says they have a hash

640
00:16:55,110 --> 00:16:56,265
0,150 150,375 375,480 480,740 880,1155
table, it's sort of two

641
00:16:56,265 --> 00:16:58,275
0,275 775,1295 1315,1560 1560,1755 1755,2010
parts there,| the hash function
|哈希函数本身，

642
00:16:58,275 --> 00:16:59,250
0,330 330,540 540,705 705,840 840,975
itself,| that can how to
|它可以将一个大的键空间映射到一个有限的、较小的域，

643
00:16:59,250 --> 00:17:01,350
0,290 1030,1305 1305,1560 1560,1860 1860,2100
map a large key space

644
00:17:01,350 --> 00:17:03,030
0,270 270,600 600,900 900,1380 1380,1680
down to a finite, smaller

645
00:17:03,030 --> 00:17:04,100
0,320
domain,|
|

646
00:17:04,380 --> 00:17:05,180
0,305 305,455 455,545 545,665 665,800
based on the number of
根据我的数组中将要包含的槽的数量，

647
00:17:05,180 --> 00:17:05,960
0,195 195,450 450,510 510,585 585,780
slots, I'm going to have

648
00:17:05,960 --> 00:17:07,835
0,300 300,540 540,735 735,1040 1600,1875
in in my array,| and
|这里有一个权衡，

649
00:17:07,835 --> 00:17:08,630
0,270 270,360 360,480 480,615 615,795
there be this trade off|
|

650
00:17:08,630 --> 00:17:09,710
0,225 225,465 465,735 735,930 930,1080
between how fast we want
在我们希望哈希函数的速度，

651
00:17:09,710 --> 00:17:10,565
0,165 165,360 360,525 525,675 675,855
our hash function to be|
|

652
00:17:10,565 --> 00:17:13,085
0,335 1735,2025 2025,2220 2220,2370 2370,2520
versus how likely it is
与两个不同的键发生冲突的可能性之间。

653
00:17:13,085 --> 00:17:14,645
0,210 210,420 420,725 925,1290 1290,1560
that two keys, two distinct

654
00:17:14,645 --> 00:17:16,500
0,305 655,930 930,1295
keys will collide.|
|

655
00:17:17,210 --> 00:17:18,460
0,320 320,395 395,730 810,1145 1145,1250
What's the hash, what's the
我能构建的最快的哈希函数是什么？

656
00:17:18,460 --> 00:17:19,810
0,360 360,555 555,720 720,1040 1090,1350
fastest hash function I could

657
00:17:19,810 --> 00:17:20,760
0,260
build?|
|

658
00:17:22,270 --> 00:17:23,440
0,290 290,520
What's that?|
那是什么？|

659
00:17:23,440 --> 00:17:24,460
0,255 255,530 610,840 840,915 915,1020
So, [], you can go
[]，你可以比这个更快，

660
00:17:24,460 --> 00:17:25,285
0,165 165,300 300,420 420,645 645,825
faster than that,| so he
|所以他说的是，

661
00:17:25,285 --> 00:17:25,990
0,150 150,360 360,480 480,540 540,705
basically says,| for a given
|对于一个给定的键，你吐出相同的键，

662
00:17:25,990 --> 00:17:26,575
0,195 195,315 315,420 420,495 495,585
key, you spit out the

663
00:17:26,575 --> 00:17:27,550
0,135 135,425 565,810 810,900 900,975
same key,| but if you
|但是如果你有一个字符串键，而我要把它变成一个整数，

664
00:17:27,550 --> 00:17:28,405
0,75 75,210 210,420 420,675 675,855
have a string key and

665
00:17:28,405 --> 00:17:28,765
0,90 90,150 150,195 195,270 270,360
I got to make it

666
00:17:28,765 --> 00:17:29,410
0,90 90,390 390,510 510,570 570,645
an integer,| how do I
|我该怎么做？

667
00:17:29,410 --> 00:17:30,360
0,105 105,350
do that?|
|

668
00:17:32,690 --> 00:17:33,720
0,275 275,425 425,560 560,725 725,1030
So take the first bit,|
拿出第一个位，|

669
00:17:36,190 --> 00:17:37,095
0,380 380,605 605,695 695,785 785,905
yeah, that would be pretty
是的，那也会很快的，

670
00:17:37,095 --> 00:17:40,860
0,180 180,485 3205,3480 3480,3615 3615,3765
fast, too,| you just can
|你可以只返回 1 ，

671
00:17:40,860 --> 00:17:42,020
0,210 210,530
return 1,

672
00:17:42,540 --> 00:17:44,645
0,400 1440,1805 1805,1925 1925,2000 2000,2105
right,| that sit in the
|它们位于寄存器中的堆栈中，速度非常快。

673
00:17:44,645 --> 00:17:46,055
0,275 685,930 930,1005 1005,1185 1185,1410
stack in a register that

674
00:17:46,055 --> 00:17:47,900
0,105 105,255 255,545
be super fast.|
|

675
00:17:48,120 --> 00:17:49,040
0,305 305,410 410,560 560,770 770,920
It's the worst hash function
就碰撞而言，这是最糟糕的哈希函数，

676
00:17:49,040 --> 00:17:50,015
0,135 135,255 255,375 375,675 675,975
in terms of collision,| because
|因为所有东西都将映射到 1 ，

677
00:17:50,015 --> 00:17:50,525
0,165 165,255 255,330 330,390 390,510
everything is going to map

678
00:17:50,525 --> 00:17:52,070
0,135 135,395 835,1125 1125,1305 1305,1545
to 1,| but it it'll
|但它会很快。

679
00:17:52,070 --> 00:17:53,900
0,90 90,350 1090,1410 1410,1665 1665,1830
be fast.| So it's this
|所以这是一种权衡试图找出，

680
00:17:53,900 --> 00:17:54,680
0,180 180,345 345,510 510,630 630,780
trade off trying to figure

681
00:17:54,680 --> 00:17:55,520
0,165 165,420 420,660 660,765 765,840
out| and you sort of
|而你有点认为完美的哈希函数是另一端，

682
00:17:55,520 --> 00:17:56,345
0,150 150,330 330,480 480,660 660,825
think the perfect hash function

683
00:17:56,345 --> 00:17:57,920
0,165 165,425 445,795 795,1145 1315,1575
is the other end,| the
|碰撞率是零，

684
00:17:57,920 --> 00:17:59,170
0,210 210,405 405,570 570,855 855,1250
collision rate is, is, is,

685
00:17:59,340 --> 00:18:00,920
0,320 320,640 960,1205 1205,1370 1370,1580
is zero,| but it's super
|但它非常慢，

686
00:18:00,920 --> 00:18:01,745
0,315 315,525 525,630 630,735 735,825
slow,| because you have to
|因为你必须进行额外的查找。

687
00:18:01,745 --> 00:18:03,500
0,120 120,315 315,570 570,1055 1525,1755
do this extra lookup.| So
|所以你想要中间的东西，

688
00:18:03,500 --> 00:18:04,100
0,75 75,210 210,390 390,525 525,600
you want something in the

689
00:18:04,100 --> 00:18:04,595
0,120 120,330 330,375 375,405 405,495
middle,| that's going to be
|既快速又有低碰撞率。

690
00:18:04,595 --> 00:18:05,675
0,270 270,645 645,885 885,990 990,1080
fast and and have a

691
00:18:05,675 --> 00:18:06,920
0,120 120,345 345,665
low collision rate.|
|

692
00:18:07,420 --> 00:18:08,700
0,380 380,620 620,755 755,890 890,1280
And, and then the hashing
然后，哈希方案将是，

693
00:18:08,700 --> 00:18:09,255
0,150 150,270 270,360 360,450 450,555
scheme is going be| the
|我们在完成哈希之后将用来处理冲突的机制，

694
00:18:09,255 --> 00:18:10,200
0,245 265,555 555,615 615,705 705,945
mechanism we're going to use

695
00:18:10,200 --> 00:18:12,495
0,255 255,530 1330,1820 1840,2145 2145,2295
to handle collisions after we

696
00:18:12,495 --> 00:18:15,075
0,120 120,255 255,695 1105,1505 2335,2580
done our hashing| and the
|这里的权衡方式将是，

697
00:18:15,075 --> 00:18:16,485
0,245 745,1020 1020,1140 1140,1275 1275,1410
way the trade off here

698
00:18:16,485 --> 00:18:18,060
0,105 105,210 210,285 285,515 1195,1575
is going to be again,|
|

699
00:18:18,060 --> 00:18:19,500
0,210 210,440 610,900 900,1170 1170,1440
sort of the classic storage
计算机科学中经典的存储与计算，

700
00:18:19,500 --> 00:18:20,780
0,210 210,585 585,780 780,975 975,1280
versus compute in computer science,|
|

701
00:18:21,070 --> 00:18:22,440
0,290 290,470 470,760 960,1235 1235,1370
like I could, I could
比如我可以分配一个 2TB 的哈希表，

702
00:18:22,440 --> 00:18:24,270
0,525 525,900 900,1185 1185,1590 1590,1830
allocate a two terabyte hash

703
00:18:24,270 --> 00:18:25,965
0,260 550,810 810,1065 1065,1350 1350,1695
table| and I'm pretty, pretty
|我不太可能有冲突，

704
00:18:25,965 --> 00:18:27,450
0,375 375,465 465,540 540,785 1195,1485
unlikely going to have, I'm

705
00:18:27,450 --> 00:18:28,155
0,105 105,300 300,465 465,555 555,705
not likely going to have

706
00:18:28,155 --> 00:18:29,280
0,365 475,720 720,840 840,990 990,1125
collisions| for my key set
|因为我的键集非常小，

707
00:18:29,280 --> 00:18:30,315
0,225 225,525 525,750 750,900 900,1035
is super small,| but I
|但我分配了这个巨大的哈希表，

708
00:18:30,315 --> 00:18:32,270
0,330 330,525 525,845 1345,1710 1710,1955
allocated this massive hash table,|
|

709
00:18:32,720 --> 00:18:33,515
0,225 225,315 315,420 420,570 570,795
or I can have a
或者我可以有一个更小的，

710
00:18:33,515 --> 00:18:34,325
0,255 255,480 480,630 630,750 750,810
smaller one,| but I'll have
|但我会有很多碰撞，

711
00:18:34,325 --> 00:18:35,210
0,90 90,195 195,315 315,600 600,885
a lot of collisions| and
|因此我必须花费更多的计算来处理这些碰撞。

712
00:18:35,210 --> 00:18:35,780
0,150 150,210 210,270 270,390 390,570
therefore I have to spend

713
00:18:35,780 --> 00:18:37,130
0,290 310,795 795,990 990,1170 1170,1350
more compute to handle those

714
00:18:37,130 --> 00:18:38,465
0,320 580,840 840,960 960,1185 1185,1335
collisions.| So again, it's trying
|所以，它试图找出如何做正确的权衡，

715
00:18:38,465 --> 00:18:39,005
0,135 135,255 255,375 375,465 465,540
to figure out how to

716
00:18:39,005 --> 00:18:40,025
0,90 90,195 195,455 655,915 915,1020
do the right, get the

717
00:18:40,025 --> 00:18:41,600
0,150 150,315 315,495 495,815 1285,1575
right trade off| between not
|在不过度分配，

718
00:18:41,600 --> 00:18:43,040
0,195 195,710 880,1125 1125,1275 1275,1440
over allocating,| but then also
|同时也不浪费大量指令来处理碰撞之间。

719
00:18:43,040 --> 00:18:43,985
0,260 280,645 645,735 735,810 810,945
not wasting a lot of

720
00:18:43,985 --> 00:18:45,350
0,270 270,495 495,675 675,995 1075,1365
instructions to deal with with

721
00:18:45,350 --> 00:18:46,440
0,380
collisions.|
|

722
00:18:48,060 --> 00:18:49,060
0,230 230,335 335,485 485,770 770,1000
All right, so today's talk,|
好的，今天的演讲，|

723
00:18:49,110 --> 00:18:49,895
0,305 305,410 410,500 500,575 575,785
we'll talk a little bit
我们将稍微讨论一下哈希函数，

724
00:18:49,895 --> 00:18:52,040
0,255 255,465 465,725 1135,1535 1885,2145
about hash functions,| {} just
|只是为了向你们展示什么是最先进的，

725
00:18:52,040 --> 00:18:53,180
0,260 550,810 810,915 915,1020 1020,1140
to show you what the

726
00:18:53,180 --> 00:18:53,830
0,105 105,180 180,270 270,390 390,650
state of the art is,|
|

727
00:18:53,850 --> 00:18:54,410
0,290 290,365 365,425 425,470 470,560
I'm not going to say
我不会说它们是如何工作的，

728
00:18:54,410 --> 00:18:55,625
0,120 120,255 255,435 435,740 970,1215
how they work| to tell
|来告诉你们它们的存在，

729
00:18:55,625 --> 00:18:56,945
0,90 90,210 210,405 405,725 1015,1320
you that they exist,| again,
|再次，我们是数据库人，

730
00:18:56,945 --> 00:18:57,935
0,225 225,375 375,675 675,930 930,990
we're database people,| we're not
|我们不是做编写哈希函数的，

731
00:18:57,935 --> 00:18:58,475
0,75 75,150 150,300 300,435 435,540
in the business of writing

732
00:18:58,475 --> 00:18:59,360
0,210 210,405 405,645 645,735 735,885
hash functions,| we'll let other
|我们会让别人为我们做这件事。

733
00:18:59,360 --> 00:19:00,160
0,165 165,300 300,435 435,555 555,800
people do that for us.|
|

734
00:19:01,080 --> 00:19:02,080
0,260 260,380 380,530 530,680 680,1000
And then we'll talk about
然后我们将讨论经典的静态哈希方案，

735
00:19:02,460 --> 00:19:03,965
0,380 380,605 605,680 680,910 1140,1505
the sort of the classic

736
00:19:03,965 --> 00:19:05,570
0,315 315,705 705,1145 1225,1470 1470,1605
static hashing schemes,| where, you
|在这种方案中，提前知道键的数量。

737
00:19:05,570 --> 00:19:06,440
0,240 240,420 420,525 525,675 675,870
know, the number of keys

738
00:19:06,440 --> 00:19:07,700
0,180 180,300 300,560 880,1140 1140,1260
ahead of time.| And then
|然后我们将讨论动态哈希方案，

739
00:19:07,700 --> 00:19:09,095
0,150 150,300 300,620 760,1065 1065,1395
we'll talk about dynamic hashing

740
00:19:09,095 --> 00:19:10,265
0,270 270,540 540,810 810,990 990,1170
schemes,| where the hash table
|其中哈希表可以增长和缩小，

741
00:19:10,265 --> 00:19:11,260
0,150 150,345 345,510 510,660 660,995
can actually grow and shrink,|
|

742
00:19:11,840 --> 00:19:12,610
0,275 275,410 410,515 515,635 635,770
based on the number of
根据键的数量，

743
00:19:12,610 --> 00:19:14,380
0,260 820,1220
keys,| okay?|
|好的？|

744
00:19:15,460 --> 00:19:16,820
0,260 260,520
All right.|
好的。|

745
00:19:17,850 --> 00:19:19,100
0,245 245,490 750,1070 1070,1160 1160,1250
So again, we're not in
再说一次，我们不是在做编写哈希函数的，

746
00:19:19,100 --> 00:19:20,225
0,75 75,320 370,690 690,900 900,1125
the business of writing hash

747
00:19:20,225 --> 00:19:21,395
0,245 295,615 615,885 885,1065 1065,1170
functions,| other people that are
|在这个领域，其他比我们更聪明的人已经为我们做到了这个，

748
00:19:21,395 --> 00:19:22,190
0,225 225,360 360,495 495,645 645,795
smarter than us in this

749
00:19:22,190 --> 00:19:23,090
0,225 225,450 450,630 630,780 780,900
space have have done it

750
00:19:23,090 --> 00:19:24,365
0,105 105,350 880,1110 1110,1215 1215,1275
for us,| so we're just
|所以，我们将依靠它们。

751
00:19:24,365 --> 00:19:25,030
0,60 60,135 135,270 270,405 405,665
going to rely on them.|
|

752
00:19:25,470 --> 00:19:26,285
0,275 275,395 395,590 590,770 770,815
Again, the basic idea of
哈希函数的基本思想是，

753
00:19:26,285 --> 00:19:27,020
0,60 60,285 285,465 465,630 630,735
a hash functions is that,|
|

754
00:19:27,020 --> 00:19:27,970
0,90 90,210 210,435 435,660 660,950
we have some input key,|
我们有一些输入键，|

755
00:19:28,170 --> 00:19:29,570
0,305 305,725 725,860 860,980 980,1400
any arbitrary number of bytes
任何类型的任意数量的字节，

756
00:19:29,570 --> 00:19:30,965
0,225 225,420 420,770 1000,1260 1260,1395
of any type,| and we
|我们需要返回一个表示那个键的整数，

757
00:19:30,965 --> 00:19:32,870
0,150 150,425 535,930 930,1325 1405,1905
need to return an integer

758
00:19:32,870 --> 00:19:34,505
0,150 150,405 405,705 705,1010 1270,1635
that represents that key,| typically
|通常是 64 位，

759
00:19:34,505 --> 00:19:36,830
0,255 255,960 960,1235 1915,2175 2175,2325
is 64 bits,| there are
|有 128 位的哈希函数，

760
00:19:36,830 --> 00:19:38,960
0,1140 1140,1430 1480,1785 1785,1965 1965,2130
128 bit hash functions,| but
|但我不认为数据库使用这些，

761
00:19:38,960 --> 00:19:40,145
0,230 280,585 585,660 660,1050 1050,1185
I don't think databases use

762
00:19:40,145 --> 00:19:41,720
0,275 475,720 720,965 1045,1470 1470,1575
those,| there are 32 bit
|还有 32 位哈希函数，

763
00:19:41,720 --> 00:19:43,840
0,165 165,330 330,525 525,800
hash functions as well,|
|

764
00:19:43,970 --> 00:19:45,420
0,365 365,725 725,965 965,1055 1055,1450
so to return an integer.|
所以要返回一个整数。|

765
00:19:46,220 --> 00:19:48,190
0,400 660,950 950,1220 1220,1600 1740,1970
So in this scheme or
所以在这个方案，或者在这个数据库系统中，

766
00:19:48,190 --> 00:19:48,940
0,135 135,300 300,480 480,645 645,750
in, in this, in a

767
00:19:48,940 --> 00:19:50,395
0,210 210,560 640,900 900,1185 1185,1455
database system,| we don't care
|我们不关心哈希函数的任何类型的保护隐私机制，

768
00:19:50,395 --> 00:19:52,810
0,365 1255,1590 1590,1770 1770,2015 2035,2415
about any sort of protection

769
00:19:52,810 --> 00:19:55,420
0,345 345,1010 2050,2295 2295,2400 2400,2610
privacy mechanisms for a hash

770
00:19:55,420 --> 00:19:56,740
0,260 580,885 885,1080 1080,1200 1200,1320
function,| meaning we're not going
|意味着我们不会使用任何有加密保证的东西，

771
00:19:56,740 --> 00:19:57,625
0,75 75,315 315,570 570,690 690,885
to use anything that has

772
00:19:57,625 --> 00:19:59,470
0,555 555,1055 1435,1665 1665,1770 1770,1845
cryptographic guarantees,| so we're not
|所以我们没有使用 SHA-256 或其他任何东西，

773
00:19:59,470 --> 00:20:00,640
0,240 240,570 570,735 735,900 900,1170
using {SHA-256 - - -}

774
00:20:00,640 --> 00:20:01,615
0,240 240,465 465,660 660,780 780,975
or whatever,| like we don't,
|我们不在乎这些东西，

775
00:20:01,615 --> 00:20:02,350
0,105 105,300 300,450 450,585 585,735
we don't care about those

776
00:20:02,350 --> 00:20:03,850
0,270 270,650 820,1140 1140,1320 1320,1500
things,| because we're running on
|因为我们在系统内部运行，

777
00:20:03,850 --> 00:20:04,800
0,195 195,420 420,555 555,675 675,950
the inside of the system,|
|

778
00:20:06,440 --> 00:20:08,915
0,440 1570,1875 1875,2010 2010,2235 2235,2475
it's we're not worried about
我们并不担心会泄露任何东西，

779
00:20:08,915 --> 00:20:10,390
0,495 495,810 810,1035 1035,1200 1200,1475
leaking anything,| when we can
|当我们可以构建一个哈希表来进行 JOIN 时，

780
00:20:10,530 --> 00:20:11,360
0,275 275,395 395,575 575,695 695,830
build a hash table to

781
00:20:11,360 --> 00:20:12,650
0,105 105,225 225,500 790,1095 1095,1290
do a JOIN,| because no
|因为系统外部的任何人都看不到该数据结构，

782
00:20:12,650 --> 00:20:13,430
0,135 135,225 225,450 450,690 690,780
one on the outside of

783
00:20:13,430 --> 00:20:14,495
0,90 90,315 315,630 630,870 870,1065
the system can see that

784
00:20:14,495 --> 00:20:15,740
0,240 240,575
data structure,|
|

785
00:20:15,890 --> 00:20:17,020
0,245 245,425 425,725 725,875 875,1130
so we don't care about
所以我们不关心任何这些事情，

786
00:20:17,020 --> 00:20:18,600
0,240 240,375 375,525 525,830 1180,1580
any of those things| and
|结果是，我们可以跑得更快，

787
00:20:19,280 --> 00:20:20,485
0,290 290,455 455,730 810,1055 1055,1205
as a result, we can

788
00:20:20,485 --> 00:20:21,210
0,150 150,255 255,330 330,435 435,725
actually run a lot faster,

789
00:20:21,990 --> 00:20:23,030
0,320 320,590 590,740 740,875 875,1040
right,| {SHA-256 - - -}
|SHA-256 的速度会非常慢，

790
00:20:23,030 --> 00:20:24,005
0,105 105,195 195,375 375,660 660,975
will be really slow| versus
|相对于 MurmurHash 或 XXHash 之类的东西。

791
00:20:24,005 --> 00:20:26,390
0,300 300,635 1015,1415 1675,2055 2055,2385
something like like {MurmurHash -}

792
00:20:26,390 --> 00:20:27,940
0,255 255,405 405,585 585,1010
or {XXHash - -}.|
|

793
00:20:28,020 --> 00:20:29,180
0,400

794
00:20:29,270 --> 00:20:29,920
0,230 230,305 305,410 410,530 530,650
And as I already said
正如我之前说过的，

795
00:20:29,920 --> 00:20:30,715
0,165 165,315 315,420 420,570 570,795
before,| we want something that's
|我们想要的是速度快、碰撞率低的东西。

796
00:20:30,715 --> 00:20:31,375
0,195 195,375 375,450 450,555 555,660
fast and it has a

797
00:20:31,375 --> 00:20:32,660
0,120 120,360 360,695
low collision rate.|
|

798
00:20:32,960 --> 00:20:34,140
0,400
So,
所以，这只是一个快速的概述，

799
00:20:34,140 --> 00:20:34,970
0,165 165,300 300,420 420,555 555,830
this is just a quick,

800
00:20:36,220 --> 00:20:39,080
0,290 290,2195 2195,2405 2405,2615 2615,2860
quick overview,| what hash function
|了解系统使用的是什么哈希函数，

801
00:20:39,130 --> 00:20:41,565
0,305 305,470 470,730 1740,2135 2135,2435
systems are using,| some like
|有些像 Postgres 使用他们自己的哈希函数，

802
00:20:41,565 --> 00:20:42,960
0,510 510,810 810,960 960,1125 1125,1395
Postgres roll their own hash

803
00:20:42,960 --> 00:20:44,550
0,260 940,1200 1200,1320 1320,1470 1470,1590
function,| but a lot of
|但许多更现代的系统，

804
00:20:44,550 --> 00:20:45,900
0,90 90,240 240,495 495,860 1000,1350
the more modern systems,| they're
|他们将使用现成的东西，

805
00:20:45,900 --> 00:20:46,740
0,75 75,195 195,420 420,660 660,840
going to use something off

806
00:20:46,740 --> 00:20:48,825
0,165 165,440 820,1215 1215,1650 1650,2085
the shelf,| like {XXHash -}
|比如 XXHash 或 MurmurHash 或 SpookyHash 。

807
00:20:48,825 --> 00:20:50,820
0,365 985,1350 1350,1635 1635,1815 1815,1995
or {MurmurHash -} or the

808
00:20:50,820 --> 00:20:52,700
0,345 345,680
{SpookyHash -}.|
|

809
00:20:52,700 --> 00:20:55,130
0,380 760,1160 1840,2070 2070,2190 2190,2430
So basically the main takeaway
所以，从根本上说，这一点的主要结论是，

810
00:20:55,130 --> 00:20:56,400
0,105 105,210 210,330 330,590
from this is that,|
|

811
00:20:56,400 --> 00:20:57,195
0,180 180,345 345,450 450,600 600,795
the state of art one
最先进的一个是 Facebook 的 XXHash ，

812
00:20:57,195 --> 00:20:58,430
0,120 120,345 345,750 750,945 945,1235
is {XXHash -} from Facebook,|
|

813
00:20:59,350 --> 00:21:00,435
0,245 245,365 365,530 530,800 800,1085
with the third version, {XXHash-3
第三个版本， XXHash-3 ，

814
00:21:00,435 --> 00:21:02,145
0,255 255,545 775,1095 1095,1410 1410,1710
- -},| this one is
|这个版本被证明具有最快的性能和最低的冲突率，

815
00:21:02,145 --> 00:21:05,505
0,210 210,360 360,570 570,935 2785,3360
shown to have the fastest

816
00:21:05,505 --> 00:21:06,915
0,330 330,720 720,1050 1050,1245 1245,1410
performance and also the lowest

817
00:21:06,915 --> 00:21:07,980
0,300 300,635
collision rate,|
|

818
00:21:07,980 --> 00:21:09,900
0,320 940,1230 1230,1425 1425,1650 1650,1920
{} there are some systems
有一些系统使用 CRC-32 或 64 来哈希整数，

819
00:21:09,900 --> 00:21:11,655
0,240 240,495 495,810 810,1160 1240,1755
that use {CRC-32 -}

820
00:21:11,655 --> 00:21:13,875
0,135 135,695 1375,1725 1725,2100 2100,2220
or 64 for hashing {}

821
00:21:13,875 --> 00:21:15,120
0,485 595,855 855,930 930,1050 1050,1245
integers,| because it would actually
|因为 x86 中的 CPU 指令会在几个周期内完成它，

822
00:21:15,120 --> 00:21:16,665
0,345 345,645 645,900 900,1035 1035,1545
CPU instructions in {x86 -}

823
00:21:16,665 --> 00:21:18,570
0,240 240,390 390,665 1075,1475 1645,1905
that do that in a

824
00:21:18,570 --> 00:21:21,450
0,120 120,240 240,360 360,770 2650,2880
few number of cycles,| there
|有一些系统做这个，

825
00:21:21,450 --> 00:21:22,140
0,75 75,195 195,375 375,555 555,690
are some systems that do

826
00:21:22,140 --> 00:21:23,430
0,165 165,470 610,915 915,1095 1095,1290
that,| but in terms of
|但在随机字符串方面，你通常希望使用这个，

827
00:21:23,430 --> 00:21:25,560
0,315 315,740 1150,1440 1440,1730 1870,2130
random strings, you typically want

828
00:21:25,560 --> 00:21:26,720
0,105 105,255 255,560
to use this,|
|

829
00:21:26,760 --> 00:21:28,085
0,260 260,500 500,665 665,1145 1145,1325
so {MurmurHash -} {is,[]},| because
MurmurHash 是[]，| 因为 MurmurHash 是由一个[随机的家伙]在互联网上写的，

830
00:21:28,085 --> 00:21:28,790
0,135 135,225 225,420 420,585 585,705
it was {MurmurHash -} was

831
00:21:28,790 --> 00:21:29,720
0,135 135,270 270,480 480,750 750,930
written by this [random dude]

832
00:21:29,720 --> 00:21:30,815
0,105 105,255 255,560 760,1005 1005,1095
on the Internet,| he had
|他有一个好的、快速的通用哈希函数，

833
00:21:30,815 --> 00:21:31,805
0,105 105,300 300,570 570,795 795,990
a good, fast general purpose

834
00:21:31,805 --> 00:21:33,635
0,255 255,515 895,1295 1315,1605 1605,1830
hash function,| Google took that
|Google 采用它，并通过 fork 做了 CityHash ，

835
00:21:33,635 --> 00:21:35,890
0,180 180,360 360,600 600,1115 1855,2255
and made {CityHash -} by

836
00:21:35,910 --> 00:21:37,070
0,425 425,670 720,980 980,1085 1085,1160
forking it,| and then they
|然后他们有了一个更新的版本，

837
00:21:37,070 --> 00:21:37,805
0,75 75,180 180,390 390,555 555,735
have a newer version,| we
|我们称之为 FarmHash ，

838
00:21:37,805 --> 00:21:40,475
0,150 150,425 955,1260 1260,1715 2425,2670
call it {FarmHash -},| that
|它的有更好的碰撞率，

839
00:21:40,475 --> 00:21:41,380
0,120 120,270 270,435 435,630 630,905
has even better collision rates,|
|

840
00:21:41,400 --> 00:21:42,515
0,395 395,650 650,800 800,995 995,1115
there's, there's a bunch of
有很多不同的哈希函数，

841
00:21:42,515 --> 00:21:43,990
0,245 535,840 840,1020 1020,1215 1215,1475
different hash functions out there,|
|

842
00:21:44,520 --> 00:21:46,100
0,400 630,1085 1085,1340 1340,1460 1460,1580
but {XXHash-3 - -} is
但是 XXHash-3 是你想要使用的。

843
00:21:46,100 --> 00:21:46,720
0,105 105,195 195,285 285,375 375,620
what you want to use.|
|

844
00:21:47,280 --> 00:21:48,150
0,240 240,420 525,585 585,705 705,870
And so there's a bunch
GitHub 上有一堆这样的存储库，

845
00:21:48,150 --> 00:21:50,120
0,135 135,285 285,1065 1065,1425 1425,1970
of these repositories on Github,|
|

846
00:21:51,010 --> 00:21:51,990
0,260 260,410 410,590 590,710 710,980
or people I've written basically
或者人们[]或基准，

847
00:21:51,990 --> 00:21:54,080
0,390 390,690 690,825 825,1280 1690,2090
{[] -} or benchmarks to,|
|

848
00:21:54,160 --> 00:21:55,905
0,400 660,935 935,1115 1115,1415 1415,1745
{} to run all possible
运行所有可能的哈希函数，

849
00:21:55,905 --> 00:21:56,805
0,285 285,495 495,675 675,750 750,900
hash functions that are out

850
00:21:56,805 --> 00:21:58,005
0,305 535,840 840,1005 1005,1110 1110,1200
there| and see what their
|看看它们的碰撞率是多少，

851
00:21:58,005 --> 00:21:58,830
0,195 195,390 390,585 585,750 750,825
collision rate is,| see what
|看看性能是什么，

852
00:21:58,830 --> 00:22:00,930
0,135 135,360 360,680 1750,1995 1995,2100
the performance is,| so this
|这个是 SMhasher ，

853
00:22:00,930 --> 00:22:02,415
0,195 195,450 450,675 675,1185 1185,1485
is this {Mhasher -} {SMhasher

854
00:22:02,415 --> 00:22:03,735
0,405 405,660 660,825 825,1020 1020,1320
-},| there's another one written
|这是另一个 MurmurHash 的人写的，

855
00:22:03,735 --> 00:22:04,730
0,255 255,360 360,540 540,735 735,995
by the {MurmurHash -} guy|
|

856
00:22:05,140 --> 00:22:06,780
0,260 260,500 500,695 695,1000 1320,1640
and there's another one that's
还有一个是这个方面的 fork ，

857
00:22:06,780 --> 00:22:08,700
0,105 105,300 300,405 405,680 1600,1920
a fork at this,| that's
|这只是[]所有密码学的东西，

858
00:22:08,700 --> 00:22:11,175
0,230 1570,1830 1830,1935 1935,2040 2040,2475
only [] all the cryptography

859
00:22:11,175 --> 00:22:13,365
0,275 625,960 960,1290 1290,1575 1575,2190
stuff,| but for this repository
|但对于这里的存储库，

860
00:22:13,365 --> 00:22:14,460
0,240 240,390 390,510 510,780 780,1095
here,| they have this nice
|他们在这里有一个很好的总结，

861
00:22:14,460 --> 00:22:15,780
0,270 270,620 700,960 960,1125 1125,1320
summary here,| that says these
|说这些是工作最好的，并且有很好的碰撞率，

862
00:22:15,780 --> 00:22:16,935
0,105 105,195 195,450 450,830 880,1155
are the ones that work

863
00:22:16,935 --> 00:22:17,840
0,135 135,315 315,495 495,630 630,905
the best and have good

864
00:22:18,250 --> 00:22:19,380
0,350 350,670
collision rates,|
|

865
00:22:19,380 --> 00:22:21,090
0,120 120,270 270,560 1270,1560 1560,1710
and then the top one
然后这里最上面的是 XXHash-3 ， Facebook 的那个。

866
00:22:21,090 --> 00:22:22,515
0,195 195,465 465,870 870,1125 1125,1425
here is {XXHash-3 - -},

867
00:22:22,515 --> 00:22:24,160
0,345 345,675 675,1025
the Facebook one.|
|

868
00:22:25,540 --> 00:22:26,990
0,260 260,520 750,1010 1010,1205 1205,1450
So again, we don't care,|
所以，我们并不关系，|

869
00:22:27,460 --> 00:22:28,620
0,305 305,365 365,530 530,790 840,1160
it's a hash function, keys
这是一个哈希函数，输入键，输出整型，

870
00:22:28,620 --> 00:22:30,390
0,320 520,975 975,1220 1390,1695 1695,1770
in, integer out,| we'll just
|我们将使用他们给出的任何东西。

871
00:22:30,390 --> 00:22:32,080
0,260 400,675 675,795 795,1040
use whatever they have.|
|

872
00:22:32,120 --> 00:22:33,955
0,245 245,455 455,940 1290,1595 1595,1835
And then there's the full
然后这是所有不同哈希函数的完整列表，

873
00:22:33,955 --> 00:22:35,035
0,240 240,545 655,915 915,990 990,1080
list of all the different

874
00:22:35,035 --> 00:22:36,400
0,180 180,425 715,975 975,1125 1125,1365
hash functions,| some are tailored
|有些是为 ARM 量身定制的，

875
00:22:36,400 --> 00:22:37,350
0,120 120,375 375,615 615,705 705,950
to ARM,| some are tailored
|有些是为 x86 量身定制的，或任何（CPU），

876
00:22:37,430 --> 00:22:39,240
0,275 275,695 695,890 890,1180 1410,1810
{x86 -} or whatever| you
|你可以根据环境获得更多的低级别细节，

877
00:22:39,290 --> 00:22:40,920
0,400
can,

878
00:22:41,070 --> 00:22:41,990
0,245 245,350 350,575 575,785 785,920
you can get, you know,

879
00:22:41,990 --> 00:22:42,995
0,180 180,345 345,585 585,840 840,1005
more low level details based

880
00:22:42,995 --> 00:22:44,105
0,120 120,255 255,525 525,795 795,1110
on the environment,| but {XXHash3
|但 XXHash3 将是一个很好的默认选择。

881
00:22:44,105 --> 00:22:45,095
0,300 300,555 555,795 795,900 900,990
- -} is going to

882
00:22:45,095 --> 00:22:46,450
0,245 385,645 645,840 840,1065 1065,1355
be a good default choice.|
|

883
00:22:50,050 --> 00:22:51,460
0,260 260,410 410,530 530,760
All right, so now.|
好的，现在。|

884
00:22:52,210 --> 00:22:53,940
0,400 630,1010 1010,1205 1205,1505 1505,1730
Assuming, assuming running {XXHash3 -
假设运行 XXHash3 ，

885
00:22:53,940 --> 00:22:54,930
0,260 460,705 705,780 780,855 855,990
-},| we want to talk
|我们想讨论一下哈希表是什么样子的，

886
00:22:54,930 --> 00:22:56,090
0,255 255,510 510,660 660,885 885,1160
about what the hash table

887
00:22:56,410 --> 00:22:57,090
0,260 260,350 350,410 410,530 530,680
is going to look like|
|

888
00:22:57,090 --> 00:22:57,780
0,120 120,255 255,360 360,450 450,690
and how do we handle
以及如何处理碰撞。

889
00:22:57,780 --> 00:22:59,020
0,470
collisions.|
|

890
00:22:59,030 --> 00:22:59,905
0,245 245,335 335,470 470,665 665,875
So for this lecture, I'm
所以在这节课上，我将集中讨论两个最常见的问题，

891
00:22:59,905 --> 00:23:00,720
0,75 75,150 150,330 330,540 540,815
going to focus on the

892
00:23:01,520 --> 00:23:03,115
0,275 275,455 455,695 695,1030 1320,1595
two most common ones,| but
|但第一个是所有系统中最常见的一个，

893
00:23:03,115 --> 00:23:04,150
0,195 195,450 450,750 750,960 960,1035
number one is actually going

894
00:23:04,150 --> 00:23:04,885
0,90 90,255 255,405 405,540 540,735
to be the most common

895
00:23:04,885 --> 00:23:06,390
0,305 325,705 705,1035 1035,1245 1245,1505
one of all the systems,|
|

896
00:23:06,560 --> 00:23:08,980
0,365 365,545 545,970 1920,2270 2270,2420
linear probe hashing,| it's the
线性探测哈希，|这是最简单的，

897
00:23:08,980 --> 00:23:10,160
0,530
simplest,|
|

898
00:23:10,650 --> 00:23:11,615
0,260 260,395 395,590 590,785 785,965
and it seems kind of
在某些方面，它似乎有点脑残，

899
00:23:11,615 --> 00:23:12,610
0,225 225,420 420,570 570,720 720,995
brain dead in some ways,|
|

900
00:23:13,830 --> 00:23:15,590
0,400 810,1115 1115,1340 1340,1490 1490,1760
but because it's so simple,
但因为它是如此简单，它实际上是最快的。

901
00:23:15,590 --> 00:23:16,780
0,195 195,405 405,615 615,705 705,1190
it is actually the fastest,

902
00:23:17,550 --> 00:23:19,640
0,400 1020,1295 1295,1460 1460,1730 1730,2090
right.| And then Cuckoo hashing
|而 Cuckoo 哈希是它的一个变体，

903
00:23:19,640 --> 00:23:20,885
0,290 340,615 615,900 900,1005 1005,1245
is a variant of this,|
|

904
00:23:20,885 --> 00:23:22,265
0,365 475,810 810,1020 1020,1185 1185,1380
that basically does multiple hash
它基本上是执行多个哈希函数。

905
00:23:22,265 --> 00:23:23,450
0,245 535,810 810,975 975,1050 1050,1185
functions.| So there's a bunch
|所以还有很多其他的技术，

906
00:23:23,450 --> 00:23:24,590
0,120 120,240 240,530 610,990 990,1140
of other techniques,| Robin Hood
|Robin Hood 哈希， Hopscotch 哈希，

907
00:23:24,590 --> 00:23:26,050
0,300 300,690 690,1005 1005,1200 1200,1460
hashing, Hopscotch hashing,| Swiss Tables
|来自 Google 的 Swiss 表，

908
00:23:26,700 --> 00:23:28,115
0,275 275,550 810,1085 1085,1265 1265,1415
from Google,| we won't cover
|这学期我们不会讲这些，

909
00:23:28,115 --> 00:23:29,210
0,210 210,375 375,510 510,810 810,1095
that in this semester,| but
|但如果你选了高级课程，

910
00:23:29,210 --> 00:23:29,885
0,165 165,255 255,375 375,510 510,675
if you take the advanced

911
00:23:29,885 --> 00:23:30,995
0,305 415,675 675,795 795,945 945,1110
class,| we will cover those
|我们会讲这些内容。

912
00:23:30,995 --> 00:23:31,860
0,275
things.|
|

913
00:23:31,860 --> 00:23:32,490
0,165 165,240 240,330 330,465 465,630
And I would say that,
我要说的是，目前的研究基本上表明，

914
00:23:32,490 --> 00:23:34,125
0,290 370,675 675,930 930,1275 1275,1635
the current research basically shows

915
00:23:34,125 --> 00:23:35,960
0,365 655,930 930,1230 1230,1545 1545,1835
that,| the Linear Probe stuff
|线性探测的东西和 Swiss 表是最快的，

916
00:23:36,370 --> 00:23:37,695
0,335 335,545 545,725 725,1000 1050,1325
and the Swiss Tables are

917
00:23:37,695 --> 00:23:38,820
0,135 135,480 480,645 645,840 840,1125
the fastest ones,| all these
|所有这些额外的花式版本是，

918
00:23:38,820 --> 00:23:41,960
0,380 1120,1470 1470,1820
extra fancy versions

919
00:23:42,370 --> 00:23:44,020
0,400
are,|
|

920
00:23:44,620 --> 00:23:46,350
0,400 810,1145 1145,1355 1355,1490 1490,1730
as they try to be,
他们试图提高性能，

921
00:23:46,350 --> 00:23:47,040
0,255 255,375 375,435 435,510 510,690
they try to be more

922
00:23:47,040 --> 00:23:48,465
0,300 300,585 585,825 825,1125 1125,1425
performance,| because they avoid having
|因为他们避免了更长的寻找键的时间，

923
00:23:48,465 --> 00:23:50,100
0,335 505,795 795,1020 1020,1305 1305,1635
to spend longer time looking

924
00:23:50,100 --> 00:23:52,125
0,380 700,990 990,1280 1510,1800 1800,2025
for for keys| by moving
|当插入时，移动东西时，

925
00:23:52,125 --> 00:23:53,355
0,270 270,600 600,900 900,1080 1080,1230
things around, when when you

926
00:23:53,355 --> 00:23:55,020
0,485 715,1115
insert,| but
|但是所有移动东西的工作都是性能损失，

927
00:23:55,020 --> 00:23:55,860
0,225 225,450 450,600 600,705 705,840
all that work of moving

928
00:23:55,860 --> 00:23:56,895
0,195 195,435 435,690 690,870 870,1035
things around is is a

929
00:23:56,895 --> 00:23:58,485
0,225 225,755 1075,1335 1335,1485 1485,1590
performance penalty| and you're better
|你最好在哈希中做一些简单的事情。

930
00:23:58,485 --> 00:24:00,165
0,120 120,345 345,725 1075,1350 1350,1680
off just doing the naive

931
00:24:00,165 --> 00:24:02,900
0,275 355,600 600,690 690,1115
thing in your hashing.|
|

932
00:24:04,290 --> 00:24:05,300
0,260 260,515 515,815 815,875 875,1010
This question, there's a reason
这个问题，我们不讨论链哈希的原因，

933
00:24:05,300 --> 00:24:05,990
0,210 210,405 405,465 465,555 555,690
why we're not talking about

934
00:24:05,990 --> 00:24:07,540
0,180 180,650 700,945 945,1230 1230,1550
chain hashing,| because that's dynamic,
|因为它是动态的，它是下一个，

935
00:24:08,190 --> 00:24:09,920
0,335 335,410 410,670
that'll be next,|
|

936
00:24:10,850 --> 00:24:12,295
0,290 290,650 650,845 845,1150 1170,1445
chain hashing can grow, this
链哈希可以增长，这个是固定大小，

937
00:24:12,295 --> 00:24:13,600
0,150 150,300 300,575
is fixed size,|
|

938
00:24:14,030 --> 00:24:14,650
0,215 215,260 260,350 350,470 470,620
that we'll cover that later
我们会在这学期，这节课的晚些时候讲到，

939
00:24:14,650 --> 00:24:15,505
0,120 120,330 330,525 525,690 690,855
this semester or later this

940
00:24:15,505 --> 00:24:16,440
0,275
class,|
|

941
00:24:17,970 --> 00:24:19,070
0,275 275,380 380,500 500,740 740,1100
these are all static hashing
这些都是静态哈希方案。

942
00:24:19,070 --> 00:24:20,000
0,410
schemes.|
|

943
00:24:21,870 --> 00:24:23,380
0,335 335,665 665,830 830,1085 1085,1510
There's variations of linear probing,
有各种各样的线性探测，

944
00:24:23,400 --> 00:24:27,065
0,430 510,940 960,1535 1535,2020 3330,3665
{ - -} probing,| let's
|让我们简单一点。

945
00:24:27,065 --> 00:24:28,160
0,105 105,210 210,455
keep it simple.|
|

946
00:24:28,860 --> 00:24:29,885
0,275 275,455 455,665 665,860 860,1025
All right, so Linear Probe
好的，所以线性探测哈希很简单，

947
00:24:29,885 --> 00:24:34,520
0,360 360,665 3325,3660 3660,3995
hashing is really simple,|
|

948
00:24:34,520 --> 00:24:36,130
0,120 120,240 240,495 495,860 1210,1610
it's a giant array of
它是一个巨大的 slot 数组，

949
00:24:37,530 --> 00:24:40,010
0,430 1050,1450 2040,2330 2330,2390 2390,2480
slots| and we're going to
|我们要哈希到它，

950
00:24:40,010 --> 00:24:42,300
0,330 330,555 555,890
hash into it,|
|

951
00:24:42,670 --> 00:24:43,815
0,260 260,455 455,710 710,890 890,1145
if we insert, we hash
如果我们插入，我们会哈希到它，

952
00:24:43,815 --> 00:24:45,105
0,195 195,515 565,855 855,1035 1035,1290
into it,| if the slot
|如果 slot 是空的，

953
00:24:45,105 --> 00:24:46,485
0,225 225,545 715,975 975,1260 1260,1380
is free,| we insert the
|我们就插入我们要找的东西，

954
00:24:46,485 --> 00:24:47,700
0,105 105,255 255,420 420,755 925,1215
thing we're looking for,| if
|如果 slot 不是空的，

955
00:24:47,700 --> 00:24:48,860
0,165 165,360 360,540 540,795 795,1160
the slot is not free,|
|

956
00:24:49,150 --> 00:24:50,010
0,245 245,410 410,605 605,740 740,860
we just look at the
我们只需查看下一个 slot 并插入到那里，

957
00:24:50,010 --> 00:24:52,845
0,195 195,560 910,1310 2200,2700 2700,2835
next slot and insert there

958
00:24:52,845 --> 00:24:53,430
0,90 90,210 210,360 360,480 480,585
if we can,| or we
|或者我们继续寻找，直到我们有一个空闲的 slot ，

959
00:24:53,430 --> 00:24:54,960
0,210 210,560 1060,1305 1305,1410 1410,1530
keep looking until we have

960
00:24:54,960 --> 00:24:56,505
0,150 150,345 345,680 700,1065 1065,1545
a free slot,| potentially wrapping
|可能会环绕，

961
00:24:56,505 --> 00:24:57,520
0,305
around,|
|

962
00:24:57,950 --> 00:24:58,705
0,230 230,335 335,470 470,575 575,755
until we find a free
直到我们找到一个空闲的地方。

963
00:24:58,705 --> 00:24:59,840
0,335
location.|
|

964
00:24:59,840 --> 00:25:02,255
0,150 150,390 390,720 720,1100 2140,2415
And then if we loop
然后如果我们循环回来，

965
00:25:02,255 --> 00:25:03,860
0,165 165,330 330,495 495,660 660,1605
back around| and realize we're
|意识到我们在开始的 slot ，

966
00:25:03,860 --> 00:25:04,625
0,105 105,270 270,480 480,630 630,765
at the slot where we

967
00:25:04,625 --> 00:25:05,645
0,180 180,485 505,765 765,885 885,1020
started that,| then we know
|那么我们知道哈希表是满的，

968
00:25:05,645 --> 00:25:06,520
0,120 120,300 300,435 435,600 600,875
the hash table is full|
|

969
00:25:06,780 --> 00:25:08,590
0,260 260,350 350,440 440,700 1410,1810
and we have to {}
我们必须中止它，

970
00:25:08,880 --> 00:25:11,360
0,400 780,1180 1200,1625 1625,1900 2190,2480
and {you,know} abort it,| double
|加倍大小，重新哈希所有东西，

971
00:25:11,360 --> 00:25:12,820
0,165 165,440 460,720 720,1080 1080,1460
the size and rehash everything,|
|

972
00:25:13,170 --> 00:25:13,940
0,290 290,365 365,485 485,620 620,770
it's a simple way to
这是一种简单的增长方式。

973
00:25:13,940 --> 00:25:14,680
0,150 150,410
grow it,

974
00:25:14,940 --> 00:25:16,670
0,400 960,1250 1250,1430 1430,1580 1580,1730
right.| So the state, our
|所以我们对这个的实现来自 Google ，

975
00:25:16,670 --> 00:25:18,125
0,290 520,795 795,1050 1050,1290 1290,1455
implementation for this or one

976
00:25:18,125 --> 00:25:19,745
0,305 505,765 765,900 900,1335 1335,1620
state is this [] thing

977
00:25:19,745 --> 00:25:23,315
0,395 685,975 975,1265 2755,3155 3235,3570
from, from Google,| and it's
|它是 flat_hash_map 类型或数据结构，

978
00:25:23,315 --> 00:25:25,325
0,105 105,365 445,935 985,1385 1615,2010
the {flat_hash -}, {flat_hash_map -

979
00:25:25,325 --> 00:25:27,460
0,275 805,1185 1185,1545 1545,1830 1830,2135
-} type or data structure,|
|

980
00:25:28,160 --> 00:25:29,035
0,305 305,455 455,560 560,695 695,875
and they have pretty good
他们有非常好的文档来描述它是如何工作的，

981
00:25:29,035 --> 00:25:30,145
0,330 330,480 480,755 775,1020 1020,1110
documentation to describe actually how

982
00:25:30,145 --> 00:25:31,210
0,105 105,365 595,870 870,990 990,1065
it works,| and some of
|并且他们所做的一些优化将涵盖在内。

983
00:25:31,210 --> 00:25:32,275
0,105 105,450 450,645 645,840 840,1065
the optimizations they do will

984
00:25:32,275 --> 00:25:33,180
0,275
cover.|
|

985
00:25:33,280 --> 00:25:34,425
0,245 245,350 350,485 485,755 755,1145
So this is sometimes called
所以这有时被称为开放寻址哈希，

986
00:25:34,425 --> 00:25:36,560
0,300 300,785 835,1155 1155,1575 1575,2135
open addressing, open addressing hashing,|
|

987
00:25:36,730 --> 00:25:38,720
0,365 365,730 1350,1595 1595,1715 1715,1990
because the idea is that
因为它的思想是，

988
00:25:38,890 --> 00:25:39,560
0,400
it,|
|

989
00:25:39,830 --> 00:25:41,170
0,320 320,515 515,850 960,1235 1235,1340
there's no guarantee that for
不能保证对于给定的键，

990
00:25:41,170 --> 00:25:42,475
0,90 90,315 315,680 910,1230 1230,1305
a given key,| it's going
|它将始终位于 slot 中的相同地址或相同位置，

991
00:25:42,475 --> 00:25:43,405
0,195 195,450 450,660 660,810 810,930
to always be in the

992
00:25:43,405 --> 00:25:44,530
0,225 225,465 465,630 630,855 855,1125
same address or same location

993
00:25:44,530 --> 00:25:45,970
0,180 180,330 330,650 970,1275 1275,1440
in the slot,| depending on
|取决于在它之前插入了什么，

994
00:25:45,970 --> 00:25:47,245
0,165 165,420 420,675 675,870 870,1275
what, what, what got inserted

995
00:25:47,245 --> 00:25:48,700
0,195 195,545 745,1020 1020,1245 1245,1455
before it,| it may, it
|它可能会移来移去。

996
00:25:48,700 --> 00:25:50,100
0,150 150,300 300,480 480,800
may get moved around,

997
00:25:50,430 --> 00:25:51,640
0,400
right.|
|

998
00:25:51,640 --> 00:25:52,960
0,315 315,660 660,885 885,975 975,1320
If you get a dictionary
如果你得到一个 Python 的字典，

999
00:25:52,960 --> 00:25:54,145
0,135 135,525 525,735 735,930 930,1185
in Python,| this is essentially
|这基本上也是你要得到的东西。

1000
00:25:54,145 --> 00:25:55,380
0,335 415,720 720,825 825,975 975,1235
what you're getting as well.|
|

1001
00:25:57,725 --> 00:25:58,025
0,45 45,105 105,165 165,225 225,300
So let's see how it
所以让我们来看看它是如何工作的。

1002
00:25:58,025 --> 00:25:59,360
0,245 655,930 930,1110 1110,1260 1260,1335
works.| So say we want
|假设我们想要插入键 A ，

1003
00:25:59,360 --> 00:26:00,920
0,60 60,390 390,615 615,890
to insert key A,

1004
00:26:00,920 --> 00:26:01,960
0,210 210,405 405,510 510,780 780,1040
right,| so we hash it,|
|所以我们对它进行哈希，|

1005
00:26:02,160 --> 00:26:03,170
0,365 365,620 620,755 755,875 875,1010
mod by the number of
根据我们拥有的 slot 的数量取模，

1006
00:26:03,170 --> 00:26:04,295
0,165 165,270 270,360 360,620 850,1125
slots that we have| and
|然后我们到达这个位置，

1007
00:26:04,295 --> 00:26:04,940
0,105 105,180 180,300 300,495 495,645
then we hit land this

1008
00:26:04,940 --> 00:26:06,125
0,150 150,420 420,770 880,1110 1110,1185
a location here,| so that
|这样我们就可以插入键，和值一起，

1009
00:26:06,125 --> 00:26:08,380
0,105 105,575 925,1245 1245,1565 1855,2255
we insert our key along

1010
00:26:08,700 --> 00:26:10,140
0,245 245,455 455,820
the value together,

1011
00:26:10,140 --> 00:26:11,805
0,380 940,1200 1200,1305 1305,1470 1470,1665
right,| again, the reason why
|再次，我们需要键的原因是，

1012
00:26:11,805 --> 00:26:12,630
0,120 120,240 240,390 390,600 600,825
we need the key is

1013
00:26:12,630 --> 00:26:13,320
0,180 180,345 345,465 465,585 585,690
because,| if we go to
|如果我们再次查找 A ，

1014
00:26:13,320 --> 00:26:15,420
0,105 105,530 1300,1695 1695,1935 1935,2100
a lookup again for looking

1015
00:26:15,420 --> 00:26:17,250
0,180 180,440 790,1065 1065,1340 1540,1830
for A,| we need, we
|我们需要哈希到相同的位置，

1016
00:26:17,250 --> 00:26:18,260
0,255 255,360 360,450 450,660 660,1010
hash to the same location,|
|

1017
00:26:18,550 --> 00:26:19,245
0,260 260,395 395,515 515,605 605,695
but now we got to
但现在我们必须做一个相等检查，

1018
00:26:19,245 --> 00:26:20,190
0,90 90,225 225,600 600,780 780,945
do an equality check| to
|看看我们正在寻找的键是否是给定 slot 中的键。

1019
00:26:20,190 --> 00:26:21,195
0,120 120,375 375,660 660,855 855,1005
see whether the key that

1020
00:26:21,195 --> 00:26:21,945
0,135 135,285 285,465 465,600 600,750
we're looking for is the

1021
00:26:21,945 --> 00:26:22,935
0,270 270,570 570,735 735,825 825,990
key in in a given

1022
00:26:22,935 --> 00:26:23,760
0,365
slot.|
|

1023
00:26:25,510 --> 00:26:26,430
0,290 290,545 545,770 770,860 860,920
Same thing, so if you
一样的东西，如果你想要对 B 进行哈希，

1024
00:26:26,430 --> 00:26:27,255
0,75 75,150 150,345 345,570 570,825
want to hash B,| same
|同样的事情，在这里哈希，对 slot 的数量取模，

1025
00:26:27,255 --> 00:26:29,445
0,305 415,840 840,1145 1765,2055 2055,2190
thing, hash here mod by

1026
00:26:29,445 --> 00:26:30,165
0,75 75,180 180,300 300,525 525,720
the number of slots,| we
|我们最终在这里，排在顶部。

1027
00:26:30,165 --> 00:26:31,350
0,90 90,195 195,455 835,1080 1080,1185
end up here and we

1028
00:26:31,350 --> 00:26:32,460
0,105 105,195 195,300 300,560
sort at the top.|
|

1029
00:26:32,850 --> 00:26:34,085
0,400 570,830 830,920 920,995 995,1235
So now we want to
所以现在我们要插入 C ，

1030
00:26:34,085 --> 00:26:35,780
0,575 595,995
insert C,|
|

1031
00:26:36,180 --> 00:26:37,235
0,245 245,350 350,635 635,860 860,1055
so we hash C,| it
所以我们哈希 C ，|它到达 A 所在的相同位置，

1032
00:26:37,235 --> 00:26:38,195
0,210 210,375 375,465 465,675 675,960
lands to the same location

1033
00:26:38,195 --> 00:26:39,800
0,195 195,360 360,665 1105,1380 1380,1605
where A is,| but that
|但是那个 slot 被占用了，

1034
00:26:39,800 --> 00:26:42,050
0,410 430,830 1120,1670 1900,2130 2130,2250
slot is occupied,| so we
|所以我们不能把它插入到那里，

1035
00:26:42,050 --> 00:26:43,535
0,270 270,540 540,660 660,920 1240,1485
can't insert it there,| so
|所以我们只需往下走到下一个 slot ，

1036
00:26:43,535 --> 00:26:44,795
0,90 90,240 240,510 510,875 955,1260
we just follow down to

1037
00:26:44,795 --> 00:26:46,265
0,150 150,300 300,635 865,1140 1140,1470
the next slot| and insert
|然后在那里插入我们的键。

1038
00:26:46,265 --> 00:26:47,320
0,150 150,300 300,575
our key there,

1039
00:26:47,620 --> 00:26:48,780
0,400
right.|
|

1040
00:26:49,930 --> 00:26:50,940
0,275 275,410 410,545 545,770 770,1010
Same thing with D,| D
对于 D 也是同样的事情，|一旦 D 去到 C 所在的地方，

1041
00:26:50,940 --> 00:26:51,630
0,165 165,270 270,360 360,525 525,690
once to go where C

1042
00:26:51,630 --> 00:26:52,890
0,260 400,690 690,990 990,1110 1110,1260
is,| it can't, because that
|它就不能，因为那个 slot 被占用了，

1043
00:26:52,890 --> 00:26:54,750
0,360 360,800 1090,1485 1485,1740 1740,1860
slot occupied,| so it just
|所以它向下移动到下一个，然后插入到那里。

1044
00:26:54,750 --> 00:26:55,245
0,135 135,255 255,330 330,390 390,495
moves down to the next

1045
00:26:55,245 --> 00:26:56,330
0,275 295,555 555,675 675,810 810,1085
one and inserts it there.|
|

1046
00:26:56,860 --> 00:26:57,710
0,245 245,335 335,440 440,575 575,850
And we just keep going
我们继续，对于我们想要存储的所有其他键。

1047
00:26:57,760 --> 00:26:58,590
0,305 305,455 455,590 590,710 710,830
down for all the other

1048
00:26:58,590 --> 00:26:59,600
0,255 255,480 480,600 600,735 735,1010
keys we want to store,

1049
00:27:00,080 --> 00:27:01,060
0,290
right.|
|

1050
00:27:01,250 --> 00:27:02,215
0,245 245,350 350,500 500,710 710,965
And in this case here,|
在这种情况下，|

1051
00:27:02,215 --> 00:27:04,560
0,335 445,735 735,945 945,1265 1945,2345
if, say, if F, this
假设 F 这个空间被占用了，

1052
00:27:04,610 --> 00:27:06,240
0,290 290,515 515,940
space was occupied,|
|

1053
00:27:06,280 --> 00:27:07,280
0,305 305,440 440,515 515,680 680,1000
F kind of wrapped around,
F 绕回，从顶部开始，插入到顶部，

1054
00:27:07,450 --> 00:27:08,355
0,245 245,320 320,440 440,695 695,905
start at the beginning and

1055
00:27:08,355 --> 00:27:09,680
0,285 285,420 420,525 525,785
insert at the top,|
|

1056
00:27:10,520 --> 00:27:11,215
0,245 245,335 335,410 410,530 530,695
think of it as a
把它想象成一个巨大的圆形缓冲区。

1057
00:27:11,215 --> 00:27:12,760
0,240 240,585 585,1025
giant circular buffer.|
|

1058
00:27:14,450 --> 00:27:16,180
0,305 305,515 515,820
Pretty simple, right?|
很简单，对吧？|

1059
00:27:18,460 --> 00:27:19,335
0,245 245,350 350,485 485,665 665,875
What are some potential problems
这有哪些潜在的问题？

1060
00:27:19,335 --> 00:27:20,480
0,150 150,395
with this?|
|

1061
00:27:20,620 --> 00:27:22,405
0,380 460,1080 1080,1500 1500,1650 1650,1785

1062
00:27:22,405 --> 00:27:23,380
0,180 180,330 330,510 510,845

1063
00:27:23,870 --> 00:27:25,030
0,275 275,440 440,815 815,995 995,1160
He says deletion sucks,| says
他说，删除很糟糕，|意味着你失去了整个链，

1064
00:27:25,030 --> 00:27:25,675
0,105 105,210 210,300 300,405 405,645
you lose the whole chain,|
|

1065
00:27:25,675 --> 00:27:26,780
0,195 195,240 240,285 285,515
what do you mean?|
你是什么意思？|

1066
00:27:26,780 --> 00:27:28,150
0,165 165,345 345,600 600,950 970,1370

1067
00:27:28,200 --> 00:27:29,225
0,275 275,485 485,695 695,845 845,1025

1068
00:27:29,225 --> 00:27:31,040
0,270 270,525 525,720 720,1025 1285,1815

1069
00:27:31,040 --> 00:27:32,435
0,240 240,555 555,885 885,1155 1155,1395

1070
00:27:32,435 --> 00:27:33,280
0,305

1071
00:27:33,840 --> 00:27:34,470
0,165 165,255 255,345 345,480 480,630

1072
00:27:34,470 --> 00:27:35,655
0,150 150,600 600,795 795,990 990,1185

1073
00:27:35,655 --> 00:27:36,705
0,180 180,285 285,480 480,720 720,1050

1074
00:27:36,705 --> 00:27:37,060
0,315

1075
00:27:39,720 --> 00:27:41,240
0,320 320,500 500,650 650,940 1290,1520
Right, so he says,| I
好的，所以他说，|我不认为所有的幻灯片都提前了，

1076
00:27:41,240 --> 00:27:41,810
0,105 105,240 240,315 315,420 420,570
don't think all the slides

1077
00:27:41,810 --> 00:27:42,910
0,120 120,195 195,440 610,855 855,1100
ahead of time,| what happens,
|如果删除 C ，会发生什么情况？

1078
00:27:43,530 --> 00:27:44,375
0,245 245,365 365,485 485,635 635,845
what happens if you delete

1079
00:27:44,375 --> 00:27:45,880
0,305
C?|
|

1080
00:27:46,070 --> 00:27:48,040
0,400 660,980 980,1300 1440,1715 1715,1970
So delete C, we hash
所以删除 C ，我们对它进行哈希，

1081
00:27:48,040 --> 00:27:49,195
0,260 340,630 630,825 825,990 990,1155
it,| we land where A
|我们落在 A 所在的地方，

1082
00:27:49,195 --> 00:27:50,280
0,305
is,

1083
00:27:50,290 --> 00:27:52,050
0,400 690,965 965,1085 1085,1330 1470,1760
right,| now we do the
|现在我们做相等检查，看看 C 是否等于 A ，

1084
00:27:52,050 --> 00:27:53,415
0,240 240,450 450,555 555,800 1090,1365
equality check to see does

1085
00:27:53,415 --> 00:27:55,110
0,225 225,465 465,755 895,1295 1465,1695
A equal C,| no, so
|不，所以我们知道这不是我们要找的键，

1086
00:27:55,110 --> 00:27:55,770
0,75 75,195 195,450 450,540 540,660
we know that's not the

1087
00:27:55,770 --> 00:27:56,910
0,120 120,255 255,390 390,710 880,1140
key we're looking for| and
|然后我们继续前进，

1088
00:27:56,910 --> 00:27:57,855
0,120 120,255 255,435 435,720 720,945
then we keep going| until
|直到我们找到空的 slot 或我们要找的键，

1089
00:27:57,855 --> 00:27:58,845
0,105 105,240 240,450 450,750 750,990
we find empty slot or

1090
00:27:58,845 --> 00:27:59,720
0,150 150,255 255,390 390,540 540,875
the key we're looking for,|
|

1091
00:27:59,830 --> 00:28:00,585
0,230 230,290 290,410 410,590 590,755
so in this case here,|
在这种情况下，|

1092
00:28:00,585 --> 00:28:01,650
0,195 195,420 420,630 630,810 810,1065
after jumping down, we find
在跳下之后，我们找到 C ，

1093
00:28:01,650 --> 00:28:02,970
0,380 640,915 915,1080 1080,1215 1215,1320
C| and now we need
|现在我们需要删除它，

1094
00:28:02,970 --> 00:28:04,020
0,165 165,330 330,590
to delete it,|
|

1095
00:28:04,470 --> 00:28:05,585
0,260 260,455 455,650 650,890 890,1115
but now we have an
但现在我们有一个空的空间，就像他说的，

1096
00:28:05,585 --> 00:28:06,760
0,195 195,495 495,720 720,885 885,1175
empty space, as he said,|
|

1097
00:28:07,290 --> 00:28:08,405
0,380 380,635 635,815 815,995 995,1115
so if I try to
所以如果我试着去查找 D ，

1098
00:28:08,405 --> 00:28:09,365
0,195 195,390 390,495 495,795 795,960
go do a lookup on

1099
00:28:09,365 --> 00:28:10,970
0,165 165,360 360,665 1135,1515 1515,1605
something like D,| D {is,going}
|D 会哈希到这个空的地方，

1100
00:28:10,970 --> 00:28:11,810
0,90 90,375 375,495 495,600 600,840
to hash to this empty

1101
00:28:11,810 --> 00:28:12,900
0,380
spot,|
|

1102
00:28:14,080 --> 00:28:14,655
0,245 245,335 335,410 410,470 470,575
and it's going to say,
它会说，好的，这里什么都没有，

1103
00:28:14,655 --> 00:28:15,560
0,165 165,330 330,495 495,645 645,905
oh well, nothing is here,

1104
00:28:16,260 --> 00:28:17,240
0,210 210,345 345,465 465,660 660,980
right,| but it really is,
|但它真的是，在下一个 slot ，

1105
00:28:17,560 --> 00:28:18,240
0,245 245,320 320,455 455,545 545,680
you know, it's the next

1106
00:28:18,240 --> 00:28:19,380
0,240 240,495 495,765 765,1005 1005,1140
slot down,| but because the
|但因为协议的工作方式，方案的工作方式，

1107
00:28:19,380 --> 00:28:20,670
0,105 105,240 240,600 600,890 1000,1290
way the protocol works, the

1108
00:28:20,670 --> 00:28:22,005
0,180 180,470 760,1020 1020,1185 1185,1335
scheme works,| if I see
|如果我看到一个空的 slot ，我就知道我完成了，

1109
00:28:22,005 --> 00:28:23,175
0,90 90,270 270,665 805,1050 1050,1170
an empty slot, then I

1110
00:28:23,175 --> 00:28:24,240
0,120 120,270 270,515
know I'm done,

1111
00:28:24,820 --> 00:28:25,920
0,400
right.|
|

1112
00:28:26,840 --> 00:28:27,215
0,60 60,120 120,210 210,315 315,375
So what's one way to
那么，处理这一问题的一种方法是什么？

1113
00:28:27,215 --> 00:28:28,340
0,135 135,455
handle this?|
|

1114
00:28:30,650 --> 00:28:32,290
0,620 620,1070 1070,1280 1280,1415 1415,1640
Gravestone, tombstone, that's one approach,
墓碑，这是一种方法，是的，

1115
00:28:32,290 --> 00:28:34,690
0,320 1660,1950 1950,2040 2040,2160 2160,2400
yes,| we'll get it there,|
|我们会到那里，|

1116
00:28:34,690 --> 00:28:35,755
0,380 430,690 690,810 810,930 930,1065
which that is the correct
这就是正确的答案。

1117
00:28:35,755 --> 00:28:37,480
0,275
answer.|
|

1118
00:28:37,480 --> 00:28:38,560
0,315 315,555 555,720 720,870 870,1080
So you could do this,|
所以你可以这样做，|

1119
00:28:38,560 --> 00:28:40,660
0,210 210,330 330,590 940,1520 1720,2100
you could just rehash, move
你可以重新哈希，向上移动，

1120
00:28:40,660 --> 00:28:42,340
0,380 490,890
up, right,|
|

1121
00:28:42,490 --> 00:28:43,230
0,245 245,350 350,440 440,590 590,740
is that a good idea
这是个好主意还是坏主意，

1122
00:28:43,230 --> 00:28:44,070
0,60 60,135 135,330 330,615 615,840
or a bad idea,| well,
|显然这是个坏主意，

1123
00:28:44,070 --> 00:28:44,790
0,150 150,300 300,360 360,525 525,720
clearly it's a bad idea,|
|

1124
00:28:44,790 --> 00:28:45,360
0,120 120,240 240,360 360,465 465,570
because I said no one
因为我说过没人会这么做，

1125
00:28:45,360 --> 00:28:46,815
0,150 150,440 1000,1245 1245,1350 1350,1455
does this,| but why is
|但为什么这是个坏主意呢？

1126
00:28:46,815 --> 00:28:47,960
0,75 75,135 135,300 300,635
it a bad idea?|
|

1127
00:28:49,900 --> 00:28:51,260
0,335 335,575 575,800 800,1040 1040,1360
Move everything,| again, think huge,
移动所有东西，|想象大一点，十亿个键，

1128
00:28:51,310 --> 00:28:52,890
0,275 275,515 515,880 1230,1490 1490,1580
a billion keys,| I going
|我要去重新哈希每一个，那是很糟糕的，

1129
00:28:52,890 --> 00:28:54,210
0,120 120,330 330,750 750,1050 1050,1320
to go rehash everyone that

1130
00:28:54,210 --> 00:28:57,030
0,150 150,440 610,1010 1510,1910 2470,2820
be terrible, right,| so it's
|所以它非常昂贵，没有人做这个。

1131
00:28:57,030 --> 00:28:58,260
0,195 195,525 525,900 900,1125 1125,1230
super expensive and no one

1132
00:28:58,260 --> 00:29:00,440
0,150 150,440
does this.|
|

1133
00:29:01,640 --> 00:29:03,145
0,350 350,455 455,635 635,970 1140,1505
Skipping through this, right.| So
跳过这个。|所以，是的，这没有道理，

1134
00:29:03,145 --> 00:29:04,990
0,365 1195,1455 1455,1590 1590,1725 1725,1845
yeah, this is not the

1135
00:29:04,990 --> 00:29:05,500
0,135 135,240 240,360 360,435 435,510
sense,| you don't want to
|你不想做这个。

1136
00:29:05,500 --> 00:29:07,480
0,75 75,320 1300,1575 1575,1740 1740,1980
do this.| The correct solution
|正确的答案是他说的是墓碑，

1137
00:29:07,480 --> 00:29:08,305
0,210 210,345 345,480 480,600 600,825
is what he was saying

1138
00:29:08,305 --> 00:29:09,625
0,365 685,930 930,1080 1080,1185 1185,1320
is what it's called a

1139
00:29:09,625 --> 00:29:11,380
0,485 925,1170 1170,1320 1320,1545 1545,1755
tombstone,| and the idea here
|这里的想法是，

1140
00:29:11,380 --> 00:29:12,600
0,165 165,345 345,570 570,855 855,1220
is that,| I delete C,|
|我删除 C ，|

1141
00:29:13,550 --> 00:29:14,695
0,320 320,515 515,755 755,980 980,1145
but instead, again, instead of
但是不是将其设置为空，

1142
00:29:14,695 --> 00:29:16,210
0,210 210,360 360,495 495,785 1195,1515
setting it as empty,| I'm
|我将在这里放一个小标记，

1143
00:29:16,210 --> 00:29:17,125
0,105 105,210 210,270 270,435 435,915
gonna put a little marker

1144
00:29:17,125 --> 00:29:18,020
0,275
here,|
|

1145
00:29:18,270 --> 00:29:20,390
0,275 275,550 600,1000 1140,1570 1830,2120
to say this slot,| there
表示这个 slot ，|曾经有一个键在这里，现在它被删除了。

1146
00:29:20,390 --> 00:29:21,275
0,180 180,345 345,495 495,690 690,885
was a key here and

1147
00:29:21,275 --> 00:29:22,900
0,135 210,285 285,465 465,935
now it's been deleted.|
|

1148
00:29:22,940 --> 00:29:24,235
0,260 260,440 440,710 710,1040 1040,1295
So that way,| if anybody
这样的话，|如果有人过来，比如，做一个查找 D ，

1149
00:29:24,235 --> 00:29:25,405
0,195 195,515 565,870 870,1050 1050,1170
comes along like doing a

1150
00:29:25,405 --> 00:29:27,210
0,180 180,330 330,635 1015,1410 1410,1805
lookup in D,| it sees
|它看到墓碑，

1151
00:29:27,320 --> 00:29:28,525
0,305 305,770 770,920 920,1070 1070,1205
the tombstone| and says, well,
|说，嗯，它不是空的，

1152
00:29:28,525 --> 00:29:30,040
0,180 180,300 300,575 895,1230 1230,1515
it's not empty,| something was
|有东西曾经在这里，

1153
00:29:30,040 --> 00:29:31,780
0,350 1090,1320 1320,1470 1470,1590 1590,1740
here,| but there's nothing here
|但这里没有我要找的东西，

1154
00:29:31,780 --> 00:29:32,665
0,120 120,330 330,480 480,720 720,885
that I'm looking for,| so
|所以让我往下看，继续扫描，

1155
00:29:32,665 --> 00:29:33,685
0,105 105,285 285,435 435,665 745,1020
let me, let me look

1156
00:29:33,685 --> 00:29:35,490
0,275 775,1050 1050,1230 1230,1515 1515,1805
down and keep scanning along|
|

1157
00:29:35,960 --> 00:29:36,730
0,245 245,365 365,515 515,650 650,770
until I find the thing
直到我找到我要找的东西。

1158
00:29:36,730 --> 00:29:37,900
0,180 180,330 330,650
I'm looking for,

1159
00:29:38,100 --> 00:29:39,200
0,400
right.|
|

1160
00:29:40,940 --> 00:29:42,600
0,400 480,725 725,845 845,1295 1295,1660
So you can reuse these,|
所以你可以重复使用这些，|

1161
00:29:44,420 --> 00:29:45,715
0,245 245,365 365,770 770,1040 1040,1295
you can reuse the slot
你可以重新使用带有墓碑标记的 slot 给新的键，

1162
00:29:45,715 --> 00:29:46,270
0,180 180,255 255,345 345,450 450,555
with the marker of the

1163
00:29:46,270 --> 00:29:48,265
0,375 375,555 555,765 765,1100 1750,1995
tombstone for new keys,| you
|你只需要在它上面插入，

1164
00:29:48,265 --> 00:29:49,135
0,105 105,420 420,600 600,765 765,870
just insert over top of

1165
00:29:49,135 --> 00:29:49,840
0,105 105,210 210,315 315,555 555,705
it| and that doesn't break
|这不会打破流程或哈希表中任何内容。

1166
00:29:49,840 --> 00:29:51,280
0,180 180,420 420,770 850,1215 1215,1440
the flow or break anything

1167
00:29:51,280 --> 00:29:53,230
0,260 610,1010 1330,1605 1605,1740 1740,1950
else in, in the hash

1168
00:29:53,230 --> 00:29:54,740
0,260 610,1010
table, right.|
|

1169
00:29:55,080 --> 00:29:56,045
0,275 275,470 470,650 650,815 815,965
Now, maybe the case you
现在，也许你想定期地运行一个垃圾收集，

1170
00:29:56,045 --> 00:29:56,825
0,75 75,165 165,585 585,690 690,780
want to periodically run a

1171
00:29:56,825 --> 00:29:57,725
0,240 240,480 480,690 690,780 780,900
garbage collection,| because you can
|因为你可以开始积累大量的这些墓碑，

1172
00:29:57,725 --> 00:29:58,640
0,120 120,570 570,720 720,795 795,915
start accumulating much of these

1173
00:29:58,640 --> 00:29:59,840
0,435 435,615 615,750 750,870 870,1200
tombstones| and it's just wasted
|那是在浪费空间，

1174
00:29:59,840 --> 00:30:01,205
0,290 580,855 855,1020 1020,1110 1110,1365
space,| if you're not reusing
|如果你不重复使用它们，

1175
00:30:01,205 --> 00:30:03,970
0,335 1585,1985 2185,2415 2415,2505 2505,2765
them,| but for our purposes,
|但是对于我们的目的，我们可以忽略它。

1176
00:30:04,800 --> 00:30:06,220
0,260 260,410 410,575 575,850
we can ignore that.|
|

1177
00:30:07,530 --> 00:30:08,350
0,245 245,350 350,440 440,545 545,820
So I want to put
所以我想放入 G ，

1178
00:30:08,400 --> 00:30:09,500
0,320 320,605 605,845 845,980 980,1100
say G,| G can go
|G 可以在这里，

1179
00:30:09,500 --> 00:30:10,930
0,135 135,410 520,885 885,1185 1185,1430
right here| and that's fine.|
|这是可以的。|

1180
00:30:12,900 --> 00:30:14,615
0,305 305,740 740,935 935,1300 1470,1715
Now, I'm not going, not
现在，我不打算讨论太多的细节，

1181
00:30:14,615 --> 00:30:15,110
0,60 60,150 150,285 285,405 405,495
going to discuss this too

1182
00:30:15,110 --> 00:30:16,280
0,230 250,540 540,795 795,1020 1020,1170
much details,| but there is
|但是有一个挑战，

1183
00:30:16,280 --> 00:30:17,345
0,195 195,450 450,705 705,885 885,1065
a challenge though,| how you
|你实际上如何表示这些墓碑，

1184
00:30:17,345 --> 00:30:18,215
0,150 150,240 240,330 330,575 595,870
actually want to represent these

1185
00:30:18,215 --> 00:30:19,520
0,515
tombstones,|
|

1186
00:30:19,560 --> 00:30:21,935
0,400 480,830 830,1180 1320,1720 2130,2375
and also represent something that
同时也表示了一种空的东西，

1187
00:30:21,935 --> 00:30:23,200
0,120 120,395
is empty,|
|

1188
00:30:23,200 --> 00:30:24,655
0,290 370,750 750,960 960,1190 1210,1455
and potentially also represent that
也可能表示我有一个 null 键，

1189
00:30:24,655 --> 00:30:25,590
0,90 90,180 180,300 300,600 600,935
I have a null key,|
|

1190
00:30:26,400 --> 00:30:27,455
0,245 245,365 365,545 545,830 830,1055
which you can do in
这是你可以在数据库系统中做的。

1191
00:30:27,455 --> 00:30:28,780
0,90 90,285 285,635
a database system,

1192
00:30:29,220 --> 00:30:30,380
0,400
right.|
|

1193
00:30:31,570 --> 00:30:32,565
0,335 335,530 530,650 650,815 815,995
So we could do the
所以，我们可以使用我们之前讨论过的 slotted pages 的技巧，

1194
00:30:32,565 --> 00:30:33,500
0,240 240,450 450,570 570,690 690,935
trick we talked about before

1195
00:30:33,850 --> 00:30:35,085
0,320 320,680 680,905 905,1130 1130,1235
with slotted pages,| where we
|我们可以在哈希表中的每个头部或每个页面的顶部前面放置一个 bitmap ，

1196
00:30:35,085 --> 00:30:36,585
0,90 90,195 195,330 330,815 1195,1500
could have a bitmap in

1197
00:30:36,585 --> 00:30:37,560
0,165 165,425 475,735 735,855 855,975
front of at the top

1198
00:30:37,560 --> 00:30:38,280
0,90 90,240 240,420 420,525 525,720
of every head or every

1199
00:30:38,280 --> 00:30:39,530
0,350 430,675 675,780 780,990 990,1250
page in our hash table,|
|

1200
00:30:39,730 --> 00:30:40,860
0,275 275,410 410,665 665,890 890,1130
I'm not showing the division
我没有在这里显示页面之间的划分，

1201
00:30:40,860 --> 00:30:42,315
0,345 345,735 735,1095 1095,1320 1320,1455
here between pages,| but think
|但是考虑，

1202
00:30:42,315 --> 00:30:43,995
0,120 120,365 835,1080 1080,1485 1485,1680
of like,| for simplicity, every
|简单起见，每个页面都是这些 slot ，

1203
00:30:43,995 --> 00:30:45,380
0,335 445,735 735,900 900,1065 1065,1385
page is to these slots,|
|

1204
00:30:45,730 --> 00:30:46,410
0,230 230,305 305,410 410,605 605,680
so in the header of
所以在页面的头部中，

1205
00:30:46,410 --> 00:30:47,250
0,165 165,390 390,555 555,675 675,840
that page,| I could keep
|我可以跟踪，

1206
00:30:47,250 --> 00:30:48,135
0,165 165,285 285,465 465,660 660,885
track of like,| okay, here's
|好的，这里是空的 slot ，

1207
00:30:48,135 --> 00:30:49,005
0,120 120,390 390,570 570,660 660,870
the slots that are empty,|
|

1208
00:30:49,005 --> 00:30:49,830
0,300 300,390 390,570 570,720 720,825
here's the slots that are
这里是 null slot ，

1209
00:30:49,830 --> 00:30:51,105
0,320 490,750 750,945 945,1050 1050,1275
null,| or here's the slots
|或者这里是有墓碑标记的 slot 。

1210
00:30:51,105 --> 00:30:52,080
0,165 165,425
that are,

1211
00:30:52,080 --> 00:30:53,700
0,210 210,500
that are,

1212
00:30:53,700 --> 00:30:54,240
0,105 105,195 195,315 315,435 435,540
that are marked with the

1213
00:30:54,240 --> 00:30:55,300
0,470
tombstone.|
|

1214
00:30:55,630 --> 00:30:56,625
0,230 230,395 395,605 605,755 755,995
So I need some additional
所以我需要一些额外的元数据来跟踪这些事情，

1215
00:30:56,625 --> 00:30:57,765
0,660 660,750 750,870 870,1020 1020,1140
metadata to keep track of

1216
00:30:57,765 --> 00:30:59,445
0,120 120,300 300,605 1165,1470 1470,1680
these things,| and you obviously
|你显然不想在每个键的基础上这样做，

1217
00:30:59,445 --> 00:30:59,985
0,195 195,270 270,360 360,450 450,540
don't want to do it

1218
00:30:59,985 --> 00:31:00,860
0,105 105,240 240,435 435,615 615,875
on a per key basis,|
|

1219
00:31:01,030 --> 00:31:03,280
0,400
because,
因为，这可能会扰乱事物的排列方式，浪费空间。

1220
00:31:03,800 --> 00:31:04,585
0,290 290,425 425,545 545,680 680,785
that could mess up with

1221
00:31:04,585 --> 00:31:06,565
0,120 120,405 405,495 495,755 1645,1980
the alignment of things waste

1222
00:31:06,565 --> 00:31:07,660
0,335
space.|
|

1223
00:31:10,580 --> 00:31:11,140
0,245 245,320 320,395 395,485 485,560
So the other thing we
我们现在要处理的另一件事是非唯一键。

1224
00:31:11,140 --> 00:31:11,770
0,75 75,165 165,270 270,405 405,630
got to deal with now

1225
00:31:11,770 --> 00:31:14,620
0,350 1240,1545 1545,1815 1815,2180
is {non-unique -} keys.|
|

1226
00:31:15,240 --> 00:31:16,400
0,225 225,470
All right.|
好的。|

1227
00:31:17,235 --> 00:31:17,910
0,75 75,150 150,285 285,495 495,675
So there's two approaches to
所以，有两种方法可以做到这个。

1228
00:31:17,910 --> 00:31:19,040
0,120 120,380
do this.|
|

1229
00:31:19,040 --> 00:31:20,630
0,210 210,450 450,800 1180,1440 1440,1590
One is that,| instead of
其中之一是，|不是将值与键一起存储在我们的大型哈希数组中，

1230
00:31:20,630 --> 00:31:22,960
0,285 285,540 540,860 1570,1950 1950,2330
storing the value in our

1231
00:31:23,340 --> 00:31:26,660
0,335 335,665 665,970 1860,2260 3060,3320
giant hash array, array, along

1232
00:31:26,660 --> 00:31:27,940
0,105 105,225 225,500
with the keys,|
|

1233
00:31:28,040 --> 00:31:29,080
0,305 305,500 500,725 725,905 905,1040
instead, the value would just
取而代之的是，该值只是一个指针，比如页面 ID ，

1234
00:31:29,080 --> 00:31:30,300
0,135 135,330 330,810 810,975 975,1220
be a pointer, like a

1235
00:31:30,590 --> 00:31:32,080
0,305 305,610
page ID,|
|

1236
00:31:32,080 --> 00:31:34,260
0,345 345,585 585,830 910,1310 1780,2180
to some other location that
到每个其他未知，存储我的键列表，抱歉，值列表，

1237
00:31:34,490 --> 00:31:35,590
0,320 320,530 530,740 740,935 935,1100
will store my list of

1238
00:31:35,590 --> 00:31:39,720
0,290 1900,2160 2160,2420 2980,3380 3730,4130
keys, {sorry,list,of} values, right,| so
|所以对于键 XYZ ，

1239
00:31:39,800 --> 00:31:41,620
0,260 260,395 395,575 995,1300 1530,1820
for the key XYZ,| there's
|有一个指针指向一个链表，

1240
00:31:41,620 --> 00:31:43,470
0,105 105,450 450,645 645,950 1450,1850
a pointer to some, basically

1241
00:31:43,670 --> 00:31:45,010
0,275 275,440 440,730 870,1130 1130,1340
a linked list,| that has
|它有所有可能的值，

1242
00:31:45,010 --> 00:31:46,540
0,255 255,405 405,585 585,920 1270,1530
all the possible values,| and
|然后对于另一个键，相同的东西。

1243
00:31:46,540 --> 00:31:47,310
0,120 120,225 225,300 300,450 450,770
then for the other key,

1244
00:31:47,330 --> 00:31:49,160
0,275 275,455 455,760
the same thing.|
|

1245
00:31:49,330 --> 00:31:50,340
0,335 335,470 470,635 635,800 800,1010
What's nice about this is
这样做的好处是，

1246
00:31:50,340 --> 00:31:51,495
0,240 240,480 480,660 660,960 960,1155
because,| as I insert new
|当我一次又一次地插入新键、重复键时，

1247
00:31:51,495 --> 00:31:54,210
0,305 1795,2220 2220,2475 2475,2595 2595,2715
keys, insert duplic keys over

1248
00:31:54,210 --> 00:31:55,640
0,165 165,470 670,1020 1020,1140 1140,1430
over again,| I'm not really
|我并没有改变主哈希表，

1249
00:31:55,840 --> 00:31:57,270
0,400 450,800 800,1055 1055,1295 1295,1430
changing the main hash table,|
|

1250
00:31:57,270 --> 00:31:58,125
0,180 180,255 255,390 390,720 720,855
I'm sort of appending to
我在追加到这个链表，

1251
00:31:58,125 --> 00:31:59,150
0,240 240,465 465,555 555,720 720,1025
this sort of link list,|
|

1252
00:31:59,760 --> 00:32:00,750
0,315 315,450 450,600 600,765 765,990
it's like the chain hash
这就像他之前谈到的链哈希表，

1253
00:32:00,750 --> 00:32:01,665
0,165 165,405 405,615 615,765 765,915
table that he talked about

1254
00:32:01,665 --> 00:32:02,595
0,275 295,540 540,615 615,750 750,930
before| or he asked about
|或者之前他问到的，

1255
00:32:02,595 --> 00:32:03,465
0,275 295,615 615,720 720,795 795,870
before,| we get in a
|我们稍后会讨论到。

1256
00:32:03,465 --> 00:32:04,340
0,245
second.|
|

1257
00:32:04,870 --> 00:32:06,015
0,245 245,410 410,695 695,965 965,1145
The more common approach is
更常见的方法是将冗余键存储在一起，

1258
00:32:06,015 --> 00:32:07,940
0,275 685,960 960,1380 1380,1590 1590,1925
to store redundant keys together,

1259
00:32:08,840 --> 00:32:09,960
0,400
right,|
|

1260
00:32:09,960 --> 00:32:10,905
0,120 120,285 285,465 465,765 765,945
and again, this doesn't break
这并没有打破线性探测哈希方案的开放寻址，

1261
00:32:10,905 --> 00:32:12,210
0,210 210,405 405,795 795,1035 1035,1305
the open addressing of linear

1262
00:32:12,210 --> 00:32:13,760
0,180 180,480 480,770 1000,1275 1275,1550
probe hashing scheme| is that
|我总是哈希键，

1263
00:32:14,650 --> 00:32:16,455
0,380 380,670 1230,1535 1535,1685 1685,1805
I'm always {hash -} the

1264
00:32:16,455 --> 00:32:17,865
0,275 415,690 690,930 930,1110 1110,1410
key,| I landed on location|
|我落在一个地点，|

1265
00:32:17,865 --> 00:32:19,940
0,210 210,345 345,635 865,1265
and I find a,
我找到一个空的 slot ，

1266
00:32:19,940 --> 00:32:20,555
0,90 90,195 195,330 330,465 465,615
you know, I just find

1267
00:32:20,555 --> 00:32:21,575
0,135 135,285 285,480 480,755 775,1020
a free slot| and the
|和我要找的东西。

1268
00:32:21,575 --> 00:32:22,780
0,90 90,210 210,360 360,695
thing I'm looking for.|
|

1269
00:32:23,290 --> 00:32:23,985
0,290 290,485 485,620 620,665 665,695
This does make it a
这确实使它变得有点棘手，

1270
00:32:23,985 --> 00:32:25,215
0,60 60,150 150,300 300,755 985,1230
little bit more tricky,| when
|当你查找，

1271
00:32:25,215 --> 00:32:26,205
0,135 135,300 300,600 600,780 780,990
you do lookups,| like give
|比如给我所有 XYZ 的键，键值对，

1272
00:32:26,205 --> 00:32:27,705
0,135 135,395 1045,1290 1290,1380 1380,1500
me all, give me all

1273
00:32:27,705 --> 00:32:29,500
0,135 135,255 255,360 675,965
the keys of XYZ,

1274
00:32:29,750 --> 00:32:31,225
0,275 275,470 470,820 1050,1325 1325,1475
key value pairs,| because now
|因为现在我必须继续扫描，

1275
00:32:31,225 --> 00:32:32,260
0,135 135,285 285,465 465,735 735,1035
I got, I know, like

1276
00:32:32,260 --> 00:32:33,550
0,180 180,285 285,405 405,680 1030,1290
I got to keep, I

1277
00:32:33,550 --> 00:32:34,450
0,105 105,195 195,390 390,795 795,900
got to keep scanning| until
|直到我找到一个空的位置，空的 slot ，

1278
00:32:34,450 --> 00:32:35,610
0,135 135,345 345,510 510,765 765,1160
I find an empty location,

1279
00:32:35,780 --> 00:32:36,940
0,335 335,635 635,845 845,1025 1025,1160
empty slot,| to know that
|知道我再也见不到 XYZ 了，

1280
00:32:36,940 --> 00:32:37,435
0,135 135,225 225,330 330,405 405,495
I'm not going to see

1281
00:32:37,720 --> 00:32:39,250
0,135 135,315 315,650 1000,1335 1335,1530
XYZ ever again,| whereas in
|而在第一个场景中，

1282
00:32:39,250 --> 00:32:40,980
0,120 120,360 360,600 600,860 1330,1730
the first, the first scenario,|
|

1283
00:32:41,880 --> 00:32:43,155
0,240 240,525 840,1020 1020,1155 1155,1275
I find XYZ in my
我在哈希表中找到 XYZ ，

1284
00:32:43,155 --> 00:32:44,780
0,195 195,455 565,825 825,1085 1225,1625
hash table,| then I land
|然后沿着指向值列表的指针，

1285
00:32:45,640 --> 00:32:46,880
0,305 305,470 470,785 785,950 950,1240
follow the pointer to the

1286
00:32:46,900 --> 00:32:48,180
0,290 290,425 425,670 900,1145 1145,1280
list of values| and I
|我知道这就是我可以为给定键提供的所有可能值。

1287
00:32:48,180 --> 00:32:49,290
0,195 195,480 480,690 690,900 900,1110
know that's all the possible

1288
00:32:49,290 --> 00:32:50,175
0,285 285,465 465,570 570,735 735,885
values I could have for

1289
00:32:50,175 --> 00:32:51,380
0,120 120,330 330,665
that given key,

1290
00:32:52,140 --> 00:32:53,280
0,400
right.|
|

1291
00:32:53,440 --> 00:32:54,795
0,275 275,410 410,860 860,1115 1115,1355
But for simplicity reasons,| instead
但为了简单起见，|我没有为非唯一键维护单独的链表，

1292
00:32:54,795 --> 00:32:57,405
0,90 90,285 285,545 1345,1745 2365,2610
I having't maintained the sort

1293
00:32:57,405 --> 00:32:58,290
0,105 105,300 300,525 525,720 720,885
of separate linked list for

1294
00:32:58,290 --> 00:32:59,355
0,135 135,345 345,630 630,885 885,1065
{non-unique -} keys| and and
|以及对于唯一键的内联版本，

1295
00:32:59,355 --> 00:33:01,665
0,210 210,435 435,725 1315,1715 2065,2310
the the non, the the

1296
00:33:01,665 --> 00:33:03,920
0,300 300,600 600,995
inline version for,

1297
00:33:04,560 --> 00:33:06,365
0,275 275,440 440,695 695,1060 1500,1805
for for unique keys,| most
|大多数系统使用冗余键方法，

1298
00:33:06,365 --> 00:33:08,315
0,305 1075,1350 1350,1470 1470,1770 1770,1950
systems use the redundant key

1299
00:33:08,315 --> 00:33:09,200
0,305
approach,|
|

1300
00:33:09,530 --> 00:33:11,635
0,305 305,575 1710,1925 1925,1985 1985,2105
because you don't have to
因为你不需要多重实现。

1301
00:33:11,635 --> 00:33:13,200
0,165 165,330 330,725
multiple implement implementations.|
|

1302
00:33:14,790 --> 00:33:15,920
0,400
Yes.|
是的|

1303
00:33:21,650 --> 00:33:22,555
0,260 260,425 425,605 605,755 755,905
Your question is, how would
你的问题是，你如何区分？

1304
00:33:22,555 --> 00:33:24,440
0,255 255,840 840,1145
you differentiate between?|
|

1305
00:33:24,990 --> 00:33:26,380
0,410 410,530 530,725 725,1025 1025,1390

1306
00:33:32,340 --> 00:33:33,220
0,230 230,305 305,455 455,620 620,880
So his question is,| how
所以他的问题是，|你如何区分更新一个值，而不是插入一个值，

1307
00:33:33,300 --> 00:33:35,255
0,245 245,350 350,610 1080,1480 1680,1955
would you differentiate update a

1308
00:33:35,255 --> 00:33:36,905
0,240 240,605 775,1140 1140,1545 1545,1650
value versus an insert of

1309
00:33:36,905 --> 00:33:39,020
0,90 90,335
a value,|
|

1310
00:33:39,700 --> 00:33:41,175
0,395 395,740 740,1040 1040,1205 1205,1475
yeah, for hash tables, you
是的，对于哈希表，你不应该做更新，

1311
00:33:41,175 --> 00:33:42,480
0,315 315,645 645,915 915,1185 1185,1305
really don't do updates,| it
|它应该是先删除后插入。

1312
00:33:42,480 --> 00:33:43,140
0,75 75,150 150,285 285,480 480,660
would be a delete followed

1313
00:33:43,140 --> 00:33:44,680
0,120 120,195 195,620 910,1310
by an insert, right.|
|

1314
00:33:45,350 --> 00:33:46,620
0,400

1315
00:33:46,620 --> 00:33:47,130
0,90 90,165 165,270 270,390 390,510
And of course, now the
当然，现在棘手的事情是，

1316
00:33:47,130 --> 00:33:48,030
0,240 240,360 360,555 555,750 750,900
tricky thing is,| if I
|如果我想删除键 XYZ 值是 value2 ，

1317
00:33:48,030 --> 00:33:49,640
0,135 135,360 360,740
want to delete

1318
00:33:50,320 --> 00:33:51,780
0,195 195,435 435,675 675,980 1060,1460
key XYZ with {value2 -},|
|

1319
00:33:53,380 --> 00:33:54,660
0,320

1320
00:33:54,660 --> 00:33:57,855
0,350 550,950 1030,1430 2800,3075 3075,3195
I, if I {want,to,delete,one} of
如果我想删除其中一个，

1321
00:33:57,855 --> 00:33:59,130
0,245 685,945 945,1050 1050,1140 1140,1275
these,| I have to know
|我必须知道它的值，确保是那个，

1322
00:33:59,130 --> 00:34:04,160
0,165 165,440 910,1170 1170,1430 4630,5030
the value, make sure {that,one},|
|

1323
00:34:04,540 --> 00:34:05,235
0,260 260,380 380,500 500,605 605,695
may not be what I
可能不是我想要的。

1324
00:34:05,235 --> 00:34:05,960
0,245
want.|
|

1325
00:34:05,960 --> 00:34:06,770
0,225 225,375 375,555 555,690 690,810

1326
00:34:06,770 --> 00:34:08,340
0,135 135,345 345,680

1327
00:34:13,160 --> 00:34:14,850
0,245 245,490 900,1205 1205,1400 1400,1690
The question if you have,|
问题是，如果你有，|

1328
00:34:15,920 --> 00:34:16,600
0,260 260,380 380,485 485,560 560,680
so if you have a
如果你有一个键有多个值，

1329
00:34:16,600 --> 00:34:18,580
0,225 225,560 610,945 945,1280 1720,1980
key with multiple values,| you
|你只需要哈希整个 tuple ，

1330
00:34:18,580 --> 00:34:19,465
0,135 135,360 360,495 495,660 660,885
just hash the entire tuple,|
|

1331
00:34:19,465 --> 00:34:19,885
0,165 165,210 210,240 240,315 315,420
what do you mean by
你说的是什么意思？

1332
00:34:19,885 --> 00:34:22,820
0,245 1135,1395 1395,1545 1545,1835
that?| { - -}
|

1333
00:34:22,820 --> 00:34:24,620
0,350 370,630 630,765 765,1040 1540,1800

1334
00:34:25,860 --> 00:34:26,760
0,90 90,165 165,360 360,660 660,900

1335
00:34:26,760 --> 00:34:27,140
0,135 135,330

1336
00:34:30,340 --> 00:34:32,520
0,380 380,635 635,910 1740,2030 2030,2180
Yeah, so like,| yeah, so
是的，所以就像，|是的，所以声明就像，

1337
00:34:32,520 --> 00:34:34,060
0,135 135,270 270,530
statement is like,|
|

1338
00:34:34,070 --> 00:34:34,885
0,245 245,440 440,575 575,725 725,815
if I'm looking for if
如果我在寻找完全匹配，

1339
00:34:34,885 --> 00:34:36,270
0,165 165,315 315,570 570,905 985,1385
I'm looking for exact match,|
|

1340
00:34:36,830 --> 00:34:37,615
0,245 245,380 380,545 545,680 680,785
in that case, like I
在这种情况下，我不需要哈希表，

1341
00:34:37,615 --> 00:34:38,185
0,135 135,210 210,300 300,450 450,570
don't need the hash table,|
|

1342
00:34:38,185 --> 00:34:40,015
0,195 195,465 465,690 690,965 1525,1830
because if I have,| but
因为如果我有，|但是如果我试图从数据结构中删除它，

1343
00:34:40,015 --> 00:34:41,035
0,300 300,555 555,735 735,840 840,1020
like if I'm trying to

1344
00:34:41,035 --> 00:34:41,830
0,225 225,375 375,510 510,630 630,795
remove it from the data

1345
00:34:41,830 --> 00:34:43,555
0,240 240,450 450,690 690,1040 1420,1725
structure,| like this exact, like
|就像这个完全匹配键值对，

1346
00:34:43,555 --> 00:34:44,920
0,180 180,420 420,785
key value pair,

1347
00:34:44,920 --> 00:34:47,860
0,350 520,915 915,1310 1360,1760
right,| then you basically,
|然后你基本上，

1348
00:34:47,950 --> 00:34:49,760
0,400 540,940
and you,

1349
00:34:50,510 --> 00:34:52,020
0,400
you,|
|

1350
00:34:52,660 --> 00:34:53,730
0,245 245,350 350,485 485,755 755,1070
you need to find that
你需要找到确切的对，

1351
00:34:53,730 --> 00:34:54,570
0,240 240,495 495,660 660,750 750,840
exact pair,| you need to
|你需要有时间，

1352
00:34:54,570 --> 00:34:55,815
0,75 75,270 270,510 510,800 970,1245
have it time| and just
|只是维护数据结构。

1353
00:34:55,815 --> 00:34:57,255
0,240 240,465 465,645 645,965 1165,1440
maintaining the data structure.| {}
|

1354
00:34:57,255 --> 00:34:58,455
0,225 225,435 435,695 745,1065 1065,1200

1355
00:34:58,455 --> 00:34:59,295
0,165 165,255 255,375 375,540 540,840

1356
00:34:59,295 --> 00:35:00,100
0,225 225,375 375,525 525,765

1357
00:35:04,360 --> 00:35:05,565
0,245 245,365 365,635 635,965 965,1205
The question is why, Why
问题是为什么要这么做，

1358
00:35:05,565 --> 00:35:07,635
0,165 165,425 1405,1710 1710,1920 1920,2070
do this,| so like, if
|如果我做一个 JOIN ，

1359
00:35:07,635 --> 00:35:09,770
0,180 180,285 285,435 435,725 1735,2135
I'm doing a JOIN,| the
|两个连接表之间的关系是，

1360
00:35:10,360 --> 00:35:11,340
0,335 335,545 545,680 680,815 815,980
relationship between the two join

1361
00:35:11,340 --> 00:35:12,465
0,210 210,390 390,650 670,960 960,1125
tables is that,| one side
|一边可能不是唯一的，

1362
00:35:12,465 --> 00:35:13,880
0,135 135,255 255,360 360,605 1015,1415
might not be unique, right,|
|

1363
00:35:16,050 --> 00:35:16,910
0,365 365,575 575,680 680,770 770,860
so I need to have
所以我需要这个。

1364
00:35:16,910 --> 00:35:18,050
0,260 520,810 810,945 945,1050 1050,1140
this.| And so I want
|所以我想得到所有的，

1365
00:35:18,050 --> 00:35:18,910
0,75 75,225 225,435 435,600 600,860
to get all of the,|
|

1366
00:35:19,170 --> 00:35:20,255
0,275 275,410 410,590 590,755 755,1085
you have basically an iterator
你基本上有一个迭代器，

1367
00:35:20,255 --> 00:35:21,050
0,195 195,330 330,435 435,615 615,795
says,| give me all the
|给我 key 等于 XYZ 的所有值，

1368
00:35:21,050 --> 00:35:23,140
0,260 820,1110 1110,1320 1320,1500 1800,2090
values for key equals XYZ|
|

1369
00:35:23,460 --> 00:35:25,160
0,400 870,1220 1220,1355 1355,1505 1505,1700
and spitting this things out
然后在我遍历哈希表的时候把这些东西吐出来，

1370
00:35:25,160 --> 00:35:26,795
0,315 315,750 750,945 945,1230 1230,1635
as I'm as I'm traversing

1371
00:35:26,795 --> 00:35:27,940
0,150 150,345 345,605
the hash table,|
|

1372
00:35:28,415 --> 00:35:29,110
0,135 135,210 210,330 330,450 450,695
because I'm doing the JOIN.|
因为我在做 JOIN 。|

1373
00:35:30,610 --> 00:35:32,130
0,400 570,830 830,950 950,1340 1340,1520
Yes.| { - - -}
是的。|

1374
00:35:32,130 --> 00:35:32,860
0,240 240,495 495,690

1375
00:35:34,320 --> 00:35:35,135
0,275 275,440 440,590 590,710 710,815
His question is,| would you
他的问题是，|你会不会重新哈希，

1376
00:35:35,135 --> 00:35:36,620
0,585 585,810 810,990 990,1200 1200,1485
rehash,| when it's completely for
|当它 80% 满的时候，

1377
00:35:36,620 --> 00:35:38,210
0,240 240,465 465,800 970,1335 1335,1590
{80% -} full,| so the
|所以不同的系统有不同的，

1378
00:35:38,210 --> 00:35:40,740
0,255 255,585 585,885 885,1220
different systems have different,|
|

1379
00:35:40,940 --> 00:35:41,920
0,305 305,365 365,500 500,875 875,980
there's like a threshold would
比如有一个阈值，

1380
00:35:41,920 --> 00:35:42,970
0,210 210,405 405,555 555,795 795,1050
say,| if I go above
|如果我超过这个，

1381
00:35:42,970 --> 00:35:43,975
0,270 270,525 525,705 705,885 885,1005
this,| I know I'm gonna
|我知道我会溢出或用完空间，

1382
00:35:43,975 --> 00:35:44,965
0,480 480,690 690,825 825,900 900,990
overflow or run out of

1383
00:35:44,965 --> 00:35:45,955
0,165 165,390 390,585 585,765 765,990
space,| I go ahead and
|我就去触发一个重新哈希，

1384
00:35:45,955 --> 00:35:47,545
0,315 315,495 495,845 1195,1470 1470,1590
trigger a rehash.| { -}
|

1385
00:35:47,545 --> 00:35:48,355
0,120 120,270 270,465 465,660 660,810

1386
00:35:48,355 --> 00:35:49,285
0,180 180,375 375,510 510,675 675,930

1387
00:35:49,285 --> 00:35:50,620
0,210 210,345 345,540 540,875

1388
00:35:52,720 --> 00:35:55,520
0,400 1050,1325 1325,1580 1580,1960 2400,2800
Yeah, point, yes,| like the
是的，观点是对的，|你越来越接近最坏的情况，

1389
00:35:55,930 --> 00:35:57,105
0,260 260,440 440,755 755,1010 1010,1175
you get closer to that

1390
00:35:57,105 --> 00:35:58,590
0,210 210,405 405,695 955,1245 1245,1485
worst case scenario,| where like
|比如如果它开始变满，

1391
00:35:58,590 --> 00:35:59,460
0,225 225,330 330,525 525,750 750,870
if it gets, it starts

1392
00:35:59,460 --> 00:36:00,630
0,75 75,195 195,500 730,1005 1005,1170
to get full,| so rather
|所以，不是等待它 100% 满了，

1393
00:36:00,630 --> 00:36:01,800
0,135 135,380 730,990 990,1125 1125,1170
than waiting to it's like

1394
00:36:01,800 --> 00:36:03,180
0,75 75,165 165,375 375,740 1090,1380
{100% - -} full,| maybe
|可能达到 80% ，因为，

1395
00:36:03,180 --> 00:36:04,370
0,135 135,225 225,650 670,930 930,1190
go to 80%, because though,|
|

1396
00:36:04,600 --> 00:36:05,505
0,335 335,470 470,620 620,755 755,905
it's better off to pay
最后承担惩罚来调整哈希表的大小，

1397
00:36:05,505 --> 00:36:06,885
0,150 150,570 570,780 780,1215 1215,1380
the penalty to resize the

1398
00:36:06,885 --> 00:36:08,175
0,210 210,485 595,840 840,945 945,1290
hash table,| which is doubling
|变为两倍，

1399
00:36:08,175 --> 00:36:09,405
0,270 270,605 625,900 900,1050 1050,1230
you,| so {resize -} hash
|重新调真大小哈希是两倍它的大小，

1400
00:36:09,405 --> 00:36:10,035
0,90 90,195 195,345 345,480 480,630
table is double the size

1401
00:36:10,035 --> 00:36:10,800
0,135 135,365
of it,|
|

1402
00:36:10,810 --> 00:36:11,760
0,305 305,470 470,605 605,770 770,950
go through all your keys|
通过你所有的键，|

1403
00:36:11,760 --> 00:36:12,540
0,135 135,495 495,585 585,690 690,780
and rehash them and put
对它们进行重新哈希，放入新的哈希表中，

1404
00:36:12,540 --> 00:36:13,065
0,60 60,165 165,270 270,360 360,525
them into the new hash

1405
00:36:13,065 --> 00:36:13,590
0,105 105,195 195,285 285,405 405,525
table| and then throw away
|然后丢弃旧的，

1406
00:36:13,590 --> 00:36:14,900
0,90 90,210 210,500 610,1035 1035,1310
the old one,| that's not,
|这是很昂贵的，

1407
00:36:15,070 --> 00:36:16,500
0,485 485,1055 1055,1250 1250,1370 1370,1430
that's expensive,| if it's a
|如果它是一个大的哈希表，

1408
00:36:16,500 --> 00:36:17,730
0,120 120,345 345,590 880,1125 1125,1230
large hash table,| so, but
|但是有一个权衡，

1409
00:36:17,730 --> 00:36:18,345
0,150 150,255 255,390 390,510 510,615
there's a {tradeoff -} of,|
|

1410
00:36:18,345 --> 00:36:19,335
0,210 210,555 555,780 780,900 900,990
like, okay, if I'm at
比如，好的，如果我有 80% 满，

1411
00:36:19,335 --> 00:36:21,060
0,390 390,755 1015,1335 1335,1515 1515,1725
80% full,| I'd rather pay
|我宁愿承担惩罚来增加一倍的大小，

1412
00:36:21,060 --> 00:36:22,095
0,135 135,510 510,720 720,870 870,1035
that penalty to double the

1413
00:36:22,095 --> 00:36:23,595
0,275 565,900 900,1125 1125,1335 1335,1500
size| rather than all the
|而不是所有我需要做的额外操作，

1414
00:36:23,595 --> 00:36:24,765
0,240 240,635 685,945 945,1065 1065,1170
additional operations I need to

1415
00:36:24,765 --> 00:36:25,995
0,245 475,750 750,870 870,1020 1020,1230
do| spend a long time
|需要花费很长时间进行搜索，

1416
00:36:25,995 --> 00:36:27,000
0,255 255,605
searching through,|
|

1417
00:36:27,900 --> 00:36:29,060
0,320 320,500 500,755 755,950 950,1160
there's no, there's no one
没有一个统一答案。

1418
00:36:29,060 --> 00:36:30,020
0,260
answer.|
|

1419
00:36:30,390 --> 00:36:31,610
0,230 230,610 630,980 980,1070 1070,1220
But that's, that's why there's
但是，通常有一个可调的阈值，

1420
00:36:31,610 --> 00:36:33,020
0,120 120,330 330,560 970,1260 1260,1410
a, there's a, there's usually

1421
00:36:33,020 --> 00:36:34,730
0,195 195,495 495,980 1330,1605 1605,1710
a tunable threshold,| whether or
|无论他们是否向你公开，

1422
00:36:34,730 --> 00:36:35,960
0,105 105,225 225,600 600,1035 1035,1230
not they expose, expose that

1423
00:36:35,960 --> 00:36:37,745
0,180 180,470 1120,1440 1440,1635 1635,1785
to you| as like a
|作为数据库系统的用户，

1424
00:36:37,745 --> 00:36:38,650
0,195 195,375 375,465 465,600 600,905
user of the database system,|
|

1425
00:36:38,760 --> 00:36:39,670
0,290 290,455 455,560 560,650 650,910
it depends on the implementation,|
这取决于实现，|

1426
00:36:40,020 --> 00:36:41,270
0,260 260,605 605,785 785,980 980,1250
but there usually a threshold
但通常有一个阈值说明，

1427
00:36:41,270 --> 00:36:41,810
0,75 75,210 210,375 375,465 465,540
to say,| when do you
|你希望在什么时候继续并调整大小。

1428
00:36:41,810 --> 00:36:42,335
0,105 105,210 210,345 345,450 450,525
want to go ahead and

1429
00:36:42,335 --> 00:36:43,280
0,365
resize.|
|

1430
00:36:48,450 --> 00:36:50,165
0,350 350,700 930,1190 1190,1355 1355,1715
Okay, so some other optimizations
好的，我们还可以做一些其他的优化。

1431
00:36:50,165 --> 00:36:51,360
0,180 180,270 270,515
we can do.|
|

1432
00:36:51,610 --> 00:36:53,730
0,400 1050,1400 1400,1625 1625,1880 1880,2120
{} That one is you
一个是你可以有不同的哈希表实现，

1433
00:36:53,730 --> 00:36:56,055
0,150 150,440 1030,1430 1780,2100 2100,2325
could have different hash table

1434
00:36:56,055 --> 00:36:58,065
0,545 955,1230 1230,1440 1440,1695 1695,2010
implementations,| that have these different
|有这些不同的机制，或者决策，

1435
00:36:58,065 --> 00:36:59,510
0,630 630,825 825,1050 1050,1215 1215,1445
mechanisms or like, you know,

1436
00:36:59,770 --> 00:37:01,515
0,395 395,790 960,1220 1220,1415 1415,1745
decisions| about when to split,
|关于何时拆分，如何存储东西，等等，

1437
00:37:01,515 --> 00:37:02,460
0,255 255,390 390,570 570,780 780,945
how to store things and

1438
00:37:02,460 --> 00:37:04,740
0,410 640,975 975,1310 1330,1730 1960,2280
{what,not},| based on the data
|基于你存储的数据类型。

1439
00:37:04,740 --> 00:37:05,940
0,195 195,360 360,620
type you're storing.|
|

1440
00:37:07,030 --> 00:37:08,055
0,335 335,590 590,770 770,890 890,1025
So an obvious thing would
所以一个显而易见的事情是，

1441
00:37:08,055 --> 00:37:09,590
0,195 195,515 745,1005 1005,1200 1200,1535
be like,| if I have,
|如果我想要的是支持字符串键的哈希表，

1442
00:37:10,120 --> 00:37:10,860
0,245 245,320 320,380 380,485 485,740
I want to be hash

1443
00:37:10,860 --> 00:37:12,620
0,260 280,585 585,890 1150,1455 1455,1760
tables that support string keys,|
|

1444
00:37:13,300 --> 00:37:14,410
0,210 210,450 450,720 720,870 870,1110
if my strings are very
如果我的字符串非常小，

1445
00:37:14,410 --> 00:37:17,250
0,380 460,860 1450,1935 1935,2210 2260,2840
small,| like 64 {bits,64 -}
|比如 64 位或 64 字节或更少，

1446
00:37:17,300 --> 00:37:18,535
0,275 275,485 485,860 860,1085 1085,1235
bits or 64 bytes or

1447
00:37:18,535 --> 00:37:19,860
0,365 445,720 720,840 840,1050 1050,1325
64 bits or bytes less,|
|

1448
00:37:20,120 --> 00:37:21,235
0,260 260,455 455,635 635,755 755,1115
they might store that inline
它们可能会存储我的内联哈希表中，

1449
00:37:21,235 --> 00:37:22,345
0,180 180,405 405,665 805,1050 1050,1110
my hash table,| but if
|但如果它是一个非常大的字符串，

1450
00:37:22,345 --> 00:37:23,515
0,105 105,210 210,450 450,815 865,1170
it's a really large string,|
|

1451
00:37:23,515 --> 00:37:24,205
0,165 165,345 345,405 405,525 525,690
I don't want to store
我不想将其存储在我的哈希表中，

1452
00:37:24,205 --> 00:37:25,050
0,135 135,225 225,345 345,585 585,845
that in my hash table,|
|

1453
00:37:25,490 --> 00:37:26,110
0,275 275,395 395,485 485,560 560,620
maybe I just want to
也许我只想有一个指向实际字符串本身的指针，

1454
00:37:26,110 --> 00:37:27,310
0,75 75,225 225,675 675,945 945,1200
have a pointer to the

1455
00:37:27,310 --> 00:37:29,065
0,255 255,540 540,890 1300,1560 1560,1755
actual string itself,| so now
|所以现在我可以有一个 64 位的指针，

1456
00:37:29,065 --> 00:37:29,950
0,195 195,300 300,405 405,525 525,885
I can have a 64

1457
00:37:29,950 --> 00:37:31,020
0,150 150,590
bit pointer,|
|

1458
00:37:31,940 --> 00:37:32,815
0,245 245,470 470,770 770,830 830,875
but now it's going to
但现在，进行查找成本将会很高，

1459
00:37:32,815 --> 00:37:33,625
0,135 135,390 390,570 570,660 660,810
be expensive to do that

1460
00:37:33,625 --> 00:37:34,780
0,420 420,630 630,795 795,990 990,1155
lookup| to see whether I
|查看是否有匹配，

1461
00:37:34,780 --> 00:37:35,695
0,120 120,255 255,495 495,720 720,915
have a match,| so maybe
|可能我真的希望将该字符串的哈希

1462
00:37:35,695 --> 00:37:36,790
0,270 270,450 450,525 525,755 805,1095
I actually want to store

1463
00:37:36,790 --> 00:37:38,310
0,290 460,870 870,975 975,1170 1170,1520
the hash of that string|
|

1464
00:37:38,720 --> 00:37:39,865
0,320 320,515 515,695 695,890 890,1145
as part of the key
作为键的一部分存储在哈希表中，

1465
00:37:39,865 --> 00:37:41,215
0,225 225,360 360,585 585,845 1075,1350
in my hash table| to
|以避免进行那种查找，

1466
00:37:41,215 --> 00:37:42,115
0,180 180,360 360,465 465,660 660,900
avoid having to do that

1467
00:37:42,115 --> 00:37:43,120
0,425
lookup,

1468
00:37:43,360 --> 00:37:44,500
0,400
right.|
|

1469
00:37:44,750 --> 00:37:46,040
0,400

1470
00:37:46,040 --> 00:37:47,180
0,285 285,495 495,720 720,975 975,1140
We talked about storing the
我们讨论了存储元数据，

1471
00:37:47,180 --> 00:37:48,500
0,600 600,810 810,975 975,1140 1140,1320
metadata,| like as something a
|比如墓碑，或者空值，或者空 slot ，

1472
00:37:48,500 --> 00:37:51,575
0,495 495,705 705,930 930,1280 2800,3075
tombstone or something a {}

1473
00:37:51,575 --> 00:37:53,675
0,225 225,515 595,930 930,1265 1765,2100
null value or a or

1474
00:37:53,675 --> 00:37:55,520
0,315 315,615 615,965 1435,1695 1695,1845
an empty slot,| you could
|你可以将其存储在页头中，

1475
00:37:55,520 --> 00:37:56,240
0,150 150,270 270,390 390,525 525,720
store that in the page

1476
00:37:56,240 --> 00:37:57,425
0,470 520,780 780,915 915,1050 1050,1185
header,| because now you have
|因为现在你有一堆打包的位，

1477
00:37:57,425 --> 00:37:58,450
0,135 135,270 270,450 450,690 690,1025
a bunch of packed bits,|
|

1478
00:37:58,710 --> 00:37:59,705
0,380 380,605 605,800 800,905 905,995
you'd actually store that in
你会将其存储在整个哈希表本身中。

1479
00:37:59,705 --> 00:38:00,910
0,135 135,330 330,555 555,810 810,1205
the entire hash table itself,

1480
00:38:01,670 --> 00:38:02,820
0,400
right.|
|

1481
00:38:03,420 --> 00:38:04,760
0,260 260,440 440,755 755,1085 1085,1340
So the, the Google {HashMap
所以， Google 的 HashMap 做到了这个，

1482
00:38:04,760 --> 00:38:05,495
0,150 150,330 330,510 510,645 645,735
-} does this,| where they
|他们有一个单独的哈希表，专门用于元数据，

1483
00:38:05,495 --> 00:38:06,380
0,90 90,210 210,420 420,705 705,885
have a separate hash table,

1484
00:38:06,380 --> 00:38:07,880
0,195 195,315 315,405 405,1040 1120,1500
just for the metadata,| that's
|它更小、更紧凑，

1485
00:38:07,880 --> 00:38:09,650
0,180 180,500 670,945 945,1340 1510,1770
much smaller and compact,| you
|你在它上面进行查找，

1486
00:38:09,650 --> 00:38:10,450
0,90 90,165 165,375 375,510 510,800
do a lookup on that,|
|

1487
00:38:10,650 --> 00:38:11,435
0,260 260,380 380,500 500,635 635,785
to tell you what is
告诉你要在真正的哈希表中查找的是什么，

1488
00:38:11,435 --> 00:38:12,020
0,150 150,270 270,420 420,495 495,585
the thing you're about to

1489
00:38:12,020 --> 00:38:13,325
0,120 120,285 285,560 760,1050 1050,1305
go look up in the

1490
00:38:13,325 --> 00:38:14,330
0,210 210,345 345,555 555,765 765,1005
the real hash table,| is
|那个东西是否是空值或空的。

1491
00:38:14,330 --> 00:38:15,500
0,210 210,525 525,765 765,900 900,1170
that thing you know, null

1492
00:38:15,500 --> 00:38:17,060
0,225 225,530 910,1185 1185,1380 1380,1560
or, or, or empty or

1493
00:38:17,060 --> 00:38:17,740
0,260
not.|
|

1494
00:38:19,000 --> 00:38:19,815
0,245 245,335 335,455 455,590 590,815
And then this one is
然后这个很有趣，

1495
00:38:19,815 --> 00:38:21,150
0,240 240,515 715,1005 1005,1170 1170,1335
interesting,| this one comes from
|这一个来自 Clickhouse ，

1496
00:38:21,150 --> 00:38:24,240
0,410 1450,1850 2050,2490 2490,2780 2830,3090
Clickhouse,| the OLAP system that
|这是俄罗斯的一种基于索引的 OLAP 的系统，

1497
00:38:24,240 --> 00:38:24,915
0,105 105,195 195,330 330,510 510,675
came out of the index

1498
00:38:24,915 --> 00:38:27,390
0,135 135,395 1645,1950 1950,2220 2220,2475
in Russia,| so they talk
|所以他们谈论他们想要成为什么样子，

1499
00:38:27,390 --> 00:38:27,990
0,150 150,285 285,420 420,525 525,600
about how they want to

1500
00:38:27,990 --> 00:38:29,190
0,230 400,660 660,825 825,990 990,1200
be,| since it's so expensive
|因为为哈希表分配内存是如此昂贵，

1501
00:38:29,190 --> 00:38:30,060
0,120 120,420 420,525 525,705 705,870
to allocate the memory for

1502
00:38:30,060 --> 00:38:31,455
0,90 90,300 300,560 1000,1245 1245,1395
a hash table,| you don't
|你不会想要分配一堆内存，

1503
00:38:31,455 --> 00:38:32,835
0,45 45,135 135,395 925,1170 1170,1380
want to just, you know,

1504
00:38:32,835 --> 00:38:33,710
0,405 405,465 465,540 540,630 630,875
allocate a bunch of memory,|
|

1505
00:38:33,970 --> 00:38:34,815
0,275 275,425 425,590 590,725 725,845
use it once and then
使用一次，然后扔掉，

1506
00:38:34,815 --> 00:38:36,210
0,135 135,270 270,545 955,1230 1230,1395
throw it away,| which you
|你想要一次又一次地重复使用那个内存，

1507
00:38:36,210 --> 00:38:36,975
0,135 135,240 240,345 345,465 465,765
actually want to just reuse

1508
00:38:36,975 --> 00:38:37,890
0,195 195,405 405,615 615,810 810,915
that, that memory over and

1509
00:38:37,890 --> 00:38:39,105
0,165 165,500 730,990 990,1110 1110,1215
over again,| but you need
|但你需要一种快速的方法来清理它，

1510
00:38:39,105 --> 00:38:39,945
0,120 120,330 330,540 540,690 690,840
a fast way to clear

1511
00:38:39,945 --> 00:38:40,740
0,120 120,365
it out,|
|

1512
00:38:41,240 --> 00:38:42,445
0,380 380,620 620,755 755,980 980,1205
so instead of going through
所以，不是遍历并将所有 slot 标记为已删除，

1513
00:38:42,445 --> 00:38:43,795
0,150 150,480 480,630 630,935 1015,1350
and marking all the slots

1514
00:38:43,795 --> 00:38:45,570
0,255 255,785 1075,1335 1335,1485 1485,1775
as deleted,| you just maintain
|你只需维护一个版本计数器，版本 ID ，

1515
00:38:45,740 --> 00:38:47,320
0,335 335,650 650,1030 1140,1400 1400,1580
a version counter, a version

1516
00:38:47,320 --> 00:38:48,460
0,320
ID,|
|

1517
00:38:48,460 --> 00:38:50,245
0,290 550,950 1180,1455 1455,1620 1620,1785
and whenever you say I
每当你说我想删除该表的内容时，

1518
00:38:50,245 --> 00:38:51,910
0,105 105,270 270,605 1075,1350 1350,1665
want to delete the contents

1519
00:38:51,910 --> 00:38:53,245
0,105 105,240 240,530 880,1125 1125,1335
of this table,| you just
|你只需递增该表上的版本计数器，

1520
00:38:53,245 --> 00:38:54,595
0,405 405,690 690,945 945,1200 1200,1350
increment that version counter on

1521
00:38:54,595 --> 00:38:56,020
0,120 120,395 805,1065 1065,1230 1230,1425
the table,| and then now
|现在，如果你在该表内的插槽中执行的任何查找，

1522
00:38:56,020 --> 00:38:57,880
0,255 255,675 675,840 840,1100 1600,1860
any lookup you do inside

1523
00:38:57,880 --> 00:38:59,155
0,180 180,420 420,770 850,1125 1125,1275
of a slot inside that

1524
00:38:59,155 --> 00:39:00,295
0,225 225,450 450,600 600,780 780,1140
table,| if the version IDs
|如果版本 ID 不匹配，

1525
00:39:00,295 --> 00:39:03,400
0,195 195,455 895,1295 1735,2135 2815,3105
don't match,| then if the
|如果 slot 版本号小于表版本号，

1526
00:39:03,400 --> 00:39:04,630
0,255 255,480 480,720 720,975 975,1230
slot version number is less

1527
00:39:04,630 --> 00:39:05,700
0,210 210,360 360,540 540,765 765,1070
than the table version number,|
|

1528
00:39:05,750 --> 00:39:06,655
0,245 245,380 380,560 560,740 740,905
then you know it's been
你知道它已经被删除，

1529
00:39:06,655 --> 00:39:07,660
0,375 375,510 510,615 615,765 765,1005
deleted| and you can ignore
|你可以忽略其中的所有内容，

1530
00:39:07,660 --> 00:39:08,860
0,210 210,345 345,620 790,1035 1035,1200
everything in there| and that
|这将清除它，然后递增版本 ID 。

1531
00:39:08,860 --> 00:39:09,870
0,255 255,345 345,525 525,735 735,1010
clears it out and then

1532
00:39:10,730 --> 00:39:11,790
0,290 290,485 485,590 590,755 755,1060
you increment the version ID.|
|

1533
00:39:13,260 --> 00:39:13,820
0,245 245,320 320,365 365,455 455,560
So there a bunch of
所以，你可以在不同的场景中使用一系列不同的技巧

1534
00:39:13,820 --> 00:39:14,615
0,150 150,405 405,495 495,615 615,795
different tricks you can do

1535
00:39:14,615 --> 00:39:15,875
0,165 165,345 345,875 895,1140 1140,1260
in different scenarios| to make
|来使这些事情更高效地运行，

1536
00:39:15,875 --> 00:39:16,960
0,135 135,285 285,435 435,570 570,1085
these things run more efficiently|
|

1537
00:39:17,100 --> 00:39:18,395
0,400 420,680 680,860 860,1100 1100,1295
and the various systems do
不同的系统做不同的事情，

1538
00:39:18,395 --> 00:39:20,105
0,195 195,515 955,1410 1410,1560 1560,1710
different things,| Clickhouse, in my
|Clickhouse ，在我看来，

1539
00:39:20,105 --> 00:39:22,190
0,305 865,1355 1465,1755 1755,1920 1920,2085
opinion,| there's, that link there
|那个链接可以把你带到博客文章，

1540
00:39:22,190 --> 00:39:22,700
0,180 180,300 300,360 360,420 420,510
will take you to the

1541
00:39:22,700 --> 00:39:24,230
0,150 150,440 760,1125 1125,1380 1380,1530
blog article,| they claim they
|他们声称他们有 30 种不同的哈希表实现，

1542
00:39:24,230 --> 00:39:25,775
0,165 165,390 390,675 675,1245 1245,1545
have 30 different implementations of

1543
00:39:25,775 --> 00:39:28,130
0,255 255,515 1915,2175 2175,2280 2280,2355
hash tables,| a lot of
|其中很多都是基于 C++ 模板化的，基于数据类型，

1544
00:39:28,130 --> 00:39:29,315
0,105 105,630 630,915 915,1080 1080,1185
it templateized based in {C++

1545
00:39:29,315 --> 00:39:30,695
0,120 120,395 895,1170 1170,1290 1290,1380
- -}, based on the

1546
00:39:30,695 --> 00:39:31,970
0,180 180,515 655,885 885,1065 1065,1275
data type,| and they do
|他们做了一系列的编译器技巧，

1547
00:39:31,970 --> 00:39:33,065
0,90 90,180 180,285 285,705 705,1095
a bunch of compiler tricks|
|

1548
00:39:33,065 --> 00:39:34,865
0,395 535,935 1135,1455 1455,1665 1665,1800
to, to remove code you
来删除你不需要的代码，

1549
00:39:34,865 --> 00:39:36,380
0,180 180,425 925,1185 1185,1320 1320,1515
don't need,| if you know,
|如果你知道，比如某个东西不能为空，

1550
00:39:36,380 --> 00:39:37,505
0,195 195,390 390,645 645,855 855,1125
like something cannot be null|
|

1551
00:39:37,505 --> 00:39:39,215
0,335 715,975 975,1230 1230,1485 1485,1710
or is a string of
或者是一个特定大小的字符串，

1552
00:39:39,215 --> 00:39:40,400
0,285 285,605
certain size,|
|

1553
00:39:40,400 --> 00:39:41,600
0,380

1554
00:39:41,610 --> 00:39:42,590
0,305 305,515 515,650 650,770 770,980
they probably, in my opinion,
在我看来，在我研究的所有源系统中，

1555
00:39:42,590 --> 00:39:43,520
0,180 180,330 330,540 540,735 735,930
of all the source systems

1556
00:39:43,520 --> 00:39:44,690
0,180 180,315 315,590 700,1050 1050,1170
I looked at,| they're probably
|它们可能是最复杂的，

1557
00:39:44,690 --> 00:39:46,010
0,105 105,210 210,660 660,950 1030,1320
the most sophisticated ones,| that
|拥有最复杂的哈希表。

1558
00:39:46,010 --> 00:39:46,940
0,150 150,255 255,345 345,720 720,930
have the most sophisticated hash

1559
00:39:46,940 --> 00:39:47,820
0,260
tables.|
|

1560
00:39:47,990 --> 00:39:49,040
0,400

1561
00:39:50,570 --> 00:39:52,030
0,260 260,500 500,755 755,980 980,1460
All right, so one variant
好的，线性探测哈希的一种变体是一种被称为 Cuckoo 哈希的技术。

1562
00:39:52,030 --> 00:39:53,995
0,320 670,1190 1270,1575 1575,1680 1680,1965
of linear, linear probe hashing

1563
00:39:53,995 --> 00:39:55,165
0,225 225,465 465,660 660,900 900,1170
is a technique called Cuckoo

1564
00:39:55,165 --> 00:39:56,140
0,425
hashing.|
|

1565
00:39:56,590 --> 00:39:57,660
0,260 260,500 500,785 785,950 950,1070
And the idea here is
这里的想法是，

1566
00:39:57,660 --> 00:39:59,235
0,260 790,1050 1050,1170 1170,1335 1335,1575
that,| instead of having a
|不是只有一个哈希函数，

1567
00:39:59,235 --> 00:40:00,465
0,315 315,705 705,945 945,1140 1140,1230
single hash function,| to do
|在我的哈希表中查找一个位置，

1568
00:40:00,465 --> 00:40:01,305
0,105 105,225 225,345 345,525 525,840
a look up to one

1569
00:40:01,305 --> 00:40:03,765
0,395 805,1110 1110,1415 1975,2250 2250,2460
location in my, in my

1570
00:40:03,765 --> 00:40:05,060
0,285 285,545
hash table,|
|

1571
00:40:05,060 --> 00:40:05,855
0,195 195,270 270,360 360,525 525,795
what if I had multiple
如果我有多个哈希函数，

1572
00:40:05,855 --> 00:40:08,315
0,315 315,575 1375,1775 1915,2220 2220,2460
hash functions| and I hash
|并且我哈希了多个位置，

1573
00:40:08,315 --> 00:40:09,515
0,135 135,425 445,840 840,1065 1065,1200
up multiple locations| and I
|我找到了任何一个有空闲 slot 的位置，

1574
00:40:09,515 --> 00:40:11,840
0,305 1105,1410 1410,1635 1635,1955 2065,2325
find whatever one has a

1575
00:40:11,840 --> 00:40:13,400
0,260 520,950
free slot,|
|

1576
00:40:13,400 --> 00:40:14,200
0,90 90,180 180,330 330,510 510,800
and I use that one,|
我就用那个，|

1577
00:40:14,810 --> 00:40:15,700
0,245 245,335 335,455 455,635 635,890
instead of having to scan
而不是必须扫描，

1578
00:40:15,700 --> 00:40:17,695
0,240 240,530 1480,1725 1725,1845 1845,1995
through now,| until I find
|直到我为键找到一个空闲的 slot 。

1579
00:40:17,695 --> 00:40:19,225
0,135 135,270 270,480 480,785 1255,1530
a free slot for my

1580
00:40:19,225 --> 00:40:20,140
0,275
key.|
|

1581
00:40:20,670 --> 00:40:21,350
0,245 245,350 350,470 470,575 575,680
So this is going to
所以这将保证我所有的查找和删除都是 O(1) ，

1582
00:40:21,350 --> 00:40:23,825
0,260 400,675 675,945 945,1340 2050,2475
guarantee that all my lookup

1583
00:40:23,825 --> 00:40:24,770
0,135 135,555 555,675 675,765 765,945
and deletions will be {O(1)

1584
00:40:24,770 --> 00:40:26,300
0,320 340,740
-},| because
|因为不管我有多少哈希函数，

1585
00:40:27,060 --> 00:40:27,920
0,260 260,425 425,575 575,680 680,860
no matter how many hash

1586
00:40:27,920 --> 00:40:30,160
0,180 180,375 375,650
functions I have,|
|

1587
00:40:30,170 --> 00:40:30,925
0,230 230,305 305,470 470,680 680,755
you know, I don't have
我不需要扫一遍，

1588
00:40:30,925 --> 00:40:31,600
0,120 120,285 285,450 450,630 630,675
to scan through,| I'm going
|我会落在我的 HashMap 或哈希表中的某个位置，

1589
00:40:31,600 --> 00:40:32,530
0,90 90,255 255,435 435,660 660,930
to land at some location

1590
00:40:32,530 --> 00:40:33,325
0,150 150,300 300,465 465,585 585,795
in my, in my {HashMap

1591
00:40:33,325 --> 00:40:34,980
0,275 475,810 810,1095 1095,1395 1395,1655
-} or my hash table,|
|

1592
00:40:35,000 --> 00:40:36,160
0,290 290,515 515,710 710,890 890,1160
that has the data that
那里有我正在寻找的数据，

1593
00:40:36,160 --> 00:40:37,030
0,240 240,375 375,570 570,735 735,870
I'm looking for,| or it
|或者它不存在，

1594
00:40:37,030 --> 00:40:38,360
0,300 300,620
doesn't exist,|
|

1595
00:40:39,330 --> 00:40:40,265
0,620 620,680 680,725 725,785 785,935
{insert,is} going to be more
插入将会更昂贵，

1596
00:40:40,265 --> 00:40:41,555
0,300 300,695 835,1170 1170,1245 1245,1290
expensive,| because we'll see it
|因为，我们很快就会看到它，

1597
00:40:41,555 --> 00:40:42,155
0,45 45,120 120,300 300,480 480,600
in a second,| you may
|你可能不得不开始移动东西，重新组织东西。

1598
00:40:42,155 --> 00:40:42,830
0,105 105,180 180,285 285,465 465,675
have to start moving things

1599
00:40:42,830 --> 00:40:44,700
0,195 195,345 345,890 940,1340
around and reorganizing stuff.|
|

1600
00:40:44,770 --> 00:40:46,275
0,395 395,740 740,980 980,1280 1280,1505
So there's only one system
据我所知，只有一个系统做了 Cuckoo 哈希，

1601
00:40:46,275 --> 00:40:47,280
0,165 165,315 315,480 480,690 690,1005
I know that does Cuckoo

1602
00:40:47,280 --> 00:40:48,555
0,345 345,570 570,810 810,1080 1080,1275
hashing,| that publicly talks about
|公开谈论它，

1603
00:40:48,555 --> 00:40:50,550
0,275 415,690 690,960 960,1235 1495,1995
it,| and that's this overlap
|这是来自 IBM 的重叠加速器叫做 BLU, B L U ，

1604
00:40:50,550 --> 00:40:53,160
0,435 435,585 585,1070 1480,1880 2230,2610
accelerator from IBM called BLU

1605
00:40:53,160 --> 00:40:55,155
0,255 255,450 450,770 1660,1905 1905,1995
B L U,| and in
|在他们的论文中，

1606
00:40:55,155 --> 00:40:55,890
0,120 120,315 315,480 480,600 600,735
their paper,| they talk about
|他们谈到了是如何大量使用 Cuckoo 哈希的。

1607
00:40:55,890 --> 00:40:56,790
0,180 180,360 360,480 480,660 660,900
how they make heavy use

1608
00:40:56,790 --> 00:40:58,340
0,255 255,480 480,735 735,1130
of of Cuckoo hashing.|
|

1609
00:40:58,480 --> 00:40:59,265
0,305 305,485 485,605 605,695 695,785
And as far as, you
根据当前所知，

1610
00:40:59,265 --> 00:41:00,060
0,120 120,255 255,465 465,660 660,795
know,| the best {open-source -}
|Cuckoo 哈希表最好的开源实现是，

1611
00:41:00,060 --> 00:41:01,650
0,480 480,630 630,720 720,1130 1270,1590
implementation of a Cuckoo hash

1612
00:41:01,650 --> 00:41:02,960
0,260 430,750 750,915 915,1035 1035,1310
table is actually| from David
|来自 CMU 的 David Anderson ，

1613
00:41:02,980 --> 00:41:05,320
0,400 720,1120 1170,1720
Anderson from CMU,|
|

1614
00:41:06,140 --> 00:41:08,110
0,245 245,380 380,670 960,1360 1650,1970
I think Google, said, David
我认为 Google ， David 声称 Google 大量使用了它。

1615
00:41:08,110 --> 00:41:09,085
0,270 270,540 540,750 750,870 870,975
claims Google uses a lot

1616
00:41:09,085 --> 00:41:09,920
0,105 105,335
of it.|
|

1617
00:41:10,320 --> 00:41:11,330
0,245 245,350 350,470 470,730 750,1010
And so the name has
所以名字， Cuckoo 。

1618
00:41:11,330 --> 00:41:12,140
0,120 120,285 285,450 450,705 705,810
to do, the Cuckoo has

1619
00:41:12,140 --> 00:41:14,000
0,90 90,165 165,410
to do with.|
|

1620
00:41:16,290 --> 00:41:17,255
0,245 245,350 350,485 485,710 710,965
Okay, it {send,by} Google that,
好的， Google 发送的。

1621
00:41:17,255 --> 00:41:21,340
0,245
yeah.|
|

1622
00:41:21,380 --> 00:41:22,960
0,400
So.|
所以。|

1623
00:41:23,780 --> 00:41:24,895
0,275 275,425 425,650 650,1010 1010,1115
So the name Cuckoo has
所以， Cuckoo 这个名字与这种鸟有关，

1624
00:41:24,895 --> 00:41:25,590
0,75 75,150 150,225 225,375 375,695
to do with this bird,|
|

1625
00:41:25,640 --> 00:41:28,080
0,400 780,1180 1680,2000 2000,2180 2180,2440
where they lay their eggs,
它们可以把蛋下到另一个鸟巢里，

1626
00:41:28,130 --> 00:41:28,945
0,260 260,380 380,530 530,665 665,815
they can lay their eggs

1627
00:41:28,945 --> 00:41:30,660
0,210 210,435 435,765 765,1025 1315,1715
in another bird's nest, right,|
|

1628
00:41:30,980 --> 00:41:31,920
0,275 275,395 395,545 545,695 695,940
and so the idea is,|
所以这个想法是，|

1629
00:41:31,940 --> 00:41:33,010
0,350 350,590 590,770 770,920 920,1070
my key may end up,
我的键可能最终会[窃取]别人在我的哈希表中的位置，

1630
00:41:33,010 --> 00:41:33,985
0,210 210,375 375,525 525,810 810,975
may end up [stealing] somebody

1631
00:41:33,985 --> 00:41:35,800
0,405 405,725 1225,1485 1485,1605 1605,1815
else's slot in my hash

1632
00:41:35,800 --> 00:41:36,640
0,210 210,435 435,600 600,750 750,840
table,| if I try to
|如果我试图去那里，而他们正在使用它。

1633
00:41:36,640 --> 00:41:37,765
0,105 105,270 270,560 640,975 975,1125
go there and they're using

1634
00:41:37,765 --> 00:41:38,440
0,305
it.|
|

1635
00:41:38,610 --> 00:41:39,575
0,230 230,395 395,545 545,770 770,965
So let's see examples.| So
让我们来看一些例子。|假设我们有一个简单的哈希表，

1636
00:41:39,575 --> 00:41:40,355
0,180 180,315 315,480 480,675 675,780
say we have, again, we

1637
00:41:40,355 --> 00:41:41,690
0,75 75,180 180,455 805,1095 1095,1335
have a {simple -} hash

1638
00:41:41,690 --> 00:41:43,670
0,260 490,735 735,980 1420,1845 1845,1980
table,| but now anytime we
|但现在任何时候我们做一个操作，

1639
00:41:43,670 --> 00:41:44,735
0,120 120,270 270,590 730,1035 1035,1065
do an operation,| we're going
|我们都会有两个哈希函数，

1640
00:41:44,735 --> 00:41:45,490
0,30 30,120 120,270 270,495 495,755
to have two hash functions,|
|

1641
00:41:45,810 --> 00:41:46,715
0,275 275,485 485,575 575,695 695,905
so it's going to be
所以这将是我们之前讨论的相同的哈希函数实现，

1642
00:41:46,715 --> 00:41:48,670
0,240 240,545 985,1365 1365,1590 1590,1955
the same hash function implementation

1643
00:41:48,780 --> 00:41:49,640
0,245 245,335 335,470 470,650 650,860
that we talked about before,|
|

1644
00:41:49,640 --> 00:41:51,335
0,195 195,510 510,980 1120,1470 1470,1695
like {XXHash -}, {MurmurHash -},
比如 XXHash MurmurHash SpookyHash ，这无关紧要，

1645
00:41:51,335 --> 00:41:52,330
0,270 270,465 465,570 570,750 750,995
{SpookyHash -}, it doesn't matter,|
|

1646
00:41:52,530 --> 00:41:53,240
0,245 245,365 365,470 470,620 620,710
but we'll just give it
但我们给哈希函数一个不同的种子，

1647
00:41:53,240 --> 00:41:54,760
0,90 90,350 370,770
a different seed

1648
00:41:54,760 --> 00:41:55,720
0,300 300,510 510,585 585,780 780,960
{} to the hash function,|
|

1649
00:41:55,720 --> 00:41:56,995
0,210 210,800 820,1035 1035,1095 1095,1275
that guarantees for a given
保证对于给定的键，它并不保证，

1650
00:41:56,995 --> 00:41:58,300
0,335 505,735 735,900 900,1110 1110,1305
key, it doesn't guarantee,| but
|但很可能对于给定的键，

1651
00:41:58,300 --> 00:41:59,380
0,135 135,300 300,570 570,840 840,1080
it's very likely that that

1652
00:41:59,380 --> 00:42:00,685
0,150 150,240 240,435 435,770 970,1305
for a given key,| it's
|它将产生两个不同的哈希值。

1653
00:42:00,685 --> 00:42:02,250
0,245 835,1155 1155,1215 1215,1305 1305,1565
going, it's going to produce

1654
00:42:02,330 --> 00:42:04,120
0,245 245,395 395,665 665,940
two different hash values.|
|

1655
00:42:04,600 --> 00:42:05,715
0,230 230,350 350,665 665,905 905,1115
So I hash A,| and
所以我哈希 A ，|这里有两个位置，

1656
00:42:05,715 --> 00:42:06,735
0,210 210,450 450,600 600,780 780,1020
I have these two locations

1657
00:42:06,735 --> 00:42:07,590
0,315 315,510 510,570 570,660 660,855
here,| so at the very
|所以一开始，

1658
00:42:07,590 --> 00:42:08,370
0,240 240,390 390,570 570,690 690,780
beginning,| my hash table is
|我的哈希表是空的，

1659
00:42:08,370 --> 00:42:09,750
0,230 670,975 975,1125 1125,1215 1215,1380
empty,| so I can either
|所以我可以抛硬币，也可以挑第一个，这都无关紧要，

1660
00:42:09,750 --> 00:42:10,470
0,180 180,315 315,525 525,615 615,720
flip a coin or pick

1661
00:42:10,470 --> 00:42:11,250
0,120 120,285 285,465 465,585 585,780
the first one, it doesn't

1662
00:42:11,250 --> 00:42:12,870
0,260 490,765 765,1005 1005,1380 1380,1620
matter,| and so I'll decide
|所以我决定，对于插入 A ，

1663
00:42:12,870 --> 00:42:15,390
0,350 580,930 930,1455 1455,1730 2260,2520
that for inserting A,| it
|它在这里的第一个 slot ，

1664
00:42:15,390 --> 00:42:16,320
0,120 120,345 345,570 570,735 735,930
goes in the first slot

1665
00:42:16,320 --> 00:42:17,080
0,290
here,|
|

1666
00:42:17,810 --> 00:42:18,835
0,245 245,490 570,800 800,875 875,1025
now I want to put
现在我想把 b 放进去，

1667
00:42:18,835 --> 00:42:21,160
0,195 195,485 1645,1920 1920,2130 2130,2325
B in,| and so the
|所以第一个哈希函数哈希 A 的位置，

1668
00:42:21,160 --> 00:42:22,345
0,180 180,465 465,705 705,1050 1050,1185
first hash function hash to

1669
00:42:22,345 --> 00:42:23,515
0,120 120,300 300,605 715,990 990,1170
where A is,| the second
|第二个哈希函数是空的 slot ，

1670
00:42:23,515 --> 00:42:24,310
0,225 225,420 420,645 645,750 750,795
hash function goes to an

1671
00:42:24,310 --> 00:42:26,455
0,180 180,560 820,1140 1140,1460 1900,2145
empty slot,| so because the
|因为另一个是空的，

1672
00:42:26,455 --> 00:42:27,760
0,120 120,240 240,420 420,845 985,1305
other one is occupied,| I'm
|所以我会一直选择空的，

1673
00:42:27,760 --> 00:42:28,660
0,60 60,225 225,465 465,720 720,900
going to always choose the

1674
00:42:28,660 --> 00:42:29,515
0,150 150,405 405,570 570,720 720,855
empty one| and I'll put
|我会把 B 放在最上面，

1675
00:42:29,515 --> 00:42:30,610
0,305 415,690 690,810 810,945 945,1095
B at the top like

1676
00:42:30,610 --> 00:42:31,300
0,260
that,|
|

1677
00:42:32,500 --> 00:42:33,525
0,290 290,440 440,575 575,725 725,1025
Now where things get tricky
现在事情变得棘手的是，

1678
00:42:33,525 --> 00:42:34,550
0,135 135,285 285,435 435,660 660,1025
is that,| we have multiple,
|我们有两个哈希函数或多个哈希函数哈希到两个位置，

1679
00:42:35,830 --> 00:42:36,795
0,275 275,470 470,650 650,815 815,965
two hash functions or multiple

1680
00:42:36,795 --> 00:42:38,700
0,210 210,455 685,1170 1170,1560 1560,1905
hash functions hash to two

1681
00:42:38,700 --> 00:42:41,205
0,285 285,555 555,840 840,1190 2260,2505
locations that both have,| that
|这两个位置都被占用，

1682
00:42:41,205 --> 00:42:42,230
0,105 105,240 240,360 360,570 570,1025
are both are being occupied,|
|

1683
00:42:43,020 --> 00:42:43,930
0,215 215,260 260,380 380,590 590,910
so in this case here,|
所以在这种情况下，|

1684
00:42:44,190 --> 00:42:45,260
0,320 320,560 560,710 710,845 845,1070
for whatever, you know, whatever
不管什么，不管我们想用什么协议，什么方案，

1685
00:42:45,260 --> 00:42:46,355
0,495 495,765 765,930 930,1020 1020,1095
protocol, whatever scheme we want

1686
00:42:46,355 --> 00:42:46,970
0,75 75,240 240,435 435,525 525,615
to use,| say we can
|比如说我们可以抛硬币，我们决定驱逐 B ，

1687
00:42:46,970 --> 00:42:48,305
0,120 120,255 255,680 760,1095 1095,1335
flip a coin, we decide

1688
00:42:48,305 --> 00:42:49,330
0,165 165,285 285,390 390,690 690,1025
we want to evict B,|
|

1689
00:42:50,290 --> 00:42:51,650
0,335 335,590 590,740 740,1010 1010,1360
so we'll go ahead and
所以我们继续，敲击 B 的头部，

1690
00:42:52,300 --> 00:42:53,330
0,380 380,590 590,695 695,785 785,1030
bash B on the head,|
|

1691
00:42:53,410 --> 00:42:54,720
0,260 260,470 470,800 800,1115 1115,1310
take its location, put C
拿取它的位置，把 C 放进去，

1692
00:42:54,720 --> 00:42:56,300
0,135 135,410 820,1095 1095,1275 1275,1580
in there,| but now we
|但是现在我们要把 B 放回去，

1693
00:42:56,710 --> 00:42:57,930
0,260 260,520 540,785 785,980 980,1220
now we got to put

1694
00:42:57,930 --> 00:42:59,340
0,195 195,420 420,740
B back in,|
|

1695
00:42:59,340 --> 00:43:01,725
0,350 550,950 1210,1590 1590,2145 2145,2385
so because B landed on
因为 B 落在这里，使用了第二个哈希函数，

1696
00:43:01,725 --> 00:43:03,570
0,305 715,1065 1065,1335 1335,1575 1575,1845
this using the second hash

1697
00:43:03,570 --> 00:43:04,620
0,260
function,|
|

1698
00:43:04,890 --> 00:43:06,410
0,335 335,590 590,815 815,1120 1260,1520
after we, after we take
在我们将其取出并放回之后，

1699
00:43:06,410 --> 00:43:07,055
0,105 105,285 285,465 465,555 555,645
it out and put it

1700
00:43:07,055 --> 00:43:08,570
0,135 135,425 595,995 1105,1380 1380,1515
back in,| we use the
|我们使用第一个哈希函数，

1701
00:43:08,570 --> 00:43:10,080
0,180 180,465 465,740
first hash function,|
|

1702
00:43:10,330 --> 00:43:11,235
0,245 245,350 350,545 545,755 755,905
but then that takes us
但这就把我们带到了 A 所在的位置，

1703
00:43:11,235 --> 00:43:12,210
0,120 120,300 300,585 585,810 810,975
to the location where A

1704
00:43:12,210 --> 00:43:13,890
0,225 225,560 910,1260 1260,1500 1500,1680
is located,| so B is
|所以 B 被允许从 A 窃取，

1705
00:43:13,890 --> 00:43:14,750
0,165 165,315 315,450 450,585 585,860
allowed to steal from A,|
|

1706
00:43:15,040 --> 00:43:16,635
0,275 275,455 455,665 665,970 1260,1595
so B goes there, A
所以 B 去了那里， A 出来了，

1707
00:43:16,635 --> 00:43:17,745
0,225 225,480 480,705 705,960 960,1110
comes out,| we hash A
|我们用第二个哈希函数对 A 进行哈希，

1708
00:43:17,745 --> 00:43:18,555
0,105 105,195 195,375 375,615 615,810
with a second hash function,|
|

1709
00:43:18,555 --> 00:43:19,550
0,195 195,315 315,435 435,645 645,995
and then we land to
然后我们落到另一个位置。

1710
00:43:19,930 --> 00:43:21,320
0,380 380,760
another location.|
|

1711
00:43:21,890 --> 00:43:22,795
0,275 275,440 440,590 590,710 710,905
And again, just like before
同样，就像之前的线性探测哈希一样，

1712
00:43:22,795 --> 00:43:24,340
0,315 315,720 720,1245 1245,1455 1455,1545
in {linear,probe} hashing,| you need
|你需要跟踪你是否被困在循环中，

1713
00:43:24,340 --> 00:43:25,060
0,105 105,225 225,405 405,585 585,720
to keep track of, if

1714
00:43:25,060 --> 00:43:26,040
0,210 210,435 435,630 630,720 720,980
you're stuck in a loop,

1715
00:43:26,300 --> 00:43:27,370
0,400 600,815 815,875 875,980 980,1070
right,| so you just got
|所以你要跟踪的是，

1716
00:43:27,370 --> 00:43:28,350
0,75 75,195 195,345 345,600 600,980
to keep track is,| this
|这是键，我把同样的键放进去，

1717
00:43:28,460 --> 00:43:29,530
0,275 275,440 440,635 635,920 920,1070
is the key, I'm putting

1718
00:43:29,530 --> 00:43:30,640
0,290 370,660 660,855 855,1005 1005,1110
in the same key,| I
|我试着首先放在最开始的地方，

1719
00:43:30,640 --> 00:43:31,315
0,105 105,210 210,375 375,540 540,675
try to first put in

1720
00:43:31,315 --> 00:43:32,485
0,105 105,270 270,605 715,960 960,1170
the very beginning| and I've
|我循环回来，我被困在无限循环中，

1721
00:43:32,485 --> 00:43:33,370
0,210 210,330 330,480 480,660 660,885
I've just loop back around

1722
00:43:33,370 --> 00:43:33,940
0,165 165,315 315,420 420,510 510,570
and I'm stuck in an

1723
00:43:33,940 --> 00:43:35,455
0,270 270,530 760,1110 1110,1365 1365,1515
infinite loop| and therefore I
|因此我需要放弃，

1724
00:43:35,455 --> 00:43:36,760
0,120 120,225 225,545 835,1140 1140,1305
need to abort,| double the
|两倍哈希表的大小，并重新哈希所有内容。

1725
00:43:36,760 --> 00:43:37,405
0,135 135,240 240,300 300,480 480,645
size of the hash table

1726
00:43:37,405 --> 00:43:38,640
0,165 165,540 540,935
and rehash everything.|
|

1727
00:43:40,620 --> 00:43:41,495
0,245 245,410 410,560 560,710 710,875
So now when I want
所以现在当我想要查找 B 时，

1728
00:43:41,495 --> 00:43:42,110
0,90 90,165 165,240 240,480 480,615
to do a lookup on

1729
00:43:42,110 --> 00:43:43,160
0,290
B,|
|

1730
00:43:43,820 --> 00:43:45,100
0,290 290,500 500,800 800,1130 1130,1280
I take B, hash it
我使用 B ，对它进行两次哈希，

1731
00:43:45,100 --> 00:43:47,170
0,290 760,1160 1180,1580 1690,1950 1950,2070
twice| and I get two
|我得到了两个不同的位置，

1732
00:43:47,170 --> 00:43:48,175
0,210 210,525 525,750 750,870 870,1005
different locations| and now I
|现在我检查一下，

1733
00:43:48,175 --> 00:43:49,180
0,180 180,465 465,735 735,885 885,1005
do my check to see,|
|

1734
00:43:49,180 --> 00:43:50,260
0,120 120,270 270,540 540,840 840,1080
is the key stored in
存放在这个 slot 中的键是否是我要找的键，

1735
00:43:50,260 --> 00:43:51,505
0,285 285,620 730,1005 1005,1125 1125,1245
this slot the key I'm

1736
00:43:51,505 --> 00:43:52,780
0,135 135,455 565,870 870,1110 1110,1275
looking for,| if yes, then
|如果是，那么我就有我要找的东西了。

1737
00:43:52,780 --> 00:43:53,305
0,90 90,210 210,315 315,405 405,525
I have the thing I'm

1738
00:43:53,305 --> 00:43:54,120
0,135 135,455
looking for.|
|

1739
00:43:54,650 --> 00:43:55,735
0,275 275,500 500,710 710,845 845,1085
Again now, and I don't
现在，我不需要执行线性探测扫描，或者查找空的 slot ，

1740
00:43:55,735 --> 00:43:56,515
0,105 105,240 240,390 390,540 540,780
need to do that linear

1741
00:43:56,515 --> 00:43:57,940
0,240 240,540 540,785 835,1170 1170,1425
probe scanning or looking for

1742
00:43:57,940 --> 00:43:59,125
0,180 180,375 375,740 850,1080 1080,1185
an empty slot,| key I'm
|我在查找的键，

1743
00:43:59,125 --> 00:44:00,550
0,120 120,425 445,675 675,855 855,1425
looking for,| because I'm guaranteed,|
|因为我可以保证，|

1744
00:44:00,550 --> 00:44:01,675
0,350 490,765 765,900 900,1020 1020,1125
either the key is going
哈希之后，要么键就在那里，

1745
00:44:01,675 --> 00:44:03,180
0,105 105,255 255,545 655,990 990,1505
to be there after hashing|
|

1746
00:44:03,830 --> 00:44:04,870
0,275 275,485 485,740 740,920 920,1040
{or,does} not exist in the
要么不在表中。

1747
00:44:04,870 --> 00:44:05,680
0,260
table.|
|

1748
00:44:09,050 --> 00:44:09,715
0,215 215,275 275,350 350,500 500,665
This is a good idea
这是个好主意还是坏主意？

1749
00:44:09,715 --> 00:44:10,980
0,105 105,300 300,635
or bad idea?|
|

1750
00:44:20,080 --> 00:44:20,760
0,260 260,350 350,425 425,545 545,680
He said it seems like
他说，看起来会有更多的碰撞。

1751
00:44:20,760 --> 00:44:21,590
0,75 75,120 120,225 225,420 420,830
there would be more collisions.|
|

1752
00:44:29,520 --> 00:44:31,030
0,260 260,470 470,755 755,1090 1110,1510
Well, no, right, because if,|
好的，不，因为如果，|

1753
00:44:34,450 --> 00:44:35,980
0,365 365,605 605,880
well, so like,|
嗯，就像这样，|

1754
00:44:36,220 --> 00:44:37,860
0,105 105,240 240,435 435,680
there's trade offs, right,|
这是有取舍的，|

1755
00:44:37,900 --> 00:44:38,910
0,305 305,440 440,545 545,695 695,1010
yes, could be more collisions,|
是的，可能会有更多的碰撞，|

1756
00:44:38,910 --> 00:44:39,630
0,225 225,360 360,480 480,585 585,720
but like, at least in
但是，至少在线性探测散列中，

1757
00:44:39,630 --> 00:44:41,400
0,240 240,405 405,860 1030,1380 1380,1770
linear probe hashing,| you're guaranteed
|你保证总是会放一些东西在里面，

1758
00:44:41,400 --> 00:44:42,195
0,120 120,255 255,420 420,615 615,795
to always put something in

1759
00:44:42,195 --> 00:44:43,515
0,275 535,870 870,1065 1065,1215 1215,1320
there, right,| it may be
|它可能在最糟糕的 slot ，

1760
00:44:43,515 --> 00:44:44,280
0,60 60,150 150,315 315,570 570,765
in the worst slot,| maybe
|也许就在你试图进入的那个 slot 的正上方，

1761
00:44:44,280 --> 00:44:46,665
0,290 1570,1920 1920,2100 2100,2265 2265,2385
the slot right above the

1762
00:44:46,665 --> 00:44:47,175
0,105 105,225 225,330 330,420 420,510
one you try to go

1763
00:44:47,175 --> 00:44:48,060
0,240 240,495 495,615 615,720 720,885
into| and you loop back
|然后你循环回来，

1764
00:44:48,060 --> 00:44:49,665
0,320 1000,1230 1230,1305 1305,1455 1455,1605
around,| but at least if
|但至少如果有空的 slot ，你就会得到它。

1765
00:44:49,665 --> 00:44:50,715
0,150 150,225 225,360 360,665 715,1050
there's a free slot, you'll

1766
00:44:50,715 --> 00:44:51,560
0,105 105,365
get it.|
|

1767
00:44:53,350 --> 00:44:54,460
0,400
Yes.|
好的。|

1768
00:44:54,460 --> 00:44:55,720
0,135 135,330 330,585 585,1050 1050,1260

1769
00:44:55,720 --> 00:44:56,640
0,75 75,180 180,330 330,590

1770
00:44:57,150 --> 00:44:58,865
0,290 290,1235 1235,1460 1460,1595 1595,1715
Yeah, he's absolutely right,| so
是的，他说的完全正确，|这是在做随机 IO ，

1771
00:44:58,865 --> 00:44:59,950
0,105 105,225 225,405 405,630 630,1085
this is doing random IOs,|
|

1772
00:45:00,000 --> 00:45:01,385
0,260 260,440 440,650 650,1000 1140,1385
because I'm jumping around,| the
因为我在跳来跳去，|哈希表本质上是随机 IO ，

1773
00:45:01,385 --> 00:45:03,035
0,195 195,345 345,635 1135,1455 1455,1650
hash table is essentially random

1774
00:45:03,035 --> 00:45:04,300
0,315 315,525 525,690 690,915 915,1265
IOs,| but once I land
|但是一旦我落在某个地方，执行随机查找，

1775
00:45:04,350 --> 00:45:05,860
0,400 600,860 860,950 950,1085 1085,1510
somewhere, doing a random lookup,|
|

1776
00:45:06,060 --> 00:45:07,580
0,275 275,425 425,785 785,1060
then a sequential scan,|
那么就是顺序 IO 了，|

1777
00:45:07,620 --> 00:45:09,950
0,275 275,455 455,620 620,880 1950,2330
this is always random, right.|
这永远是随机的。|

1778
00:45:09,950 --> 00:45:18,550
0,380 7810,8115 8115,8280 8280,8370 8370,8600

1779
00:45:27,540 --> 00:45:32,690
0,400 1290,1690 3720,4025 4025,4330 4890,5150

1780
00:45:32,690 --> 00:45:41,885
0,260 2890,3105 3105,3225 3225,3530 8860,9195

1781
00:45:41,885 --> 00:45:43,430
0,335 505,840 840,1110 1110,1380 1380,1545

1782
00:45:43,430 --> 00:45:44,900
0,150 150,315 315,465 465,740

1783
00:45:44,900 --> 00:45:51,040
0,210 210,470 5320,5745 5745,5880 5880,6140
I mean, that's the life.|
我是说，这就是生活。|

1784
00:45:51,480 --> 00:45:56,590
0,395 395,700 1950,2350 4560,4835 4835,5110
It's impressive, yeah,| okay. I
令人印象深刻，|好的，我是说，你是个好 DJ ，

1785
00:45:57,300 --> 00:45:57,935
0,260 260,365 365,485 485,530 530,635
I mean, you're a good

1786
00:45:58,100 --> 00:46:00,155
0,210 210,480 480,740 1660,1935 1935,2055
DJ, it's not,| and you
|你做的数据库，这是有意义的，对吧？

1787
00:46:00,155 --> 00:46:01,390
0,120 120,660 660,795 795,945 945,1235
do databases, that makes sense,

1788
00:46:01,590 --> 00:46:05,280
0,400 2310,2710
right?| Yeah,
|好的，祝贺你。

1789
00:46:05,280 --> 00:46:11,640
0,150 150,410 1180,1610 5980,6240 6240,6360
all right, congrats.| So your
|所以你的问题是？

1790
00:46:11,640 --> 00:46:13,620
0,165 165,470
question was?|
|

1791
00:46:23,340 --> 00:46:24,790
0,260 260,380 380,590 590,845 845,1450

1792
00:46:24,810 --> 00:46:25,700
0,395 395,665 665,860

1793
00:46:27,040 --> 00:46:28,010
0,290 290,395 395,485 485,665 665,970
Yeah, so his question is,|
是的，所以他的问题是，|

1794
00:46:28,360 --> 00:46:29,540
0,260 260,395 395,560 560,710 710,1180
is it possible to parallelize
有没有可能并行通往不同位置的访问？

1795
00:46:29,830 --> 00:46:31,070
0,350 350,575 575,695 695,890 890,1240
the access to different locations?|
|

1796
00:46:33,390 --> 00:46:34,570
0,320 320,545 545,740 740,905 905,1180
Yes, you could do that,|
是的，你可以这么做，|

1797
00:46:35,460 --> 00:46:37,310
0,395 395,790 810,1300 1500,1745 1745,1850
{} like there's two different
有两种不同的并行方式，

1798
00:46:37,310 --> 00:46:38,525
0,120 120,225 225,620 790,1095 1095,1215
ways to parallelize,| we'll eventually
|我们最终会做到这个，

1799
00:46:38,525 --> 00:46:39,950
0,165 165,255 255,485 895,1245 1245,1425
get to there,| like you
|比如你可以有多个线程

1800
00:46:39,950 --> 00:46:41,585
0,60 60,150 150,390 390,980 1270,1635
can have multiple threads| or
|或单个线程做向量化指令， SIMD 指令，

1801
00:46:41,585 --> 00:46:43,835
0,360 360,840 840,990 990,1265 1765,2250
single threads, but do vectorized

1802
00:46:43,835 --> 00:46:46,600
0,285 285,600 600,945 945,1325
instructions, SIMD instructions, like,|
|

1803
00:46:46,670 --> 00:46:49,350
0,400 1050,1370 1370,1865 1865,2135 2375,2680
and for SIMD, this won't,|
对于 SIMD 来说，这不会，|

1804
00:46:49,840 --> 00:46:50,755
0,210 210,465 465,645 645,780 780,915
{} you could do this,|
你可以这样做，|

1805
00:46:50,755 --> 00:46:51,970
0,255 255,570 570,840 840,1020 1020,1215
but it requires you moving
但它需要你移动数据的次数有点多，

1806
00:46:51,970 --> 00:46:52,840
0,270 270,450 450,555 555,675 675,870
data around a bit much,|
|

1807
00:46:52,840 --> 00:46:53,350
0,150 150,210 210,285 285,390 390,510
because you have to make
因为你必须确保数据保持对齐，

1808
00:46:53,350 --> 00:46:56,220
0,120 120,240 240,650 1810,2210
sure things aligned,| but,|
|但是，|

1809
00:46:56,220 --> 00:46:57,915
0,360 360,600 600,825 825,1190 1450,1695
so you may introduce with
所以，你可以引入带有向量化指令的单个线程，

1810
00:46:57,915 --> 00:46:58,995
0,105 105,285 285,510 510,690 690,1080
a single thread with vectorized

1811
00:46:58,995 --> 00:47:01,100
0,335 1105,1380 1380,1605 1605,1860 1860,2105
instructions,| I know there's techniques
|我知道有技术存在，

1812
00:47:01,120 --> 00:47:01,875
0,305 305,440 440,575 575,635 635,755
exist,| I don't know about
|我不知道 Cuckoo 哈希[]，

1813
00:47:01,875 --> 00:47:03,980
0,210 210,450 450,695 1525,1815 1815,2105
Cuckoo hashing [],| but for,
|但要使这个变为多线程，

1814
00:47:04,330 --> 00:47:05,570
0,230 230,335 335,500 500,755 755,1240
to make this multi threaded,|
|

1815
00:47:05,950 --> 00:47:08,385
0,380 380,640 1650,1925 1925,2150 2150,2435
it'd be so much work
它将太多的工作，

1816
00:47:08,385 --> 00:47:09,350
0,195 195,345 345,495 495,660 660,965
or just too much work,|
|

1817
00:47:09,550 --> 00:47:10,700
0,400
to
告诉两个线程，

1818
00:47:11,320 --> 00:47:12,780
0,350 350,605 605,965 965,1205 1205,1460
tell two threads,| okay, we're
|好的，我们在找这个键，

1819
00:47:12,780 --> 00:47:14,145
0,255 255,510 510,830 910,1185 1185,1365
looking this key,| you hash
|你这样哈希它，

1820
00:47:14,145 --> 00:47:14,805
0,105 105,225 225,345 345,540 540,660
it this way,| I'll hash
|我会这样哈希它，

1821
00:47:14,805 --> 00:47:16,100
0,105 105,270 270,575 715,1005 1005,1295
it this way,| and then
|然后同步谁产生了结果，

1822
00:47:16,660 --> 00:47:19,380
0,275 275,550 1470,2030 2030,2380 2430,2720
to then synchronize on who

1823
00:47:19,380 --> 00:47:21,060
0,350 460,825 825,1190 1300,1545 1545,1680
produces back result,| that is
|不值得这样做。

1824
00:47:21,060 --> 00:47:22,280
0,165 165,330 330,495 495,770
just not worth it.|
|

1825
00:47:22,900 --> 00:47:23,980
0,400
Yes.|
是的。|

1826
00:47:27,600 --> 00:47:28,800
0,285 285,540 540,860

1827
00:47:34,020 --> 00:47:35,130
0,260 340,615 615,795 795,960 960,1110

1828
00:47:35,130 --> 00:47:35,340
0,180

1829
00:47:37,410 --> 00:47:38,765
0,290 290,425 425,635 635,910 990,1355

1830
00:47:38,765 --> 00:47:39,660
0,210 210,545

1831
00:47:40,260 --> 00:47:42,050
0,320 320,515 515,695 695,1000 1560,1790
So your question is,| do
所以你的问题是，|你必须保证哈希函数。

1832
00:47:42,050 --> 00:47:43,040
0,60 60,120 120,210 210,470 670,990
you have to guarantee that

1833
00:47:43,040 --> 00:47:48,460
0,320 1330,1650 1650,1910
the hash function.|
|

1834
00:47:49,510 --> 00:47:50,420
0,305 305,610

1835
00:47:51,780 --> 00:47:53,380
0,590 670,1005 1005,1340

1836
00:47:54,220 --> 00:47:55,320
0,400
Yes.|
是的。|

1837
00:47:55,840 --> 00:47:57,190
0,75 75,240 240,560 580,975 975,1350

1838
00:47:58,310 --> 00:48:00,370
0,400 930,1330 1680,1910 1910,1970 1970,2060
So, so do you have
所以，你必须保证你的哈希函数不能这样做，

1839
00:48:00,370 --> 00:48:01,120
0,90 90,255 255,435 435,585 585,750
to guarantee your hash function

1840
00:48:01,120 --> 00:48:03,580
0,240 240,330 330,590 1780,2070 2070,2460
can't do that,| you can't,
|你不能，

1841
00:48:03,580 --> 00:48:05,290
0,320 760,1245 1245,1530 1530,1590 1590,1710
right,| that's, that's why I'm
|这就是为什么我说你想要选择一个碰撞率低的哈希函数，

1842
00:48:05,290 --> 00:48:06,205
0,180 180,405 405,540 540,690 690,915
saying you want to choose

1843
00:48:06,205 --> 00:48:07,240
0,210 210,450 450,660 660,870 870,1035
a hash function that has

1844
00:48:07,240 --> 00:48:08,290
0,165 165,345 345,645 645,885 885,1050
a low collision rate,| so
|你不能保证这不会发生，

1845
00:48:08,290 --> 00:48:09,810
0,260 280,645 645,915 915,1230 1230,1520
the like, you can't guarantee

1846
00:48:09,860 --> 00:48:11,290
0,260 260,470 470,700 990,1250 1250,1430
that won't happen,| but the
|但可以保证它会发生的可能性是低的，

1847
00:48:11,290 --> 00:48:12,640
0,525 525,800 850,1110 1110,1230 1230,1350
likelihood that that it will

1848
00:48:12,640 --> 00:48:13,560
0,260
happen

1849
00:48:14,140 --> 00:48:15,360
0,305 305,610
is low,|
|

1850
00:48:16,330 --> 00:48:16,935
0,230 230,350 350,470 470,530 530,605
the only thing you can
你唯一能得到的就是一个完美的哈希函数。

1851
00:48:16,935 --> 00:48:17,700
0,135 135,345 345,525 525,630 630,765
get to is a perfect

1852
00:48:17,700 --> 00:48:18,840
0,195 195,440
hash function.|
|

1853
00:48:19,400 --> 00:48:20,720
0,180 180,510 510,765 765,1080 1080,1320

1854
00:48:21,450 --> 00:48:22,415
0,275 275,485 485,665 665,785 785,965
His question,| does it default
他的问题，|它默认是线性探测哈希吗，你是什么意思？

1855
00:48:22,415 --> 00:48:23,315
0,165 165,375 375,510 510,690 690,900
to linear probe {hashing -},

1856
00:48:23,315 --> 00:48:26,500
0,135 135,180 180,225 225,455
what do you mean?|
|

1857
00:48:27,720 --> 00:48:29,350
0,305 305,515 515,770 770,1030 1230,1630

1858
00:48:29,400 --> 00:48:31,240
0,400 630,890 890,1040 1040,1330 1440,1840

1859
00:48:32,430 --> 00:48:33,950
0,245 245,320 320,425 425,700 1260,1520

1860
00:48:33,950 --> 00:48:34,750
0,135 135,240 240,345 345,510 510,800

1861
00:48:37,070 --> 00:48:39,010
0,365 365,590 590,850 990,1390 1650,1940
Oh, if I, if I
哦，如果我跑出这个位置，

1862
00:48:39,010 --> 00:48:40,830
0,150 150,410 790,1190 1330,1575 1575,1820
run out locations for this,|
|

1863
00:48:41,480 --> 00:48:42,790
0,365 365,725 725,1010 1010,1145 1145,1310
either because all the slots
要么是因为所有的 slot 都满了，

1864
00:48:42,790 --> 00:48:43,975
0,150 150,410 550,885 885,1080 1080,1185
are full| or I get
|要么是我试图做 Cuckoo 时绕回，

1865
00:48:43,975 --> 00:48:44,830
0,105 105,300 300,570 570,735 735,855
a wrap around when I

1866
00:48:44,830 --> 00:48:45,955
0,165 165,300 300,560 640,900 900,1125
try to do the cuckoo

1867
00:48:45,955 --> 00:48:48,025
0,245 1375,1635 1635,1785 1785,1935 1935,2070
thing,| you double the size
|你把它的大小加倍。

1868
00:48:48,025 --> 00:48:48,760
0,105 105,335
of it.|
|

1869
00:48:50,040 --> 00:48:51,240
0,150 150,375 375,675 675,915 915,1200

1870
00:48:51,240 --> 00:48:53,120
0,360 360,740 970,1370

1871
00:48:54,560 --> 00:48:55,100
0,105 105,195 195,285 285,390 390,540

1872
00:48:55,100 --> 00:48:56,660
0,290 310,705 705,1070 1150,1410 1410,1560

1873
00:48:56,960 --> 00:48:57,805
0,260 260,365 365,485 485,635 635,845

1874
00:48:57,805 --> 00:48:59,300
0,300 300,665 715,1115

1875
00:48:59,470 --> 00:49:00,240
0,245 245,350 350,470 470,605 605,770

1876
00:49:00,240 --> 00:49:01,280
0,210 210,530 550,840 840,990

1877
00:49:02,180 --> 00:49:04,205
0,320 1390,1680 1680,1785 1785,1860 1860,2025
{} Yeah, so his question
是的，所以他的问题是，

1878
00:49:04,205 --> 00:49:04,970
0,180 180,315 315,420 420,555 555,765
is,| is there a defined
|是否有一个定义的顺序，

1879
00:49:04,970 --> 00:49:06,545
0,285 285,525 525,690 690,980 1330,1575
order,| such that like you
|比如你可以总是检查第一个哈希，

1880
00:49:06,545 --> 00:49:07,640
0,90 90,255 255,575 625,915 915,1095
can maybe just always check

1881
00:49:07,640 --> 00:49:09,935
0,180 180,470 1000,1610 1870,2115 2115,2295
the first hash,| like I'm
|我显示的是两行，

1882
00:49:09,935 --> 00:49:10,940
0,195 195,390 390,615 615,855 855,1005
showing two lines coming out

1883
00:49:10,940 --> 00:49:11,765
0,90 90,165 165,330 330,540 540,825
of it,| but in, in
|但在假设它，不平行的情况下，

1884
00:49:11,765 --> 00:49:13,090
0,395 565,810 810,945 945,1050 1050,1325
a assume it's not parallel,|
|

1885
00:49:13,350 --> 00:49:15,730
0,260 260,520 930,1280 1280,1810 1980,2380
it is executing sequentially,| like
它是按顺序执行的，|比如，有什么协议，检查这个，

1886
00:49:16,020 --> 00:49:17,860
0,260 260,520
could I,

1887
00:49:18,080 --> 00:49:19,090
0,260 260,380 380,515 515,815 815,1010
is there some protocol, say,

1888
00:49:19,090 --> 00:49:20,700
0,315 315,710
check this,|
|

1889
00:49:20,700 --> 00:49:22,125
0,240 240,500 550,945 945,1260 1260,1425
and then only fetch the
然后，只获取第二个页面，

1890
00:49:22,125 --> 00:49:23,145
0,275 325,570 570,675 675,840 840,1020
page for the second one,|
|

1891
00:49:23,145 --> 00:49:23,930
0,120 120,255 255,405 405,525 525,785
if I if I know
如果我知道它不会在那里，

1892
00:49:24,130 --> 00:49:24,750
0,290 290,380 380,470 470,530 530,620
it's not going to be

1893
00:49:24,750 --> 00:49:25,815
0,260 490,750 750,870 870,975 975,1065
there,| I mean, you can
|我的意思是，你可以做很多事情，

1894
00:49:25,815 --> 00:49:26,295
0,75 75,120 120,195 195,330 330,480
do a bunch of everything,|
|

1895
00:49:26,295 --> 00:49:27,225
0,90 90,150 150,270 270,690 690,930
so you could prefetch the
这样你就可以预取第二页，

1896
00:49:27,225 --> 00:49:28,540
0,210 210,545
second page,

1897
00:49:28,610 --> 00:49:30,205
0,400 630,950 950,1130 1130,1445 1445,1595
right,| because the hashing is
|因为哈希实际上很便宜。

1898
00:49:30,205 --> 00:49:31,390
0,210 210,420 420,660 660,825 825,1185
actually cheap,| it's the lookup
|查找是很昂贵的，

1899
00:49:31,390 --> 00:49:33,940
0,240 240,600 600,980 1480,1880 2170,2550
is expensive, right,| so maybe
|所以也许我我可以选一个，

1900
00:49:33,940 --> 00:49:36,220
0,360 360,740 1300,1620 1620,1920 1920,2280
I I could choose one

1901
00:49:36,220 --> 00:49:37,280
0,380
that,|
|

1902
00:49:37,610 --> 00:49:38,950
0,275 275,485 485,770 770,1010 1010,1340
I have two page IDs
我有两个页面 ID ，我去查了一下，

1903
00:49:38,950 --> 00:49:39,810
0,105 105,210 210,390 390,585 585,860
I went into look up,|
|

1904
00:49:40,220 --> 00:49:40,855
0,260 260,365 365,455 455,545 545,635
so if I have a
所以，如果我有一个方法，首先检查哪个存在，

1905
00:49:40,855 --> 00:49:41,950
0,120 120,255 255,515 595,885 885,1095
way to go which one

1906
00:49:41,950 --> 00:49:43,075
0,225 225,450 450,705 705,945 945,1125
actually exists first,| maybe go
|也许去检查那一下，预取另一个，

1907
00:49:43,075 --> 00:49:44,380
0,150 150,300 300,1080 1080,1185 1185,1305
check that {one\,,prefetch} the other

1908
00:49:44,380 --> 00:49:46,300
0,290 610,870 870,1130 1510,1785 1785,1920
one,| again, it depends on
|同样，这取决于实现。

1909
00:49:46,300 --> 00:49:47,380
0,120 120,240 240,500
the {implementation -}.|
|

1910
00:49:50,060 --> 00:49:50,990
0,180 180,375 375,570 570,750 750,930

1911
00:49:50,990 --> 00:49:52,205
0,240 240,420 420,740 850,1110 1110,1215

1912
00:49:52,205 --> 00:49:52,640
0,180 180,405

1913
00:49:52,640 --> 00:49:53,720
0,500

1914
00:49:54,340 --> 00:49:55,045
0,120 120,300 300,420 420,570 570,705

1915
00:49:55,045 --> 00:49:55,500
0,120 120,395

1916
00:49:58,310 --> 00:49:59,725
0,365 365,730 840,1130 1130,1295 1295,1415
But, but it depending on
但是，这取决于插入的是什么和你是如何移动的，

1917
00:49:59,725 --> 00:50:00,685
0,135 135,300 300,735 735,855 855,960
what got inserted and how

1918
00:50:00,685 --> 00:50:01,510
0,90 90,210 210,345 345,525 525,825
you think, got moving around,|
|

1919
00:50:01,510 --> 00:50:05,005
0,380 1120,1365 1365,1610 2830,3230 3250,3495
like, you know, but the
但事实是我们提出了这么多。

1920
00:50:05,005 --> 00:50:05,485
0,120 120,210 210,315 315,405 405,480
fact that we're coming up

1921
00:50:05,485 --> 00:50:06,360
0,60 60,165 165,420 420,645 645,875
with sort of so many.|
|

1922
00:50:10,020 --> 00:50:13,090
0,245 245,350 350,530 530,850 2670,3070
Is there another woman,| is
有别的女人吗，|是要上厕所吗，

1923
00:50:13,680 --> 00:50:14,450
0,230 230,305 305,515 515,710 710,770
going to bathroom,| what is
|他在干什么？

1924
00:50:14,450 --> 00:50:16,860
0,75 75,320
he doing?|
|

1925
00:50:18,700 --> 00:50:20,220
0,400 750,1025 1025,1220 1220,1385 1385,1520
Anyway, yeah.| So the fact
无论什么，是的。|所以我们有不同的方式来做这件事，

1926
00:50:20,220 --> 00:50:21,060
0,150 150,255 255,465 465,690 690,840
we coming of different ways

1927
00:50:21,060 --> 00:50:21,960
0,105 105,225 225,435 435,690 690,900
to do this,| it shows
|这表明线性探测哈希是多复杂，

1928
00:50:21,960 --> 00:50:23,280
0,165 165,420 420,690 690,960 960,1320
how complicated is where linear

1929
00:50:23,280 --> 00:50:24,375
0,225 225,405 405,650 730,975 975,1095
{probe,hashing},| you just kind of
|你只是有点[]它。

1930
00:50:24,375 --> 00:50:31,240
0,180 180,315 315,575 835,1235
[] through it, right?|
|

1931
00:50:31,760 --> 00:50:32,605
0,275 275,440 440,605 605,725 725,845
This question is,| in a
这个问题是，|在一般系统中，默认的是什么，

1932
00:50:32,605 --> 00:50:33,700
0,180 180,465 465,795 795,990 990,1095
general system, what, what is

1933
00:50:33,700 --> 00:50:34,830
0,165 165,465 465,720 720,900 900,1130
the default,| I don't know,
|我不知道，我们可以去查一下 David 的代码，

1934
00:50:35,150 --> 00:50:36,025
0,245 245,350 350,500 500,635 635,875
we can go look up

1935
00:50:36,025 --> 00:50:37,765
0,330 330,795 795,1115 1375,1635 1635,1740
on David's code,| default, it
|默认可能是[三]，

1936
00:50:37,765 --> 00:50:39,160
0,90 90,225 225,515
might be three,|
|

1937
00:50:39,160 --> 00:50:40,320
0,150 150,270 270,390 390,650 760,1160
I have no idea, yeah.|
我不知道，是的。|

1938
00:50:41,830 --> 00:50:42,920
0,400
{All,Right}.|
好的。|

1939
00:50:43,130 --> 00:50:43,915
0,245 245,320 320,380 380,500 500,785
I want to get through
我想通过链式散列，因为我们的其中一个项目需要这个。

1940
00:50:43,915 --> 00:50:47,845
0,395 1105,1380 1380,2745 2745,3005 3625,3930
the chain hashing because we'll

1941
00:50:47,845 --> 00:50:48,625
0,120 120,315 315,555 555,720 720,780
need this for one of

1942
00:50:48,625 --> 00:50:50,520
0,75 75,335
the projects.|
|

1943
00:50:50,710 --> 00:50:51,930
0,245 245,490 630,920 920,1070 1070,1220
So again, all of these
所以，到目前为止，我展示的所有这些协议都是静态散列方案。再说一次，如果我们耗尽了空间或循环返回，那么我们需要这样做。

1944
00:50:51,930 --> 00:50:53,130
0,405 405,540 540,720 720,945 945,1200
protocols I've showed so far,

1945
00:50:53,130 --> 00:50:54,390
0,240 240,345 345,540 540,870 870,1260
these are all static hashing

1946
00:50:54,390 --> 00:50:55,650
0,440 610,870 870,975 975,1110 1110,1260
schemes. Again, if we run

1947
00:50:55,650 --> 00:50:56,930
0,120 120,255 255,510 510,885 885,1280
out of space or we

1948
00:50:57,070 --> 00:50:58,665
0,260 260,425 425,730 990,1310 1310,1595
loop back around, then we

1949
00:50:58,665 --> 00:50:59,680
0,225 225,485
need to.|
|

1950
00:51:00,020 --> 00:51:00,790
0,305 305,470 470,605 605,710 710,770
Double the size of the
将哈希表的大小加倍并重新填充它，这是很昂贵的。

1951
00:51:00,790 --> 00:51:01,705
0,135 135,270 270,435 435,855 855,915
hash table and repopulate it,

1952
00:51:01,705 --> 00:51:02,980
0,60 60,300 300,605
and that's expensive.|
|

1953
00:51:03,080 --> 00:51:04,315
0,400 600,845 845,935 935,1070 1070,1235
So we will now talk
因此，我们现在将讨论不同的技术来增量地调整哈希表的大小，而不必重建整个哈希表。

1954
00:51:04,315 --> 00:51:06,490
0,180 180,375 375,665 775,1175 1585,2175
about different techniques to incrementally

1955
00:51:06,490 --> 00:51:08,155
0,360 360,525 525,750 750,1010 1270,1665
resize the hash table without

1956
00:51:08,155 --> 00:51:09,445
0,330 330,540 540,885 885,1065 1065,1290
having to rebuild the entire

1957
00:51:09,445 --> 00:51:10,320
0,335
thing.|
|

1958
00:51:10,610 --> 00:51:11,605
0,260 260,350 350,485 485,710 710,995
So the most common one
因此，最常见的方法是链式散列。同样，当你偶尔想到哈希表时，大多数人都会想到这一点，但他们会看看实际系统中实际使用的两种更高级的技术。

1959
00:51:11,605 --> 00:51:12,745
0,75 75,165 165,420 420,720 720,1140
going to be chain hashing.

1960
00:51:12,745 --> 00:51:13,375
0,195 195,345 345,435 435,510 510,630
And again, this is what

1961
00:51:13,375 --> 00:51:14,095
0,135 135,285 285,420 420,570 570,720
most people think of when

1962
00:51:14,095 --> 00:51:14,815
0,90 90,210 210,345 345,540 540,720
you think about hash tables

1963
00:51:14,815 --> 00:51:17,215
0,335 1645,1935 1935,2085 2085,2190 2190,2400
sometimes and then, but they'll

1964
00:51:17,215 --> 00:51:18,055
0,105 105,300 300,480 480,630 630,840
look at two more advanced

1965
00:51:18,055 --> 00:51:21,220
0,305 955,1355 2485,2730 2730,2895 2895,3165
techniques that actually are used

1966
00:51:21,220 --> 00:51:22,640
0,240 240,420 420,710
in real systems.|
|

1967
00:51:24,310 --> 00:51:25,800
0,305 305,515 515,1000 1020,1265 1265,1490
So chain hashing, the basic
所以链式散列的基本思想是。

1968
00:51:25,800 --> 00:51:27,140
0,225 225,345 345,620
idea is that.|
|

1969
00:51:27,150 --> 00:51:28,420
0,260 260,395 395,670 690,980 980,1270
Instead of having this giant
数组不是包含我们实际插入关键字的所有槽的巨大数组，而是指向链接列表或链或桶的指针。

1970
00:51:28,590 --> 00:51:30,530
0,400 450,850 1260,1550 1550,1700 1700,1940
array of all the slots

1971
00:51:30,530 --> 00:51:31,630
0,210 210,390 390,555 555,795 795,1100
where we actually insert keys,

1972
00:51:33,300 --> 00:51:34,115
0,320 320,500 500,635 635,740 740,815
array is just going to

1973
00:51:34,115 --> 00:51:36,860
0,210 210,750 750,1115 2095,2460 2460,2745
be pointers to essentially link

1974
00:51:36,860 --> 00:51:39,010
0,500 520,920 1180,1530 1530,1725 1725,2150
lists or chains or buckets

1975
00:51:39,270 --> 00:51:40,480
0,400
where.|
|

1976
00:51:40,600 --> 00:51:41,910
0,380 380,650 650,845 845,1055 1055,1310
All the keys that map
在我们的哈希表中映射到该槽的所有键都将在该链表中的槽中找到。

1977
00:51:41,910 --> 00:51:43,590
0,350 610,1005 1005,1365 1365,1560 1560,1680
to that slot in our

1978
00:51:43,590 --> 00:51:45,000
0,210 210,470 700,975 975,1140 1140,1410
hash table will be found

1979
00:51:45,000 --> 00:51:46,050
0,270 270,465 465,630 630,810 810,1050
in that in that linked

1980
00:51:46,050 --> 00:51:47,140
0,320
list.|
|

1981
00:51:47,150 --> 00:51:48,745
0,400 810,1070 1070,1175 1175,1490 1490,1595
Right. If you allocate a
正确的。如果您在Java中分配一个散列映射，这基本上就是您所得到的。

1982
00:51:48,745 --> 00:51:50,185
0,225 225,360 360,495 495,995 1195,1440
hash map in Java, this

1983
00:51:50,185 --> 00:51:51,000
0,135 135,315 315,450 450,555 555,815
is essentially what you get.|
|

1984
00:51:51,750 --> 00:51:52,775
0,260 260,365 365,485 485,740 740,1025
And so the, the linked
因此，链表部分基本上可以无限增长，因为在最坏的情况下，我的所有键都散列到同一个槽。我只是，我只是添加到这个巨大的列表中，我，我正在倒下，或者基本上是以顺序扫描结束。但再说一次，理想情况下，如果我有一个好的散列函数，我就不会有，我会有一个很好的密钥分发。

1985
00:51:52,775 --> 00:51:54,050
0,225 225,465 465,735 735,1035 1035,1275
list part can essentially grow

1986
00:51:54,050 --> 00:51:56,120
0,680 1030,1395 1395,1725 1725,1965 1965,2070
infinitely because again, in the

1987
00:51:56,120 --> 00:51:57,035
0,120 120,285 285,510 510,750 750,915
worst case scenario, all my

1988
00:51:57,035 --> 00:51:57,890
0,195 195,465 465,570 570,675 675,855
keys hash to the same

1989
00:51:57,890 --> 00:51:59,615
0,350 550,990 990,1230 1230,1305 1305,1725
slot. I'm, I'm just appending

1990
00:51:59,615 --> 00:52:01,100
0,120 120,240 240,450 450,785 1195,1485
to this giant list and

1991
00:52:01,100 --> 00:52:02,780
0,510 510,855 855,1080 1080,1395 1395,1680
I'm, I'm falling down or

1992
00:52:02,780 --> 00:52:03,890
0,290 520,780 780,885 885,990 990,1110
basically end up with a

1993
00:52:03,890 --> 00:52:06,200
0,300 300,590 970,1230 1230,1490 1750,2310
sequential scan. But again, ideally

1994
00:52:06,200 --> 00:52:06,725
0,60 60,120 120,195 195,300 300,525
if I have a hash

1995
00:52:06,725 --> 00:52:08,240
0,210 210,480 480,725 955,1230 1230,1515
function that's good, I won't.

1996
00:52:08,240 --> 00:52:09,250
0,225 225,330 330,450 450,660 660,1010
I'll have a good distribution

1997
00:52:09,330 --> 00:52:11,160
0,400 930,1330
of keys.|
|

1998
00:52:11,620 --> 00:52:12,375
0,245 245,350 350,470 470,605 605,755
The way to think about
考虑这一点的方法是，我们实际上是在对我们的巨型哈希表进行分区。我们以前已经分成了更小的哈希表本身，或者更小的表。

1999
00:52:12,375 --> 00:52:14,025
0,120 120,365 445,795 795,1055 1075,1650
this is we're essentially partitioning

2000
00:52:14,025 --> 00:52:15,045
0,275 295,615 615,840 840,930 930,1020
our giant hash table. We

2001
00:52:15,045 --> 00:52:18,570
0,165 165,485 715,1115 2995,3300 3300,3525
have before into smaller hash

2002
00:52:18,570 --> 00:52:19,760
0,240 240,525 525,690 690,870 870,1190
tables themselves, or smaller tables.|
|

2003
00:52:20,530 --> 00:52:22,425
0,400 1230,1475 1475,1565 1565,1670 1670,1895
EM, we can get unique
嗯，我们可以用我们以前做过的同样的技巧来获得唯一的密钥。只要继续把多余的钥匙添加到这个巨大的列表中就行了。我们仍然可以使用Tombone，但在这种情况下，压缩通常会更快。

2004
00:52:22,425 --> 00:52:23,280
0,285 285,450 450,540 540,675 675,855
keys doing the same tricks

2005
00:52:23,280 --> 00:52:25,185
0,90 90,195 195,440 1360,1710 1710,1905
we did before. Just keep

2006
00:52:25,185 --> 00:52:26,835
0,480 480,815 865,1305 1305,1485 1485,1650
appending the redundant keys to

2007
00:52:26,835 --> 00:52:28,575
0,105 105,270 270,575 1405,1650 1650,1740
this giant list. We can

2008
00:52:28,575 --> 00:52:30,150
0,120 120,285 285,785 835,1140 1140,1575
still use tombones, but oftentimes

2009
00:52:30,150 --> 00:52:32,130
0,410 430,705 705,980 1480,1815 1815,1980
compaction is just faster in

2010
00:52:32,130 --> 00:52:33,020
0,105 105,380
this case.|
|

2011
00:52:34,300 --> 00:52:35,295
0,305 305,470 470,665 665,860 860,995
Right. So now again we
正确的。现在我们又有了桶指针，这就是哈希函数要散列的地方。然后这些只是指向存在的不同桶的指针。所以如果我们想把一个放进去，我们用我们拥有的桶指针的数量来散列它，然后我们就落在那个桶里。我们找到第一个空闲的位置，然后将其插入。

2012
00:52:35,295 --> 00:52:36,180
0,195 195,420 420,570 570,705 705,885
have here we have our

2013
00:52:36,180 --> 00:52:37,635
0,225 225,710 880,1140 1140,1275 1275,1455
bucket pointers and this is

2014
00:52:37,635 --> 00:52:39,210
0,305 715,1065 1065,1275 1275,1485 1485,1575
where hash functions are going

2015
00:52:39,210 --> 00:52:40,520
0,60 60,225 225,470 790,1050 1050,1310
to hash into. And then

2016
00:52:40,540 --> 00:52:41,820
0,305 305,455 455,605 605,845 845,1280
these are just be pointers

2017
00:52:41,820 --> 00:52:43,800
0,320 1030,1290 1290,1470 1470,1785 1785,1980
to the different buckets that

2018
00:52:43,800 --> 00:52:45,465
0,320 1000,1335 1335,1515 1515,1590 1590,1665
exist. So if we want

2019
00:52:45,465 --> 00:52:46,515
0,90 90,210 210,390 390,695 775,1050
to put a in, we

2020
00:52:46,515 --> 00:52:47,430
0,225 225,375 375,555 555,750 750,915
hash it mod in by

2021
00:52:47,430 --> 00:52:48,660
0,105 105,240 240,390 390,650 850,1230
the number of bucket pointers

2022
00:52:48,660 --> 00:52:49,680
0,105 105,350 580,825 825,915 915,1020
we have and then we

2023
00:52:49,680 --> 00:52:50,715
0,150 150,285 285,420 420,710 760,1035
land in that bucket. We

2024
00:52:50,715 --> 00:52:51,680
0,150 150,285 285,450 450,645 645,965
find the first free slot

2025
00:52:51,880 --> 00:52:52,910
0,275 275,395 395,500 500,770 770,1030
and we just insert it.|
|

2026
00:52:54,350 --> 00:52:55,520
0,400
Right.|
正确的。|

2027
00:52:55,520 --> 00:52:56,270
0,240 240,495 495,555 555,615 615,750
Same thing, going to put
同样的，把B放到顶端，就像以前一样。

2028
00:52:56,270 --> 00:52:57,080
0,255 255,495 495,630 630,720 720,810
B B goes to the

2029
00:52:57,080 --> 00:52:58,600
0,165 165,470 850,1125 1125,1260 1260,1520
top here just as before.|
|

2030
00:52:59,840 --> 00:53:00,715
0,245 245,350 350,500 500,650 650,875
And then now, in case
现在，如果CC散列到a所在的同一存储桶，我们只需顺序扫描，直到找到第一个空闲插槽。

2031
00:53:01,075 --> 00:53:02,790
0,395 715,1185 1185,1305 1305,1440 1440,1715
CC hashes to the same

2032
00:53:02,870 --> 00:53:05,670
0,400 1380,1780 1950,2240 2240,2465 2465,2800
bucket where a is located,

2033
00:53:05,930 --> 00:53:07,375
0,260 260,520 570,875 875,1055 1055,1445
we just scan through sequentially

2034
00:53:07,375 --> 00:53:08,905
0,120 120,240 240,515 1105,1365 1365,1530
until we find the first

2035
00:53:08,905 --> 00:53:10,040
0,180 180,485
free slot.|
|

2036
00:53:12,730 --> 00:53:17,760
0,245 245,335 335,580
Take a call.|
接个电话。|

2037
00:53:17,760 --> 00:53:18,950
0,315 315,510 510,675 675,885 885,1190
Uh, you put d and
呃，你把D和D放在A的位置。它可以扫过。所有的插槽都是空的。你可以在页眉中放一些东西，然后说我没有更多的空位了。因此，永远要扩展我。当你找到我的时候，这都不重要了。然后，基本上这里的页面将指向另一个页面，在那里您可以找到d。

2038
00:53:19,600 --> 00:53:20,625
0,290 290,470 470,665 665,845 845,1025
d goes where where a

2039
00:53:20,625 --> 00:53:22,605
0,305 475,875 1105,1455 1455,1740 1740,1980
is. It scans through. All

2040
00:53:22,605 --> 00:53:23,625
0,135 135,300 300,390 390,605 775,1020
the slots are empty. You

2041
00:53:23,625 --> 00:53:24,180
0,90 90,195 195,330 330,450 450,555
can put something in the

2042
00:53:24,180 --> 00:53:24,930
0,165 165,405 405,480 480,615 615,750
page header and say I

2043
00:53:24,930 --> 00:53:25,820
0,135 135,255 255,375 375,540 540,890
have no more free slots.

2044
00:53:25,900 --> 00:53:27,105
0,305 305,560 560,815 815,1040 1040,1205
Therefore, always expand me. When

2045
00:53:27,105 --> 00:53:28,020
0,90 90,210 210,315 315,545 655,915
you get to me, it

2046
00:53:28,020 --> 00:53:30,830
0,225 225,470 910,1185 1185,1460 2410,2810
doesn't matter. And then basically

2047
00:53:31,390 --> 00:53:32,325
0,305 305,515 515,680 680,785 785,935
this page here will then

2048
00:53:32,325 --> 00:53:33,765
0,195 195,345 345,525 525,845 1195,1440
point to another page where

2049
00:53:33,765 --> 00:53:34,940
0,90 90,210 210,405 405,725
you can find d.|
|

2050
00:53:35,010 --> 00:53:35,630
0,260 260,365 365,455 455,530 530,620
And then we want to
然后我们想把e放在后面，直到我们在这里找到。

2051
00:53:35,630 --> 00:53:37,400
0,135 135,410 820,1200 1200,1515 1515,1770
put e and follow through

2052
00:53:37,400 --> 00:53:38,650
0,150 150,380 490,795 795,975 975,1250
until we find e here.|
|

2053
00:53:39,140 --> 00:53:40,100
0,260
Right.|
正确的。|

2054
00:53:40,430 --> 00:53:41,640
0,395 395,680 680,830 830,950 950,1210
And f can go here.|
F可以放在这里。|

2055
00:53:43,540 --> 00:53:44,580
0,260 260,500 500,740 740,890 890,1040
So again, the nice thing
这样做的好处是，我可以在一个存储桶中增加密钥列表，而不会影响。

2056
00:53:44,580 --> 00:53:45,405
0,135 135,300 300,450 450,630 630,825
about this is that I

2057
00:53:45,405 --> 00:53:48,690
0,210 210,545 805,1205 1585,1985 2995,3285
can grow the the key

2058
00:53:48,690 --> 00:53:50,085
0,150 150,315 315,480 480,740 1000,1395
list within a bucket without

2059
00:53:50,085 --> 00:53:51,800
0,420 420,660 660,1005 1005,1350 1350,1715
affecting other parts of the.|
|

2060
00:53:52,580 --> 00:53:54,220
0,260 460,720 720,980
Of the table.|
餐桌上的。|

2061
00:53:54,260 --> 00:53:55,340
0,400
But.|
但。|

2062
00:53:55,590 --> 00:53:56,510
0,290 290,485 485,680 680,830 830,920
You can have a sort
你可以有一个两级，两级的哈希表，像这样是一个哈希表，把你带到这些桶中，另一个哈希表，但简单的是，我们只是把它显示为一个链表，就像这样。

2063
00:53:56,510 --> 00:53:57,425
0,60 60,180 180,330 330,590 640,915
of like two level, two

2064
00:53:57,425 --> 00:53:58,390
0,165 165,390 390,555 555,720 720,965
level hash tables where like

2065
00:53:58,470 --> 00:53:59,450
0,290 290,425 425,515 515,740 740,980
this is a hash table

2066
00:53:59,450 --> 00:54:00,425
0,240 240,375 375,480 480,705 705,975
that takes you into these

2067
00:54:00,425 --> 00:54:03,080
0,425 805,1095 1095,1305 1305,1565 2365,2655
buckets, another hash table, but

2068
00:54:03,080 --> 00:54:04,085
0,555 555,705 705,780 780,915 915,1005
simplicity, we're just showing it

2069
00:54:04,085 --> 00:54:04,850
0,120 120,285 285,405 405,570 570,765
as as a linked list

2070
00:54:04,850 --> 00:54:05,880
0,165 165,440
like this.|
|

2071
00:54:06,890 --> 00:54:08,220
0,290 290,470 470,725 725,1010 1010,1330
But doing that, yes, question.|
但这样做，是的，有问题。|

2072
00:54:12,240 --> 00:54:12,995
0,260 260,395 395,530 530,635 635,755
This question is when you
这个问题是，当您创建一个新的存储桶时，如何确定它的大小？

2073
00:54:12,995 --> 00:54:13,775
0,135 135,240 240,360 360,585 585,780
create a new bucket, how

2074
00:54:13,775 --> 00:54:14,540
0,75 75,240 240,465 465,615 615,765
do you determine the size

2075
00:54:14,540 --> 00:54:17,120
0,135 135,380
of it?|
|

2076
00:54:17,780 --> 00:54:18,750
0,290 290,410 410,575 575,710 710,970
We're not talking about whether
我们不是在讨论这节课是否，我们没有讨论，像是磁盘上或内存中的页面支持，但如果它是，呃，假设它是由磁盘上的页面支持的，并且是缓冲的。因此，无论数据库中的页面大小是多少，都是存储桶的页面大小。

2077
00:54:19,040 --> 00:54:19,825
0,245 245,350 350,515 515,650 650,785
for this lecture, we haven't

2078
00:54:19,825 --> 00:54:20,725
0,90 90,195 195,330 330,675 675,900
talked about whether something like

2079
00:54:20,725 --> 00:54:22,330
0,285 285,465 465,785 1105,1410 1410,1605
backed by pages from on

2080
00:54:22,330 --> 00:54:24,280
0,530 580,840 840,975 975,1250 1690,1950
disk or in memory, but

2081
00:54:24,280 --> 00:54:25,140
0,150 150,315 315,450 450,585 585,860
like if it is a,

2082
00:54:25,400 --> 00:54:27,540
0,400 1200,1475 1475,1655 1655,1895 1895,2140
uh, assume it's backed by

2083
00:54:27,980 --> 00:54:28,960
0,335 335,515 515,590 590,710 710,980
pages that are on disk

2084
00:54:28,960 --> 00:54:30,420
0,60 60,135 135,500 790,1125 1125,1460
and are buffer. So if

2085
00:54:30,560 --> 00:54:31,510
0,260 260,395 395,590 590,815 815,950
whatever the page size in

2086
00:54:31,510 --> 00:54:32,515
0,75 75,320 490,855 855,915 915,1005
the database, that'll be the

2087
00:54:32,515 --> 00:54:33,450
0,135 135,390 390,600 600,690 690,935
page size of a bucket.|
|

2088
00:54:34,620 --> 00:54:35,645
0,290 290,455 455,755 755,875 875,1025
So in postco is eight
所以在POSTCO中是8千字节。我的SQL是16K字节，对吗？

2089
00:54:35,645 --> 00:54:37,580
0,545 1105,1395 1395,1605 1605,1710 1710,1935
kilobytes. My sql is sixteen

2090
00:54:37,580 --> 00:54:38,960
0,570 570,950
kilobytes, right?|
|

2091
00:54:41,050 --> 00:54:42,360
0,365 365,545 545,770 770,1010 1010,1310
I'm showing within one page
我在一页两页内展示了两个关键字，因为它是PowerPoint。

2092
00:54:42,360 --> 00:54:44,115
0,380 490,780 780,1005 1005,1340 1450,1755
two, two keys because it's

2093
00:54:44,115 --> 00:54:45,380
0,425
powerpoint.|
|

2094
00:54:46,750 --> 00:54:47,870
0,260 260,440 440,635 635,815 815,1120
So again, if I have
再说一次，如果我有很多密钥，散列在同一个位置，这种线性扫描可能会很昂贵。实际上，您可以在存储桶指针列表中进行一个非常简单的优化。您还可以存储Bloom滤镜。

2095
00:54:48,460 --> 00:54:49,350
0,260 260,395 395,515 515,665 665,890
a lot of keys, hash

2096
00:54:49,350 --> 00:54:50,720
0,75 75,150 150,315 315,650 970,1370
in the same location, this

2097
00:54:51,070 --> 00:54:52,500
0,440 440,695 695,935 935,1175 1175,1430
linear scan here can be

2098
00:54:52,500 --> 00:54:54,030
0,320 850,1155 1155,1290 1290,1365 1365,1530
expensive. So actually a really

2099
00:54:54,030 --> 00:54:55,190
0,240 240,615 615,780 780,900 900,1160
simple optimization you can do

2100
00:54:55,420 --> 00:54:57,375
0,400 870,1175 1175,1385 1385,1625 1625,1955
is in your bucket pointer

2101
00:54:57,375 --> 00:54:59,130
0,275 595,840 840,1035 1035,1385 1465,1755
list. You also store a

2102
00:54:59,130 --> 00:55:00,260
0,195 195,470
bloom filter.|
|

2103
00:55:00,840 --> 00:55:01,820
0,275 275,455 455,665 665,830 830,980
That just tells you whether
这只是告诉您在我的链接列表中是否存在一个键。所以，如果我现在想要在G中查找，我首先检查布隆过滤器。我问它是否存在。

2104
00:55:01,820 --> 00:55:03,275
0,195 195,465 465,830 850,1215 1215,1455
a key exists in in

2105
00:55:03,275 --> 00:55:04,430
0,165 165,345 345,635 895,1110 1110,1155
my linked list. So if

2106
00:55:04,430 --> 00:55:05,015
0,90 90,195 195,315 315,450 450,585
I want to look up

2107
00:55:05,015 --> 00:55:06,605
0,165 165,375 375,695 1045,1350 1350,1590
now in G I first

2108
00:55:06,605 --> 00:55:07,625
0,210 210,360 360,555 555,810 810,1020
check the bloom filter. I

2109
00:55:07,625 --> 00:55:08,420
0,135 135,270 270,405 405,600 600,795
ask it whether it exists

2110
00:55:08,420 --> 00:55:09,400
0,150 150,410
or not.|
|

2111
00:55:09,400 --> 00:55:11,125
0,350 580,960 960,1320 1320,1545 1545,1725
If yes, then then I'll
如果是，那么我将继续沿着指针前进，然后扫描到我找到我正在寻找的东西，如果不是。

2112
00:55:11,125 --> 00:55:12,160
0,135 135,360 360,570 570,885 885,1035
keep following the pointer and

2113
00:55:12,160 --> 00:55:13,300
0,260 280,630 630,870 870,1035 1035,1140
go, then scan along to

2114
00:55:13,300 --> 00:55:13,825
0,90 90,210 210,300 300,375 375,525
I find the thing I'm

2115
00:55:13,825 --> 00:55:15,920
0,150 150,485 745,1050 1050,1355
looking for, if not.|
|

2116
00:55:15,930 --> 00:55:16,895
0,260 260,380 380,545 545,785 785,965
If it says no, then
如果它说不，那我就不做扫描了。

2117
00:55:17,000 --> 00:55:17,740
0,105 105,195 195,300 300,450 450,740
I don't do that scan.|
|

2118
00:55:19,220 --> 00:55:20,200
0,230 230,380 380,710 710,845 845,980
So that avoids that, having
因此，这就避免了不得不进行额外的遍历。

2119
00:55:20,200 --> 00:55:21,480
0,120 120,315 315,510 510,705 705,1280
to do that extra traversal.|
|

2120
00:55:24,260 --> 00:55:24,790
0,230 230,275 275,365 365,470 470,530
Do you ever know what
你知道什么是气球脚吗？

2121
00:55:24,790 --> 00:55:25,500
0,105 105,255 255,360 360,465 465,710
a balloon foot there is?|
|

2122
00:55:26,730 --> 00:55:28,920
0,395 395,790
No, okay.|
不，好吧。|

2123
00:55:28,930 --> 00:55:29,870
0,230 230,320 320,500 500,680 680,940
So I asked. Hold up.|
所以我就问了。等一下。|

2124
00:55:31,600 --> 00:55:33,285
0,290 290,500 500,680 680,950 950,1685
Balloon filters are awesome and
气球过滤器很棒，对很多东西都很有用。

2125
00:55:33,285 --> 00:55:34,260
0,195 195,545 595,825 825,885 885,975
be useful for a bunch

2126
00:55:34,260 --> 00:55:35,240
0,105 105,350
of things.|
|

2127
00:55:36,000 --> 00:55:37,700
0,245 245,490 570,970 1170,1475 1475,1700
All right, quickly. A bloom
好的，快点。Bloom Filter是一种概率数据结构，它可以告诉您可以回答集合成员身份查询。因此，筛选器不同于索引。索引告诉您，对于给定的键，它在哪里？在这个记录ID中吗？在此页面中，筛选器只能说，密钥是否存在？是还是不是？我不能告诉你它在哪里。它只会告诉你它是否存在。

2128
00:55:37,700 --> 00:55:38,765
0,240 240,300 300,405 405,870 870,1065
filterter is a probabilistic data

2129
00:55:38,765 --> 00:55:40,385
0,335 625,915 915,1140 1140,1380 1380,1620
structure that can tell you

2130
00:55:40,385 --> 00:55:41,660
0,210 210,330 330,575 625,900 900,1275
that can answer set membership

2131
00:55:41,660 --> 00:55:44,000
0,440 910,1260 1260,1610 1750,2115 2115,2340
queries. So a filter is

2132
00:55:44,000 --> 00:55:45,340
0,165 165,315 315,495 495,830 940,1340
different than an index. An

2133
00:55:45,360 --> 00:55:46,565
0,335 335,590 590,890 890,1100 1100,1205
index tells you for a

2134
00:55:46,565 --> 00:55:48,340
0,240 240,605 925,1260 1260,1485 1485,1775
given key, where is it?

2135
00:55:48,690 --> 00:55:50,195
0,320 320,560 560,800 800,1120 1230,1505
In this record ID? In

2136
00:55:50,195 --> 00:55:51,755
0,180 180,485 745,1080 1080,1365 1365,1560
this page, a filter can

2137
00:55:51,755 --> 00:55:53,285
0,195 195,545 805,1110 1110,1305 1305,1530
only say, does the key

2138
00:55:53,285 --> 00:55:54,785
0,330 330,615 615,765 765,1025 1165,1500
exist? Yes or no? Can't

2139
00:55:54,785 --> 00:55:55,570
0,105 105,240 240,405 405,540 540,785
tell you where it is.

2140
00:55:55,590 --> 00:55:56,450
0,260 260,395 395,545 545,695 695,860
It just tells you whether

2141
00:55:56,450 --> 00:55:57,520
0,210 210,530
it exists.|
|

2142
00:55:57,590 --> 00:56:01,225
0,400 1020,1385 1385,1750 2490,2890 3300,3635
Right, so A A bloom
对，所以A布卢姆过滤器这家伙叫布卢姆，我想是从七十年代开始的。所以Bloom过滤器是一个公共数据结构，这意味着它可以百分之百正确地告诉你密钥不存在。

2143
00:56:01,225 --> 00:56:03,280
0,455 1255,1500 1500,1665 1665,1845 1845,2055
filterer the guy was named

2144
00:56:03,280 --> 00:56:04,540
0,380 670,915 915,1035 1035,1155 1155,1260
bloom, I think from the

2145
00:56:04,540 --> 00:56:07,525
0,410 1450,1785 1785,2120 2530,2805 2805,2985
seventies. So the the bloom

2146
00:56:07,525 --> 00:56:09,160
0,395 505,840 840,1065 1065,1335 1335,1635
filterter is a public data

2147
00:56:09,160 --> 00:56:11,395
0,320 610,960 960,1310 1720,2010 2010,2235
structure, meaning like it can

2148
00:56:11,395 --> 00:56:12,730
0,255 255,435 435,600 600,905 1075,1335
tell you with with hundred

2149
00:56:12,730 --> 00:56:14,140
0,120 120,315 315,860 1000,1260 1260,1410
percent percent correctness that a

2150
00:56:14,140 --> 00:56:15,760
0,165 165,345 345,630 630,1010
key does not exist.|
|

2151
00:56:15,830 --> 00:56:16,735
0,230 230,305 305,425 425,650 650,905
But if you say it
但如果你说它可以告诉你密钥确实存在，它可能实际上是错误的，并给你错误的肯定。

2152
00:56:16,735 --> 00:56:17,380
0,180 180,315 315,435 435,525 525,645
can tell you that a

2153
00:56:17,380 --> 00:56:18,505
0,210 210,510 510,810 810,990 990,1125
key does exist and it

2154
00:56:18,505 --> 00:56:20,395
0,240 240,435 435,555 555,845 1615,1890
might actually be wrong and

2155
00:56:20,395 --> 00:56:22,080
0,135 135,285 285,525 525,1115
give you false positives.|
|

2156
00:56:22,710 --> 00:56:23,720
0,260 260,365 365,455 455,695 695,1010
And you can only do
而且你只能在基本的软式飞艇脚注上做两个操作。您可以执行插入操作和查找操作。您不能删除。

2157
00:56:23,720 --> 00:56:24,815
0,285 285,600 600,795 795,885 885,1095
two operations on the basic

2158
00:56:24,815 --> 00:56:25,985
0,255 255,635 685,960 960,1080 1080,1170
blimp footer. You can do

2159
00:56:25,985 --> 00:56:27,065
0,75 75,495 495,795 795,990 990,1080
an insert and you can

2160
00:56:27,065 --> 00:56:27,935
0,75 75,165 165,465 465,630 630,870
do a lookup. You can't

2161
00:56:27,935 --> 00:56:29,280
0,120 120,665
do deletes.|
|

2162
00:56:29,320 --> 00:56:30,520
0,305 305,410 410,670
We'll see why.|
我们会知道原因的。|

2163
00:56:31,200 --> 00:56:32,210
0,230 230,380 380,620 620,875 875,1010
So it basically just think
所以它基本上只认为它只是一个位图。

2164
00:56:32,210 --> 00:56:32,915
0,105 105,300 300,510 510,615 615,705
of like most of all

2165
00:56:32,915 --> 00:56:34,540
0,150 150,270 270,450 450,935
it just a bitmap.|
|

2166
00:56:34,540 --> 00:56:35,560
0,290
Right.|
正确的。|

2167
00:56:35,560 --> 00:56:37,510
0,320 790,1140 1140,1410 1410,1665 1665,1950
And a bit will be
并且将根据插入的密钥来设置位。

2168
00:56:37,510 --> 00:56:39,820
0,315 315,600 600,920 1810,2115 2115,2310
set based on the keys

2169
00:56:39,820 --> 00:56:41,260
0,150 150,270 270,890
that get inserted.|
|

2170
00:56:41,360 --> 00:56:42,985
0,290 290,545 545,785 785,920 920,1625
So say I start inserting
假设我开始插入吴唐文蛤的成员，所以我插入了RISM，所以我会有哈希函数。我将再次对其进行散列，相同的散列实现，只是不同的种子。我提取了一些散列值，然后根据我的蓝过滤器中的比特数对其进行修改。然后不管这个数字是什么，我都会将这些位设置为1。

2171
00:56:42,985 --> 00:56:43,795
0,300 300,435 435,495 495,645 645,810
members of the Wu Tang

2172
00:56:43,795 --> 00:56:45,990
0,335 1165,1380 1380,1455 1455,1755 1755,2195
clam, so I insert rism

2173
00:56:46,130 --> 00:56:47,340
0,290 290,425 425,590 590,815 815,1210
and so I'll have the

2174
00:56:48,410 --> 00:56:50,560
0,365 365,640 1380,1745 1745,1970 1970,2150
hash functions. I'll hash it

2175
00:56:50,560 --> 00:56:52,315
0,320 430,735 735,1110 1110,1490 1510,1755
again, same hash implementation, just

2176
00:56:52,315 --> 00:56:53,755
0,75 75,270 270,635 1015,1290 1290,1440
a different seed. I get

2177
00:56:53,755 --> 00:56:55,210
0,135 135,375 375,555 555,875 1165,1455
some hash value out and

2178
00:56:55,210 --> 00:56:56,185
0,150 150,300 300,510 510,720 720,975
then I mod it by

2179
00:56:56,185 --> 00:56:58,045
0,365 415,765 765,1115 1435,1725 1725,1860
the number of bits that

2180
00:56:58,045 --> 00:56:58,720
0,75 75,165 165,255 255,435 435,675
I have in my my

2181
00:56:58,720 --> 00:57:00,640
0,225 225,500 970,1245 1245,1520 1600,1920
blueoon filter. And then whatever

2182
00:57:00,640 --> 00:57:01,930
0,225 225,450 450,765 765,1080 1080,1290
that number is, I set

2183
00:57:01,930 --> 00:57:03,460
0,210 210,450 450,645 645,920
those bits to one.|
|

2184
00:57:04,210 --> 00:57:05,010
0,260 260,365 365,500 500,665 665,800
Flip it from zero to
把它从零翻到一。

2185
00:57:05,010 --> 00:57:05,960
0,260
one.|
|

2186
00:57:06,030 --> 00:57:07,870
0,275 275,590 590,940 1200,1520 1520,1840
I insert gist, same thing,
我插入Gist，同样的东西，对其进行散列，修改位数并将这些位设置为1。

2187
00:57:07,980 --> 00:57:09,920
0,395 395,670 1110,1715 1715,1850 1850,1940
hash it, modify the number

2188
00:57:09,920 --> 00:57:11,135
0,120 120,380 550,840 840,1020 1020,1215
of bits and set those

2189
00:57:11,135 --> 00:57:12,240
0,195 195,330 330,575
bits to one.|
|

2190
00:57:12,610 --> 00:57:13,245
0,290 290,410 410,485 485,560 560,635
Now if I want to
现在如果我想在Rim上查一查。

2191
00:57:13,245 --> 00:57:14,660
0,75 75,165 165,605 685,960 960,1415
do a lookup on Rim.|
|

2192
00:57:15,790 --> 00:57:17,115
0,335 335,635 635,875 875,1055 1055,1325
Same thing, I just do
同样的，我只是做了一个，呃，散列密钥。我在找mod，号码，然后我去检查是否我散列到的所有比特，呃，比特位置。如果它们设置为1，如果它们设置为1，那么我知道这是设置好的。

2193
00:57:17,115 --> 00:57:19,230
0,365 985,1385 1555,1905 1905,2025 2025,2115
a, uh, hash the key.

2194
00:57:19,230 --> 00:57:20,745
0,120 120,270 270,590 790,1190 1270,1515
I'm looking for mod, the

2195
00:57:20,745 --> 00:57:21,705
0,165 165,345 345,540 540,750 750,960
number and then I go

2196
00:57:21,705 --> 00:57:22,790
0,240 240,405 405,540 540,750 750,1085
check to see whether all

2197
00:57:22,840 --> 00:57:25,305
0,290 290,580 1170,1570 1770,2120 2120,2465
the bits, uh, bit locations

2198
00:57:25,305 --> 00:57:26,720
0,330 330,585 585,870 870,1140 1140,1415
that I I've hashed to.

2199
00:57:26,980 --> 00:57:28,070
0,275 275,530 530,665 665,815 815,1090
If they're set to one,

2200
00:57:28,330 --> 00:57:29,390
0,290 290,500 500,635 635,785 785,1060
if they're set to one,

2201
00:57:29,440 --> 00:57:32,085
0,245 245,395 395,700 2190,2465 2465,2645
then I know this was

2202
00:57:32,085 --> 00:57:34,960
0,305
set.|
|

2203
00:57:34,960 --> 00:57:35,680
0,105 105,285 285,390 390,525 525,720
If it's set to one
如果它设置为1，那么我认为它可能存在，但我可能错了，因为可能是其他东西设置了这些位。

2204
00:57:35,680 --> 00:57:37,390
0,165 165,410 610,1010 1180,1500 1500,1710
then I I I think

2205
00:57:37,390 --> 00:57:38,500
0,195 195,450 450,780 780,990 990,1110
it could exist but I

2206
00:57:38,500 --> 00:57:39,385
0,150 150,300 300,525 525,720 720,885
could be wrong because something

2207
00:57:39,385 --> 00:57:40,150
0,210 210,360 360,465 465,600 600,765
else might have set those

2208
00:57:40,150 --> 00:57:41,180
0,290
bits.|
|

2209
00:57:42,380 --> 00:57:43,495
0,400 450,710 710,890 890,965 965,1115
Right. So I'll get back
正确的。所以，如果我真的看上了厨师，我会回到现实中来的。

2210
00:57:43,495 --> 00:57:44,740
0,180 180,300 300,545 805,1080 1080,1245
true for this if I

2211
00:57:44,740 --> 00:57:45,820
0,135 135,315 315,650 730,960 960,1080
do look om on the

2212
00:57:45,820 --> 00:57:46,920
0,350
chef.|
|

2213
00:57:46,920 --> 00:57:47,760
0,240 240,480 480,630 630,750 750,840
Again, when I do a
同样，当我进行查找时，其中一位被设置为零，所以我知道不可能插入，因为否则这些位中的一位，所有这些位都会被设置。所以我得到了虚假，但我再次抬头安息。现在我可以得到一个假阳性，因为我从未插入它，但因此他的位被设置为1。

2214
00:57:47,760 --> 00:57:48,570
0,135 135,360 360,570 570,675 675,810
look up, one of the

2215
00:57:48,570 --> 00:57:49,580
0,195 195,375 375,525 525,705 705,1010
bits is set to zero

2216
00:57:49,930 --> 00:57:51,015
0,230 230,380 380,650 650,875 875,1085
so I know that cannot

2217
00:57:51,015 --> 00:57:51,980
0,165 165,240 240,630 630,720 720,965
have been inserted because otherwise

2218
00:57:52,270 --> 00:57:53,430
0,245 245,305 305,380 380,640 870,1160
one of those bits, all

2219
00:57:53,430 --> 00:57:54,000
0,150 150,285 285,390 390,450 450,570
those bits would have been

2220
00:57:54,000 --> 00:57:55,160
0,290 400,630 630,720 720,870 870,1160
set. So I get false,

2221
00:57:55,540 --> 00:57:56,940
0,395 395,710 710,875 875,980 980,1400
but I look up ob

2222
00:57:56,940 --> 00:57:58,620
0,180 180,330 330,590 1030,1425 1425,1680
rest in peace again. Now

2223
00:57:58,620 --> 00:57:59,175
0,105 105,195 195,270 270,360 360,555
I can get a false

2224
00:57:59,175 --> 00:58:00,495
0,330 330,585 585,750 750,885 885,1320
positive because I never inserted

2225
00:58:00,495 --> 00:58:02,235
0,225 225,605 1045,1350 1350,1560 1560,1740
it, but his bits were

2226
00:58:02,235 --> 00:58:05,080
0,135 135,255 255,515 1075,1475
set to one therefore.|
|

2227
00:58:05,180 --> 00:58:06,820
0,920 920,1115 1115,1265 1265,1490 1490,1640
It's true, but it's actually
这是真的，但实际上是错的。

2228
00:58:06,820 --> 00:58:07,640
0,260
wrong.|
|

2229
00:58:08,280 --> 00:58:08,900
0,245 245,320 320,395 395,500 500,620
So you can put that
所以你可以把那个气球过滤器放在你的吊桶链前面。

2230
00:58:08,900 --> 00:58:09,940
0,270 270,495 495,660 660,780 780,1040
balloon filter in front of

2231
00:58:10,800 --> 00:58:12,400
0,290 290,515 515,850
your bucket chain.|
|

2232
00:58:12,400 --> 00:58:13,890
0,210 210,390 390,710 880,1260 1260,1490
And that, and it'll be
然后，它将填充为实际插入到其中的密钥设置的位。我可以增量地维护它，因为每次我在遗愿清单中插入新的密钥时，我都会更新我的Bloom Filterller。

2233
00:58:13,940 --> 00:58:15,250
0,455 455,635 635,815 815,1055 1055,1310
populated with the bits set

2234
00:58:15,250 --> 00:58:15,910
0,135 135,255 255,420 420,540 540,660
for the keys that are

2235
00:58:15,910 --> 00:58:17,200
0,135 135,495 495,660 660,980 1030,1290
actually inserted into it. And

2236
00:58:17,200 --> 00:58:18,370
0,120 120,240 240,480 480,765 765,1170
I can maintain it incrementally,

2237
00:58:18,370 --> 00:58:20,830
0,120 120,300 300,465 465,710 1990,2460
because every time I insert

2238
00:58:20,830 --> 00:58:21,880
0,90 90,210 210,435 435,765 765,1050
a new key into that

2239
00:58:21,880 --> 00:58:23,125
0,195 195,500 580,915 915,1110 1110,1245
bucket list, I update my

2240
00:58:23,125 --> 00:58:24,120
0,165 165,575
bloom filterlder.|
|

2241
00:58:24,460 --> 00:58:25,600
0,400
Right.|
正确的。|

2242
00:58:25,720 --> 00:58:26,970
0,335 335,485 485,890 890,1085 1085,1250
There's different variations of bloom
布隆过滤器有不同的变体。你可以有不同级别的它们。你有腐烂的人。布隆过滤器的大小可以改变它们的散列函数。有一大堆不同的东西。但像这样的数据结构是非常有用的，因为我们在整个系统中使用所有的数据结构。是的，假阳性率是如何变化的？

2243
00:58:26,970 --> 00:58:27,690
0,270 270,390 390,465 465,570 570,720
filters. You can have different

2244
00:58:27,690 --> 00:58:28,545
0,195 195,360 360,555 555,750 750,855
levels of them. You have

2245
00:58:28,545 --> 00:58:30,615
0,420 420,695 1105,1505 1585,1920 1920,2070
decaying ones. The size of

2246
00:58:30,615 --> 00:58:31,470
0,90 90,270 270,540 540,705 705,855
the bloom filters can, can

2247
00:58:31,470 --> 00:58:32,685
0,180 180,375 375,570 570,830 910,1215
vary them hash functions. There's

2248
00:58:32,685 --> 00:58:33,090
0,30 30,105 105,210 210,300 300,405
a whole bunch of different

2249
00:58:33,090 --> 00:58:34,260
0,180 180,330 330,560 670,960 960,1170
things. But like this data

2250
00:58:34,260 --> 00:58:35,280
0,195 195,330 330,525 525,810 810,1020
structure is super useful as

2251
00:58:35,280 --> 00:58:36,120
0,120 120,300 300,525 525,705 705,840
we use all throughout the

2252
00:58:36,120 --> 00:58:37,260
0,210 210,560 670,915 915,1020 1020,1140
system. Yes, how does the

2253
00:58:37,260 --> 00:58:38,570
0,120 120,255 255,450 450,990 990,1310
rate of false positives change?|
|

2254
00:58:39,740 --> 00:58:40,555
0,290 290,470 470,620 620,725 725,815
His question is how does
他的问题是，当你签署蓝色过滤器时，比率如何下降比率假阳性变化。有一些公式说，如果你想要1%的假阳性率，你需要有一个这种大小的布氏过滤器，但这个夏天的散列函数，它真的是指数的，线性的。

2255
00:58:40,555 --> 00:58:41,425
0,60 60,150 150,390 390,675 675,870
the rate falls rate false

2256
00:58:41,425 --> 00:58:42,220
0,225 225,435 435,555 555,675 675,795
positive change as you sign

2257
00:58:42,220 --> 00:58:43,315
0,105 105,210 210,405 405,870 870,1095
the blue filter. There's some

2258
00:58:43,315 --> 00:58:44,845
0,285 285,510 510,675 675,965 1165,1530
formula that says like for

2259
00:58:44,845 --> 00:58:45,655
0,225 225,375 375,555 555,690 690,810
if you want like a

2260
00:58:45,655 --> 00:58:47,215
0,360 360,600 600,870 870,1235 1315,1560
1% false positive rate, you

2261
00:58:47,215 --> 00:58:47,710
0,90 90,165 165,225 225,330 330,495
need to have a bloom

2262
00:58:47,710 --> 00:58:48,910
0,195 195,330 330,525 525,830 880,1200
filterter of this size and,

2263
00:58:48,910 --> 00:58:50,230
0,320 580,855 855,990 990,1125 1125,1320
and, but this summer hash

2264
00:58:50,230 --> 00:58:52,110
0,165 165,405 405,555 555,1350 1350,1880
function, it's really exponential, linear.|
|

2265
00:58:52,370 --> 00:58:53,910
0,275 275,455 455,635 635,910 990,1540
This question is X linear.
这个问题是X线性的。我不知道，我记得。但是在那里。

2266
00:58:53,990 --> 00:58:55,180
0,275 275,470 470,620 620,890 890,1190
I don't know, I remember.

2267
00:58:55,180 --> 00:58:56,560
0,225 225,650
But there.|
|

2268
00:58:57,060 --> 00:58:58,565
0,290 290,545 545,910 990,1250 1250,1505
This website here, the bloom
这个网站在这里，开花都是经过计算的。你说你想要的误检率，你有多少个密钥，它就会告诉你你想要的Bloom的大小，然后是哈希函数的数量。

2269
00:58:58,565 --> 00:58:59,855
0,225 225,665 685,975 975,1140 1140,1290
are calculated. You say what

2270
00:58:59,855 --> 00:59:00,790
0,180 180,405 405,585 585,690 690,935
false positive rate you want,

2271
00:59:00,870 --> 00:59:01,655
0,245 245,380 380,530 530,650 650,785
how many keys you have

2272
00:59:01,655 --> 00:59:02,375
0,105 105,255 255,375 375,540 540,720
and it'll tell you the

2273
00:59:02,375 --> 00:59:03,800
0,195 195,450 450,785 925,1260 1260,1425
size of the bloom you

2274
00:59:03,800 --> 00:59:06,335
0,260 490,765 765,1040 2230,2460 2460,2535
want and then the number

2275
00:59:06,335 --> 00:59:07,380
0,75 75,210 210,455
of hash functions.|
|

2276
00:59:07,690 --> 00:59:08,860
0,400
Yes.|
是。|

2277
00:59:10,920 --> 00:59:11,720
0,245 245,380 380,545 545,680 680,800
The question is, how does
问题是，Win是如何出席选举的？他们不会的。

2278
00:59:11,720 --> 00:59:13,390
0,225 225,450 450,950 1290,1410 1410,1670
win attend theletion? They don't.|
|

2279
00:59:14,550 --> 00:59:15,580
0,400
Right.|
正确的。|

2280
00:59:16,850 --> 00:59:18,300
0,260 260,520 540,1010 1010,1190 1190,1450
There are variations of them
它们有多层次的变体，你可以为基本的一层这样做，但它们不是。

2281
00:59:18,680 --> 00:59:19,705
0,275 275,470 470,680 680,845 845,1025
with multi levels you can

2282
00:59:19,705 --> 00:59:21,030
0,150 150,395 565,825 825,1005 1005,1325
do it for basic one

2283
00:59:21,260 --> 00:59:22,300
0,260 260,610
they don't.|
|

2284
00:59:23,500 --> 00:59:24,570
0,365 365,590 590,770 770,905 905,1070
And blue PS are super
蓝色的PS非常有用。我们会在整个系统中以多种方式使用它。我们可以用它来做大麻。

2285
00:59:24,570 --> 00:59:26,340
0,290 400,690 690,920 1330,1620 1620,1770
useful. We'll use throughout the

2286
00:59:26,340 --> 00:59:27,435
0,260 310,555 555,735 735,945 945,1095
system in a bunch of

2287
00:59:27,435 --> 00:59:28,185
0,150 150,375 375,555 555,645 645,750
ways. We we'll use it

2288
00:59:28,185 --> 00:59:29,400
0,90 90,285 285,665
for hash jointins.|
|

2289
00:59:29,880 --> 00:59:30,695
0,290 290,440 440,605 605,650 650,815
Because again, it's a lot
因为再一次，这是一个便宜得多，去看看，它在我的布隆过滤器比去实际上遵循一个页面，看看这个，看看是否存在的东西。

2290
00:59:30,695 --> 00:59:31,580
0,240 240,375 375,510 510,705 705,885
cheaper to go look up

2291
00:59:31,580 --> 00:59:32,405
0,180 180,390 390,570 570,705 705,825
to see, is it in

2292
00:59:32,405 --> 00:59:33,910
0,135 135,330 330,605 925,1215 1215,1505
my bloom filter than go

2293
00:59:34,530 --> 00:59:35,885
0,260 260,500 500,785 785,1085 1085,1355
actually follow a page and

2294
00:59:35,885 --> 00:59:36,605
0,135 135,300 300,495 495,630 630,720
look on this and see

2295
00:59:36,605 --> 00:59:37,570
0,135 135,360 360,570 570,705 705,965
whether something exists or not.|
|

2296
00:59:44,240 --> 00:59:45,730
0,320 320,500 500,650 650,1160 1160,1490
So a more sophisticated scheme
因此，一个更复杂的方案被称为可扩展散列。

2297
00:59:45,730 --> 00:59:47,640
0,255 255,480 480,840 840,1310
is called extendable hashing.|
|

2298
00:59:47,640 --> 00:59:48,075
0,120 120,240 240,345 345,405 405,435
And this is going to
这就像链式散列一样，但是。

2299
00:59:48,075 --> 00:59:49,520
0,90 90,285 285,540 540,1080 1080,1445
be like chain hashing, but.|
|

2300
00:59:51,760 --> 00:59:53,060
0,275 275,380 380,665 665,980 980,1300
We're gonna allow the, the,
我们将允许，我们将能够分割桶，以避免这些无限长的，呃，桶列表，我们将以这样一种方式分割它，我们只需要，呃，我们只需要在哈希表的一小部分中递增，而不必重新哈希所有内容。

2301
00:59:53,290 --> 00:59:53,895
0,275 275,320 320,380 380,455 455,605
we're gonna be able to

2302
00:59:53,895 --> 00:59:54,885
0,165 165,300 300,600 600,765 765,990
split the buckets to avoid

2303
00:59:54,885 --> 00:59:57,000
0,315 315,870 870,1145 1285,1685 1795,2115
these infinitely long, uh, bucket

2304
00:59:57,000 --> 00:59:58,290
0,500 790,1035 1035,1155 1155,1185 1185,1290
lists and we're going to

2305
00:59:58,290 --> 00:59:58,755
0,150 150,225 225,285 285,375 375,465
split it in such a

2306
00:59:58,755 --> 01:00:00,200
0,120 120,255 255,390 390,665 1045,1445
way that we only, uh,

2307
01:00:00,790 --> 01:00:01,695
0,245 245,365 365,485 485,695 695,905
we only need to do

2308
01:00:01,695 --> 01:00:02,910
0,165 165,645 645,765 765,930 930,1215
it incrementally in a small

2309
01:00:02,910 --> 01:00:03,645
0,225 225,330 330,405 405,585 585,735
part of the hash table

2310
01:00:03,645 --> 01:00:04,635
0,210 210,360 360,480 480,705 705,990
rather than having to {re-rehash

2311
01:00:04,635 --> 01:00:06,120
0,455 595,995
-} everything.|
|

2312
01:00:06,560 --> 01:00:07,615
0,245 245,365 365,575 575,815 815,1055
And the key idea of
这个方法的关键思想是，当我们在桶列表或桶哈希表中查找时，我们要扩展我们必须查看的位数，以找到我们要查找的桶链。我们可以改变它。

2313
01:00:07,615 --> 01:00:08,275
0,210 210,345 345,435 435,525 525,660
this is going to work

2314
01:00:08,275 --> 01:00:08,950
0,120 120,240 240,420 420,465 465,675
is that we're going to

2315
01:00:08,950 --> 01:00:10,285
0,380 580,825 825,945 945,1125 1125,1335
expand the number of bits

2316
01:00:10,285 --> 01:00:11,100
0,135 135,225 225,360 360,525 525,815
we have to look at

2317
01:00:11,450 --> 01:00:12,475
0,260 260,380 380,530 530,920 920,1025
when we do lookups in

2318
01:00:12,475 --> 01:00:13,390
0,165 165,330 330,465 465,690 690,915
our in our bucket list

2319
01:00:13,390 --> 01:00:14,995
0,150 150,410 430,765 765,1010 1360,1605
or bucket hash table to

2320
01:00:14,995 --> 01:00:16,015
0,150 150,420 420,675 675,825 825,1020
go find the, the bucket

2321
01:00:16,015 --> 01:00:17,310
0,210 210,480 480,765 765,945 945,1295
chain that we're looking for.

2322
01:00:17,660 --> 01:00:19,410
0,400 630,905 905,1085 1085,1370 1370,1750
And we can vary this

2323
01:00:19,430 --> 01:00:21,620
0,400
per.|
|

2324
01:00:21,900 --> 01:00:22,920
0,400
So.|
是的|

2325
01:00:23,050 --> 01:00:24,915
0,400 660,1060 1110,1415 1415,1595 1595,1865
Per value per key type,
每个键类型的每个值，而不是键类型。

2326
01:00:24,915 --> 01:00:26,280
0,285 285,435 435,695
not key type.|
|

2327
01:00:26,290 --> 01:00:27,795
0,395 395,680 680,920 920,1220 1220,1505
We can vary this based
我们可以根据我们看到的遗愿清单来改变这一点，所以情况可能是这样的。

2328
01:00:27,795 --> 01:00:30,045
0,335 1015,1350 1350,1685 1735,2040 2040,2250
on what bucket list we're

2329
01:00:30,045 --> 01:00:31,545
0,180 180,515 895,1185 1185,1335 1335,1500
looking at, so it may

2330
01:00:31,545 --> 01:00:32,980
0,150 150,285 285,510 510,845
be the case that.|
|

2331
01:00:32,980 --> 01:00:34,330
0,210 210,435 435,735 735,1035 1035,1350
Two different locations, multiple locations
两个不同的位置，在我们的桶数组中的多个位置将指向同一个桶列表，但是随着我们的需要，它可以扩展和分解。

2332
01:00:34,330 --> 01:00:35,200
0,195 195,345 345,495 495,630 630,870
in our in our bucket

2333
01:00:35,200 --> 01:00:36,280
0,350 430,705 705,870 870,990 990,1080
array will point to the

2334
01:00:36,280 --> 01:00:37,600
0,150 150,375 375,710 940,1185 1185,1320
same bucket list, but then

2335
01:00:37,600 --> 01:00:38,485
0,165 165,390 390,615 615,750 750,885
that can expand and break

2336
01:00:38,485 --> 01:00:39,400
0,210 210,540 540,780 780,855 855,915
up as we need it

2337
01:00:39,400 --> 01:00:40,660
0,90 90,195 195,345 345,650
as we go along.|
|

2338
01:00:40,810 --> 01:00:42,660
0,400 930,1190 1190,1385 1385,1580 1580,1850
EM, so I I didn't
所以我并不认为这是，这有点复杂，我认为没有任何系统真正使用它，但结果是g dbm，这是新的数据库管理器。想想看，你知道一个键值存储，有点像rocksdb或sql light。你可以运行这个程序，并嵌入到你的系统中，就像电影哈希表一样，然后asteris DB是一个，是加州大学欧文分校的一个大数据项目，他们在他们的想法中使用了电影哈希。

2339
01:00:42,660 --> 01:00:43,680
0,165 165,300 300,450 450,710 760,1020
actually think this is, this

2340
01:00:43,680 --> 01:00:44,565
0,105 105,195 195,330 330,620 670,885
is a bit complicated and

2341
01:00:44,565 --> 01:00:45,675
0,60 60,210 210,425 535,855 855,1110
I didn't think any system

2342
01:00:45,675 --> 01:00:47,550
0,180 180,360 360,695 925,1325 1645,1875
actually uses it EM, but

2343
01:00:47,550 --> 01:00:48,555
0,90 90,225 225,420 420,585 585,1005
it turns out g dbm

2344
01:00:48,555 --> 01:00:50,505
0,180 180,425 445,705 705,965 1585,1950
which is the new database

2345
01:00:50,505 --> 01:00:51,900
0,315 315,525 525,630 630,875 1165,1395
manager. Think of like you

2346
01:00:51,900 --> 01:00:53,600
0,230 640,930 930,1095 1095,1335 1335,1700
know a key value store

2347
01:00:54,040 --> 01:00:55,275
0,400 570,905 905,1070 1070,1130 1130,1235
that like sort of like

2348
01:00:55,275 --> 01:00:56,490
0,540 540,690 690,945 945,1080 1080,1215
rocksdb or sql light. You

2349
01:00:56,490 --> 01:00:57,315
0,105 105,225 225,360 360,570 570,825
can run this and embedded

2350
01:00:57,315 --> 01:00:59,265
0,135 135,240 240,515 1405,1740 1740,1950
in your system that space

2351
01:00:59,265 --> 01:01:00,030
0,150 150,315 315,450 450,600 600,765
and tie you on like

2352
01:01:00,030 --> 01:01:01,425
0,150 150,360 360,620 1000,1260 1260,1395
cinema hash tables and then

2353
01:01:01,425 --> 01:01:03,015
0,390 390,750 750,960 960,1235 1345,1590
asteris DB is a, is

2354
01:01:03,015 --> 01:01:04,335
0,245 385,675 675,885 885,1140 1140,1320
a big data project at

2355
01:01:04,335 --> 01:01:06,045
0,90 90,345 345,725 1315,1575 1575,1710
a UC Irvine and they

2356
01:01:06,045 --> 01:01:07,185
0,165 165,435 435,855 855,990 990,1140
have ah and're they're using

2357
01:01:07,185 --> 01:01:08,840
0,270 270,540 540,660 660,1235
cinemaal hashing in theirantation.|
|

2358
01:01:08,840 --> 01:01:09,720
0,260
Right.|
对的|

2359
01:01:10,240 --> 01:01:10,600
0,60 60,120 120,180 180,255 255,360
So let's see how this
让我们看看这是如何工作的。

2360
01:01:10,600 --> 01:01:11,500
0,260
works.|
|

2361
01:01:12,090 --> 01:01:12,920
0,305 305,500 500,635 635,740 740,830
Right. So the first thing
对的我们首先要做的是，我们有了插槽数组，它将指向我们的bucket list。

2362
01:01:12,920 --> 01:01:13,370
0,105 105,135 135,180 180,300 300,450
we're going to have is

2363
01:01:13,370 --> 01:01:14,630
0,195 195,375 375,620 730,1020 1020,1260
that we have our slot

2364
01:01:14,630 --> 01:01:15,185
0,225 225,345 345,465 465,495 495,555
array and it's going to

2365
01:01:15,185 --> 01:01:16,000
0,105 105,195 195,300 300,495 495,815
point to our bucket list.|
|

2366
01:01:16,740 --> 01:01:17,325
0,150 150,300 300,465 465,510 510,585
And then we're going to
然后我们将有一个全局标识符，它告诉我们需要查找多少位来查找散列值，以确定如何在桶数组中进行查找。

2367
01:01:17,325 --> 01:01:20,175
0,245 265,665 1285,1685 1735,2345 2575,2850
have this global identifier that

2368
01:01:20,175 --> 01:01:21,225
0,165 165,405 405,615 615,810 810,1050
tells us how many bits

2369
01:01:21,225 --> 01:01:22,035
0,150 150,255 255,375 375,525 525,810
we need to look at

2370
01:01:22,035 --> 01:01:23,730
0,300 300,510 510,810 810,1085 1375,1695
for our hash values to

2371
01:01:23,730 --> 01:01:24,795
0,320 400,690 690,825 825,915 915,1065
determine how we do our

2372
01:01:24,795 --> 01:01:27,020
0,575 715,1035 1035,1355 1555,1890 1890,2225
lookups in our bucket array.|
|

2373
01:01:27,860 --> 01:01:29,245
0,275 275,500 500,850 1050,1280 1280,1385
And then for sort of
然后出于记账的原因，每个遗愿清单也将包含我们的本地位大小，它们需要查看的位数。

2374
01:01:29,245 --> 01:01:31,075
0,420 420,695 985,1350 1350,1635 1635,1830
bookkeeping reasons, every bucket list

2375
01:01:31,075 --> 01:01:32,130
0,165 165,360 360,600 600,795 795,1055
as well will also have

2376
01:01:32,240 --> 01:01:34,075
0,260 260,410 410,665 665,1030 1530,1835
what our local bit bit

2377
01:01:34,075 --> 01:01:35,170
0,210 210,515 535,825 825,975 975,1095
size is, number bits they

2378
01:01:35,170 --> 01:01:36,260
0,105 105,195 195,315 315,590
need to look at.|
|

2379
01:01:36,260 --> 01:01:36,800
0,150 150,225 225,345 345,465 465,540
So you can see in
所以你可以在这里看到，这里的前两个槽，它们都指向相同的遗愿清单，而底部的这两个，它们指向不同的位置。

2380
01:01:36,800 --> 01:01:38,915
0,90 90,270 270,590 1570,1890 1890,2115
the case here, these first

2381
01:01:38,915 --> 01:01:40,310
0,210 210,495 495,845 925,1260 1260,1395
two slots here, they're both

2382
01:01:40,310 --> 01:01:41,075
0,120 120,165 165,255 255,480 480,765
going to be pointing to

2383
01:01:41,075 --> 01:01:42,485
0,195 195,360 360,600 600,935 1075,1410
the same bucket list, whereas

2384
01:01:42,485 --> 01:01:43,235
0,255 255,420 420,540 540,660 660,750
these two ones at the

2385
01:01:43,235 --> 01:01:44,315
0,245 505,795 795,855 855,900 900,1080
bottom, they're going to be

2386
01:01:44,315 --> 01:01:46,060
0,240 240,360 360,570 570,935
pointing to different locations.|
|

2387
01:01:46,770 --> 01:01:48,160
0,275 275,410 410,605 605,940 990,1390
And this is because the.|
这是因为。|

2388
01:01:50,540 --> 01:01:51,420
0,260 260,395 395,515 515,620 620,880
We need to look at
我们需要查看全局，我们将查看两个位，但对于前两个条目，当位为零时，它们将重复使用相同的、相同的存储桶列表，该列表由本地标识符来标识。

2389
01:01:51,680 --> 01:01:52,570
0,545 545,725 725,785 785,830 830,890
globally, we're going to look

2390
01:01:52,570 --> 01:01:54,180
0,120 120,300 300,590 970,1290 1290,1610
at two bits, but for

2391
01:01:54,440 --> 01:01:56,730
0,400 1020,1325 1325,1580 1580,1805 1805,2290
the, the first two entries,

2392
01:01:57,050 --> 01:01:59,530
0,365 365,665 665,890 890,1180 2190,2480
when the when the bit

2393
01:01:59,530 --> 01:02:01,165
0,210 210,530 1210,1515 1515,1560 1560,1635
is zero, they're going to

2394
01:02:01,165 --> 01:02:02,320
0,375 375,600 600,810 810,1005 1005,1155
reuse the same, the same

2395
01:02:02,320 --> 01:02:04,525
0,210 210,530 820,1155 1155,1490 1810,2205
bucket list identified by the

2396
01:02:04,525 --> 01:02:05,760
0,270 270,480 480,870 870,990 990,1235
the local identifier up here.|
|

2397
01:02:07,800 --> 01:02:08,630
0,245 245,410 410,515 515,680 680,830
So let's say now I
现在让我们来看看这把钥匙。我把它搞砸了。然后我查看最上面的两位，因为它设置了我的全局标识符，全局计数器，然后我散列到这个位置。我只需跟随指针，然后落在那个桶里，我就可以进行线性搜索，找到我正在寻找的东西。

2398
01:02:08,630 --> 01:02:09,110
0,90 90,165 165,255 255,345 345,480
want to do a look

2399
01:02:09,110 --> 01:02:10,760
0,225 225,560 1000,1275 1275,1455 1455,1650
up on on this key

2400
01:02:10,760 --> 01:02:12,695
0,290 520,825 825,1125 1125,1400 1660,1935
here. I hash it. I

2401
01:02:12,695 --> 01:02:13,925
0,210 210,420 420,690 690,1005 1005,1230
then look at the top

2402
01:02:13,925 --> 01:02:14,870
0,180 180,390 390,585 585,780 780,945
two bits because that's what

2403
01:02:14,870 --> 01:02:16,805
0,180 180,450 450,800 1120,1470 1470,1935
set my my global identifier,

2404
01:02:16,805 --> 01:02:19,010
0,285 285,635 1765,2010 2010,2100 2100,2205
global counter, and then I

2405
01:02:19,010 --> 01:02:20,045
0,210 210,330 330,555 555,855 855,1035
hash to this location. I

2406
01:02:20,045 --> 01:02:21,215
0,120 120,285 285,435 435,875 925,1170
just follow the pointer and

2407
01:02:21,215 --> 01:02:22,145
0,135 135,360 360,555 555,705 705,930
I land in that bucket

2408
01:02:22,145 --> 01:02:23,315
0,195 195,455 475,795 795,1005 1005,1170
and I can just do

2409
01:02:23,315 --> 01:02:24,155
0,135 135,390 390,570 570,720 720,840
the linear search to find

2410
01:02:24,155 --> 01:02:25,060
0,135 135,255 255,405 405,570 570,905
the thing I'm looking for.|
|

2411
01:02:27,360 --> 01:02:27,965
0,275 275,380 380,455 455,530 530,605
Say now I want to
现在说我想把b。

2412
01:02:27,965 --> 01:02:29,200
0,165 165,485
put b.|
|

2413
01:02:30,170 --> 01:02:32,125
0,400 720,1120 1350,1775 1775,1865 1865,1955
B again globally. I know
B再次在全球范围内。我知道我需要看看上面的两个部分。我抬头看了看我的帽子，我的桶，我的遗愿清单，基于这两个部分。然后我降落在这个地方。在这里，我继续并插入它。

2414
01:02:32,125 --> 01:02:32,635
0,75 75,165 165,255 255,330 330,510
I need to look at

2415
01:02:32,635 --> 01:02:34,030
0,195 195,345 345,495 495,755 1135,1395
the top two bits. I

2416
01:02:34,030 --> 01:02:34,585
0,105 105,195 195,315 315,450 450,555
do a look up at

2417
01:02:34,585 --> 01:02:36,030
0,180 180,515 595,945 945,1170 1170,1445
my my hat, my bucket,

2418
01:02:36,260 --> 01:02:38,035
0,275 275,470 470,790 1380,1655 1655,1775
my bucket list based on

2419
01:02:38,035 --> 01:02:39,310
0,105 105,225 225,485 865,1140 1140,1275
those two bits. Then I

2420
01:02:39,310 --> 01:02:40,345
0,165 165,300 300,465 465,720 720,1035
land into this location. Here

2421
01:02:40,345 --> 01:02:41,650
0,285 285,450 450,720 720,990 990,1305
I go ahead and insert

2422
01:02:41,650 --> 01:02:42,320
0,260
it.|
|

2423
01:02:42,850 --> 01:02:43,440
0,245 245,335 335,425 425,500 500,590
But now I want to
但现在我想把c放进去。

2424
01:02:43,440 --> 01:02:44,840
0,210 210,435 435,710
put c in.|
|

2425
01:02:44,840 --> 01:02:46,100
0,320 610,855 855,960 960,1080 1080,1260
And if I look at
如果我看最后两个比特，它落在我插入b时的相同位置，但现在这个桶是满的。我不能再放入更多的条目，所以我需要扩展我正在查看的位数，以扩展我拥有的选项数。所以我要将全局计数器从2增加到3。

2426
01:02:46,100 --> 01:02:47,525
0,225 225,435 435,615 615,890 1150,1425
the last two bits, it

2427
01:02:47,525 --> 01:02:48,395
0,165 165,300 300,390 390,585 585,870
lands in the same location

2428
01:02:48,395 --> 01:02:49,820
0,180 180,270 270,600 600,875 1135,1425
when I inserted b, but

2429
01:02:49,820 --> 01:02:51,160
0,255 255,525 525,750 750,1005 1005,1340
now this bucket is full.

2430
01:02:51,600 --> 01:02:52,400
0,275 275,515 515,605 605,695 695,800
I can't put any more

2431
01:02:52,400 --> 01:02:54,035
0,315 315,590 1090,1380 1380,1515 1515,1635
entries in, so I need

2432
01:02:54,035 --> 01:02:55,130
0,255 255,600 600,810 810,930 930,1095
to expand the number of

2433
01:02:55,130 --> 01:02:56,270
0,180 180,405 405,600 600,915 915,1140
bits I'm looking at to

2434
01:02:56,270 --> 01:02:58,085
0,260 490,825 825,1160 1420,1680 1680,1815
now expand the number of

2435
01:02:58,085 --> 01:02:59,465
0,225 225,405 405,495 495,755 1135,1380
options that I have. So

2436
01:02:59,465 --> 01:03:00,230
0,165 165,225 225,375 375,615 615,765
I'm going to increment the

2437
01:03:00,230 --> 01:03:01,835
0,240 240,570 570,950 970,1350 1350,1605
global counter to from two

2438
01:03:01,835 --> 01:03:03,060
0,180 180,485
to three.|
|

2439
01:03:03,060 --> 01:03:03,975
0,195 195,270 270,405 405,660 660,915
I'm going to double the
我将把存储桶数组中的指针数增加一倍。

2440
01:03:03,975 --> 01:03:05,150
0,305 325,585 585,690 690,855 855,1175
size of the number of

2441
01:03:06,040 --> 01:03:07,190
0,395 395,515 515,680 680,875 875,1150
pointers I have in my

2442
01:03:07,210 --> 01:03:08,680
0,365 365,730
bucket array.|
|

2443
01:03:08,690 --> 01:03:11,005
0,290 290,580 1800,2060 2060,2150 2150,2315
But then create the new
然后创建新的条目，但是当位设置为0时，它们仍然指向这里的第一个桶，因为我还没有那个桶，所以我需要为它寻找一个位。

2444
01:03:11,005 --> 01:03:13,960
0,335 505,780 780,1020 1020,1385 2695,2955
entry, but then the when

2445
01:03:13,960 --> 01:03:14,755
0,150 150,315 315,465 465,615 615,795
the bit is set to

2446
01:03:14,755 --> 01:03:16,240
0,305 565,930 930,1155 1155,1395 1395,1485
zero, they're all still going

2447
01:03:16,240 --> 01:03:17,065
0,120 120,315 315,465 465,600 600,825
to point to the first

2448
01:03:17,065 --> 01:03:18,720
0,330 330,725 925,1170 1170,1275 1275,1655
bucket here because I haven't

2449
01:03:18,740 --> 01:03:20,065
0,290 290,455 455,730 870,1115 1115,1325
that one yet, so I

2450
01:03:20,065 --> 01:03:20,620
0,225 225,315 315,375 375,450 450,555
I need to look at

2451
01:03:20,620 --> 01:03:22,100
0,165 165,360 360,510 510,770
one bit for that.|
|

2452
01:03:22,100 --> 01:03:24,100
0,290 940,1200 1200,1460
For the next.|
为了下一次。|

2453
01:03:24,440 --> 01:03:25,315
0,260 260,380 380,515 515,680 680,875
When the bits are one,
当比特是一个时，一个指向下面的另一个桶，其他的也是一样的。

2454
01:03:25,315 --> 01:03:27,055
0,305 685,1020 1020,1290 1290,1545 1545,1740
one that points to this

2455
01:03:27,055 --> 01:03:28,540
0,195 195,435 435,660 660,965 1195,1485
other bucket down here and

2456
01:03:28,540 --> 01:03:29,500
0,165 165,330 330,480 480,720 720,960
the same thing for these

2457
01:03:29,500 --> 01:03:30,620
0,150 150,440
other ones.|
|

2458
01:03:30,620 --> 01:03:31,680
0,380
Right.|
正确的。|

2459
01:03:31,690 --> 01:03:32,490
0,245 245,425 425,605 605,710 710,800
So now when I want
所以现在，当我想要进行查找以放入c时，我需要查看三个位。我顺着那个指针走到了这个桶的位置。

2460
01:03:32,490 --> 01:03:33,120
0,75 75,150 150,225 225,480 480,630
to do a lookup to

2461
01:03:33,120 --> 01:03:34,260
0,180 180,390 390,680 760,1020 1020,1140
put c in, I need

2462
01:03:34,260 --> 01:03:35,090
0,105 105,195 195,330 330,525 525,830
to look at three bits.

2463
01:03:35,380 --> 01:03:36,735
0,380 380,680 680,875 875,1175 1175,1355
I followed that pointer here

2464
01:03:36,735 --> 01:03:37,620
0,180 180,330 330,480 480,690 690,885
that then takes me to

2465
01:03:37,620 --> 01:03:38,980
0,135 135,375 375,740
this bucket location.|
|

2466
01:03:41,270 --> 01:03:42,160
0,245 245,380 380,560 560,740 740,890
So going back here when
所以当我分手的时候回到这里。

2467
01:03:42,160 --> 01:03:43,660
0,135 135,270 270,465 465,800
I did my split.|
|

2468
01:03:43,750 --> 01:03:45,825
0,400 450,695 695,770 770,1150 1740,2075
I had to resize these
我不得不调整这些家伙的大小，然后滑了下去，我只需要插入一个新的水桶。但我取走了这里的东西，因为这个是满的，我只是把那个拆了，然后为它创建了一个新的桶。我不需要触摸底部的那个，也不需要触摸顶部的那个。

2469
01:03:45,825 --> 01:03:47,550
0,270 270,605 925,1230 1230,1485 1485,1725
guys just slid down and

2470
01:03:47,550 --> 01:03:48,590
0,120 120,300 300,480 480,570 570,1040
I only had to insert

2471
01:03:49,300 --> 01:03:51,560
0,290 290,470 470,760 1770,2015 2015,2260
one new bucket. But I

2472
01:03:51,580 --> 01:03:52,845
0,260 260,380 380,560 560,880 1020,1265
took what was here because

2473
01:03:52,845 --> 01:03:53,850
0,120 120,240 240,375 375,665 745,1005
this one was full and

2474
01:03:53,850 --> 01:03:54,690
0,120 120,315 315,525 525,690 690,840
I just split that one

2475
01:03:54,690 --> 01:03:55,365
0,120 120,255 255,360 360,465 465,675
and created the new bucket

2476
01:03:55,365 --> 01:03:56,475
0,195 195,455 565,840 840,1035 1035,1110
for it. I didn't have

2477
01:03:56,475 --> 01:03:57,030
0,105 105,255 255,390 390,480 480,555
to touch the one at

2478
01:03:57,030 --> 01:03:57,675
0,75 75,255 255,435 435,585 585,645
the bottom and didn't have

2479
01:03:57,675 --> 01:03:58,140
0,90 90,210 210,330 330,405 405,465
to touch the one at

2480
01:03:58,140 --> 01:03:58,960
0,90 90,350
the top.|
|

2481
01:04:00,450 --> 01:04:01,220
0,275 275,410 410,530 530,635 635,770
I do have to double
我确实要把这个的大小翻一番，但那不是。

2482
01:04:01,220 --> 01:04:02,320
0,150 150,315 315,480 480,720 720,1100
the size of this but

2483
01:04:02,370 --> 01:04:05,040
0,640
that.|
|

2484
01:04:05,230 --> 01:04:05,820
0,245 245,335 335,410 410,485 485,590
You have to take a
当你这样做的时候，你必须锁住它，因为你必须复制一份并调整它的大小，但它不是。这没什么大不了的。你可以很快做到这一点。

2485
01:04:05,820 --> 01:04:06,450
0,180 180,330 330,435 435,525 525,630
latch on it when you

2486
01:04:06,450 --> 01:04:07,050
0,135 135,315 315,465 465,540 540,600
do it because you have

2487
01:04:07,050 --> 01:04:08,540
0,60 60,290 490,765 765,1040 1090,1490
to make a copy and

2488
01:04:08,890 --> 01:04:10,280
0,440 440,730 780,1010 1010,1145 1145,1390
resize it, but it's not.

2489
01:04:10,330 --> 01:04:11,130
0,320 320,425 425,590 590,725 725,800
It's not that big of

2490
01:04:11,130 --> 01:04:12,180
0,75 75,320 640,885 885,975 975,1050
a deal. You can do

2491
01:04:12,180 --> 01:04:13,420
0,90 90,240 240,530
that pretty quickly.|
|

2492
01:04:18,220 --> 01:04:19,740
0,275 275,455 455,605 605,850
Any questions about this?|
对此有什么问题吗？|

2493
01:04:20,520 --> 01:04:21,620
0,105 105,270 270,590
Is this good?|
这个不错吗？|

2494
01:04:21,760 --> 01:04:24,700
0,245 245,380 380,670
Is this good?|
这个不错吗？|

2495
01:04:25,580 --> 01:04:26,720
0,400
So.|
所以。|

2496
01:04:26,730 --> 01:04:27,980
0,530 530,725 725,950 950,1130 1130,1250
Resizing this slot array is
调整这种槽阵列的大小相对便宜。

2497
01:04:27,980 --> 01:04:29,300
0,260 280,680
relatively cheap.|
|

2498
01:04:30,570 --> 01:04:31,580
0,335 335,575 575,860 860,905 905,1010
It's clever. It's a good
这很聪明。这是个好主意。这是一个聪明的主意，不管它是好是坏。

2499
01:04:31,580 --> 01:04:34,205
0,290 1600,1890 1890,1995 1995,2265 2265,2625
idea. It's a clever idea

2500
01:04:34,205 --> 01:04:34,895
0,225 225,315 315,405 405,585 585,690
whether or not it's good

2501
01:04:34,895 --> 01:04:36,400
0,90 90,335
or not.|
|

2502
01:04:36,740 --> 01:04:37,760
0,400
It.|
它。|

2503
01:04:38,650 --> 01:04:39,810
0,335 335,605 605,830 830,935 935,1160
Engineering wise, it's a bit
从工程角度来说，跟踪所有元数据的位置有点棘手。

2504
01:04:39,810 --> 01:04:40,710
0,360 360,480 480,630 630,795 795,900
tricky to keep track of

2505
01:04:40,710 --> 01:04:41,990
0,90 90,195 195,750 750,975 975,1280
all the metadata where like

2506
01:04:42,310 --> 01:04:44,380
0,260 260,515 515,910
you know what.|
|

2507
01:04:44,570 --> 01:04:45,400
0,320 320,530 530,665 665,755 755,830
What bits I need to
我需要看什么比特，作为对它的散列。

2508
01:04:45,400 --> 01:04:46,480
0,90 90,270 270,590 670,945 945,1080
be looking at as a

2509
01:04:46,480 --> 01:04:48,460
0,195 195,345 345,650
hash into it.|
|

2510
01:04:48,470 --> 01:04:50,065
0,335 335,695 695,970 1110,1400 1400,1595
But it's basically just change
但这基本上只是更改散列。因此，我从更改散列中获得的所有好处都适用于此。我现在有一个额外的机制来拆分东西，这样我就不会有无限的增长。

2511
01:04:50,065 --> 01:04:51,295
0,545 595,855 855,975 975,1080 1080,1230
hashing. So all the benefits

2512
01:04:51,295 --> 01:04:52,410
0,165 165,270 270,405 405,585 585,1115
I get from change hashing

2513
01:04:52,610 --> 01:04:54,415
0,335 335,695 695,1460 1460,1685 1685,1805
are applicable here. I have

2514
01:04:54,415 --> 01:04:55,585
0,90 90,255 255,575 595,900 900,1170
an extra mechanism now to

2515
01:04:55,585 --> 01:04:56,455
0,255 255,450 450,660 660,795 795,870
split things up so I

2516
01:04:56,455 --> 01:04:57,510
0,135 135,240 240,390 390,780 780,1055
don't have this infinitely growing.|
|

2517
01:04:59,560 --> 01:05:01,500
0,245 245,490 630,920 920,1210
You know, linked list.|
你知道的，链表。|

2518
01:05:02,380 --> 01:05:02,970
0,215 215,335 335,410 410,500 500,590
So it's just a way
因此，这只是一种处理增量调整大小的方法，这是在常规链哈希中做不到的。

2519
01:05:02,970 --> 01:05:05,970
0,260 580,980 1600,1920 1920,2360 2770,3000
to handle incremental resizing in

2520
01:05:05,970 --> 01:05:06,740
0,75 75,165 165,285 285,510 510,770
a way you couldn't do

2521
01:05:07,690 --> 01:05:09,220
0,260 260,425 425,605 605,1030
in regular chain hashing.|
|

2522
01:05:10,530 --> 01:05:11,600
0,400
Yes.|
是。|

2523
01:05:13,830 --> 01:05:14,900
0,275 275,550
I think.|
我认为。|

2524
01:05:14,970 --> 01:05:17,030
0,275 275,550 1230,1625 1625,1910 1910,2060
Yeah, again, linear probing is
是的，同样，线性探测可能是最容易做的事情，并锁定整个表并使其大小加倍。

2525
01:05:17,030 --> 01:05:17,795
0,195 195,345 345,540 540,660 660,765
probably the easiest thing to

2526
01:05:17,795 --> 01:05:19,940
0,245 565,965 1555,1860 1860,2010 2010,2145
do and lock the whole

2527
01:05:19,940 --> 01:05:20,915
0,255 255,510 510,690 690,825 825,975
table and double the size

2528
01:05:20,915 --> 01:05:22,380
0,135 135,365
of it.|
|

2529
01:05:22,620 --> 01:05:23,920
0,135 135,195 195,300 300,560
Sometimes it's good enough.|
有时候这已经足够好了。|

2530
01:05:27,640 --> 01:05:28,740
0,400
Right.|
正确的。|

2531
01:05:29,470 --> 01:05:30,435
0,245 245,335 335,515 515,755 755,965
So the last one is
最后一种是线性散列，这实际上就是postco所做的。

2532
01:05:30,435 --> 01:05:32,550
0,285 285,755 1675,1920 1920,1995 1995,2115
linear hashing, and this is

2533
01:05:32,550 --> 01:05:34,020
0,120 120,210 210,495 495,770
actually what postco does.|
|

2534
01:05:34,300 --> 01:05:35,505
0,400 420,725 725,920 920,1085 1085,1205
Or something very close to
或者是非常接近这个的东西。

2535
01:05:35,505 --> 01:05:36,440
0,245
this.|
|

2536
01:05:36,440 --> 01:05:37,660
0,210 210,330 330,510 510,735 735,1220
And the reason why postgres?|
为什么是波斯格雷斯？|

2537
01:05:38,610 --> 01:05:39,920
0,290 290,485 485,755 755,1010 1010,1310
Well, there another about Berkeley
关于伯克利分校的另一个问题也是如此。

2538
01:05:39,920 --> 01:05:40,700
0,90 90,255 255,465 465,630 630,780
E B that also does

2539
01:05:40,700 --> 01:05:42,560
0,290
this.|
|

2540
01:05:42,810 --> 01:05:44,165
0,395 395,740 740,1010 1010,1205 1205,1355
The the company that built
创建Berkeley DB的公司是一家名为Sleepy Cat Software的公司。所以，制造Wire Tiger的人，他们最初创建了Sleepy Cat，后来卖给了甲骨文。所以甲骨文拥有伯克利数据库，然后他们走出去，开始了新的公司，而不是叫一个昏昏欲睡的猫叫钢丝轮胎像一个像一个。

2541
01:05:44,165 --> 01:05:45,170
0,270 270,495 495,690 690,855 855,1005
Berkeley DB was a company

2542
01:05:45,170 --> 01:05:47,200
0,210 210,510 510,675 675,980 1630,2030
called sleepy cat software. So

2543
01:05:47,520 --> 01:05:48,665
0,290 290,500 500,680 680,860 860,1145
the people that built wire

2544
01:05:48,665 --> 01:05:51,305
0,365 595,975 975,1355 1915,2315 2335,2640
tiger, they, they, they, they

2545
01:05:51,305 --> 01:05:52,715
0,285 285,645 645,1005 1005,1200 1200,1410
originally started sleepy cat that

2546
01:05:52,715 --> 01:05:53,770
0,180 180,345 345,465 465,780 780,1055
got sold to Oracle. So

2547
01:05:53,940 --> 01:05:55,820
0,500 500,680 680,995 995,1360 1620,1880
Oracle own Berkeley DB and

2548
01:05:55,820 --> 01:05:56,345
0,120 120,240 240,360 360,450 450,525
then they went out and

2549
01:05:56,345 --> 01:05:57,350
0,105 105,210 210,345 345,635 775,1005
started the new company instead

2550
01:05:57,350 --> 01:05:58,190
0,75 75,195 195,345 345,615 615,840
of calling a sleepy cat

2551
01:05:58,190 --> 01:05:59,135
0,210 210,315 315,480 480,765 765,945
called a wire tire like

2552
01:05:59,135 --> 01:06:00,080
0,150 150,300 300,545
a like a.|
|

2553
01:06:00,150 --> 01:06:02,240
0,245 245,490 1380,1670 1670,1820 1820,2090
You know, tiger on cocaine
你知道，老虎可卡因或什么的。它试图相反，但是，但是在90年代早期用postgres编写更好的哈希实现的女人是Berkeley DB的创始人。所以她为postgres写了它，然后为Berkeley DB写了它。

2554
01:06:02,240 --> 01:06:04,175
0,135 135,410 1360,1590 1590,1755 1755,1935
or whatever. It was trying

2555
01:06:04,175 --> 01:06:05,225
0,90 90,180 180,375 375,720 720,1050
to be the opposite, but,

2556
01:06:05,225 --> 01:06:06,875
0,225 225,515 805,1110 1110,1380 1380,1650
but the the woman that

2557
01:06:06,875 --> 01:06:08,300
0,300 300,585 585,855 855,1170 1170,1425
wrote the ler hashing implementation

2558
01:06:08,300 --> 01:06:09,440
0,270 270,660 660,810 810,945 945,1140
in postgres in the early

2559
01:06:09,440 --> 01:06:11,105
0,500 820,1095 1095,1230 1230,1545 1545,1665
nineties was the founder of

2560
01:06:11,105 --> 01:06:12,290
0,270 270,635 685,945 945,1065 1065,1185
Berkeley DB. So she wrote

2561
01:06:12,290 --> 01:06:13,040
0,105 105,225 225,570 570,660 660,750
it for postgres and then

2562
01:06:13,040 --> 01:06:13,900
0,105 105,195 195,300 300,540 540,860
wrote it for Berkeley DB.|
|

2563
01:06:14,360 --> 01:06:15,320
0,45 45,260
All right.|
好吧|

2564
01:06:16,290 --> 01:06:17,465
0,260 260,365 365,610 810,1055 1055,1175
And she was one of
她是石破天惊的一个学生。

2565
01:06:17,465 --> 01:06:19,100
0,135 135,405 405,660 660,935
stone breaker pg students.|
|

2566
01:06:19,380 --> 01:06:21,380
0,245 245,335 335,760 1110,1510 1740,2000
At of Berkeley, so the
因此，道路孵化可能比电影孵化更复杂。有可能，但是。

2567
01:06:21,380 --> 01:06:23,690
0,1215 1215,1530 1530,1725 1725,1970 2020,2310
wayar hatching can be more

2568
01:06:23,690 --> 01:06:25,900
0,290 310,710 790,1080 1080,1550 1810,2210
complicated than cinema hatchhing. Potentially,

2569
01:06:25,920 --> 01:06:27,440
0,400
but.|
|

2570
01:06:27,440 --> 01:06:28,535
0,210 210,465 465,720 720,870 870,1095
The basic idea is that
基本的想法是我们要跟踪。

2571
01:06:28,535 --> 01:06:29,375
0,240 240,285 285,375 375,555 555,840
we're going to keep track

2572
01:06:29,375 --> 01:06:31,840
0,365
of.|
|

2573
01:06:32,720 --> 01:06:35,125
0,320 320,640 1410,1775 1775,2075 2075,2405
The next next bucket list
下一个我们要拆分的遗愿清单。

2574
01:06:35,125 --> 01:06:36,740
0,255 255,375 375,585 585,935
we want to split.|
|

2575
01:06:36,740 --> 01:06:38,495
0,350 760,1050 1050,1245 1245,1455 1455,1755
EM, and that when any
EM，并且当任何时候在我们的桶列表链和哈希表中的任何地方有溢出时，无论我们用分裂指针指向什么，那就是我们要分裂的。

2576
01:06:38,495 --> 01:06:39,965
0,315 315,555 555,645 645,1260 1260,1470
time there's an overflow in

2577
01:06:39,965 --> 01:06:41,840
0,245 415,675 675,935 1345,1665 1665,1875
our in our bucket list

2578
01:06:41,840 --> 01:06:42,725
0,195 195,480 480,705 705,780 780,885
chain and anywhere in our

2579
01:06:42,725 --> 01:06:44,510
0,225 225,485 1015,1335 1335,1590 1590,1785
hash table, whatever we're pointing

2580
01:06:44,510 --> 01:06:45,670
0,195 195,315 315,495 495,720 720,1160
at with our split pointer,

2581
01:06:45,720 --> 01:06:47,015
0,440 440,575 575,850 960,1235 1235,1295
that's the one we're going

2582
01:06:47,015 --> 01:06:48,100
0,150 150,455
to split.|
|

2583
01:06:48,100 --> 01:06:49,015
0,240 240,420 420,645 645,810 810,915
And the idea here is
这里的想法是，我们想增量地做这件事，而不是在调整大小时锁定整个表，这样我们就可以在进行时做一些小的修改。

2584
01:06:49,015 --> 01:06:49,780
0,150 150,345 345,510 510,645 645,765
that, again, we want to

2585
01:06:49,780 --> 01:06:51,565
0,120 120,315 315,980 1330,1605 1605,1785
do this incrementally and not

2586
01:06:51,565 --> 01:06:52,285
0,165 165,270 270,420 420,570 570,720
have to lock the whole

2587
01:06:52,285 --> 01:06:53,800
0,225 225,405 405,525 525,995 1285,1515
table while we resize so

2588
01:06:53,800 --> 01:06:54,850
0,90 90,195 195,375 375,690 690,1050
we can make small changes

2589
01:06:54,850 --> 01:06:56,520
0,360 360,600 600,765 765,1070
as we go along.|
|

2590
01:06:56,520 --> 01:06:57,330
0,165 165,330 330,540 540,690 690,810
And the idea here is,
这里的想法是，同样，你摊销了成本，就像，它是在多个工人之间分摊的。所以没有一个工人是不幸的人，他出现了，试图插入一些东西，然后，你知道，他们抽到了短签，他们要对整个事情负责。你在进行的过程中逐步地做，这样会使性能变得平滑。

2591
01:06:57,330 --> 01:06:58,485
0,120 120,300 300,780 780,990 990,1155
again, you're amortizing the cost

2592
01:06:58,485 --> 01:07:00,150
0,150 150,575 625,900 900,1175 1345,1665
of resizing so like, it's

2593
01:07:00,150 --> 01:07:01,170
0,90 90,255 255,495 495,750 750,1020
sort of shared across multiple

2594
01:07:01,170 --> 01:07:02,805
0,330 330,570 570,1200 1200,1380 1380,1635
workers. So there's not one

2595
01:07:02,805 --> 01:07:03,855
0,240 240,465 465,525 525,840 840,1050
worker who's the unlucky one

2596
01:07:03,855 --> 01:07:05,010
0,165 165,345 345,635 745,1035 1035,1155
that shows up, tries to

2597
01:07:05,010 --> 01:07:06,795
0,270 270,560 940,1200 1200,1460 1540,1785
insert something, and then, you

2598
01:07:06,795 --> 01:07:07,890
0,225 225,525 525,720 720,855 855,1095
know, they draw the short

2599
01:07:07,890 --> 01:07:08,955
0,285 285,450 450,690 690,900 900,1065
straw and they're responsible for

2600
01:07:08,955 --> 01:07:10,170
0,315 315,480 480,585 585,845 955,1215
resizing the whole thing. You

2601
01:07:10,170 --> 01:07:11,760
0,120 120,380 1000,1440 1440,1515 1515,1590
do it incrementally as you

2602
01:07:11,760 --> 01:07:12,465
0,120 120,315 315,465 465,585 585,705
go along, and that sort

2603
01:07:12,465 --> 01:07:13,980
0,135 135,345 345,540 540,905
of smooths out performance.|
|

2604
01:07:14,460 --> 01:07:15,905
0,245 245,490 780,1085 1085,1295 1295,1445
So again, the idea here
所以，这里的想法是，我们要。

2605
01:07:15,905 --> 01:07:16,870
0,120 120,285 390,465 465,645 645,965
is that we're going to.|
|

2606
01:07:18,380 --> 01:07:19,045
0,275 275,380 380,545 545,605 605,665
We're gonna, we're gonna be
我们会，我们会分一份的，不管怎样。下一个我们需要的是分裂，这可能不是溢出的。它应该是下一个在哪里，按照我们的递增顺序。然后我们需要维护多个散列函数，这些函数将帮助我们确定。

2607
01:07:19,045 --> 01:07:21,990
0,75 75,270 270,605 745,1145 2545,2945
able to split a split,

2608
01:07:22,040 --> 01:07:22,765
0,275 275,380 380,485 485,620 620,725
whatever. The next one we

2609
01:07:22,765 --> 01:07:23,905
0,105 105,285 285,605 685,975 975,1140
need is split, which may

2610
01:07:23,905 --> 01:07:24,505
0,150 150,270 270,360 360,480 480,600
not be the one that

2611
01:07:24,505 --> 01:07:25,555
0,435 435,645 645,750 750,885 885,1050
overflowed. It should be whatever

2612
01:07:25,555 --> 01:07:26,880
0,105 105,240 240,510 510,875 925,1325
the next one is in,

2613
01:07:27,260 --> 01:07:29,215
0,260 260,455 455,725 725,1060 1650,1955
in our incremental order. And

2614
01:07:29,215 --> 01:07:31,000
0,305 595,900 900,1110 1110,1455 1455,1785
then we'll have maintain multiple

2615
01:07:31,000 --> 01:07:32,305
0,315 315,540 540,890 970,1215 1215,1305
hash functions that that are

2616
01:07:32,305 --> 01:07:34,040
0,90 90,210 210,420 420,755
gonna help us determine.|
|

2617
01:07:35,380 --> 01:07:38,460
0,400 480,880 1170,1570 1650,2050 2760,3080
Which location within our bucket
在我们的遗愿清单中，我们应该关注哪个位置？

2618
01:07:38,460 --> 01:07:39,225
0,210 210,375 375,480 480,570 570,765
list we should be looking

2619
01:07:39,225 --> 01:07:40,200
0,335
at?|
|

2620
01:07:40,720 --> 01:07:41,565
0,230 230,320 320,425 425,515 515,845
Let me share the diagram
让我来分享这张图表，这更有意义。

2621
01:07:41,565 --> 01:07:42,380
0,135 135,270 270,420 420,555 555,815
and this makes more sense.|
|

2622
01:07:43,850 --> 01:07:44,740
0,245 245,365 365,500 500,650 650,890
So again, just look before
所以再说一次，在我们开始之前先看看，我们这里有我们的遗愿清单，它将映射到桶链。

2623
01:07:44,740 --> 01:07:45,775
0,195 195,345 345,510 510,750 750,1035
we have, we have our

2624
01:07:45,775 --> 01:07:47,080
0,210 210,405 405,695 865,1125 1125,1305
bucket list here, and that's

2625
01:07:47,080 --> 01:07:49,420
0,60 60,150 150,330 330,650 2020,2340
going to map to bucket

2626
01:07:49,420 --> 01:07:50,500
0,350
chains.|
|

2627
01:07:50,500 --> 01:07:51,085
0,195 195,345 345,495 495,525 525,585
And then we're going have
然后我们会有一个拆分指针，它会说，这是我们想要随时拆分的下一个东西。我们的哈希哈希表中的任何内容都会溢出。

2628
01:07:51,085 --> 01:07:51,985
0,150 150,360 360,675 675,825 825,900
a split pointer that's going

2629
01:07:51,985 --> 01:07:52,750
0,90 90,255 255,540 540,630 630,765
to say, here's the next

2630
01:07:52,750 --> 01:07:53,365
0,135 135,225 225,315 315,420 420,615
thing we want to split

2631
01:07:53,365 --> 01:07:55,705
0,665 1135,1395 1395,1905 1905,2160 2160,2340
anytime. Anything overflows in our

2632
01:07:55,705 --> 01:07:57,060
0,300 300,525 525,785
hash hash table.|
|

2633
01:07:57,290 --> 01:07:58,210
0,260 260,365 365,470 470,695 695,920
And then we have, at
然后，在一开始，我们假设我们有一个散列函数，为了简单起见，我们有一个只是键的散列函数，键被n修改，但再次假设它接受任意字符串或任意字节序列，并产生整数。

2634
01:07:58,210 --> 01:07:59,380
0,105 105,270 270,590 790,1050 1050,1170
the very beginning, we assume

2635
01:07:59,380 --> 01:08:00,250
0,105 105,240 240,420 420,660 660,870
we have one hash function

2636
01:08:00,250 --> 01:08:04,525
0,315 315,450 450,630 630,920 4000,4275
that's just the key, the

2637
01:08:04,525 --> 01:08:06,820
0,180 180,485 1225,1515 1515,1805 2035,2295
key mod by n for

2638
01:08:06,820 --> 01:08:08,490
0,375 375,620 850,1125 1125,1335 1335,1670
simplicity reasons, but again, assuming

2639
01:08:08,510 --> 01:08:10,170
0,395 395,635 635,860 860,1310 1310,1660
it's taking any arbitrary string

2640
01:08:10,340 --> 01:08:11,575
0,260 260,440 440,830 830,1040 1040,1235
or any arbitrary byte sequence

2641
01:08:11,575 --> 01:08:13,420
0,270 270,540 540,785 895,1505
and spitting out integer.|
|

2642
01:08:14,160 --> 01:08:15,040
0,275 275,425 425,560 560,650 650,880
So say I want to,
假设我想要，我想要六个，我做了我的查找，在两点，我跟随着，我找到了我正在寻找的钥匙，看起来和以前一样，没有什么特别的。但现在我想放17个，它应该放到这个桶里。但那玩意儿已经满了。

2643
01:08:15,300 --> 01:08:16,180
0,245 245,320 320,395 395,560 560,880
I want to get six,

2644
01:08:17,280 --> 01:08:19,565
0,290 290,440 440,590 590,1030 2040,2285
I do my lookup and

2645
01:08:19,565 --> 01:08:20,390
0,150 150,375 375,525 525,630 630,825
at two and I follow

2646
01:08:20,390 --> 01:08:21,140
0,225 225,375 375,465 465,600 600,750
along and I find the

2647
01:08:21,140 --> 01:08:22,940
0,90 90,210 210,345 345,650 1510,1800
key I'm looking for that

2648
01:08:22,940 --> 01:08:24,110
0,195 195,360 360,480 480,740 850,1170
looks just like before, nothing

2649
01:08:24,110 --> 01:08:25,520
0,320 910,1155 1155,1245 1245,1335 1335,1410
special. But now I want

2650
01:08:25,520 --> 01:08:27,080
0,90 90,255 255,560 1240,1470 1470,1560
to put seventeen and it

2651
01:08:27,080 --> 01:08:29,075
0,120 120,345 345,710 1390,1710 1710,1995
should go into this bucket

2652
01:08:29,075 --> 01:08:30,850
0,365 655,915 915,1095 1095,1485 1485,1775
here. But that thing's full.|
|

2653
01:08:31,400 --> 01:08:32,285
0,350 370,660 660,735 735,810 810,885
So we're just going to
所以我们只是要做一个溢出，就像链哈希法一样，用另一个桶来扩展它，并将它插入到新页面中。但现在，因为我们已经满溢了。

2654
01:08:32,285 --> 01:08:34,130
0,90 90,180 180,755 1315,1590 1590,1845
do an overflow, just like

2655
01:08:34,130 --> 01:08:35,360
0,270 270,630 630,825 825,1005 1005,1230
chain hashing to extend it

2656
01:08:35,360 --> 01:08:37,340
0,255 255,560 820,1140 1140,1460 1720,1980
with another, another bucket and

2657
01:08:37,340 --> 01:08:40,325
0,240 240,360 360,600 600,980 2560,2985
insert it into the insert

2658
01:08:40,325 --> 01:08:41,530
0,90 90,225 225,515 625,915 915,1205
it into that new page.

2659
01:08:42,150 --> 01:08:44,290
0,290 290,580 960,1280 1280,1460 1460,2140
But now, because we overflowed.|
|

2660
01:08:45,030 --> 01:08:46,480
0,245 245,350 350,605 605,1000 1050,1450
We need to split whatever
无论我指的是哪一个分割点，我们都需要分割。

2661
01:08:46,710 --> 01:08:47,495
0,290 290,455 455,575 575,650 650,785
the split point I was

2662
01:08:47,495 --> 01:08:48,640
0,210 210,515
pointing at.|
|

2663
01:08:48,640 --> 01:08:49,345
0,165 165,225 225,345 345,525 525,705
So in this case here,
所以在本例中，它指向0桶0桶列表0，即使它没有溢出。

2664
01:08:49,345 --> 01:08:52,360
0,240 240,495 495,875 2275,2655 2655,3015
it's pointing to bucket zero

2665
01:08:52,360 --> 01:08:54,175
0,285 285,495 495,800 1300,1620 1620,1815
bucket list zero, even though

2666
01:08:54,175 --> 01:08:55,740
0,180 180,390 390,875
that didn't overflow.|
|

2667
01:08:56,080 --> 01:08:56,730
0,230 230,320 320,425 425,530 530,650
So what we need to
所以我们现在需要做的是查看这个遗愿清单中的所有条目，然后我们将根据n2n对它们进行重新散列。

2668
01:08:56,730 --> 01:08:57,375
0,150 150,300 300,420 420,540 540,645
do now is look at

2669
01:08:57,375 --> 01:08:59,115
0,225 225,465 465,935 1255,1560 1560,1740
all the entries inside this

2670
01:08:59,115 --> 01:09:00,480
0,210 210,545 895,1155 1155,1320 1320,1365
bucket list, and we're going

2671
01:09:00,480 --> 01:09:02,325
0,90 90,570 570,950 1150,1500 1500,1845
to rehash them based on

2672
01:09:02,325 --> 01:09:04,980
0,395 1225,1620 1620,1875 1875,2135
the n two n.|
|

2673
01:09:05,160 --> 01:09:06,215
0,245 245,365 365,410 410,560 560,1055
Because we're going to incrementally
因为我们每次都会递增一个遗愿清单的大小。所以我们有四个参赛作品。现在，在我们分开之后，现在我们有五个了。

2674
01:09:06,215 --> 01:09:08,320
0,335 505,905 1045,1445 1465,1785 1785,2105
grow the size of the

2675
01:09:08,430 --> 01:09:09,905
0,335 335,670 750,1055 1055,1265 1265,1475
bucket list by one each

2676
01:09:09,905 --> 01:09:11,600
0,305 745,975 975,1205 1225,1530 1530,1695
time. So we had four

2677
01:09:11,600 --> 01:09:13,235
0,440 730,1110 1110,1395 1395,1545 1545,1635
entries. Now, after we got

2678
01:09:13,235 --> 01:09:14,255
0,150 150,375 375,645 645,885 885,1020
to split, now we'll have

2679
01:09:14,255 --> 01:09:15,340
0,305
five.|
|

2680
01:09:15,880 --> 01:09:16,970
0,230 230,320 320,515 515,770 770,1090
So we go through and
所以我们遍历，这指向那里，对于每个单独的密钥，我们将基于，而不是mod，n来重新散列它，但是mod 2n，所以8mod8是0，所以它停留在它是20的地方。模数8现在是4，所以它将被移到下面这一页。

2681
01:09:17,710 --> 01:09:18,825
0,260 260,395 395,670 720,965 965,1115
this points there, for every

2682
01:09:18,825 --> 01:09:19,680
0,240 240,510 510,750 750,795 795,855
single key, we're going to

2683
01:09:19,680 --> 01:09:21,200
0,300 300,510 510,720 720,1040 1120,1520
rehash it based on on

2684
01:09:21,400 --> 01:09:22,320
0,230 230,320 320,485 485,725 725,920
instead of mod n, but

2685
01:09:22,320 --> 01:09:23,960
0,195 195,375 375,620 1090,1365 1365,1640
mod two n so eight

2686
01:09:24,280 --> 01:09:25,380
0,290 290,485 485,680 680,920 920,1100
mod eight is zero, so

2687
01:09:25,380 --> 01:09:26,150
0,135 135,330 330,450 450,525 525,770
that stays where it was

2688
01:09:26,650 --> 01:09:28,050
0,380 380,710 710,995 995,1205 1205,1400
twenty. Mod eight is now

2689
01:09:28,050 --> 01:09:29,160
0,320 520,765 765,990 990,1050 1050,1110
four, so that's going to

2690
01:09:29,160 --> 01:09:30,140
0,90 90,255 255,525 525,735 735,980
get moved down to this

2691
01:09:30,280 --> 01:09:31,820
0,335 335,590 590,800 800,1090
new page down here.|
|

2692
01:09:32,130 --> 01:09:33,220
0,400
Right.|
正确的。|

2693
01:09:33,820 --> 01:09:34,950
0,275 275,485 485,755 755,965 965,1130
And then now the split
然后现在拆分指针只向下移动一位。

2694
01:09:34,950 --> 01:09:35,940
0,270 270,405 405,600 600,810 810,990
pointer just moves down by

2695
01:09:35,940 --> 01:09:36,960
0,290
one.|
|

2696
01:09:37,180 --> 01:09:38,490
0,275 275,485 485,725 725,980 980,1310
And we continue doing whatever
我们将继续执行您在哈希表上继续操作的操作。

2697
01:09:38,490 --> 01:09:40,455
0,380 850,1250 1480,1755 1755,1875 1875,1965
you continue operating on the

2698
01:09:40,455 --> 01:09:41,440
0,150 150,395
hash table.|
|

2699
01:09:41,670 --> 01:09:42,800
0,400
Right.|
正确的。|

2700
01:09:43,940 --> 01:09:44,665
0,245 245,320 320,395 395,515 515,725
So now I do get
所以现在我真的得到了20美元。

2701
01:09:44,665 --> 01:09:45,760
0,335
twenty.|
|

2702
01:09:45,760 --> 01:09:47,335
0,225 225,530 640,1005 1005,1335 1335,1575
I first, uh, when I
我首先，呃，当我第一次散列它的时候，我会得到零，但然后我知道我的遗愿列表中的那个位置在拆分指针打印的位置上方。所以我已经，我已经把上面的所有东西都拆分了。

2703
01:09:47,335 --> 01:09:48,745
0,180 180,465 465,725 985,1260 1260,1410
first hash it, I would

2704
01:09:48,745 --> 01:09:50,455
0,275 325,725 1195,1440 1440,1545 1545,1710
get zero, but then I

2705
01:09:50,455 --> 01:09:52,540
0,255 255,605 1015,1415 1465,1845 1845,2085
know that that location in

2706
01:09:52,540 --> 01:09:54,750
0,260 400,800 1390,1710 1710,1920 1920,2210
my my bucket list here

2707
01:09:54,950 --> 01:09:56,695
0,400 420,820 1020,1340 1340,1550 1550,1745
is above where the split

2708
01:09:56,695 --> 01:09:58,090
0,240 240,450 450,810 810,1055 1165,1395
pointer is printing at. So

2709
01:09:58,090 --> 01:09:59,545
0,315 315,645 645,840 840,1245 1245,1455
I've, I've already splitted everything

2710
01:09:59,545 --> 01:10:00,640
0,195 195,405 405,695
up above it.|
|

2711
01:10:00,640 --> 01:10:02,440
0,350 370,705 705,1040 1180,1530 1530,1800
So after I mod by
所以在我四次修改后，现在我得到了八次修改，以确定它的真实位置，然后这就是我如何在底部找到它的方法。

2712
01:10:02,440 --> 01:10:03,610
0,320 520,780 780,885 885,990 990,1170
four, I got a mod

2713
01:10:03,610 --> 01:10:04,675
0,255 255,525 525,780 780,960 960,1065
by eight now to figure

2714
01:10:04,675 --> 01:10:05,730
0,135 135,285 285,450 450,705 705,1055
out where it really is,

2715
01:10:06,170 --> 01:10:06,940
0,245 245,365 365,590 590,665 665,770
and then that's how I

2716
01:10:06,940 --> 01:10:07,765
0,120 120,270 270,435 435,600 600,825
can find it down here

2717
01:10:07,765 --> 01:10:08,920
0,195 195,300 300,545
at the bottom.|
|

2718
01:10:10,610 --> 01:10:11,230
0,230 230,305 305,395 395,485 485,620
Say I want to get
假设在这种情况下我想得到9个。它指向拆分指针所指向的存储桶的确切位置，所以我知道我还没有拆分它，所以我只能对它进行散列一次，然后沿着链表扫描，直到找到我要找的东西。

2719
01:10:11,230 --> 01:10:12,805
0,290 700,960 960,1110 1110,1320 1320,1575
nine in this case here.

2720
01:10:12,805 --> 01:10:13,840
0,255 255,435 435,630 630,840 840,1035
It's pointing to exactly where

2721
01:10:13,840 --> 01:10:15,235
0,210 210,560 790,1050 1050,1185 1185,1395
the bucket the split pointer

2722
01:10:15,235 --> 01:10:16,330
0,165 165,390 390,695 775,1005 1005,1095
is pointing at, so I

2723
01:10:16,330 --> 01:10:17,140
0,135 135,255 255,540 540,705 705,810
know I haven't split it

2724
01:10:17,140 --> 01:10:18,385
0,260 430,660 660,890 910,1140 1140,1245
yet, so I can just

2725
01:10:18,385 --> 01:10:19,645
0,180 180,390 390,510 510,785 1015,1260
only hash it once and

2726
01:10:19,645 --> 01:10:20,935
0,150 150,375 375,675 675,1035 1035,1290
I scan along the link

2727
01:10:20,935 --> 01:10:21,655
0,195 195,345 345,435 435,585 585,720
list until I find the

2728
01:10:21,655 --> 01:10:22,820
0,105 105,255 255,405 405,725
thing I'm looking for.|
|

2729
01:10:27,350 --> 01:10:28,930
0,260 260,425 425,665 665,1000 1290,1580
And at some point, the
在某一时刻，拆分指针将到达底部，我将有，我将有八个槽，我只是循环回来，从头开始。

2730
01:10:28,930 --> 01:10:29,680
0,180 180,420 420,510 510,645 645,750
split pointer will get to

2731
01:10:29,680 --> 01:10:31,350
0,90 90,350 970,1230 1230,1440 1440,1670
the bottom, and I'll have,

2732
01:10:31,370 --> 01:10:33,055
0,320 320,440 440,650 650,1000 1320,1685
I'll have eight slots and

2733
01:10:33,055 --> 01:10:33,865
0,210 210,330 330,465 465,630 630,810
I just loop back around

2734
01:10:33,865 --> 01:10:34,740
0,150 150,285 285,405 405,570 570,875
and start all over again.|
|

2735
01:10:37,430 --> 01:10:38,340
0,245 245,350 350,500 500,650 650,910
So this seems kind of
所以这看起来有点违反直觉，好像我没有拆分溢出的东西，我拆分到分割点所指向的任何位置。

2736
01:10:38,360 --> 01:10:39,760
0,710 710,830 830,965 965,1175 1175,1400
counterintuitive that, like I'm not

2737
01:10:39,760 --> 01:10:40,980
0,345 345,450 450,585 585,705 705,1220
splitting the thing that overflowed,

2738
01:10:41,180 --> 01:10:42,235
0,380 380,635 635,755 755,905 905,1055
I'm splitting to whatever the

2739
01:10:42,235 --> 01:10:43,700
0,150 150,345 345,570 570,875
split point points at.|
|

2740
01:10:43,960 --> 01:10:45,075
0,245 245,455 455,725 725,920 920,1115
But the idea is again
但我们的想法是，如果你说这个位置是一个，这个东西非常热，我不停地溢出，溢出，我最终会把它分成两半。

2741
01:10:45,075 --> 01:10:47,150
0,305 415,815 1165,1500 1500,1755 1755,2075
that if you say this

2742
01:10:47,680 --> 01:10:50,340
0,400 1380,1780 1980,2300 2300,2495 2495,2660
location one, this thing is

2743
01:10:50,340 --> 01:10:51,120
0,225 225,435 435,540 540,645 645,780
super hot and I keep

2744
01:10:51,120 --> 01:10:54,345
0,465 465,1130 2590,2880 2880,3045 3045,3225
overflowing, overflowing, I'm eventually going

2745
01:10:54,345 --> 01:10:55,260
0,120 120,255 255,515
to split it.|
|

2746
01:10:55,260 --> 01:10:56,440
0,380
Right.|
正确的。|

2747
01:10:56,730 --> 01:10:58,940
0,400 480,880 1320,1720 1740,2045 2045,2210
So eventually, everything gets split
因此，最终，一切都会被拆分并正确调整大小。

2748
01:10:58,940 --> 01:11:01,480
0,195 195,530 940,1470 1470,1820
out and resize correctly.|
|

2749
01:11:04,490 --> 01:11:05,580
0,400
Yes.|
是。|

2750
01:11:06,800 --> 01:11:07,745
0,135 135,300 300,480 480,705 705,945
It seems like every time
似乎每次我们结束的时候。

2751
01:11:07,745 --> 01:11:08,320
0,195 195,485
we over.|
|

2752
01:11:15,580 --> 01:11:16,255
0,75 75,180 180,345 345,525 525,675
As it moves down by
我们补充说，因为它同时向下移动了一位。

2753
01:11:16,255 --> 01:11:17,170
0,135 135,300 300,525 525,735 735,915
one the same time, we

2754
01:11:17,170 --> 01:11:17,560
0,290
add.|
|

2755
01:11:19,220 --> 01:11:20,500
0,400 510,755 755,890 890,1070 1070,1280
So the question is when,
所以问题是什么时候，什么时候它会真正地被包围？因为有一个这样你就会达到这样的程度。

2756
01:11:20,500 --> 01:11:21,175
0,180 180,270 270,390 390,525 525,675
when would it actually wrap

2757
01:11:21,175 --> 01:11:23,260
0,225 225,545 1135,1440 1440,1745 1855,2085
around? Because have one so

2758
01:11:23,260 --> 01:11:23,785
0,60 60,150 150,300 300,420 420,525
you would get to the

2759
01:11:23,785 --> 01:11:24,920
0,135 135,395
point where.|
|

2760
01:11:25,230 --> 01:11:26,870
0,275 275,440 440,670 870,1270 1320,1640
So it'd be five, six,
所以它是5，6，7，然后你就是7，然后你必须循环回到0，因为你知道从它在这里的时候，当它只从0到3的时候。

2761
01:11:26,870 --> 01:11:28,295
0,320 490,750 750,990 990,1275 1275,1425
seven, and then you'll be

2762
01:11:28,295 --> 01:11:29,720
0,335 805,1065 1065,1170 1170,1290 1290,1425
seven, and then you have

2763
01:11:29,720 --> 01:11:32,045
0,260 1540,1845 1845,2025 2025,2175 2175,2325
to you loop back around

2764
01:11:32,045 --> 01:11:32,795
0,135 135,300 300,450 450,570 570,750
to zero because you know

2765
01:11:32,795 --> 01:11:36,190
0,305 1525,1925 2425,2715 2715,3045 3045,3395
that from when it's here,

2766
01:11:36,720 --> 01:11:37,640
0,245 245,380 380,530 530,740 740,920
when it's only from zero

2767
01:11:37,640 --> 01:11:38,960
0,225 225,560
to three.|
|

2768
01:11:40,580 --> 01:11:41,945
0,290 370,735 735,930 930,1065 1065,1365
Yeah, once you get past
是的，一旦过了7点，你就知道你的起点了。从你开始的地方算起是2n。然后你又循环回来。

2769
01:11:41,945 --> 01:11:43,570
0,360 360,630 630,935 1105,1365 1365,1625
seven, you know where you

2770
01:11:43,590 --> 01:11:45,725
0,290 290,470 470,1730 1730,1895 1895,2135
starting point. That's two n

2771
01:11:45,725 --> 01:11:46,660
0,225 225,345 345,480 480,645 645,935
from where you started at.

2772
01:11:46,740 --> 01:11:47,525
0,245 245,365 365,500 500,620 620,785
So then you loop back

2773
01:11:47,525 --> 01:11:48,320
0,305
around.|
|

2774
01:11:49,575 --> 01:11:50,840
0,90 90,335
Don't we?|
不是吗？|

2775
01:11:53,450 --> 01:11:54,460
0,365 365,590 590,680 680,785 785,1010
You add a new page
你添加了一个新的页面，但我知道当我读到第八页时，我应该绕过去。

2776
01:11:54,460 --> 01:11:55,465
0,195 195,330 330,555 555,825 825,1005
but like, I know that

2777
01:11:55,465 --> 01:11:56,380
0,105 105,225 225,405 405,690 690,915
I should wrap around when

2778
01:11:56,380 --> 01:11:57,640
0,120 120,380 820,1065 1065,1155 1155,1260
I get when I go

2779
01:11:57,640 --> 01:11:58,800
0,105 105,350
to eight.|
|

2780
01:11:58,800 --> 01:12:00,600
0,350 430,735 735,1040 1270,1620 1620,1800
At position eight, because when
在位置8，因为我开始的时候有4，所以2乘以4等于8，所以当我超过8的时候，我循环回来。然后你一直这样做，直到你得到16岁，然后循环回来。

2781
01:12:00,600 --> 01:12:02,270
0,150 150,470 910,1155 1155,1335 1335,1670
I started I had four,

2782
01:12:02,500 --> 01:12:03,735
0,365 365,620 620,860 860,1085 1085,1235
so two times four is

2783
01:12:03,735 --> 01:12:04,305
0,180 180,315 315,375 375,450 450,570
eight, so when I get

2784
01:12:04,305 --> 01:12:05,235
0,180 180,420 420,630 630,765 765,930
past eight, I loop back

2785
01:12:05,235 --> 01:12:06,765
0,305 655,1020 1020,1260 1260,1380 1380,1530
around. Then you do that

2786
01:12:06,765 --> 01:12:07,740
0,135 135,210 210,330 330,605 685,975
until you get sixteen and

2787
01:12:07,740 --> 01:12:09,280
0,150 150,315 315,620
loop back around.|
|

2788
01:12:15,280 --> 01:12:16,400
0,320 320,485 485,575 575,770 770,1120
Good idea or bad idea?|
好主意还是坏主意？|

2789
01:12:22,920 --> 01:12:24,605
0,335 335,605 605,1000 1110,1430 1430,1685
It's clever, right? Again, it's,
这很聪明，对吧？再说一次，这是一个很好的技巧，增量地做这件事。但话又说回来，有更多的簿记，更多的机器。

2790
01:12:24,605 --> 01:12:25,900
0,150 150,210 210,455 565,930 930,1295
it's a nice technique to

2791
01:12:26,010 --> 01:12:28,775
0,335 335,530 530,695 695,1210 2430,2765
do, do this incrementally. But

2792
01:12:28,775 --> 01:12:29,495
0,225 225,420 420,465 465,570 570,720
again, there's a lot more

2793
01:12:29,495 --> 01:12:31,000
0,465 465,600 600,720 720,855 855,1505
bookkeeping, a lot more machinery.|
|

2794
01:12:31,660 --> 01:12:32,485
0,90 90,255 255,450 450,630 630,825
In order to actually implement
为了真正实现这些目标。

2795
01:12:32,485 --> 01:12:33,480
0,305
those.|
|

2796
01:12:33,690 --> 01:12:34,900
0,400
Yes.|
是。|

2797
01:12:38,610 --> 01:12:39,950
0,365 365,710 710,995 995,1190 1190,1340
And this question is, if
问题是，如果你只是在抬头看的时候才这样做，那么在这个场景中，你只有两次最多的散列，是的。

2798
01:12:39,950 --> 01:12:40,505
0,105 105,225 225,360 360,465 465,555
you only do when you

2799
01:12:40,505 --> 01:12:41,180
0,105 105,225 225,345 345,450 450,675
do look up, you only

2800
01:12:41,180 --> 01:12:42,280
0,255 255,450 450,570 570,765 765,1100
had hash it most twice

2801
01:12:42,450 --> 01:12:44,140
0,260 260,395 395,635 635,1000
in this scenario, yes.|
|

2802
01:12:45,480 --> 01:12:46,475
0,260 260,395 395,530 530,755 755,995
Like if, like, if this
就像，如果，如果这个东西很大，我可以说是的。所以实际上发生的事情是，一旦我说到8，我绕回，我可以去掉第一个散列函数。是的，那么在这种情况下，你会添加最多的两个吗？

2803
01:12:46,475 --> 01:12:47,420
0,135 135,285 285,570 570,825 825,945
thing is massive, I could

2804
01:12:47,420 --> 01:12:48,845
0,180 180,500 820,1110 1110,1290 1290,1425
have like yeah. So actually

2805
01:12:48,845 --> 01:12:50,795
0,105 105,285 285,605 1465,1755 1755,1950
what happens is once I

2806
01:12:50,795 --> 01:12:52,385
0,255 255,605 1015,1305 1305,1455 1455,1590
get to say I got

2807
01:12:52,385 --> 01:12:53,150
0,120 120,285 285,465 465,600 600,765
to eight and I wrap

2808
01:12:53,150 --> 01:12:54,530
0,195 195,500 670,945 945,1140 1140,1380
back around, I can drop

2809
01:12:54,530 --> 01:12:55,985
0,180 180,315 315,540 540,800 1120,1455
the first hash function. Yeah,

2810
01:12:55,985 --> 01:12:56,885
0,285 285,510 510,660 660,795 795,900
so in this case, are

2811
01:12:56,885 --> 01:12:57,365
0,90 90,150 150,195 195,300 300,480
you going to add most

2812
01:12:57,365 --> 01:12:58,460
0,305
two?|
|

2813
01:13:02,430 --> 01:13:03,540
0,400
Yes.|
是。|

2814
01:13:04,880 --> 01:13:05,710
0,150 150,240 240,315 315,495 495,830
Go to the next line.|
转到下一行。|

2815
01:13:07,680 --> 01:13:10,415
0,275 275,820 2130,2450 2450,2630 2630,2735
About deletes so there are
关于删除，所以只有。

2816
01:13:10,415 --> 01:13:10,840
0,245
only.|
|

2817
01:13:16,100 --> 01:13:17,960
0,290 490,780 780,1070 1150,1550
One, two, m, eight.|
一，二，米，八。|

2818
01:13:19,830 --> 01:13:21,240
0,290 290,470 470,760
His question is.|
他的问题是。|

2819
01:13:22,390 --> 01:13:23,880
0,305 305,610 1100,1220 1220,1370 1370,1490
And here I'm trying to
而现在我正试着在8点前脱掉。

2820
01:13:23,880 --> 01:13:25,860
0,260 610,900 900,1190
mod by eight.|
|

2821
01:13:25,900 --> 01:13:26,750
0,275 275,395 395,470 470,575 575,850
But what if I get
但如果我有七个，但我没有呢？但是，再说一次，你，你得不到7分是因为？

2822
01:13:26,830 --> 01:13:27,780
0,350 350,545 545,635 635,800 800,950
seven and I don't have

2823
01:13:27,780 --> 01:13:29,400
0,290 490,765 765,960 960,1280 1300,1620
it? But again, you, you

2824
01:13:29,400 --> 01:13:30,300
0,360 360,480 480,570 570,690 690,900
wouldn't be able to get

2825
01:13:30,300 --> 01:13:31,840
0,330 330,710
seven because?|
|

2826
01:13:31,970 --> 01:13:33,300
0,400
Uh.|
呃。|

2827
01:13:33,300 --> 01:13:34,800
0,465 465,615 615,920 1000,1305 1305,1500
You'd be below the split
你会在分裂指针之下，你只会以4，8的速度散列。

2828
01:13:34,800 --> 01:13:35,880
0,360 360,525 525,690 690,825 825,1080
pointer and you'd only hash

2829
01:13:35,880 --> 01:13:37,880
0,290 580,980 1060,1460
by four, eight.|
|

2830
01:13:39,190 --> 01:13:41,025
0,305 305,515 515,820 990,1280 1280,1835
Right. So, so this demarcation
正确的。所以，这条分界线是说，我已经把上面的一切都拆分了，下面没有什么可以避免这个问题，你不会落地在这里，你真的喜欢你不会落地。

2831
01:13:41,025 --> 01:13:42,705
0,270 270,525 525,900 900,1205 1285,1680
line says I've split everything

2832
01:13:42,705 --> 01:13:44,970
0,395 565,825 825,1035 1035,1385 1855,2265
above and nothing below avoids

2833
01:13:44,970 --> 01:13:46,515
0,135 135,410 820,1155 1155,1335 1335,1545
that problem that you don't

2834
01:13:46,515 --> 01:13:47,660
0,240 240,555 555,765 765,885 885,1145
land here and you really

2835
01:13:47,710 --> 01:13:49,100
0,395 395,620 620,970
like you don't.|
|

2836
01:13:49,310 --> 01:13:50,380
0,245 245,425 425,695 695,905 905,1070
You don't hash first and
你不会先散列，然后在这里登陆，但如果你先散列两次，然后在这里登陆一些东西，你还没有分裂。

2837
01:13:50,380 --> 01:13:51,280
0,195 195,435 435,645 645,795 795,900
land here, but if you

2838
01:13:51,280 --> 01:13:52,420
0,195 195,470 580,825 825,975 975,1140
hash by two n you

2839
01:13:52,420 --> 01:13:53,515
0,150 150,345 345,630 630,870 870,1095
land something here, you haven't

2840
01:13:53,515 --> 01:13:54,340
0,180 180,485
split yet.|
|

2841
01:13:54,870 --> 01:13:56,645
0,320 320,530 530,830 830,1330 1470,1775
The split pointer waterline avoids
分体式指针水线避免了这个问题。

2842
01:13:56,645 --> 01:13:57,600
0,120 120,395
that problem.|
|

2843
01:14:04,330 --> 01:14:06,220
0,335 335,670
Right, so.|
对，所以。|

2844
01:14:06,500 --> 01:14:07,465
0,350 350,590 590,740 740,875 875,965
Splitting buckets based on the
根据翻转所有者划分存储桶最终会导致所有存储桶溢出。

2845
01:14:07,465 --> 01:14:09,040
0,105 105,365 805,1185 1185,1440 1440,1575
flip owner eventually gets you

2846
01:14:09,040 --> 01:14:11,780
0,210 210,705 705,1160
all overflow buckets.|
|

2847
01:14:11,780 --> 01:14:13,535
0,380 1210,1455 1455,1575 1575,1680 1680,1755
Again, said this, when you
同样，当您到达底部时，您只需丢弃第一个哈希函数，然后循环返回。

2848
01:14:13,535 --> 01:14:14,380
0,105 105,210 210,405 405,600 600,845
reach the bottom, you just

2849
01:14:14,490 --> 01:14:15,575
0,290 290,425 425,665 665,965 965,1085
drop the first hash function

2850
01:14:15,575 --> 01:14:17,700
0,120 120,225 225,390 390,695
and loop back around.|
|

2851
01:14:17,880 --> 01:14:19,280
0,400
The.|
这个。|

2852
01:14:20,490 --> 01:14:22,175
0,335 335,635 635,1000 1230,1505 1505,1685
In this technique also allows
在这个技巧上也能让你做到。

2853
01:14:22,175 --> 01:14:23,460
0,135 135,240 240,515
you to do.|
|

2854
01:14:24,390 --> 01:14:25,840
0,500 500,620 620,1025 1025,1160 1160,1450
Contraction or coalescing as well,
也可以缩写或合并，因为你可以确定遗愿清单是空的。

2855
01:14:26,280 --> 01:14:28,480
0,400 720,995 995,1270 1410,1805 1805,2200
because you could identify that

2856
01:14:29,190 --> 01:14:30,250
0,275 275,470 470,680 680,815 815,1060
a bucket list is empty.|
|

2857
01:14:31,130 --> 01:14:32,380
0,400 570,815 815,950 950,1100 1100,1250
And you could do the
而你可以做相反的事情。你可以，可以把它扔掉，把空的那一桶巩固起来。就像你可以扔掉它，然后把拆分指针向上移动一样。

2858
01:14:32,380 --> 01:14:33,790
0,240 240,435 435,680 700,1080 1080,1410
reverse. You could, could could

2859
01:14:33,790 --> 01:14:35,790
0,210 210,345 345,620 1030,1650 1650,2000
throw it away, consolidate the

2860
01:14:36,050 --> 01:14:37,735
0,400 420,680 680,940 1080,1460 1460,1685
the one bucket empty. So

2861
01:14:37,735 --> 01:14:38,620
0,210 210,420 420,585 585,765 765,885
like you could just throw

2862
01:14:38,620 --> 01:14:39,580
0,120 120,380 490,750 750,855 855,960
it away and you move

2863
01:14:39,580 --> 01:14:40,530
0,150 150,315 315,555 555,675 675,950
the split pointer back up.|
|

2864
01:14:41,410 --> 01:14:42,270
0,245 245,350 350,500 500,695 695,860
And at last, you actually
最后，您实际上缩小了哈希表的大小。

2865
01:14:42,270 --> 01:14:43,185
0,180 180,315 315,555 555,795 795,915
shrink the size of the

2866
01:14:43,185 --> 01:14:44,360
0,195 195,455
hash table.|
|

2867
01:14:44,540 --> 01:14:45,720
0,320 320,485 485,635 635,860 860,1180
Right, so going back here,
好的，回到这里，假设我删除了20个。

2868
01:14:46,010 --> 01:14:47,740
0,245 245,410 410,650 650,970
say I delete twenty.|
|

2869
01:14:48,680 --> 01:14:50,010
0,290 290,485 485,635 635,880 930,1330
I mod it by four,
我把它修改为4，但后来我意识到它在拆分指针的下方，我必须深入到底部，然后继续删除它。但现在这一页是空的。

2870
01:14:50,450 --> 01:14:51,400
0,260 260,365 365,515 515,710 710,950
but then I realize that's

2871
01:14:51,400 --> 01:14:52,630
0,240 240,570 570,810 810,1095 1095,1230
below the split pointer and

2872
01:14:52,630 --> 01:14:53,290
0,120 120,210 210,285 285,405 405,660
I got to get down

2873
01:14:53,290 --> 01:14:54,790
0,285 285,435 435,615 615,950 1270,1500
to the bottom here and

2874
01:14:54,790 --> 01:14:55,420
0,75 75,210 210,345 345,480 480,630
I go ahead and delete

2875
01:14:55,420 --> 01:14:56,755
0,260 520,780 780,960 960,1170 1170,1335
it. But now this page

2876
01:14:56,755 --> 01:14:58,000
0,135 135,395
is empty.|
|

2877
01:14:58,070 --> 01:14:59,035
0,215 215,275 275,425 425,680 680,965
So if I wanted to,
所以如果我想，我可以把指针移回去，然后删除最后一个条目，删除最后一个哈希表。

2878
01:14:59,035 --> 01:15:00,220
0,240 240,495 495,765 765,960 960,1185
I could just move the

2879
01:15:00,220 --> 01:15:01,830
0,285 285,420 420,710 1090,1350 1350,1610
pointer back up and then

2880
01:15:01,880 --> 01:15:02,890
0,290 290,455 455,710 710,920 920,1010
drop that last entry and

2881
01:15:02,890 --> 01:15:03,780
0,150 150,270 270,390 390,630 630,890
drop the last hash table.|
|

2882
01:15:04,980 --> 01:15:06,860
0,400 960,1280 1280,1490 1490,1700 1700,1880
Right. And obviously you need
对的显然你需要聪明点，确保我不会振荡，比如，插入20，删除20，插入20，我不断地分裂和合并。那就糟了

2883
01:15:06,860 --> 01:15:07,730
0,105 105,240 240,510 510,735 735,870
to be clever and make

2884
01:15:07,730 --> 01:15:09,130
0,165 165,315 315,590 790,1050 1050,1400
sure that like I don't

2885
01:15:09,150 --> 01:15:10,670
0,530 530,680 680,1025 1025,1280 1280,1520
oscillate, like insert twenty, delete

2886
01:15:10,670 --> 01:15:11,765
0,165 165,420 420,645 645,885 885,1095
twenty, insert twenty, I keep

2887
01:15:11,765 --> 01:15:13,370
0,315 315,450 450,615 615,1265 1345,1605
splitting it and coalescing. That

2888
01:15:13,370 --> 01:15:15,540
0,105 105,225 225,500
would be bad.|
|

2889
01:15:15,540 --> 01:15:17,535
0,330 330,660 660,1010 1060,1460 1750,1995
But you could contract the
但你可以在此基础上压缩数据结构。

2890
01:15:17,535 --> 01:15:18,560
0,180 180,435 435,630 630,765 765,1025
data structure based on this.|
|

2891
01:15:19,200 --> 01:15:20,295
0,320 580,810 810,945 945,990 990,1095
Right. You don't want to
对的你不想插入21，然后溢出，再一次分裂。

2892
01:15:20,295 --> 01:15:21,800
0,300 300,660 660,825 825,1215 1215,1505
insert 21 then overflow and

2893
01:15:21,940 --> 01:15:23,780
0,245 245,350 350,515 515,820
split all over again.|
|

2894
01:15:26,220 --> 01:15:27,850
0,260 260,425 425,575 575,1090 1230,1630
I don't think postgres supports
我不认为postgres支持缩小哈希表的大小。

2895
01:15:28,890 --> 01:15:29,840
0,440 440,560 560,725 725,875 875,950
shrinking the size of the

2896
01:15:29,840 --> 01:15:30,940
0,150 150,410
hash table.|
|

2897
01:15:31,470 --> 01:15:32,075
0,260 260,365 365,455 455,530 530,605
As far as I know,
据我所知，没有重建整个事情。

2898
01:15:32,075 --> 01:15:33,340
0,245 295,795 795,885 885,990 990,1265
without rebuilding the whole thing.|
|

2899
01:15:38,580 --> 01:15:40,180
0,245 245,410 410,730 990,1340 1340,1600
All right, so hash tables,
好的，哈希表，又一次，超级有用。大多数系统将只实现哈希的线性。但是，您仍然可以根据数据类型和其他方面的使用方式来专门化它。clickhouse可能是最好的例子。对于很多商业系统来说。很难知道他们实际上在使用什么，除非有一篇论文讨论它，或者我们知道在那里工作的人可以告诉我们，你知道，这不是你知道的使用SQL的人，应用程序开发人员，你应该知道或关心的事情，但有时知道这些评估是如何实现的是很好的。

2900
01:15:40,350 --> 01:15:42,395
0,335 335,590 590,910 1470,1805 1805,2045
again, super useful. Most systems

2901
01:15:42,395 --> 01:15:43,130
0,150 150,210 210,255 255,420 420,735
are going to just implement

2902
01:15:43,130 --> 01:15:44,630
0,285 285,555 555,660 660,1130 1240,1500
the lineer of hashing. But

2903
01:15:44,630 --> 01:15:45,665
0,135 135,255 255,375 375,585 585,1035
again you can still specialize

2904
01:15:45,665 --> 01:15:46,385
0,120 120,240 240,390 390,525 525,720
it based on the data

2905
01:15:46,385 --> 01:15:47,765
0,270 270,465 465,720 720,1050 1050,1380
type and other aspects of

2906
01:15:47,765 --> 01:15:48,530
0,285 285,480 480,570 570,660 660,765
how it's going to be

2907
01:15:48,530 --> 01:15:50,480
0,260 610,1005 1005,1470 1470,1725 1725,1950
used. And clickhouse is probably

2908
01:15:50,480 --> 01:15:51,580
0,135 135,315 315,585 585,810 810,1100
the best example of this.

2909
01:15:52,830 --> 01:15:53,405
0,215 215,275 275,380 380,470 470,575
For a lot of the

2910
01:15:53,405 --> 01:15:54,515
0,210 210,495 495,765 765,930 930,1110
commercial systems. It's very hard

2911
01:15:54,515 --> 01:15:55,760
0,120 120,365 445,720 720,1050 1050,1245
to know what hasatchhable they're

2912
01:15:55,760 --> 01:15:57,425
0,135 135,410 1120,1380 1380,1560 1560,1665
actually using unless there's a

2913
01:15:57,425 --> 01:15:59,060
0,275 325,660 660,885 885,1175 1345,1635
paper talking about it or

2914
01:15:59,060 --> 01:15:59,810
0,150 150,300 300,480 480,615 615,750
we know people that work

2915
01:15:59,810 --> 01:16:00,640
0,180 180,315 315,435 435,570 570,830
there that can tell us,

2916
01:16:01,800 --> 01:16:02,780
0,230 230,410 410,635 635,785 785,980
you know, this is not

2917
01:16:02,780 --> 01:16:04,145
0,300 300,660 660,1020 1020,1245 1245,1365
something you as you know

2918
01:16:04,145 --> 01:16:06,110
0,165 165,455 685,1265 1375,1710 1710,1965
someone using sql, an application

2919
01:16:06,110 --> 01:16:07,400
0,320 580,870 870,1020 1020,1140 1140,1290
developer, you should know or

2920
01:16:07,400 --> 01:16:09,260
0,290 1270,1500 1500,1620 1620,1740 1740,1860
care, but it's nice to

2921
01:16:09,260 --> 01:16:10,760
0,90 90,350 460,860 1120,1380 1380,1500
know what sometimes how these

2922
01:16:10,760 --> 01:16:11,880
0,255 255,390 390,680
assessments are implemented.|
|

2923
01:16:14,030 --> 01:16:14,860
0,260 260,365 365,455 455,620 620,830
Nice thing about hash functions
散列函数的好处是，它会很快。在最好的情况下，它们将支持一个查找，但同样，我们需要能够确保我们可以。

2924
01:16:14,860 --> 01:16:16,300
0,255 255,465 465,570 570,860 1120,1440
again, it'll be fast. They'll

2925
01:16:16,300 --> 01:16:17,155
0,120 120,255 255,405 405,705 705,855
support o one lookup in

2926
01:16:17,155 --> 01:16:18,535
0,75 75,195 195,360 360,635 1105,1380
the best case scenario, but

2927
01:16:18,535 --> 01:16:19,045
0,135 135,240 240,360 360,465 465,510
again, we need to be

2928
01:16:19,045 --> 01:16:20,200
0,215 235,540 540,735 735,900 900,1155
able to make sure that

2929
01:16:20,200 --> 01:16:22,140
0,315 315,650
we can.|
|

2930
01:16:22,330 --> 01:16:23,690
0,230 230,320 320,455 455,730 960,1360
You know, we, we may
你知道，我们，我们可能需要有效地增长，如果我们估计错误的大小，我们将看到我们如何做这些估计稍后。

2931
01:16:23,710 --> 01:16:25,280
0,245 245,365 365,635 635,1220 1220,1570
need to grow efficiently if

2932
01:16:25,930 --> 01:16:27,680
0,400 480,755 755,890 890,1070 1070,1750
we estimate the size incorrectly,

2933
01:16:27,760 --> 01:16:28,910
0,245 245,410 410,635 635,875 875,1150
and we'll see how we

2934
01:16:28,960 --> 01:16:30,290
0,260 260,455 455,785 785,1025 1025,1330
do those estimations later on.|
|

2935
01:16:31,800 --> 01:16:33,815
0,400 720,1120 1140,1540 1560,1850 1850,2015
So some systems will give
所以有些系统会在你调用创建索引的时候给你哈希表，postgres会让你把这个postgresci叫做创建索引。你可以说使用哈希，你会得到一个哈希表。你会得到他们的线性哈希表植入，对不对？

2936
01:16:33,815 --> 01:16:34,850
0,150 150,420 420,660 660,885 885,1035
you hash table when you

2937
01:16:34,850 --> 01:16:36,755
0,195 195,450 450,800 1300,1785 1785,1905
call create index postgres will

2938
01:16:36,755 --> 01:16:37,670
0,120 120,225 225,315 315,480 480,915
let you do this postgresci

2939
01:16:37,670 --> 01:16:38,540
0,75 75,225 225,465 465,720 720,870
be called create index. You

2940
01:16:38,540 --> 01:16:39,905
0,75 75,210 210,450 450,980 1090,1365
can say using hash and

2941
01:16:39,905 --> 01:16:40,610
0,165 165,240 240,345 345,540 540,705
you'll get a hash table.

2942
01:16:40,610 --> 01:16:42,875
0,210 210,300 300,560 1630,1935 1935,2265
You'll get their their linear

2943
01:16:42,875 --> 01:16:45,120
0,195 195,315 315,875 1225,1625
hash table implantation, right?|
|

2944
01:16:45,120 --> 01:16:45,825
0,105 105,225 225,360 360,495 495,705
But this is not the
但这并不是默认的。

2945
01:16:45,825 --> 01:16:46,800
0,335
default.|
|

2946
01:16:46,910 --> 01:16:48,460
0,350 350,700 780,1055 1055,1265 1265,1550
For for almost all systems,
对于几乎所有的系统，当您调用时，创建索引。

2947
01:16:48,460 --> 01:16:49,860
0,350 430,675 675,825 825,1065 1065,1400
when you call, create index.|
|

2948
01:16:51,160 --> 01:16:52,720
0,260 260,395 395,545 545,820
They may know why.|
他们可能知道原因。|

2949
01:16:55,540 --> 01:16:57,255
0,305 305,530 530,940 960,1360 1440,1715
No range cans yes. The
没有范围可以。你唯一能做的就是哈希表的质量查找，你需要有整个键。

2950
01:16:57,255 --> 01:16:58,035
0,210 210,420 420,540 540,645 645,780
only thing you can do

2951
01:16:58,035 --> 01:16:58,935
0,120 120,225 225,450 450,675 675,900
with the hash table is

2952
01:16:58,935 --> 01:17:00,615
0,165 165,405 405,1025 1225,1500 1500,1680
the quality lookups and you

2953
01:17:00,615 --> 01:17:01,560
0,165 165,270 270,405 405,630 630,945
need to have the entire

2954
01:17:01,560 --> 01:17:02,600
0,380
key.|
|

2955
01:17:02,600 --> 01:17:03,785
0,380 400,690 690,900 900,1080 1080,1185
Right. If my key is
正确的。如果我的键在A列和B列，我可以做组合键。如果我没有人工智能，就没有B，我就不能查了。

2956
01:17:03,785 --> 01:17:06,845
0,245 2245,2550 2550,2715 2715,2850 2850,3060
on column a and column

2957
01:17:06,845 --> 01:17:08,015
0,300 300,540 540,645 645,795 795,1170
B I can do composite

2958
01:17:08,015 --> 01:17:09,485
0,275 595,855 855,1005 1005,1245 1245,1470
keys. If I don't have

2959
01:17:10,110 --> 01:17:11,060
0,245 245,365 365,470 470,710 710,950
AI, don't have B I

2960
01:17:11,060 --> 01:17:11,830
0,225 225,300 300,390 390,510 510,770
can't do a look up.|
|

2961
01:17:13,130 --> 01:17:14,110
0,260 260,395 395,575 575,785 785,980
In A B plus tree,
在A，B+树中，我们将在下一节课中讨论，你可以做这些前缀杯子，这是有史以来最好的数据结构。用于数据库。尝试实际上也很好，但您可以使用默认选择的尝试。这些系统将是A、B、Plus树。

2962
01:17:14,110 --> 01:17:15,510
0,150 150,500 550,870 870,1095 1095,1400
which we'll discuss next class,

2963
01:17:16,610 --> 01:17:17,875
0,305 305,515 515,695 695,860 860,1265
you can do these prefixel

2964
01:17:17,875 --> 01:17:19,000
0,365 445,705 705,825 825,975 975,1125
cups and it is the

2965
01:17:19,000 --> 01:17:19,975
0,165 165,405 405,675 675,840 840,975
best data structure of all

2966
01:17:19,975 --> 01:17:23,005
0,305 775,1035 1035,1655 2515,2835 2835,3030
time. For databases. Tries are

2967
01:17:23,005 --> 01:17:25,015
0,150 150,300 300,480 480,785 1735,2010
actually pretty good too, but

2968
01:17:25,015 --> 01:17:28,290
0,120 120,240 240,435 435,755 2875,3275
you can put tries of

2969
01:17:30,800 --> 01:17:32,410
0,365 365,650 650,935 935,1280 1280,1610
the default choice. Those systems

2970
01:17:32,410 --> 01:17:33,505
0,240 240,450 450,735 735,960 960,1095
are going be A B

2971
01:17:33,505 --> 01:17:34,500
0,180 180,485
plus tree.|
|

2972
01:17:34,500 --> 01:17:35,630
0,255 255,540 540,600 600,825 825,1130
And that's what we'll discuss
这就是我们下周要讨论的问题。但同样，我们将假设它是单线程的。

2973
01:17:36,010 --> 01:17:37,035
0,290 290,470 470,635 635,770 770,1025
next week. But again, we'll

2974
01:17:37,035 --> 01:17:38,840
0,225 225,450 450,660 660,1175
assume it's single threaded.|
|

2975
01:17:39,090 --> 01:17:40,265
0,320 320,640 720,965 965,1040 1040,1175
On monday and then on
周一和周三，我们将了解如何使其成为多线程的。

2976
01:17:40,265 --> 01:17:41,210
0,305 385,675 675,765 765,870 870,945
wednesday we'll see how to

2977
01:17:41,210 --> 01:17:43,680
0,105 105,380 550,885 885,1340
make it multi threaded.|
|

2978
01:17:44,330 --> 01:18:04,885
0,395 395,650 650,910 19680,19970 19970,20555
Alright hit it the motherfuck
好了，他妈的每克28克，这取决于它是不是你还没有打到暴徒，还没有让你闭嘴我用夹子的底部打你，告诉你，抬头告诉我，让我看看你的脸背后是什么，我有黑板敲打，我不能追踪那个舌头，就像大便，你不能在多米尼加人那里系花边，或者你得叫我多米尼加黑色的黑色黑色皮革黑胶木，我整个黑色肮脏的8号木头，把你送到普尔门，你得到你的瓦塔多去滑冰，这是你的第一个错误，我排队买蛋糕，你的等待，我的等待，直到活着。

2979
01:18:04,885 --> 01:18:06,630
0,270 270,575 685,1215 1215,1410 1410,1745
hook up 28 a gram

2980
01:18:06,710 --> 01:18:08,100
0,335 335,560 560,725 725,1040 1040,1390
depending on if it's up

2981
01:18:08,210 --> 01:18:09,160
0,260 260,485 485,605 605,755 755,950
you ain't hit the mob

2982
01:18:09,160 --> 01:18:10,495
0,320 460,765 765,960 960,1155 1155,1335
yet still got your shut

2983
01:18:10,495 --> 01:18:11,515
0,225 225,510 510,765 765,900 900,1020
up I smack you with

2984
01:18:11,515 --> 01:18:12,520
0,165 165,405 405,615 615,795 795,1005
the bottom of the clip

2985
01:18:12,520 --> 01:18:13,500
0,150 150,315 315,480 480,675 675,980
to tell you look up

2986
01:18:13,610 --> 01:18:14,500
0,290 290,440 440,545 545,680 680,890
show me what it sa

2987
01:18:14,500 --> 01:18:15,550
0,285 285,510 510,660 660,840 840,1050
at for a blow your

2988
01:18:15,550 --> 01:18:16,645
0,255 255,555 555,795 795,930 930,1095
face back I gotta a

2989
01:18:16,645 --> 01:18:18,310
0,480 480,780 780,1020 1020,1290 1290,1665
blackboard taps the f can't

2990
01:18:18,310 --> 01:18:20,155
0,225 225,1065 1065,1305 1305,1605 1605,1845
trace thatyllus like t for

2991
01:18:20,155 --> 01:18:21,355
0,270 270,510 510,825 825,1020 1020,1200
poop you can't lace that

2992
01:18:21,355 --> 01:18:22,840
0,150 150,300 300,1065 1065,1320 1320,1485
at the Dominican or you

2993
01:18:22,840 --> 01:18:24,595
0,255 255,510 510,675 675,1395 1395,1755
got call me Dominican black

2994
01:18:24,595 --> 01:18:26,320
0,420 420,675 675,1095 1095,1380 1380,1725
sclly black leather black sued

2995
01:18:26,320 --> 01:18:27,910
0,495 495,705 705,960 960,1275 1275,1590
timberins my whole black dirty

2996
01:18:27,910 --> 01:18:28,825
0,240 240,435 435,615 615,780 780,915
eight to send you to

2997
01:18:28,825 --> 01:18:30,160
0,150 150,420 420,785 925,1200 1200,1335
the pur gates you get

2998
01:18:30,160 --> 01:18:31,555
0,675 675,825 825,1020 1020,1185 1185,1395
youravatado to skate and that's

2999
01:18:31,555 --> 01:18:33,010
0,105 105,365 385,785 985,1275 1275,1455
your first mistake I in

3000
01:18:33,010 --> 01:18:34,140
0,255 255,465 465,630 630,840 840,1130
line for that cake your

3001
01:18:34,580 --> 01:18:36,870
0,400 480,880 1260,1580 1580,1895 1895,2290
wait my wait the through

3002
01:18:39,200 --> 01:18:44,620
0,400
living.|
|
