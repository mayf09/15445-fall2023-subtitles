1
00:00:31,750 --> 00:00:36,560
0,400 2370,2705 2705,2950
{} How's life?|
生活怎么样？|

2
00:00:36,780 --> 00:00:38,600
0,260 260,365 365,470 470,730 1440,1820

3
00:00:38,600 --> 00:00:40,000
0,210 210,315 315,495 495,1050 1050,1400

4
00:00:40,230 --> 00:00:42,320
0,320 320,560 560,880 1200,1600 1770,2090

5
00:00:42,320 --> 00:00:43,955
0,225 225,530 580,980 1060,1350 1350,1635
{ - -} I mean,
我的意思是，是的，所有的 Wu-Tang Clan 都很年轻，

6
00:00:43,955 --> 00:00:45,310
0,315 315,585 585,855 855,1065 1065,1355
yeah, all the Wu-Tang Clan

7
00:00:45,330 --> 00:00:49,300
0,290 290,545 545,3320 3320,3575 3575,3970
pretty young.| { - -}
|

8
00:00:49,740 --> 00:00:52,295
0,400 720,1120 1500,2080 2190,2450 2450,2555
{ - -},| that was
|这是一种[]， Wu-Tang 。

9
00:00:52,295 --> 00:00:55,980
0,105 105,225 225,635 1945,2345
kind of [], Wu-Tang.|
|

10
00:00:55,990 --> 00:00:56,910
0,290 290,395 395,560 560,710 710,920
There's no {Wu-Tang -} questions
今年的考试没有 Wu-Tang 的问题，

11
00:00:56,910 --> 00:00:58,010
0,165 165,285 285,555 555,825 825,1100
on the exam this year,|
|

12
00:00:58,150 --> 00:00:59,085
0,305 305,545 545,635 635,740 740,935
previous year {} have been,|
之前的年份有，|

13
00:00:59,085 --> 00:01:00,345
0,335 505,825 825,900 900,1080 1080,1260
so don't feel like you
所以不要感觉你需要知道这些事情。

14
00:01:00,345 --> 00:01:01,005
0,105 105,195 195,285 285,405 405,660
need to know these things.|
|

15
00:01:01,005 --> 00:01:03,570
0,395 445,845 1135,1455 1455,1775 2305,2565
{All,right}, again awesome, {} {2PL
好的，太棒了， 2PL 。

16
00:01:03,570 --> 00:01:06,765
0,260 1960,2205 2205,2450 2770,3060 3060,3195
-}.| You guys, lot to
|你们有很多事要做，

17
00:01:06,765 --> 00:01:07,980
0,105 105,365 775,1005 1005,1095 1095,1215
go over,| the list is
|列表越来越长。

18
00:01:07,980 --> 00:01:09,330
0,165 165,470 640,900 900,1095 1095,1350
getting longer.| So project #1
|所以项目 #1 在本周日午夜截止，

19
00:01:09,330 --> 00:01:11,510
0,255 255,590 700,1100 1180,1580 1780,2180
is due this Sunday at

20
00:01:11,530 --> 00:01:13,110
0,400 690,935 935,1070 1070,1250 1250,1580
midnight,| again, we're having special
|再次，我们周六有特别的办公时间，是面对面的，

21
00:01:13,110 --> 00:01:15,050
0,225 225,470 670,1070 1120,1520 1540,1940
office hours on, on Saturday,

22
00:01:15,340 --> 00:01:17,565
0,365 365,515 515,820 1770,2060 2060,2225
that's in person,| they announced
|他们在 Piazza 上宣布了这个消息，

23
00:01:17,565 --> 00:01:18,300
0,120 120,240 240,570 570,660 660,735
it on Piazza,| I think
|我想是在五楼，

24
00:01:18,300 --> 00:01:19,190
0,105 105,165 165,315 315,555 555,890
it's on the fifth floor|
|

25
00:01:20,230 --> 00:01:21,320
0,260 260,350 350,410 410,530 530,1090
and one to make [].|
一个是给[]。|

26
00:01:21,460 --> 00:01:22,635
0,365 365,635 635,830 830,935 935,1175
Homework #2, it's been bumped
家庭作业 #2 被推迟到了 10 月 4 日，星期三，

27
00:01:22,635 --> 00:01:25,365
0,225 225,605 1465,1785 1785,2105 2455,2730
out to October 4th, so

28
00:01:25,365 --> 00:01:27,840
0,275 1105,1395 1395,1685 1975,2340 2340,2475
Wednesday,| make sure made not
|确保截止日期和项目 #1 不同。

29
00:01:27,840 --> 00:01:28,545
0,165 165,300 300,405 405,540 540,705
have be the same due

30
00:01:28,545 --> 00:01:30,510
0,180 180,450 450,765 765,1115 1585,1965
date as project #1.| Homework
|作业 #3 将在本周发布，

31
00:01:30,510 --> 00:01:31,320
0,270 270,405 405,480 480,600 600,810
#3 will be out this

32
00:01:31,320 --> 00:01:32,415
0,320 370,735 735,825 825,915 915,1095
week,| that's {will -} due
|截止日期是四天以后。

33
00:01:32,415 --> 00:01:33,800
0,210 210,420 420,755
four days later.|
|

34
00:01:33,810 --> 00:01:34,760
0,275 275,485 485,710 710,845 845,950
And again, that kind of
再次，这很糟糕，

35
00:01:34,760 --> 00:01:35,495
0,225 225,315 315,465 465,615 615,735
sucks,| that it kind of
|这么快就把它塞进去了，

36
00:01:35,495 --> 00:01:36,460
0,150 150,255 255,375 375,600 600,965
cram it so quickly,| but
|但是因为期中考试，

37
00:01:36,510 --> 00:01:38,390
0,400 780,1025 1025,1370 1370,1670 1670,1880
because the midterm exam,| which
|它将涵盖家庭作业 #3 的内容，

38
00:01:38,390 --> 00:01:41,000
0,165 165,470 550,950
will cover things,

39
00:01:41,640 --> 00:01:42,650
0,290 290,425 425,635 635,815 815,1010
will cover things that in

40
00:01:42,650 --> 00:01:44,150
0,255 255,555 555,920 1120,1380 1380,1500
in homework #3,| we want
|我们想把它带回给你们，并评分，

41
00:01:44,150 --> 00:01:45,620
0,90 90,225 225,530 1030,1335 1335,1470
to get that back to

42
00:01:45,620 --> 00:01:47,460
0,75 75,300 300,570 570,1070
you guys and graded,|
|

43
00:01:47,460 --> 00:01:49,080
0,350 520,885 885,1125 1125,1425 1425,1620
before the the midterm exam
在星期三的期中考试之前。

44
00:01:49,080 --> 00:01:51,140
0,255 255,525 525,830 1180,1580 1660,2060
on on Wednesday.| So midterm,
|所以期中考试将在 10 月 11 日在这里，

45
00:01:51,460 --> 00:01:52,650
0,455 455,605 605,740 740,935 935,1190
midterm it be in class

46
00:01:52,650 --> 00:01:54,645
0,350 880,1215 1215,1485 1485,1830 1830,1995
here on October 11th,| it's
|它是星期三，在正常的上课时间，

47
00:01:54,645 --> 00:01:56,115
0,60 60,305 625,1025 1075,1350 1350,1470
a wednesday and during the

48
00:01:56,115 --> 00:01:58,170
0,165 165,405 405,725 1615,1905 1905,2055
regular class time,| if you
|如果你需要住宿，请给我们发邮件，

49
00:01:58,170 --> 00:01:59,840
0,180 180,710 790,1170 1170,1410 1410,1670
need accommodations, please email us|
|

50
00:01:59,860 --> 00:02:01,550
0,260 260,395 395,670 690,1090 1290,1690
and so we can start
这样我们就可以开始组织和照顾后勤，

51
00:02:01,690 --> 00:02:03,150
0,440 440,790 1020,1295 1295,1400 1400,1460
organizing and taking care of

52
00:02:03,150 --> 00:02:05,000
0,75 75,1095 1095,1245 1245,1380 1380,1850
the logistics,| {don't,post} on Piazza.|
|不要贴在 Piazza 上。|

53
00:02:08,860 --> 00:02:09,465
0,275 275,335 335,395 395,455 455,605
We're trying to get homework
我们现在正试着把作业 #3 放出来，

54
00:02:09,465 --> 00:02:11,145
0,180 180,360 360,665 1195,1515 1515,1680
#3 out now,| it should
|今天应该就能出来了，

55
00:02:11,145 --> 00:02:11,925
0,75 75,195 195,465 465,675 675,780
be out today,| I don't
|我不知道今天会不会放出。

56
00:02:11,925 --> 00:02:12,240
0,30 30,60 60,135 135,225 225,315
know if it be out

57
00:02:12,240 --> 00:02:14,120
0,260 760,1160 1240,1560 1560,1635 1635,1880
today.| Yes, that's the plan,|
|是的，这就是计划，|

58
00:02:14,710 --> 00:02:15,405
0,245 245,335 335,455 455,575 575,695
but the trouble is like,
但问题是，它并不包括，

59
00:02:15,405 --> 00:02:16,545
0,120 120,345 345,570 570,855 855,1140
it doesn't cover things,| it's
|它不包括排序和 Join ，

60
00:02:16,545 --> 00:02:17,865
0,75 75,150 150,395 415,995 1015,1320
{doesn't -} cover sorting and

61
00:02:17,865 --> 00:02:19,125
0,390 390,510 510,645 645,875 985,1260
Joins,| which I'll cover next
|我将在下周介绍。

62
00:02:19,125 --> 00:02:21,260
0,275
week.|
|

63
00:02:21,660 --> 00:02:23,075
0,275 275,455 455,760 1020,1295 1295,1415
Any questions about any of
对这些东西有什么问题吗？

64
00:02:23,075 --> 00:02:24,200
0,135 135,425
these things?|
|

65
00:02:24,720 --> 00:02:26,320
0,400
Yes.|
是的。|

66
00:02:30,450 --> 00:02:31,130
0,245 245,335 335,440 440,560 560,680
Whatever it says on the
现在网站上的任何内容都是当前的计划，是的。

67
00:02:31,130 --> 00:02:33,200
0,255 255,650 1510,1800 1800,1935 1935,2070
website now is the current

68
00:02:33,200 --> 00:02:34,600
0,290 340,740
plan, yes.|
|

69
00:02:34,970 --> 00:02:36,680
0,400
Yes.|
是的。|

70
00:02:41,580 --> 00:02:42,350
0,260 260,380 380,500 500,620 620,770
At the end of fall
在秋假结束时，

71
00:02:42,350 --> 00:02:45,880
0,290 940,1340 2830,3120 3120,3270 3270,3530
break,| we double check that,|
|我们会仔细检查这个，|

72
00:02:46,140 --> 00:02:47,050
0,260 260,380 380,500 500,635 635,910
I thought we moved it,|
我以为我们把它移走了，|

73
00:02:47,070 --> 00:02:47,860
0,230 230,305 305,455 455,530 530,790
so we didn't have {to,do}
这样我们就不用在秋假做了，

74
00:02:48,840 --> 00:02:50,060
0,260 260,520 780,1025 1025,1115 1115,1220
fall break,| we will take
|我们会处理好的。

75
00:02:50,060 --> 00:02:50,920
0,105 105,195 195,440
care of that.|
|

76
00:02:51,650 --> 00:02:53,100
0,305 305,610
Other questions?|
还有其他问题吗？|

77
00:02:55,420 --> 00:02:56,740
0,230 230,380 380,700
All right, cool.|
好的，酷。|

78
00:02:57,140 --> 00:02:58,680
0,245 245,410 410,730
All right, so,|
好的，那么，|

79
00:02:58,680 --> 00:02:59,925
0,290 340,585 585,750 750,960 960,1245
the the last two classes
最后两节课，我们讨论了数据结构，

80
00:02:59,925 --> 00:03:01,395
0,360 360,555 555,900 900,1215 1215,1470
we've talked about data structures,|
|

81
00:03:01,395 --> 00:03:02,390
0,195 195,345 345,510 510,735 735,995
we talked about hash tables|
我们讨论了哈希表，|

82
00:03:02,410 --> 00:03:03,030
0,245 245,320 320,395 395,500 500,620
and then we talked about
然后我们讨论了 B+ 树，

83
00:03:03,030 --> 00:03:05,420
0,135 135,315 315,620 940,1340 1990,2390
{B+ -} trees,| {} and
|我之前说过，

84
00:03:05,920 --> 00:03:07,530
0,335 335,680 680,830 830,1120 1290,1610
I prefaced our conversation| going
|在开始讨论哈希表和 B+ 树时，

85
00:03:07,530 --> 00:03:09,075
0,315 315,710 730,975 975,1275 1275,1545
into discussing the {hash,table} B+

86
00:03:09,075 --> 00:03:10,430
0,255 255,630 630,900 900,1065 1065,1355
trees stuff,| to say that
|为了简化讨论，

87
00:03:10,930 --> 00:03:14,120
0,400 450,1180 1980,2360 2360,2740 2790,3190
to simplify the discussion| and,
|以及对这些数据结构和算法的解释，

88
00:03:14,200 --> 00:03:16,410
0,290 290,580 1140,1460 1460,1780 1920,2210
and the, the explanation of

89
00:03:16,410 --> 00:03:17,445
0,165 165,375 375,645 645,840 840,1035
these data structures and the

90
00:03:17,445 --> 00:03:18,530
0,285 285,375 375,435 435,665 685,1085
algorithms,| that are used to
|那些用于操作它们或使用它们的，

91
00:03:18,820 --> 00:03:20,745
0,400 960,1505 1505,1670 1670,1805 1805,1925
to manipulate them or work

92
00:03:20,745 --> 00:03:22,080
0,135 135,395 925,1230 1230,1260 1260,1335
with them,| we're going to
|我们假设它是单线程的，

93
00:03:22,080 --> 00:03:23,120
0,120 120,225 225,390 390,570 570,1040
assume that it's single threaded,|
|

94
00:03:23,740 --> 00:03:24,990
0,320 320,530 530,695 695,970 990,1250
because that just makes your
因为这只会让你的生活更轻松，

95
00:03:24,990 --> 00:03:27,150
0,135 135,410 910,1310 1840,2085 2085,2160
life easier,| {} but of
|但是当然，在任何现代系统中，

96
00:03:27,150 --> 00:03:28,490
0,135 135,330 330,570 570,920 940,1340
course, in any modern system,|
|

97
00:03:29,140 --> 00:03:31,830
0,400 1290,1715 1715,1960 2340,2585 2585,2690
in today's hardware,| you need
在今天的硬件中，|你需要支持多个线程或多个 worker 同时运行，

98
00:03:31,830 --> 00:03:33,015
0,150 150,345 345,650 730,1110 1110,1185
to support multiple threads or

99
00:03:33,015 --> 00:03:34,320
0,210 210,575 775,1080 1080,1215 1215,1305
multiple workers running at the

100
00:03:34,320 --> 00:03:35,565
0,180 180,500 850,1080 1080,1215 1215,1245
same time,| again, I'm going
|同样，我将尝试使用 worker 一词，

101
00:03:35,565 --> 00:03:36,030
0,75 75,180 180,270 270,375 375,465
to try to use the

102
00:03:36,030 --> 00:03:37,140
0,120 120,410 550,810 810,960 960,1110
word workers,| because that can
|因为它可以表示线程或进程，

103
00:03:37,140 --> 00:03:38,025
0,180 180,390 390,555 555,705 705,885
mean either a thread or

104
00:03:38,025 --> 00:03:39,690
0,305 715,1185 1185,1320 1320,1455 1455,1665
process,| Postgres is not multi
|Postgres 不是多线程，而是多进程，

105
00:03:39,690 --> 00:03:41,480
0,225 225,390 390,540 540,860 1390,1790
thread, it's multi process,| most
|大多数现代系统都是多线程的，

106
00:03:41,560 --> 00:03:42,810
0,365 365,635 635,785 785,950 950,1250
modern systems are multi threaded,|
|

107
00:03:42,810 --> 00:03:43,485
0,150 150,285 285,420 420,570 570,675
but the idea is the
但理念是一样的。

108
00:03:43,485 --> 00:03:44,895
0,245 655,930 930,1095 1095,1260 1260,1410
same.| But still again we
|不过，我们还是希望能够让多个 worker 同时运行，

109
00:03:44,895 --> 00:03:45,375
0,135 135,240 240,300 300,375 375,480
want to be able to

110
00:03:45,375 --> 00:03:47,760
0,240 240,635 1255,1655 1915,2220 2220,2385
have multiple workers running at

111
00:03:47,760 --> 00:03:48,630
0,120 120,300 300,585 585,780 780,870
the same time| be able
|能够访问这些数据结构，

112
00:03:48,630 --> 00:03:49,910
0,255 255,540 540,720 720,945 945,1280
to access these data structures,|
|

113
00:03:50,710 --> 00:03:52,545
0,320 320,640 1080,1460 1460,1715 1715,1835
so that if one of
这样，如果其中一个必须停顿，

114
00:03:52,545 --> 00:03:53,930
0,105 105,270 270,510 510,845 985,1385
them has to stall,| because
|因为它们要访问磁盘，

115
00:03:53,950 --> 00:03:54,975
0,320 320,440 440,605 605,935 935,1025
they're going to disk,| we
|我们可以让其他 worker 同时运行，

116
00:03:54,975 --> 00:03:56,490
0,120 120,285 285,575 925,1290 1290,1515
can have other workers run

117
00:03:56,490 --> 00:03:57,285
0,105 105,195 195,330 330,570 570,795
at the same time| and
|并做一些有用的事情。

118
00:03:57,285 --> 00:03:58,620
0,240 240,540 540,875
do useful things,

119
00:03:58,890 --> 00:04:00,530
0,400 930,1220 1220,1400 1400,1535 1535,1640
right.| {} System will look
|系统将看起来非常迟钝，

120
00:04:00,530 --> 00:04:01,715
0,150 150,795 795,960 960,1065 1065,1185
very unresponsive,| if you only
|如果你只有一个 worker ，

121
00:04:01,715 --> 00:04:03,620
0,120 120,225 225,485 535,935 1525,1905
have a single worker,| again,
|再次，假设它是一个线程，

122
00:04:03,620 --> 00:04:04,895
0,240 240,390 390,510 510,800 1000,1275
assume it's a thread| and
|然后我将运行一些查询，

123
00:04:04,895 --> 00:04:06,430
0,275 295,615 615,690 690,935 1135,1535
then I'm going to go

124
00:04:06,840 --> 00:04:08,045
0,275 275,410 410,700 840,1100 1100,1205
run some query,| and then
|然后当我必须去我的页表时，

125
00:04:08,045 --> 00:04:08,645
0,90 90,180 180,285 285,420 420,600
as soon as I have

126
00:04:08,645 --> 00:04:09,590
0,285 285,510 510,630 630,795 795,945
to go my page table,|
|

127
00:04:09,590 --> 00:04:10,100
0,90 90,165 165,270 270,360 360,510
and the thing I don't
我不需要的东西是，

128
00:04:10,100 --> 00:04:11,345
0,195 195,560 730,990 990,1125 1125,1245
need is,| the page I
|我需要的页面不在那里，

129
00:04:11,345 --> 00:04:12,455
0,135 135,375 375,635 775,1020 1020,1110
need isn't there,| I have
|我必须停顿，

130
00:04:12,455 --> 00:04:13,160
0,135 135,360 360,540 540,630 630,705
to stall,| because I got
|因为我必须去磁盘上获取它。

131
00:04:13,160 --> 00:04:13,640
0,60 60,135 135,225 225,390 390,480
to go to disk and

132
00:04:13,640 --> 00:04:14,640
0,135 135,410
get it.|
|

133
00:04:14,640 --> 00:04:16,230
0,165 165,440 580,870 870,1095 1095,1590
While, {} while we're stalled,|
当我们停滞不前时，|

134
00:04:16,230 --> 00:04:17,385
0,240 240,435 435,585 585,795 795,1155
the {CPU -} essentially stalled,|
CPU 基本上也停滞不前了，|

135
00:04:17,385 --> 00:04:18,450
0,120 120,225 225,405 405,720 720,1065
we can have other threads,
我们可以让其他线程，其他 worker 做有用的事情。

136
00:04:18,450 --> 00:04:19,580
0,150 150,390 390,600 600,795 795,1130
other workers do useful things.|
|

137
00:04:20,020 --> 00:04:21,165
0,245 245,455 455,560 560,800 800,1145
So that's the goal of
这就是我们今天要讨论的目标，

138
00:04:21,165 --> 00:04:22,080
0,365 505,735 735,840 840,870 870,915
of what we're going to

139
00:04:22,080 --> 00:04:22,725
0,75 75,195 195,360 360,525 525,645
talk about today| is how
|就是我们如何真正使这些数据结构线程安全。

140
00:04:22,725 --> 00:04:23,420
0,60 60,150 150,270 270,405 405,695
do we actually make these

141
00:04:23,890 --> 00:04:26,220
0,320 320,640 1140,1445 1445,1750
data structures thread safe.|
|

142
00:04:26,590 --> 00:04:27,390
0,260 260,410 410,545 545,710 710,800
And so what I'll say
所以我要说的是，

143
00:04:27,390 --> 00:04:28,440
0,120 120,380 550,780 780,855 855,1050
is that,| this is how
|这就是大多数系统将会实现的，

144
00:04:28,440 --> 00:04:29,460
0,330 330,675 675,885 885,960 960,1020
most systems are going to

145
00:04:29,460 --> 00:04:31,730
0,210 210,590 1060,1350 1350,1640 1870,2270
be implemented,| most systems will
|大多数系统都会尝试利用多线程，

146
00:04:31,840 --> 00:04:32,700
0,245 245,335 335,470 470,680 680,860
try to take advantage of

147
00:04:32,700 --> 00:04:35,565
0,240 240,800 1750,2240 2320,2715 2715,2865
multiple threads,| there, there's sort
|有一种[分类]系统，

148
00:04:35,565 --> 00:04:37,125
0,135 135,425 595,990 990,1335 1335,1560
of category systems,| that actually
|不会做我们今天所说的任何事情，

149
00:04:37,125 --> 00:04:37,860
0,240 240,345 345,495 495,630 630,735
don't do any of the

150
00:04:37,860 --> 00:04:38,720
0,165 165,360 360,450 450,585 585,860
things we're talking about today,|
|

151
00:04:39,490 --> 00:04:40,305
0,245 245,350 350,485 485,665 665,815
and the most famous one
最著名的是 Redis ，

152
00:04:40,305 --> 00:04:41,775
0,105 105,270 270,695 955,1260 1260,1470
is {} Redis,| that it's
|它是一个单进程、单线程，

153
00:04:41,775 --> 00:04:43,250
0,105 105,345 345,695 745,1110 1110,1475
a single process, single thread,|
|

154
00:04:43,510 --> 00:04:44,640
0,260 260,410 410,575 575,980 980,1130
so all the latching stuff
所以我们今天要讨论的所有锁的东西，

155
00:04:44,640 --> 00:04:45,090
0,135 135,165 165,225 225,330 330,450
we're going to talk about

156
00:04:45,090 --> 00:04:46,050
0,260 310,570 570,750 750,840 840,960
today,| they don't have to
|他们都不需要做，

157
00:04:46,050 --> 00:04:47,020
0,260
do,|
|

158
00:04:47,020 --> 00:04:48,220
0,380 400,675 675,885 885,1065 1065,1200
because they know no other
因为它们不知道没有其他线程同时运行。

159
00:04:48,220 --> 00:04:48,880
0,225 225,330 330,420 420,510 510,660
threads running at the same

160
00:04:48,880 --> 00:04:49,780
0,290
time.|
|

161
00:04:50,390 --> 00:04:51,745
0,275 275,365 365,605 605,970 1050,1355
There'll be other systems they
还会有其他系统，它们有，

162
00:04:51,745 --> 00:04:53,905
0,245 1315,1665 1665,1785 1785,1920 1920,2160
have,| they'll still be multi
|它们仍然是多线程的，

163
00:04:53,905 --> 00:04:55,320
0,405 405,600 600,855 855,1080 1080,1415
threaded,| but they'll maybe have
|但它们可能只有一个写线程，

164
00:04:55,670 --> 00:04:57,250
0,350 350,605 605,890 890,1270 1290,1580
only one writer thread,| but
|但是有多个读线程同时运行，

165
00:04:57,250 --> 00:04:58,510
0,255 255,585 585,990 990,1155 1155,1260
multiple reader threads running at

166
00:04:58,510 --> 00:04:59,260
0,75 75,210 210,435 435,600 600,750
the same time,| and that
|这简化了很多事情，

167
00:04:59,260 --> 00:05:00,240
0,390 390,510 510,600 600,720 720,980
simplifies a bunch of things,|
|

168
00:05:00,470 --> 00:05:01,300
0,260 260,410 410,575 575,710 710,830
but you still need the
但你仍然需要我们今天要讨论的锁保护。

169
00:05:01,300 --> 00:05:02,470
0,390 390,795 795,975 975,1125 1125,1170
latching protections that we're going

170
00:05:02,470 --> 00:05:04,540
0,90 90,240 240,420 420,710
to talk about today.|
|

171
00:05:06,300 --> 00:05:08,195
0,260 260,410 410,700 1440,1730 1730,1895
So that the, the thing
所以，我们将使用的东西，

172
00:05:08,195 --> 00:05:08,830
0,105 105,210 210,255 255,360 360,635
that we're going to use|
|

173
00:05:08,880 --> 00:05:12,605
0,335 335,670 1350,1750 1830,2230 3300,3725
to, to enforce the threads
强制线程或 worker 以特定方式运行，

174
00:05:12,605 --> 00:05:13,595
0,120 120,360 360,570 570,825 825,990
or workers to behave a

175
00:05:13,595 --> 00:05:15,290
0,225 225,575 1135,1380 1380,1515 1515,1695
certain way,| so that we
|这样我们最终就不会出现损坏的数据和无效的数据结构，

176
00:05:15,290 --> 00:05:17,465
0,255 255,405 405,645 645,980 1720,2175
don't end up with corrupted

177
00:05:17,465 --> 00:05:18,790
0,210 210,435 435,810 810,990 990,1325
data and invalid data structures|
|

178
00:05:19,200 --> 00:05:19,835
0,275 275,365 365,410 410,500 500,635
is going to be called
将被称为并发控制协议。

179
00:05:19,835 --> 00:05:21,040
0,120 120,495 495,600 600,675 675,1205
a concurrent {control -} protocol.|
|

180
00:05:21,950 --> 00:05:23,140
0,350 350,605 605,755 755,1040 1040,1190
And again, for today's class,|
再次，在今天的课上，|

181
00:05:23,140 --> 00:05:23,680
0,165 165,195 195,270 270,405 405,540
we're going to see how
我们将看到我们如何为 worker 做这件事，

182
00:05:23,680 --> 00:05:24,900
0,260 400,660 660,795 795,945 945,1220
we do this for workers,|
|

183
00:05:25,550 --> 00:05:26,725
0,320 320,470 470,740 740,980 980,1175
after the midterm,| we'll discuss
期中考试结束后，|我们将讨论如何使用并发控制来协调事务。

184
00:05:26,725 --> 00:05:27,990
0,120 120,210 210,330 330,725 865,1265
how we use {concurrcncy,control} to,

185
00:05:29,000 --> 00:05:31,380
0,400 480,980 980,1300
to coordinate transactions.|
|

186
00:05:31,770 --> 00:05:32,405
0,275 275,380 380,440 440,530 530,635
And so you can sort
所以你可以这样想，

187
00:05:32,405 --> 00:05:33,020
0,105 105,210 210,300 300,435 435,615
of think of this,| this
|这种并发控制协议就像系统的交通警察，

188
00:05:33,020 --> 00:05:34,310
0,210 210,405 405,840 840,1080 1080,1290
concurrency control protocol is like

189
00:05:34,310 --> 00:05:35,270
0,150 150,375 375,645 645,810 810,960
the traffic cop of the

190
00:05:35,270 --> 00:05:37,325
0,290 700,1100 1360,1695 1695,1890 1890,2055
system,| that allows you to
|允许告诉不同的 worker ，

191
00:05:37,325 --> 00:05:39,845
0,305 415,815 835,1230 1230,1625 2065,2520
tell, tell different workers,| who's
|谁被允许在给定的时间做什么。

192
00:05:39,845 --> 00:05:41,105
0,120 120,240 240,390 390,695 955,1260
allowed to do what at

193
00:05:41,105 --> 00:05:42,620
0,195 195,435 435,785
what given time,

194
00:05:43,270 --> 00:05:44,805
0,400 930,1190 1190,1340 1340,1460 1460,1535
right.| And the idea is
|我们的想法是，

195
00:05:44,805 --> 00:05:45,225
0,60 60,165 165,210 210,255 255,420
that,| they're going to be
|它们将在某个共享对象或某个临界区上操作，

196
00:05:45,225 --> 00:05:46,350
0,225 225,390 390,600 600,900 900,1125
operating on some shared object

197
00:05:46,350 --> 00:05:47,310
0,120 120,255 255,480 480,780 780,960
or some critical section,| and
|我们不想让它们相互干扰并造成问题。

198
00:05:47,310 --> 00:05:47,955
0,90 90,315 315,405 405,510 510,645
we don't want to have

199
00:05:47,955 --> 00:05:48,825
0,135 135,465 465,555 555,645 645,870
them interfere with each other

200
00:05:48,825 --> 00:05:50,340
0,270 270,480 480,785
and cause problems.|
|

201
00:05:50,760 --> 00:05:51,920
0,365 365,665 665,875 875,1025 1025,1160
And the, the two types
你可能会遇到的两种问题是逻辑正确性和物理正确性，

202
00:05:51,920 --> 00:05:52,670
0,120 120,285 285,420 420,510 510,750
of problems you could have

203
00:05:52,670 --> 00:05:54,830
0,380 880,1410 1410,1770 1770,1905 1905,2160
are logical correctness and physical

204
00:05:54,830 --> 00:05:55,670
0,450 450,540 540,630 630,735 735,840
correctness,| and I think I
|我想我上周也提到过这个。

205
00:05:55,670 --> 00:05:57,875
0,180 180,500 1420,1725 1725,1980 1980,2205
mentioned this last week as

206
00:05:57,875 --> 00:05:59,765
0,275 625,945 945,1155 1155,1560 1560,1890
well.| So the logical correctness,
|所以逻辑正确性的想法是，

207
00:05:59,765 --> 00:06:01,430
0,195 195,390 390,540 540,815 1345,1665
the idea is that,| if
|如果我把一个键插入到我的 B+ 树中，

208
00:06:01,430 --> 00:06:03,410
0,320 730,1275 1275,1425 1425,1680 1680,1980
I insert a key into

209
00:06:03,410 --> 00:06:04,445
0,195 195,360 360,570 570,825 825,1035
my {B+ -} tree,| I
|我插入键 5 ，

210
00:06:04,445 --> 00:06:06,245
0,300 300,510 510,815 1375,1650 1650,1800
insert key 5| and then
|然后如果我回来，试着查找键 5 ，

211
00:06:06,245 --> 00:06:06,845
0,120 120,225 225,360 360,495 495,600
if I come back and

212
00:06:06,845 --> 00:06:07,595
0,180 180,360 360,450 450,585 585,750
I try to look for

213
00:06:07,595 --> 00:06:09,095
0,165 165,455 745,1065 1065,1320 1320,1500
key 5,| I should see
|我应该会看到它。

214
00:06:09,095 --> 00:06:09,740
0,245
it.|
|

215
00:06:10,160 --> 00:06:10,885
0,260 260,335 335,440 440,590 590,725
Well, the other example I
好的，我说的另一个例子是，

216
00:06:10,885 --> 00:06:12,685
0,135 135,395 1075,1350 1350,1560 1560,1800
said was,| if I delete
|如果我删除键 5 ，

217
00:06:12,685 --> 00:06:13,960
0,210 210,515 805,1050 1050,1155 1155,1275
key 5| and I come
|然后我回来尝试查找键 5 ，

218
00:06:13,960 --> 00:06:14,485
0,120 120,225 225,315 315,405 405,525
back and try to look

219
00:06:14,485 --> 00:06:15,220
0,120 120,240 240,405 405,570 570,735
for key 5,| again, I
|我应该看不到它。

220
00:06:15,220 --> 00:06:16,420
0,315 315,435 435,680
shouldn't see it,

221
00:06:16,460 --> 00:06:17,605
0,290 290,455 455,590 590,725 725,1145
right.| So, at a logical
|所以，在逻辑层面上，

222
00:06:17,605 --> 00:06:18,835
0,225 225,575 775,1050 1050,1170 1170,1230
level,| that we want to
|我们希望确保，

223
00:06:18,835 --> 00:06:20,020
0,90 90,210 210,300 300,975 975,1185
make sure that,| we're seeing
|我们看到的是我们应该在数据结构中看到的东西。

224
00:06:20,020 --> 00:06:20,950
0,165 165,300 300,480 480,690 690,930
the things we should see

225
00:06:20,950 --> 00:06:22,460
0,180 180,300 300,480 480,800
in our data structures.|
|

226
00:06:22,590 --> 00:06:23,420
0,275 275,425 425,545 545,665 665,830
The thing that we care
我们在今天的课程中关心的是物理正确性，

227
00:06:23,420 --> 00:06:24,770
0,255 255,510 510,870 870,1095 1095,1350
about in today's class is

228
00:06:24,770 --> 00:06:26,975
0,150 150,405 405,980 1270,1670 1930,2205
the physical correctness,| meaning how
|这意味着我们如何确保，

229
00:06:26,975 --> 00:06:28,880
0,120 120,360 360,705 705,1055 1555,1905
do we ensure that,| if
|如果我们遍历哈希表或遍历 B+ 树，

230
00:06:28,880 --> 00:06:30,455
0,530 640,1005 1005,1230 1230,1335 1335,1575
we're walking through a hash

231
00:06:30,455 --> 00:06:31,610
0,240 240,495 495,900 900,1005 1005,1155
table or traversing the {B+

232
00:06:31,610 --> 00:06:33,200
0,210 210,530 850,1200 1200,1425 1425,1590
-} tree| and at some
|在某些点上，我们必须跟随指针，

233
00:06:33,200 --> 00:06:33,770
0,150 150,285 285,345 345,435 435,570
point, we've got to follow

234
00:06:33,770 --> 00:06:34,805
0,165 165,525 525,765 765,930 930,1035
a pointer,| like like a
|比如页面 ID ，

235
00:06:34,805 --> 00:06:35,630
0,150 150,375 375,585 585,705 705,825
page ID| to take us
|将我们带到其他地方，

236
00:06:35,630 --> 00:06:37,175
0,180 180,500 760,1065 1065,1260 1260,1545
somewhere else,| that page ID
|那个页面 ID 是正确的，

237
00:06:37,175 --> 00:06:38,540
0,375 375,705 705,1020 1020,1230 1230,1365
is is correct,| like it's
|比如它不会把我们带到一个有一堆垃圾的表页。

238
00:06:38,540 --> 00:06:39,065
0,75 75,150 150,225 225,345 345,525
not going to take us

239
00:06:39,065 --> 00:06:41,105
0,305 1405,1650 1650,1725 1725,1830 1830,2040
to, you know, a table

240
00:06:41,105 --> 00:06:41,795
0,255 255,435 435,540 540,615 615,690
page that has a bunch

241
00:06:41,795 --> 00:06:42,780
0,90 90,330 330,435 435,695
of garbage in it.|
|

242
00:06:43,890 --> 00:06:44,810
0,260 260,380 380,560 560,770 770,920
Because what happens if if
因为如果跟随一个页面，

243
00:06:44,810 --> 00:06:45,790
0,210 210,435 435,585 585,720 720,980
you go follow a page|
|

244
00:06:45,930 --> 00:06:47,110
0,290 290,455 455,650 650,875 875,1180
and you start looking at
并开始查看这些看起来并不像你希望看到的数据，

245
00:06:47,190 --> 00:06:48,515
0,350 350,700 720,1100 1100,1205 1205,1325
data, that doesn't look like

246
00:06:48,515 --> 00:06:49,300
0,150 150,285 285,390 390,510 510,785
you expect to look like,|
|

247
00:06:49,590 --> 00:06:50,195
0,275 275,320 320,380 380,470 470,605
you're going to have a
那样会出现段错误，

248
00:06:50,195 --> 00:06:50,825
0,180 180,375 375,495 495,600 600,630
seg fault,| because you're going
|因为你要尝试读取一些过去的缓冲区，

249
00:06:50,825 --> 00:06:51,770
0,105 105,240 240,330 330,575 655,945
to try to read past

250
00:06:51,770 --> 00:06:52,880
0,165 165,465 465,615 615,855 855,1110
some buffer| or things, things
|或者东西会崩溃，

251
00:06:52,880 --> 00:06:53,855
0,135 135,380 520,780 780,885 885,975
are gonna, things are to

252
00:06:53,855 --> 00:06:54,545
0,135 135,255 255,315 315,405 405,690
break| or you get corrupted
|或者获得损坏的数据。

253
00:06:54,545 --> 00:06:55,460
0,245
data.|
|

254
00:06:55,660 --> 00:06:56,880
0,260 260,395 395,755 755,1040 1040,1220
So again, logical correctness, we'll
所以再次，逻辑正确性，我们会在期中考试之后担心，

255
00:06:56,880 --> 00:06:57,980
0,105 105,255 255,420 420,630 630,1100
worry about later, after midterm,|
|

256
00:06:58,060 --> 00:06:59,025
0,425 425,545 545,680 680,815 815,965
today's class is really about
今天的课程是关于物理正确性的。

257
00:06:59,025 --> 00:07:00,400
0,225 225,755
physical correctness.|
|

258
00:07:01,490 --> 00:07:02,215
0,245 245,350 350,485 485,590 590,725
So I first want to
所以，我首先想要介绍，

259
00:07:02,215 --> 00:07:04,450
0,305 1165,1440 1440,1665 1665,1980 1980,2235
describe,| go over quickly of
|快速介绍一下什么是 latch ，

260
00:07:04,450 --> 00:07:06,990
0,290 1180,1620 1620,1800 1800,2120 2140,2540
what latches are again| and
|以及如何在我们的数据库系统中实现它们。

261
00:07:07,040 --> 00:07:07,930
0,260 260,335 335,455 455,665 665,890
how do you actually implement

262
00:07:07,930 --> 00:07:08,710
0,270 270,465 465,525 525,585 585,780
them inside of our database

263
00:07:08,710 --> 00:07:10,165
0,350 670,945 945,1065 1065,1170 1170,1455
system.| And again, the takeaway
|再次，这里的要点是，

264
00:07:10,165 --> 00:07:12,325
0,120 120,210 210,455 1495,2055 2055,2160
here is that,| ideally we
|理想情况下，我们不想依赖操作系统，

265
00:07:12,325 --> 00:07:12,940
0,135 135,195 195,315 315,495 495,615
don't want to rely on

266
00:07:12,940 --> 00:07:14,665
0,90 90,255 255,480 480,800 1450,1725
what the operating system| gives
|在 latch 方面提供给我们的东西。

267
00:07:14,665 --> 00:07:15,780
0,210 210,420 420,555 555,675 675,1115
us in terms of latches.|
|

268
00:07:16,310 --> 00:07:17,635
0,275 275,500 500,665 665,875 875,1325
Then we'll see a simplified
然后我们将看到一个简单的例子，

269
00:07:17,635 --> 00:07:18,985
0,285 285,635 835,1125 1125,1260 1260,1350
example of| of how to
|如何进行哈希表 latch ，

270
00:07:18,985 --> 00:07:20,890
0,240 240,585 585,750 750,1265 1585,1905
do hash table latching,| let's
|我们大部分时间都在进行 B+ 树 latch ，

271
00:07:20,890 --> 00:07:21,750
0,105 105,255 255,405 405,570 570,860
say most our time doing

272
00:07:21,800 --> 00:07:23,305
0,290 290,470 470,635 635,1090 1260,1505
{B+ -} tree latching,| and
|我们将看到一个基本版本和一个优化版本，

273
00:07:23,305 --> 00:07:25,435
0,135 135,255 255,545 1435,1800 1800,2130
we'll see a basic version

274
00:07:25,435 --> 00:07:27,160
0,240 240,450 450,750 750,1055 1465,1725
and an optimized version,| and
|然后我们将以讨论如何处理叶子节点扫描结束。

275
00:07:27,160 --> 00:07:28,555
0,105 105,410 700,1005 1005,1185 1185,1395
then we'll finish off talking

276
00:07:28,555 --> 00:07:30,040
0,165 165,240 240,485 1015,1290 1290,1485
how to handle leaf node

277
00:07:30,040 --> 00:07:30,800
0,290
scans.|
|

278
00:07:31,290 --> 00:07:32,340
0,400
Okay?|
好的？|

279
00:07:34,670 --> 00:07:35,545
0,305 305,440 440,530 530,635 635,875
Right. So I think I
正确的。所以我想我之前展示了这张幻灯片，我只想再一次重温一下锁和闩锁之间的这个阶段。再说一次，如果你来自操作系统世界或分布式世界，他们，他们可能是指，当我说闩ch时，他们可能会认为是loc。

280
00:07:35,545 --> 00:07:36,730
0,255 255,420 420,630 630,915 915,1185
showed this slide before and

281
00:07:36,730 --> 00:07:37,270
0,165 165,285 285,375 375,465 465,540
again I just want to

282
00:07:37,270 --> 00:07:40,260
0,435 435,710 1990,2355 2355,2655 2655,2990
revisited again this stage between

283
00:07:40,670 --> 00:07:42,400
0,425 425,545 545,1030 1320,1595 1595,1730
locks and latches. And again,

284
00:07:42,400 --> 00:07:43,165
0,105 105,240 240,405 405,585 585,765
if you're coming from the

285
00:07:43,165 --> 00:07:44,820
0,315 315,690 690,1020 1020,1305 1305,1655
OS world or distributed world,

286
00:07:45,080 --> 00:07:48,145
0,400 1380,1670 1670,1895 1895,2230 2820,3065
they, they might mean when

287
00:07:48,145 --> 00:07:49,015
0,120 120,285 285,540 540,735 735,870
I say latch, they might

288
00:07:49,015 --> 00:07:50,180
0,195 195,515
think loc.|
|

289
00:07:50,180 --> 00:07:51,425
0,240 240,420 420,570 570,830 940,1245
Right. But in database, that's
正确的。但在数据库中，这是我们在这门课中最关心的生活。所以我们需要确保，当我们说到锁定与锁定时，我们明白我们在说什么。

290
00:07:51,425 --> 00:07:53,450
0,60 60,165 165,285 285,545 1705,2025
what we care about mostly

291
00:07:53,450 --> 00:07:54,695
0,180 180,360 360,680 850,1110 1110,1245
my life in, in this

292
00:07:54,695 --> 00:07:55,880
0,275 445,690 690,900 900,1110 1110,1185
course. So we need to

293
00:07:55,880 --> 00:07:56,555
0,90 90,195 195,360 360,555 555,675
make sure we understand what

294
00:07:56,555 --> 00:07:57,290
0,150 150,255 255,465 465,630 630,735
we're talking about when we

295
00:07:57,290 --> 00:07:58,300
0,135 135,300 300,525 525,720 720,1010
say lock versus the latch.|
|

296
00:07:59,330 --> 00:08:00,235
0,245 245,365 365,755 755,830 830,905
So a lock's going to
所以锁将是一个高级的，原始的，呃，保护原语，它允许我们保护我们数据库的逻辑内容，比如一个二元组，一个数据库，一个表。

297
00:08:00,235 --> 00:08:01,930
0,150 150,360 360,600 600,935 1165,1695
be this high level, primitive,

298
00:08:01,930 --> 00:08:03,505
0,350 430,830 910,1305 1305,1410 1410,1575
uh, protection primitive that allows

299
00:08:03,505 --> 00:08:06,490
0,225 225,545 1615,1980 1980,2345 2395,2985
us to protect the logical

300
00:08:06,490 --> 00:08:08,520
0,465 465,660 660,795 795,1070 1630,2030
contents of our database, like

301
00:08:08,600 --> 00:08:10,510
0,290 290,760 960,1235 1235,1510 1620,1910
a twople, a database, a

302
00:08:10,510 --> 00:08:11,720
0,290
table.|
|

303
00:08:11,720 --> 00:08:14,800
0,290 970,1370 1780,2180
Right. And the.|
正确的。还有。|

304
00:08:14,990 --> 00:08:16,510
0,350 350,700 840,1250 1250,1460 1460,1520
When we acquire one of
当我们获得这些锁中的一个时，事务将在该事务的持续时间内持有该锁。

305
00:08:16,510 --> 00:08:18,370
0,135 135,680 910,1185 1185,1460 1540,1860
these locks, the transaction will

306
00:08:18,370 --> 00:08:19,560
0,240 240,465 465,720 720,930 930,1190
hold that lock for the

307
00:08:20,180 --> 00:08:22,300
0,500 500,710 710,860 860,1150
duration of that transaction.|
|

308
00:08:22,300 --> 00:08:23,485
0,165 165,375 375,660 660,900 900,1185
It's not always true. We'll
这并不总是正确的。我们将看到可以提前释放锁的示例，但出于我们今天的目的，我们假设情况就是这样。

309
00:08:23,485 --> 00:08:24,460
0,225 225,525 525,735 735,840 840,975
see examples where we can

310
00:08:24,460 --> 00:08:26,140
0,180 180,465 465,615 615,920 1420,1680
release locks, maybe early, but

311
00:08:26,140 --> 00:08:27,355
0,90 90,195 195,465 465,860 880,1215
for our purposes today we'll

312
00:08:27,355 --> 00:08:28,720
0,135 135,315 315,405 405,665
assume that's the case.|
|

313
00:08:29,050 --> 00:08:30,260
0,290 290,485 485,725 725,890 890,1210
And then there'll be some
然后在我们的urgeto协议中会有一些更高级别的机制来确保我们不会有任何死锁。

314
00:08:30,460 --> 00:08:32,805
0,350 350,620 620,940 1320,1640 1640,2345
higher level mechanism within oururgeto

315
00:08:32,805 --> 00:08:34,650
0,605 835,1260 1260,1350 1350,1545 1545,1845
protocol that's going to ensure

316
00:08:34,650 --> 00:08:35,490
0,240 240,390 390,600 600,690 690,840
that we don't have any

317
00:08:35,490 --> 00:08:36,800
0,710
deadlocks.|
|

318
00:08:36,800 --> 00:08:37,775
0,165 165,330 330,480 480,615 615,975
And then if a deadlock
然后，如果真的出现死锁，那么数据库将具有一种机制，能够回滚事务所做的更改，使其看起来就像没有进行任何更改。所以我们没有，我们没有任何部分更新。

319
00:08:37,775 --> 00:08:40,805
0,255 255,605 1045,1445 1765,2165 2755,3030
does arise, then the the

320
00:08:40,805 --> 00:08:42,010
0,510 510,705 705,825 825,945 945,1205
databases will have a mechanism

321
00:08:42,090 --> 00:08:42,755
0,230 230,275 275,350 350,485 485,665
to be able to roll

322
00:08:42,755 --> 00:08:44,390
0,195 195,375 375,665 1165,1470 1470,1635
back the changes that the

323
00:08:44,390 --> 00:08:45,680
0,255 255,650 820,1065 1065,1170 1170,1290
transaction made to make it

324
00:08:45,680 --> 00:08:46,955
0,120 120,255 255,530 610,1010 1030,1275
look as if, you know,

325
00:08:46,955 --> 00:08:47,795
0,120 120,300 300,375 375,555 555,840
it didn't make any changes.

326
00:08:47,795 --> 00:08:48,470
0,210 210,285 285,450 450,525 525,675
So we don't, we don't

327
00:08:48,470 --> 00:08:49,980
0,60 60,180 180,570 570,890
have any partial updates.|
|

328
00:08:51,310 --> 00:08:52,635
0,320 320,530 530,680 680,890 890,1325
Today we're focused on latches
今天我们关注的是锁存，所以锁存将是我们用来保护我们的数据结构中的临界区免受另一个工作者攻击的低级原语。

329
00:08:52,635 --> 00:08:53,400
0,180 180,300 300,390 390,690 690,765
and so the latches are

330
00:08:53,400 --> 00:08:53,940
0,45 45,75 75,150 150,300 300,540
going to be the low

331
00:08:53,940 --> 00:08:55,485
0,350 640,1095 1095,1185 1185,1290 1290,1545
level primitives that we used

332
00:08:55,485 --> 00:08:57,330
0,395 775,1110 1110,1380 1380,1665 1665,1845
to protect critical sections in

333
00:08:57,330 --> 00:08:58,130
0,90 90,195 195,300 300,480 480,800
our, in our data structures

334
00:08:58,630 --> 00:09:00,495
0,290 290,485 485,790 1500,1745 1745,1865
from one worker, you know,

335
00:09:00,495 --> 00:09:02,100
0,240 240,540 540,875
against against another.|
|

336
00:09:02,170 --> 00:09:04,050
0,290 290,580 780,1180 1230,1490 1490,1880
And so the, the duration
因此，我们将持有闩锁的生命周期将非常短，就像思考一个关键部分一样。我要去拿一个插销在一页上，做一些改变，然后立即释放那个插销。

337
00:09:04,050 --> 00:09:05,025
0,225 225,450 450,720 720,840 840,975
of the lifetime that we're

338
00:09:05,025 --> 00:09:05,535
0,30 30,90 90,195 195,315 315,510
going to hold a latch

339
00:09:05,535 --> 00:09:06,135
0,150 150,210 210,255 255,360 360,600
is going to be very

340
00:09:06,135 --> 00:09:07,680
0,365 715,1005 1005,1200 1200,1395 1395,1545
short, like go like think

341
00:09:07,680 --> 00:09:08,610
0,120 120,345 345,645 645,870 870,930
a critical section. I'm going

342
00:09:08,610 --> 00:09:09,630
0,90 90,350 490,735 735,840 840,1020
to go take a latch

343
00:09:09,630 --> 00:09:10,860
0,135 135,240 240,500 730,1020 1020,1230
on a page, make some

344
00:09:10,860 --> 00:09:11,820
0,270 270,465 465,615 615,795 795,960
change, and then release that

345
00:09:11,820 --> 00:09:13,240
0,255 255,590
latch immediately.|
|

346
00:09:13,930 --> 00:09:16,770
0,400 600,1000 2190,2540 2540,2780 2780,2840
And, uh, because it's going
而且，呃，因为这将是非常简单的，我们最大限度地减少了我们为这些闩锁所做的预订。我们不想拥有，我们也不想拥有。数据集不会自动为我们回滚任何更改。

347
00:09:16,770 --> 00:09:17,720
0,45 45,150 150,360 360,615 615,950
to be very simple, we

348
00:09:17,980 --> 00:09:19,650
0,515 515,665 665,800 800,1270 1320,1670
minimize that of bookke we're

349
00:09:19,650 --> 00:09:21,420
0,225 225,435 435,570 570,1100 1480,1770
taking for these latches. We

350
00:09:21,420 --> 00:09:22,425
0,285 285,390 390,510 510,765 765,1005
don't want to have, we

351
00:09:22,425 --> 00:09:23,595
0,395 535,780 780,930 930,1080 1080,1170
don't. The data set is

352
00:09:23,595 --> 00:09:24,795
0,120 120,225 225,455 565,945 945,1200
not going to automatically roll

353
00:09:24,795 --> 00:09:25,880
0,135 135,315 315,600 600,825 825,1085
back any changes for us.|
|

354
00:09:26,540 --> 00:09:27,910
0,180 180,390 390,615 615,1125 1125,1370
We don't avoid deadlocks and
我们不会避免死锁，除非我们获得了某个东西的锁存，否则我们不会进行任何更改。

355
00:09:27,930 --> 00:09:28,880
0,260 260,395 395,575 575,755 755,950
try to not make any

356
00:09:28,880 --> 00:09:29,975
0,320 370,660 660,795 795,960 960,1095
changes unless we acquire the

357
00:09:29,975 --> 00:09:31,240
0,165 165,315 315,575
latch for something.|
|

358
00:09:31,310 --> 00:09:32,005
0,245 245,350 350,455 455,620 620,695
So that we don't have
这样我们就不必回滚，我们将在同时运行的不同工人之间进行最小限度的协调。

359
00:09:32,005 --> 00:09:33,025
0,90 90,225 225,405 405,695 805,1020
to roll things back, we

360
00:09:33,025 --> 00:09:34,465
0,45 45,275 325,750 750,1155 1155,1440
would have minimal coordination between

361
00:09:34,465 --> 00:09:36,205
0,305 835,1125 1125,1305 1305,1500 1500,1740
the, between the different workers

362
00:09:36,205 --> 00:09:37,050
0,210 210,315 315,405 405,555 555,845
running at the same time.|
|

363
00:09:38,080 --> 00:09:39,110
0,290 290,425 425,530 530,710 710,1030
Whereas in the lock case
而在锁的情况下，我跳到了前面，但是会有一个表，在内部被称为锁表。你去看看里面。您可以看到谁在闩锁中为不同的对象持有锁。我们不想维持这一切，因为这太昂贵了。

364
00:09:39,310 --> 00:09:40,860
0,365 365,920 920,1100 1100,1295 1295,1550
I, I'm jumping ahead, but

365
00:09:40,860 --> 00:09:41,745
0,210 210,300 300,390 390,585 585,885
there will be a table

366
00:09:41,745 --> 00:09:42,990
0,335 415,825 825,945 945,1065 1065,1245
literally internally called a lock

367
00:09:42,990 --> 00:09:44,190
0,320 580,825 825,900 900,1035 1035,1200
table. And you go look

368
00:09:44,190 --> 00:09:44,850
0,120 120,255 255,360 360,480 480,660
in there. You can see

369
00:09:44,850 --> 00:09:46,770
0,180 180,390 390,950 1450,1695 1695,1920
who holds locks for different

370
00:09:46,770 --> 00:09:48,750
0,380 820,1185 1185,1695 1695,1845 1845,1980
objects in latches. We don't

371
00:09:48,750 --> 00:09:49,335
0,45 45,105 105,285 285,480 480,585
want to maintain any of

372
00:09:49,335 --> 00:09:50,330
0,120 120,240 240,465 465,660 660,995
that because that's so expensive.|
|

373
00:09:51,040 --> 00:09:52,065
0,400 450,710 710,815 815,920 920,1025
Relative to the amount of
相对于我们希望在数据结构中的关键部分中完成的工作量。

374
00:09:52,065 --> 00:09:52,650
0,120 120,240 240,315 315,405 405,585
work we want to do

375
00:09:52,650 --> 00:09:53,835
0,225 225,375 375,585 585,945 945,1185
within a critical section in

376
00:09:53,835 --> 00:09:55,120
0,105 105,270 270,575
our data structures.|
|

377
00:09:56,720 --> 00:09:58,285
0,260 260,440 440,670 1110,1430 1430,1565
So there's this, there's this
所以有这张，这张桌子。我还喜欢上一次我推荐的这本书，这本书是gr的，当他再次展示锁和闩锁之间的变化时，以及排序读取这个表的方法是在你向下阅读的一列中，你知道它在保护什么，如何保护它。而不同的方式就是保护东西。例如，一个锁将事务彼此分开，它将保护逻辑数据库内容页，或者对不起，保护两个表和数据库。

378
00:09:58,285 --> 00:09:59,365
0,210 210,420 420,585 585,795 795,1080
table. I also like from

379
00:09:59,365 --> 00:10:00,280
0,240 240,420 420,555 555,675 675,915
the the book I recommended

380
00:10:00,280 --> 00:10:01,210
0,300 300,525 525,675 675,780 780,930
last time from this guy

381
00:10:01,210 --> 00:10:02,550
0,290 520,765 765,900 900,1065 1065,1340
gr, the b tree book

382
00:10:03,560 --> 00:10:04,870
0,290 290,440 440,590 590,880 960,1310
when again he shows this

383
00:10:04,870 --> 00:10:05,860
0,285 285,465 465,570 570,795 795,990
change between the locks versus

384
00:10:05,860 --> 00:10:07,300
0,560 790,1035 1035,1140 1140,1290 1290,1440
latches and the way to

385
00:10:07,300 --> 00:10:08,320
0,225 225,465 465,630 630,810 810,1020
sort to read this table

386
00:10:08,320 --> 00:10:10,270
0,320 400,705 705,915 915,1220 1660,1950
is within a column you

387
00:10:10,270 --> 00:10:11,305
0,195 195,450 450,675 675,870 870,1035
read down and say, you

388
00:10:11,305 --> 00:10:12,520
0,245 385,705 705,885 885,1020 1020,1215
know what the thing is

389
00:10:12,520 --> 00:10:13,690
0,405 405,570 570,750 750,1080 1080,1170
protecting, how is protecting it.

390
00:10:13,690 --> 00:10:14,770
0,105 105,195 195,375 375,710 760,1080
And the different ways is

391
00:10:14,770 --> 00:10:16,225
0,315 315,590 880,1170 1170,1320 1320,1455
protecting things. So for example,

392
00:10:16,225 --> 00:10:17,020
0,165 165,390 390,585 585,690 690,795
a lock is going to

393
00:10:17,020 --> 00:10:18,300
0,210 210,560 640,885 885,1005 1005,1280
separate transactions from each other

394
00:10:19,010 --> 00:10:19,810
0,230 230,350 350,410 410,530 530,800
and it's going to protect

395
00:10:19,810 --> 00:10:21,730
0,270 270,735 735,1020 1020,1560 1560,1920
the logical database contents pages

396
00:10:21,730 --> 00:10:24,510
0,240 240,500 820,1220 1660,2055 2055,2780
or sorry, two tables, databases.|
|

397
00:10:25,020 --> 00:10:25,860
0,210 210,315 315,435 435,615 615,840
And we can hold them
我们可以在整个交易期间持有它们。我们将在稍后讨论模式。我们可以在不同的模式下锁定对象，比如独占共享意图更新。我们将得到，我们将稍后到达那里，并且数据提供死锁检测或死锁预防机制。

398
00:10:25,860 --> 00:10:26,925
0,240 240,465 465,690 690,915 915,1065
for the entire length of

399
00:10:26,925 --> 00:10:28,665
0,105 105,365 1165,1455 1455,1560 1560,1740
the transaction. We'll talk about

400
00:10:28,665 --> 00:10:29,640
0,300 300,405 405,540 540,780 780,975
modes in a second. We

401
00:10:29,640 --> 00:10:30,735
0,75 75,180 180,315 315,590 850,1095
can take a lock for

402
00:10:30,735 --> 00:10:32,000
0,225 225,465 465,570 570,735 735,1265
an object in different modes,

403
00:10:32,230 --> 00:10:35,325
0,395 395,820 1200,1600 2490,2855 2855,3095
like exclusive shared intention updates.

404
00:10:35,325 --> 00:10:35,940
0,150 150,270 270,450 450,510 510,615
We'll get, we'll get there

405
00:10:35,940 --> 00:10:37,580
0,260 790,1065 1065,1230 1230,1380 1380,1640
later, and that the data

406
00:10:37,930 --> 00:10:39,390
0,320 320,560 560,935 935,1340 1340,1460
provide either deadlock detection or

407
00:10:39,390 --> 00:10:41,240
0,255 255,570 570,1250
deadlock prevention mechanisms.|
|

408
00:10:41,240 --> 00:10:42,275
0,150 150,420 420,720 720,900 900,1035
Built in to avoid these
内置以避免这些问题。话又说回来，这些都是实现这一点的机制。然后我们要跟踪的信息，什么锁被持有，被保存在锁管理器中，一个集中的数据结构。

409
00:10:42,275 --> 00:10:44,030
0,275 895,1155 1155,1380 1380,1620 1620,1755
problems. And then again, these

410
00:10:44,030 --> 00:10:44,795
0,90 90,165 165,540 540,645 645,765
are the mechanisms to do

411
00:10:44,795 --> 00:10:46,190
0,275 505,765 765,885 885,1095 1095,1395
this. And then the information

412
00:10:46,190 --> 00:10:46,850
0,180 180,315 315,375 375,495 495,660
that we're to keep track

413
00:10:46,850 --> 00:10:47,615
0,150 150,300 300,555 555,645 645,765
of, what locks are being

414
00:10:47,615 --> 00:10:48,530
0,195 195,390 390,540 540,705 705,915
held is being kept in

415
00:10:48,530 --> 00:10:50,980
0,180 180,360 360,680 1570,1875 1875,2450
a lock manager, a centralized

416
00:10:51,540 --> 00:10:52,860
0,320 320,640
data structure.|
|

417
00:10:53,630 --> 00:10:54,900
0,350 350,545 545,710 710,905 905,1270
Today, again, we're focused on
今天，我们再一次专注于闩锁，所以闩锁将保护工人免受彼此的伤害。这将仅在内存数据结构中使用。所以这是字面上的，你知道的，b+树在记忆中。但是，一旦你知道我们的b+树中的一个页面是否被从磁盘中刷新出来，我就不会在它到磁盘上时拿着它的闩锁，因为它是没有意义的。

418
00:10:55,310 --> 00:10:57,205
0,640 810,1070 1070,1355 1355,1790 1790,1895
latches, so latch latches are

419
00:10:57,205 --> 00:10:57,925
0,60 60,150 150,345 345,570 570,720
going to protect workers from

420
00:10:57,925 --> 00:10:59,110
0,120 120,395 745,1005 1005,1095 1095,1185
each other. This will be

421
00:10:59,110 --> 00:11:00,220
0,225 225,480 480,645 645,840 840,1110
only for in memory data

422
00:11:00,220 --> 00:11:01,990
0,350 1030,1305 1305,1470 1470,1620 1620,1770
structures. So like this is

423
00:11:01,990 --> 00:11:03,355
0,210 210,495 495,860 1030,1260 1260,1365
literally for the, you know,

424
00:11:03,355 --> 00:11:04,380
0,165 165,360 360,570 570,750 750,1025
b plus trees in memory.

425
00:11:04,760 --> 00:11:06,670
0,320 320,640 1200,1445 1445,1640 1640,1910
But once you know if

426
00:11:06,670 --> 00:11:08,305
0,320 460,705 705,840 840,1130 1240,1635
if if a page within

427
00:11:08,305 --> 00:11:09,625
0,315 315,510 510,675 675,965 1015,1320
our b plus tree gets

428
00:11:09,625 --> 00:11:10,585
0,225 225,330 330,480 480,825 825,960
flushed out the disk, I

429
00:11:10,585 --> 00:11:12,325
0,225 225,375 375,540 540,845 1465,1740
wouldn't hold the latch for

430
00:11:12,325 --> 00:11:12,910
0,150 150,300 300,420 420,495 495,585
that thing when it goes

431
00:11:12,910 --> 00:11:14,065
0,135 135,285 285,585 585,825 825,1155
out to disk because it's

432
00:11:14,065 --> 00:11:15,540
0,515
meaningless.|
|

433
00:11:15,970 --> 00:11:17,240
0,380 380,635 635,725 725,920 920,1270
It's protecting the critical sections.
它是在保护关键区域。只有两种模式。我们可以保持锁存，读写，我们处理死锁的方法是通过对我们进行编码训练，因为系统开发人员必须编写良好的代码来确保没有死锁。

434
00:11:17,590 --> 00:11:18,795
0,335 335,485 485,695 695,890 890,1205
There's only be two modes.

435
00:11:18,795 --> 00:11:19,500
0,75 75,165 165,285 285,405 405,705
We can hold our latches

436
00:11:19,500 --> 00:11:21,705
0,165 165,330 330,435 435,680 1930,2205
in, read and write, and

437
00:11:21,705 --> 00:11:22,400
0,120 120,255 255,420 420,465 465,695
the way we're going to

438
00:11:22,660 --> 00:11:24,375
0,320 320,755 755,905 905,1210 1320,1715
handle deadlocks is through coding

439
00:11:24,375 --> 00:11:26,010
0,275 565,885 885,1110 1110,1290 1290,1635
discipline us as the system

440
00:11:26,010 --> 00:11:27,090
0,290 340,600 600,720 720,885 885,1080
developers have to write good

441
00:11:27,090 --> 00:11:27,750
0,195 195,330 330,420 420,525 525,660
code to make sure there's

442
00:11:27,750 --> 00:11:28,920
0,105 105,680
no deadlocks.|
|

443
00:11:28,920 --> 00:11:29,970
0,195 195,405 405,540 540,750 750,1050
Easier said than done, short,
说起来容易做起来难，简短地说，但好像不会有什么东西，系统的其他部分会帮助我们摆脱困境。

444
00:11:29,970 --> 00:11:31,890
0,195 195,440 1330,1665 1665,1800 1800,1920
but like there's not going

445
00:11:31,890 --> 00:11:32,880
0,60 60,165 165,435 435,750 750,990
to be something, some other

446
00:11:32,880 --> 00:11:33,780
0,180 180,270 270,345 345,585 585,900
part of the system that's

447
00:11:33,780 --> 00:11:34,490
0,60 60,150 150,315 315,435 435,710
going to bail us out.|
|

448
00:11:35,480 --> 00:11:36,370
0,305 305,515 515,545 545,650 650,890
And we're going to keep
我们将保留有关这些锁存的信息实际上嵌入到数据结构本身中。

449
00:11:36,370 --> 00:11:38,410
0,350 850,1215 1215,1485 1485,1680 1680,2040
the information about these latches

450
00:11:38,410 --> 00:11:39,760
0,195 195,530 760,1080 1080,1245 1245,1350
are actually embedded in the

451
00:11:39,760 --> 00:11:41,440
0,195 195,530 550,950
data structure itself.|
|

452
00:11:41,440 --> 00:11:42,175
0,180 180,255 255,450 450,525 525,735
So there won't be a
所以不会有一个集中的，集中的东西。

453
00:11:42,175 --> 00:11:44,320
0,605 775,1275 1275,1595
centralized, centralized thing.|
|

454
00:11:45,180 --> 00:11:46,115
0,290 290,440 440,575 575,710 710,935
Again, this makes more sense
同样，当我们开始讨论不同的数据结构类型时，这就更有意义了，因此，我们将在第15课的期中考试后讨论锁的内容。

455
00:11:46,115 --> 00:11:47,360
0,210 210,315 315,575 715,1050 1050,1245
when we start walking through

456
00:11:47,360 --> 00:11:48,310
0,90 90,225 225,435 435,690 690,950
the different data structureer types,

457
00:11:48,810 --> 00:11:49,715
0,275 275,395 395,500 500,695 695,905
and so the lock stuff

458
00:11:49,715 --> 00:11:51,350
0,165 165,395 865,1185 1185,1500 1500,1635
we'll cover after midterm in

459
00:11:51,350 --> 00:11:52,580
0,195 195,530
lecture fifteen.|
|

460
00:11:55,150 --> 00:11:56,730
0,400 510,830 830,1250 1250,1415 1415,1580
So our latches only have
所以我们的闩锁只有两种模式。它可以是读模式或写模式。所以，阅读模式。在交换操作中，您可以让多个工作者同时在读取模式下获取锁存，因为，您知道，无论他们正在做什么，都不会破坏任何数据结构。它召唤，召唤，任何冲突，对吗？

461
00:11:56,730 --> 00:11:58,410
0,150 150,620 1150,1380 1380,1470 1470,1680
two modes. It can be

462
00:11:58,410 --> 00:11:59,580
0,270 270,540 540,825 825,1020 1020,1170
read mode or a write

463
00:11:59,580 --> 00:12:01,605
0,290 460,735 735,915 915,1220 1780,2025
mode. So read mode. There

464
00:12:01,605 --> 00:12:03,435
0,120 120,600 600,965 1015,1415 1585,1830
are commutative operations where you

465
00:12:03,435 --> 00:12:04,785
0,90 90,225 225,515 565,965 1045,1350
can have multiple workers take

466
00:12:04,785 --> 00:12:06,020
0,180 180,405 405,660 660,915 915,1235
a latch in read mode

467
00:12:06,310 --> 00:12:07,410
0,290 290,440 440,620 620,890 890,1100
at the same time because,

468
00:12:07,410 --> 00:12:08,510
0,135 135,375 375,630 630,855 855,1100
you know whatever they're doing

469
00:12:08,530 --> 00:12:10,820
0,425 425,620 620,940 1830,2060 2060,2290
isn't going to, you know,

470
00:12:10,990 --> 00:12:12,240
0,380 380,485 485,620 620,910 990,1250
isn't going to break whatever

471
00:12:12,240 --> 00:12:13,080
0,135 135,315 315,525 525,705 705,840
the data structure is. It

472
00:12:13,080 --> 00:12:15,290
0,260 430,720 720,1010 1180,1830 1830,2210
calls, calls, any conflicts, right?|
|

473
00:12:16,520 --> 00:12:18,090
0,245 245,350 350,610 960,1265 1265,1570
If I need, if two
如果我需要，如果两个工作人员需要阅读同一页，我可以在读取模式下进行。

474
00:12:18,290 --> 00:12:19,210
0,335 335,530 530,650 650,785 785,920
workers need to read the

475
00:12:19,210 --> 00:12:20,335
0,165 165,470 700,930 930,1020 1020,1125
same page, and I can

476
00:12:20,335 --> 00:12:21,300
0,120 120,285 285,465 465,660 660,965
take that in read mode.|
|

477
00:12:22,020 --> 00:12:23,175
0,165 165,410 490,750 750,975 975,1155
Well, that that doesn't. They're
嗯，那不是。他们没有做任何正确的事情。它不会打碎任何东西。这样我就可以让它们同时运行。

478
00:12:23,175 --> 00:12:23,880
0,75 75,180 180,330 330,555 555,705
not do any right. It

479
00:12:23,880 --> 00:12:25,320
0,165 165,390 390,770 970,1290 1290,1440
doesn't break anything. So I

480
00:12:25,320 --> 00:12:26,400
0,75 75,210 210,480 480,825 825,1080
can go ahead and have

481
00:12:26,400 --> 00:12:27,015
0,150 150,285 285,420 420,510 510,615
them both run at the

482
00:12:27,015 --> 00:12:28,300
0,180 180,485
same time.|
|

483
00:12:28,730 --> 00:12:30,055
0,305 305,545 545,800 800,1070 1070,1325
Write mode or exclusive mode
写模式或独占模式是当您知道一个线程想要访问对象并实际对其进行更改时，我不希望任何其他线程同时运行相同的线程来操作我的对象。因此，只有一个，只有一个工人可以将闩锁保持在正确的模式下，这会阻止其他所有人进入。

484
00:12:30,055 --> 00:12:31,540
0,255 255,575 625,915 915,1170 1170,1485
is when you know one

485
00:12:31,540 --> 00:12:33,415
0,300 300,650 1180,1455 1455,1665 1665,1875
thread is wants to access

486
00:12:33,415 --> 00:12:34,465
0,225 225,465 465,675 675,855 855,1050
the object and actually make

487
00:12:34,465 --> 00:12:35,875
0,315 315,540 540,785 1045,1290 1290,1410
changes to it, and I

488
00:12:35,875 --> 00:12:37,255
0,210 210,330 330,495 495,765 765,1380
don't want any other threads

489
00:12:37,255 --> 00:12:38,740
0,270 270,435 435,585 585,845 1135,1485
to run the same to

490
00:12:38,740 --> 00:12:39,760
0,225 225,375 375,650 700,945 945,1020
operate on my object at

491
00:12:39,760 --> 00:12:41,700
0,90 90,240 240,530 1120,1520 1540,1940
the same time. So only

492
00:12:41,720 --> 00:12:43,510
0,400 810,1130 1130,1340 1340,1580 1580,1790
one, only one worker can

493
00:12:43,510 --> 00:12:44,740
0,165 165,330 330,585 585,945 945,1230
hold the latch in right

494
00:12:44,740 --> 00:12:46,045
0,290 340,585 585,735 735,1040 1060,1305
mode and that blocks everyone

495
00:12:46,045 --> 00:12:47,300
0,225 225,525 525,845
else else out.|
|

496
00:12:47,680 --> 00:12:49,350
0,400 930,1175 1175,1280 1280,1460 1460,1670
Right, and a really simple
是的，一个非常简单的兼容性矩阵将看起来像这样。如果我有一个读模式，如果我有一个处于读模式的闩锁，如果有人想要在读模式下获得一个闩锁，我可以做到。这是允许的，但任何其他组合，如果至少有一个闩锁将其保持在正确模式或希望使其处于正确模式，我必须否认这一点。

497
00:12:49,350 --> 00:12:50,700
0,525 525,945 945,1065 1065,1200 1200,1350
compatibility matrix will look like

498
00:12:50,700 --> 00:12:52,200
0,290 430,830 1030,1290 1290,1395 1395,1500
this. If I have a

499
00:12:52,200 --> 00:12:53,085
0,150 150,440 520,765 765,825 825,885
read mode, if I have

500
00:12:53,085 --> 00:12:53,870
0,75 75,210 210,360 360,510 510,785
a latch in read mode,

501
00:12:53,890 --> 00:12:54,795
0,260 260,500 500,755 755,845 845,905
if someone wants to get

502
00:12:54,795 --> 00:12:55,580
0,90 90,225 225,360 360,510 510,785
a latch in read mode,

503
00:12:55,780 --> 00:12:56,685
0,260 260,365 365,470 470,635 635,905
I can do that. That's

504
00:12:56,685 --> 00:12:58,460
0,275 445,845 985,1275 1275,1470 1470,1775
allowed, but any other combination

505
00:12:58,540 --> 00:12:59,355
0,245 245,335 335,500 500,695 695,815
where at least one of

506
00:12:59,355 --> 00:13:00,720
0,105 105,525 525,875 925,1230 1230,1365
the latches either holds it

507
00:13:00,720 --> 00:13:01,770
0,105 105,270 270,560 610,885 885,1050
in right mode or wants

508
00:13:01,770 --> 00:13:02,475
0,165 165,300 300,405 405,525 525,705
to get it in right

509
00:13:02,475 --> 00:13:04,170
0,305 865,1140 1140,1290 1290,1425 1425,1695
mode, I have to deny

510
00:13:04,170 --> 00:13:04,840
0,290
that.|
|

511
00:13:06,540 --> 00:13:08,330
0,400 780,1180 1290,1580 1580,1715 1715,1790
So again, going back to
再说一次，回到我之前所说的编码规则，最愚蠢的事情就是采用每一个闩锁和写入模式，即使你只会阅读它。它将保护您的所有数据结构。但就像，你知道的，基本上会被降级到单线程系统。同样，如果我在读模式下使用锁存器，但我开始对它所保护的东西进行更改，那么，那就是我们的错。这是程序员的错。然后系统就会崩溃。这是我们的责任。

512
00:13:08,330 --> 00:13:08,825
0,60 60,135 135,240 240,360 360,495
what I say before about

513
00:13:08,825 --> 00:13:10,640
0,210 210,455 865,1215 1215,1470 1470,1815
coding discipline, like the stupidest

514
00:13:10,640 --> 00:13:11,345
0,135 135,270 270,420 420,570 570,705
thing to do is to

515
00:13:11,345 --> 00:13:12,470
0,255 255,570 570,810 810,960 960,1125
take every latch and write

516
00:13:12,470 --> 00:13:13,280
0,210 210,420 420,570 570,705 705,810
mode, even though you're only

517
00:13:13,280 --> 00:13:14,510
0,120 120,195 195,315 315,590 760,1230
going to read it. It'll

518
00:13:14,510 --> 00:13:15,580
0,225 225,405 405,540 540,735 735,1070
protect all your data structures.

519
00:13:15,750 --> 00:13:18,190
0,320 320,640 1020,1420 1590,2105 2105,2440
But like, you know, basically

520
00:13:18,300 --> 00:13:19,250
0,245 245,335 335,440 440,815 815,950
going to get relegated to

521
00:13:19,250 --> 00:13:21,050
0,90 90,285 285,510 510,800 1540,1800
a single thread system. And

522
00:13:21,050 --> 00:13:22,235
0,420 420,660 660,825 825,1020 1020,1185
likewise, if I take my

523
00:13:22,235 --> 00:13:23,435
0,165 165,330 330,555 555,875 955,1200
latch in read mode, but

524
00:13:23,435 --> 00:13:24,740
0,105 105,360 360,705 705,1035 1035,1305
I start making changes to

525
00:13:24,740 --> 00:13:26,465
0,195 195,480 480,980 1180,1455 1455,1725
whatever it's protecting, then that's,

526
00:13:26,465 --> 00:13:27,335
0,210 210,360 360,570 570,765 765,870
that's our fault. That's the

527
00:13:27,335 --> 00:13:28,715
0,390 390,635 835,1080 1080,1185 1185,1380
programmer's fault. And the system

528
00:13:28,715 --> 00:13:30,260
0,420 420,630 630,720 720,995
crashes. That's on us.|
|

529
00:13:33,530 --> 00:13:36,040
0,245 245,335 335,560 560,820
And there isn't any.|
而现在却没有。|

530
00:13:36,080 --> 00:13:38,970
0,350 350,590 590,880 1980,2630 2630,2890
Without getting into verifiable languages,
如果不进入可验证的语言，在c++或rust中就没有任何机制可以保护我们免受这些事情的影响。

531
00:13:39,290 --> 00:13:40,680
0,275 275,500 500,665 665,970 990,1390
there isn't really any mechanism

532
00:13:40,880 --> 00:13:42,100
0,400 540,785 785,905 905,1055 1055,1220
in c plus, plus or

533
00:13:42,100 --> 00:13:42,910
0,210 210,450 450,525 525,660 660,810
rust that's going to protect

534
00:13:42,910 --> 00:13:44,280
0,195 195,375 375,495 495,770
us from these things.|
|

535
00:13:44,400 --> 00:13:45,460
0,400
Right.|
正确的。|

536
00:13:46,010 --> 00:13:47,670
0,260 260,470 470,905 1170,1415 1415,1660
Because the compiler can't know.|
因为编译器不能知道。|

537
00:13:50,650 --> 00:13:51,460
0,60 60,120 120,240 240,530 580,810
So let's look how you
因此，让我们来看看您想要如何实现闩锁。

538
00:13:51,460 --> 00:13:53,380
0,60 60,150 150,315 315,800
want to implement latches.|
|

539
00:13:53,380 --> 00:13:54,445
0,255 255,720 720,870 870,975 975,1065
So ideally we want a
因此，理想情况下，我们需要一个内存占用较小的锁存器，因为我们不想为锁存器存储大量附加元数据，因为我们希望这些元数据嵌入到数据结构本身中，理想情况下，我们希望它成为数据结构本身。

540
00:13:54,445 --> 00:13:57,145
0,150 150,285 285,545 595,995 2425,2700
latch that has, uh, small

541
00:13:57,145 --> 00:13:58,180
0,275 295,615 615,795 795,900 900,1035
memory footprint because we don't

542
00:13:58,180 --> 00:13:58,890
0,60 60,165 165,300 300,435 435,710
want to store a lot

543
00:13:59,180 --> 00:14:01,105
0,400 420,755 755,1450 1560,1805 1805,1925
of additional metadata for our

544
00:14:01,105 --> 00:14:02,425
0,240 240,420 420,675 675,990 990,1320
latch because we're these be

545
00:14:02,425 --> 00:14:03,520
0,315 315,525 525,630 630,795 795,1095
embedded in the data structure

546
00:14:03,520 --> 00:14:06,160
0,380 1870,2115 2115,2460 2460,2550 2550,2640
itself and ideally we want

547
00:14:06,160 --> 00:14:07,740
0,75 75,210 210,375 375,650
to have it be.|
|

548
00:14:07,740 --> 00:14:08,910
0,210 210,435 435,645 645,1020 1020,1170
When there's no contention in
当系统中没有争用时，意味着没有两个线程或工作线程试图同时锁存，我们希望以最小的开销尽可能快地运行。我拿到门闩，马上做我的事。

549
00:14:08,910 --> 00:14:10,280
0,120 120,410 520,855 855,1110 1110,1370
the system, meaning there's no

550
00:14:10,420 --> 00:14:11,475
0,335 335,620 620,710 710,890 890,1055
two threads or workers trying

551
00:14:11,475 --> 00:14:12,570
0,245 505,795 795,885 885,960 960,1095
to latch at the same

552
00:14:12,570 --> 00:14:13,905
0,290 730,975 975,1065 1065,1140 1140,1335
time, we want to go

553
00:14:13,905 --> 00:14:15,170
0,240 240,405 405,570 570,845 865,1265
as fast as possible with

554
00:14:15,370 --> 00:14:17,265
0,410 410,910 1290,1565 1565,1760 1760,1895
minimal overhead. I acquire the

555
00:14:17,265 --> 00:14:17,925
0,165 165,300 300,405 405,525 525,660
latch and do my thing

556
00:14:17,925 --> 00:14:19,020
0,165 165,455
right away.|
|

557
00:14:19,410 --> 00:14:21,590
0,400 570,890 890,1190 1190,1570 1890,2180
If we have to, we
如果我们必须这样做，我们就拿不到我们需要的插销。然后我们必须决定我们应该等待多长时间，以及我们想要如何等待。

558
00:14:21,590 --> 00:14:22,310
0,240 240,315 315,405 405,570 570,720
can't get the latch we

559
00:14:22,310 --> 00:14:23,645
0,260 580,870 870,1005 1005,1125 1125,1335
need. Then we have to

560
00:14:23,645 --> 00:14:24,890
0,180 180,330 330,615 615,975 975,1245
make a decision of how

561
00:14:24,890 --> 00:14:25,775
0,195 195,360 360,510 510,705 705,885
long we should wait and

562
00:14:25,775 --> 00:14:26,500
0,150 150,270 270,360 360,465 465,725
how we want to wait.|
|

563
00:14:27,400 --> 00:14:28,860
0,275 275,455 455,680 680,980 980,1460
And we'll see different scenarios
我们将看到我们想要如何做到这一点的不同场景。

564
00:14:28,860 --> 00:14:29,640
0,300 300,510 510,615 615,690 690,780
of how we want to

565
00:14:29,640 --> 00:14:31,920
0,120 120,380
do this.|
|

566
00:14:32,390 --> 00:14:33,990
0,275 275,830 830,1055 1055,1280 1280,1600
And ideally, also too, we,
在理想情况下，我们也不希望每个闩锁都有一堆关于谁在等待这个闩锁的元数据，因为这基本上是每一个人的提示。

567
00:14:34,070 --> 00:14:35,245
0,380 380,650 650,935 935,1040 1040,1175
we, we don't want to

568
00:14:35,245 --> 00:14:37,290
0,275 775,1020 1020,1125 1125,1290 1290,2045
have a bunch of metadata

569
00:14:37,430 --> 00:14:40,105
0,400 1020,1450 1740,2120 2120,2495 2495,2675
per latch about who's waiting

570
00:14:40,105 --> 00:14:41,740
0,180 180,315 315,635 955,1275 1275,1635
for this latch, because that's

571
00:14:41,740 --> 00:14:43,180
0,260 310,675 675,930 930,1245 1245,1440
now basically a cue for

572
00:14:43,180 --> 00:14:44,500
0,210 210,560
every single.|
|

573
00:14:44,500 --> 00:14:45,160
0,300 300,420 420,495 495,585 585,660
Latch you could have in
你可以在你的数据结构中锁住它。我想像一棵巨大的p+树，有十亿个条目。你要在里面放多少，多少页？其中每一个现在都可以有自己的优先队列。

574
00:14:45,160 --> 00:14:45,925
0,90 90,255 255,510 510,690 690,765
your data structure. And I

575
00:14:45,925 --> 00:14:46,705
0,105 105,225 225,435 435,630 630,780
think of like a giant

576
00:14:46,705 --> 00:14:47,965
0,165 165,345 345,665 865,1125 1125,1260
p plus tree with a

577
00:14:47,965 --> 00:14:49,870
0,210 210,725 1225,1485 1485,1710 1710,1905
billion entries. How many, how

578
00:14:49,870 --> 00:14:50,500
0,135 135,360 360,555 555,585 585,630
many pages you're going to

579
00:14:50,500 --> 00:14:51,175
0,90 90,195 195,360 360,555 555,675
have in there? Each of

580
00:14:51,175 --> 00:14:52,825
0,150 150,315 315,575 1285,1545 1545,1650
those could have now their

581
00:14:52,825 --> 00:14:54,160
0,135 135,390 390,815
own priority queue.|
|

582
00:14:54,950 --> 00:14:56,080
0,400
Right.|
正确的。|

583
00:14:56,580 --> 00:14:58,355
0,400 930,1295 1295,1550 1550,1685 1685,1775
So again, coming from the
所以，再一次，来自数据库世界，我们说我们不，我们不想依赖操作系统来做任何这些事情。但操作系统人员表示，数据不知道他们在做什么，他们不应该实现自己的锁存。您可以在Linux邮件列表中看到这一点。所以这里有一个帖子或减号说，哦，是的，就像你不想一样，你不应该写你自己的闩锁东西。它基本上是这样说的，比如你不应该使用自旋锁，但我会在用户空间的一秒钟内清理它。这就是我们运行用户空间的数据系统。

584
00:14:58,355 --> 00:14:59,420
0,210 210,495 495,720 720,915 915,1065
database world, we say we

585
00:14:59,420 --> 00:15:00,545
0,440 610,855 855,1005 1005,1050 1050,1125
don't, we don't want to

586
00:15:00,545 --> 00:15:01,010
0,90 90,165 165,255 255,375 375,465
rely on the OS to

587
00:15:01,010 --> 00:15:01,690
0,75 75,165 165,255 255,390 390,680
do any of these things.

588
00:15:02,100 --> 00:15:03,005
0,245 245,350 350,515 515,695 695,905
But then the OS people

589
00:15:03,005 --> 00:15:04,325
0,335 475,720 720,915 915,1185 1185,1320
say the data don't know

590
00:15:04,325 --> 00:15:05,135
0,180 180,315 315,465 465,630 630,810
know what they're doing and

591
00:15:05,135 --> 00:15:05,960
0,90 90,195 195,330 330,495 495,825
they should not be implementing

592
00:15:05,960 --> 00:15:07,535
0,105 105,225 225,680 1210,1470 1470,1575
their own latches. And you

593
00:15:07,535 --> 00:15:08,435
0,105 105,225 225,345 345,570 570,900
can see this in the

594
00:15:08,435 --> 00:15:09,500
0,225 225,450 450,735 735,900 900,1065
the Linux mailing list. So

595
00:15:09,500 --> 00:15:11,290
0,315 315,590 1030,1335 1335,1515 1515,1790
here's a post or minus

596
00:15:12,330 --> 00:15:14,195
0,350 350,695 695,1010 1010,1330 1470,1865
saying like oh yeah, like

597
00:15:14,195 --> 00:15:16,205
0,395 535,1085 1525,1785 1785,1890 1890,2010
you don't, you should not

598
00:15:16,205 --> 00:15:17,015
0,135 135,285 285,405 405,495 495,810
be writing your own latching

599
00:15:17,015 --> 00:15:17,825
0,210 210,375 375,435 435,600 600,810
thing. And it basically says

600
00:15:17,825 --> 00:15:18,620
0,180 180,405 405,585 585,690 690,795
here like you should not

601
00:15:18,620 --> 00:15:19,580
0,165 165,345 345,540 540,690 690,960
use spin lock, but I'll

602
00:15:19,580 --> 00:15:20,150
0,210 210,315 315,405 405,480 480,570
clean that is in a

603
00:15:20,150 --> 00:15:21,665
0,260 340,615 615,825 825,1155 1155,1515
second in user space. That's

604
00:15:21,665 --> 00:15:22,685
0,215 325,585 585,675 675,795 795,1020
us where the data system

605
00:15:22,685 --> 00:15:24,040
0,225 225,345 345,510 510,845
running a user space.|
|

606
00:15:24,050 --> 00:15:24,865
0,275 275,440 440,575 575,695 695,815
Says you should not be
说你不应该使用自旋锁，所以你应该滚动自己，除非你知道你在做什么，而且你知道你正在做的事情很少。

607
00:15:24,865 --> 00:15:25,735
0,245 265,525 525,720 720,795 795,870
using spin locks so you

608
00:15:25,735 --> 00:15:26,560
0,195 195,480 480,660 660,750 750,825
roll yourself unless you know

609
00:15:26,560 --> 00:15:27,220
0,60 60,195 195,360 360,555 555,660
what you're doing and the

610
00:15:27,220 --> 00:15:27,775
0,150 150,300 300,405 405,480 480,555
chances are you know what

611
00:15:27,775 --> 00:15:30,260
0,135 135,365 565,900 900,1235
you're doing is low.|
|

612
00:15:30,395 --> 00:15:32,770
0,105 105,365 1555,1830 1830,1980 1980,2375
He's wrong, despite being linus.|
他错了，尽管他是莱纳斯。|

613
00:15:34,480 --> 00:15:35,470
0,195 195,360 360,630 630,930 930,990
All right, so I'm going
好的，我将介绍如何实现闩锁的三个基本实现。嗯，还有更先进的，比如苹果公司的停车场。这可能是目前使用的最好的一个。然后是CS锁，这是我们将在高级课程中讨论的排队问题。但就我们这里的目的而言，我们不需要知道这一点，但我们需要了解闩锁实际做什么的基本隐含实现，以便当您开始将它们分散在代码中时，您就了解了它们的后果。

614
00:15:35,470 --> 00:15:36,475
0,75 75,195 195,390 390,660 660,1005
to go through three basic

615
00:15:36,475 --> 00:15:39,055
0,605 1315,1715 1795,2195 2215,2460 2460,2580
implementations of of how to

616
00:15:39,055 --> 00:15:41,335
0,180 180,665 865,1265 1795,2130 2130,2280
implement latches. EM, there's more

617
00:15:41,335 --> 00:15:42,310
0,255 255,495 495,645 645,780 780,975
advanced ones like the parking

618
00:15:42,310 --> 00:15:43,615
0,210 210,405 405,675 675,1040 1060,1305
lot stuff from Apple. This

619
00:15:43,615 --> 00:15:44,485
0,150 150,375 375,555 555,720 720,870
is probably the best one

620
00:15:44,485 --> 00:15:45,985
0,90 90,240 240,420 420,695 1255,1500
to use right now. And

621
00:15:45,985 --> 00:15:47,250
0,105 105,300 300,480 480,735 735,1265
then there m CS locks,

622
00:15:48,020 --> 00:15:49,530
0,260 260,520 660,950 950,1235 1235,1510
which is a queuing thing

623
00:15:50,660 --> 00:15:51,670
0,320 320,500 500,755 755,905 905,1010
we'll cover in in the

624
00:15:51,670 --> 00:15:52,495
0,180 180,420 420,615 615,720 720,825
advanced class. But for our

625
00:15:52,495 --> 00:15:53,380
0,195 195,465 465,660 660,795 795,885
purposes here, we don't need

626
00:15:53,380 --> 00:15:54,340
0,105 105,210 210,435 435,750 750,960
to know this, but we

627
00:15:54,340 --> 00:15:55,645
0,150 150,405 405,770 790,1080 1080,1305
need to understand the basic

628
00:15:55,645 --> 00:15:57,040
0,195 195,450 450,705 705,965 985,1395
implic implementation of what latches

629
00:15:57,040 --> 00:15:58,320
0,150 150,300 300,560 820,1050 1050,1280
are actually doing, so that

630
00:15:58,400 --> 00:15:59,365
0,260 260,365 365,545 545,860 860,965
when you start sprinkling them

631
00:15:59,365 --> 00:16:00,640
0,105 105,255 255,545 685,1050 1050,1275
in your code, you understand

632
00:16:00,640 --> 00:16:02,660
0,105 105,585 585,795 795,1070
the ramifications of them.|
|

633
00:16:06,580 --> 00:16:07,640
0,245 245,365 365,530 530,680 680,1060
You mean p thread mux?
你是说p线多路复用器？我们很快就会讲到这一点，是的。她的问题是，C+UX有什么问题？因此，如果你调用mux和c+，你实际上得到了什么？

634
00:16:07,960 --> 00:16:08,550
0,305 305,365 365,440 440,515 515,590
We'll get to that in

635
00:16:08,550 --> 00:16:09,525
0,60 60,290 370,660 660,810 810,975
a second, yes. Her question

636
00:16:09,525 --> 00:16:10,530
0,305 385,720 720,825 825,930 930,1005
is what's wrong with c

637
00:16:10,530 --> 00:16:12,180
0,165 165,620 1270,1500 1500,1560 1560,1650
plus ux? So if you

638
00:16:12,180 --> 00:16:13,215
0,165 165,525 525,675 675,825 825,1035
call mux and c plus,

639
00:16:13,215 --> 00:16:13,940
0,150 150,210 210,315 315,465 465,725
what do you actually get?|
|

640
00:16:15,940 --> 00:16:18,200
0,400 840,1240
But what?|
但是什么？|

641
00:16:18,400 --> 00:16:20,210
0,275 275,550 1130,1250 1250,1565 1565,1810
Yeah, but who's implementing that?|
是啊，但谁在实施这一点呢？|

642
00:16:21,700 --> 00:16:23,640
0,290 290,580 1260,1640 1640,1865 1865,1940
P thread, but how does
P线程，但是P线程是如何工作的呢？

643
00:16:23,640 --> 00:16:24,820
0,75 75,195 195,330 330,590
A P thread work?|
|

644
00:16:25,840 --> 00:16:33,240
0,350 350,610 750,1150
Tumor slides, okay.|
肿瘤玻片，好的。|

645
00:16:33,670 --> 00:16:35,360
0,305 305,530 530,850 1110,1400 1400,1690
Right, so eh, maybe this
对，所以，呃，也许这就是滑梯。好的，所以最基本的，拿回来，这是数据库世界。接下来我们再来讨论一下OS。所以你实现的最基本的锁存被称为设置和设置旋转锁的测试，称为旋转锁，我意识到我调用的是旋转锁，当真正的锁存时。

646
00:16:35,530 --> 00:16:37,275
0,275 275,550 780,1025 1025,1270 1410,1745
the slide. All right, so

647
00:16:37,275 --> 00:16:38,970
0,180 180,300 300,575 1405,1635 1635,1695
the most basic, take it

648
00:16:38,970 --> 00:16:40,275
0,230 430,690 690,840 840,1065 1065,1305
back, this is database world.

649
00:16:40,275 --> 00:16:41,390
0,285 285,540 540,735 735,855 855,1115
We'll talk OS one next.

650
00:16:41,710 --> 00:16:44,730
0,400 660,920 920,1145 1145,1510 2700,3020
So the most basic latch

651
00:16:44,730 --> 00:16:45,630
0,255 255,510 510,675 675,795 795,900
you implement is called a

652
00:16:45,630 --> 00:16:47,250
0,150 150,315 315,590 970,1305 1305,1620
test to set and set

653
00:16:47,250 --> 00:16:49,440
0,270 270,1860 1860,1965 1965,2070 2070,2190
spin lock called a spin

654
00:16:49,440 --> 00:16:50,235
0,150 150,270 270,420 420,615 615,795
lock, and I realize I'm

655
00:16:50,235 --> 00:16:51,345
0,210 210,450 450,675 675,915 915,1110
calling spin lock when really

656
00:16:51,345 --> 00:16:53,400
0,485
latches.|
|

657
00:16:53,400 --> 00:16:54,450
0,260 460,735 735,870 870,945 945,1050
But this is the most
但这是实现这一点最简单的方法，因为它实际上是一个64位的内存地址，是吗？你只需要做原子比较和交换，看看你是否可以设置它。如果你不能设置它，那么你就旋转，一直试着一遍又一遍地设置它，就像耳垂看起来像这样。我宣布一个原子牛市，这只是一个声明原子的东西的句法展示。然后现在我有了这个，我的闩锁在这里，我把它称为测试和设置，字面上只是试图设置一个检查，看看它是否为当前的值为零。

658
00:16:54,450 --> 00:16:55,290
0,270 270,375 375,480 480,645 645,840
simplest way to implement this

659
00:16:55,290 --> 00:16:56,450
0,195 195,390 390,570 570,810 810,1160
is because it literally is

660
00:16:56,950 --> 00:16:59,450
0,290 290,910 1200,1600 1740,2120 2120,2500
a 64 bit memory address,

661
00:16:59,920 --> 00:17:01,380
0,400 780,1085 1085,1295 1295,1370 1370,1460
eh? That you're just going

662
00:17:01,380 --> 00:17:02,460
0,45 45,165 165,750 750,930 930,1080
to do atomic compare and

663
00:17:02,460 --> 00:17:03,675
0,240 240,560 670,945 945,1065 1065,1215
swap on to see whether

664
00:17:03,675 --> 00:17:04,440
0,150 150,300 300,480 480,645 645,765
you can set it. And

665
00:17:04,440 --> 00:17:05,190
0,75 75,210 210,495 495,630 630,750
if you can't set it,

666
00:17:05,190 --> 00:17:06,090
0,105 105,315 315,570 570,735 735,900
then you spin and keep

667
00:17:06,090 --> 00:17:06,675
0,135 135,240 240,360 360,465 465,585
trying to set it over

668
00:17:06,675 --> 00:17:07,845
0,105 105,255 255,575 655,960 960,1170
and over again like the

669
00:17:07,845 --> 00:17:09,140
0,375 375,630 630,855 855,1005 1005,1295
codevid literally look like this.

670
00:17:09,460 --> 00:17:11,040
0,290 290,725 725,1070 1070,1250 1250,1580
I declare a an atomic

671
00:17:11,040 --> 00:17:12,440
0,500 610,870 870,990 990,1125 1125,1400
bulllean this is just a

672
00:17:12,490 --> 00:17:14,430
0,530 530,785 785,1060 1380,1790 1790,1940
syntactic showirl for declaring something

673
00:17:14,430 --> 00:17:16,245
0,135 135,620 910,1185 1185,1460 1510,1815
that's atomic. And then now

674
00:17:16,245 --> 00:17:17,415
0,165 165,330 330,635 685,960 960,1170
I have this, my latch

675
00:17:17,415 --> 00:17:18,330
0,305 355,600 600,690 690,795 795,915
here and I call it

676
00:17:18,330 --> 00:17:19,245
0,135 135,300 300,495 495,690 690,915
test and set and literally

677
00:17:19,245 --> 00:17:20,820
0,225 225,375 375,540 540,845 1285,1575
just trying to set a

678
00:17:20,820 --> 00:17:21,650
0,165 165,285 285,390 390,510 510,830
check to see whether it's

679
00:17:21,970 --> 00:17:23,680
0,290 290,545 545,910
current value zero.|
|

680
00:17:23,680 --> 00:17:25,570
0,225 225,510 510,860 1270,1590 1590,1890
If, if if. If yes,
如果，如果。如果是，则我可以设置1，并且我可以在单个指令中自动完成该操作。所以这不像如果然后这个然后其他人可以在我之前突然出现并在我之前改变它，它学会了一条指令来应用这个改变。如果我拿不到，我就转圈。

681
00:17:25,570 --> 00:17:26,695
0,285 285,540 540,795 795,975 975,1125
then I can set the

682
00:17:26,695 --> 00:17:27,685
0,275 475,705 705,780 780,885 885,990
one and I can do

683
00:17:27,685 --> 00:17:28,750
0,105 105,210 210,315 315,575 775,1065
that in a single single

684
00:17:28,750 --> 00:17:30,025
0,410 460,860 880,1110 1110,1215 1215,1275
instruction automatically. So it's not

685
00:17:30,025 --> 00:17:31,105
0,120 120,330 330,600 600,870 870,1080
like if then this then

686
00:17:31,105 --> 00:17:32,100
0,225 225,450 450,585 585,720 720,995
that somebody else can come

687
00:17:32,240 --> 00:17:33,355
0,290 290,550 630,890 890,1010 1010,1115
swoop in and change it

688
00:17:33,355 --> 00:17:35,340
0,245 685,1085 1135,1455 1455,1680 1680,1985
before I before I can,

689
00:17:35,480 --> 00:17:37,015
0,245 245,470 470,620 620,1060 1290,1535
it learns one instruction to

690
00:17:37,015 --> 00:17:38,425
0,245 265,540 540,690 690,965 1165,1410
go apply this change. And

691
00:17:38,425 --> 00:17:39,175
0,90 90,225 225,480 480,600 600,750
if I can't get it,

692
00:17:39,175 --> 00:17:40,520
0,120 120,225 225,420 420,755
then I just spin.|
|

693
00:17:40,590 --> 00:17:41,330
0,260 260,410 410,530 530,665 665,740
Because we're doing this in
因为我们是在数据库、数据库级别和用户群中执行此操作，所以我们可以决定是要重试多少次，还是要放弃对操作系统的威胁，还是放弃并重新启动。

694
00:17:41,330 --> 00:17:43,130
0,90 90,350 490,890 940,1340 1540,1800
the database, database level and

695
00:17:43,130 --> 00:17:44,435
0,195 195,530 700,960 960,1110 1110,1305
user base, we can decide

696
00:17:44,435 --> 00:17:45,125
0,210 210,360 360,465 465,585 585,690
whether, how many times we

697
00:17:45,125 --> 00:17:46,505
0,90 90,180 180,635 895,1155 1155,1380
want to retry, whether we

698
00:17:46,505 --> 00:17:47,345
0,225 225,360 360,525 525,690 690,840
want to yield the threat

699
00:17:47,345 --> 00:17:48,830
0,105 105,240 240,545 775,1095 1095,1485
to the OS or abort

700
00:17:48,830 --> 00:17:50,120
0,240 240,390 390,800
ourselves and restart.|
|

701
00:17:50,970 --> 00:17:52,080
0,400
Right.|
正确的。|

702
00:17:53,190 --> 00:17:54,940
0,275 275,395 395,515 515,790
Why is this bad?|
为什么这很糟糕？|

703
00:17:56,860 --> 00:18:02,715
0,490 3330,3730 4650,5050 5310,5615 5615,5855
What's you busy? So you're
你在忙什么？所以你基本上是在旋转循环，旋转cp u？检查，检查，检查。一遍又一遍。我可以这么说。

704
00:18:02,715 --> 00:18:04,185
0,245 325,675 675,810 810,1085 1135,1470
basically spinning the cycle, spinning

705
00:18:04,185 --> 00:18:05,340
0,105 105,300 300,515 685,960 960,1155
the cp u? Check, check,

706
00:18:05,340 --> 00:18:06,200
0,195 195,330 330,420 420,555 555,860
check. Over and over again.

707
00:18:06,970 --> 00:18:08,030
0,260 260,380 380,515 515,725 725,1060
I could put maybe like.|
|

708
00:18:08,660 --> 00:18:10,880
0,180 180,440 460,720 720,980 1600,2220
I could put a exponential
我可以把指数放回去说，好的，我试着得到，我不能得到，等一毫秒，两毫秒，四毫秒，对吗？

709
00:18:10,880 --> 00:18:11,945
0,165 165,465 465,720 720,915 915,1065
back off to say, OK,

710
00:18:11,945 --> 00:18:12,500
0,75 75,195 195,300 300,420 420,555
I tried to get, I

711
00:18:12,500 --> 00:18:13,745
0,180 180,270 270,530 700,1035 1035,1245
couldn't get it, wait one

712
00:18:13,745 --> 00:18:15,260
0,435 435,660 660,1035 1035,1140 1140,1515
millisecond, two milliseconds, four milliseconds,

713
00:18:15,260 --> 00:18:16,100
0,260
right?|
|

714
00:18:16,810 --> 00:18:18,080
0,400
Um.|
恩。|

715
00:18:18,210 --> 00:18:20,090
0,320 320,640 1140,1475 1475,1805 1805,1880
Actually, the, so that's a
事实上，这是一个挑战，你只是一遍又一遍地旋转。另一个问题将是现金一致性流量。

716
00:18:20,090 --> 00:18:21,650
0,260 430,765 765,1035 1035,1260 1260,1560
challenge that you're just spinning

717
00:18:21,650 --> 00:18:22,700
0,60 60,120 120,255 255,560 730,1050
over and over again. Another

718
00:18:22,700 --> 00:18:23,210
0,180 180,285 285,345 345,390 390,510
problem is going to be

719
00:18:23,210 --> 00:18:24,740
0,195 195,510 510,830
cash coherence traffic.|
|

720
00:18:24,740 --> 00:18:25,790
0,255 255,450 450,645 645,885 885,1050
Right. So again, assuming I
正确的。所以，再一次，假设我有一个双插槽CPU，我想要获取的闩锁在这个NUMA区域上，知道NUMA是什么。

721
00:18:25,790 --> 00:18:27,250
0,225 225,465 465,630 630,975 975,1460
have a two socket cpu,

722
00:18:27,630 --> 00:18:29,315
0,400 960,1280 1280,1490 1490,1565 1565,1685
the latch I'm trying to

723
00:18:29,315 --> 00:18:30,665
0,285 285,555 555,845 865,1170 1170,1350
acquire is over here on

724
00:18:30,665 --> 00:18:32,615
0,240 240,525 525,825 825,1085 1705,1950
this this numa region, know

725
00:18:32,615 --> 00:18:34,060
0,120 120,360 360,605
what numa is.|
|

726
00:18:34,360 --> 00:18:35,850
0,380 380,725 725,950 950,1160 1160,1490
Eh, non uniform memory access,
呃，非均匀内存访问，基本上就像我的c中有两个插槽，我的主板上有两个两个插槽或两个或更多个插槽，每个CPU插槽都会有接近它的DRAM，与之交谈真的很快。

727
00:18:35,850 --> 00:18:36,690
0,330 330,540 540,630 630,705 705,840
basically like if I have

728
00:18:36,690 --> 00:18:37,730
0,195 195,570 570,660 660,765 765,1040
two sockets in my c,

729
00:18:37,780 --> 00:18:39,045
0,335 335,560 560,860 860,1070 1070,1265
two two sockets or two

730
00:18:39,045 --> 00:18:39,765
0,105 105,240 240,450 450,540 540,720
or more sockets on my

731
00:18:39,765 --> 00:18:42,405
0,545 1045,1445 1765,2235 2235,2565 2565,2640
motherboard, each cpu sockets is

732
00:18:42,405 --> 00:18:43,440
0,75 75,150 150,395 565,855 855,1035
going to have d Ram

733
00:18:43,440 --> 00:18:44,730
0,240 240,405 405,555 555,800 1060,1290
that's close to it and

734
00:18:44,730 --> 00:18:45,735
0,180 180,390 390,660 660,855 855,1005
it's really fast to talk

735
00:18:45,735 --> 00:18:46,680
0,135 135,395
to that.|
|

736
00:18:46,680 --> 00:18:48,150
0,180 180,345 345,615 615,1010 1180,1470
But I can also talk
但我也可以与另一个插座上的内存交谈，我称之为NUMA区域，但流量要慢得多，因为我必须通过一个插座到另一个插座之间的互连，对吧。

737
00:18:48,150 --> 00:18:49,995
0,180 180,420 420,1410 1410,1650 1650,1845
to memory that's over on

738
00:18:49,995 --> 00:18:51,660
0,240 240,785 955,1185 1185,1415 1435,1665
another socket, and I call

739
00:18:51,660 --> 00:18:52,755
0,60 60,150 150,375 375,620 820,1095
it a numa region, but

740
00:18:52,755 --> 00:18:54,015
0,275 355,675 675,915 915,1095 1095,1260
that that traffic is much

741
00:18:54,015 --> 00:18:54,765
0,270 270,450 450,555 555,660 660,750
slower because I got to

742
00:18:54,765 --> 00:18:55,905
0,75 75,165 165,315 315,870 870,1140
go over this interconnect between

743
00:18:55,905 --> 00:18:56,900
0,210 210,540 540,630 630,735 735,995
one socket to the other,

744
00:18:57,220 --> 00:18:58,260
0,400
right.|
|

745
00:18:58,260 --> 00:18:59,730
0,135 135,410 520,1140 1140,1380 1380,1470
And so Intel, they do
因此，英特尔做了很多工作，以确保当你编写程序时，你不知道，从技术上讲，你不需要知道内存的实际位置。但当然，现在你可以让你的程序访问另一个套接字上的东西，它变得非常慢，恐怖分子试图玩游戏，移动东西，因为你试图加快速度。我们可以暂时忽略这一点。对于这门课，我们不必担心Numa。我只是想解释一下。

746
00:18:59,730 --> 00:19:00,210
0,75 75,180 180,285 285,390 390,480
a lot of work to

747
00:19:00,210 --> 00:19:01,290
0,105 105,380 550,795 795,915 915,1080
make sure when you write

748
00:19:01,290 --> 00:19:02,775
0,290 310,585 585,870 870,1130 1150,1485
programs you don't know and

749
00:19:02,775 --> 00:19:04,560
0,335 625,1110 1110,1440 1440,1665 1665,1785
and don't technically have to

750
00:19:04,560 --> 00:19:05,850
0,260 430,735 735,1005 1005,1200 1200,1290
know where memory actually is

751
00:19:05,850 --> 00:19:07,455
0,260 460,860 1180,1410 1410,1470 1470,1605
physically located. But of course,

752
00:19:07,455 --> 00:19:08,925
0,240 240,420 420,525 525,785 1195,1470
now you could have your

753
00:19:08,925 --> 00:19:10,230
0,275 535,795 795,975 975,1200 1200,1305
program access something that's on

754
00:19:10,230 --> 00:19:11,355
0,195 195,705 705,945 945,1020 1020,1125
another socket and it gets

755
00:19:11,355 --> 00:19:12,705
0,270 270,665 775,1035 1035,1155 1155,1350
really slow and the horror

756
00:19:12,705 --> 00:19:13,665
0,210 210,390 390,585 585,795 795,960
tries to play games and

757
00:19:13,665 --> 00:19:14,430
0,120 120,315 315,540 540,675 675,765
move things around for you

758
00:19:14,430 --> 00:19:15,170
0,105 105,210 210,330 330,465 465,740
try to speed things up.

759
00:19:15,400 --> 00:19:16,365
0,245 245,490 510,755 755,860 860,965
We can ignore that for

760
00:19:16,365 --> 00:19:16,995
0,120 120,255 255,360 360,480 480,630
now. And for this class

761
00:19:16,995 --> 00:19:17,370
0,105 105,210 210,240 240,285 285,375
we don't have to worry

762
00:19:17,370 --> 00:19:17,985
0,135 135,375 375,450 450,540 540,615
about numa. I just want

763
00:19:17,985 --> 00:19:19,740
0,120 120,425 745,1145
to explain that.|
|

764
00:19:19,750 --> 00:19:22,140
0,400 420,820 1680,1955 1955,2165 2165,2390
This, this, a worker running
这个，这个，一个在这个，这边这个CPU上运行的工作人员想要获取这个另一个插槽CPU内存中的闩锁。所以它会不停地旋转，一次又一次地旋转。但现在，这个互连上的所有流量将使我的整个数据库系统变慢。这是低效的，因为我在旋转，而且实际硬件上的流量本身也很昂贵。

765
00:19:22,140 --> 00:19:23,535
0,135 135,380 550,930 930,1290 1290,1395
on this, this cpu over

766
00:19:23,535 --> 00:19:25,200
0,275 535,840 840,1035 1035,1355 1405,1665
here wants to acquire the

767
00:19:25,200 --> 00:19:27,255
0,290 610,1010 1240,1515 1515,1695 1695,2055
latch in this other socket

768
00:19:27,255 --> 00:19:29,430
0,285 285,545 1675,1935 1935,2115 2115,2175
cpu memory. So it's going

769
00:19:29,430 --> 00:19:30,075
0,75 75,225 225,465 465,540 540,645
to keep spinning and over

770
00:19:30,075 --> 00:19:31,395
0,135 135,255 255,375 375,635 985,1320
it again. But now it's

771
00:19:31,395 --> 00:19:32,340
0,120 120,330 330,600 600,810 810,945
all this traffic over this

772
00:19:32,340 --> 00:19:34,760
0,560 1630,1965 1965,2040 2040,2145 2145,2420
interconnect that's going to slow

773
00:19:35,200 --> 00:19:36,440
0,290 290,455 455,665 665,920 920,1240
my entire database system down.

774
00:19:37,630 --> 00:19:38,565
0,245 245,320 320,395 395,815 815,935
So this is inefficient because

775
00:19:38,565 --> 00:19:39,630
0,180 180,450 450,660 660,885 885,1065
I'm spinning, but also like

776
00:19:39,630 --> 00:19:40,860
0,225 225,560 610,900 900,1080 1080,1230
the traffic on the actual

777
00:19:40,860 --> 00:19:43,060
0,240 240,620 820,1220 1240,1640
hardware itself is expensive.|
|

778
00:19:44,830 --> 00:19:45,950
0,245 245,395 395,590 590,800 800,1120
So now her question is,
所以现在她的问题是，你知道为什么，出了什么问题吗？或者CA plus互斥实际上是如何工作的？

779
00:19:46,180 --> 00:19:47,445
0,260 260,395 395,670 690,1055 1055,1265
you know why, what's wrong?

780
00:19:47,445 --> 00:19:49,040
0,365 565,825 825,1035 1035,1290 1290,1595
Or how does actually the

781
00:19:49,600 --> 00:19:50,870
0,350 350,485 485,815 815,1010 1010,1270
CA plus mutex actually work?|
|

782
00:19:51,410 --> 00:19:52,555
0,400 480,755 755,890 890,1010 1010,1145
So this is called a
因此，这被称为阻止用户体验。它是最容易使用的，因为它是内置在c++中的。

783
00:19:52,555 --> 00:19:54,175
0,315 315,725 925,1245 1245,1335 1335,1620
blocking ux. It's the easiest

784
00:19:54,175 --> 00:19:55,600
0,150 150,285 285,545 565,965 1135,1425
thing to use because it's

785
00:19:55,600 --> 00:19:56,370
0,90 90,225 225,345 345,480 480,770
built in c plus plus.|
|

786
00:19:59,670 --> 00:20:01,090
0,335 335,545 545,815 815,1100 1100,1420
Basically, you acquire and release.
基本上，你获得并释放。它没有太多的机制，你使用它的方式，它有点像这样。你锁上它，再解锁，在中间做你想做的任何事情。

787
00:20:01,530 --> 00:20:02,195
0,320 320,395 395,470 470,545 545,665
There's not a lot of

788
00:20:02,195 --> 00:20:04,565
0,495 495,690 690,965 1945,2235 2235,2370
mechanisms in it and the

789
00:20:04,565 --> 00:20:05,150
0,105 105,210 210,330 330,450 450,585
way you use it, it's

790
00:20:05,150 --> 00:20:06,095
0,75 75,150 150,255 255,530 670,945
sort of like this. You

791
00:20:06,095 --> 00:20:07,490
0,180 180,345 345,450 450,845 1105,1395
lock it and unlock, do

792
00:20:07,490 --> 00:20:07,985
0,135 135,225 225,315 315,405 405,495
whatever you want in the

793
00:20:07,985 --> 00:20:08,940
0,245
middle.|
|

794
00:20:09,280 --> 00:20:11,120
0,400 900,1175 1175,1355 1355,1550 1550,1840
So I asked her, how
所以我问她，这件事到底是如何实施的？有人知道吗？

795
00:20:11,380 --> 00:20:12,330
0,245 245,350 350,530 530,740 740,950
is this thing actually implemented?

796
00:20:12,330 --> 00:20:13,740
0,195 195,375 375,680
Is anybody know?|
|

797
00:20:14,660 --> 00:20:15,565
0,230 230,290 290,380 380,590 590,905
So if you call cd
所以，如果你叫cd muutex，你在c+中得到了什么？

798
00:20:15,565 --> 00:20:16,420
0,390 390,570 570,645 645,735 735,855
muutex, what do you get

799
00:20:16,420 --> 00:20:17,740
0,105 105,180 180,285 285,560
in c plus plus?|
|

800
00:20:20,340 --> 00:20:21,960
0,260 260,820
P threadutex.|
P线程。|

801
00:20:22,350 --> 00:20:23,360
0,245 245,365 365,500 500,635 635,1010
How is p thread mutex
P线程互斥是如何实现的？

802
00:20:23,360 --> 00:20:24,380
0,350
implemented?|
|

803
00:20:26,570 --> 00:20:27,600
0,305 305,365 365,470 470,605 605,1030
It's called a few texts.
这叫几条短信。禅宗Linux。我之前听过几条短信。

804
00:20:27,710 --> 00:20:29,950
0,275 275,640 1770,2015 2015,2120 2120,2240
Zen Linux. Heard a few

805
00:20:29,950 --> 00:20:31,180
0,180 180,410
texts before.|
|

806
00:20:31,670 --> 00:20:33,760
0,380 380,710 710,980 980,1450 1860,2090
Fast user space mutex so
快速的用户空间互斥，所以它的工作方式是。

807
00:20:33,760 --> 00:20:34,770
0,90 90,270 270,450 450,660 660,1010
the way it works is.|
|

808
00:20:35,660 --> 00:20:36,830
0,165 165,435 435,735 735,975 975,1170
It has the spin block
它有我在上一张幻灯片中展示的旋转块。在用户空间，他们会有他们自己的小测试和设置，你可以做，但如果你做不到，如果你试图获得它，但你做不到。

809
00:20:36,830 --> 00:20:37,310
0,120 120,195 195,300 300,405 405,480
that I just showed in

810
00:20:37,310 --> 00:20:38,390
0,60 60,240 240,540 540,795 795,1080
the last slide. In user

811
00:20:38,390 --> 00:20:39,560
0,300 300,570 570,795 795,1020 1020,1170
space, they'll have their own

812
00:20:39,560 --> 00:20:40,505
0,210 210,405 405,555 555,735 735,945
little test and set thing

813
00:20:40,505 --> 00:20:41,795
0,150 150,285 285,575 955,1200 1200,1290
you can do, but if

814
00:20:41,795 --> 00:20:42,740
0,135 135,540 540,705 705,810 810,945
you can't, if you try

815
00:20:42,740 --> 00:20:43,475
0,135 135,345 345,480 480,555 555,735
to acquire it and you

816
00:20:43,475 --> 00:20:44,600
0,545
can't.|
|

817
00:20:45,180 --> 00:20:46,295
0,275 275,440 440,680 680,950 950,1115
Then you fall back to
然后，您将退回到内核中的重量级互斥体。

818
00:20:46,295 --> 00:20:48,455
0,135 135,420 420,1085 1405,1935 1935,2160
a heavy heavyweight mutex inside

819
00:20:48,455 --> 00:20:49,640
0,165 165,605
the kernel.|
|

820
00:20:49,740 --> 00:20:51,710
0,400 870,1175 1175,1475 1475,1790 1790,1970
So, so if if no
所以，如果没有人拿着一个有几条短信的闩锁，我会尝试获取它。如果没有人持有它，那么我只需在用户空间中进行比较并真正快速地交换即可。我受够了。而我，我的线一直在运行。如果我不能得到它，那么操作系统。

821
00:20:51,710 --> 00:20:52,835
0,120 120,255 255,390 390,680 880,1125
one holds a latch with

822
00:20:52,835 --> 00:20:53,480
0,105 105,240 240,435 435,525 525,645
a few texts, I try

823
00:20:53,480 --> 00:20:54,530
0,120 120,315 315,620 640,915 915,1050
to acquire it. If no

824
00:20:54,530 --> 00:20:55,280
0,135 135,300 300,495 495,645 645,750
one holds it, then I

825
00:20:55,280 --> 00:20:56,090
0,150 150,300 300,465 465,645 645,810
just do a compare and

826
00:20:56,090 --> 00:20:57,725
0,270 270,570 570,825 825,1130 1360,1635
swap real real fast in

827
00:20:57,725 --> 00:20:58,940
0,225 225,575 625,870 870,1035 1035,1215
user space. And I'm done.

828
00:20:58,940 --> 00:21:00,860
0,210 210,470 730,1130 1450,1740 1740,1920
And I, my thread keeps

829
00:21:00,860 --> 00:21:02,270
0,290 460,720 720,930 930,1275 1275,1410
running. If I can't get

830
00:21:02,270 --> 00:21:03,880
0,285 285,540 540,690 690,980
it, then the OS.|
|

831
00:21:03,920 --> 00:21:05,035
0,365 365,590 590,695 695,905 905,1115
Takes control of us and
控制了我们，我们现在进入内核，然后我们变得松散，因为它知道我不能运行，直到我等待的东西可用。

832
00:21:05,035 --> 00:21:06,070
0,105 105,255 255,480 480,735 735,1035
we go down now into

833
00:21:06,070 --> 00:21:07,615
0,240 240,650 910,1185 1185,1365 1365,1545
the kernel and then we

834
00:21:07,615 --> 00:21:08,875
0,150 150,720 720,870 870,1005 1005,1260
get decheduled because it knows

835
00:21:08,875 --> 00:21:10,320
0,285 285,510 510,795 795,1050 1050,1445
that I can't run until

836
00:21:10,340 --> 00:21:11,380
0,320 320,500 500,695 695,860 860,1040
the thing I'm waiting for

837
00:21:11,380 --> 00:21:12,580
0,150 150,440
is available.|
|

838
00:21:12,925 --> 00:21:13,420
0,75 75,165 165,300 300,405 405,495
But what's down in the
但是内核里到底有什么呢？他们是如何跟踪线程的？

839
00:21:13,420 --> 00:21:14,290
0,285 285,435 435,570 570,720 720,870
kernel? How they keep track

840
00:21:14,290 --> 00:21:15,520
0,150 150,620
of threads?|
|

841
00:21:16,890 --> 00:21:18,200
0,260 260,520
With that.|
有了这一点。|

842
00:21:18,590 --> 00:21:20,020
0,230 230,305 305,395 395,640
So I say that.|
所以我这么说。|

843
00:21:20,020 --> 00:21:21,390
0,345 345,525 525,660 660,920 970,1370
Blocking queue, but like, what?|
阻塞队列，但就像，什么？|

844
00:21:22,510 --> 00:21:24,460
0,180 180,530
There's also.|
还有一种。|

845
00:21:24,560 --> 00:21:26,455
0,980 980,1295 1295,1670 1670,1790 1790,1895
There's the scheduler has its
调度器有自己的哈希表来跟踪哪些线程正在运行，所以它们使用自己的锁存器来保护数据结构。因此，如果我不能获得这一点，我会进入内核，我会被取消调度，这是非常非常昂贵的。系统通话费用很高。我们想避开他们，对吗？

846
00:21:26,455 --> 00:21:27,280
0,120 120,375 375,540 540,690 690,825
own hash table to keep

847
00:21:27,280 --> 00:21:28,150
0,165 165,360 360,585 585,780 780,870
track of what threads are

848
00:21:28,150 --> 00:21:30,490
0,260 730,1130 1840,2100 2100,2220 2220,2340
running, so they use their

849
00:21:30,490 --> 00:21:31,390
0,165 165,465 465,585 585,735 735,900
own latches to protect that

850
00:21:31,390 --> 00:21:32,965
0,210 210,530 760,1155 1155,1425 1425,1575
data structure. So if I

851
00:21:32,965 --> 00:21:34,075
0,255 255,510 510,765 765,960 960,1110
can't acquire this, I go

852
00:21:34,075 --> 00:21:34,885
0,150 150,255 255,360 360,675 675,810
down in the kernel and

853
00:21:34,885 --> 00:21:35,845
0,90 90,195 195,660 660,765 765,960
I get descheduled and that's

854
00:21:35,845 --> 00:21:36,850
0,165 165,345 345,570 570,825 825,1005
very, very expensive. Sys calls

855
00:21:36,850 --> 00:21:37,630
0,180 180,390 390,570 570,690 690,780
are expensive. We want to

856
00:21:37,630 --> 00:21:39,540
0,150 150,440 820,1220
avoid them, right?|
|

857
00:21:39,710 --> 00:21:40,810
0,395 395,710 710,890 890,995 995,1100
Right. So this is just
正确的。这就是像这样的图表。同样，我让我的两个工人运行不同的套接字。他们两个都试图在同一时间相当。其中一个将获得用户空间闩锁。另一个人试图下去拿操作系统门锁，他们得到了正确的取消日程安排。

858
00:21:40,810 --> 00:21:42,040
0,105 105,360 360,495 495,770 910,1230
the diagram like this. So

859
00:21:42,040 --> 00:21:43,330
0,255 255,435 435,585 585,890 940,1290
again, I have my two

860
00:21:43,330 --> 00:21:44,700
0,210 210,450 450,720 720,900 900,1370
two workers running different sockets.

861
00:21:45,020 --> 00:21:45,745
0,275 275,425 425,545 545,635 635,725
They both try to quite

862
00:21:45,745 --> 00:21:46,795
0,60 60,120 120,255 255,545 775,1050
at the same time. One

863
00:21:46,795 --> 00:21:47,410
0,105 105,240 240,405 405,525 525,615
of them will get the

864
00:21:47,410 --> 00:21:48,580
0,150 150,345 345,680 820,1050 1050,1170
user space latch. The other

865
00:21:48,580 --> 00:21:49,270
0,225 225,435 435,525 525,600 600,690
guy tries to go down

866
00:21:49,270 --> 00:21:49,870
0,60 60,120 120,195 195,345 345,600
and get the OS latch

867
00:21:49,870 --> 00:21:50,530
0,180 180,285 285,420 420,555 555,660
and they get they get

868
00:21:50,530 --> 00:21:52,340
0,560 670,1070
descheduled right.|
|

869
00:21:52,830 --> 00:21:53,900
0,350 350,590 590,755 755,920 920,1070
And again, this is, this
再一次，这是，这是缓慢的，因为任何时候你涉及到操作系统，这是糟糕的。

870
00:21:53,900 --> 00:21:55,055
0,180 180,420 420,630 630,1005 1005,1155
is slow because anytime you

871
00:21:55,055 --> 00:21:56,165
0,165 165,345 345,570 570,870 870,1110
involve the OS, this is

872
00:21:56,165 --> 00:21:57,120
0,275
bad.|
|

873
00:22:00,040 --> 00:22:02,085
0,400 540,875 875,1160 1160,1510 1770,2045
So the last two first
所以我展示的最后两个前两个睫毛，它们并没有真的有模式，只是要么全有要么全无。因此，您在一个。

874
00:22:02,085 --> 00:22:02,850
0,120 120,345 345,450 450,570 570,765
two lashes I showed you,

875
00:22:02,850 --> 00:22:04,035
0,195 195,330 330,450 450,690 690,1185
they didn't really have modes,

876
00:22:04,035 --> 00:22:05,040
0,120 120,210 210,455 595,870 870,1005
it was just all or

877
00:22:05,040 --> 00:22:06,600
0,260 940,1215 1215,1350 1350,1440 1440,1560
nothing. And so the way

878
00:22:06,600 --> 00:22:08,240
0,180 180,435 435,800 880,1260 1260,1640
you implement this in a.|
|

879
00:22:09,790 --> 00:22:11,265
0,350 350,700 810,1085 1085,1265 1265,1475
In in in t plus
在in in t加上读、写或闩锁的情况下，你可以使用共享互斥。我想我们，我们，我们在总线盒EM中做读写锁，这只是一个P线程重写锁。而这基本上是工作的方式是，闩锁本身将有自己的优先提示。它自己的计数器记录有多少线程在等待。实际上，您可以找到该、该、该闩锁本身的调度策略。所以这里的想法是，如果我有一个A读取器线程出现，一旦合唱团锁存，我去检查是否有人在等待锁存或锁存在读模式或写模式下读取。如果它可用，那么我递增我的计数器，说现在有人在控制反击，我继续做我想做的任何事情。

880
00:22:11,265 --> 00:22:11,940
0,150 150,240 240,390 390,555 555,675
with the read, write or

881
00:22:11,940 --> 00:22:13,170
0,290 520,765 765,870 870,1035 1035,1230
latch you can use shared

882
00:22:13,170 --> 00:22:14,235
0,435 435,645 645,750 750,915 915,1065
muutex. I think we we

883
00:22:14,235 --> 00:22:15,290
0,120 120,255 255,480 480,675 675,1055
do the readwr write eh

884
00:22:15,340 --> 00:22:17,240
0,400 510,910 990,1355 1355,1610 1610,1900
lock in in bus tub

885
00:22:17,530 --> 00:22:18,570
0,400 450,710 710,815 815,920 920,1040
EM which is just A

886
00:22:18,570 --> 00:22:20,270
0,135 135,270 270,510 510,770 1300,1700
P thread rewrite lock. And

887
00:22:20,380 --> 00:22:21,465
0,245 245,380 380,545 545,800 800,1085
the way this basically works

888
00:22:21,465 --> 00:22:22,710
0,165 165,360 360,570 570,875 925,1245
is that the latch itself

889
00:22:22,710 --> 00:22:23,295
0,180 180,285 285,360 360,465 465,585
is going to have its

890
00:22:23,295 --> 00:22:24,825
0,135 135,420 420,1025 1075,1320 1320,1530
own priority cues. Its own

891
00:22:24,825 --> 00:22:25,815
0,450 450,630 630,780 780,900 900,990
counterters keep track of like

892
00:22:25,815 --> 00:22:26,660
0,90 90,240 240,465 465,570 570,845
how many threads are waiting.

893
00:22:27,040 --> 00:22:28,380
0,320 320,500 500,680 680,1000 1020,1340
You actually can find the

894
00:22:28,380 --> 00:22:30,830
0,405 405,680 910,1310 1330,1730 2050,2450
scheduling policy for the the,

895
00:22:31,330 --> 00:22:33,080
0,335 335,670 930,1190 1190,1415 1415,1750
the, the the latch itself.

896
00:22:33,610 --> 00:22:34,620
0,245 245,410 410,680 680,890 890,1010
So the idea here is

897
00:22:34,620 --> 00:22:36,200
0,260 580,885 885,1095 1095,1290 1290,1580
that if I have A

898
00:22:37,270 --> 00:22:38,480
0,260 260,470 470,710 710,905 905,1210
A reader thread comes along

899
00:22:38,770 --> 00:22:39,555
0,260 260,380 380,485 485,665 665,785
and once the choir the

900
00:22:39,555 --> 00:22:40,740
0,275 475,735 735,900 900,1065 1065,1185
latch, I go check to

901
00:22:40,740 --> 00:22:42,195
0,120 120,315 315,770 940,1275 1275,1455
see whether anybody waiting for

902
00:22:42,195 --> 00:22:44,115
0,195 195,525 525,690 690,935 1615,1920
the latch or the latch

903
00:22:44,115 --> 00:22:44,745
0,120 120,240 240,390 390,525 525,630
reading in read mode or

904
00:22:44,745 --> 00:22:46,820
0,135 135,425 1345,1605 1605,1800 1800,2075
write mode. If it's available

905
00:22:46,930 --> 00:22:48,075
0,290 290,530 530,815 815,950 950,1145
then I increment my counter

906
00:22:48,075 --> 00:22:49,310
0,165 165,300 300,675 675,885 885,1235
to say somebody's holding the

907
00:22:49,540 --> 00:22:50,790
0,260 260,605 605,860 860,1025 1025,1250
the relash now and I

908
00:22:50,790 --> 00:22:51,570
0,255 255,375 375,495 495,645 645,780
go ahead and do whatever

909
00:22:51,570 --> 00:22:52,360
0,120 120,380
I want.|
|

910
00:22:52,360 --> 00:22:53,155
0,210 210,330 330,480 480,645 645,795
And now if anybody else
现在，如果其他人也出现了在读取模式下获取的内容，系统就会知道我就是那个锁存知道我现在处于读取模式的人，这样它就可以让其他人也运行。但现在，如果出现写入锁存写入工作器，尝试获取锁存，我们就有两个读取读取工作器已经持有锁存和读取模式。因此，它将不得不停止，它们维护一个内部优先级队列，以跟踪哪些线程正在等待此操作。

911
00:22:53,155 --> 00:22:54,265
0,165 165,450 450,705 705,930 930,1110
comes along also what's acquired

912
00:22:54,265 --> 00:22:55,465
0,165 165,315 315,605 745,1005 1005,1200
in read mode, the system

913
00:22:55,465 --> 00:22:57,295
0,270 270,615 615,935 1015,1415 1465,1830
knows I'm the the latch

914
00:22:57,295 --> 00:22:58,285
0,270 270,525 525,645 645,825 825,990
knows I'm in read mode

915
00:22:58,285 --> 00:22:59,320
0,150 150,425 565,810 810,915 915,1035
right now so it can

916
00:22:59,320 --> 00:23:00,400
0,135 135,255 255,375 375,650 820,1080
let the other guy run

917
00:23:00,400 --> 00:23:01,860
0,135 135,410 820,1065 1065,1185 1185,1460
as well. But now if

918
00:23:02,030 --> 00:23:03,355
0,245 245,425 425,680 680,1025 1025,1325
if a write latch write

919
00:23:03,355 --> 00:23:04,930
0,225 225,465 465,785 1045,1350 1350,1575
worker comes along, tries acquire

920
00:23:04,930 --> 00:23:06,340
0,135 135,410 760,1020 1020,1200 1200,1410
the latch, we have two

921
00:23:06,340 --> 00:23:08,530
0,290 520,840 840,1160 1360,1760 1870,2190
read read workers already holding

922
00:23:08,530 --> 00:23:09,390
0,150 150,285 285,420 420,570 570,860
the latch and read mode.

923
00:23:09,590 --> 00:23:10,210
0,245 245,410 410,470 470,530 530,620
So it's going to have

924
00:23:10,210 --> 00:23:11,190
0,165 165,405 405,585 585,705 705,980
to stall and they maintain

925
00:23:11,210 --> 00:23:12,955
0,320 320,640 1050,1430 1430,1670 1670,1745
an internal priority queue to

926
00:23:12,955 --> 00:23:14,005
0,135 135,315 315,555 555,810 810,1050
keep track of what threads

927
00:23:14,005 --> 00:23:15,220
0,105 105,285 285,450 450,695
are waiting for this.|
|

928
00:23:15,290 --> 00:23:16,300
0,245 245,470 470,740 740,875 875,1010
So then, depending on the
然后，根据策略，如果出现另一个线程，您可以在锁存器中进行配置，然后再次在读取模式下进行配置，理论上我可以获取它，因为它与所有其他锁存器或将其保持在读取模式下的工作器是可交换的。我马上就能把它弄好。但您可以将策略设置为说我知道另一个线程正在以正确的模式等待它。因此，让我继续下去，让它睡着吧。

929
00:23:16,300 --> 00:23:17,455
0,285 285,540 540,690 690,1005 1005,1155
policy, you can configure in

930
00:23:17,455 --> 00:23:18,940
0,120 120,395 685,990 990,1245 1245,1485
the latch if another thread

931
00:23:18,940 --> 00:23:20,275
0,210 210,530 820,1065 1065,1200 1200,1335
comes along, then once again

932
00:23:20,275 --> 00:23:21,415
0,105 105,270 270,575 715,960 960,1140
in read mode and in

933
00:23:21,415 --> 00:23:22,690
0,335 385,690 690,900 900,1080 1080,1275
theory I could, I could

934
00:23:22,690 --> 00:23:24,505
0,285 285,620 820,1170 1170,1440 1440,1815
acquire it because it's commutative

935
00:23:24,505 --> 00:23:25,465
0,120 120,255 255,375 375,525 525,960
with all the other latches

936
00:23:25,465 --> 00:23:26,560
0,180 180,455 505,825 825,990 990,1095
or the workers that hold

937
00:23:26,560 --> 00:23:27,700
0,90 90,180 180,330 330,620 850,1140
it in read mode. I

938
00:23:27,700 --> 00:23:28,560
0,135 135,240 240,375 375,555 555,860
could it quite right away.

939
00:23:28,700 --> 00:23:29,680
0,350 350,545 545,680 680,845 845,980
But you can set the

940
00:23:29,680 --> 00:23:30,720
0,225 225,435 435,555 555,735 735,1040
policy to say I know

941
00:23:30,800 --> 00:23:32,035
0,335 335,545 545,680 680,940 990,1235
another thread is waiting for

942
00:23:32,035 --> 00:23:33,175
0,90 90,225 225,405 405,695 895,1140
it in right mode. So

943
00:23:33,175 --> 00:23:33,960
0,90 90,180 180,300 300,480 480,785
let me go ahead and

944
00:23:34,280 --> 00:23:35,400
0,245 245,335 335,470 470,760
put it to sleep.|
|

945
00:23:36,290 --> 00:23:37,500
0,400
Right.|
正确的。|

946
00:23:37,510 --> 00:23:38,340
0,260 260,380 380,515 515,665 665,830
And in c plus plus,
在c++中，我认为它们都是在用户空间中完成的，不是在内核中，而是，当你不得不阻塞并等待你要寻找的闩锁时，那将是一个我们不想做的Osnel操作系统互斥锁。

947
00:23:38,340 --> 00:23:39,285
0,150 150,285 285,660 660,780 780,945
I think they're doing this

948
00:23:39,285 --> 00:23:40,485
0,210 210,450 450,645 645,900 900,1200
all in in user space,

949
00:23:40,485 --> 00:23:41,340
0,255 255,465 465,630 630,750 750,855
not, not down in the

950
00:23:41,340 --> 00:23:42,900
0,225 225,435 435,800 1090,1395 1395,1560
kernel, but, but when you

951
00:23:42,900 --> 00:23:43,980
0,135 135,285 285,560 580,885 885,1080
have to then block and

952
00:23:43,980 --> 00:23:45,045
0,225 225,525 525,765 765,930 930,1065
wait for the require the

953
00:23:45,045 --> 00:23:46,125
0,165 165,345 345,495 495,810 810,1080
latch you're looking for, then

954
00:23:46,125 --> 00:23:46,755
0,225 225,300 300,390 390,480 480,630
that's going to be an

955
00:23:46,755 --> 00:23:48,885
0,600 600,975 975,1475 1765,2025 2025,2130
osnel OS mutex which we

956
00:23:48,885 --> 00:23:49,880
0,135 135,195 195,285 285,545
don't want to do.|
|

957
00:23:50,970 --> 00:23:53,420
0,400 570,970 1620,2020 2070,2330 2330,2450
So the just showing you
那么，刚刚向您展示了测试和设置操作的高级概述，那么交换是您用来构建更复杂的基础构建块吗？

958
00:23:53,420 --> 00:23:54,275
0,105 105,210 210,330 330,705 705,855
a high level overview of

959
00:23:54,275 --> 00:23:55,505
0,210 210,540 540,855 855,1050 1050,1230
the the the test and

960
00:23:55,505 --> 00:23:56,840
0,285 285,570 570,975 975,1200 1200,1335
set operation thear swap is

961
00:23:56,840 --> 00:23:57,905
0,120 120,465 465,705 705,930 930,1065
the basing building block that

962
00:23:57,905 --> 00:23:59,135
0,105 105,365 565,810 810,990 990,1230
you used to build more

963
00:23:59,135 --> 00:24:01,060
0,305
complicated?|
|

964
00:24:01,370 --> 00:24:02,860
0,335 335,820
Latch primitives.|
闩锁原语。|

965
00:24:03,470 --> 00:24:04,225
0,290 290,425 425,530 530,650 650,755
And depending on that, whether
取决于这一点，无论你是否希望操作系统这样做。

966
00:24:04,225 --> 00:24:04,795
0,90 90,195 195,330 330,465 465,570
you want the OS to

967
00:24:04,795 --> 00:24:07,160
0,105 105,285 285,465 465,725
do it or not.|
|

968
00:24:07,260 --> 00:24:09,980
0,320 320,640 690,1090
Most systems most.|
大多数系统。|

969
00:24:10,710 --> 00:24:12,560
0,400 480,800 800,1040 1040,1360 1530,1850
Those bigger database systems, the
那些更大的数据库系统，企业级的，将不会依赖于操作系统的任何东西，它是可移植性的组合，而且它只是更快地避免操作系统和Linus出错。

970
00:24:12,560 --> 00:24:13,850
0,210 210,480 480,750 750,1035 1035,1290
enterprise ones, will not rely

971
00:24:13,850 --> 00:24:14,710
0,105 105,195 195,315 315,525 525,860
on the OS for anything,

972
00:24:15,060 --> 00:24:16,115
0,230 230,350 350,410 410,640 780,1055
and it's a combination for

973
00:24:16,115 --> 00:24:18,440
0,485 535,935 955,1355 1915,2205 2205,2325
portability, and also it's just

974
00:24:18,440 --> 00:24:19,420
0,240 240,435 435,555 555,705 705,980
faster to avoid the OS

975
00:24:19,800 --> 00:24:21,380
0,275 275,560 560,710 710,1000
and linus goes wrong.|
|

976
00:24:21,880 --> 00:24:23,000
0,400
Yeah.|
嗯。|

977
00:24:24,390 --> 00:24:26,075
0,290 290,425 425,560 560,940 1290,1685
Alright, so now let's, yes,
好的，那么现在让我们，是的，我只想澄清，阻塞互斥体也是建立在测试集上的吗？

978
00:24:26,075 --> 00:24:26,915
0,240 240,330 330,420 420,525 525,840
I just want to clarify,

979
00:24:26,915 --> 00:24:28,400
0,165 165,345 345,675 675,1115 1195,1485
is the blocking mutex also

980
00:24:28,400 --> 00:24:29,940
0,195 195,435 435,735 735,1100
built on test set?|
|

981
00:24:30,100 --> 00:24:31,035
0,260 260,410 410,560 560,710 710,935
The question is, is parking
问题是，停车meutex是苹果公司吗？这是奖金吗？不是说所有人都是吗？是的，是的，就像你知道什么是父母互换一样？

982
00:24:31,035 --> 00:24:32,325
0,485 535,840 840,975 975,1080 1080,1290
meutex Apple? Is that bonus?

983
00:24:32,325 --> 00:24:33,405
0,225 225,485 595,885 885,1005 1005,1080
Hasn't said all of them

984
00:24:33,405 --> 00:24:34,845
0,135 135,425 595,945 945,1185 1185,1440
are? Yes, yeah, like that's

985
00:24:34,845 --> 00:24:35,625
0,240 240,465 465,555 555,645 645,780
the you ever know what

986
00:24:35,625 --> 00:24:37,100
0,225 225,450 450,725
parent swap is?|
|

987
00:24:38,400 --> 00:24:40,120
0,350 350,700 1080,1325 1325,1445 1445,1720
No, okay, I have slides.|
不，好吧，我有幻灯片。|

988
00:24:42,630 --> 00:24:44,945
0,305 305,610 1020,1280 1280,1540 1980,2315
One slide, all right. So
一张幻灯片，好的。所以比较交换是一种原子结构，现代CPU提供这种结构，允许您检查内存位置，以查看它是否是当前的，该内存地址的当前值是否为您预期的值。如果是，那么我可以继续，并在一条指令中再次用我的新值覆盖它。如果你必须在c+代码中这样做，如果这个值等于这个。

989
00:24:44,945 --> 00:24:46,550
0,270 270,555 555,765 765,915 915,1605
compare swap is this atomicruction

990
00:24:46,550 --> 00:24:48,730
0,330 330,710 1150,1485 1485,1875 1875,2180
that, that modern cpus provide

991
00:24:48,960 --> 00:24:50,045
0,305 305,530 530,710 710,890 890,1085
that allow you to check

992
00:24:50,045 --> 00:24:51,635
0,150 150,425 475,875 1165,1440 1440,1590
a memory location to see

993
00:24:51,635 --> 00:24:52,940
0,195 195,420 420,525 525,815 925,1305
whether it's a current, whether

994
00:24:52,940 --> 00:24:54,530
0,380 700,1035 1035,1305 1305,1485 1485,1590
the current value of that

995
00:24:54,530 --> 00:24:56,000
0,240 240,620 820,1110 1110,1275 1275,1470
memory address is what you

996
00:24:56,000 --> 00:24:57,260
0,195 195,315 315,405 405,650 970,1260
expected it to be. And

997
00:24:57,260 --> 00:24:58,925
0,150 150,285 285,560 1180,1485 1485,1665
if it is, then I

998
00:24:58,925 --> 00:24:59,945
0,135 135,300 300,465 465,600 600,1020
can go ahead and overwrite

999
00:24:59,945 --> 00:25:00,910
0,150 150,285 285,435 435,645 645,965
it with my new value

1000
00:25:01,500 --> 00:25:02,710
0,275 275,410 410,560 560,740 740,1210
again in a single instruction.

1001
00:25:03,540 --> 00:25:04,295
0,245 245,365 365,500 500,620 620,755
If you had to do

1002
00:25:04,295 --> 00:25:05,075
0,135 135,255 255,420 420,615 615,780
this in c plus code

1003
00:25:05,075 --> 00:25:06,245
0,105 105,195 195,455 685,1005 1005,1170
to be like if the

1004
00:25:06,245 --> 00:25:07,780
0,245 265,585 585,905
value equals this.|
|

1005
00:25:07,790 --> 00:25:09,390
0,400 870,1115 1115,1220 1220,1340 1340,1600
Then set it to that.
那就把它调到那个位置。但再说一次，如果这只是完成这一任务的实际指令，那将是多条指令。当你去检查这个值是否，你知道，标志设置为真时，当你去更新它的时候，其他人可能已经在你之前偷偷进入并在之前更新了。

1006
00:25:09,740 --> 00:25:10,870
0,275 275,545 545,830 830,995 995,1130
But again, if that was

1007
00:25:10,870 --> 00:25:12,190
0,260 430,735 735,945 945,1155 1155,1320
just the actual instructions to

1008
00:25:12,190 --> 00:25:12,925
0,120 120,300 300,480 480,600 600,735
do that, that would be

1009
00:25:12,925 --> 00:25:13,975
0,255 255,600 600,810 810,915 915,1050
multiple instructions. And by the

1010
00:25:13,975 --> 00:25:14,740
0,150 150,285 285,450 450,630 630,765
time you go check to

1011
00:25:14,740 --> 00:25:15,870
0,105 105,285 285,510 510,765 765,1130
see whether that value is,

1012
00:25:16,040 --> 00:25:17,380
0,245 245,350 350,610 750,1085 1085,1340
you know, is the flag

1013
00:25:17,380 --> 00:25:18,865
0,180 180,330 330,620 1090,1350 1350,1485
set to true, by the

1014
00:25:18,865 --> 00:25:19,510
0,165 165,330 330,450 450,540 540,645
time you go and then

1015
00:25:19,510 --> 00:25:20,335
0,210 210,420 420,540 540,675 675,825
go update it, somebody else

1016
00:25:20,335 --> 00:25:21,790
0,120 120,270 270,540 540,785 1075,1455
might have squeaked in and

1017
00:25:21,790 --> 00:25:22,765
0,270 270,360 360,555 555,765 765,975
sneaked in before you did

1018
00:25:22,765 --> 00:25:24,520
0,255 255,450 450,690 690,1055
and update before before.|
|

1019
00:25:24,520 --> 00:25:25,750
0,150 150,330 330,525 525,750 750,1230
And so on my cpus
在我的CPU上，你可以在一条指令中做到这一点。这是原子的保证。但当你检查并设置它时，其他人不能比你先进去。

1020
00:25:25,750 --> 00:25:26,425
0,180 180,300 300,435 435,570 570,675
you can do this in

1021
00:25:26,425 --> 00:25:27,715
0,120 120,270 270,615 615,885 885,1290
a single instruction. That's atomic

1022
00:25:27,715 --> 00:25:29,170
0,135 135,395 445,845 985,1290 1290,1455
to guarantee that. But when

1023
00:25:29,170 --> 00:25:30,175
0,165 165,345 345,510 510,765 765,1005
you check it and set

1024
00:25:30,175 --> 00:25:31,135
0,275 295,570 570,675 675,795 795,960
it, no one else can

1025
00:25:31,135 --> 00:25:32,040
0,135 135,255 255,450 450,645 645,905
get in before you do.|
|

1026
00:25:32,560 --> 00:25:33,565
0,255 255,405 540,660 660,780 780,1005
And then that's the basic
然后这是基本的周长，允许做更复杂的事情。

1027
00:25:33,565 --> 00:25:34,555
0,345 345,525 525,690 690,840 840,990
perimeter, allows to do more

1028
00:25:34,555 --> 00:25:35,940
0,275 325,725
complicated things.|
|

1029
00:25:36,220 --> 00:25:37,170
0,305 305,530 530,635 635,800 800,950
So there's a bunch of
所以有一堆不同的内在函数，在，in，在c和c++中，你可以使用它，对吧。他们对此有不同的版本。就像您所说的，如果测试和设置成功，或者PARS停止了一个种子，它们将返回旧值或新值或TRUE和FALSE。但他们基本上都在做同样的事情。在这种情况下，对于这个内部函数，我说这是地址，我想检查并假设它是一个64位整数。这是我想要查看当前是否设置的值，如果是，这是我希望您现在设置的值。

1030
00:25:37,170 --> 00:25:39,060
0,210 210,885 885,1200 1200,1545 1545,1890
different intrinsics in, in, in

1031
00:25:39,060 --> 00:25:39,780
0,210 210,330 330,435 435,540 540,720
c and c plus plus

1032
00:25:39,780 --> 00:25:40,580
0,165 165,270 270,420 420,555 555,800
you can use for this,

1033
00:25:40,780 --> 00:25:42,375
0,400 810,1070 1070,1190 1190,1370 1370,1595
right. They have different versions

1034
00:25:42,375 --> 00:25:43,490
0,150 150,315 315,510 510,750 750,1115
of this. Like some like

1035
00:25:43,750 --> 00:25:44,730
0,305 305,500 500,650 650,800 800,980
if you, if the test

1036
00:25:44,730 --> 00:25:46,275
0,150 150,300 300,590 910,1410 1410,1545
and set can succeeds or

1037
00:25:46,275 --> 00:25:47,390
0,255 255,570 570,690 690,840 840,1115
the paras stops a seed,

1038
00:25:47,530 --> 00:25:48,480
0,335 335,485 485,650 650,785 785,950
they'll return back the old

1039
00:25:48,480 --> 00:25:49,530
0,300 300,540 540,660 660,825 825,1050
value or the new value

1040
00:25:49,530 --> 00:25:50,610
0,210 210,345 345,450 450,710 850,1080
or true and false. But

1041
00:25:50,610 --> 00:25:51,510
0,105 105,195 195,470 490,765 765,900
they're all basically doing the

1042
00:25:51,510 --> 00:25:52,935
0,165 165,470 910,1155 1155,1320 1320,1425
same thing. So let's say

1043
00:25:52,935 --> 00:25:54,105
0,120 120,240 240,420 420,725 925,1170
in this case here for

1044
00:25:54,105 --> 00:25:55,245
0,120 120,555 555,735 735,885 885,1140
this intrinsic I'm saying here's

1045
00:25:55,245 --> 00:25:55,875
0,120 120,285 285,420 420,510 510,630
the address, I want to

1046
00:25:55,875 --> 00:25:56,850
0,275 385,660 660,780 780,900 900,975
check and assume it's a

1047
00:25:56,850 --> 00:25:58,500
0,390 390,510 510,980 1150,1530 1530,1650
64 bit integer. Here's the

1048
00:25:58,500 --> 00:25:59,460
0,260 310,570 570,690 690,810 810,960
value that I want to

1049
00:25:59,460 --> 00:26:00,975
0,210 210,530 730,1035 1035,1275 1275,1515
see whether is currently set

1050
00:26:00,975 --> 00:26:02,085
0,305 475,750 750,885 885,1005 1005,1110
to, and then if it

1051
00:26:02,085 --> 00:26:03,135
0,240 240,555 555,645 645,795 795,1050
is, here's the value I

1052
00:26:03,135 --> 00:26:03,735
0,225 225,330 330,420 420,510 510,600
want you to set it

1053
00:26:03,735 --> 00:26:04,500
0,105 105,240 240,515
to right now.|
|

1054
00:26:04,630 --> 00:26:05,385
0,275 275,395 395,530 530,650 650,755
So we jump to this
所以我们跳到这个内存地址。是的，现在是20号。然后，我继续用30覆盖。

1055
00:26:05,385 --> 00:26:06,710
0,210 210,450 450,720 720,1050 1050,1325
memory address here. It's twenty,

1056
00:26:07,660 --> 00:26:09,705
0,395 395,790 990,1390 1680,1925 1925,2045
twenty, twenty, yes. Then I

1057
00:26:09,705 --> 00:26:10,830
0,150 150,270 270,360 360,755 835,1125
go ahead and overwrite with

1058
00:26:10,830 --> 00:26:11,800
0,290
thirty.|
|

1059
00:26:13,010 --> 00:26:14,400
0,305 305,610
Pretty simple.|
很简单。|

1060
00:26:14,540 --> 00:26:15,460
0,245 245,485 485,590 590,815 815,920
But that's again, that's the
但话又说回来了，这就是基础。我们需要所有的，你知道，来建造我们所有更复杂的闩锁。

1061
00:26:15,460 --> 00:26:16,270
0,180 180,375 375,510 510,660 660,810
building block. We need to

1062
00:26:16,270 --> 00:26:17,515
0,180 180,500 580,840 840,1050 1050,1245
have all, you know, to

1063
00:26:17,515 --> 00:26:18,450
0,210 210,435 435,555 555,675 675,935
build all our more complicated

1064
00:26:18,470 --> 00:26:19,620
0,580
latches.|
|

1065
00:26:21,290 --> 00:26:22,825
0,245 245,395 395,485 485,760 1140,1535
I don't know when this
我不知道这个掉期的东西是什么时候加的。我认为那就像90年代末，至少在接下来的86年。

1066
00:26:22,825 --> 00:26:23,785
0,315 315,480 480,630 630,810 810,960
swap stuff was added. I

1067
00:26:23,785 --> 00:26:24,265
0,90 90,150 150,225 225,360 360,480
think it was like the

1068
00:26:24,265 --> 00:26:25,825
0,120 120,545 1045,1305 1305,1440 1440,1560
late nineties, at least in

1069
00:26:25,825 --> 00:26:27,120
0,120 120,605
next 86.|
|

1070
00:26:28,600 --> 00:26:29,760
0,245 245,320 320,550
There we go.|
我们走吧。|

1071
00:26:29,760 --> 00:26:31,880
0,210 210,470 760,1035 1035,1310
Okay, cool. All right.|
好的，酷。好的。|

1072
00:26:32,880 --> 00:26:33,560
0,230 230,380 380,455 455,575 575,680
So let's see how we
现在，让我们看看如何对哈希表执行此操作，或者使用闩锁哈希表。

1073
00:26:33,560 --> 00:26:34,355
0,75 75,150 150,380 400,645 645,795
can do this for hash

1074
00:26:34,355 --> 00:26:35,705
0,150 150,455 505,840 840,1050 1050,1350
tables now, or use latching

1075
00:26:35,705 --> 00:26:36,800
0,150 150,395
hash tables.|
|

1076
00:26:37,120 --> 00:26:38,655
0,400 900,1265 1265,1355 1355,1460 1460,1535
So hash table is going
所以哈希表将很容易被支持，因为假设线性Pro哈希是，你只有很多方法可以实际访问哈希表。

1077
00:26:38,655 --> 00:26:39,435
0,45 45,105 105,270 270,495 495,780
to be easy to support

1078
00:26:39,435 --> 00:26:42,170
0,395 1285,1685 1795,2175 2175,2295 2295,2735
because assuming linear Pro hashing

1079
00:26:42,370 --> 00:26:44,025
0,260 260,520 900,1220 1220,1400 1400,1655
is that there's only certain

1080
00:26:44,025 --> 00:26:45,120
0,210 210,465 465,645 645,795 795,1095
many ways you can actually

1081
00:26:45,120 --> 00:26:46,620
0,270 270,405 405,600 600,860
access the hash table.|
|

1082
00:26:46,930 --> 00:26:48,315
0,290 290,680 680,905 905,1100 1100,1385
I hash, assuming it's linear,
我散列，假设它是线性的，线性的，线性的道具散列，我散列到我的散列数组或散列表中的某个位置，然后我从上到下扫描，寻找条目。我在找，你知道的，我需要的，对吧？

1083
00:26:48,315 --> 00:26:50,010
0,405 405,735 735,855 855,1295 1405,1695
linear, linear prop hashing I

1084
00:26:50,010 --> 00:26:51,630
0,270 270,375 375,570 570,920 1330,1620
hash to some location into

1085
00:26:51,630 --> 00:26:53,085
0,165 165,495 495,825 825,1130 1210,1455
my hash hash array or

1086
00:26:53,085 --> 00:26:53,865
0,75 75,240 240,420 420,615 615,780
a hash table and I

1087
00:26:53,865 --> 00:26:55,500
0,150 150,345 345,630 630,965 1255,1635
then I scan down from

1088
00:26:55,500 --> 00:26:57,015
0,285 285,450 450,710 1060,1320 1320,1515
top to down to looking

1089
00:26:57,015 --> 00:26:57,780
0,180 180,255 255,450 450,600 600,765
for the entries. I'm looking,

1090
00:26:57,780 --> 00:26:58,610
0,195 195,330 330,465 465,570 570,830
you know, that I need,

1091
00:26:58,720 --> 00:26:59,700
0,400
right?|
|

1092
00:27:00,520 --> 00:27:01,515
0,245 245,335 335,485 485,695 695,995
And in this case here,
在本例中，因为所有线程都朝着相同的方向移动，就像从上到下一样，即使它们可能从哈希表中的不同位置开始，我也不能有任何死锁。

1093
00:27:01,515 --> 00:27:02,415
0,300 300,465 465,660 660,750 750,900
because the threads are all

1094
00:27:02,415 --> 00:27:03,380
0,225 225,360 360,435 435,630 630,965
moving in the same direction,

1095
00:27:03,790 --> 00:27:05,250
0,350 350,635 635,890 890,1190 1190,1460
like going top down, even

1096
00:27:05,250 --> 00:27:06,225
0,255 255,480 480,675 675,870 870,975
though they may start at

1097
00:27:06,225 --> 00:27:07,230
0,210 210,540 540,750 750,840 840,1005
different locations in the hash

1098
00:27:07,230 --> 00:27:08,820
0,260 760,1080 1080,1365 1365,1455 1455,1590
table, I can't have any

1099
00:27:08,820 --> 00:27:10,020
0,650
deadlocks.|
|

1100
00:27:10,030 --> 00:27:11,250
0,260 260,380 380,650 650,905 905,1220
Because there isn't one thread
因为没有一根线是自上而下的，没有一根线是自下而上的。

1101
00:27:11,250 --> 00:27:12,420
0,285 285,525 525,765 765,990 990,1170
going top down a thread

1102
00:27:12,420 --> 00:27:14,060
0,210 210,450 450,770
going bottom up.|
|

1103
00:27:14,290 --> 00:27:15,500
0,400
Right.|
正确的。|

1104
00:27:15,860 --> 00:27:17,020
0,400
So.|
所以。|

1105
00:27:17,020 --> 00:27:17,830
0,240 240,420 420,615 615,720 720,810
The question is going to
问题将是，我们要做的是什么粒度？我们希望有我们的闩锁来保护我们的数据结构，因为这将决定我们能够支持的并行度。

1106
00:27:17,830 --> 00:27:19,480
0,240 240,480 480,690 690,1545 1545,1650
be to, what granularity do

1107
00:27:19,480 --> 00:27:20,125
0,165 165,330 330,420 420,540 540,645
we do? We want to

1108
00:27:20,125 --> 00:27:20,995
0,135 135,285 285,465 465,675 675,870
have our latch to protect

1109
00:27:20,995 --> 00:27:22,465
0,135 135,330 330,665 955,1215 1215,1470
our data structure because that's

1110
00:27:22,465 --> 00:27:23,890
0,90 90,240 240,545 685,1085 1165,1425
going to determine the amount

1111
00:27:23,890 --> 00:27:24,865
0,150 150,660 660,810 810,885 885,975
of parallelism we'll be able

1112
00:27:24,865 --> 00:27:26,000
0,180 180,515
to support.|
|

1113
00:27:26,440 --> 00:27:27,870
0,260 260,500 500,880 960,1325 1325,1430
For this lecture, we're going
对于这堂课，我们将忽略如何处理表的大小调整。处理这一问题的最简单方法是，你有一个正确的锁存来保护，呃，对数据结构本身的访问。所以如果我满了，我需要把它的大小增加一倍，我只需将闩锁切换到写入模式，然后进行我的，我的大小调整，这样就会阻止其他人进入，这是最简单的方法。

1114
00:27:27,870 --> 00:27:28,845
0,180 180,465 465,690 690,810 810,975
to ignore how to handle

1115
00:27:28,845 --> 00:27:30,900
0,420 420,660 660,935 1555,1815 1815,2055
resizing the table. The way

1116
00:27:30,900 --> 00:27:31,800
0,285 285,540 540,645 645,735 735,900
the simplest way to handle

1117
00:27:31,800 --> 00:27:32,805
0,195 195,315 315,420 420,680 760,1005
that is you have sort

1118
00:27:32,805 --> 00:27:34,035
0,210 210,495 495,735 735,990 990,1230
of a right latch that

1119
00:27:34,035 --> 00:27:37,890
0,360 360,665 715,1115 1825,2225 3565,3855
protects the, uh, the access

1120
00:27:37,890 --> 00:27:38,930
0,135 135,225 225,390 390,675 675,1040
to the data structure itself.

1121
00:27:39,220 --> 00:27:40,575
0,260 260,485 485,850 870,1145 1145,1355
So if if I get

1122
00:27:40,575 --> 00:27:41,235
0,240 240,390 390,465 465,555 555,660
full and I need to

1123
00:27:41,235 --> 00:27:42,110
0,150 150,315 315,480 480,630 630,875
double the size of it,

1124
00:27:42,220 --> 00:27:43,290
0,260 260,455 455,680 680,860 860,1070
I just switch that latch

1125
00:27:43,290 --> 00:27:44,595
0,195 195,405 405,710 910,1155 1155,1305
into write mode and then

1126
00:27:44,595 --> 00:27:46,280
0,195 195,465 465,720 720,1175 1285,1685
do my, my resizing and

1127
00:27:46,510 --> 00:27:47,715
0,305 305,620 620,860 860,1055 1055,1205
that prevents everybody else from

1128
00:27:47,715 --> 00:27:49,395
0,165 165,455 1045,1380 1380,1455 1455,1680
coming in, that's the easiest

1129
00:27:49,395 --> 00:27:50,340
0,120 120,210 210,315 315,575
way to do this.|
|

1130
00:27:51,960 --> 00:27:53,495
0,245 245,350 350,640 840,1240 1260,1535
So the scopes of our
因此，我们的锁存器的作用域可以在一页或一个槽内。再一次，这将决定我们的并行度。因此，很明显，当页面闩锁要用闩锁保护整个页面本身时，无论您想要读取页面中的一个Ent条目还是所有条目，您都会持有整个内容的闩锁。

1131
00:27:53,495 --> 00:27:54,425
0,315 315,435 435,600 600,780 780,930
latches can either be within

1132
00:27:54,425 --> 00:27:56,225
0,165 165,455 895,1275 1275,1605 1605,1800
a page or slot. And

1133
00:27:56,225 --> 00:27:56,840
0,150 150,285 285,390 390,480 480,615
again, this is going to

1134
00:27:56,840 --> 00:27:57,665
0,180 180,315 315,420 420,735 735,825
determine amount of parallelism we

1135
00:27:57,665 --> 00:27:59,105
0,245 685,960 960,1155 1155,1320 1320,1440
have. So obviously when a

1136
00:27:59,105 --> 00:28:00,050
0,195 195,495 495,705 705,795 795,945
page latch is going to

1137
00:28:00,050 --> 00:28:01,810
0,300 300,675 675,1020 1020,1365 1365,1760
protect the entire page itself

1138
00:28:02,250 --> 00:28:03,830
0,245 245,350 350,640 1110,1415 1415,1580
with a latch, and no

1139
00:28:03,830 --> 00:28:04,505
0,180 180,390 390,525 525,600 600,675
matter whether you want to

1140
00:28:04,505 --> 00:28:05,590
0,150 150,330 330,495 495,735 735,1085
read one ent entry or

1141
00:28:05,670 --> 00:28:06,560
0,305 305,440 440,680 680,785 785,890
all the entries in the

1142
00:28:06,560 --> 00:28:07,700
0,260 520,750 750,870 870,1020 1020,1140
page, you would, you would

1143
00:28:07,700 --> 00:28:08,480
0,135 135,255 255,450 450,645 645,780
hold a latch on the

1144
00:28:08,480 --> 00:28:09,560
0,180 180,500
entire thing.|
|

1145
00:28:09,750 --> 00:28:11,555
0,335 335,605 605,815 815,1090 1560,1805
The alternative would be you
另一种选择是，页面中的每个单独位置都有一个闩锁。

1146
00:28:11,555 --> 00:28:12,170
0,90 90,180 180,285 285,480 480,615
would have a latch for

1147
00:28:12,170 --> 00:28:13,490
0,135 135,420 420,830 910,1170 1170,1320
every single slot in a

1148
00:28:13,490 --> 00:28:14,540
0,290
page.|
|

1149
00:28:14,540 --> 00:28:15,080
0,75 75,165 165,270 270,345 345,540
And this is going to
这将允许更多的细粒进入。但同样，现在的挑战是我要占用更多的空间，因为每个单独的插槽都需要有一个闩锁。现在，当我扫描我的哈希表时，我在前进的过程中获得了每个插槽的闩锁。

1150
00:28:15,080 --> 00:28:16,340
0,285 285,465 465,645 645,945 945,1260
allow more fine grain access.

1151
00:28:16,340 --> 00:28:17,825
0,315 315,600 600,890 1030,1290 1290,1485
But again, now the challenge

1152
00:28:17,825 --> 00:28:19,175
0,225 225,515 895,1200 1200,1275 1275,1350
is that I'm going to

1153
00:28:19,175 --> 00:28:20,015
0,135 135,315 315,540 540,720 720,840
take more space, because every

1154
00:28:20,015 --> 00:28:21,215
0,255 255,555 555,780 780,1020 1020,1200
single, every single slot needs

1155
00:28:21,215 --> 00:28:22,640
0,120 120,225 225,330 330,605 1075,1425
to have a latch. And

1156
00:28:22,640 --> 00:28:23,840
0,285 285,480 480,705 705,1020 1020,1200
now, as I'm scanning through

1157
00:28:23,840 --> 00:28:25,745
0,290 730,1005 1005,1230 1230,1490 1630,1905
my my hash table, I

1158
00:28:25,745 --> 00:28:26,600
0,105 105,210 210,435 435,630 630,855
got to acquire the latch

1159
00:28:26,600 --> 00:28:27,845
0,180 180,375 375,705 705,1050 1050,1245
for every single slot as

1160
00:28:27,845 --> 00:28:29,100
0,165 165,330 330,665
I'm going along.|
|

1161
00:28:29,350 --> 00:28:30,285
0,245 245,395 395,590 590,740 740,935
So again, there's no free
因此，再一次，在系统或计算机科学领域，没有免费的午餐。它要么是我每页只有一个闩锁，我没有一次针对该页面的CHO，它不会占用太多空间，但它会阻止其他所有人从整个页面中删除，或者针对每个单独的插槽使用Have。

1162
00:28:30,285 --> 00:28:31,485
0,210 210,465 465,705 705,930 930,1200
lunch in, in, in systems

1163
00:28:31,485 --> 00:28:33,165
0,315 315,600 600,825 825,1115 1375,1680
or in computer science. It's

1164
00:28:33,165 --> 00:28:34,770
0,150 150,455 745,1005 1005,1265 1285,1605
either I have a single

1165
00:28:34,770 --> 00:28:36,135
0,240 240,405 405,680 910,1230 1230,1365
latch per page, which I

1166
00:28:36,135 --> 00:28:37,080
0,90 90,150 150,240 240,515 655,945
don't have the Cho once

1167
00:28:37,080 --> 00:28:38,580
0,135 135,240 240,500 1210,1440 1440,1500
for the page, and it

1168
00:28:38,580 --> 00:28:39,030
0,150 150,225 225,285 285,345 345,450
doesn't take a lot of

1169
00:28:39,030 --> 00:28:40,005
0,255 255,510 510,630 630,765 765,975
space, but then it blocks

1170
00:28:40,005 --> 00:28:40,770
0,180 180,315 315,495 495,630 630,765
everyone else out from a

1171
00:28:40,770 --> 00:28:42,150
0,150 150,315 315,620 940,1230 1230,1380
the entire page or a

1172
00:28:42,150 --> 00:28:44,120
0,260 370,770 1090,1395 1395,1620 1620,1970
have for every single slot.|
|

1173
00:28:46,620 --> 00:28:48,470
0,400 630,1030 1260,1565 1565,1700 1700,1850
So say hash table like
假设像这样的散列表要出现，线程一要出现，并发现我们散列d，我们到达了这个位置。我们让整个页面处于正确的模式。看，试着通过向下扫描来找到我们正在寻找的条目，但同时另一个线程想要出现，想要插入相同的东西。我散列到这个页面，但是锁存器已经锁住了页面，在读取模式下，这与正确的模式锁存无关，需要进行插入。

1174
00:28:48,470 --> 00:28:51,005
0,260 1870,2145 2145,2295 2295,2430 2430,2535
this t one wants to

1175
00:28:51,005 --> 00:28:52,295
0,135 135,425 595,885 885,1095 1095,1290
come along, thread one wants

1176
00:28:52,295 --> 00:28:53,230
0,135 135,270 270,420 420,615 615,935
come along and find d

1177
00:28:53,370 --> 00:28:54,440
0,245 245,500 500,695 695,860 860,1070
we hash d we landed

1178
00:28:54,440 --> 00:28:55,820
0,180 180,450 450,770 970,1230 1230,1380
this location here. We get

1179
00:28:55,820 --> 00:28:57,760
0,290 370,705 705,1040 1060,1460 1540,1940
the entire page in in

1180
00:28:57,930 --> 00:28:59,960
0,400 420,710 710,1000 1410,1790 1790,2030
in right mode. Look, try

1181
00:28:59,960 --> 00:29:01,100
0,105 105,285 285,620 700,1065 1065,1140
to find the entries that

1182
00:29:01,100 --> 00:29:01,700
0,105 105,210 210,345 345,450 450,600
we're looking for by just

1183
00:29:01,700 --> 00:29:02,870
0,300 300,560 730,960 960,1050 1050,1170
scanning down, but at the

1184
00:29:02,870 --> 00:29:03,995
0,195 195,510 510,810 810,1005 1005,1125
same time another thread wants

1185
00:29:03,995 --> 00:29:04,805
0,90 90,225 225,465 465,690 690,810
to come along, wants to

1186
00:29:04,805 --> 00:29:06,485
0,330 330,635 1075,1380 1380,1545 1545,1680
insert e same thing. I

1187
00:29:06,485 --> 00:29:07,385
0,255 255,345 345,480 480,720 720,900
hashed to this page but

1188
00:29:07,385 --> 00:29:08,570
0,120 120,330 330,540 540,845 925,1185
the latch is already the

1189
00:29:08,570 --> 00:29:10,030
0,120 120,240 240,500 670,1155 1155,1460
page is already latched in

1190
00:29:10,050 --> 00:29:11,480
0,290 290,485 485,790 930,1190 1190,1430
in read mode and that's

1191
00:29:11,480 --> 00:29:12,965
0,555 555,860 910,1155 1155,1290 1290,1485
notutative with the right mode

1192
00:29:12,965 --> 00:29:13,655
0,210 210,345 345,465 465,570 570,690
latch and needs to do

1193
00:29:13,655 --> 00:29:14,620
0,105 105,515
the insert.|
|

1194
00:29:14,620 --> 00:29:15,990
0,380 520,780 780,900 900,1065 1065,1370
So we have to stall
因此，我们也必须搁置线程。

1195
00:29:16,010 --> 00:29:17,360
0,335 335,670
thread, too.|
|

1196
00:29:17,490 --> 00:29:18,695
0,260 260,380 380,530 530,815 815,1205
And again, whether it's spinning
同样，它是在用户空间旋转还是被内核重新调度，这取决于您的闩锁实现。

1197
00:29:18,695 --> 00:29:19,925
0,315 315,645 645,915 915,1095 1095,1230
in user space or got

1198
00:29:19,925 --> 00:29:21,320
0,375 375,465 465,585 585,965 1075,1395
rescheduled by the kernel, that

1199
00:29:21,320 --> 00:29:22,330
0,195 195,315 315,435 435,675 675,1010
depends on your latch implementation.|
|

1200
00:29:23,730 --> 00:29:26,630
0,230 230,425 425,790 870,1270 2550,2900
So now when the when
所以现在，当线程1扫描完这一页时，它可以跳到下一页，它仍然持有它开始的页的闩锁，因为它需要知道如何查看下一页。

1201
00:29:26,630 --> 00:29:28,145
0,255 255,560 610,915 915,1185 1185,1515
thread one is done scanning

1202
00:29:28,145 --> 00:29:29,420
0,135 135,425 685,960 960,1110 1110,1275
this page, it can jump

1203
00:29:29,420 --> 00:29:30,760
0,135 135,225 225,390 390,710 940,1340
to the next page, it

1204
00:29:31,020 --> 00:29:32,180
0,305 305,530 530,725 725,980 980,1160
still holds the latch to

1205
00:29:32,180 --> 00:29:33,110
0,105 105,270 270,450 450,675 675,930
the page it started out

1206
00:29:33,110 --> 00:29:33,815
0,180 180,285 285,420 420,555 555,705
because it needs to know

1207
00:29:33,815 --> 00:29:35,240
0,180 180,455 955,1215 1215,1320 1320,1425
how to where to look

1208
00:29:35,240 --> 00:29:36,380
0,150 150,440
at next.|
|

1209
00:29:36,380 --> 00:29:37,670
0,330 330,525 525,645 645,870 870,1290
Right, to make sure nobody's
对，为了确保没人搬动东西。然后我们，我们可以释放第一页上的闩锁，获得第二页上的闩锁，然后线程2可以开始运行，并试图找出要插入的位置和内容。

1210
00:29:37,670 --> 00:29:39,560
0,165 165,390 390,710 1390,1695 1695,1890
moving things around. And so

1211
00:29:39,560 --> 00:29:40,700
0,285 285,540 540,630 630,825 825,1140
we we can then release

1212
00:29:40,700 --> 00:29:42,035
0,195 195,470 580,900 900,1125 1125,1335
the latch on page number

1213
00:29:42,035 --> 00:29:43,670
0,305 895,1200 1200,1320 1320,1485 1485,1635
one, acquire the latch on

1214
00:29:43,670 --> 00:29:44,585
0,135 135,315 315,555 555,750 750,915
page number two, and then

1215
00:29:44,585 --> 00:29:46,415
0,305 895,1215 1215,1425 1425,1635 1635,1830
now thread two can start

1216
00:29:46,415 --> 00:29:47,810
0,275 325,725 925,1170 1170,1275 1275,1395
running and try to figure

1217
00:29:47,810 --> 00:29:48,760
0,135 135,285 285,465 465,510 510,950
out where, what's to insert.|
|

1218
00:29:50,240 --> 00:29:51,625
0,260 260,410 410,635 635,970 1080,1385
The same thing once once
同样的事情一旦下来这里做正确的事情，读锁存器就不能与正确的锁存器相匹配，因此它必须等待。然后，一旦线程1完成，线程2就可以连接锁存器并进行更新以断言其条目。

1219
00:29:51,625 --> 00:29:52,525
0,165 165,315 315,585 585,810 810,900
come down here to do

1220
00:29:52,525 --> 00:29:54,430
0,90 90,335 745,1095 1095,1445 1585,1905
the right, the the read

1221
00:29:54,430 --> 00:29:55,345
0,255 255,420 420,600 600,795 795,915
latch is not comput with

1222
00:29:55,345 --> 00:29:57,310
0,90 90,335 535,840 840,1175 1645,1965
the right right latch, so

1223
00:29:57,310 --> 00:29:58,230
0,240 240,405 405,525 525,660 660,920
therefore it has to wait.

1224
00:29:58,580 --> 00:29:59,560
0,305 305,530 530,725 725,860 860,980
Then once thread one is

1225
00:29:59,560 --> 00:30:01,975
0,260 1300,1620 1620,1845 1845,2010 2010,2415
done, thread two can thenire

1226
00:30:01,975 --> 00:30:02,995
0,120 120,315 315,615 615,855 855,1020
the latch and do the

1227
00:30:02,995 --> 00:30:03,990
0,180 180,285 285,495 495,675 675,995
update to assert its entry.|
|

1228
00:30:08,730 --> 00:30:09,960
0,305 305,610
Yes, question.|
是的，我有个问题。|

1229
00:30:10,160 --> 00:30:11,340
0,90 90,350
We have.|
我们有。|

1230
00:30:11,980 --> 00:30:12,960
0,150 150,270 270,480 480,705 705,980
If we have a read
如果我们有一个读锁存合唱团。

1231
00:30:13,070 --> 00:30:14,300
0,365 365,760
latch choir.|
|

1232
00:30:18,580 --> 00:30:19,720
0,210 210,420 420,675 675,915 915,1140
The order we schedule things
我们安排事情的顺序并不是那种比赛条件。你的问题是，如果我拿着，如果我拿着，我就有一个锁扣。

1233
00:30:19,720 --> 00:30:20,605
0,165 165,420 420,600 600,780 780,885
in isn't that sort of

1234
00:30:20,605 --> 00:30:22,165
0,90 90,300 300,665 1135,1395 1395,1560
a race condition. Your question

1235
00:30:22,165 --> 00:30:23,395
0,195 195,330 330,480 480,785 985,1230
is, if I hold, if

1236
00:30:23,395 --> 00:30:24,280
0,120 120,270 270,545 565,810 810,885
I hold the, I have

1237
00:30:24,280 --> 00:30:25,700
0,105 105,255 255,560
a rel latch.|
|

1238
00:30:27,540 --> 00:30:28,955
0,350 350,635 635,920 920,1175 1175,1415
Say there again, sorry. I
再说一遍，对不起。我想，更广泛地说，我想问的是，我们不是遇到了竞争条件，比如基于作者是否碰巧在读者之前偷偷溜进来，以及无论我们的日程安排是什么？

1239
00:30:28,955 --> 00:30:30,155
0,195 195,455 595,870 870,1140 1140,1200
I guess more broadly what

1240
00:30:30,155 --> 00:30:30,740
0,135 135,225 225,300 300,420 420,585
I'm trying to ask is,

1241
00:30:30,740 --> 00:30:31,505
0,180 180,240 240,315 315,480 480,765
don't we run into race

1242
00:30:31,505 --> 00:30:33,995
0,365 385,785 895,1215 1215,1535 2125,2490
conditions like based on whether

1243
00:30:33,995 --> 00:30:35,075
0,240 240,465 465,735 735,930 930,1080
the writer happened to sneak

1244
00:30:35,075 --> 00:30:36,260
0,135 135,345 345,525 525,785 895,1185
in before the reader and

1245
00:30:36,260 --> 00:30:37,600
0,165 165,330 330,705 705,960 960,1340
whatever our scheduling policy is?|
|

1246
00:30:39,610 --> 00:30:40,410
0,305 305,470 470,605 605,710 710,800
So going back to like
所以回到一开始，是的，我很抱歉，就像什么方面来说，不像是比赛条件？

1247
00:30:40,410 --> 00:30:42,030
0,105 105,270 270,495 495,800 1270,1620
the very beginning here, yeah,

1248
00:30:42,030 --> 00:30:42,975
0,210 210,330 330,495 495,705 705,945
I was sorry, like, not

1249
00:30:42,975 --> 00:30:43,845
0,195 195,300 300,480 480,705 705,870
like a race condition in

1250
00:30:43,845 --> 00:30:45,480
0,210 210,420 420,660 660,1025
terms of like what?|
|

1251
00:30:45,480 --> 00:30:46,790
0,230 340,585 585,810 810,1050 1050,1310
EM what our output is
我们的产出是什么样的。

1252
00:30:46,840 --> 00:30:47,440
0,400
like.|
|

1253
00:30:47,860 --> 00:30:48,625
0,180 180,270 270,375 375,570 570,765
If we have something trying
如果我们同时有一些东西想要阅读，我们就是在试图写作。

1254
00:30:48,625 --> 00:30:49,255
0,135 135,270 270,390 390,495 495,630
to read at the same

1255
00:30:49,255 --> 00:30:49,980
0,135 135,315 315,390 390,480 480,725
time, we're trying to write.|
|

1256
00:30:51,500 --> 00:30:54,145
0,400 750,1150 1890,2255 2255,2495 2495,2645
Uh, so again, say this
再说一遍，假设t2出现在t1之前。

1257
00:30:54,145 --> 00:30:55,525
0,165 165,455 535,885 885,1155 1155,1380
scenario here, say t two

1258
00:30:55,525 --> 00:30:56,550
0,180 180,360 360,555 555,735 735,1025
shows up before t one.|
|

1259
00:30:58,350 --> 00:30:59,860
0,400 600,905 905,995 995,1175 1175,1510
And what the race condition
那么你想要应对的比赛状况是什么呢？

1260
00:31:00,150 --> 00:31:00,880
0,245 245,320 320,395 395,485 485,730
you trying to deal with?|
|

1261
00:31:05,280 --> 00:31:06,410
0,180 180,390 390,615 615,810 810,1130
If you if you read,
如果你读了，就写，然后再读一遍关于日程安排的政策。

1262
00:31:06,730 --> 00:31:08,415
0,400 540,905 905,1160 1160,1370 1370,1685
then write, then read again

1263
00:31:08,415 --> 00:31:10,280
0,240 240,375 375,720 720,995
about the scheduling policy.|
|

1264
00:31:10,280 --> 00:31:11,650
0,180 180,375 375,525 525,975 975,1370
As the two reads happened.|
当这两个阅读发生的时候。|

1265
00:31:12,160 --> 00:31:13,050
0,350 350,530 530,590 590,665 665,890
Alright, so when you say
好的，当你说读，写，读，然后写，然后像第二次读一样读，这是不是就像另一个找到钥匙一样？比方说，比方说，你找到了，然后插入一个发现。同样，我们的调度策略将查找放在右侧之前，那么这不会创建一个。

1266
00:31:13,050 --> 00:31:14,415
0,300 300,620 730,1065 1065,1245 1245,1365
read, write, read and then

1267
00:31:14,415 --> 00:31:15,740
0,150 150,255 255,375 375,665 925,1325
write and then read like

1268
00:31:15,970 --> 00:31:17,250
0,320 320,605 605,890 890,1085 1085,1280
that second read, is that

1269
00:31:17,250 --> 00:31:19,640
0,255 255,590 1030,1430 1780,2085 2085,2390
like another find a key?

1270
00:31:19,780 --> 00:31:20,925
0,380 380,605 605,845 845,1025 1025,1145
Let's say so let's say

1271
00:31:20,925 --> 00:31:22,095
0,180 180,450 450,660 660,810 810,1170
you find and then insert

1272
00:31:22,095 --> 00:31:24,090
0,120 120,225 225,435 435,785 1705,1995
that a find. Again, our

1273
00:31:24,090 --> 00:31:25,575
0,375 375,650 850,1155 1155,1320 1320,1485
scheduling policy puts the find

1274
00:31:25,575 --> 00:31:27,135
0,305 445,765 765,945 945,1205 1255,1560
before the the right, then

1275
00:31:27,135 --> 00:31:28,500
0,240 240,485 685,975 975,1265
wouldn't that create a.|
|

1276
00:31:30,030 --> 00:31:31,620
0,245 245,335 335,455 455,730
But is it wrong?|
但这是错的吗？|

1277
00:31:32,980 --> 00:31:33,885
0,230 230,395 395,560 560,740 740,905
Well, it's like we don't,
嗯，就像我们没有，我们不知道是否，如果我们要得到旧的价值。

1278
00:31:33,885 --> 00:31:34,830
0,105 105,300 300,465 465,720 720,945
we don't know if, if

1279
00:31:34,830 --> 00:31:35,520
0,165 165,255 255,405 405,525 525,690
we're gonna get the old

1280
00:31:35,520 --> 00:31:36,680
0,320
value.|
|

1281
00:31:36,680 --> 00:31:37,535
0,210 210,405 405,555 555,735 735,855
Before the right or the
在右侧之前或在右侧之后的新值。

1282
00:31:37,535 --> 00:31:38,390
0,120 120,330 330,585 585,750 750,855
new value after to the

1283
00:31:38,390 --> 00:31:39,000
0,260
right.|
|

1284
00:31:39,430 --> 00:31:42,620
0,400 840,1240 1260,1655 1655,2050
Right, yeah. So, so.|
对，是的。所以，所以。|

1285
00:31:46,670 --> 00:31:50,020
0,290 290,455 455,730 2210,2440
So yeah, so there's.|
所以是的，所以有。|

1286
00:31:50,820 --> 00:31:52,490
0,490 750,1025 1025,1145 1145,1265 1265,1670
There. This is the logical
那里。这就是逻辑上的正确性，对吧？

1287
00:31:52,490 --> 00:31:55,240
0,345 345,620 640,1040
correctness thing, right?|
|

1288
00:31:55,630 --> 00:31:57,105
0,380 380,605 605,830 830,1145 1145,1475
If say I I I
如果我做一个SELECT，我运行一升，没有在这个哈希表中查找的SELECT查询，我找到了正确的d和，我就得到了答案。

1289
00:31:57,105 --> 00:31:58,700
0,255 255,495 495,875 1045,1320 1320,1595
do a select, I run

1290
00:31:59,020 --> 00:32:00,870
0,400 450,845 845,1115 1115,1420 1590,1850
a liter, select query that

1291
00:32:00,870 --> 00:32:01,470
0,255 255,360 360,450 450,510 510,600
doesn't look up in this

1292
00:32:01,470 --> 00:32:02,835
0,210 210,360 360,630 630,990 990,1365
hash table and I find

1293
00:32:02,835 --> 00:32:04,875
0,395 745,1145 1495,1800 1800,1950 1950,2040
d right and, and I

1294
00:32:04,875 --> 00:32:06,140
0,105 105,240 240,360 360,605
get back the answer.|
|

1295
00:32:06,370 --> 00:32:08,580
0,400 1200,1445 1445,1610 1610,1910 1910,2210
Now some other transaction, another
现在有了其他事务，另一个线程出现并删除了d。

1296
00:32:08,580 --> 00:32:09,615
0,210 210,360 360,495 495,630 630,1035
thread comes along and deletes

1297
00:32:09,615 --> 00:32:10,740
0,305
d.|
|

1298
00:32:10,840 --> 00:32:11,790
0,335 335,545 545,725 725,875 875,950
Right. And r in the
正确的。和r，然后在哈希表中。那么Dan的第一个线程现在运行另一个SELECT查询来查找d，并且不会返回它，对吗？是的，从数据结构的角度来看，这对于我们今天讨论的内容来说是很好的。

1299
00:32:11,790 --> 00:32:13,155
0,165 165,410 640,945 945,1170 1170,1365
hash table then. Then the

1300
00:32:13,155 --> 00:32:14,025
0,195 195,375 375,480 480,645 645,870
first thread of Dan now

1301
00:32:14,025 --> 00:32:15,315
0,255 255,600 600,870 870,1095 1095,1290
runs another select query that

1302
00:32:15,315 --> 00:32:16,215
0,210 210,420 420,570 570,705 705,900
finds d and it doesn't

1303
00:32:16,215 --> 00:32:17,240
0,105 105,255 255,405 405,645 645,1025
come back with it, right?

1304
00:32:17,350 --> 00:32:19,130
0,400 720,980 980,1130 1130,1400 1400,1780
Yeah, from the data structure

1305
00:32:19,150 --> 00:32:21,255
0,400 750,1220 1220,1510 1770,2015 2015,2105
perspective, that's fine for what

1306
00:32:21,255 --> 00:32:22,600
0,135 135,210 210,330 330,605
we're talking about today.|
|

1307
00:32:22,670 --> 00:32:23,470
0,245 245,350 350,500 500,650 650,800
When we talk about after
当我们谈到期中考试之后，那就是，这是不一致阅读的反常现象。

1308
00:32:23,470 --> 00:32:26,215
0,120 120,560 850,1430 1570,2060 2440,2745
the midterm, that's, that's, that's

1309
00:32:26,215 --> 00:32:29,820
0,60 60,725 2185,2505 2505,3120 3120,3605
an anomaly of inconsistent reads.|
|

1310
00:32:30,460 --> 00:32:31,620
0,150 150,480 480,675 675,885 885,1160
And that's something that the
这是系统的机制将在事务级别处理的事情，在数据结构的低级别，我们不在乎。

1311
00:32:32,180 --> 00:32:33,325
0,365 365,575 575,710 710,935 935,1145
mechanism for the system will

1312
00:32:33,325 --> 00:32:34,840
0,165 165,330 330,600 600,995 1285,1515
handle in transaction level, at

1313
00:32:34,840 --> 00:32:35,620
0,120 120,330 330,555 555,705 705,780
the low level level of

1314
00:32:35,620 --> 00:32:36,580
0,75 75,225 225,510 510,750 750,960
the data structure, we don't

1315
00:32:36,580 --> 00:32:37,520
0,260
care.|
|

1316
00:32:37,610 --> 00:32:39,600
0,365 365,640 840,1115 1115,1540 1590,1990
It's correct. Who decides what
这是正确的。谁按顺序决定什么是什么，我们应该看到或不看到什么权利。这是一个更高层次的事情，是在后面发生的。

1317
00:32:39,860 --> 00:32:41,580
0,395 395,650 650,860 860,1210 1320,1720
in the order what, what

1318
00:32:41,840 --> 00:32:42,670
0,305 305,470 470,605 605,725 725,830
rights we should see or

1319
00:32:42,670 --> 00:32:44,080
0,180 180,500 820,1200 1200,1275 1275,1410
not see. That's a higher

1320
00:32:44,080 --> 00:32:44,880
0,180 180,315 315,405 405,525 525,800
level thing that comes later.|
|

1321
00:32:45,480 --> 00:32:46,845
0,290 580,840 840,975 975,1155 1155,1365
Yes, and the great thing
是的，关于数据库或这些交易的伟大之处在于，有多个潜在的技术上正确的答案。

1322
00:32:46,845 --> 00:32:48,440
0,305 475,1080 1080,1170 1170,1305 1305,1595
about databases or these transactions

1323
00:32:48,490 --> 00:32:50,235
0,290 290,580 750,1160 1160,1415 1415,1745
is like there's multiple answers

1324
00:32:50,235 --> 00:32:51,500
0,195 195,270 270,450 450,785 865,1265
that are all technically correct,

1325
00:32:51,970 --> 00:32:53,020
0,400
potentially.|
|

1326
00:32:54,110 --> 00:32:55,350
0,400 450,740 740,830 830,965 965,1240
But we'll get that later
但我们会在晚些时候拿到。

1327
00:32:56,870 --> 00:32:58,340
0,260 260,520
of the.|
|

1328
00:32:58,470 --> 00:33:00,140
0,400 780,1070 1070,1205 1205,1310 1310,1670
No, well, in the specification
不，好的，在SQL的规范中，有关于在不同的隔离级别上被认为是正确或不正确的描述，我们还没有讨论。

1329
00:33:00,140 --> 00:33:01,415
0,210 210,600 600,930 930,1140 1140,1275
of sql there's, there's a,

1330
00:33:01,415 --> 00:33:03,430
0,225 225,455 655,945 945,1175 1615,2015
there's a, there's a description

1331
00:33:03,540 --> 00:33:05,285
0,365 365,730 900,1235 1235,1520 1520,1745
about what is considered correct

1332
00:33:05,285 --> 00:33:06,305
0,120 120,300 300,585 585,825 825,1020
or not correct at different

1333
00:33:06,305 --> 00:33:07,505
0,450 450,690 690,900 900,1020 1020,1200
isolation levels, which we haven't

1334
00:33:07,505 --> 00:33:08,380
0,135 135,425
covered yet.|
|

1335
00:33:08,470 --> 00:33:10,760
0,400 630,905 905,1180
Right. And the.|
正确的。还有。|

1336
00:33:10,760 --> 00:33:12,820
0,150 150,590 970,1290 1290,1545 1545,2060
The easiest, the most strictest
最简单、最严格的正确级别将是隔离级别，称为严格可序列化或强可序列化基本上就是这样的意思。

1337
00:33:12,990 --> 00:33:14,465
0,485 485,695 695,875 875,1070 1070,1475
correctness level would be isolation

1338
00:33:14,465 --> 00:33:16,810
0,165 165,455 685,1085 1435,1710 1710,2345
level, be called strict serializable

1339
00:33:16,920 --> 00:33:18,725
0,350 350,620 620,1210 1260,1595 1595,1805
or strong serializable basically means

1340
00:33:18,725 --> 00:33:19,840
0,150 150,425
that like.|
|

1341
00:33:20,140 --> 00:33:21,890
0,305 305,545 545,880 1020,1385 1385,1750
Whoever comes first should should
无论谁先来，都应该看到系统就像它自己运行一样，它的更改首先得到应用。

1342
00:33:21,970 --> 00:33:22,980
0,290 290,425 425,590 590,800 800,1010
see the system as if

1343
00:33:22,980 --> 00:33:24,830
0,165 165,410 910,1230 1230,1500 1500,1850
it was running by itself

1344
00:33:25,060 --> 00:33:26,760
0,290 290,580 630,1030 1140,1445 1445,1700
and its changes get applied

1345
00:33:26,760 --> 00:33:27,840
0,350
first.|
|

1346
00:33:27,840 --> 00:33:29,400
0,290 730,1005 1005,1230 1230,1425 1425,1560
Right. And then everything else
正确的。然后其他的一切都在那之后。但从数据的角度来看，我不关心你的线程进入并删除d，寻找d，然后d被删除，然后你再去寻找它。它不见了。这不是数据结构的问题。那是别人的问题。这是我们的问题。但不是，不是今天的课。

1347
00:33:29,400 --> 00:33:31,370
0,165 165,390 390,740 880,1280 1570,1970
comes after that. But getting

1348
00:33:31,540 --> 00:33:32,480
0,290 290,440 440,545 545,665 665,940
way, way ahead of ourselves

1349
00:33:33,010 --> 00:33:34,290
0,260 260,365 365,610 660,1040 1040,1280
from the data perspective, I

1350
00:33:34,290 --> 00:33:35,190
0,225 225,390 390,540 540,705 705,900
don't care that your thread

1351
00:33:35,190 --> 00:33:36,735
0,165 165,440 640,945 945,1200 1200,1545
came in and and deleted

1352
00:33:36,735 --> 00:33:38,505
0,275 565,840 840,975 975,1235 1465,1770
d, look for d, then

1353
00:33:38,505 --> 00:33:39,255
0,180 180,345 345,600 600,675 675,750
d got deleted and you

1354
00:33:39,255 --> 00:33:39,705
0,90 90,165 165,270 270,360 360,450
go to look for it

1355
00:33:39,705 --> 00:33:41,415
0,195 195,450 450,695 1135,1560 1560,1710
again. It's missing. That's not

1356
00:33:41,415 --> 00:33:43,230
0,120 120,270 270,510 510,845 1495,1815
the data structures problem. That's

1357
00:33:43,230 --> 00:33:44,685
0,135 135,420 420,650 1030,1320 1320,1455
somebody else's problem. It's our

1358
00:33:44,685 --> 00:33:45,960
0,255 255,465 465,660 660,990 990,1275
problem. But like, not, not

1359
00:33:45,960 --> 00:33:47,160
0,270 270,500
today's lecture.|
|

1360
00:33:49,825 --> 00:33:50,640
0,60 60,120 120,240 240,465 465,815
And it's really hard, yeah.|
这真的很难，是的。|

1361
00:33:53,100 --> 00:33:53,945
0,290 290,485 485,590 590,725 725,845
Oh, it's why all the
哦，这就是为什么所有没有S的人一开始都做新的交易。因为这他妈的很难，对吧？

1362
00:33:53,945 --> 00:33:54,785
0,120 120,300 300,510 510,690 690,840
no s guys did new

1363
00:33:54,785 --> 00:33:55,580
0,225 225,405 405,510 510,660 660,795
transactions in the beginning. Because

1364
00:33:55,580 --> 00:33:58,640
0,120 120,285 285,530 910,1310
this shit hard, right?|
|

1365
00:33:59,300 --> 00:33:59,870
0,240 240,345 345,465 465,510 510,570
All right, we'll come to
好的，我们稍后再谈这个。很多事情他们没有做，因为这很难。然后他们不得不在晚些时候这样做。再说一次，让我向您演示如何插销。

1366
00:33:59,870 --> 00:34:01,895
0,75 75,320 1540,1785 1785,1905 1905,2025
that later. A lot of

1367
00:34:01,895 --> 00:34:02,525
0,120 120,255 255,405 405,510 510,630
things they didn't do because

1368
00:34:02,525 --> 00:34:03,995
0,135 135,365 955,1200 1200,1290 1290,1470
it's hard. And then they

1369
00:34:03,995 --> 00:34:04,960
0,180 180,405 405,630 630,720 720,965
had to do it later.

1370
00:34:06,690 --> 00:34:07,295
0,260 260,350 350,425 425,530 530,605
Again, let me just show

1371
00:34:07,295 --> 00:34:08,590
0,45 45,105 105,335 505,825 825,1295
you how to slot latches.|
|

1372
00:34:10,520 --> 00:34:11,170
0,305 305,440 440,500 500,560 560,650
Again, now I have a
同样，现在我在每个槽本身和我的哈希表上都有一个闩锁。所以现在，当我执行查找D时，我得到了插槽本身的读取闩锁上的闩锁，是吗？我可以继续阅读我正在寻找的内容，然后说这个人现在想跳到这个页面。他想要正确地抓住c，忽略他是如何发现的，因为他在那里散列。

1373
00:34:11,170 --> 00:34:12,280
0,180 180,315 315,465 465,750 750,1110
latch on every single slot

1374
00:34:12,280 --> 00:34:13,140
0,225 225,345 345,450 450,615 615,860
itself and my hash table.

1375
00:34:13,520 --> 00:34:14,290
0,230 230,410 410,590 590,680 680,770
So now when I do

1376
00:34:14,290 --> 00:34:15,295
0,105 105,300 300,620 670,915 915,1005
a find D I get

1377
00:34:15,295 --> 00:34:16,375
0,105 105,345 345,695 715,960 960,1080
the latch on the read

1378
00:34:16,375 --> 00:34:18,120
0,330 330,725 745,1095 1095,1410 1410,1745
latch on the slot itself,

1379
00:34:18,680 --> 00:34:19,600
0,400 450,680 680,755 755,845 845,920
eh? I can go ahead

1380
00:34:19,600 --> 00:34:20,065
0,60 60,150 150,240 240,345 345,465
and read what I'm looking

1381
00:34:20,065 --> 00:34:21,220
0,305 385,675 675,840 840,990 990,1155
for and say this guy

1382
00:34:21,220 --> 00:34:21,805
0,150 150,270 270,375 375,480 480,585
now wants to jump to

1383
00:34:21,805 --> 00:34:22,885
0,135 135,425 595,840 840,960 960,1080
this page. He wants to

1384
00:34:22,885 --> 00:34:26,215
0,90 90,335 625,915 915,1235 2935,3330
get the right latch on

1385
00:34:26,215 --> 00:34:28,570
0,395 805,1205 1765,2055 2055,2220 2220,2355
on c, ignore how he

1386
00:34:28,570 --> 00:34:29,725
0,165 165,375 375,645 645,900 900,1155
found that because he hash

1387
00:34:29,725 --> 00:34:31,280
0,275
there.|
|

1388
00:34:31,440 --> 00:34:33,215
0,400 660,995 995,1265 1265,1550 1550,1775
The now when the the
现在，当第一个线程试图在下一个插槽上获得重新锁存时，他不能，因为另一个线程拥有闩锁，所以他有一个失速，但在这一点上，即使他要停止并等待，对他来说，释放前一个插槽上的闩锁是安全的，因为。

1389
00:34:33,215 --> 00:34:34,025
0,210 210,435 435,600 600,720 720,810
first thread tries to get

1390
00:34:34,025 --> 00:34:35,255
0,105 105,540 540,855 855,1035 1035,1230
the relatch on the next

1391
00:34:35,255 --> 00:34:37,180
0,365 415,735 735,1200 1200,1530 1530,1925
slot, he can't because the

1392
00:34:37,500 --> 00:34:38,590
0,320 320,530 530,695 695,815 815,1090
other thread has the latch

1393
00:34:38,760 --> 00:34:39,730
0,275 275,395 395,515 515,680 680,970
so he has a stall,

1394
00:34:40,140 --> 00:34:42,050
0,230 230,290 290,455 455,790 1620,1910
but at this point, even

1395
00:34:42,050 --> 00:34:42,740
0,150 150,330 330,390 390,510 510,690
though he's going to stall

1396
00:34:42,740 --> 00:34:44,015
0,150 150,410 580,960 960,1140 1140,1275
and wait, it's safe for

1397
00:34:44,015 --> 00:34:44,840
0,105 105,255 255,450 450,600 600,825
him to release the latch

1398
00:34:44,840 --> 00:34:46,210
0,210 210,330 330,590 640,990 990,1370
on the previous previous slot

1399
00:34:46,620 --> 00:34:47,800
0,400
because.|
|

1400
00:34:47,840 --> 00:34:50,560
0,610 1560,1820 1820,2080
He has his.|
他有他的。|

1401
00:34:50,690 --> 00:34:52,390
0,485 485,860 860,1130 1130,1430 1430,1700
There's, there's no issue, there's
没有，没有问题，他没有理由一直握着这个门闩，对吧，因为他只会旋转，等待这个东西在这里，现在一切都在那里。我提到了哈希表本身的、的重组。例如，如果您必须调整它的大小，假设有一些其他的闩锁保护整个处于读取模式的东西。所以这是可以的。

1402
00:34:52,390 --> 00:34:53,185
0,165 165,390 390,570 570,690 690,795
no reason for him to

1403
00:34:53,185 --> 00:34:54,565
0,120 120,395 475,810 810,1110 1110,1380
keep holding holding this this

1404
00:34:54,565 --> 00:34:56,230
0,335 865,1215 1215,1425 1425,1575 1575,1665
latch, right, because he's just

1405
00:34:56,230 --> 00:34:56,845
0,105 105,255 255,420 420,510 510,615
going to spin and wait

1406
00:34:56,845 --> 00:34:58,030
0,135 135,285 285,465 465,755 865,1185
for this thing here and

1407
00:34:58,030 --> 00:35:01,210
0,255 255,500 1240,1640 1900,2390 2920,3180
everything's still now there. I

1408
00:35:01,210 --> 00:35:02,785
0,225 225,450 450,1050 1050,1320 1320,1575
mentioned the reorganization of the,

1409
00:35:02,785 --> 00:35:04,435
0,300 300,525 525,815 1105,1425 1425,1650
of, of the hash table

1410
00:35:04,435 --> 00:35:05,680
0,365 745,1005 1005,1110 1110,1185 1185,1245
itself. Like if you have

1411
00:35:05,680 --> 00:35:07,360
0,75 75,420 420,740 1060,1395 1395,1680
to resize it, assume that

1412
00:35:07,360 --> 00:35:08,575
0,300 300,405 405,570 570,870 870,1215
there's some other latch protecting

1413
00:35:08,575 --> 00:35:09,520
0,120 120,315 315,540 540,765 765,945
the entire thing that's in

1414
00:35:09,520 --> 00:35:11,070
0,240 240,530 610,855 855,1260 1260,1550
read mode. So that's OK.|
|

1415
00:35:11,520 --> 00:35:12,395
0,245 245,410 410,605 605,740 740,875
We only set that to
只有在必须调整整个对象大小的情况下，我们才会将其设置为正确模式，因此t 2的全局锁存器将使全局锁存器处于读取模式。

1416
00:35:12,395 --> 00:35:13,220
0,180 180,405 405,600 600,720 720,825
right mode if we have

1417
00:35:13,220 --> 00:35:14,030
0,120 120,405 405,540 540,645 645,810
to resize the whole thing

1418
00:35:14,030 --> 00:35:15,640
0,195 195,500 670,975 975,1230 1230,1610
so, so the global latch

1419
00:35:15,870 --> 00:35:17,450
0,400 870,1190 1190,1355 1355,1460 1460,1580
for t two would have

1420
00:35:17,450 --> 00:35:18,485
0,135 135,315 315,600 600,840 840,1035
the global latch in read

1421
00:35:18,485 --> 00:35:19,340
0,305
mode.|
|

1422
00:35:19,890 --> 00:35:21,350
0,400 810,1070 1070,1190 1190,1295 1295,1460
Yes, so these are the
是的，所以这就是佩奇的位置。

1423
00:35:21,350 --> 00:35:22,620
0,225 225,405 405,710
slot in page.|
|

1424
00:35:22,750 --> 00:35:25,420
0,400 1410,1685 1685,1960
No, this is.|
不，这才是。|

1425
00:35:25,420 --> 00:35:26,665
0,165 165,330 330,495 495,855 855,1245
Just think like it's some
把它想象成我们的哈希表的某个页面中的某个偏移量，所以它的长度都是固定的。

1426
00:35:26,665 --> 00:35:28,075
0,270 270,420 420,600 600,905 1165,1410
offset in some page for

1427
00:35:28,075 --> 00:35:29,095
0,105 105,285 285,545 625,870 870,1020
our hash table so it's

1428
00:35:29,095 --> 00:35:30,320
0,105 105,300 300,605
all fixed length.|
|

1429
00:35:30,600 --> 00:35:31,760
0,400
Yeah.|
嗯。|

1430
00:35:32,070 --> 00:35:33,020
0,245 245,365 365,575 575,770 770,950
So like this, but lining
所以就像这样，但是将页面排列成更多的部分？

1431
00:35:33,020 --> 00:35:34,220
0,150 150,285 285,450 450,740 910,1200
up the page into more

1432
00:35:34,220 --> 00:35:34,400
0,150
parts?|
|

1433
00:35:34,530 --> 00:35:36,800
0,335 335,575 575,815 815,1150 1950,2270
Yeah, correct. Yes, yeah. Basically,
是啊，没错。是的，是的。基本上，你是想要细粒锁扣还是粗粒锁扣？仅此而已。

1434
00:35:36,800 --> 00:35:37,880
0,135 135,180 180,315 315,620 760,1080
do you want fine, fine

1435
00:35:37,880 --> 00:35:38,885
0,210 210,540 540,690 690,885 885,1005
grain latches or coarse grain

1436
00:35:38,885 --> 00:35:39,850
0,375 375,570 570,630 630,720 720,965
latches? That's all it is.|
|

1437
00:35:41,550 --> 00:35:42,540
0,400
Okay.|
好吧。|

1438
00:35:43,150 --> 00:35:44,010
0,320 320,485 485,560 560,680 680,860
So this should be pretty
因此，这应该是相当简单的。

1439
00:35:44,010 --> 00:35:44,980
0,500
straightforward.|
|

1440
00:35:45,330 --> 00:35:46,360
0,400
Okay.|
好吧。|

1441
00:35:46,360 --> 00:35:46,960
0,180 180,255 255,330 330,435 435,600
Let's get to b plus
让我们去B+树，因为这更难，也更有趣。因此，就像前面在我们的哈希表和b+树中一样，希望同时读取多个线程。这里的挑战现在是在哈希表中，使用最少的线性探测，页面的数量是固定的。

1442
00:35:46,960 --> 00:35:47,850
0,195 195,390 390,525 525,630 630,890
trees because this is harder

1443
00:35:47,900 --> 00:35:51,580
0,400 840,1100 1100,1235 1235,1510 3330,3680
and and more fun. So

1444
00:35:51,580 --> 00:35:53,110
0,255 255,420 420,525 525,770 1270,1530
again, just like before in

1445
00:35:53,110 --> 00:35:53,860
0,105 105,255 255,435 435,630 630,750
our hash table and b

1446
00:35:53,860 --> 00:35:54,445
0,150 150,315 315,435 435,495 495,585
plus tree, want to have

1447
00:35:54,445 --> 00:35:55,330
0,225 225,525 525,660 660,780 780,885
multiple threads read at the

1448
00:35:55,330 --> 00:35:58,510
0,165 165,470 2050,2450 2530,2925 2925,3180
same time. The challenge here

1449
00:35:58,510 --> 00:35:59,950
0,135 135,410 700,975 975,1140 1140,1440
is now in the hash

1450
00:35:59,950 --> 00:36:01,590
0,260 430,720 720,915 915,1200 1200,1640
table with least linear probing

1451
00:36:01,910 --> 00:36:03,040
0,400 420,680 680,800 800,935 935,1130
the the number of pages

1452
00:36:03,040 --> 00:36:04,280
0,210 210,500
was fixed.|
|

1453
00:36:04,290 --> 00:36:05,570
0,260 260,520 660,995 995,1175 1175,1280
And the organization of the
并且数据结构的组织是固定的。

1454
00:36:05,570 --> 00:36:07,860
0,195 195,530 910,1215 1215,1520
data structure was fixed.|
|

1455
00:36:07,970 --> 00:36:09,265
0,320 320,640 660,905 905,1040 1040,1295
Meaning like, you know, matter
意思是，你知道，如果我，如果我创建我的哈希表，我说有一百万个槽，不管我有一千个线程在它上面，还是一个线程在它上面，这都无关紧要。我永远都会有一百万个空位。作为一个问题，不管我有没有50万个密钥，数据结构都是一样的。

1456
00:36:09,265 --> 00:36:10,915
0,210 210,455 535,935 1195,1485 1485,1650
if I, if I create

1457
00:36:10,915 --> 00:36:12,100
0,120 120,315 315,575 715,960 960,1185
my hash table and I

1458
00:36:12,100 --> 00:36:13,680
0,380 610,855 855,960 960,1185 1185,1580
have say a million slots,

1459
00:36:13,970 --> 00:36:14,980
0,245 245,470 470,665 665,875 875,1010
it doesn't matter whether I

1460
00:36:14,980 --> 00:36:16,315
0,135 135,285 285,560 610,1110 1110,1335
have a thousand threads going

1461
00:36:16,315 --> 00:36:17,350
0,195 195,390 390,615 615,840 840,1035
at it or one thread

1462
00:36:17,350 --> 00:36:18,340
0,180 180,345 345,585 585,885 885,990
going at it. I'm always

1463
00:36:18,340 --> 00:36:18,775
0,75 75,120 120,195 195,270 270,435
going to have a million

1464
00:36:18,775 --> 00:36:19,855
0,365 565,795 795,870 870,960 960,1080
slots. And as a matter,

1465
00:36:19,855 --> 00:36:20,530
0,90 90,150 150,330 330,525 525,675
if I have, you know,

1466
00:36:20,530 --> 00:36:21,370
0,165 165,315 315,435 435,615 615,840
a half a million keys

1467
00:36:21,370 --> 00:36:22,480
0,150 150,270 270,390 390,650 850,1110
in it or not, the

1468
00:36:22,480 --> 00:36:23,425
0,210 210,450 450,645 645,810 810,945
data structure is always the

1469
00:36:23,425 --> 00:36:24,380
0,275
same.|
|

1470
00:36:24,570 --> 00:36:25,655
0,260 260,380 380,530 530,770 770,1085
In A B plus tree
A、B+树中所说的数据结构是，是自组织还是自平衡。当我向其中插入内容时，我开始删除其中的内容。它将开始自我重组。

1471
00:36:25,655 --> 00:36:27,065
0,255 255,405 405,645 645,1025 1045,1410
says the data structure is,

1472
00:36:27,065 --> 00:36:28,730
0,365 385,785 895,1245 1245,1530 1530,1665
is is self organize or

1473
00:36:28,730 --> 00:36:30,680
0,150 150,770 1000,1335 1335,1560 1560,1950
self balancing. As I insert

1474
00:36:30,680 --> 00:36:32,240
0,180 180,420 420,770 1000,1320 1320,1560
things into it, I start

1475
00:36:32,240 --> 00:36:33,770
0,300 300,465 465,630 630,890 1210,1530
deleting things from it. It's

1476
00:36:33,770 --> 00:36:35,560
0,75 75,165 165,410 670,1395 1395,1790
going to start reorganizing itself.|
|

1477
00:36:36,530 --> 00:36:37,135
0,230 230,305 305,395 395,470 470,605
So I need to make
因此，我需要确保在我重新组织事物时，出现了分裂。我确保必须确保数据结构是正确的。

1478
00:36:37,135 --> 00:36:38,515
0,180 180,330 330,555 555,840 840,1380
sure that as I'm reorganizing

1479
00:36:38,515 --> 00:36:39,925
0,240 240,510 510,810 810,1215 1215,1410
things, the splits emerges. I

1480
00:36:39,925 --> 00:36:41,590
0,195 195,405 405,695 1375,1605 1605,1665
make sure that I have

1481
00:36:41,590 --> 00:36:42,250
0,75 75,180 180,285 285,465 465,660
to make sure that the

1482
00:36:42,250 --> 00:36:43,820
0,165 165,375 375,615 615,950
data structure is correct.|
|

1483
00:36:45,230 --> 00:36:45,880
0,260 260,350 350,470 470,545 545,650
Right. So let's see how
正确的。因此，让我们看看事情会变得多么糟糕。假设我们这里有一条线索，他们想要删除底部的键44。那我该怎么做？我向下遍历，看着向导帖子标记，确定我是否想要左右移动，然后向下到达我的叶节点，然后继续删除它。

1484
00:36:45,880 --> 00:36:47,155
0,135 135,270 270,390 390,650 1000,1275
things can go bad. Say

1485
00:36:47,155 --> 00:36:48,090
0,150 150,300 300,450 450,630 630,935
we have a thread here

1486
00:36:48,290 --> 00:36:49,200
0,275 275,410 410,500 500,620 620,910
and they want to delete

1487
00:36:49,580 --> 00:36:51,210
0,275 275,790 1080,1325 1325,1400 1400,1630
key 44 at the bottom.

1488
00:36:51,740 --> 00:36:52,500
0,245 245,320 320,395 395,500 500,760
So what do I do?

1489
00:36:52,640 --> 00:36:54,085
0,335 335,665 665,970 1080,1325 1325,1445
I traverse down and I

1490
00:36:54,085 --> 00:36:54,910
0,135 135,255 255,390 390,585 585,825
look at the guide post

1491
00:36:54,910 --> 00:36:56,230
0,345 345,480 480,615 615,890 1060,1320
markers to figure out whether

1492
00:36:56,230 --> 00:36:56,650
0,105 105,180 180,225 225,300 300,420
I want to go left

1493
00:36:56,650 --> 00:36:57,370
0,120 120,315 315,495 495,585 585,720
and right and I reach

1494
00:36:57,370 --> 00:37:00,295
0,225 225,405 405,650 1630,2030 2650,2925
down to my my leaf

1495
00:37:00,295 --> 00:37:01,495
0,210 210,455 715,960 960,1065 1065,1200
node here and I go

1496
00:37:01,495 --> 00:37:02,560
0,120 120,255 255,405 405,665
ahead and delete it.|
|

1497
00:37:02,570 --> 00:37:03,235
0,230 230,350 350,485 485,575 575,665
But now I have to
但现在我必须重新平衡。我必须做一个合并，因为这个叶子的音符不到半满。所以也许我会从我的兄弟姐妹那里偷走一个条目。

1498
00:37:03,235 --> 00:37:04,030
0,450 450,555 555,630 630,720 720,795
rebalance. I have to do

1499
00:37:04,030 --> 00:37:05,500
0,90 90,420 420,540 540,800 1180,1470
a merge because this leaf

1500
00:37:05,500 --> 00:37:07,900
0,225 225,560 1840,2130 2130,2280 2280,2400
note is is less than

1501
00:37:07,900 --> 00:37:09,250
0,150 150,440 550,855 855,1050 1050,1350
half full. So maybe I'll

1502
00:37:09,250 --> 00:37:11,770
0,320 1090,1440 1440,1710 1710,2030 2230,2520
steal an entry from my

1503
00:37:11,770 --> 00:37:13,410
0,765 765,855 855,990 990,1380 1380,1640
sibling's gonna move 41 over.|
|

1504
00:37:14,120 --> 00:37:15,835
0,400 660,920 920,1180 1260,1520 1520,1715
Right, but before I can
对，但在我这么做之前。

1505
00:37:15,835 --> 00:37:17,220
0,255 255,575
do that.|
|

1506
00:37:17,410 --> 00:37:18,720
0,395 395,695 695,905 905,1115 1115,1310
Uh, my thread gets de
呃，我的线程被正确地取消了调度。不管出于什么原因，操作系统决定做一些事情。伽马射线降了下来。这无关紧要，对吧？我的线程不再运行了。

1507
00:37:18,720 --> 00:37:20,280
0,470 640,945 945,1155 1155,1350 1350,1560
scheduleded right. For whatever reason,

1508
00:37:20,280 --> 00:37:21,030
0,195 195,375 375,540 540,645 645,750
the OS decided to do

1509
00:37:21,030 --> 00:37:22,215
0,260 310,705 705,855 855,1020 1020,1185
something. Gamma rays came down.

1510
00:37:22,215 --> 00:37:24,045
0,105 105,300 300,545 745,1145 1525,1830
It doesn't matter, right? My

1511
00:37:24,045 --> 00:37:25,520
0,255 255,360 360,570 570,905
thread's not running anymore.|
|

1512
00:37:25,840 --> 00:37:27,915
0,245 245,490 1080,1480 1500,1835 1835,2075
So now, while while Fred
所以现在，当弗雷德一号睡着的时候，第二条线索出现了，他们想找到41，他们开始像以前一样向下遍历，他们到达了这里，对吗？再说一次，现在他们看着路标，他们沿着路标，他们意识到他们想要下到，右边的节点h。

1513
00:37:27,915 --> 00:37:29,115
0,150 150,330 330,665 715,1020 1020,1200
one is asleep, thread two

1514
00:37:29,115 --> 00:37:29,790
0,165 165,360 360,495 495,585 585,675
comes along and they want

1515
00:37:29,790 --> 00:37:31,515
0,90 90,300 300,890 1300,1575 1575,1725
to find 41 and they

1516
00:37:31,515 --> 00:37:32,460
0,150 150,555 555,690 690,825 825,945
start traversing down just like

1517
00:37:32,460 --> 00:37:33,320
0,165 165,330 330,435 435,570 570,860
before and they get here,

1518
00:37:33,730 --> 00:37:35,265
0,400 750,1040 1040,1220 1220,1400 1400,1535
right? And again, now they

1519
00:37:35,265 --> 00:37:36,180
0,75 75,150 150,240 240,690 690,915
look at the guidepost they

1520
00:37:36,180 --> 00:37:38,055
0,290 340,735 735,1130 1270,1575 1575,1875
follow the the they realize

1521
00:37:38,055 --> 00:37:38,760
0,255 255,345 345,420 420,525 525,705
they want to go down

1522
00:37:38,760 --> 00:37:39,495
0,165 165,330 330,495 495,585 585,735
to the, to the right

1523
00:37:39,495 --> 00:37:41,680
0,305 805,1170 1170,1445
to node h.|
|

1524
00:37:41,680 --> 00:37:43,230
0,180 180,405 405,675 675,885 885,1550
But now it gets rescheduled
但现在，无论出于什么原因，它都会被重新安排。

1525
00:37:43,280 --> 00:37:44,660
0,290 290,440 440,700
for whatever reason.|
|

1526
00:37:44,670 --> 00:37:46,940
0,275 275,550 1590,1880 1880,2060 2060,2270
And then thread one wakes
然后线程一醒来，移动了41。

1527
00:37:46,940 --> 00:37:49,240
0,290 460,810 810,1430
up, moves 41.|
|

1528
00:37:49,250 --> 00:37:50,575
0,290 290,530 530,860 860,1145 1145,1325
T want t thread, two
我不想线程，两次醒来，下到节点，以为是需要去的，现在钥匙不在那里了。

1529
00:37:50,575 --> 00:37:51,970
0,180 180,455 595,900 900,1140 1140,1395
wakes up, goes down to

1530
00:37:51,970 --> 00:37:52,750
0,180 180,405 405,570 570,660 660,780
the node, thought it was

1531
00:37:52,750 --> 00:37:53,490
0,135 135,210 210,285 285,435 435,740
need of the go to,

1532
00:37:53,720 --> 00:37:54,775
0,320 320,545 545,710 710,935 935,1055
and now the key's not

1533
00:37:54,775 --> 00:37:55,680
0,275
there.|
|

1534
00:37:57,490 --> 00:37:58,665
0,305 305,500 500,790 840,1085 1085,1175
Best case scenario, you get
最好的情况是，你会得到一个假阴性。最坏的情况是，你会崩溃。

1535
00:37:58,665 --> 00:38:00,255
0,105 105,285 285,555 555,905 1285,1590
a false negative here. Worst

1536
00:38:00,255 --> 00:38:02,200
0,195 195,485 535,825 825,1115
case scenario, you crash.|
|

1537
00:38:02,200 --> 00:38:03,480
0,285 285,510 510,705 705,1035 1035,1280
And the system fails, and
系统出现故障，您可能会损坏您的数据。

1538
00:38:03,740 --> 00:38:05,160
0,260 260,520 720,1040 1040,1175 1175,1420
you could corrupt your data.|
|

1539
00:38:07,550 --> 00:38:08,530
0,245 245,320 320,440 440,830 830,980
So we need latches to
所以我们需要插销来保护这东西。

1540
00:38:08,530 --> 00:38:09,660
0,165 165,315 315,590
protect this thing.|
|

1541
00:38:10,820 --> 00:38:11,725
0,260 260,365 365,485 485,695 695,905
And so the technique we're
因此，我们将使用的技术称为闩锁抓取或闩锁耦合。我想教科书把它叫做闩锁联轴器。我认为维基百科称其为闩锁耦合，对吧，但这基本上是我们在向下遍历树时要用来决定的协议。

1542
00:38:11,725 --> 00:38:12,460
0,45 45,120 120,315 315,540 540,735
going to use is called

1543
00:38:12,460 --> 00:38:13,765
0,270 270,630 630,735 735,930 930,1305
latch crabbing or latch coupling.

1544
00:38:13,765 --> 00:38:14,635
0,135 135,255 255,375 375,720 720,870
I think the textbook calls

1545
00:38:14,635 --> 00:38:15,595
0,135 135,330 330,720 720,840 840,960
it latch coupling. I think

1546
00:38:15,595 --> 00:38:17,020
0,275 355,975 975,1095 1095,1230 1230,1425
the Wikipedia calls it latch

1547
00:38:17,020 --> 00:38:19,120
0,195 195,620 850,1250 1750,1980 1980,2100
latch coupling, right, but it's

1548
00:38:19,120 --> 00:38:20,290
0,195 195,450 450,930 930,1110 1110,1170
basically the protocol we're going

1549
00:38:20,290 --> 00:38:23,860
0,90 90,350 490,890 1630,2030 3220,3570
to use to decide as

1550
00:38:23,860 --> 00:38:25,290
0,240 240,525 525,795 795,1095 1095,1430
we traverse down our tree.|
|

1551
00:38:26,020 --> 00:38:28,090
0,350 700,1100 1360,1860 1860,1965 1965,2070
Uh, what latches we want
呃，我们想拿什么插销，然后什么时候才能解开我们头顶上的插销？

1552
00:38:28,090 --> 00:38:29,830
0,135 135,410 850,1140 1140,1410 1410,1740
to take and then when

1553
00:38:29,830 --> 00:38:31,135
0,210 210,390 390,615 615,795 795,1305
can we release the latches

1554
00:38:31,135 --> 00:38:32,700
0,285 285,495 495,785
up above us?|
|

1555
00:38:32,710 --> 00:38:34,005
0,305 305,545 545,740 740,1100 1100,1295
Because again, the easiest way
因为同样，保护整个数据结构的最简单方法是在顶部放置一个巨大的闩锁，整个事情，然后每个人都必须通过门禁。但随后，这就成为了一个瓶颈。

1556
00:38:34,005 --> 00:38:34,905
0,195 195,360 360,525 525,690 690,900
to protect this entire data

1557
00:38:34,905 --> 00:38:35,970
0,240 240,405 405,615 615,840 840,1065
structure is put a giant

1558
00:38:35,970 --> 00:38:36,840
0,300 300,465 465,600 600,735 735,870
latch on top, the whole

1559
00:38:36,840 --> 00:38:38,130
0,290 580,840 840,975 975,1125 1125,1290
thing, and then everyone has

1560
00:38:38,130 --> 00:38:39,180
0,135 135,270 270,705 705,915 915,1050
to get gatekeep through. But

1561
00:38:39,180 --> 00:38:41,030
0,120 120,345 345,680 1000,1260 1260,1850
then that becomes a bottleneck.|
|

1562
00:38:41,480 --> 00:38:42,170
0,300 300,465 465,555 555,615 615,690
So we want to be
所以我们想变得更聪明，当我们知道可以的时候，有选择地释放我们的闩锁。

1563
00:38:42,170 --> 00:38:44,510
0,165 165,470 520,920 1510,2070 2070,2340
more clever and selectively release

1564
00:38:44,510 --> 00:38:45,485
0,210 210,555 555,705 705,840 840,975
our latches as we go

1565
00:38:45,485 --> 00:38:46,790
0,275 535,810 810,945 945,1065 1065,1305
down when we know it's

1566
00:38:46,790 --> 00:38:47,600
0,320
OK.|
|

1567
00:38:48,280 --> 00:38:49,370
0,215 215,275 275,440 440,815 815,1090
So the basic protocol is
所以基本的程序是，为了得到b+3，你总是把根设为最后一个。但是，一旦我在我的路线上，我想知道我是否想要左右移动，然后我拿到我孩子的插销，我将从当前的父母IM下，然后一旦我知道我没事，我可以去那里，如果我知道我现在的音符是安全的，我可以释放我的父母插销。

1568
00:38:49,600 --> 00:38:50,355
0,245 245,380 380,515 515,635 635,755
in order for me to

1569
00:38:50,355 --> 00:38:51,770
0,120 120,395 685,960 960,1125 1125,1415
go into b plus three,

1570
00:38:51,940 --> 00:38:54,180
0,400 1650,1895 1895,2015 2015,2135 2135,2240
I you always set to

1571
00:38:54,180 --> 00:38:55,770
0,165 165,330 330,540 540,890 1330,1590
last the root. But, but

1572
00:38:55,770 --> 00:38:56,670
0,135 135,315 315,375 375,615 615,900
once I'm in my my

1573
00:38:56,670 --> 00:38:57,945
0,290 460,705 705,855 855,1065 1065,1275
route and I I figure

1574
00:38:57,945 --> 00:38:58,920
0,210 210,515 595,840 840,915 915,975
out whether I want to

1575
00:38:58,920 --> 00:39:00,120
0,75 75,195 195,330 330,590 940,1200
go left and right and

1576
00:39:00,120 --> 00:39:01,020
0,120 120,285 285,525 525,690 690,900
then I acquire the latch

1577
00:39:01,020 --> 00:39:02,100
0,165 165,330 330,650 730,960 960,1080
of my child, that I'm

1578
00:39:02,100 --> 00:39:02,580
0,60 60,120 120,210 210,360 360,480
going to go down from

1579
00:39:02,580 --> 00:39:03,410
0,90 90,255 255,450 450,600 600,830
the current parent IM at

1580
00:39:03,700 --> 00:39:04,590
0,260 260,395 395,545 545,770 770,890
and then once I'm know

1581
00:39:04,590 --> 00:39:06,075
0,285 285,590 850,1140 1140,1365 1365,1485
I'm okay and I'm able

1582
00:39:06,075 --> 00:39:07,110
0,120 120,255 255,545 625,885 885,1035
to go there, I can

1583
00:39:07,110 --> 00:39:09,120
0,290 640,960 960,1215 1215,1580 1750,2010
release my parent latch for

1584
00:39:09,120 --> 00:39:09,890
0,120 120,270 270,420 420,555 555,770
that current note I'm at

1585
00:39:10,210 --> 00:39:11,250
0,365 365,590 590,725 725,845 845,1040
if if I know it's

1586
00:39:11,250 --> 00:39:12,060
0,260
safe.|
|

1587
00:39:12,910 --> 00:39:14,070
0,245 245,350 350,610 660,965 965,1160
And the definition of safe
安全的定义将是，我们知道基于我们试图执行的操作，插入或删除。

1588
00:39:14,070 --> 00:39:14,810
0,165 165,270 270,330 330,450 450,740
is going to be that

1589
00:39:15,130 --> 00:39:17,115
0,305 305,610 660,1060 1530,1835 1835,1985
we know that based on

1590
00:39:17,115 --> 00:39:17,970
0,180 180,435 435,660 660,750 750,855
the operation we're trying to

1591
00:39:17,970 --> 00:39:20,140
0,260 280,840 840,1110 1110,1460
do, insert or delete.|
|

1592
00:39:20,140 --> 00:39:22,210
0,350 790,1095 1095,1155 1155,1610 1780,2070
If it's an insert, we
如果它是插入的，我们知道孩子没有填满，因此如果我，如果我在插入钥匙时必须拆分，它不会导致在那个童年进行分裂，这可能会传播到父级。

1593
00:39:22,210 --> 00:39:23,815
0,210 210,530 580,915 915,1200 1200,1605
know that the child isn't

1594
00:39:23,815 --> 00:39:26,010
0,335 535,930 930,1325 1435,1815 1815,2195
full and therefore if I,

1595
00:39:26,360 --> 00:39:27,210
0,260 260,395 395,530 530,620 620,850
if I had to do

1596
00:39:27,590 --> 00:39:30,625
0,350 350,700 2550,2795 2795,2885 2885,3035
a split when I insert

1597
00:39:30,625 --> 00:39:31,630
0,135 135,425 535,840 840,930 930,1005
my key, it's not going

1598
00:39:31,630 --> 00:39:32,275
0,90 90,225 225,360 360,465 465,645
to cause to do a

1599
00:39:32,275 --> 00:39:33,805
0,255 255,450 450,725 925,1290 1290,1530
split at that childhood, which

1600
00:39:33,805 --> 00:39:34,825
0,150 150,300 300,690 690,885 885,1020
may get propagated up to

1601
00:39:34,825 --> 00:39:35,680
0,120 120,395
the parent.|
|

1602
00:39:35,870 --> 00:39:36,610
0,290 290,500 500,575 575,665 665,740
If I'm going to do
如果我要执行删除，如果我知道它已满了一半以上，那么，如果我删除一个键，我知道我不会执行合并，这也是我们将事情向上传播到我的父节点。

1603
00:39:36,610 --> 00:39:38,170
0,120 120,410 1060,1290 1290,1395 1395,1560
a delete, if I know

1604
00:39:38,170 --> 00:39:38,860
0,105 105,255 255,375 375,510 510,690
that it's more than half

1605
00:39:38,860 --> 00:39:39,775
0,270 270,510 510,645 645,735 735,915
full, then again, if I

1606
00:39:39,775 --> 00:39:40,765
0,210 210,360 360,570 570,780 780,990
remove a key, I know

1607
00:39:40,765 --> 00:39:41,380
0,255 255,360 360,465 465,540 540,615
I'm not going to do

1608
00:39:41,380 --> 00:39:42,250
0,90 90,405 405,570 570,720 720,870
a merge, which again, we

1609
00:39:42,250 --> 00:39:44,275
0,390 390,585 585,795 795,1100 1630,2025
propagate things up to my

1610
00:39:44,275 --> 00:39:45,600
0,300 300,540 540,815
parent node here.|
|

1611
00:39:45,930 --> 00:39:47,140
0,400
Right.|
正确的。|

1612
00:39:47,810 --> 00:39:48,820
0,260 260,365 365,455 455,620 620,1010
So again, the basic protocol
所以，再一次，基本的协议是我开始了根优先向下合唱团，在我向下的过程中读取每个孩子的锁存，因为我再次进行了读取操作。我不是在做更新，然后我只是打开我的父母。

1613
00:39:48,820 --> 00:39:49,585
0,135 135,285 285,435 435,570 570,765
is I started the root

1614
00:39:49,585 --> 00:39:51,445
0,240 240,545 865,1260 1260,1500 1500,1860
first down choir, read latches

1615
00:39:51,445 --> 00:39:52,345
0,120 120,285 285,555 555,750 750,900
on every child as I'm

1616
00:39:52,345 --> 00:39:53,560
0,150 150,420 420,660 660,855 855,1215
going down because again, I'm

1617
00:39:53,560 --> 00:39:54,790
0,210 210,330 330,525 525,860 940,1230
doing a read operation. I'm

1618
00:39:54,790 --> 00:39:56,425
0,135 135,420 420,800 1240,1515 1515,1635
not doing updates, and then

1619
00:39:56,425 --> 00:39:57,360
0,90 90,195 195,495 495,660 660,935
I just unlatch my parent.|
|

1620
00:39:58,010 --> 00:39:59,770
0,400 660,920 920,1070 1070,1475 1475,1760
EM for doing inserted delete,
对于执行插入删除操作的EM，我开始了路线，当我下山时拿着右锁，然后一旦我有了我的孩子，我就知道我将进入正确的模式。

1621
00:39:59,770 --> 00:40:00,760
0,255 255,405 405,540 540,735 735,990
I start the route, taking

1622
00:40:00,760 --> 00:40:01,855
0,210 210,630 630,840 840,960 960,1095
right latches as I go

1623
00:40:01,855 --> 00:40:04,420
0,275 655,960 960,1265 2125,2415 2415,2565
down and then once I

1624
00:40:04,420 --> 00:40:05,380
0,135 135,375 375,675 675,870 870,960
have my child, know that

1625
00:40:05,380 --> 00:40:06,300
0,120 120,195 195,360 360,600 600,920
I'm going to move to

1626
00:40:06,350 --> 00:40:07,820
0,305 305,515 515,820
in right mode.|
|

1627
00:40:07,820 --> 00:40:08,615
0,255 255,375 375,510 510,675 675,795
Then I go check to
然后我去检查它是否安全，是否安全，我可以去解开我头顶上的任何闩锁。

1628
00:40:08,615 --> 00:40:09,830
0,105 105,210 210,405 405,665 955,1215
see whether it's safe and

1629
00:40:09,830 --> 00:40:10,685
0,120 120,240 240,435 435,690 690,855
if it is safe and

1630
00:40:10,685 --> 00:40:11,495
0,75 75,165 165,345 345,570 570,810
I can go release any

1631
00:40:11,495 --> 00:40:12,485
0,360 360,450 450,600 600,810 810,990
latches I have up above

1632
00:40:12,485 --> 00:40:13,380
0,275
me.|
|

1633
00:40:15,200 --> 00:40:15,880
0,230 230,380 380,455 455,575 575,680
So let's go back to
所以让我们回到这里的例子。所以我想找到键38，我从根开始，把根取进去，在根节点中，在右锁存模式下，我开始抱歉了。然后我获得了b上的读取闩锁，然后我向下移动，在这里，我可以安全地释放a上的闩锁，因为它再次执行读取操作。我已经到达了我需要去的地方，所以我要去那里，这样我就可以继续前进，松开b上的闩锁。

1634
00:40:15,880 --> 00:40:16,945
0,90 90,270 270,590 760,990 990,1065
our example here. So I

1635
00:40:16,945 --> 00:40:18,060
0,75 75,165 165,375 375,615 615,1115
want to find key 38

1636
00:40:18,650 --> 00:40:20,020
0,305 305,530 530,710 710,970 1110,1370
I start the root, take

1637
00:40:20,020 --> 00:40:21,900
0,135 135,330 330,570 570,890 1480,1880
the root in, in root

1638
00:40:21,980 --> 00:40:23,970
0,440 440,730 990,1295 1295,1610 1610,1990
node in right latch mode,

1639
00:40:25,190 --> 00:40:26,545
0,275 275,440 440,725 725,1040 1040,1355
I get down to sorry.

1640
00:40:26,545 --> 00:40:28,050
0,255 255,390 390,645 645,995 1105,1505
Then I acquire the the

1641
00:40:28,190 --> 00:40:29,695
0,290 290,545 545,740 740,1030 1260,1505
read latch on b, then

1642
00:40:29,695 --> 00:40:30,775
0,105 105,255 255,545 775,1005 1005,1080
I move down and at

1643
00:40:30,775 --> 00:40:31,870
0,150 150,375 375,630 630,930 930,1095
this point here, it's safe

1644
00:40:31,870 --> 00:40:32,635
0,150 150,285 285,450 450,630 630,765
for me to release the

1645
00:40:32,635 --> 00:40:35,065
0,275 295,695 1165,1440 1440,1715 2155,2430
latch on on a because

1646
00:40:35,065 --> 00:40:35,995
0,165 165,450 450,615 615,720 720,930
again, it's doing a read

1647
00:40:35,995 --> 00:40:37,720
0,365 715,1035 1035,1215 1215,1500 1500,1725
operation. I've already arrived at

1648
00:40:37,720 --> 00:40:38,365
0,195 195,345 345,435 435,540 540,645
b where I need to

1649
00:40:38,365 --> 00:40:39,085
0,180 180,390 390,555 555,630 630,720
go, so I'm going to

1650
00:40:39,085 --> 00:40:40,165
0,120 120,395 655,885 885,975 975,1080
go there so I can

1651
00:40:40,165 --> 00:40:40,795
0,120 120,240 240,360 360,510 510,630
go ahead and release the

1652
00:40:40,795 --> 00:40:42,020
0,180 180,375 375,665
latch on b.|
|

1653
00:40:42,030 --> 00:40:43,190
0,275 275,395 395,665 665,920 920,1160
Get the latch rel latch
将闩锁扣上。D，同样的事情。松开b上的闩锁对我来说是安全的，所以我会继续这样做，我下到h，依此类推，我终于拿到了我要找的钥匙，我完成了。

1654
00:40:43,190 --> 00:40:44,765
0,300 300,650 790,1080 1080,1305 1305,1575
on. D, same thing. It's

1655
00:40:44,765 --> 00:40:45,275
0,120 120,240 240,315 315,390 390,510
safe for me to release

1656
00:40:45,275 --> 00:40:46,025
0,120 120,270 270,420 420,615 615,750
the latch on b, so

1657
00:40:46,025 --> 00:40:46,400
0,90 90,150 150,225 225,285 285,375
I'll go ahead and do

1658
00:40:46,400 --> 00:40:47,555
0,260 580,825 825,930 930,1035 1035,1155
that and I get down

1659
00:40:47,555 --> 00:40:48,755
0,120 120,365 655,945 945,1095 1095,1200
to h and so forth

1660
00:40:48,755 --> 00:40:49,325
0,75 75,165 165,315 315,465 465,570
and I finally get the

1661
00:40:49,325 --> 00:40:50,060
0,90 90,240 240,360 360,585 585,735
key I'm looking for, and

1662
00:40:50,060 --> 00:40:50,840
0,120 120,350
I'm done.|
|

1663
00:40:55,040 --> 00:40:56,915
0,180 180,525 525,800 1360,1680 1680,1875
Late 38 now again started
38岁末，现在再次开始了根子。我把根放在根锁存中，根节点在右模式锁存。

1664
00:40:56,915 --> 00:40:57,545
0,135 135,285 285,420 420,510 510,630
the root. I get the

1665
00:40:57,545 --> 00:40:59,200
0,180 180,435 435,785 1045,1335 1335,1655
root in in root latch

1666
00:40:59,370 --> 00:41:00,590
0,275 275,440 440,680 680,920 920,1220
the root node in right

1667
00:41:00,590 --> 00:41:01,960
0,225 225,560
mode latch.|
|

1668
00:41:02,480 --> 00:41:03,490
0,275 275,395 395,500 500,680 680,1010
I get a right latch
我把b锁住了，就搬到这里来。

1669
00:41:03,490 --> 00:41:05,190
0,360 360,740 820,1125 1125,1365 1365,1700
on b, move down here.|
|

1670
00:41:05,920 --> 00:41:07,165
0,240 240,420 420,675 675,975 975,1245
And again, at this point
再说一次，在这一点上，如果我，如果我这样做了，我不知道在b下面的树中我下面会发生什么，因为如果我知道我是否必须从我当前所在的音符和b中删除一个键，我将不得不进行合并。因此，我不能释放我父母a上的闩锁，因为我，我可能不得不去更改上面的a of。

1671
00:41:07,165 --> 00:41:09,880
0,335 1675,1950 1950,2220 2220,2475 2475,2715
here, if I, if I

1672
00:41:09,880 --> 00:41:10,870
0,380 430,675 675,825 825,870 870,990
do, I don't know what's

1673
00:41:10,870 --> 00:41:11,470
0,60 60,120 120,240 240,450 450,600
going to happen below me

1674
00:41:11,470 --> 00:41:12,450
0,75 75,210 210,390 390,630 630,980
in the tree below b

1675
00:41:12,950 --> 00:41:14,455
0,350 350,700 900,1160 1160,1325 1325,1505
and because if I know

1676
00:41:14,455 --> 00:41:15,310
0,120 120,240 240,375 375,585 585,855
if I have to delete

1677
00:41:15,310 --> 00:41:16,495
0,210 210,465 465,795 795,1035 1035,1185
a key from the note

1678
00:41:16,495 --> 00:41:17,610
0,195 195,360 360,570 570,795 795,1115
I'm currently at and b,

1679
00:41:17,930 --> 00:41:18,805
0,335 335,470 470,635 635,770 770,875
I'm gonna have to do

1680
00:41:18,805 --> 00:41:20,695
0,150 150,755 955,1350 1350,1665 1665,1890
a merge. So therefore I

1681
00:41:20,695 --> 00:41:21,700
0,315 315,495 495,645 645,855 855,1005
can't release the latch on

1682
00:41:21,700 --> 00:41:24,175
0,165 165,500 850,1250 1810,2190 2190,2475
my parent a, because I

1683
00:41:24,175 --> 00:41:24,985
0,180 180,345 345,495 495,615 615,810
I may have to go

1684
00:41:24,985 --> 00:41:25,960
0,240 240,480 480,675 675,795 795,975
make changes to a of

1685
00:41:25,960 --> 00:41:26,840
0,320
above.|
|

1686
00:41:26,850 --> 00:41:27,500
0,230 230,350 350,395 395,470 470,650
So I'm going to hold
所以我将保持b和a的右锁，现在到D，我看到无论我在树的下面发生了什么，如果我必须从D，D中删除一个键，它将不会进行合并。

1687
00:41:27,500 --> 00:41:28,840
0,180 180,345 345,615 615,945 945,1340
the right latch on on

1688
00:41:28,890 --> 00:41:30,485
0,335 335,605 605,800 800,1060 1320,1595
on b and a get

1689
00:41:30,485 --> 00:41:32,270
0,165 165,360 360,665 1195,1545 1545,1785
down to d now at

1690
00:41:32,270 --> 00:41:33,305
0,165 165,345 345,540 540,810 810,1035
D I see that no

1691
00:41:33,305 --> 00:41:34,925
0,165 165,485 895,1275 1275,1500 1500,1620
matter what happens to me

1692
00:41:34,925 --> 00:41:37,130
0,275 295,555 555,720 720,1025 1945,2205
below in the tree, if

1693
00:41:37,130 --> 00:41:37,865
0,120 120,240 240,360 360,540 540,735
I had to remove a

1694
00:41:37,865 --> 00:41:38,960
0,180 180,420 420,735 735,960 960,1095
key from D D, it's

1695
00:41:38,960 --> 00:41:39,880
0,105 105,210 210,300 300,540 540,920
not going to do do

1696
00:41:39,900 --> 00:41:41,260
0,230 230,335 335,880
do a merge.|
|

1697
00:41:41,260 --> 00:41:41,995
0,240 240,390 390,540 540,645 645,735
And therefore, it's not going
因此，它不会在它上面做任何改变。因此，我可以安全地松开A和B上的闩锁。

1698
00:41:41,995 --> 00:41:42,835
0,45 45,120 120,285 285,570 570,840
to make any changes up

1699
00:41:42,835 --> 00:41:44,440
0,195 195,485 835,1155 1155,1440 1440,1605
above it. So it's safe

1700
00:41:44,440 --> 00:41:45,055
0,150 150,255 255,345 345,465 465,615
for me to go ahead

1701
00:41:45,055 --> 00:41:46,650
0,275 445,735 735,885 885,1275 1275,1595
and release the latches on

1702
00:41:47,180 --> 00:41:48,480
0,275 275,425 425,700
a and b.|
|

1703
00:41:49,890 --> 00:41:51,170
0,275 275,410 410,590 590,910 990,1280
Does the order matter? Sorry,
顺序重要吗？抱歉，我有个问题。哪个节点是安全节点？

1704
00:41:51,170 --> 00:41:53,000
0,290 1000,1335 1335,1575 1575,1680 1680,1830
question. Which node is the

1705
00:41:53,000 --> 00:41:54,140
0,225 225,710
safe node?|
|

1706
00:41:54,515 --> 00:41:55,600
0,90 90,150 150,285 285,575 685,1085
Whatever you're at now, whatever
不管你现在在做什么，不管是什么。

1707
00:41:55,800 --> 00:41:57,280
0,400
the.|
|

1708
00:41:57,280 --> 00:41:58,720
0,350 430,690 690,950 1030,1290 1380,1440
So if I, if I'm
所以如果我，如果我在B。

1709
00:41:58,720 --> 00:42:00,080
0,165 165,500
at b.|
|

1710
00:42:00,120 --> 00:42:01,270
0,275 275,410 410,665 665,905 905,1150
I get the and I
我得到了，我需要去D，所以我得到了正确的结果。我将闩锁设置为正确模式。

1711
00:42:01,440 --> 00:42:02,290
0,245 245,335 335,425 425,560 560,850
need to go to d,

1712
00:42:02,610 --> 00:42:03,275
0,230 230,290 290,410 410,560 560,665
so I get I get

1713
00:42:03,275 --> 00:42:04,025
0,105 105,225 225,435 435,645 645,750
it in right. I get

1714
00:42:04,025 --> 00:42:04,870
0,105 105,240 240,360 360,540 540,845
the latch in right mode.|
|

1715
00:42:05,600 --> 00:42:06,470
0,150 150,285 285,495 495,645 645,870
And then now I have
现在我有了时尚。然后我检查一下，我安全了吗？上面的每个人。

1716
00:42:06,470 --> 00:42:07,655
0,345 345,585 585,735 735,975 975,1185
mode. Then I check, am

1717
00:42:07,655 --> 00:42:17,540
0,165 165,485 7855,8205 8205,8555
I safe? Everybody above.|
|

1718
00:42:17,700 --> 00:42:19,010
0,320 320,640 660,935 935,1070 1070,1310
It being more than half.|
已经超过一半了。|

1719
00:42:21,680 --> 00:42:23,035
0,260 260,425 425,620 620,910 1080,1355
This question is is is
这个问题是半满的吗？唯一的检查是看它是否安全，还有什么，如果发生了，还会导致合并。

1720
00:42:23,035 --> 00:42:24,400
0,165 165,360 360,600 600,935 1105,1365
it being half full? The

1721
00:42:24,400 --> 00:42:25,855
0,260 550,900 900,1170 1170,1350 1350,1455
only check to see whether

1722
00:42:25,855 --> 00:42:27,570
0,180 180,425 865,1230 1230,1455 1455,1715
it's safe and what else,

1723
00:42:27,920 --> 00:42:29,560
0,260 260,410 410,605 605,910 1350,1640
what else would cause a

1724
00:42:29,560 --> 00:42:30,540
0,330 330,465 465,615 615,735 735,980
merge in case of a.|
|

1725
00:42:31,550 --> 00:42:32,480
0,400
Delete.|
删除。|

1726
00:42:34,790 --> 00:42:35,590
0,320 320,380 380,500 500,650 650,800
That's the thing we only
这是我们唯一关心的事情，就像出现分裂一样。我们正在努力确保我们不会把自己搞砸。

1727
00:42:35,590 --> 00:42:37,150
0,150 150,390 390,770 820,1140 1140,1560
care about, like splits emerges.

1728
00:42:37,150 --> 00:42:37,945
0,285 285,345 345,495 495,675 675,795
We're trying to make sure

1729
00:42:37,945 --> 00:42:38,680
0,90 90,180 180,375 375,570 570,735
that we don't screw ourselves

1730
00:42:38,680 --> 00:42:39,640
0,120 120,380
with that.|
|

1731
00:42:43,330 --> 00:42:44,900
0,320 320,640
Right, so.|
对，所以。|

1732
00:42:45,860 --> 00:42:46,780
0,275 275,425 425,575 575,725 725,920
So at this one here
所以在d的这个位置，我们必须松开a和b上的闩锁。

1733
00:42:46,780 --> 00:42:48,355
0,255 255,590 1060,1320 1320,1440 1440,1575
at d, we had to

1734
00:42:48,355 --> 00:42:49,180
0,150 150,285 285,570 570,690 690,825
release the latches on a

1735
00:42:49,180 --> 00:42:50,260
0,135 135,410
and b.|
|

1736
00:42:50,360 --> 00:42:51,630
0,260 260,515 515,785 785,965 965,1270
Because, again, d is safe.|
因为，再说一次，d是安全的。|

1737
00:42:52,420 --> 00:42:53,200
0,150 150,270 270,450 450,630 630,780
Does the order in which
我们释放这些闩锁的顺序重要吗？

1738
00:42:53,200 --> 00:42:54,450
0,255 255,480 480,630 630,975 975,1250
we release those latches matter?|
|

1739
00:42:56,080 --> 00:42:57,680
0,240 240,495 495,780 780,1160
Makes more sense to.|
更有意义的是。|

1740
00:42:57,910 --> 00:42:59,080
0,335 335,670
Going up.|
往上走。|

1741
00:43:01,300 --> 00:43:02,145
0,290 290,470 470,590 590,695 695,845
He says it makes more
他说，从底部到顶部，先放b，再放一个为什么，这样做更有意义。

1742
00:43:02,145 --> 00:43:03,915
0,275 655,1055 1135,1425 1425,1575 1575,1770
sense going from the bottom

1743
00:43:03,915 --> 00:43:04,785
0,165 165,255 255,390 390,555 555,870
to the top by releasing

1744
00:43:04,785 --> 00:43:06,320
0,255 255,510 510,675 675,935 1135,1535
b, followed by a why.|
|

1745
00:43:07,610 --> 00:43:08,940
0,365 365,620 620,860 860,1210
Someone is waiting on.|
有人在等着。|

1746
00:43:13,370 --> 00:43:14,440
0,305 305,500 500,665 665,860 860,1070
Also released that it does
也发布了它不会的消息。

1747
00:43:14,440 --> 00:43:14,640
0,150
not.|
|

1748
00:43:18,000 --> 00:43:20,230
0,400 1200,1430 1430,1580 1580,1865 1865,2230
So if I release b
所以如果我放了b，有人在等a。

1749
00:43:20,760 --> 00:43:21,850
0,275 275,515 515,650 650,815 815,1090
and someone waiting for a.|
|

1750
00:43:25,040 --> 00:43:26,160
0,400
Yes.|
是。|

1751
00:43:30,840 --> 00:43:31,610
0,230 230,335 335,485 485,620 620,770
So, he says, if you
所以，他说，如果你释放b。

1752
00:43:31,610 --> 00:43:32,980
0,210 210,530
release b.|
|

1753
00:43:34,100 --> 00:43:35,845
0,245 245,335 335,580 1380,1625 1625,1745
Then it does the other
然后它做另一个线程，等待b或a，对不起，在相同的路径上。

1754
00:43:35,845 --> 00:43:36,625
0,165 165,345 345,495 495,630 630,780
thread, waiting for b or

1755
00:43:36,625 --> 00:43:39,190
0,240 240,605 1975,2250 2250,2430 2430,2565
a sorry yeah has on

1756
00:43:39,190 --> 00:43:41,020
0,60 60,180 180,470
the same path.|
|

1757
00:43:41,300 --> 00:43:42,140
0,120 120,285 285,525 525,690 690,840
Try to acquire a lock
试着锁定航空公司。

1758
00:43:42,140 --> 00:43:43,300
0,165 165,710
on airways.|
|

1759
00:43:43,970 --> 00:43:45,480
0,260 260,470 470,635 635,880 1110,1510
A latch, but yes, yeah,
一个插销，但是，是的，是的，好的。

1760
00:43:46,730 --> 00:43:47,800
0,400
okay.|
|

1761
00:43:48,020 --> 00:43:48,700
0,230 230,290 290,425 425,590 590,680
But if I release it
但如果我在b上释放它，它仍在等待a。

1762
00:43:48,700 --> 00:43:49,555
0,120 120,345 345,570 570,690 690,855
on b, it still waiting

1763
00:43:49,555 --> 00:43:50,680
0,150 150,395
for a.|
|

1764
00:43:52,870 --> 00:43:53,900
0,275 275,470 470,650 650,770 770,1030
Also, too, what if I
同样，如果我有一个线程正在等待，但我想从树的这一边下来怎么办？

1765
00:43:53,980 --> 00:43:55,455
0,230 230,380 380,700 1020,1340 1340,1475
have a thread that's waiting

1766
00:43:55,455 --> 00:43:56,085
0,150 150,330 330,480 480,540 540,630
for a but I want

1767
00:43:56,085 --> 00:43:56,910
0,75 75,150 150,300 300,540 540,825
to go down this side

1768
00:43:56,910 --> 00:43:58,080
0,195 195,330 330,620
of the tree?|
|

1769
00:43:58,430 --> 00:44:00,300
0,335 335,575 575,800 800,1120
But I release b.|
但我会释放b。|

1770
00:44:00,390 --> 00:44:01,720
0,105 105,270 270,560
It's still blocked.|
它还是被封住了。|

1771
00:44:02,470 --> 00:44:03,740
0,275 275,395 395,560 560,980 980,1270
So from a correctness reason,
所以从正确的理由来看，从正确的角度来看，这实际上并不重要。

1772
00:44:04,000 --> 00:44:05,385
0,245 245,350 350,725 725,1090 1140,1385
from a correctness standpoint, it

1773
00:44:05,385 --> 00:44:06,780
0,270 270,435 435,695
doesn't actually matter.|
|

1774
00:44:06,780 --> 00:44:08,150
0,225 225,465 465,690 690,1005 1005,1370
Like the system, the the
就像系统一样，无论你从底部到顶部，从底部的顶部，数据结构都将是正确的。出于性能原因，我们想要自上而下，因为我们想要发布。就像你想的那样，门闩是在保护它下面的一切。因此，如果我在根上保持右锁存，我就是在以正确的模式保护整个数据结构。

1775
00:44:08,170 --> 00:44:09,120
0,305 305,515 515,680 680,800 800,950
data structure will still be

1776
00:44:09,120 --> 00:44:10,980
0,225 225,450 450,740 1480,1740 1740,1860
correct whether you go from

1777
00:44:10,980 --> 00:44:11,595
0,105 105,255 255,390 390,465 465,615
the bottom to the top,

1778
00:44:11,595 --> 00:44:12,855
0,150 150,225 225,315 315,575 895,1260
top of the bottom. For

1779
00:44:12,855 --> 00:44:13,980
0,330 330,690 690,945 945,1050 1050,1125
performance reasons, we want to

1780
00:44:13,980 --> 00:44:15,855
0,135 135,360 360,680 1510,1770 1770,1875
go top down because we

1781
00:44:15,855 --> 00:44:17,070
0,90 90,225 225,515 715,1035 1035,1215
want to release. Like you

1782
00:44:17,070 --> 00:44:17,595
0,120 120,225 225,330 330,450 450,525
way to think about it

1783
00:44:17,595 --> 00:44:18,950
0,165 165,390 390,585 585,825 825,1355
is the latch is protecting

1784
00:44:19,300 --> 00:44:20,610
0,260 260,470 470,820 1020,1250 1250,1310
everything below it. So if

1785
00:44:20,610 --> 00:44:21,500
0,105 105,255 255,390 390,555 555,890
I hold a right latch

1786
00:44:21,550 --> 00:44:22,890
0,260 260,380 380,640 660,1085 1085,1340
on the root, I'm protecting

1787
00:44:22,890 --> 00:44:24,210
0,165 165,470 640,945 945,1155 1155,1320
the entire data structure in

1788
00:44:24,210 --> 00:44:25,120
0,150 150,440
right mode.|
|

1789
00:44:25,120 --> 00:44:26,140
0,290
Right.|
正确的。|

1790
00:44:26,390 --> 00:44:27,980
0,400
Um.|
恩。|

1791
00:44:28,860 --> 00:44:29,615
0,260 260,380 380,545 545,680 680,755
Now, there may be a
现在，这里可能有一堆读线程和其他线程在做一些事情，但这没有关系，因为它会这样做。

1792
00:44:29,615 --> 00:44:30,860
0,105 105,330 330,660 660,1095 1095,1245
bunch of read threads and

1793
00:44:30,860 --> 00:44:32,285
0,225 225,680 730,1050 1050,1230 1230,1425
other threads doing stuff over

1794
00:44:32,285 --> 00:44:34,180
0,335 745,1005 1005,1290 1290,1545 1545,1895
here, but that's okay because

1795
00:44:34,440 --> 00:44:35,680
0,275 275,410 410,670
it would have.|
|

1796
00:44:35,690 --> 00:44:37,705
0,400 510,830 830,1510 1620,1865 1865,2015
If their modifications would have
如果他们的修改会导致我们进行拆分或合并，然后向上轮胎到轮胎的根部，他们仍然必须在这上面握住正确的闩锁。

1797
00:44:37,705 --> 00:44:38,740
0,225 225,435 435,585 585,780 780,1035
caused us to do a

1798
00:44:38,740 --> 00:44:40,590
0,180 180,315 315,890 1030,1430 1450,1850
split or merge then up

1799
00:44:40,790 --> 00:44:41,790
0,260 260,470 470,635 635,740 740,1000
the tire to the root,

1800
00:44:41,900 --> 00:44:42,700
0,245 245,350 350,485 485,650 650,800
they would have to still

1801
00:44:42,700 --> 00:44:43,780
0,260 400,645 645,780 780,960 960,1080
hold the right latch on

1802
00:44:43,780 --> 00:44:44,740
0,260
this.|
|

1803
00:44:45,450 --> 00:44:47,630
0,335 335,670 1290,1655 1655,1910 1910,2180
So again, the main takeaway
因此，再一次，主要的结论是我们希望尽快释放闩锁。因此，我们希望发布的锁存将具有最多的锁存，从而最大限度地释放我们数据结构中的大多数工作人员。所以我们总是希望至少从顶层往下走。

1804
00:44:47,630 --> 00:44:48,050
0,60 60,135 135,240 240,345 345,420
is that we want to

1805
00:44:48,050 --> 00:44:48,950
0,150 150,510 510,645 645,780 780,900
release latches as soon as

1806
00:44:48,950 --> 00:44:50,525
0,260 790,1155 1155,1365 1365,1470 1470,1575
possible. So, and we want

1807
00:44:50,525 --> 00:44:51,815
0,150 150,360 360,795 795,1080 1080,1290
to release latches that will

1808
00:44:51,815 --> 00:44:53,195
0,180 180,390 390,695 955,1200 1200,1380
have the most that would

1809
00:44:53,195 --> 00:44:56,225
0,195 195,330 330,495 495,785 2755,3030
free up the most, most

1810
00:44:56,225 --> 00:44:57,335
0,120 120,240 240,515 775,1005 1005,1110
of our workers in our

1811
00:44:57,335 --> 00:44:58,580
0,180 180,485 775,1005 1005,1110 1110,1245
data structure. So we always

1812
00:44:58,580 --> 00:44:59,345
0,105 105,195 195,450 450,630 630,765
want at lease from the

1813
00:44:59,345 --> 00:45:00,680
0,180 180,390 390,695
top going down.|
|

1814
00:45:03,660 --> 00:45:04,280
0,275 275,380 380,455 455,530 530,620
Right. So then we get
正确的。然后我们下到这里，我们找到了合适的门闩。继续删除我们的内容，我们就完成了。

1815
00:45:04,280 --> 00:45:05,165
0,165 165,435 435,660 660,765 765,885
down here and we get

1816
00:45:05,165 --> 00:45:06,550
0,275 415,705 705,915 915,1095 1095,1385
the right latch on. H,

1817
00:45:06,900 --> 00:45:09,125
0,275 275,530 530,910 1830,2075 2075,2225
go ahead and do our

1818
00:45:09,125 --> 00:45:10,380
0,195 195,315 315,435 435,665
delete and we're done.|
|

1819
00:45:12,710 --> 00:45:13,375
0,230 230,350 350,470 470,605 605,665
All right, so let's look
好的，让我们来看另一个例子。我将插入45个相同的想法。在这一点上，我得到了a向下到b的根上的正确闩锁。我知道，如果，如果树上我下面的任何东西，如果它必须分裂，我在b中有空间容纳另一把钥匙。所以我可以去松开门闩了。

1820
00:45:13,375 --> 00:45:14,320
0,90 90,255 255,575 595,900 900,945
at another example. I'm going

1821
00:45:14,320 --> 00:45:15,750
0,45 45,285 285,770 790,1110 1110,1430
to insert 45 same idea.

1822
00:45:15,920 --> 00:45:16,830
0,260 260,350 350,440 440,590 590,910
I get the right latch

1823
00:45:16,850 --> 00:45:18,030
0,320 320,485 485,680 680,905 905,1180
on the root on a

1824
00:45:18,290 --> 00:45:19,585
0,260 260,395 395,545 545,820 1050,1295
go down to b at

1825
00:45:19,585 --> 00:45:20,755
0,150 150,390 390,675 675,930 930,1170
this point here. I know

1826
00:45:20,755 --> 00:45:24,220
0,335 1645,2045 2155,2555 2845,3210 3210,3465
that if, if whatever is

1827
00:45:24,220 --> 00:45:25,200
0,240 240,420 420,510 510,675 675,980
below me in the tree,

1828
00:45:25,430 --> 00:45:26,125
0,245 245,350 350,485 485,605 605,695
if it has to do

1829
00:45:26,125 --> 00:45:28,015
0,165 165,485 655,945 945,1235 1525,1890
a split, I have room

1830
00:45:28,015 --> 00:45:29,785
0,365 535,930 930,1200 1200,1560 1560,1770
in b to accommodate another

1831
00:45:29,785 --> 00:45:31,345
0,335 655,960 960,1260 1260,1440 1440,1560
key. So it's okay for

1832
00:45:31,345 --> 00:45:32,290
0,105 105,210 210,375 375,690 690,945
me to go release the

1833
00:45:32,290 --> 00:45:33,660
0,180 180,375 375,680
latch on a.|
|

1834
00:45:33,870 --> 00:45:35,170
0,260 260,425 425,665 665,950 950,1300
Get down here on d
现在就到D线上来。D完全满了。我不知道我下面是什么，因为我还没有去过那里。所以这一点，松开是不安全的，松开d上的闩锁，直到我下降。现在我能看出来了。

1835
00:45:35,430 --> 00:45:37,060
0,380 380,710 710,980 980,1265 1265,1630
now. D is completely full.

1836
00:45:37,320 --> 00:45:38,270
0,260 260,440 440,545 545,755 755,950
I don't know what's below

1837
00:45:38,270 --> 00:45:39,365
0,210 210,315 315,435 435,770 850,1095
me in the trig because

1838
00:45:39,365 --> 00:45:40,210
0,75 75,240 240,375 375,555 555,845
I haven't gone there yet.

1839
00:45:40,890 --> 00:45:42,500
0,260 260,410 410,605 605,910 1260,1610
So this point here, it's

1840
00:45:42,500 --> 00:45:43,670
0,180 180,405 405,585 585,860 880,1170
not safe to release, to

1841
00:45:43,670 --> 00:45:44,540
0,195 195,345 345,495 495,645 645,870
release the latch on d

1842
00:45:44,540 --> 00:45:45,695
0,180 180,255 255,375 375,650 880,1155
until I go down. And

1843
00:45:45,695 --> 00:45:46,840
0,240 240,465 465,615 615,825 825,1145
now I can see that.|
|

1844
00:45:48,270 --> 00:45:49,415
0,530 530,635 635,815 815,995 995,1145
Inserting to, I would not
插入，我不会在节点i上造成分裂，所以我可以继续，并释放b和d上的闩锁，从上到下。

1845
00:45:49,415 --> 00:45:51,275
0,180 180,390 390,725 955,1355 1525,1860
cause a split on node

1846
00:45:51,275 --> 00:45:52,205
0,245 415,660 660,735 735,810 810,930
I so I can go

1847
00:45:52,205 --> 00:45:53,030
0,120 120,240 240,390 390,510 510,825
ahead and release the latches

1848
00:45:53,030 --> 00:45:55,340
0,290 670,945 945,1095 1095,1370 1990,2310
on b and d going

1849
00:45:55,340 --> 00:45:56,380
0,210 210,500
top down.|
|

1850
00:45:57,600 --> 00:45:58,235
0,245 245,320 320,365 365,515 515,635
And I can assert my
我可以断言我的钥匙。

1851
00:45:58,235 --> 00:45:59,140
0,275
key.|
|

1852
00:46:02,060 --> 00:46:02,965
0,305 305,500 500,665 665,800 800,905
Eyes look one where there
眼睛看着有裂痕的地方。

1853
00:46:02,965 --> 00:46:04,220
0,120 120,285 285,575
is a split.|
|

1854
00:46:04,230 --> 00:46:06,290
0,400 840,1100 1100,1550 1550,1850 1850,2060
Right. For simplicity we we
正确的。为了简单起见，我们可以忽略兄弟指针，所以我做的是插入25b是安全的。我要松开门闩，一号人工智能控制中心是安全的。松开b上的闩锁。

1855
00:46:06,290 --> 00:46:08,260
0,180 180,495 495,885 885,1280 1570,1970
could ignore sibling pointers, so

1856
00:46:08,460 --> 00:46:11,170
0,470 470,740 740,1070 1070,1570 2310,2710
I'm doing insert 25 b

1857
00:46:11,190 --> 00:46:12,290
0,380 380,725 725,995 995,1025 1025,1100
is safe. I'm going to

1858
00:46:12,290 --> 00:46:13,550
0,135 135,255 255,390 390,510 1000,1260
release the latch one AI

1859
00:46:13,550 --> 00:46:14,825
0,120 120,270 270,465 850,1110 1110,1275
get down to CC is

1860
00:46:14,825 --> 00:46:16,085
0,285 285,660 660,885 885,1020 1020,1260
safe. Release the latch on

1861
00:46:16,085 --> 00:46:17,100
0,365
b.|
|

1862
00:46:17,100 --> 00:46:17,790
0,105 105,195 195,315 315,510 510,690
Then I get down to
然后我下到F，F不安全。

1863
00:46:17,790 --> 00:46:19,100
0,260 280,570 570,750 750,975 975,1310
F F is not safe.|
|

1864
00:46:20,340 --> 00:46:21,335
0,245 245,380 380,665 665,845 845,995
So I can't release the
所以我不能松开门闩。

1865
00:46:21,335 --> 00:46:22,860
0,255 255,635
latch on.|
|

1866
00:46:22,860 --> 00:46:24,585
0,285 285,650 1270,1530 1530,1635 1635,1725
On c, and now I
在c上，现在我需要进行拆分，这个拆分将导致我在节点c中插入一个新条目。

1867
00:46:24,585 --> 00:46:25,310
0,90 90,165 165,240 240,405 405,725
need to do a split

1868
00:46:25,720 --> 00:46:26,610
0,260 260,440 440,725 725,785 785,890
and that split's going to

1869
00:46:26,610 --> 00:46:27,735
0,260 370,645 645,750 750,1020 1020,1125
cause me to insert a

1870
00:46:27,735 --> 00:46:29,985
0,180 180,375 375,555 555,875 1855,2250
new entry up into node

1871
00:46:29,985 --> 00:46:30,940
0,305
c.|
|

1872
00:46:31,500 --> 00:46:32,165
0,215 215,335 335,425 425,560 560,665
So I'll go ahead and
所以我会继续，呃，添加我的新的，添加我的新节点j，我没有空间了，因为这个幻灯片，我们现在忽略兄弟指针。去吧，现在就去做。对c的更新现在可以包括这个指针。

1873
00:46:32,165 --> 00:46:34,295
0,105 105,365 745,1145 1555,1875 1875,2130
do that, eh, add my

1874
00:46:34,295 --> 00:46:36,110
0,335 925,1215 1215,1380 1380,1530 1530,1815
new, add my new node

1875
00:46:36,110 --> 00:46:36,980
0,210 210,480 480,615 615,720 720,870
j, I'm out of space

1876
00:46:36,980 --> 00:46:38,900
0,150 150,285 285,770 1030,1320 1320,1920
because this powerpoint again, we're

1877
00:46:38,900 --> 00:46:40,060
0,255 255,570 570,795 795,915 915,1160
ignoring sibling pointers for now.

1878
00:46:40,470 --> 00:46:41,885
0,290 290,500 500,820 900,1220 1220,1415
Go ahead and now do.

1879
00:46:41,885 --> 00:46:42,860
0,255 255,525 525,645 645,765 765,975
The update to the c

1880
00:46:42,860 --> 00:46:44,320
0,180 180,440 610,870 870,1005 1005,1460
could now include this pointer.|
|

1881
00:46:44,900 --> 00:46:47,105
0,290 730,990 990,1185 1185,1520 1930,2205
Uh, and then once, once
嗯，然后有一次，一旦我应用了所有这些更改，然后我就到达了自上而下的闩锁。

1882
00:46:47,105 --> 00:46:47,840
0,150 150,285 285,390 390,495 495,735
I apply all these changes,

1883
00:46:47,840 --> 00:46:48,950
0,240 240,360 360,510 510,660 660,1110
then I reach the latches

1884
00:46:48,950 --> 00:46:50,320
0,300 300,510 510,800
going top down.|
|

1885
00:46:53,150 --> 00:46:53,890
0,215 215,350 350,470 470,620 620,740
So I've already given this
我之前已经给出了这个答案，但是对于所有这些场景，我做的第一件事是什么，当我想要进行更新和插入和删除时，你必须做的第一件事是什么？

1886
00:46:53,890 --> 00:46:54,700
0,240 240,480 480,585 585,690 690,810
answer before, but what was

1887
00:46:54,700 --> 00:46:55,465
0,120 120,300 300,510 510,660 660,765
the very first thing I

1888
00:46:55,465 --> 00:46:56,635
0,120 120,270 270,495 495,735 735,1170
did for all these scenarios,

1889
00:46:56,635 --> 00:46:57,160
0,105 105,195 195,300 300,375 375,525
when I want to do

1890
00:46:57,160 --> 00:46:58,165
0,225 225,360 360,600 600,750 750,1005
updates and insert and deletees,

1891
00:46:58,165 --> 00:46:58,915
0,165 165,270 270,450 450,630 630,750
what's the very first thing

1892
00:46:58,915 --> 00:47:00,060
0,90 90,210 210,330 330,575
you have to do?|
|

1893
00:47:01,700 --> 00:47:03,100
0,400 600,860 860,1055 1055,1205 1205,1400
Get a latch on the,
锁定，对，锁定根节点，对吗？

1894
00:47:03,100 --> 00:47:04,555
0,350 910,1155 1155,1230 1230,1350 1350,1455
yeah, get a latch on

1895
00:47:04,555 --> 00:47:07,760
0,90 90,195 195,545 1945,2345
the root node, right?|
|

1896
00:47:08,500 --> 00:47:09,990
0,305 305,515 515,800 800,1220 1220,1490
And like, yeah, that's correct.
就像，是的，没错。但这现在是一个瓶颈，因为它基本上变成了几乎每个人都必须进入系统的单线程数据结构。

1897
00:47:09,990 --> 00:47:11,070
0,240 240,405 405,525 525,630 630,1080
But this is a bottleneck

1898
00:47:11,070 --> 00:47:12,530
0,180 180,360 360,480 480,740 1060,1460
now because it basically becomes

1899
00:47:12,730 --> 00:47:13,740
0,245 245,350 350,530 530,830 830,1010
almost a single threaded data

1900
00:47:13,740 --> 00:47:15,210
0,320 640,960 960,1185 1185,1350 1350,1470
structure that everybody has to

1901
00:47:15,210 --> 00:47:16,900
0,180 180,420 420,615 615,890
go into the system.|
|

1902
00:47:16,970 --> 00:47:17,770
0,260 260,395 395,560 560,695 695,800
I started going to our
我开始研究我们的数据结构。首先要做的是在写入模式下获取锁存器。

1903
00:47:17,770 --> 00:47:18,865
0,165 165,470 550,810 810,960 960,1095
data structure. The first thing

1904
00:47:18,865 --> 00:47:19,800
0,105 105,210 210,390 390,630 630,935
get to do is is

1905
00:47:20,270 --> 00:47:21,190
0,335 335,485 485,635 635,770 770,920
acquire the latch in write

1906
00:47:21,190 --> 00:47:22,060
0,290
mode.|
|

1907
00:47:22,180 --> 00:47:23,670
0,245 245,350 350,610 960,1280 1280,1490
In the route in, you're
在进入的路线中，您正在进行不兼容的读取，因此它也会阻止所有的读取器。

1908
00:47:23,670 --> 00:47:24,660
0,150 150,585 585,810 810,900 900,990
doing reads that's not gonna

1909
00:47:24,660 --> 00:47:25,575
0,60 60,480 480,600 600,780 780,915
be compatible, so it'll block

1910
00:47:25,575 --> 00:47:27,060
0,135 135,240 240,465 465,845
all the readers too.|
|

1911
00:47:28,630 --> 00:47:29,775
0,260 260,500 500,785 785,1025 1025,1145
Again, it's correct, but for
再说一次，这是正确的，但出于我的表现原因，它是。

1912
00:47:29,775 --> 00:47:32,180
0,150 150,360 360,660 660,1445
my performance reasons, it's.|
|

1913
00:47:32,285 --> 00:47:33,700
0,60 60,240 240,575
It's not ideal.|
这不是很理想。|

1914
00:47:33,830 --> 00:47:34,855
0,275 275,425 425,605 605,800 800,1025
And so the, the common
所以大家常用的技术就是，呃，我要谈的这个乐观的闭锁方案。现在，我不认为这个算法有名字。它来自这份报纸，我想它来自，来自于七十年代。上面有日期吗？

1915
00:47:34,855 --> 00:47:37,020
0,330 330,585 585,845 1075,1475 1765,2165
technique everyone uses is, eh,

1916
00:47:37,550 --> 00:47:40,090
0,400 1140,1540 1740,2210 2210,2360 2360,2540
this optimistic latching scheme I'll

1917
00:47:40,090 --> 00:47:41,830
0,75 75,180 180,440 1390,1620 1620,1740
talk about. Now, I don't

1918
00:47:41,830 --> 00:47:42,520
0,75 75,240 240,465 465,555 555,690
think the algorithm has a

1919
00:47:42,520 --> 00:47:43,600
0,285 285,600 600,690 690,825 825,1080
name. It's from this paper

1920
00:47:43,600 --> 00:47:44,730
0,380 430,690 690,795 795,915 915,1130
from, I think it's from,

1921
00:47:45,500 --> 00:47:46,690
0,260 260,425 425,875 875,1055 1055,1190
from the seventies. Is there

1922
00:47:46,690 --> 00:47:47,820
0,165 165,285 285,530
date on that?|
|

1923
00:47:48,570 --> 00:47:50,330
0,320 320,515 515,995 995,1330 1410,1760
Seventy says 77 yeah, from
70就是77是的，从这些家伙那里我是赤裸裸的，有时它被称为熊的笨蛋算法，这说起来有点麻烦，但是。

1924
00:47:50,330 --> 00:47:51,005
0,210 210,360 360,495 495,585 585,675
these guys that I be

1925
00:47:51,005 --> 00:47:52,100
0,105 105,240 240,360 360,855 855,1095
on bare and schllockneck sometimes

1926
00:47:52,100 --> 00:47:53,075
0,225 225,330 330,435 435,570 570,975
it's called the bear schlocknik

1927
00:47:53,075 --> 00:47:53,765
0,120 120,360 360,450 450,570 570,690
algorith algorithm, which is kind

1928
00:47:53,765 --> 00:47:55,360
0,245 265,780 780,885 885,1145 1195,1595
of cumbersome to say, but.|
|

1929
00:47:56,090 --> 00:47:57,330
0,350 350,515 515,665 665,875 875,1240
It's based on this observation
正是基于这种观察，你知道你的大多数线程和你的大多数工作者，他们的操作，不会导致分裂或合并到你的b+树注释中。同样，我在这里的例子中，我显示了带有两个键的节点，因为这是PowerPoint的一部分。但在实际系统中，您知道节点的大小将是数据库的页面大小。所以像8千字节，16千字节，你可以存储很多密钥，在大多数情况下，你做一堆插入，或者，这不会导致任何分裂。

1930
00:47:57,410 --> 00:47:58,915
0,260 260,440 440,710 710,1060 1140,1505
that you know that most

1931
00:47:58,915 --> 00:47:59,755
0,210 210,390 390,660 660,735 735,840
of your threads and most

1932
00:47:59,755 --> 00:48:00,955
0,75 75,180 180,455 505,870 870,1200
of your workers, their operations

1933
00:48:00,955 --> 00:48:02,575
0,300 300,635 955,1260 1260,1470 1470,1620
are, are are not going

1934
00:48:02,575 --> 00:48:03,715
0,120 120,395 505,825 825,1005 1005,1140
to cause a split or

1935
00:48:03,715 --> 00:48:05,820
0,285 285,540 540,870 870,1205 1705,2105
merge into to your your

1936
00:48:06,080 --> 00:48:07,620
0,260 260,395 395,530 530,790 1140,1540
b plus tree notes. Again,

1937
00:48:07,730 --> 00:48:08,965
0,335 335,605 605,815 815,1010 1010,1235
my example here, I'm showing

1938
00:48:08,965 --> 00:48:10,285
0,420 420,665 685,990 990,1185 1185,1320
nodedes with two keys in

1939
00:48:10,285 --> 00:48:10,780
0,90 90,180 180,330 330,405 405,495
it because that's a fit

1940
00:48:10,780 --> 00:48:12,130
0,75 75,180 180,710 910,1200 1200,1350
of the powerpoint. But in

1941
00:48:12,130 --> 00:48:13,975
0,150 150,440 520,920 1540,1770 1770,1845
a real system, you know

1942
00:48:13,975 --> 00:48:14,755
0,135 135,315 315,540 540,690 690,780
the the size of a

1943
00:48:14,755 --> 00:48:15,415
0,360 360,420 420,465 465,540 540,660
node's going to be the

1944
00:48:15,415 --> 00:48:16,195
0,180 180,375 375,495 495,570 570,780
page size to your database.

1945
00:48:16,195 --> 00:48:17,380
0,210 210,330 330,510 510,975 975,1185
So like eight kilobytes, sixteen

1946
00:48:17,380 --> 00:48:18,955
0,650 970,1230 1230,1335 1335,1455 1455,1575
kilobytes and you can store

1947
00:48:18,955 --> 00:48:19,630
0,75 75,150 150,255 255,480 480,675
a lot of keys the

1948
00:48:19,630 --> 00:48:20,380
0,150 150,300 300,390 390,570 570,750
most of the times you

1949
00:48:20,380 --> 00:48:21,085
0,75 75,105 105,180 180,270 270,705
do a bunch of inserts

1950
00:48:21,085 --> 00:48:22,375
0,305 475,735 735,915 915,1080 1080,1290
or and that's not not

1951
00:48:22,375 --> 00:48:23,460
0,150 150,315 315,495 495,720 720,1085
going cause any any splits.|
|

1952
00:48:23,960 --> 00:48:25,680
0,195 195,495 495,660 660,1100
And likewise for deletes.|
同样，对于删除也是如此。|

1953
00:48:26,110 --> 00:48:28,100
0,400 660,950 950,1220 1220,1595 1595,1990
So if you assume that
因此，如果你假设拆分合并将是罕见的，那么，即使你正在进行锁存，也不是一直向下进行右锁存，而是锁存耦合方案。

1954
00:48:28,210 --> 00:48:29,300
0,320 320,575 575,665 665,800 800,1090
splits mergers will be rare,

1955
00:48:29,920 --> 00:48:32,160
0,400 750,995 995,1115 1115,1390 1890,2240
then instead of taking right

1956
00:48:32,160 --> 00:48:33,290
0,480 480,645 645,750 750,855 855,1130
latches all the way down,

1957
00:48:33,820 --> 00:48:34,770
0,275 275,395 395,560 560,710 710,950
even if you're doing the

1958
00:48:34,770 --> 00:48:36,270
0,320 400,660 660,950 1000,1290 1290,1500
the the latch, the latch

1959
00:48:36,270 --> 00:48:37,580
0,345 345,650
coupling scheme.|
|

1960
00:48:37,865 --> 00:48:38,465
0,45 45,90 90,150 150,330 330,600
You're going to take {re-latches
你要把所有的插销都拿下来。

1961
00:48:38,465 --> 00:48:39,490
0,405 405,525 525,630 630,750 750,1025
-} all the way down.|
|

1962
00:48:40,550 --> 00:48:42,655
0,290 290,440 440,665 665,1030 1830,2105
Until you get to a
直到到达重新节点的正上方的叶节点，然后检查不会进行拆分或合并的假设是否正确。

1963
00:48:42,655 --> 00:48:43,615
0,195 195,540 540,705 705,855 855,960
leaf node right above the

1964
00:48:43,615 --> 00:48:44,890
0,165 165,605 685,945 945,1095 1095,1275
{re-node, -} and then now

1965
00:48:44,890 --> 00:48:45,955
0,240 240,495 495,690 690,855 855,1065
you check to see whether

1966
00:48:45,955 --> 00:48:47,065
0,270 270,630 630,750 750,960 960,1110
that assumption that you're not

1967
00:48:47,065 --> 00:48:47,725
0,135 135,240 240,360 360,510 510,660
going to do a split

1968
00:48:47,725 --> 00:48:49,480
0,105 105,465 465,705 705,1055
or merge is correct.|
|

1969
00:48:49,690 --> 00:48:51,735
0,380 380,620 620,725 725,970 1770,2045
And if it is, then
如果是这样，那么您可以继续，并将叶节点设置为正确的模式，然后进行更改。但如果你错了，你只需重新启动，然后采取悲观的方法，你只需将右侧的闩锁一直向下。

1970
00:48:51,735 --> 00:48:52,470
0,135 135,285 285,420 420,555 555,735
you go ahead and quite

1971
00:48:52,470 --> 00:48:53,355
0,135 135,270 270,510 510,690 690,885
the leaf node in right

1972
00:48:53,355 --> 00:48:54,855
0,305 505,905 1015,1260 1260,1380 1380,1500
mode and, and then do

1973
00:48:54,855 --> 00:48:56,100
0,120 120,395 745,975 975,1050 1050,1245
your change. But if you're

1974
00:48:56,100 --> 00:48:57,960
0,260 730,975 975,1110 1110,1620 1620,1860
wrong, you just restart and

1975
00:48:57,960 --> 00:48:59,625
0,195 195,435 435,740 880,1470 1470,1665
then do the pessimistic approach,

1976
00:48:59,625 --> 00:49:00,525
0,150 150,255 255,420 420,615 615,900
you just taking right latches

1977
00:49:00,525 --> 00:49:01,660
0,105 105,210 210,315 315,575
all the way down.|
|

1978
00:49:02,480 --> 00:49:03,325
0,320 320,515 515,650 650,740 740,845
So this would be a
因此，这将是一个共同的主题，你看，不仅仅是在数据库和一系列不同的系统中。这是一种乐观的方案，你假设不会有任何问题，不会有任何问题，你会以一种快速的方式在你的系统中做出一些改变或做一些事情。

1979
00:49:03,325 --> 00:49:04,360
0,270 270,555 555,705 705,855 855,1035
common theme, you see, not

1980
00:49:04,360 --> 00:49:05,215
0,135 135,240 240,675 675,765 765,855
just in databases and a

1981
00:49:05,215 --> 00:49:06,535
0,120 120,240 240,485 835,1155 1155,1320
bunch of different systems in

1982
00:49:06,535 --> 00:49:07,915
0,245 775,1020 1020,1110 1110,1185 1185,1380
general. This is sort of

1983
00:49:07,915 --> 00:49:09,865
0,365 985,1290 1290,1455 1455,1665 1665,1950
optimistic scheme where you assume

1984
00:49:09,865 --> 00:49:10,525
0,240 240,450 450,540 540,630 630,660
that there're not going to

1985
00:49:10,525 --> 00:49:11,320
0,75 75,225 225,465 465,660 660,795
be any issues, not any

1986
00:49:11,320 --> 00:49:12,985
0,290 730,1005 1005,1170 1170,1395 1395,1665
problems, and you do the

1987
00:49:12,985 --> 00:49:13,980
0,180 180,240 240,345 345,615 615,995
sort of the fast way

1988
00:49:14,210 --> 00:49:16,390
0,380 380,755 755,1150 1650,1970 1970,2180
of, of, of making some

1989
00:49:16,390 --> 00:49:17,215
0,180 180,330 330,480 480,675 675,825
change or doing something in

1990
00:49:17,215 --> 00:49:18,260
0,120 120,395
your system.|
|

1991
00:49:18,260 --> 00:49:18,860
0,165 165,225 225,315 315,450 450,600
And then if you're wrong,
然后，如果你错了，你就把它倒回去，然后处理它。

1992
00:49:18,860 --> 00:49:19,630
0,165 165,270 270,405 405,525 525,770
you just roll it back

1993
00:49:20,280 --> 00:49:21,160
0,275 275,425 425,545 545,635 635,880
and take care of it.|
|

1994
00:49:22,760 --> 00:49:24,865
0,400 960,1475 1475,1670 1670,1820 1820,2105
EM, Intel actually had this.
嗯，情报部门真的有这个。它被称为TSX。我想，我们实际上在，在CPS本身就有这个。

1995
00:49:24,865 --> 00:49:25,960
0,240 240,345 345,480 480,885 885,1095
It was called tsx. We

1996
00:49:25,960 --> 00:49:26,760
0,135 135,255 255,390 390,525 525,800
actually had this in the,

1997
00:49:27,500 --> 00:49:29,080
0,275 275,550 600,1040 1040,1300 1320,1580
in the CPS itself, I

1998
00:49:29,080 --> 00:49:29,960
0,260
think.|
|

1999
00:49:29,960 --> 00:49:30,530
0,135 135,180 180,285 285,435 435,570
It was a bug and
这是一个窃听器，我想他们把它关掉了。它可能会回到1，但就像这种乐观记忆的东西，你可以有一个临界区，你会假设你不会在某个临界区有任何冲突，然后当你去应用更改时，然后你只需检查是否那个，那个。

2000
00:49:30,530 --> 00:49:31,085
0,105 105,195 195,315 315,450 450,555
I think they turned it

2001
00:49:31,085 --> 00:49:31,760
0,180 180,360 360,450 450,540 540,675
off. It might have got

2002
00:49:31,760 --> 00:49:32,710
0,150 150,270 270,360 360,570 570,950
turned back to one, but

2003
00:49:33,090 --> 00:49:34,175
0,230 230,350 350,530 530,770 770,1085
it was like this optimistic

2004
00:49:34,175 --> 00:49:35,270
0,315 315,540 540,765 765,975 975,1095
memory stuff where you could

2005
00:49:35,270 --> 00:49:37,330
0,260 790,1065 1065,1290 1290,1640 1660,2060
have a critical section where

2006
00:49:37,920 --> 00:49:40,595
0,400 690,1090 2100,2390 2390,2585 2585,2675
you would assume you're not

2007
00:49:40,595 --> 00:49:41,450
0,90 90,135 135,195 195,300 300,855
going to have any conflicts

2008
00:49:41,450 --> 00:49:43,130
0,195 195,345 345,555 555,890 1390,1680
in some critical section and

2009
00:49:43,130 --> 00:49:43,940
0,210 210,420 420,570 570,690 690,810
then when you went to

2010
00:49:43,940 --> 00:49:45,605
0,260 610,915 915,1110 1110,1395 1395,1665
go apply the change, then

2011
00:49:45,605 --> 00:49:46,475
0,135 135,315 315,570 570,765 765,870
you just just check to

2012
00:49:46,475 --> 00:49:47,650
0,105 105,255 255,540 540,855 855,1175
see whether that, that that.|
|

2013
00:49:48,720 --> 00:49:50,055
0,195 195,465 465,615 615,920 1090,1335
That assumption was correct and
这一假设是正确的，如果不正确，它会自动让你倒退。但同样，当我们讨论转换为事务时，我们会看到这一点。这是一种非常常见的技术。你做快速的事情，因为大多数时候不会有任何问题，如果你错了，那么你必须回滚并再次尝试。

2014
00:49:50,055 --> 00:49:50,850
0,150 150,390 390,555 555,660 660,795
if not, it would roll

2015
00:49:50,850 --> 00:49:53,700
0,105 105,330 330,710 2050,2450 2470,2850
you back automatically. But again,

2016
00:49:53,700 --> 00:49:54,630
0,315 315,420 420,615 615,810 810,930
we'll see this when we

2017
00:49:54,630 --> 00:49:55,605
0,120 120,240 240,420 420,720 720,975
do talk about convert for

2018
00:49:55,605 --> 00:49:56,895
0,275 715,960 960,1035 1035,1125 1125,1290
transactions. This is a very

2019
00:49:56,895 --> 00:49:58,095
0,225 225,545 655,930 930,1065 1065,1200
common technique. You do the

2020
00:49:58,095 --> 00:49:59,175
0,210 210,450 450,600 600,825 825,1080
fast thing because that most

2021
00:49:59,175 --> 00:49:59,940
0,105 105,180 180,390 390,600 600,765
of the times there won't

2022
00:49:59,940 --> 00:50:01,095
0,60 60,165 165,440 820,1065 1065,1155
be any issues and if

2023
00:50:01,095 --> 00:50:02,040
0,150 150,345 345,540 540,735 735,945
you're wrong then you have

2024
00:50:02,040 --> 00:50:03,600
0,105 105,225 225,390 390,680 1270,1560
to roll back and try

2025
00:50:03,600 --> 00:50:04,420
0,290
again.|
|

2026
00:50:05,430 --> 00:50:07,040
0,350 350,700 1020,1280 1280,1415 1415,1610
Right. So with this better
正确的。因此，有了这个更好的锁存方案，用于执行查找和查找，这与以前用于插入和删除的锁存方案是相同的。再一次，我们拿着我们，我们基本上做搜索，拿着右边的门闩。抱歉，一直向下读取锁存，直到我们位于叶节点之上的一个级别。

2027
00:50:07,040 --> 00:50:08,300
0,375 375,645 645,915 915,1095 1095,1260
latching scheme for, for doing

2028
00:50:08,300 --> 00:50:10,010
0,440 490,780 780,1070 1270,1620 1620,1710
lookup and finds, that's the

2029
00:50:10,010 --> 00:50:11,495
0,120 120,240 240,500 940,1185 1185,1485
same as before for inserts

2030
00:50:11,495 --> 00:50:13,210
0,105 105,635 835,1170 1170,1410 1410,1715
and deletes. Again, we take

2031
00:50:14,400 --> 00:50:15,965
0,380 380,760 780,1145 1145,1385 1385,1565
we, we basically do the

2032
00:50:15,965 --> 00:50:17,465
0,270 270,585 585,825 825,1260 1260,1500
search, taking right latches. Sorry,

2033
00:50:17,465 --> 00:50:18,410
0,210 210,585 585,720 720,825 825,945
read latches all the way

2034
00:50:18,410 --> 00:50:20,270
0,290 850,1110 1110,1320 1320,1530 1530,1860
down until we're one level

2035
00:50:20,270 --> 00:50:22,090
0,380 400,800 850,1110 1110,1305 1305,1820
above the the leaf node.|
|

2036
00:50:22,550 --> 00:50:23,410
0,260 260,380 380,500 500,680 680,860
I mean, we know where
我的意思是，我们知道我们在数据结构中的位置，因为，你知道，我们可以跟踪我们在页面中向下的级别，或者一个简单的计数器也可以。

2037
00:50:23,410 --> 00:50:24,310
0,255 255,465 465,600 600,720 720,900
we're in the, in the,

2038
00:50:24,310 --> 00:50:25,450
0,210 210,450 450,675 675,870 870,1140
in the, the data structure

2039
00:50:25,450 --> 00:50:26,770
0,350 610,855 855,1050 1050,1230 1230,1320
because, you know, we can

2040
00:50:26,770 --> 00:50:28,225
0,150 150,315 315,590 1090,1335 1335,1455
keep track of how many

2041
00:50:28,225 --> 00:50:31,075
0,195 195,515 625,870 870,1115 2545,2850
levels down we are either

2042
00:50:31,075 --> 00:50:31,900
0,135 135,240 240,450 450,675 675,825
in the page or a

2043
00:50:31,900 --> 00:50:33,000
0,180 180,420 420,600 600,780 780,1100
simple counter would work too.|
|

2044
00:50:34,650 --> 00:50:36,580
0,260 260,440 440,790 1110,1510 1530,1930
You go acquire the the
您可以获取叶节点正上方的级别。你在正确的模式下获取叶节点，然后你检查它在哪里是安全的，如果它是安全的，然后你释放你以前拿到的所有Relatch。

2045
00:50:36,810 --> 00:50:37,790
0,320 320,530 530,710 710,845 845,980
level right above the leaf

2046
00:50:37,790 --> 00:50:38,915
0,420 420,675 675,870 870,990 990,1125
node. You acquire the leaf

2047
00:50:38,915 --> 00:50:40,330
0,270 270,515 595,915 915,1125 1125,1415
node in in right mode,

2048
00:50:40,860 --> 00:50:41,645
0,290 290,440 440,575 575,695 695,785
then you check to see

2049
00:50:41,645 --> 00:50:42,875
0,90 90,300 300,575 895,1140 1140,1230
where it's safe, if it

2050
00:50:42,875 --> 00:50:44,195
0,150 150,450 450,705 705,965 1045,1320
is safe, then you release

2051
00:50:44,195 --> 00:50:45,245
0,150 150,285 285,795 795,930 930,1050
all your relatches that you

2052
00:50:45,245 --> 00:50:46,680
0,150 150,285 285,545
took from before.|
|

2053
00:50:47,260 --> 00:50:48,210
0,275 275,425 425,620 620,800 800,950
Apply your change and you're
应用您的更改，您就完成了。如果你错了，那么你只要松开你所有的闩锁，然后回去把右边的闩锁一直往下拿。

2054
00:50:48,210 --> 00:50:49,875
0,230 430,720 720,960 960,1220 1360,1665
done. If you're wrong, then

2055
00:50:49,875 --> 00:50:50,940
0,165 165,425 535,810 810,945 945,1065
you just release all your

2056
00:50:50,940 --> 00:50:52,350
0,330 330,480 480,615 615,890 1150,1410
latches and go back and

2057
00:50:52,350 --> 00:50:53,085
0,135 135,285 285,555 555,645 645,735
take right latches all the

2058
00:50:53,085 --> 00:50:54,000
0,90 90,335
way down.|
|

2059
00:50:54,100 --> 00:50:54,945
0,275 275,440 440,620 620,740 740,845
You could take, you know,
你可以再乐观一次，因为你假设下次你回来的时候，一切都会安全的。这取决于实施情况。

2060
00:50:54,945 --> 00:50:56,150
0,135 135,300 300,585 585,885 885,1205
do the optimistic se again

2061
00:50:56,230 --> 00:50:57,285
0,365 365,620 620,785 785,935 935,1055
because you assume next time

2062
00:50:57,285 --> 00:50:58,320
0,90 90,180 180,330 330,635 775,1035
you come back around, things

2063
00:50:58,320 --> 00:50:59,565
0,105 105,225 225,500 790,1080 1080,1245
will be safe. It depends

2064
00:50:59,565 --> 00:51:00,920
0,120 120,225 225,485
on the implementation.|
|

2065
00:51:00,920 --> 00:51:01,715
0,180 180,315 315,435 435,600 600,795
And so this works really
因此，这在争用较少的环境中工作得非常好，因为您显然认为不会有任何冲突，而且大多数情况下您是正确的。因此，事情运行得更快。

2066
00:51:01,715 --> 00:51:03,080
0,225 225,420 420,570 570,900 900,1365
well in low contention environments

2067
00:51:03,080 --> 00:51:05,350
0,320 1090,1410 1410,1725 1725,1995 1995,2270
because you obviously assume there

2068
00:51:05,400 --> 00:51:06,815
0,335 335,380 380,500 500,1120 1140,1415
won't be any conflicts and

2069
00:51:06,815 --> 00:51:07,550
0,150 150,255 255,345 345,495 495,735
most of the time you're

2070
00:51:07,550 --> 00:51:08,825
0,260 280,555 555,795 795,1065 1065,1275
correct. And so things run

2071
00:51:08,825 --> 00:51:09,880
0,305
faster.|
|

2072
00:51:11,570 --> 00:51:12,415
0,215 215,350 350,425 425,605 605,845
So let's go back from
所以让我们回到前面的例子。让我们再次删除38号键。不是以右锁存模式将根节点放入，而是将读模式保持向下。所以我降到了d，现在d认识到它比叶节点高一级。所以我想从节点h中删除密钥38，所以我将h带入写入模式。检查一下，看看它是否安全。是的，我可以去删掉它。

2073
00:51:12,415 --> 00:51:14,095
0,195 195,485 595,1020 1020,1355 1405,1680
example before. Let's delete key

2074
00:51:14,095 --> 00:51:16,255
0,485 1165,1565 1645,1890 1890,1995 1995,2160
38 again. Instead of taking

2075
00:51:16,255 --> 00:51:18,240
0,305 415,690 690,1005 1005,1295 1585,1985
the root node in, in,

2076
00:51:18,860 --> 00:51:19,980
0,245 245,350 350,530 530,800 800,1120
in a right latch mode,

2077
00:51:20,600 --> 00:51:22,030
0,275 275,410 410,575 575,1060 1140,1430
taking a read modede keep

2078
00:51:22,030 --> 00:51:23,380
0,225 225,560 850,1095 1095,1200 1200,1350
going down. So I get

2079
00:51:23,380 --> 00:51:25,000
0,165 165,330 330,620 1060,1380 1380,1620
down to d, now d

2080
00:51:25,000 --> 00:51:26,370
0,495 495,720 720,900 900,1065 1065,1370
recognizes that it's one level

2081
00:51:26,510 --> 00:51:28,380
0,395 395,650 650,830 830,1330 1470,1870
above the leaf node. So

2082
00:51:28,580 --> 00:51:30,780
0,275 275,395 395,640 930,1330 1800,2200
I want to delete key

2083
00:51:31,010 --> 00:51:32,520
0,530 530,815 815,1025 1025,1250 1250,1510
38 from from node h,

2084
00:51:32,750 --> 00:51:33,625
0,230 230,320 320,455 455,620 620,875
so I take the h

2085
00:51:33,625 --> 00:51:35,155
0,300 300,540 540,845 1105,1380 1380,1530
into write mode. Check to

2086
00:51:35,155 --> 00:51:36,570
0,120 120,345 345,605 895,1155 1155,1415
see it's safe. It is,

2087
00:51:36,860 --> 00:51:37,980
0,260 260,395 395,620 620,845 845,1120
I can go delete it.|
|

2088
00:51:38,630 --> 00:51:39,625
0,245 245,365 365,605 605,890 890,995
And I know I'm not
我知道我不会做任何事。我不会做任何合并，对吗？

2089
00:51:39,625 --> 00:51:41,290
0,105 105,180 180,360 360,695 1375,1665
going to do any. I'm

2090
00:51:41,290 --> 00:51:41,650
0,90 90,165 165,195 195,240 240,360
not going to do any

2091
00:51:41,650 --> 00:51:43,540
0,440 790,1190
merges, right?|
|

2092
00:51:43,880 --> 00:51:44,910
0,260 260,410 410,590 590,755 755,1030
So again, best case scenario
所以，再一次，最好的情况是，我遍历数据结构，几乎就像我在进行读取一样。

2093
00:51:45,110 --> 00:51:46,450
0,365 365,650 650,1070 1070,1175 1175,1340
I I traversed the data

2094
00:51:46,450 --> 00:51:48,025
0,320 430,765 765,1100 1150,1425 1425,1575
structure almost as if I

2095
00:51:48,025 --> 00:51:50,440
0,150 150,425 1015,1290 1290,1565
was doing a read.|
|

2096
00:51:50,440 --> 00:51:51,130
0,180 180,360 360,465 465,570 570,690
And therefore, I can have
因此，我可以有最大的并行度，但只有在底部，我才会检查这个假设是否正确。

2097
00:51:51,130 --> 00:51:52,770
0,260 460,780 780,960 960,1080 1080,1640
a maximum amount of parallelism,

2098
00:51:52,970 --> 00:51:54,235
0,400 540,845 845,980 980,1070 1070,1265
but only at the bottom

2099
00:51:54,235 --> 00:51:54,910
0,165 165,285 285,435 435,555 555,675
do I check to see

2100
00:51:54,910 --> 00:51:56,340
0,260 370,705 705,1005 1005,1140 1140,1430
whether that assumption was correct.|
|

2101
00:51:58,790 --> 00:51:59,640
0,230 230,290 290,350 350,440 440,850
See how to do insert,
看看如何做插入，再次插入25，在读取模式下扎根。在读取模式下取b。当我松开闩锁时，闩锁连接是否向下。现在我在这里进入，如果是，因为我们要做插入，没有更多的空间，所以不安全。因此，我们将不得不重新启动整个操作，然后在下降的过程中采取正确的闩锁。

2102
00:51:59,810 --> 00:52:01,780
0,440 440,940 1290,1610 1610,1820 1820,1970
insert 25 again, take the

2103
00:52:01,780 --> 00:52:03,210
0,180 180,500 670,945 945,1125 1125,1430
root in in read mode.

2104
00:52:03,350 --> 00:52:04,380
0,290 290,440 440,575 575,740 740,1030
Take b in read mode.

2105
00:52:04,610 --> 00:52:06,055
0,260 260,380 380,670 900,1310 1310,1445
Do the latch coupling as

2106
00:52:06,055 --> 00:52:07,590
0,195 195,390 390,815 985,1260 1260,1535
I release latches go down.

2107
00:52:07,970 --> 00:52:08,815
0,245 245,335 335,440 440,620 620,845
Now I get down here

2108
00:52:08,815 --> 00:52:10,660
0,305 535,935 1315,1575 1575,1710 1710,1845
into f in case of

2109
00:52:10,660 --> 00:52:12,115
0,260 790,1095 1095,1290 1290,1365 1365,1455
f because we're trying to

2110
00:52:12,115 --> 00:52:13,495
0,90 90,165 165,605 865,1155 1155,1380
do an insert f doesn't

2111
00:52:13,495 --> 00:52:14,155
0,75 75,150 150,270 270,495 495,660
have any more room so

2112
00:52:14,155 --> 00:52:15,775
0,150 150,345 345,695 1135,1440 1440,1620
it's not safe. So we're

2113
00:52:15,775 --> 00:52:16,720
0,45 45,105 105,195 195,690 690,945
going have to restart the

2114
00:52:16,720 --> 00:52:18,280
0,210 210,560 940,1230 1230,1395 1395,1560
whole operation and then just

2115
00:52:18,280 --> 00:52:19,285
0,195 195,390 390,765 765,915 915,1005
take right latches on the

2116
00:52:19,285 --> 00:52:20,140
0,105 105,365
way down.|
|

2117
00:52:24,050 --> 00:52:25,640
0,290 290,470 470,760
Neat trick, right?|
巧妙的把戏，对吧？|

2118
00:52:27,720 --> 00:52:28,660
0,400
Okay.|
好吧。|

2119
00:52:30,810 --> 00:52:31,920
0,400
So.|
所以。|

2120
00:52:31,990 --> 00:52:33,750
0,275 275,455 455,710 710,1060 1410,1760
In all these examples I've
在我到目前为止展示的所有这些例子中。

2121
00:52:33,750 --> 00:52:34,960
0,105 105,255 255,530
shown so far.|
|

2122
00:52:34,960 --> 00:52:36,040
0,255 255,390 390,630 630,915 915,1080
We were only going in
我们只朝一个方向走。

2123
00:52:36,040 --> 00:52:37,220
0,180 180,500
one direction.|
|

2124
00:52:38,100 --> 00:52:39,080
0,230 230,305 305,485 485,755 755,980
We were only going top
我们只是从上到下。

2125
00:52:39,080 --> 00:52:40,220
0,120 120,180 180,410
to the bottom.|
|

2126
00:52:40,220 --> 00:52:41,500
0,225 225,330 330,590
As I said.|
就像我说的。|

2127
00:52:41,500 --> 00:52:42,670
0,135 135,300 300,420 420,930 930,1170
There weren't any deadlocks because
没有出现任何僵局，因为没有人，你知道，每个人都会登上巅峰。他们总是从同一个点开始，然后他们就会走下坡路。没有，你知道，就像我上一节课说的，没有指向你父母的指示。

2128
00:52:42,670 --> 00:52:44,035
0,350 430,660 660,825 825,1125 1125,1365
nobody, you know, everyone's going

2129
00:52:44,035 --> 00:52:45,190
0,240 240,330 330,575 715,1020 1020,1155
to the top. They're always

2130
00:52:45,190 --> 00:52:46,000
0,180 180,330 330,480 480,675 675,810
starting the same point and

2131
00:52:46,000 --> 00:52:47,550
0,120 120,240 240,530 940,1290 1290,1550
they're going down. There's no,

2132
00:52:47,630 --> 00:52:48,295
0,245 245,320 320,410 410,530 530,665
you know, as I said

2133
00:52:48,295 --> 00:52:49,540
0,150 150,330 330,585 585,810 810,1245
last class, there's no pointers

2134
00:52:49,540 --> 00:52:50,760
0,135 135,270 270,560
to your parent.|
|

2135
00:52:50,760 --> 00:52:51,950
0,255 255,525 525,660 660,870 870,1190
You can't go back up
你不能回去，因为那里可能会发生冲突。

2136
00:52:52,240 --> 00:52:53,370
0,305 305,590 590,920 920,1010 1010,1130
and because that's where you

2137
00:52:53,370 --> 00:52:54,760
0,105 105,240 240,830
could have conflicts.|
|

2138
00:52:55,270 --> 00:52:56,325
0,260 260,520 570,830 830,995 995,1055
But again, because we're A
但再说一次，因为我们是A，B+树，我们可以有兄弟指针。

2139
00:52:56,325 --> 00:52:58,230
0,135 135,345 345,665 1495,1770 1770,1905
B plus tree, we could

2140
00:52:58,230 --> 00:52:59,880
0,195 195,525 525,980
have sibling pointers.|
|

2141
00:53:00,090 --> 00:53:00,965
0,275 275,485 485,665 665,755 755,875
And now we have a
现在我们有一个挑战，我们可以让一个线程走一条路，另一个线程走另一条路，它们都持有用于另一个人想要的东西的闩锁，另一个线程想要的东西。

2142
00:53:00,965 --> 00:53:03,280
0,255 255,635 1405,1725 1725,1980 1980,2315
challenge where we could have

2143
00:53:03,780 --> 00:53:05,240
0,380 380,725 725,1010 1010,1235 1235,1460
one thread going one way

2144
00:53:05,240 --> 00:53:06,125
0,180 180,330 330,495 495,675 675,885
and another thread going another

2145
00:53:06,125 --> 00:53:07,385
0,305 415,690 690,840 840,1035 1035,1260
way, and they both hold

2146
00:53:07,385 --> 00:53:08,945
0,465 465,785 1045,1320 1320,1425 1425,1560
latches for what the other

2147
00:53:08,945 --> 00:53:09,845
0,225 225,495 495,690 690,765 765,900
person wants, what the other

2148
00:53:09,845 --> 00:53:11,000
0,195 195,485
thread wants.|
|

2149
00:53:11,210 --> 00:53:12,480
0,400
Right.|
正确的。|

2150
00:53:12,730 --> 00:53:13,785
0,245 245,490 630,935 935,980 980,1055
So now we've got to
所以现在我们要处理那个场景，原始的b+g论文。这不是一个问题。

2151
00:53:13,785 --> 00:53:15,870
0,90 90,180 180,315 315,605 1825,2085
deal with that scenario, the

2152
00:53:15,870 --> 00:53:16,680
0,180 180,360 360,495 495,630 630,810
original b plus g paper.

2153
00:53:16,680 --> 00:53:18,260
0,180 180,435 435,525 525,770
This wasn't an issue.|
|

2154
00:53:18,600 --> 00:53:19,565
0,245 245,350 350,500 500,695 695,965
But the b link stuff
但是来自CMU的b链接的东西，这就是他们添加兄弟指针的地方，这就是你可能会有死锁的地方。

2155
00:53:19,565 --> 00:53:20,900
0,255 255,420 420,585 585,1020 1020,1335
that came from cmu, that's

2156
00:53:20,900 --> 00:53:21,755
0,75 75,165 165,330 330,600 600,855
where they added sibling pointers,

2157
00:53:21,755 --> 00:53:22,235
0,90 90,255 255,315 315,390 390,480
and that's where you can

2158
00:53:22,235 --> 00:53:23,480
0,120 120,695
have deadlocks.|
|

2159
00:53:24,710 --> 00:53:25,145
0,150 150,240 240,315 315,360 360,435
So let's look at a
让我们来看一个简单的例子。

2160
00:53:25,145 --> 00:53:26,500
0,180 180,405 405,695
simple example here.|
|

2161
00:53:26,970 --> 00:53:28,480
0,230 230,335 335,610 930,1220 1220,1510
So I want thread one,
所以我想要线程1，他们想要找到所有小于4的键，所以我将在读模式中获取根，然后在读模式中获取c，然后假设。

2162
00:53:28,710 --> 00:53:29,495
0,230 230,305 305,380 380,500 500,785
they want to find all

2163
00:53:29,495 --> 00:53:31,580
0,315 315,525 525,690 690,965 1855,2085
keys less than four, so

2164
00:53:31,580 --> 00:53:32,000
0,135 135,165 165,210 210,300 300,420
I'm going to get the

2165
00:53:32,000 --> 00:53:34,520
0,225 225,590 1210,1515 1515,1820 2260,2520
root in read mode and

2166
00:53:34,520 --> 00:53:35,615
0,165 165,345 345,615 615,915 915,1095
then get the c in

2167
00:53:35,615 --> 00:53:37,235
0,180 180,485 925,1215 1215,1380 1500,1620
read mode and then let's

2168
00:53:37,235 --> 00:53:39,060
0,275
say.|
|

2169
00:53:39,600 --> 00:53:41,045
0,400 450,815 815,1040 1040,1190 1190,1445
And then once the scan
然后一旦扫描完毕。因此，它将遵循兄弟指针。因此，就像以前一样，我持有我所在的任何节点。现在我拿着它，在当前的闩锁模式下，我有它。

2170
00:53:41,045 --> 00:53:42,110
0,285 285,605 655,885 885,1005 1005,1065
scan across. So it's going

2171
00:53:42,110 --> 00:53:43,330
0,105 105,345 345,570 570,810 810,1220
to follow the sibling pointers.

2172
00:53:43,530 --> 00:53:45,020
0,260 260,395 395,530 530,790 1200,1490
So just like before, I

2173
00:53:45,020 --> 00:53:46,190
0,290 370,690 690,915 915,1050 1050,1170
hold whatever node I'm at.

2174
00:53:46,190 --> 00:53:47,740
0,290 460,735 735,930 930,1200 1200,1550
Now I hold that in

2175
00:53:47,850 --> 00:53:48,950
0,245 245,410 410,710 710,950 950,1100
the current latch mode, I

2176
00:53:48,950 --> 00:53:49,940
0,165 165,470
have it.|
|

2177
00:53:50,130 --> 00:53:52,190
0,400 1020,1325 1325,1595 1595,1850 1850,2060
Uh, and then I then
嗯，然后我试着把门闩拿到我想去的地方。在这种情况下，c从c移动到b，所以我握住c上的闩锁，拿到b上的闩锁，移到这里，然后我可以释放c上的闩锁，然后做我需要做的任何事情。

2178
00:53:52,190 --> 00:53:53,075
0,180 180,300 300,510 510,690 690,885
try to acquire the latch

2179
00:53:53,075 --> 00:53:53,645
0,150 150,255 255,375 375,480 480,570
to where I want to

2180
00:53:53,645 --> 00:53:54,845
0,150 150,455 775,1005 1005,1080 1080,1200
go to. So in this

2181
00:53:54,845 --> 00:53:56,500
0,180 180,465 465,765 765,1085 1255,1655
case here again to c

2182
00:53:56,610 --> 00:53:57,730
0,260 260,425 425,650 650,845 845,1120
go from c to b,

2183
00:53:58,080 --> 00:53:58,895
0,230 230,335 335,515 515,665 665,815
so I hold the latch

2184
00:53:58,895 --> 00:54:00,170
0,180 180,485 715,975 975,1110 1110,1275
on c, get the latch

2185
00:54:00,170 --> 00:54:01,655
0,150 150,440 790,1065 1065,1245 1245,1485
on b, move over here

2186
00:54:01,655 --> 00:54:02,225
0,180 180,255 255,330 330,435 435,570
and then I can release

2187
00:54:02,225 --> 00:54:03,065
0,120 120,270 270,450 450,675 675,840
the latch on c and

2188
00:54:03,065 --> 00:54:03,860
0,135 135,330 330,495 495,585 585,795
then do whatever it is

2189
00:54:03,860 --> 00:54:04,660
0,225 225,330 330,450 450,555 555,800
that I need to do.|
|

2190
00:54:05,930 --> 00:54:07,040
0,400
Right.|
正确的。|

2191
00:54:07,040 --> 00:54:07,925
0,180 180,285 285,585 585,690 690,885
So the protocol is basically
所以协议基本上是一样的，尽管我们现在是水平移动而不是垂直移动。

2192
00:54:07,925 --> 00:54:08,780
0,180 180,315 315,510 510,705 705,855
the same thing, even though

2193
00:54:08,780 --> 00:54:12,020
0,150 150,380 550,950 2350,3075 3075,3240
we're now moving horizontally instead

2194
00:54:12,020 --> 00:54:13,220
0,90 90,560
of vertically.|
|

2195
00:54:13,630 --> 00:54:14,985
0,400 570,830 830,1025 1025,1220 1220,1355
Yes, I think this might
是的，我想这可能和之前的一样，但是。

2196
00:54:14,985 --> 00:54:15,630
0,120 120,225 225,360 360,510 510,645
be the same thing from

2197
00:54:15,630 --> 00:54:16,660
0,240 240,620
earlier, but.|
|

2198
00:54:16,660 --> 00:54:17,800
0,300 300,525 525,810 810,1035 1035,1140
Reading this one, then a
读了这封信，一个人下来，写下另一封信。

2199
00:54:17,800 --> 00:54:18,640
0,150 150,330 330,510 510,705 705,840
guy comes down, writes the

2200
00:54:18,640 --> 00:54:19,580
0,135 135,440
other one.|
|

2201
00:54:20,160 --> 00:54:21,320
0,335 335,530 530,790
Across the read.|
在阅读的另一边。|

2202
00:54:21,610 --> 00:54:22,840
0,275 275,455 455,845 845,1120
The same scheduling problem.|
同样的调度问题。|

2203
00:54:22,880 --> 00:54:24,685
0,400 1110,1625 1625,1685 1685,1760 1760,1805
Uh, we'll get that in
呃，我们马上就能拿到，好的。同样的日程安排，是的。

2204
00:54:24,685 --> 00:54:25,720
0,60 60,195 195,485 535,810 810,1035
a second, yes. Same schedule,

2205
00:54:25,720 --> 00:54:26,740
0,350
yes.|
|

2206
00:54:27,260 --> 00:54:29,410
0,400 990,1390 1410,1670 1670,1970 1970,2150
So again, the remos are
所以，遥控器是如此的通勤，所以我可以有两个线程，我将在同一时间到达。我第一个，所以线往下，往下到c，第二个，第三个往下到b，他们想要彼此交叉。在这种情况下，他们拿着的两个闩锁是可交换的。

2207
00:54:29,410 --> 00:54:30,415
0,150 150,500 550,810 810,915 915,1005
so commut, so I can

2208
00:54:30,415 --> 00:54:31,240
0,135 135,345 345,630 630,765 765,825
have two threads I'm going

2209
00:54:31,240 --> 00:54:31,765
0,75 75,180 180,285 285,375 375,525
to reach at the same

2210
00:54:31,765 --> 00:54:34,000
0,305 745,1145 1735,2025 2025,2145 2145,2235
time. I first, so thread

2211
00:54:34,000 --> 00:54:35,515
0,150 150,440 940,1215 1215,1365 1365,1515
goes down, goes down to

2212
00:54:35,515 --> 00:54:36,370
0,225 225,465 465,615 615,735 735,855
c, second, third goes down

2213
00:54:36,370 --> 00:54:37,405
0,120 120,380 550,810 810,930 930,1035
to b and they want

2214
00:54:37,405 --> 00:54:38,220
0,75 75,210 210,405 405,555 555,815
to go across each other.

2215
00:54:38,450 --> 00:54:39,430
0,275 275,410 410,560 560,755 755,980
And in this case here,

2216
00:54:39,430 --> 00:54:41,470
0,225 225,530 1210,1485 1485,1845 1845,2040
the the two latches they're

2217
00:54:41,470 --> 00:54:42,960
0,180 180,405 405,920
holding are commutative.|
|

2218
00:54:43,180 --> 00:54:44,835
0,350 350,700 1050,1325 1325,1460 1460,1655
So therefore, they can both
因此，他们都可以做任何他们需要做的事情，对吗？

2219
00:54:44,835 --> 00:54:46,110
0,240 240,545 805,1065 1065,1185 1185,1275
do whatever they need to

2220
00:54:46,110 --> 00:54:47,560
0,230 340,740
do, right?|
|

2221
00:54:49,335 --> 00:54:50,280
0,90 90,335
That's fine.|
那很好。|

2222
00:54:51,710 --> 00:54:52,765
0,245 245,380 380,515 515,815 815,1055
So let's now do when
所以我们现在开始吧，当我们有一个。

2223
00:54:52,765 --> 00:54:54,500
0,105 105,330 330,695
we have a.|
|

2224
00:54:55,170 --> 00:54:56,120
0,230 230,455 455,695 695,830 830,950
One of them wants to
其中一个想要写，想要读。

2225
00:54:56,120 --> 00:54:56,720
0,60 60,150 150,315 315,495 495,600
do a write, wants to

2226
00:54:56,720 --> 00:54:57,820
0,75 75,180 180,440
do a read.|
|

2227
00:54:57,860 --> 00:54:58,960
0,350 350,590 590,800 800,965 965,1100
So t one was it,
所以t是1，删除键4，t想要找到所有大于1的键。

2228
00:54:58,960 --> 00:55:00,280
0,225 225,420 420,570 570,860 1030,1320
delete the key four and

2229
00:55:00,280 --> 00:55:01,135
0,225 225,420 420,525 525,660 660,855
t wants to find all

2230
00:55:01,135 --> 00:55:02,740
0,225 225,435 435,600 600,875
keys greater than one.|
|

2231
00:55:02,870 --> 00:55:03,640
0,245 245,365 365,530 530,680 680,770
So they both start at
因此，它们同时启动，并假定我们正在进行乐观锁耦合。我刚才谈到了他们开始路线的地段耦合，都是在新兴市场。

2232
00:55:03,640 --> 00:55:04,840
0,90 90,255 255,560 790,1065 1065,1200
the same time and assume

2233
00:55:04,840 --> 00:55:06,190
0,135 135,255 255,560 730,1095 1095,1350
we're doing the optimistic lock

2234
00:55:06,190 --> 00:55:07,440
0,435 435,645 645,750 750,930 930,1250
coupling. I just talked about

2235
00:55:07,640 --> 00:55:09,280
0,305 305,790 870,1235 1235,1490 1490,1640
lot coupling where they started

2236
00:55:09,280 --> 00:55:11,155
0,120 120,380 490,890 1210,1545 1545,1875
the route, both both in

2237
00:55:11,155 --> 00:55:12,480
0,395
EM.|
|

2238
00:55:13,060 --> 00:55:14,540
0,290 290,470 470,760
In read mode.|
在读取模式下。|

2239
00:55:15,720 --> 00:55:17,360
0,400 690,1055 1055,1310 1310,1475 1475,1640
Right, eh, thread two goes
对，嗯，线程2向下，将b带入读取模式，线程c向下，取下Eh线程。一个关闭，将节点c置于写入模式，这是它想要删除的键。

2240
00:55:17,360 --> 00:55:18,980
0,290 640,990 990,1215 1215,1410 1410,1620
down, takes b into read

2241
00:55:18,980 --> 00:55:20,590
0,290 520,870 870,1110 1110,1305 1305,1610
mode, thread c goes down

2242
00:55:20,820 --> 00:55:24,340
0,290 290,580 1710,2110 2460,2860 3120,3520
and takes takes eh thread.

2243
00:55:24,420 --> 00:55:26,000
0,290 290,455 455,680 680,1030 1170,1580
One goes down, takes node

2244
00:55:26,000 --> 00:55:27,485
0,240 240,435 435,615 615,920 1240,1485
c in write mode, and

2245
00:55:27,485 --> 00:55:28,100
0,210 210,315 315,435 435,540 540,615
that's the key that it

2246
00:55:28,100 --> 00:55:29,220
0,105 105,285 285,590
wants to delete.|
|

2247
00:55:29,220 --> 00:55:32,325
0,320 790,1065 1065,1340 2200,2600 2710,3105
Right, but now thread two,
对，但是现在线程2在叶节点上扫描，它想要在读模式下获取闩锁c，但它不能，因为它在写模式下保持该锁存。

2248
00:55:32,325 --> 00:55:34,425
0,405 405,615 615,855 855,1385 1795,2100
scanning across leaf nodes and

2249
00:55:34,425 --> 00:55:35,310
0,180 180,345 345,495 495,705 705,885
it wants to acquire the

2250
00:55:35,310 --> 00:55:37,700
0,290 1210,1575 1575,1845 1845,2070 2070,2390
latch c in read mode,

2251
00:55:38,020 --> 00:55:40,605
0,245 245,380 380,910 1200,1600 2310,2585
but it can't because t

2252
00:55:40,605 --> 00:55:41,955
0,180 180,390 390,695 865,1155 1155,1350
one holds that in write

2253
00:55:41,955 --> 00:55:42,860
0,305
mode.|
|

2254
00:55:44,270 --> 00:55:44,935
0,215 215,260 260,350 350,485 485,665
So we have to decide
所以我们必须决定我们想要在这里做什么。

2255
00:55:44,935 --> 00:55:45,565
0,165 165,285 285,390 390,495 495,630
what we want to do

2256
00:55:45,565 --> 00:55:46,440
0,275
here.|
|

2257
00:55:46,550 --> 00:55:47,700
0,400
Right.|
正确的。|

2258
00:55:48,000 --> 00:55:49,745
0,395 395,890 890,1100 1100,1330 1350,1745
And t2 doesn't know anything
T2对T1一无所知。

2259
00:55:49,745 --> 00:55:51,400
0,395 475,995
about t1.|
|

2260
00:55:51,620 --> 00:55:52,615
0,245 245,380 380,545 545,755 755,995
Because I said there's no
因为我说过没有集中化的数据结构来说明，这是正在运行的线程。这是，你知道，这是他们正在做的，它所知道的是，在我想要访问的另一个节点上有一个闩锁，它目前处于正确的模式，与我想要设置的模式不兼容，所以你必须做些什么。

2261
00:55:52,615 --> 00:55:53,995
0,510 510,765 765,1020 1020,1200 1200,1380
centralized data structure that says,

2262
00:55:53,995 --> 00:55:54,730
0,255 255,360 360,570 570,645 645,735
here's the threads that are

2263
00:55:54,730 --> 00:55:56,020
0,225 225,630 630,795 795,990 990,1290
running. Here's, you know, here's

2264
00:55:56,020 --> 00:55:57,535
0,90 90,240 240,470 880,1230 1230,1515
what they're doing, all that

2265
00:55:57,535 --> 00:55:58,600
0,255 255,450 450,615 615,855 855,1065
sees all it knows is

2266
00:55:58,600 --> 00:55:59,650
0,180 180,405 405,495 495,795 795,1050
that there's a latch on

2267
00:55:59,650 --> 00:56:00,745
0,135 135,345 345,825 825,1020 1020,1095
this other node that I

2268
00:56:00,745 --> 00:56:01,825
0,90 90,180 180,330 330,635 835,1080
want to go to, and

2269
00:56:01,825 --> 00:56:02,665
0,150 150,300 300,480 480,660 660,840
it's currently in right mode

2270
00:56:02,665 --> 00:56:03,520
0,120 120,285 285,390 390,795 795,855
and that's not compatible with

2271
00:56:03,520 --> 00:56:04,045
0,75 75,195 195,345 345,450 450,525
the mode I want to

2272
00:56:04,045 --> 00:56:05,320
0,90 90,165 165,395 835,1080 1080,1275
put it in, so you

2273
00:56:05,320 --> 00:56:06,520
0,195 195,285 285,405 405,680
have to do something.|
|

2274
00:56:08,070 --> 00:56:09,380
0,245 245,490 510,830 830,1190 1190,1310
So what can t2 do
那么T2能在这里做些什么呢？

2275
00:56:09,380 --> 00:56:10,320
0,260
here?|
|

2276
00:56:13,160 --> 00:56:14,130
0,260 260,410 410,605 605,710 710,970
The weight that one option,
重量，那一个选项，还有什么？

2277
00:56:14,240 --> 00:56:15,560
0,245 245,490
what else?|
|

2278
00:56:17,940 --> 00:56:18,940
0,60 60,290
What's that?|
那是什么？|

2279
00:56:19,375 --> 00:56:20,155
0,75 75,305 355,600 600,675 675,780
Okay, let's. Are you reading
好了，我们开始吧。你在看幻灯片吗？

2280
00:56:20,155 --> 00:56:21,300
0,150 150,425
the slides?|
|

2281
00:56:25,960 --> 00:56:26,780
0,230 230,290 290,380 380,530 530,820
OK, what's the third option?|
好的，第三种选择是什么？|

2282
00:56:30,180 --> 00:56:31,280
0,305 305,560 560,815 815,995 995,1100
And go street on the
然后在另一条线上走上街头，试图杀死它，杀死它，并从它身上取下插销。

2283
00:56:31,280 --> 00:56:31,985
0,180 180,405 405,525 525,615 615,705
other thread and try to

2284
00:56:31,985 --> 00:56:34,865
0,245 475,750 750,1025 2425,2715 2715,2880
kill, kill it and take

2285
00:56:34,865 --> 00:56:36,380
0,120 120,255 255,360 360,605
the latch from it.|
|

2286
00:56:37,870 --> 00:56:38,580
0,335 335,515 515,590 590,650 650,710
So what do you think
那么，你认为在这里什么是一个好主意？

2287
00:56:38,580 --> 00:56:39,290
0,75 75,150 150,285 285,450 450,710
is a good idea here?|
|

2288
00:56:40,540 --> 00:56:42,105
0,260 260,520 870,1145 1145,1370 1370,1565
With that says, wait for
上面写着，要等多久？

2289
00:56:42,105 --> 00:56:43,040
0,105 105,365
how long?|
|

2290
00:56:48,740 --> 00:56:53,960
0,335 335,670 4080,4355 4355,4630
Heard forever how long?|
听到永远多久了？|

2291
00:56:54,000 --> 00:56:54,665
0,245 245,350 350,440 440,500 500,665
But how do you know?
但你怎么知道呢？就像，但一旦它意识到c上没有插销。

2292
00:56:54,665 --> 00:56:56,870
0,335 745,1145 1345,1635 1635,1875 1875,2205
Like, but once it realize

2293
00:56:56,870 --> 00:56:58,060
0,240 240,465 465,585 585,840 840,1190
there isn't a latch on

2294
00:56:58,080 --> 00:56:58,940
0,400
c.|
|

2295
00:56:58,940 --> 00:56:59,840
0,150 150,285 285,420 420,675 675,900
But that just waiting, right?
但那只是等待，对吗？它只是旋转，直到插销可用，但就像。

2296
00:56:59,840 --> 00:57:00,695
0,120 120,315 315,660 660,780 780,855
It just spinning until the

2297
00:57:00,695 --> 00:57:01,630
0,150 150,300 300,510 510,690 690,935
latch is available, but like.|
|

2298
00:57:02,280 --> 00:57:03,600
0,290
Are.|
是。|

2299
00:57:06,030 --> 00:57:07,260
0,230 230,320 320,410 410,640
How to say this?|
这话怎么说呢？|

2300
00:57:08,030 --> 00:57:09,190
0,215 215,335 335,590 590,875 875,1160
Do you know what T
你知道T T One是什么吗？你知道一个人在做什么吗？

2301
00:57:09,190 --> 00:57:11,095
0,255 255,450 450,740 1570,1815 1815,1905
T one is? You know

2302
00:57:11,095 --> 00:57:11,850
0,120 120,240 240,345 345,480 480,755
what t one is doing?|
|

2303
00:57:13,130 --> 00:57:14,160
0,275 275,395 470,515 515,680 680,1030
No, we don't know anything.|
不，我们什么都不知道。|

2304
00:57:14,720 --> 00:57:15,780
0,350
Right.|
正确的。|

2305
00:57:17,940 --> 00:57:18,815
0,275 275,410 410,530 530,695 695,875
Well, we know that t
嗯，我们知道tone就像编辑一样。

2306
00:57:18,815 --> 00:57:19,760
0,135 135,255 255,420 420,915
one is like editing.|
|

2307
00:57:20,390 --> 00:57:22,510
0,290 290,580 960,1360 1800,2045 2045,2120
Do you? Well, you know
你是?嗯，你知道它是在正确的模式，但它将需要多长时间？

2308
00:57:22,510 --> 00:57:23,515
0,120 120,195 195,330 330,620 760,1005
it's in right mode, but

2309
00:57:23,515 --> 00:57:23,860
0,90 90,180 180,240 240,285 285,345
how long is it going

2310
00:57:23,860 --> 00:57:24,900
0,60 60,290
to take?|
|

2311
00:57:29,830 --> 00:57:31,660
0,400
Uh.|
呃。|

2312
00:57:32,130 --> 00:57:33,300
0,400
How?|
多么?|

2313
00:57:34,240 --> 00:57:35,085
0,275 275,440 440,635 635,755 755,845
Which one? Like, do you
哪个？比如，你有没有从你的日程表中自杀？你会杀掉你日程表上的另一个人吗？你想做什么？

2314
00:57:35,085 --> 00:57:35,925
0,195 195,390 390,510 510,630 630,840
kill yourself from your schedule?

2315
00:57:35,925 --> 00:57:36,435
0,150 150,210 210,315 315,405 405,510
Do you kill the other

2316
00:57:36,435 --> 00:57:37,155
0,120 120,195 195,285 285,525 525,720
guy in your schedule? What

2317
00:57:37,155 --> 00:57:37,580
0,45 45,90 90,135 135,195 195,425
do you want to do?|
|

2318
00:57:39,390 --> 00:57:40,280
0,260 260,410 410,560 560,650 650,890
She says kill the oven.
她说关掉烤箱。太棒了，对吧？你怎么做到的？

2319
00:57:40,280 --> 00:57:42,365
0,290 310,710 1690,1935 1935,2010 2010,2085
Fantastic, right? How do you

2320
00:57:42,365 --> 00:57:43,720
0,105 105,365
do that?|
|

2321
00:57:45,580 --> 00:57:50,300
0,260 260,520
With that.|
有了这一点。|

2322
00:57:55,220 --> 00:57:55,765
0,230 230,275 275,320 320,425 425,545
What do you mean keep
你什么意思，把你过去做的每一件事都记下来？

2323
00:57:55,765 --> 00:57:56,365
0,90 90,285 285,465 465,525 525,600
a log everything you done

2324
00:57:56,365 --> 00:57:57,500
0,75 75,150 150,395
in the past?|
|

2325
00:57:57,900 --> 00:57:59,000
0,320 320,560 560,800 800,980 980,1100
Record like all the all
像你想做的所有操作一样记录下来。如果你想重新安排，那就走吧。

2326
00:57:59,000 --> 00:57:59,810
0,180 180,450 450,630 630,705 705,810
the operations you want to

2327
00:57:59,810 --> 00:58:00,410
0,165 165,315 315,420 420,525 525,600
make. And if you want

2328
00:58:00,410 --> 00:58:01,700
0,75 75,510 510,770 940,1260
to reschedule, just go.|
|

2329
00:58:04,280 --> 00:58:05,155
0,245 245,350 350,530 530,710 710,875
I mean, like store a
我的意思是，就像储存一个队列，然后说，我们会回来这样做的。

2330
00:58:05,155 --> 00:58:06,250
0,225 225,450 450,615 615,840 840,1095
que and say like, we'll

2331
00:58:06,250 --> 00:58:08,100
0,105 105,270 270,435 435,710 1450,1850
come back and do so.|
|

2332
00:58:08,990 --> 00:58:11,260
0,400 810,1070 1070,1265 1265,1600
Yeah, that sounds expensive.|
是啊，听起来很贵。|

2333
00:58:14,660 --> 00:58:15,400
0,245 245,335 335,425 425,575 575,740
What is a normal amount
正常的时间是多少？

2334
00:58:15,400 --> 00:58:16,380
0,105 105,350
of time?|
|

2335
00:58:16,580 --> 00:58:17,740
0,255 255,615 615,980
Average time for.|
的平均时间。|

2336
00:58:20,520 --> 00:58:21,545
0,260 260,500 500,770 770,920 920,1025
He says wait for the
他说，等待权利发生的平均时间。

2337
00:58:21,545 --> 00:58:22,340
0,180 180,405 405,540 540,645 645,795
average time for a right

2338
00:58:22,340 --> 00:58:24,840
0,150 150,410
to happen.|
|

2339
00:58:26,680 --> 00:58:29,180
0,275 275,550 810,1100 1100,1510 2100,2500
But like you don't say
但就像你在我这个简单的例子中没有说的，因为小提琴和PowerPoint，在叶子中有两个节点，对吗？

2340
00:58:29,350 --> 00:58:30,840
0,260 260,520 720,1040 1040,1280 1280,1490
in my simple example here,

2341
00:58:30,840 --> 00:58:32,000
0,285 285,525 525,660 660,750 750,1160
because the fiddle and powerpoint,

2342
00:58:32,410 --> 00:58:33,225
0,350 350,470 470,635 635,725 725,815
there's two nodes in the

2343
00:58:33,225 --> 00:58:34,580
0,245 265,665
leaf, right?|
|

2344
00:58:34,680 --> 00:58:35,465
0,260 260,395 395,515 515,605 605,785
What if there was a
如果这里到处都是树叶节点呢？

2345
00:58:35,465 --> 00:58:36,650
0,225 225,375 375,540 540,930 930,1185
bunch of leaf nodes all

2346
00:58:36,650 --> 00:58:37,940
0,285 285,620
over here?|
|

2347
00:58:37,980 --> 00:58:38,750
0,275 275,380 380,470 470,620 620,770
I got to hold all
我得让所有的人都保持在正确的状态，对吗？因为我希望我的更改自动发生，所以我不知道其他线程是否继续朝着相反的方向前进。我不喜欢什么是正常时间？你不知道。

2348
00:58:38,750 --> 00:58:40,175
0,135 135,360 360,710 1120,1350 1350,1425
these guys in everything in

2349
00:58:40,175 --> 00:58:41,645
0,135 135,425 895,1230 1230,1395 1395,1470
right mode, right? Because I

2350
00:58:41,645 --> 00:58:42,185
0,90 90,195 195,330 330,435 435,540
want my change to happen

2351
00:58:42,185 --> 00:58:43,730
0,635 715,1035 1035,1215 1215,1410 1410,1545
atomically so I don't know

2352
00:58:43,730 --> 00:58:44,765
0,195 195,360 360,540 540,810 810,1035
whether this other thread keep

2353
00:58:44,765 --> 00:58:45,670
0,180 180,330 330,405 405,570 570,905
going in the other direction.

2354
00:58:45,990 --> 00:58:46,820
0,245 245,410 410,590 590,755 755,830
I don't like what is

2355
00:58:46,820 --> 00:58:47,600
0,90 90,270 270,495 495,645 645,780
a normal time? You don't

2356
00:58:47,600 --> 00:58:48,320
0,230
know.|
|

2357
00:58:50,670 --> 00:58:51,695
0,275 275,425 425,590 590,785 785,1025
Give up our right lock,
放弃我们的右锁，让另一个人来读。

2358
00:58:51,695 --> 00:58:52,690
0,210 210,315 315,450 450,675 675,995
let the other guy read.|
|

2359
00:58:53,320 --> 00:58:54,040
0,195 195,315 315,435 435,555 555,720
He says give up your
他说放弃你的右锁，让另一个人读。

2360
00:58:54,040 --> 00:58:54,820
0,195 195,390 390,570 570,705 705,780
right lock and let the

2361
00:58:54,820 --> 00:58:56,280
0,105 105,285 285,590
other guy read.|
|

2362
00:58:56,460 --> 00:58:57,245
0,290 290,425 425,515 515,605 605,785
But how do you know?
但你怎么知道呢？你怎么知道他们在等你？

2363
00:58:57,245 --> 00:58:57,830
0,180 180,255 255,330 330,450 540,585
How do you know they're

2364
00:58:57,830 --> 00:58:59,040
0,150 150,330 330,590
waiting for you?|
|

2365
00:58:59,040 --> 00:59:00,140
0,255 255,450 450,690 690,825 825,1100
Like, if you're t one,
比如，如果你只有一岁，你怎么知道其他人想抢你的门锁呢？

2366
00:59:00,490 --> 00:59:01,125
0,245 245,320 320,395 395,500 500,635
how do you know somebody

2367
00:59:01,125 --> 00:59:01,830
0,150 150,285 285,390 390,480 480,705
else is trying to get

2368
00:59:01,830 --> 00:59:03,180
0,270 270,590
your latch?|
|

2369
00:59:04,340 --> 00:59:05,680
0,400 690,935 935,1025 1025,1160 1160,1340
Yes, so we don't know
是的，所以我们对其他线索一无所知。我们所知道的唯一事情就是关于我们自己和我们做了什么，以至于我们应该自杀。我们走吧。太棒了。

2370
00:59:05,680 --> 00:59:07,290
0,255 255,525 525,735 735,980 1000,1610
anything about the other threads.

2371
00:59:07,310 --> 00:59:08,065
0,230 230,335 335,470 470,575 575,755
The only thing we know

2372
00:59:08,065 --> 00:59:09,265
0,225 225,515 625,930 930,1080 1080,1200
is about ourselves and what

2373
00:59:09,265 --> 00:59:10,030
0,150 150,360 360,540 540,645 645,765
we did so that we

2374
00:59:10,030 --> 00:59:11,590
0,135 135,360 360,710 1240,1485 1485,1560
should kill ourselves. There we

2375
00:59:11,590 --> 00:59:12,940
0,135 135,440
go. Excellent.|
|

2376
00:59:12,980 --> 00:59:15,145
0,290 290,425 425,670 1530,1880 1880,2165
So you should kill yourself,
所以你应该自杀，对吗？正确的。因此，终止其他线程是很困难的，因为您将如何实现它？你能发送中断，中断面板吗？那很贵，对吧？这是一个系统呼叫。有像国旗一样的东西吗？你会说，我应该自杀吗？你必须每隔一段时间检查一次。这是怎么回事呢？正在检查其他内存位置吗？

2377
00:59:15,145 --> 00:59:18,235
0,335 1555,1890 1890,2225 2545,2850 2850,3090
right? Right. So killing other

2378
00:59:18,235 --> 00:59:19,380
0,225 225,390 390,630 630,870 870,1145
thread is hard because how

2379
00:59:19,820 --> 00:59:21,085
0,245 245,455 455,710 710,1000 1020,1265
would you implement that? Can

2380
00:59:21,085 --> 00:59:22,855
0,120 120,375 375,755 1285,1560 1560,1770
you send interrupt, interrupt panel?

2381
00:59:22,855 --> 00:59:23,920
0,345 345,570 570,780 780,975 975,1065
That's expensive, right? That's a

2382
00:59:23,920 --> 00:59:26,470
0,165 165,440 1810,2115 2115,2355 2355,2550
sys call. Is there like

2383
00:59:26,470 --> 00:59:27,835
0,210 210,495 495,735 735,1040 1120,1365
a flag? You say, should

2384
00:59:27,835 --> 00:59:29,230
0,135 135,390 390,755 1075,1320 1320,1395
I kill myself? And you

2385
00:59:29,230 --> 00:59:29,890
0,75 75,195 195,345 345,495 495,660
have to check that every

2386
00:59:29,890 --> 00:59:30,685
0,150 150,360 360,570 570,675 675,795
so often. How would that

2387
00:59:30,685 --> 00:59:33,640
0,275 2155,2460 2460,2595 2595,2700 2700,2955
work? Checking some other memory

2388
00:59:33,640 --> 00:59:34,620
0,380
location?|
|

2389
00:59:34,620 --> 00:59:35,730
0,240 240,620 640,915 915,1035 1035,1110
Right. And, and what do
正确的。然后，你得到了什么？你得到了，你知道，你不知道另一个线程做了多少工作，另一个线程完成了，因此你不知道他是否会中止。而且退回比你自己放弃代价要高得多。

2390
00:59:35,730 --> 00:59:36,500
0,90 90,255 255,405 405,510 510,770
you get? You get the,

2391
00:59:36,520 --> 00:59:37,860
0,230 230,460 660,935 935,1205 1205,1340
you know, you don't know

2392
00:59:37,860 --> 00:59:38,850
0,150 150,330 330,585 585,780 780,990
how much work the other

2393
00:59:38,850 --> 00:59:39,960
0,350 430,660 660,795 795,960 960,1110
thread, the other thread is

2394
00:59:39,960 --> 00:59:43,110
0,290 610,975 975,1340 2680,2940 2940,3150
done and therefore you don't

2395
00:59:43,110 --> 00:59:44,385
0,105 105,345 345,675 675,1110 1110,1275
know whether him abort. And

2396
00:59:44,385 --> 00:59:45,780
0,195 195,480 480,780 780,1110 1110,1395
rolling back is was way

2397
00:59:45,780 --> 00:59:47,025
0,270 270,585 585,810 810,1005 1005,1245
more expensive than than than

2398
00:59:47,025 --> 00:59:48,540
0,165 165,525 525,905
you abort yourself.|
|

2399
00:59:48,540 --> 00:59:49,485
0,210 210,405 405,660 660,825 825,945
You know nothing at this
在这一点上你什么都不知道。

2400
00:59:49,485 --> 00:59:50,280
0,275
point.|
|

2401
00:59:50,280 --> 00:59:51,380
0,350
Right.|
正确的。|

2402
00:59:51,390 --> 00:59:53,795
0,400 900,1220 1220,1540 1890,2195 2195,2405
So the best thing to
所以最好的办法就是自杀。

2403
00:59:53,795 --> 00:59:55,690
0,305 655,960 960,1185 1185,1500 1500,1895
do is just kill yourself.|
|

2404
00:59:56,940 --> 00:59:58,265
0,290 290,545 545,815 815,1055 1055,1325
And then you maybe you
然后你也许你也可以在开始的时候等待一段时间，然后立即放弃，这取决于你知道你需要做什么。

2405
00:59:58,265 --> 00:59:59,060
0,195 195,330 330,480 480,630 630,795
also could wait a little

2406
00:59:59,060 --> 00:59:59,915
0,135 135,210 210,330 330,600 600,855
bit in the beginning and

2407
00:59:59,915 --> 01:00:01,000
0,180 180,360 360,540 540,765 765,1085
then give up right away,

2408
01:00:01,380 --> 01:00:02,285
0,305 305,470 470,620 620,770 770,905
depending on what you know

2409
01:00:02,285 --> 01:00:03,660
0,135 135,255 255,375 375,635
you need to do.|
|

2410
01:00:03,670 --> 01:00:04,780
0,400
Right.|
正确的。|

2411
01:00:05,430 --> 01:00:06,350
0,275 275,455 455,635 635,770 770,920
And so this is the
所以这是最简单的事情。事实证明，这是在大多数情况下，所有情况下最好的做法，因为同样，您对线程一无所知。你不能与另一个线程通信，因为这很昂贵。

2412
01:00:06,350 --> 01:00:07,480
0,300 300,420 420,540 540,765 765,1130
simplest thing to do. And

2413
01:00:07,650 --> 01:00:08,315
0,290 290,440 440,545 545,605 605,665
it turns out to be

2414
01:00:08,315 --> 01:00:09,070
0,90 90,240 240,405 405,510 510,755
the best thing to do

2415
01:00:09,210 --> 01:00:11,195
0,260 260,395 395,940 1260,1550 1550,1985
in most scenarios, all scenarios,

2416
01:00:11,195 --> 01:00:13,445
0,240 240,545 1675,1935 1935,2145 2145,2250
because again, you don't know

2417
01:00:13,445 --> 01:00:14,240
0,120 120,225 225,375 375,585 585,795
anything about the thread. You

2418
01:00:14,240 --> 01:00:15,185
0,300 300,525 525,705 705,780 780,945
can't communicate with the other

2419
01:00:15,185 --> 01:00:16,860
0,240 240,390 390,660 660,965
thread, because that's expensive.|
|

2420
01:00:17,365 --> 01:00:18,060
0,105 105,165 165,255 255,405 405,695
And you're just better off
你最好放弃，然后重新开始。

2421
01:00:18,110 --> 01:00:19,530
0,530 530,665 665,845 845,1085 1085,1420
aborting and starting over again.|
|

2422
01:00:20,870 --> 01:00:22,000
0,400
Yes.|
是。|

2423
01:00:22,000 --> 01:00:22,945
0,255 255,420 420,585 585,765 765,945
Face the same thing when
在树上往下走的时候也要面对同样的事情，对吧？

2424
01:00:22,945 --> 01:00:24,655
0,300 300,960 960,1215 1215,1470 1470,1710
going downwards in the tree,

2425
01:00:24,655 --> 01:00:25,300
0,305
right?|
|

2426
01:00:26,200 --> 01:00:27,240
0,225 225,360 360,555 555,765 765,1040
Because if someone has taken
因为如果有人拿走了。

2427
01:00:27,470 --> 01:00:27,800
0,290
the.|
|

2428
01:00:28,680 --> 01:00:29,800
0,165 165,375 375,680 760,1080
Below us we have.|
在我们下面我们有。|

2429
01:00:31,870 --> 01:00:33,720
0,230 230,320 320,485 485,790
So his statement is?|
所以他的口供是？|

2430
01:00:34,790 --> 01:00:35,560
0,230 230,305 305,410 410,530 530,770
You would have to wait
你也必须等待或携带自己，就像当你在做树的自上而下的遍历时。如果我试图获取下一个节点上的其他人的锁存，但我所做的已经被阻止了。这里是同样的情况，同样的情况，但在这种情况下，你不是。

2431
01:00:35,560 --> 01:00:37,060
0,285 285,465 465,740 940,1245 1245,1500
also to or carry itself

2432
01:00:37,060 --> 01:00:38,130
0,300 300,540 540,675 675,840 840,1070
too, like when you're doing

2433
01:00:38,570 --> 01:00:39,790
0,365 365,860 860,920 920,1040 1040,1220
the traversal of the tree

2434
01:00:39,790 --> 01:00:41,050
0,180 180,375 375,680 910,1140 1140,1260
going top down. If I

2435
01:00:41,050 --> 01:00:41,905
0,165 165,300 300,465 465,615 615,855
try to acquire a latch

2436
01:00:41,905 --> 01:00:43,465
0,195 195,390 390,725 1195,1455 1455,1560
on somebody else on the

2437
01:00:43,465 --> 01:00:44,410
0,150 150,420 420,600 600,840 840,945
next node, but that's already

2438
01:00:44,410 --> 01:00:45,660
0,150 150,410 550,825 825,975 975,1250
being held what I do.

2439
01:00:45,770 --> 01:00:47,130
0,320 320,425 425,620 620,940 960,1360
It's the same scenario here,

2440
01:00:47,690 --> 01:00:48,685
0,275 275,425 425,650 650,875 875,995
that same scenario, but in

2441
01:00:48,685 --> 01:00:50,540
0,135 135,425 595,900 900,1115
that case, you're not.|
|

2442
01:00:52,070 --> 01:00:53,230
0,75 75,195 195,555 555,810 810,1160
You won't deadlock, though, right?|
不过，你们不会僵持的，对吧？|

2443
01:00:54,160 --> 01:00:55,200
0,210 210,375 375,540 540,720 720,1040
The problem is, like again,
问题是，就像以前一样，如果t两个人想要套上门锁，t个人想要套上b，而t两个人想要套上c的L，这是一个僵局，你不知道。

2444
01:00:55,340 --> 01:00:56,605
0,305 305,590 590,905 905,1115 1115,1265
if if t two wants

2445
01:00:56,605 --> 01:00:57,475
0,105 105,195 195,315 315,540 540,870
to get the latch on

2446
01:00:57,475 --> 01:00:59,245
0,395 985,1350 1350,1590 1590,1695 1695,1770
on, t wants to get

2447
01:00:59,245 --> 01:01:00,510
0,60 60,165 165,315 315,605 865,1265
the latch on b, and

2448
01:01:00,830 --> 01:01:01,645
0,290 290,425 425,530 530,665 665,815
t two wants to l

2449
01:01:01,645 --> 01:01:03,720
0,195 195,515 1195,1545 1545,1635 1635,2075
on c, that's a deadlock

2450
01:01:03,890 --> 01:01:05,660
0,305 305,650 650,940
you don't know.|
|

2451
01:01:05,790 --> 01:01:07,025
0,305 305,500 500,590 590,995 995,1235
That it's a deadlock or
这是一个死锁，还是只是争抢了一些插销，对吗？所以最好的办法就是立即放弃。

2452
01:01:07,025 --> 01:01:08,650
0,195 195,605 805,1140 1140,1320 1320,1625
just contention acquiring some latch,

2453
01:01:09,120 --> 01:01:11,330
0,335 335,670 840,1240 1800,2090 2090,2210
right? So the best thing

2454
01:01:11,330 --> 01:01:12,800
0,45 45,240 240,620 940,1275 1275,1470
to do is immediately give

2455
01:01:12,800 --> 01:01:13,600
0,260
up.|
|

2456
01:01:13,640 --> 01:01:14,440
0,260 260,395 395,545 545,680 680,800
And that means you could
这意味着你可能会有这样一种情况，你拿着鞭子，我拿着鞭子，我们中的一个人应该只放弃。但我们最终既放弃又自杀，对吗？

2457
01:01:14,440 --> 01:01:15,805
0,105 105,210 210,420 420,770 1090,1365
have a scenario where you

2458
01:01:15,805 --> 01:01:16,420
0,135 135,240 240,405 405,525 525,615
hold the lash and I

2459
01:01:16,420 --> 01:01:17,275
0,120 120,225 225,420 420,660 660,855
hold the lash and one

2460
01:01:17,275 --> 01:01:17,860
0,105 105,210 210,330 330,450 450,585
of us should only give

2461
01:01:17,860 --> 01:01:18,415
0,165 165,315 315,390 390,450 450,555
up. But we end up

2462
01:01:18,415 --> 01:01:19,405
0,195 195,420 420,600 600,750 750,990
both giving up and killing

2463
01:01:19,405 --> 01:01:21,100
0,365 625,1025
ourselves, right?|
|

2464
01:01:21,100 --> 01:01:24,300
0,290 730,1035 1035,1340 1630,2030 2800,3200
Uh, but again, the cost
呃，但再说一次，维护关于谁在以何种方式等待什么的元数据的成本，在假设没有争用的常规情况下要更昂贵。

2465
01:01:24,470 --> 01:01:27,055
0,305 305,610 1290,2015 2015,2270 2270,2585
of maintaining metadata about who's

2466
01:01:27,055 --> 01:01:28,210
0,135 135,300 300,465 465,755 835,1155
waiting for what in what

2467
01:01:28,210 --> 01:01:30,805
0,320 730,1170 1170,1365 1365,1700 2200,2595
way, that's more expensive to

2468
01:01:30,805 --> 01:01:31,930
0,300 300,570 570,780 780,945 945,1125
do in the regular case

2469
01:01:31,930 --> 01:01:32,710
0,90 90,180 180,300 300,480 480,780
where you assume there isn't

2470
01:01:32,710 --> 01:01:33,640
0,350
contention.|
|

2471
01:01:35,140 --> 01:01:35,890
0,135 135,330 330,495 495,600 600,750
An example in a case
这是一个双方都在等待对方的例子。

2472
01:01:35,890 --> 01:01:36,895
0,195 195,405 405,570 570,795 795,1005
where both are waiting for

2473
01:01:36,895 --> 01:01:37,520
0,120 120,395
each other.|
|

2474
01:01:37,720 --> 01:01:40,075
0,620 820,1220 1270,1560 1560,1850 2050,2355
Overheard the t two t
无意中听到的t2t1将不需要去b。

2475
01:01:40,075 --> 01:01:40,960
0,180 180,345 345,555 555,750 750,885
one will not need to

2476
01:01:40,960 --> 01:01:41,420
0,150 150,300 300,420
go to b.|
|

2477
01:01:42,300 --> 01:01:43,190
0,320 320,530 530,665 665,770 770,890
Yeah, so it was this
是啊，所以就是这个了，对吧？所以他们都在读，但假设他们都在写，对吗？我需要，我需要更新所有的钥匙。

2478
01:01:43,190 --> 01:01:44,480
0,120 120,270 270,560 700,1035 1035,1290
one here, right? So they're

2479
01:01:44,480 --> 01:01:45,440
0,120 120,315 315,660 660,810 810,960
both doing reads, but assume

2480
01:01:45,440 --> 01:01:47,150
0,150 150,255 255,435 435,740 1330,1710
they're both doing writes right?

2481
01:01:47,150 --> 01:01:48,800
0,380 400,800 1150,1395 1395,1485 1485,1650
I need, I need to

2482
01:01:48,800 --> 01:01:50,440
0,195 195,405 405,740
update all keys.|
|

2483
01:01:50,540 --> 01:01:51,510
0,275 275,410 410,560 560,710 710,970
Greater than one or something
大于1或大于4需要更新密钥，对吗？我要往这边走。他往那边去了。我们有一个僵局，多把钥匙都在里面。

2484
01:01:51,680 --> 01:01:52,555
0,245 245,350 350,530 530,725 725,875
he needs to update keys

2485
01:01:52,555 --> 01:01:54,085
0,150 150,300 300,575 745,1145 1195,1530
less than four, right? I'm

2486
01:01:54,085 --> 01:01:54,955
0,120 120,270 270,495 495,765 765,870
going this way. He's gone

2487
01:01:54,955 --> 01:01:57,070
0,165 165,455 985,1230 1230,1475 1795,2115
that way. We have that's

2488
01:01:57,070 --> 01:01:58,780
0,60 60,410 910,1305 1305,1575 1575,1710
a deadlock multiple keys in

2489
01:01:58,780 --> 01:01:59,760
0,260
the.|
|

2490
01:01:59,840 --> 01:02:00,940
0,90 90,210 210,390 390,710
At the same time.|
在同一时间。|

2491
01:02:02,450 --> 01:02:03,415
0,275 275,380 380,485 485,620 620,965
Think in terms of latches,
就插销而言，我试图在这个方向上获得插销，在那个方向上尝试，但我们陷入了僵局。

2492
01:02:03,415 --> 01:02:04,435
0,195 195,270 270,480 480,780 780,1020
I'm trying to acquire latch

2493
01:02:04,435 --> 01:02:06,090
0,305 595,900 900,1185 1185,1410 1410,1655
on this direction, trying to

2494
01:02:06,470 --> 01:02:08,160
0,320 320,640 870,1115 1115,1235 1235,1690
that direction and we're deadlocked.|
|

2495
01:02:11,500 --> 01:02:12,210
0,260 260,410 410,545 545,635 635,710
Your question is how to
你的问题是如何防止他们两人自杀。

2496
01:02:12,210 --> 01:02:12,945
0,135 135,300 300,375 375,495 495,735
prevent both of them killing

2497
01:02:12,945 --> 01:02:14,000
0,335
themselves.|
|

2498
01:02:14,130 --> 01:02:16,840
0,400 570,970 1380,1655 1820,2110
So, like, you can't.|
所以，就像，你不能。|

2499
01:02:17,050 --> 01:02:17,685
0,245 245,335 335,485 485,545 545,635
Because I don't know. I
因为我不知道。我不知道你的存在。我不知道你做对了什么。

2500
01:02:17,685 --> 01:02:18,630
0,135 135,240 240,450 450,750 750,945
don't know you exist. I

2501
01:02:18,630 --> 01:02:19,245
0,135 135,195 195,300 300,435 435,615
don't know what you're doing

2502
01:02:19,245 --> 01:02:22,060
0,365
right.|
|

2503
01:02:22,100 --> 01:02:23,605
0,400 510,815 815,965 965,1210 1260,1505
Yeah. And you know, if
嗯。你知道，如果你只考虑一般的计算机，就像你和我不太可能在我们的线程和完全相同的周期数量上步调一致，我们都会试图获得一个锁存，然后就会死锁。我们要自相残杀。这是，这是一种种族状况，但它是，它是，它是罕见的。但你无法预防它，因为预防它的成本太高了。

2504
01:02:23,605 --> 01:02:24,685
0,105 105,225 225,330 330,575 805,1080
you just think of computers

2505
01:02:24,685 --> 01:02:26,130
0,135 135,315 315,635 655,1095 1095,1445
in general, like it's very

2506
01:02:26,210 --> 01:02:27,205
0,485 485,635 635,770 770,875 875,995
unlikely that you and I

2507
01:02:27,205 --> 01:02:28,450
0,105 105,270 270,570 570,1140 1140,1245
gonna be exact lockstep in

2508
01:02:28,450 --> 01:02:30,190
0,180 180,770 970,1230 1230,1440 1440,1740
our threads and the exact

2509
01:02:30,190 --> 01:02:31,945
0,350 460,795 795,1050 1050,1305 1305,1755
same like number of cycles,

2510
01:02:31,945 --> 01:02:32,635
0,255 255,390 390,525 525,600 600,690
we're both going to try

2511
01:02:32,635 --> 01:02:33,750
0,105 105,285 285,435 435,720 720,1115
to acquire a latch together

2512
01:02:34,220 --> 01:02:35,350
0,335 335,575 575,755 755,1010 1010,1130
that then would deadlock. We

2513
01:02:35,350 --> 01:02:36,670
0,120 120,240 240,360 360,620 820,1320
go kill each other. It's,

2514
01:02:36,670 --> 01:02:37,645
0,270 270,435 435,675 675,765 765,975
it's a, it's a race

2515
01:02:37,645 --> 01:02:39,055
0,240 240,390 390,600 600,965 1105,1410
condition, but it's, it's, it's

2516
01:02:39,055 --> 01:02:39,835
0,180 180,375 375,495 495,645 645,780
rare. But you can't prevent

2517
01:02:39,835 --> 01:02:41,215
0,305 355,600 600,825 825,1155 1155,1380
it because the cost of

2518
01:02:41,215 --> 01:02:42,600
0,360 360,605 625,900 900,1080 1080,1385
preventing it is so expensive.|
|

2519
01:02:48,610 --> 01:02:50,520
0,275 275,455 455,760 1590,1820 1820,1910
The statement is, from a
这种说法是，从哲学的角度来看，杀死另一个人会更有效率，这会更好吗？

2520
01:02:50,520 --> 01:02:52,560
0,645 645,1010 1540,1800 1800,1905 1905,2040
philosophical standpoint, it would be

2521
01:02:52,560 --> 01:02:53,310
0,180 180,375 375,540 540,660 660,750
more efficient to kill the

2522
01:02:53,310 --> 01:02:54,015
0,120 120,285 285,420 420,555 555,705
other one, would that be

2523
01:02:54,015 --> 01:02:56,520
0,275
better?|
|

2524
01:02:57,010 --> 01:02:58,125
0,305 305,380 380,530 530,950 950,1115
It's not only philosophical question,
这不仅仅是一个哲学问题，它就像，直截了当地说，是不是更好，就像你拿走他们的钱包一样，无论你喜欢什么。

2525
01:02:58,125 --> 01:02:58,770
0,195 195,270 270,405 405,540 540,645
it's just like, straight up,

2526
01:02:58,770 --> 01:03:01,215
0,105 105,195 195,440 2080,2340 2340,2445
is it better, like you

2527
01:03:01,215 --> 01:03:03,645
0,105 105,240 240,660 660,995 2065,2430
take their wallet, whatever you

2528
01:03:03,645 --> 01:03:05,180
0,365
like.|
|

2529
01:03:06,260 --> 01:03:07,195
0,305 305,485 485,605 605,725 725,935
Get this is a toy
这是一个玩具的例子，好像它只有一个节点。如果你想一想，我不知道我不知道你做了什么。我不知道。你不知道我做了什么。如果我们能追踪到这一点，那么我们可能会决定，好吧，你拿着五把锁，我拿着一把，最好杀了我，因为你做到了。你得等上好长时间才能拿到那五个插销。这在某种程度上是我们在进行交易时要做的事情，他们会根据到目前为止在这个最低级别完成的工作量来确定谁获得了优先权，其他人获得了优先权。在这个最低级别，闩锁应该是如此细腻和短小。最好还是自杀吧。

2530
01:03:07,195 --> 01:03:08,110
0,285 285,495 495,615 615,795 795,915
example where like it's only

2531
01:03:08,110 --> 01:03:09,280
0,165 165,555 555,840 840,1020 1020,1170
one node. Like if you

2532
01:03:09,280 --> 01:03:11,280
0,225 225,560 1090,1380 1380,1695 1695,2000
think about, I don't know

2533
01:03:11,510 --> 01:03:12,715
0,305 305,610 720,965 965,1115 1115,1205
what the I don't know

2534
01:03:12,715 --> 01:03:13,525
0,150 150,330 330,555 555,675 675,810
what work you've done. I

2535
01:03:13,525 --> 01:03:14,335
0,240 240,390 390,525 525,600 600,810
don't. You don't know what

2536
01:03:14,335 --> 01:03:15,160
0,315 315,435 435,585 585,675 675,825
I've done. If we can

2537
01:03:15,160 --> 01:03:16,105
0,165 165,270 270,530 550,795 795,945
sort of keep track of

2538
01:03:16,105 --> 01:03:18,580
0,305 835,1155 1155,1425 1425,1775 2095,2475
that, then we may maybe

2539
01:03:18,580 --> 01:03:20,340
0,360 360,645 645,950 1150,1455 1455,1760
decide, okay, well you hold

2540
01:03:20,360 --> 01:03:22,020
0,350 350,815 815,1025 1025,1295 1295,1660
five latches, I hold one,

2541
01:03:22,280 --> 01:03:23,460
0,305 305,440 440,605 605,830 830,1180
it's better to kill me

2542
01:03:23,780 --> 01:03:24,670
0,260 260,395 395,605 605,800 800,890
because you did. You had

2543
01:03:24,670 --> 01:03:25,105
0,75 75,180 180,270 270,345 345,435
to wait a bunch of

2544
01:03:25,105 --> 01:03:25,720
0,105 105,210 210,315 315,450 450,615
time to get those five

2545
01:03:25,720 --> 01:03:27,880
0,470 670,990 990,1490 1840,2085 2085,2160
latches. So that's sort of

2546
01:03:27,880 --> 01:03:29,425
0,120 120,300 300,590 700,1100 1210,1545
a high level what we'll

2547
01:03:29,425 --> 01:03:30,240
0,120 120,240 240,345 345,510 510,815
do when we do transactions,

2548
01:03:31,010 --> 01:03:32,155
0,335 335,455 455,620 620,905 905,1145
they'll figure out who who

2549
01:03:32,155 --> 01:03:33,235
0,120 120,360 360,585 585,825 825,1080
gets priority or others based

2550
01:03:33,235 --> 01:03:34,195
0,275 355,585 585,675 675,810 810,960
on how much work they've

2551
01:03:34,195 --> 01:03:35,305
0,105 105,255 255,515 685,945 945,1110
done so far at this

2552
01:03:35,305 --> 01:03:36,475
0,240 240,510 510,720 720,1035 1035,1170
lowest level the latches are

2553
01:03:36,475 --> 01:03:37,645
0,135 135,210 210,345 345,665 865,1170
meant to be so like

2554
01:03:37,645 --> 01:03:38,740
0,225 225,435 435,600 600,825 825,1095
fine grainained and short. It's

2555
01:03:38,740 --> 01:03:39,810
0,165 165,360 360,525 525,735 735,1070
better just to kill yourself.|
|

2556
01:03:40,290 --> 01:03:41,680
0,245 245,490
All right.|
好的。|

2557
01:03:43,600 --> 01:03:45,750
0,255 255,500 580,870 870,1160 1600,2150
Let's say t two isn't
假设t2没有等待t1，那么t1自杀了。

2558
01:03:45,830 --> 01:03:48,540
0,400 420,820 1380,1640 1640,1900 2310,2710
waiting on t one, then

2559
01:03:48,740 --> 01:03:50,960
0,245 245,490 900,1280 1280,1660
t one kills itself.|
|

2560
01:03:51,620 --> 01:03:54,160
0,350 350,700 1500,1805 1805,2110 2190,2540
Tries again, still bad, kills
再试一次，还是不好，又自杀了。一百万次了，对吧？谁能说这是不可能的？

2561
01:03:54,160 --> 01:03:55,525
0,285 285,620 880,1155 1155,1275 1275,1365
itself again. Does it a

2562
01:03:55,525 --> 01:03:57,100
0,210 210,525 525,875 1165,1470 1470,1575
million times, right? Who's to

2563
01:03:57,100 --> 01:03:58,540
0,135 135,300 300,585 585,860
say that isn't possible?|
|

2564
01:03:58,690 --> 01:03:59,445
0,245 245,350 350,530 530,680 680,755
It is possible. So the
这是可能的。所以问题是，你能不能饿死一根线？你想用这个词吗？你能饿着一根线吗？因为每一次你试图得到某样东西的时候，它都是不可能的，因为里面有别人。你能开动一下吗？是。

2565
01:03:59,445 --> 01:04:00,705
0,150 150,455 655,915 915,1020 1020,1260
question is, could you basically

2566
01:04:00,705 --> 01:04:02,310
0,395 685,930 930,1095 1095,1470 1470,1605
have, could you starve a

2567
01:04:02,310 --> 01:04:03,750
0,290 760,1020 1020,1140 1140,1305 1305,1440
thread? Is the term you

2568
01:04:03,750 --> 01:04:04,485
0,60 60,120 120,345 345,585 585,735
want to use? Could you

2569
01:04:04,485 --> 01:04:05,370
0,225 225,345 345,570 570,750 750,885
starve a thread? Because every

2570
01:04:05,370 --> 01:04:05,925
0,180 180,315 315,390 390,465 465,555
single time you try to

2571
01:04:05,925 --> 01:04:08,010
0,120 120,395 805,1205 1555,1845 1845,2085
get something it, it can't

2572
01:04:08,010 --> 01:04:08,460
0,75 75,165 165,270 270,360 360,450
because someone else is in

2573
01:04:08,460 --> 01:04:09,255
0,210 210,405 405,510 510,645 645,795
there. Could you start that?

2574
01:04:09,255 --> 01:04:10,120
0,275
Yes.|
|

2575
01:04:10,680 --> 01:04:11,920
0,400
So.|
所以。|

2576
01:04:12,580 --> 01:04:13,140
0,260 260,365 365,425 425,470 470,560
I think I have a
我想我在这件事上有点头绪。看见?

2577
01:04:13,140 --> 01:04:14,740
0,135 135,255 255,435 435,770
slide on this. See?|
|

2578
01:04:16,060 --> 01:04:17,580
0,380 380,760
Yeah, so.|
是啊，所以。|

2579
01:04:19,300 --> 01:04:22,365
0,610 780,2690 2690,2780 2780,2885 2885,3065
There's, I'll answer your question
有，我马上回答你的问题。像锁存L一样，锁存不会有任何东西来为我们处理死锁，它也不会有任何可以防止读写锁存中的饥饿的东西。您可以设置优先级，比如写入器或读取器，或者您想要执行FIFO或循环调度，但是在oh内部有一个高级构造调度器。

2580
01:04:22,365 --> 01:04:23,450
0,180 180,270 270,420 420,705 705,1085
in a second. Like the

2581
01:04:23,710 --> 01:04:25,380
0,275 275,800 800,1115 1115,1340 1340,1670
the latches l, the latches

2582
01:04:25,380 --> 01:04:26,160
0,195 195,285 285,465 465,675 675,780
aren't gonna have anything to

2583
01:04:26,160 --> 01:04:27,420
0,150 150,510 510,600 600,830 1000,1260
handle deadlocks for us, and

2584
01:04:27,420 --> 01:04:28,545
0,180 180,315 315,465 465,740 820,1125
it's not gonna have anything

2585
01:04:28,545 --> 01:04:31,530
0,225 225,545 1015,1410 1410,1985 2665,2985
that can prevent starvation in

2586
01:04:31,530 --> 01:04:33,510
0,255 255,495 495,705 705,1250 1630,1980
the read write latches. You

2587
01:04:33,510 --> 01:04:35,055
0,315 315,585 585,890 1000,1305 1305,1545
can set priorities like writers

2588
01:04:35,055 --> 01:04:36,480
0,240 240,525 525,905 1105,1350 1350,1425
or readers or you want

2589
01:04:36,480 --> 01:04:37,440
0,60 60,255 255,675 675,810 810,960
to do fifo or round

2590
01:04:37,440 --> 01:04:39,795
0,315 315,770 1750,2025 2025,2220 2220,2355
Robin scheduling, but there's a

2591
01:04:39,795 --> 01:04:42,140
0,255 255,605 775,1175 1225,1835 1945,2345
high level construct scheduler inside

2592
01:04:42,370 --> 01:04:43,400
0,400
oh.|
|

2593
01:04:43,690 --> 01:04:45,840
0,400 480,880 1350,1685 1685,1955 1955,2150
This, this, this worker is
这个，这个，这个工作进程试图运行这个查询，试图触及这个数据结构，但它一直被中止。我知道它正在被中止，因为我知道它会返回一个重试消息。因此，也许我想取消其他同时运行的工人的限制，以确保我总是能通过。它已经有了一种基本上处理这一问题的方法。

2594
01:04:45,840 --> 01:04:46,820
0,105 105,195 195,360 360,600 600,980
trying to run this query

2595
01:04:47,230 --> 01:04:48,480
0,245 245,455 455,755 755,995 995,1250
trying to touch this data

2596
01:04:48,480 --> 01:04:49,785
0,350 640,885 885,990 990,1140 1140,1305
structure and it keeps getting

2597
01:04:49,785 --> 01:04:50,970
0,405 405,645 645,825 825,1020 1020,1185
aborted. And I know it's

2598
01:04:50,970 --> 01:04:53,580
0,120 120,530 1900,2295 2295,2505 2505,2610
getting aborted because know it's

2599
01:04:53,580 --> 01:04:54,830
0,105 105,380 490,735 735,825 825,1250
coming back with a retry

2600
01:04:55,000 --> 01:04:56,925
0,400 840,1240 1260,1550 1550,1745 1745,1925
message. And therefore, maybe I

2601
01:04:56,925 --> 01:04:59,085
0,275 415,1050 1050,1295 1525,1920 1920,2160
wanna dechedule other workers running

2602
01:04:59,085 --> 01:04:59,640
0,90 90,180 180,300 300,450 450,555
at the same time to

2603
01:04:59,640 --> 01:05:00,390
0,105 105,240 240,390 390,555 555,750
make sure I always get

2604
01:05:00,390 --> 01:05:02,130
0,320 1120,1500 1500,1575 1575,1650 1650,1740
through. That's had a way

2605
01:05:02,130 --> 01:05:03,740
0,105 105,330 330,630 630,950
to basically handle that.|
|

2606
01:05:04,410 --> 01:05:06,425
0,380 380,760 990,1390 1470,1820 1820,2015
Most systems basically let you
大多数系统基本上都会让你知道。

2607
01:05:06,425 --> 01:05:07,460
0,245
know.|
|

2608
01:05:07,530 --> 01:05:08,660
0,305 305,560 560,785 785,920 920,1130
Let Jesus take the wheel,
让耶稣掌舵吧，不管你想用什么短语，让它去吧，对吧，因为最终你会通过的。现在，再一次，如果我有一个，你知道，一千个查询试图同时运行，试图全部更新相同的密钥，没有神奇的调度程序能够处理这一点。一切都像是得到了内容，最终变成了一个单线程系统。

2609
01:05:08,660 --> 01:05:09,290
0,225 225,360 360,480 480,570 570,630
whatever the phrase you want

2610
01:05:09,290 --> 01:05:11,060
0,60 60,135 135,380 1420,1665 1665,1770
to use and let it

2611
01:05:11,060 --> 01:05:13,085
0,120 120,270 270,450 450,740 1720,2025
go at it, right, because

2612
01:05:13,085 --> 01:05:16,220
0,305 1345,1745 2545,2805 2805,2940 2940,3135
eventually you should get through.

2613
01:05:16,220 --> 01:05:17,315
0,195 195,470 490,735 735,855 855,1095
Now, again, if I have

2614
01:05:17,315 --> 01:05:20,470
0,365 1315,1560 1560,1740 1740,2075 2755,3155
a, you know, a thousand

2615
01:05:20,940 --> 01:05:21,740
0,410 410,515 515,605 605,710 710,800
queries trying to run at

2616
01:05:21,740 --> 01:05:22,340
0,75 75,210 210,390 390,525 525,600
the same time trying to

2617
01:05:22,340 --> 01:05:23,620
0,230 280,555 555,720 720,945 945,1280
all update the same key,

2618
01:05:23,940 --> 01:05:25,640
0,380 380,605 605,940 1020,1505 1505,1700
there's no magic scheduler that's

2619
01:05:25,640 --> 01:05:26,285
0,75 75,150 150,225 225,390 390,645
gonna be able to handle

2620
01:05:26,285 --> 01:05:28,070
0,335 775,1265 1285,1530 1530,1620 1620,1785
that. Everything's sort of get

2621
01:05:28,070 --> 01:05:29,750
0,320 520,765 765,885 885,1160 1390,1680
content, end up being a

2622
01:05:29,750 --> 01:05:31,060
0,210 210,435 435,740
single thread system.|
|

2623
01:05:31,380 --> 01:05:32,420
0,245 245,350 350,455 455,635 635,1040
So we want to optimize
因此，我们希望针对假设的情况进行优化。

2624
01:05:32,420 --> 01:05:34,655
0,270 270,560 1150,1470 1470,1790 1840,2235
for the case where we

2625
01:05:34,655 --> 01:05:36,520
0,390 390,690 690,995
assume that the.|
|

2626
01:05:37,730 --> 01:05:38,785
0,320 320,545 545,830 830,965 965,1055
We assume contention is gonna
我们假设争夺率会很低，我们希望很快就失败。免重保单。我们只是检查一下，我能做吗？不，好的，让我再试一次，因为到那时，你知道，当我去的时候，去重试，然后我就可以做我需要做的事情了。

2627
01:05:38,785 --> 01:05:40,345
0,135 135,425 1075,1335 1335,1455 1455,1560
be low and we want

2628
01:05:40,345 --> 01:05:41,815
0,105 105,210 210,360 360,665 1135,1470
to sort of fast fail

2629
01:05:41,815 --> 01:05:43,300
0,300 300,555 555,840 840,1230 1230,1485
fast. No weight policy. We

2630
01:05:43,300 --> 01:05:44,365
0,260 400,720 720,870 870,960 960,1065
just check, can I do

2631
01:05:44,365 --> 01:05:45,160
0,150 150,405 405,585 585,645 645,795
it? No, okay, let me

2632
01:05:45,160 --> 01:05:46,750
0,405 405,710 1120,1365 1365,1470 1470,1590
retry again because by the

2633
01:05:46,750 --> 01:05:47,695
0,260 310,540 540,690 690,855 855,945
time, you know, when I

2634
01:05:47,695 --> 01:05:49,675
0,120 120,255 255,725 1495,1815 1815,1980
go, go retry then then

2635
01:05:49,675 --> 01:05:50,470
0,135 135,195 195,270 270,515 535,795
I'll be able to do

2636
01:05:50,470 --> 01:05:51,120
0,90 90,180 180,285 285,390 390,650
what I need to do.|
|

2637
01:05:55,240 --> 01:05:56,640
0,275 275,440 440,730 930,1220 1220,1400
His question is why you're
他的问题是你为什么要杀人。那么，您是否必须回滚您所做的任何更改？是的，在代码中。

2638
01:05:56,640 --> 01:05:57,180
0,150 150,345 345,435 435,480 480,540
killing. So do you have

2639
01:05:57,180 --> 01:05:57,855
0,75 75,180 180,300 300,465 465,675
to roll back any changes

2640
01:05:57,855 --> 01:05:59,295
0,165 165,270 270,515 895,1245 1245,1440
that you do? Yes, in

2641
01:05:59,295 --> 01:06:00,520
0,105 105,365
the code.|
|

2642
01:06:00,730 --> 01:06:02,720
0,260 260,520 1020,1310 1310,1595 1595,1990
So again, going back to.|
再说一遍，回到。|

2643
01:06:03,880 --> 01:06:05,060
0,245 245,425 425,665 665,875 875,1180
The writer example here. Like
这里是作者的例子。就像如果。

2644
01:06:05,230 --> 01:06:06,420
0,400
if.|
|

2645
01:06:07,310 --> 01:06:08,995
0,400 810,1130 1130,1325 1325,1475 1475,1685
If this thread that kills
如果这个线程杀死了他们已经更新了一大堆东西，那么你就可以为那些你更新的东西拿着正确的闩锁，这样你就可以回到过去，撤销那些更改。

2646
01:06:08,995 --> 01:06:09,940
0,285 285,495 495,675 675,855 855,945
out they had updated a

2647
01:06:09,940 --> 01:06:10,885
0,90 90,225 225,500 580,840 840,945
bunch of things is where

2648
01:06:10,885 --> 01:06:11,890
0,105 105,255 255,420 420,615 615,1005
you hold the right latches

2649
01:06:11,890 --> 01:06:12,840
0,135 135,255 255,405 405,615 615,950
for those things you updated

2650
01:06:12,950 --> 01:06:13,630
0,245 245,320 320,395 395,500 500,680
so you can go back

2651
01:06:13,630 --> 01:06:15,140
0,210 210,405 405,570 570,830
and reverse those changes.|
|

2652
01:06:19,650 --> 01:06:21,080
0,320 320,500 500,970 1080,1340 1340,1430
It's possible deadlock. Why would
可能会陷入僵局。为什么你会陷入僵局？如果你已经握住了门闩，为什么你会陷入僵局？

2653
01:06:21,080 --> 01:06:21,875
0,75 75,165 165,495 495,705 705,795
you get deadlock? If you

2654
01:06:21,875 --> 01:06:22,685
0,135 135,300 300,435 435,645 645,810
already hold the latch, why

2655
01:06:22,685 --> 01:06:23,920
0,75 75,135 135,225 225,725
would you get deadlocked?|
|

2656
01:06:25,330 --> 01:06:26,690
0,260 260,410 410,700 810,1085 1085,1360
So what scenario is this?|
那么，这是什么情况呢？|

2657
01:06:29,700 --> 01:06:31,320
0,245 245,335 335,545 545,910
Because in this scenario.|
因为在这种情况下。|

2658
01:06:31,600 --> 01:06:32,490
0,195 195,300 300,435 435,600 600,890
He is less than four.|
他还不到四岁。|

2659
01:06:35,440 --> 01:06:37,225
0,225 225,390 390,650 910,1310 1420,1785
There you go across so
在这里，你需要什么，需要什么场景呢？

2660
01:06:37,225 --> 01:06:39,010
0,255 255,435 435,720 720,1505 1525,1785
what and what scenarios do

2661
01:06:39,010 --> 01:06:39,940
0,195 195,530
even need?|
|

2662
01:06:41,460 --> 01:06:42,260
0,230 230,320 320,470 470,635 635,800
So his question is in
所以他的问题是，在什么情况下，您需要在同级中使用向后指针？因为这似乎给我们带来了麻烦，对吧？您的问题是这样的吗？查找键少于四个的查找键大于一。

2663
01:06:42,260 --> 01:06:43,370
0,290 370,630 630,765 765,960 960,1110
what in what scenario do

2664
01:06:43,370 --> 01:06:44,300
0,75 75,195 195,315 315,615 615,930
you need the backwards pointer

2665
01:06:44,300 --> 01:06:45,380
0,120 120,240 240,570 570,855 855,1080
in the sibling? Because because

2666
01:06:45,380 --> 01:06:46,100
0,150 150,300 300,405 405,570 570,720
it seems like it's causing

2667
01:06:46,100 --> 01:06:48,200
0,240 240,390 390,620 880,1280 1840,2100
problems for us, right? Your

2668
01:06:48,200 --> 01:06:49,505
0,150 150,270 270,530 700,1050 1050,1305
query is this right? Find

2669
01:06:49,505 --> 01:06:50,330
0,210 210,330 330,465 465,630 630,825
keys' less than four find

2670
01:06:50,330 --> 01:06:51,040
0,120 120,195 195,315 315,450 450,710
keys is greater than one.|
|

2671
01:06:52,340 --> 01:06:53,370
0,260 260,365 365,545 545,800 800,1030
Because we know everything's ordered.|
因为我们知道每样东西都是有序的。|

2672
01:06:54,060 --> 01:06:54,735
0,150 150,300 300,465 465,585 585,675
In this case, we could
在这种情况下，我们可以从1开始，直到找到。

2673
01:06:54,735 --> 01:06:55,635
0,150 150,330 330,495 495,645 645,900
just start at one and

2674
01:06:55,635 --> 01:06:56,540
0,300 300,435 435,540 540,815
go until we find.|
|

2675
01:06:58,440 --> 01:06:59,540
0,260 260,515 515,770 770,935 935,1100
Same as you could start
就像你可以从一开始直到找到四把一样，我有十亿把钥匙。

2676
01:06:59,540 --> 01:07:00,305
0,135 135,300 300,450 450,615 615,765
at one and go until

2677
01:07:00,305 --> 01:07:05,540
0,120 120,345 345,695 4915,5160 5160,5235
you find four, I have

2678
01:07:05,540 --> 01:07:07,280
0,135 135,435 435,830
a billion keys.|
|

2679
01:07:07,450 --> 01:07:10,520
0,320 320,640 1230,1630 1890,2290
Right, like and I.|
对，就像和我一样。|

2680
01:07:11,410 --> 01:07:12,240
0,275 275,455 455,545 545,695 695,830
Yeah, that's just way more
是啊，那只是贵了很多。是啊，没人会这么做。

2681
01:07:12,240 --> 01:07:13,640
0,165 165,360 360,525 525,800 1000,1400
expensive. Nobody does that, yeah.|
|

2682
01:07:17,680 --> 01:07:19,125
0,320 320,545 545,850 900,1220 1220,1445
Yeah, so, so we didn't
是啊，所以，我们没说跳过名单。在单一商店被称为mem SQL之前，实际上有一个单一的商店。他们有这些跳过列表和跳过列表，只是因为他们是一个，这是一个非常自由的数据结构，这是一个坏主意。这是另一个，另一个话题，但就像他们。

2683
01:07:19,125 --> 01:07:19,935
0,60 60,210 210,405 405,600 600,810
talk about skip list. There

2684
01:07:19,935 --> 01:07:22,755
0,150 150,425 1345,1745 2215,2580 2580,2820
was a actually single store

2685
01:07:22,755 --> 01:07:23,835
0,275 445,675 675,765 765,930 930,1080
before it was single store

2686
01:07:23,835 --> 01:07:25,245
0,105 105,270 270,725 985,1260 1260,1410
was mem sql. They had

2687
01:07:25,245 --> 01:07:26,460
0,195 195,435 435,690 690,990 990,1215
these skip list and skip

2688
01:07:26,460 --> 01:07:27,980
0,165 165,405 405,740 1030,1275 1275,1520
list only have because they

2689
01:07:28,210 --> 01:07:29,190
0,305 305,455 455,710 710,800 800,980
it's a, it's a lot

2690
01:07:29,190 --> 01:07:30,000
0,180 180,345 345,570 570,735 735,810
free data structure, which is

2691
01:07:30,000 --> 01:07:30,945
0,75 75,255 255,465 465,690 690,945
a bad idea. It's another,

2692
01:07:30,945 --> 01:07:32,360
0,300 300,495 495,630 630,875 1015,1415
another topic, but like they.|
|

2693
01:07:33,380 --> 01:07:34,480
0,290 290,515 515,755 755,950 950,1100
They had their skip list
他们的跳过列表只能往一个方向走。所以他们不得不做一系列技巧，比如有办法跳到数据结构中，尝试进行反向操作，然后对其进行排序和反向。你知道，在你把它拿出来之后，它只会让生活变得更难。您可以做到这一点，并避免这种死锁问题。

2694
01:07:34,480 --> 01:07:35,140
0,135 135,270 270,390 390,480 480,660
can only go in one

2695
01:07:35,140 --> 01:07:36,595
0,320 820,1080 1080,1200 1200,1335 1335,1455
direction. So they had to

2696
01:07:36,595 --> 01:07:37,540
0,90 90,165 165,255 255,450 450,945
do a bunch of tricks

2697
01:07:37,540 --> 01:07:38,770
0,255 255,480 480,720 720,975 975,1230
of like having ways to

2698
01:07:38,770 --> 01:07:40,080
0,255 255,555 555,780 780,975 975,1310
jump into the data structure

2699
01:07:40,460 --> 01:07:41,305
0,290 290,425 425,590 590,755 755,845
to, to like try to

2700
01:07:41,305 --> 01:07:42,535
0,165 165,435 435,645 645,905 955,1230
do reverse and then sort

2701
01:07:42,535 --> 01:07:44,245
0,105 105,255 255,575 1135,1500 1500,1710
it and reverse after. You

2702
01:07:44,245 --> 01:07:44,905
0,90 90,240 240,420 420,555 555,660
know, after, after you get

2703
01:07:44,905 --> 01:07:46,045
0,75 75,305 595,855 855,975 975,1140
it out, it just makes

2704
01:07:46,045 --> 01:07:47,650
0,180 180,455 1075,1320 1320,1455 1455,1605
life harder. You can do

2705
01:07:47,650 --> 01:07:50,215
0,260 550,870 870,1430 1960,2235 2235,2565
it and avoids this deadlock

2706
01:07:50,215 --> 01:07:52,440
0,305
issue.|
|

2707
01:07:54,400 --> 01:07:55,820
0,350 350,695 695,920 920,1145 1145,1420
But it's still an example
但如果你在向下遍历，它仍然是一个例子。如果我在下落的时候拿不到门闩，那就不是死锁。我还是想潜在地自杀。

2708
01:07:56,080 --> 01:07:57,675
0,245 245,410 410,815 815,1090 1350,1595
if you're traversing down. If

2709
01:07:57,675 --> 01:07:58,635
0,120 120,360 360,555 555,690 690,960
I can't acquire the latch

2710
01:07:58,635 --> 01:07:59,715
0,255 255,405 405,540 540,825 825,1080
as I'm going down, it's

2711
01:07:59,715 --> 01:08:00,585
0,75 75,165 165,510 510,750 750,870
not a deadlock. I still

2712
01:08:00,585 --> 01:08:01,460
0,75 75,150 150,315 315,555 555,875
want to kill myself potentially.|
|

2713
01:08:02,110 --> 01:08:03,280
0,400
Usually.|
通常是这样的。|

2714
01:08:04,580 --> 01:08:05,770
0,225 225,390 390,600 600,885 885,1190
If it's only going if.|
如果它只是在。|

2715
01:08:06,270 --> 01:08:11,315
0,290 290,580 1980,2380 2820,3220 4710,5045
It still? Yeah. So you
它还在吗？嗯。所以你仍然，如果你按照你提议的去做，你不会有死锁，但你仍然可能会有闩锁争用，我拿不到闩锁，因为其他人拿着它。

2716
01:08:11,315 --> 01:08:12,620
0,315 315,540 540,705 705,795 795,1305
still, you won't have deadlocks

2717
01:08:12,620 --> 01:08:13,535
0,165 165,255 255,345 345,435 435,915
if you do what you're

2718
01:08:13,535 --> 01:08:14,840
0,455 535,825 825,1005 1005,1170 1170,1305
proposing, but you still could

2719
01:08:14,840 --> 01:08:15,785
0,150 150,360 360,690 690,840 840,945
have latch contention where I

2720
01:08:15,785 --> 01:08:17,375
0,195 195,270 270,375 375,665 1285,1590
can't get the latch cause

2721
01:08:17,375 --> 01:08:18,660
0,180 180,330 330,510 510,815
somebody else holds it.|
|

2722
01:08:18,660 --> 01:08:19,650
0,240 240,360 360,525 525,765 765,990
And in that case, again,
在这种情况下，通常情况下，你会想要旋转一小段时间，然后自杀。

2723
01:08:19,650 --> 01:08:20,730
0,290 460,705 705,795 795,915 915,1080
usually you want to spin

2724
01:08:20,730 --> 01:08:21,390
0,120 120,180 180,285 285,480 480,660
for a little bit and

2725
01:08:21,390 --> 01:08:22,680
0,150 150,360 360,680
then kill yourself.|
|

2726
01:08:23,270 --> 01:08:24,055
0,320 320,515 515,635 635,710 710,785
Yeah, you still want to
是啊，你还是想自杀。

2727
01:08:24,055 --> 01:08:25,100
0,150 150,455
kill yourself.|
|

2728
01:08:25,100 --> 01:08:25,715
0,135 135,255 255,390 390,510 510,615
That sounds weird, but you
这听起来很奇怪，但你知道我的意思。

2729
01:08:25,715 --> 01:08:28,160
0,75 75,120 120,165 165,395
know what I mean.|
|

2730
01:08:28,430 --> 01:08:29,580
0,400
Yes.|
是。|

2731
01:08:29,720 --> 01:08:30,395
0,120 120,225 225,405 405,555 555,675
The only issue that we
我们看到的唯一问题是。

2732
01:08:30,395 --> 01:08:31,260
0,135 135,395 415,815
saw with the.|
|

2733
01:08:31,390 --> 01:08:32,100
0,245 245,365 365,485 485,635 635,710
Was that we don't know
那就是我们不知道要多久。

2734
01:08:32,100 --> 01:08:32,480
0,135 135,330
how long.|
|

2735
01:08:33,000 --> 01:08:34,340
0,320 320,590 590,815 815,1090
But like, for example.|
但就像，比如说。|

2736
01:08:38,080 --> 01:08:38,620
0,75 75,195 195,315 315,420 420,540
Would there be, like, a
我们会不会有一个启发式的方法？

2737
01:08:38,620 --> 01:08:39,740
0,435 435,585 585,860
heuristic where we?|
|

2738
01:08:40,290 --> 01:08:41,530
0,245 245,350 350,610 750,995 995,1240
Amount of time and then?|
时间长短，然后呢？|

2739
01:08:41,880 --> 01:08:44,810
0,285 285,590 2290,2535 2535,2685 2685,2930
We still, so he's right.
我们还在，所以他是对的。重复他所说的话，他基本上是说，我们知道我们做了多少工作，我们做了很多更新。我们知道，这样做的成本很高。那么，我们能不能有一个试探法，说我们什么时候可以根据我们做了多少工作来确定我们想要等待多长时间？是的，你可以这么做。

2740
01:08:45,190 --> 01:08:46,230
0,245 245,365 365,640 690,935 935,1040
Repeat what said so he

2741
01:08:46,230 --> 01:08:49,395
0,225 225,590 2290,2690 2860,3090 3090,3165
basically said we know how

2742
01:08:49,395 --> 01:08:51,050
0,105 105,255 255,540 540,785 1255,1655
much work we've done and

2743
01:08:51,820 --> 01:08:52,545
0,260 260,380 380,470 470,560 560,725
we did a lot of

2744
01:08:52,545 --> 01:08:53,790
0,240 240,435 435,695 835,1080 1080,1245
updates. We know they were

2745
01:08:53,790 --> 01:08:56,955
0,255 255,450 450,710 2020,2420 2890,3165
expensive to do. So could

2746
01:08:56,955 --> 01:08:57,825
0,120 120,225 225,345 345,735 735,870
we have a heuristic that

2747
01:08:57,825 --> 01:08:59,370
0,240 240,510 510,815 1135,1380 1380,1545
says when we we could

2748
01:08:59,370 --> 01:09:00,255
0,240 240,450 450,615 615,765 765,885
determine how long we want

2749
01:09:00,255 --> 01:09:01,395
0,105 105,365 655,930 930,1050 1050,1140
to wait based on how

2750
01:09:01,395 --> 01:09:02,715
0,105 105,240 240,435 435,665 955,1320
much work we've done? Yes,

2751
01:09:02,715 --> 01:09:03,800
0,225 225,330 330,420 420,665
you could do that.|
|

2752
01:09:03,800 --> 01:09:06,010
0,350 970,1290 1290,1395 1395,1695 1695,2210
I don't think postgres mysql.|
我不认为Postgres MySQL。|

2753
01:09:06,700 --> 01:09:07,650
0,245 245,350 350,500 500,740 740,950
Actually do that. I might
真的这么做了。我可能是错的，回去做是有益的。

2754
01:09:07,650 --> 01:09:10,995
0,105 105,350 520,1610 2890,3180 3180,3345
be wrong, beneficial going back

2755
01:09:10,995 --> 01:09:11,420
0,150 150,375
and doing.|
|

2756
01:09:15,010 --> 01:09:15,930
0,245 245,320 320,550 630,860 860,920
Would it be? I mean,
会是这样吗？我的意思是，你可以想象，非常简单的启发式方法。

2757
01:09:15,930 --> 01:09:17,025
0,75 75,180 180,440 580,900 900,1095
you can imagine, really simple

2758
01:09:17,025 --> 01:09:18,160
0,515
heuristic.|
|

2759
01:09:18,160 --> 01:09:19,480
0,195 195,500 790,1035 1035,1155 1155,1320
A counter. I have a
一个柜台。我在我的本地地址有一个计数器，我的工人的本地存储器。

2760
01:09:19,480 --> 01:09:21,640
0,210 210,390 390,650 1450,1815 1815,2160
counter in my local address,

2761
01:09:21,640 --> 01:09:22,680
0,285 285,510 510,660 660,765 765,1040
local memory for my worker.|
|

2762
01:09:24,340 --> 01:09:25,515
0,260 260,515 515,830 830,995 995,1175
How many pages have I
我更新了多少页？对于我更新的每个页面。等等，也许是额外的，你知道的，几百微秒左右。简单的试探法。我不知道这样做是否真的有意义。这是对所有案件和数据库的一种逃避。这取决于工作量。这取决于，你知道，如果每个人都在更新一堆东西，那么也许这不是一个好主意。但你有一个线程，一个工作者，它更新了一些事情，是的，这可能是有意义的。

2763
01:09:25,515 --> 01:09:26,940
0,335 745,1020 1020,1125 1125,1260 1260,1425
updated? And for each page

2764
01:09:26,940 --> 01:09:28,575
0,165 165,470 850,1155 1155,1425 1425,1635
I updated. Wait, maybe an

2765
01:09:28,575 --> 01:09:30,890
0,245 445,675 675,905 1105,1500 1500,2315
extra, you know, hundred microseconds

2766
01:09:31,240 --> 01:09:33,525
0,290 290,425 425,670 1530,1820 1820,2285
something like that. Simple heuristics.

2767
01:09:33,525 --> 01:09:34,260
0,240 240,360 360,420 420,555 555,735
I don't know whether it

2768
01:09:34,260 --> 01:09:34,845
0,135 135,240 240,360 360,465 465,585
actually makes sense or not

2769
01:09:34,845 --> 01:09:36,510
0,120 120,210 210,455 1315,1590 1590,1665
to do it. It's a

2770
01:09:36,510 --> 01:09:37,290
0,150 150,345 345,480 480,615 615,780
cop out for all case

2771
01:09:37,290 --> 01:09:38,115
0,105 105,450 450,570 570,720 720,825
and databases. It depends on

2772
01:09:38,115 --> 01:09:39,945
0,90 90,465 465,690 690,965 1585,1830
the workload. Depends on, you

2773
01:09:39,945 --> 01:09:41,730
0,135 135,425 955,1470 1470,1710 1710,1785
know, if everybody's updating a

2774
01:09:41,730 --> 01:09:42,390
0,90 90,210 210,375 375,525 525,660
bunch of stuff, then maybe

2775
01:09:42,390 --> 01:09:43,305
0,210 210,270 270,405 405,690 690,915
that's a bad idea. But

2776
01:09:43,305 --> 01:09:44,670
0,90 90,225 225,480 480,845 985,1365
you have one thread, one

2777
01:09:44,670 --> 01:09:45,750
0,300 300,615 615,870 870,975 975,1080
worker that updates a little

2778
01:09:45,750 --> 01:09:46,785
0,105 105,195 195,440 640,885 885,1035
bit of things that maybe,

2779
01:09:46,785 --> 01:09:47,900
0,210 210,360 360,585 585,840 840,1115
yeah, that might make sense.|
|

2780
01:09:48,710 --> 01:09:49,900
0,245 245,490 540,800 800,1010 1010,1190
But once if I try
但一旦我尝试更新得到的相同密钥，所有东西都会陷入困境，陷入单线程系统。不过，这只是个极端的例子。

2781
01:09:49,900 --> 01:09:50,790
0,120 120,285 285,405 405,570 570,890
to update the same key

2782
01:09:50,870 --> 01:09:52,435
0,320 320,640 810,1055 1055,1190 1190,1565
it gets, everything gets bogged,

2783
01:09:52,435 --> 01:09:53,980
0,330 330,480 480,785 1135,1395 1395,1545
boggled down to a single

2784
01:09:53,980 --> 01:09:55,810
0,225 225,470 1120,1470 1470,1635 1635,1830
threaded system. That's the extreme

2785
01:09:55,810 --> 01:09:56,720
0,165 165,440
case, though.|
|

2786
01:09:56,720 --> 01:09:58,620
0,380
Yes.|
是。|

2787
01:10:06,680 --> 01:10:07,530
0,260 260,335 335,410 410,560 560,850
How do you handle that?|
你是怎么处理的？|

2788
01:10:08,505 --> 01:10:09,945
0,60 60,210 210,360 360,605 1195,1440
They're dead. I mean, they
他们都死了。我是说，他们会重新开始。

2789
01:10:09,945 --> 01:10:10,940
0,395
restart.|
|

2790
01:10:11,170 --> 01:10:12,280
0,400
Yeah.|
嗯。|

2791
01:10:13,130 --> 01:10:15,660
0,290 290,455 455,730 1920,2225 2225,2530
Yeah, so, so very clear.
是的，所以，非常清楚。我用幻灯片来说明这一点。重启机制对用户是透明的。

2792
01:10:16,130 --> 01:10:16,950
0,245 245,335 335,425 425,545 545,820
I say this in slide.

2793
01:10:16,970 --> 01:10:19,230
0,275 275,650 650,940 1110,1510 1530,2260
The restart mechanism is transparent

2794
01:10:19,250 --> 01:10:21,000
0,395 395,665 665,940
to the user.|
|

2795
01:10:21,000 --> 01:10:22,240
0,260
Um.|
恩。|

2796
01:10:22,510 --> 01:10:23,040
0,245 245,305 305,425 425,470 470,530
Yeah, I don't have a
是的，我没有这样的幻灯片。

2797
01:10:23,040 --> 01:10:24,700
0,90 90,210 210,470 640,1040
slides at this like.|
|

2798
01:10:24,700 --> 01:10:25,620
0,195 195,375 375,525 525,630 630,920
Like I run a query
就像我运行一个查询，我必须遍历A，B+树，然后我和，然后去查看主键，当我向下移动时，我得不到闩锁。我不想中止查询并返回给用户。嘿，听着，我买不到门锁因为他们不知道什么是门锁，对吧？然后告诉重新启动。我们为您透明地这样做。就像，像你这样一个查询，它可能会多次重新开始遍历b+树的一个。

2799
01:10:26,300 --> 01:10:27,640
0,400 690,935 935,1025 1025,1130 1130,1340
and I have to traverse

2800
01:10:27,640 --> 01:10:28,300
0,105 105,225 225,390 390,555 555,660
A B plus tree and

2801
01:10:28,300 --> 01:10:29,800
0,195 195,495 495,830 1120,1365 1365,1500
I and, and to go

2802
01:10:29,800 --> 01:10:30,550
0,135 135,210 210,300 300,525 525,750
look at the primary key

2803
01:10:30,550 --> 01:10:31,285
0,105 105,255 255,510 510,600 600,735
and I can't get a

2804
01:10:31,285 --> 01:10:32,280
0,210 210,360 360,555 555,690 690,995
latch as I'm going down.

2805
01:10:32,420 --> 01:10:33,310
0,275 275,470 470,560 560,635 635,890
I don't want to abort

2806
01:10:33,310 --> 01:10:34,045
0,150 150,360 360,525 525,615 615,735
the query and go back

2807
01:10:34,045 --> 01:10:34,975
0,105 105,180 180,405 405,720 720,930
to the user. Hey look,

2808
01:10:34,975 --> 01:10:35,760
0,135 135,315 315,390 390,495 495,785
I couldn't get a latch

2809
01:10:35,840 --> 01:10:36,415
0,230 230,305 305,455 455,500 500,575
because they don't know what

2810
01:10:36,415 --> 01:10:37,870
0,90 90,255 255,545 985,1290 1290,1455
a latch is, right? And

2811
01:10:37,870 --> 01:10:39,505
0,260 430,705 705,825 825,1250 1360,1635
then tell to restart. We

2812
01:10:39,505 --> 01:10:40,630
0,135 135,285 285,840 840,990 990,1125
do this transparently for you.

2813
01:10:40,630 --> 01:10:42,115
0,105 105,350 430,675 675,920 940,1485
So like, so like youit

2814
01:10:42,115 --> 01:10:44,130
0,225 225,575 805,1125 1125,1395 1395,2015
one query it may restart

2815
01:10:44,150 --> 01:10:45,310
0,320 320,575 575,950 950,1085 1085,1160
the the traverse one of

2816
01:10:45,310 --> 01:10:46,680
0,75 75,210 210,405 405,710 970,1370
the b plus tree multiple

2817
01:10:46,700 --> 01:10:47,840
0,400
times.|
|

2818
01:10:47,840 --> 01:10:48,650
0,195 195,330 330,435 435,660 660,810
And, but you don't see
但是从应用程序的最终用户那里看不到这一点。我们是在内部进行的，只是查询速度变慢了一点。

2819
01:10:48,650 --> 01:10:49,250
0,135 135,255 255,345 345,450 450,600
that from the end user

2820
01:10:49,250 --> 01:10:50,120
0,120 120,255 255,510 510,750 750,870
of the application. We're doing

2821
01:10:50,120 --> 01:10:51,200
0,195 195,615 615,855 855,945 945,1080
it internally, it's just the

2822
01:10:51,200 --> 01:10:51,800
0,180 180,315 315,390 390,465 465,600
query got a little bit

2823
01:10:51,800 --> 01:10:53,220
0,315 315,555 555,645 645,890
slower because of that.|
|

2824
01:10:56,700 --> 01:10:57,590
0,225 225,315 315,405 405,570 570,890
A lot of questions, sorry.|
很多问题，抱歉。|

2825
01:11:00,490 --> 01:11:01,815
0,400 450,725 725,860 860,1070 1070,1325
Yes. Is there an instance
是。有没有这样的例子？

2826
01:11:01,815 --> 01:11:02,640
0,305
where?|
|

2827
01:11:08,140 --> 01:11:09,330
0,305 305,590 590,800 800,965 965,1190
Yeah, absolutely. So the question
是啊，当然了。所以问题是，有没有这样一种情况，某人在根上有一个正确的闩锁，如果你重新启动，你会回来。

2828
01:11:09,330 --> 01:11:10,425
0,290 370,645 645,750 750,840 840,1095
is, is there a scenario

2829
01:11:10,425 --> 01:11:11,430
0,330 330,570 570,750 750,870 870,1005
where someone has a right

2830
01:11:11,430 --> 01:11:12,440
0,210 210,345 345,450 450,660 660,1010
latch on the root and

2831
01:11:12,640 --> 01:11:13,575
0,275 275,410 410,755 755,905 905,935
if you restart you're going

2832
01:11:13,575 --> 01:11:14,960
0,60 60,150 150,270 270,545
to come back and.|
|

2833
01:11:15,510 --> 01:11:16,680
0,275 275,550
Absolutely, yes.|
当然，是的。|

2834
01:11:16,875 --> 01:11:18,000
0,60 60,635
It's unavoidable.|
这是不可避免的。|

2835
01:11:20,660 --> 01:11:22,025
0,240 240,500 820,1065 1065,1200 1200,1365
I mean, the more keys
我的意思是，你插入的关键点越多，树就越高。

2836
01:11:22,025 --> 01:11:23,750
0,120 120,480 480,875 1255,1530 1530,1725
you insert, the tree gets

2837
01:11:23,750 --> 01:11:25,840
0,530
taller.|
|

2838
01:11:26,360 --> 01:11:29,590
0,350 350,575 575,850 1590,1990 2700,3230
And therefore, the, the likelihood
因此，有人用右手锁住根部的可能性下降了，对吗？

2839
01:11:29,590 --> 01:11:30,235
0,135 135,375 375,420 420,480 480,645
that someone's going to hold

2840
01:11:30,235 --> 01:11:30,940
0,195 195,330 330,495 495,600 600,705
a right latch on the

2841
01:11:30,940 --> 01:11:33,060
0,260 460,750 750,1040 1210,1610
root goes down right?|
|

2842
01:11:33,240 --> 01:11:34,480
0,400
EM.|
嗯。|

2843
01:11:38,410 --> 01:11:40,050
0,305 305,485 485,760 1050,1370 1370,1640
Going back to the stall
我也要回到货摊上。

2844
01:11:40,050 --> 01:11:41,940
0,270 270,590
stuff, too.|
|

2845
01:11:42,030 --> 01:11:42,930
0,120 120,330 330,555 555,705 705,900
It's not just how much
重要的不仅仅是另一个线程做了多少工作。

2846
01:11:42,930 --> 01:11:45,380
0,350 1240,1500 1500,1755 1755,2100 2100,2450
work the other thread doing

2847
01:11:45,850 --> 01:11:47,740
0,400
like.|
|

2848
01:11:49,250 --> 01:11:50,080
0,305 305,455 455,545 545,695 695,830
Like you have to sort
就像您必须等待记住这些一样，这些数据结构由位于磁盘上的缓冲池中的页面支持。因此，即使我正在更新一个密钥，我需要更新的密钥可能不在内存中，我必须从磁盘中取出它。

2849
01:11:50,080 --> 01:11:52,170
0,75 75,225 225,530 1090,1490 1690,2090
of wait for remember these,

2850
01:11:52,340 --> 01:11:53,650
0,290 290,515 515,785 785,1010 1010,1310
these data structures are backed

2851
01:11:53,650 --> 01:11:55,555
0,210 210,560 1150,1425 1425,1575 1575,1905
by pages in the buffer

2852
01:11:55,555 --> 01:11:56,635
0,275 565,795 795,870 870,960 960,1080
pool that are on a

2853
01:11:56,635 --> 01:11:58,555
0,545 1015,1275 1275,1455 1455,1665 1665,1920
disk. So even though I'm

2854
01:11:58,555 --> 01:12:00,220
0,270 270,495 495,845 1195,1500 1500,1665
updating one key, the key

2855
01:12:00,220 --> 01:12:01,255
0,120 120,240 240,435 435,750 750,1035
I need to update might

2856
01:12:01,255 --> 01:12:02,500
0,305 355,630 630,795 795,1050 1050,1245
be not in memory and

2857
01:12:02,500 --> 01:12:03,070
0,90 90,225 225,345 345,450 450,570
I gotta go out the

2858
01:12:03,070 --> 01:12:04,400
0,210 210,315 315,480 480,770
disk and get it.|
|

2859
01:12:05,130 --> 01:12:06,155
0,245 245,485 485,710 710,935 935,1025
So that's why. And you
这就是为什么。你不会想拖后腿的。你不会想要永远旋转很长一段时间，因为你不知道，就像，你知道，它必须得到一个磁盘。

2860
01:12:06,155 --> 01:12:06,935
0,165 165,225 225,345 345,600 600,780
don't want to stall. You

2861
01:12:06,935 --> 01:12:07,790
0,120 120,150 150,270 270,525 525,855
don't want to spin forever

2862
01:12:07,790 --> 01:12:08,690
0,210 210,285 285,435 435,675 675,900
for a long time because

2863
01:12:08,690 --> 01:12:09,800
0,165 165,420 420,585 585,885 885,1110
you don't know, like, you

2864
01:12:09,800 --> 01:12:10,370
0,90 90,240 240,375 375,465 465,570
know, it has to go

2865
01:12:10,370 --> 01:12:11,660
0,120 120,255 255,770
get a disk.|
|

2866
01:12:11,660 --> 01:12:12,500
0,240 240,330 330,435 435,615 615,840
It's just a really slow
这只是一个非常慢的磁盘，这将是一个很长的时间，你可以等待100毫秒。

2867
01:12:12,500 --> 01:12:13,070
0,285 285,360 360,495 495,525 525,570
disk and that's going to

2868
01:12:13,070 --> 01:12:14,705
0,230 310,570 570,765 765,1100 1390,1635
be a long time and

2869
01:12:14,705 --> 01:12:15,490
0,90 90,165 165,255 255,450 450,785
you can be waiting for

2870
01:12:16,140 --> 01:12:17,800
0,380 380,1030
100 milliseconds.|
|

2871
01:12:18,500 --> 01:12:20,120
0,395 395,970
500 milliseconds.|
500毫秒。|

2872
01:12:20,320 --> 01:12:21,105
0,230 230,305 305,455 455,620 620,785
So he said, oh, yeah,
所以他说，哦，对了，平均时间是多少？我的意思是，这取决于太多不可能吸引这些东西的因素。

2873
01:12:21,105 --> 01:12:22,275
0,255 255,435 435,600 600,935 955,1170
do the average time? I

2874
01:12:22,275 --> 01:12:22,920
0,45 45,195 195,390 390,540 540,645
mean, it depends on so

2875
01:12:22,920 --> 01:12:23,790
0,180 180,495 495,675 675,720 720,870
many factors that would be

2876
01:12:23,790 --> 01:12:24,830
0,240 240,435 435,600 600,765 765,1040
impossible to attract these things.|
|

2877
01:12:27,730 --> 01:12:28,590
0,275 275,410 410,575 575,740 740,860
Again, this is, again, this
再一次，这也是，这就是为什么它不同于常规的数据结构算法类，因为这些东西是由磁盘支持的。

2878
01:12:28,590 --> 01:12:29,370
0,120 120,270 270,420 420,555 555,780
is why this is different

2879
01:12:29,370 --> 01:12:30,780
0,350 430,735 735,870 870,1100 1120,1410
than taking a regular data

2880
01:12:30,780 --> 01:12:32,220
0,195 195,555 555,765 765,1100 1150,1440
structure algorithalms classes, because these

2881
01:12:32,220 --> 01:12:33,380
0,165 165,300 300,495 495,630 630,1160
things are backed by disk.|
|

2882
01:12:34,780 --> 01:12:35,650
0,240 240,375 375,480 480,675 675,870
And we're having multiple threads
我们有多个线程同时运行，我们需要做一系列的事情来隐藏它，这些蒸馏器。

2883
01:12:35,650 --> 01:12:36,280
0,75 75,150 150,225 225,360 360,630
running at the same time,

2884
01:12:36,280 --> 01:12:37,555
0,380 670,975 975,1050 1050,1170 1170,1275
and there's a bunch of

2885
01:12:37,555 --> 01:12:38,280
0,120 120,240 240,345 345,465 465,725
things we need to do

2886
01:12:38,930 --> 01:12:40,740
0,290 290,545 545,890 890,1175 1175,1810
to hide that, those distills.|
|

2887
01:12:43,530 --> 01:12:44,585
0,410 410,575 575,725 725,860 860,1055
Sql server, a whole other
SQL服务器，一个完全不同的野兽SQL服务器。

2888
01:12:44,585 --> 01:12:46,880
0,255 255,585 585,845
beast sql server.|
|

2889
01:12:47,500 --> 01:12:48,630
0,335 335,575 575,800 800,995 995,1130
They have, they actually have
他们有，他们实际上有他们自己的用户空间代码例程，所以如果你在遍历数据结构。

2890
01:12:48,630 --> 01:12:49,650
0,120 120,270 270,510 510,810 810,1020
their own user space code

2891
01:12:49,650 --> 01:12:51,735
0,380 970,1230 1230,1490 1540,1860 1860,2085
routines, so like if you're

2892
01:12:51,735 --> 01:12:53,720
0,495 495,675 675,870 870,1205
traversing the data structure.|
|

2893
01:12:55,010 --> 01:12:56,140
0,350 350,590 590,755 755,920 920,1130
And the thing I need,
而我需要的是，我拿不到门闩。他们不只是旋转，而是回到他们自己的用户空间时间表，并说，我不能，我不能跑，因为我在等待这个闩锁。

2894
01:12:56,140 --> 01:12:57,060
0,210 210,405 405,480 480,615 615,920
I can't get the latch.

2895
01:12:57,890 --> 01:12:59,575
0,245 245,335 335,580 630,1180 1410,1685
Instead of just spinning, they

2896
01:12:59,575 --> 01:13:00,445
0,165 165,390 390,570 570,675 675,870
go back to their own

2897
01:13:00,445 --> 01:13:01,645
0,300 300,585 585,825 825,1005 1005,1200
user space schedule and says,

2898
01:13:01,645 --> 01:13:02,875
0,270 270,600 600,795 795,1035 1035,1230
I can't, I can't run

2899
01:13:02,875 --> 01:13:03,550
0,180 180,300 300,405 405,540 540,675
because I'm waiting for this

2900
01:13:03,550 --> 01:13:04,620
0,320
latch.|
|

2901
01:13:04,620 --> 01:13:06,165
0,350 820,1095 1095,1245 1245,1380 1380,1545
And then they take your
然后他们拿走你的线程，让它做一些其他的工作，然后他们可能知道什么锁存器在等待。他们实际上在做一些跟踪，谁在等待里面锁住了什么。

2902
01:13:06,165 --> 01:13:06,990
0,210 210,435 435,630 630,750 750,825
thread away and have it

2903
01:13:06,990 --> 01:13:07,860
0,105 105,210 210,345 345,630 630,870
do some other work, and

2904
01:13:07,860 --> 01:13:08,745
0,120 120,270 270,465 465,690 690,885
then they may know what

2905
01:13:08,745 --> 01:13:09,990
0,315 315,465 465,750 750,1080 1080,1245
latcher waiting for. They're actually

2906
01:13:09,990 --> 01:13:11,790
0,240 240,495 495,800 1360,1680 1680,1800
doing some tracking, who's waiting

2907
01:13:11,790 --> 01:13:13,155
0,135 135,255 255,710 1000,1260 1260,1365
for what latches inside of

2908
01:13:13,155 --> 01:13:13,860
0,245
it.|
|

2909
01:13:14,180 --> 01:13:15,085
0,335 335,530 530,650 650,785 785,905
And they can do that
他们能够做到这一点，因为用户空间中的一切都是代码例程。

2910
01:13:15,085 --> 01:13:16,150
0,165 165,450 450,690 690,825 825,1065
because everything is code routines

2911
01:13:16,150 --> 01:13:17,380
0,120 120,300 300,620
in user space.|
|

2912
01:13:17,380 --> 01:13:18,580
0,290
Um.|
恩。|

2913
01:13:18,750 --> 01:13:20,045
0,305 305,610 630,935 935,1130 1130,1295
Very few, nobody else does.
很少有人，其他人都不知道。该SQL服务器做了一些非常酷的事情。

2914
01:13:20,045 --> 01:13:21,545
0,275 775,1110 1110,1215 1215,1320 1320,1500
That sql server does some

2915
01:13:21,545 --> 01:13:22,840
0,225 225,375 375,635
really cool things.|
|

2916
01:13:24,130 --> 01:13:25,155
0,260 260,410 410,680 680,920 920,1025
All right, cool. Any other
好的，太酷了。还有其他问题吗？

2917
01:13:25,155 --> 01:13:26,260
0,245
questions?|
|

2918
01:13:27,050 --> 01:13:28,160
0,400
Yes.|
是。|

2919
01:13:29,440 --> 01:13:30,385
0,195 195,360 360,570 570,750 750,945
Is there like, still more
是不是还有更多的反思？所以我只是有一个非常基本的问题，如果有两个线程在不同的方向上的整个设置。

2920
01:13:30,385 --> 01:13:35,440
0,335 4555,4785 4785,4860 4860,4950 4950,5055
reflection? So I just had

2921
01:13:35,440 --> 01:13:36,955
0,180 180,495 495,885 885,1260 1260,1515
a pretty basic question about

2922
01:13:36,955 --> 01:13:38,965
0,135 135,315 315,635 1375,1695 1695,2010
the whole setting if there's

2923
01:13:38,965 --> 01:13:39,850
0,165 165,435 435,555 555,690 690,885
two threads going in different

2924
01:13:39,850 --> 01:13:40,420
0,320
directions.|
|

2925
01:13:42,710 --> 01:13:43,820
0,400 480,785 785,950 950,1070
L on the book.|
L就在书上。|

2926
01:13:45,700 --> 01:13:46,830
0,255 255,465 465,660 660,855 855,1130
And so you acquire the.|
所以你获得了。|

2927
01:13:47,320 --> 01:13:48,195
0,290 290,410 410,500 500,680 680,875
Yeah. So his question is,
嗯。所以他的问题是，让我回到这里。问题是我是不是。

2928
01:13:48,195 --> 01:13:48,720
0,105 105,180 180,255 255,345 345,525
let me go back here.

2929
01:13:48,720 --> 01:13:50,740
0,225 225,510 510,795 795,1370
Question is if I'm.|
|

2930
01:13:50,910 --> 01:13:52,300
0,455 455,590 590,740 740,980 980,1390
Traversing along with sibling nodes.|
与兄弟节点一起遍历。|

2931
01:13:53,830 --> 01:13:55,640
0,400
Uh.|
呃。|

2932
01:13:56,690 --> 01:13:58,300
0,260 260,380 380,545 545,850
This one here, right?|
这张是这里的，对吗？|

2933
01:13:59,800 --> 01:14:00,340
0,90 90,195 195,315 315,405 405,540
If they're trying to get
如果他们想要穿越过去。

2934
01:14:00,340 --> 01:14:01,500
0,290
across.|
|

2935
01:14:01,630 --> 01:14:03,630
0,335 335,670 690,1090 1530,1835 1835,2000
Why does so t two
为什么这样测试，是因为c不需要，保持b上的闩锁，才能得到。

2936
01:14:03,630 --> 01:14:05,145
0,120 120,380 1030,1305 1305,1425 1425,1515
is that t one is

2937
01:14:05,145 --> 01:14:07,800
0,180 180,515 1135,1515 1515,1895 2305,2655
that c does t two

2938
01:14:07,800 --> 01:14:09,180
0,210 210,330 330,495 495,800 1060,1380
need to hold the latch

2939
01:14:09,180 --> 01:14:10,290
0,195 195,500 700,945 945,1035 1035,1110
on b in order to

2940
01:14:10,290 --> 01:14:11,580
0,120 120,330 330,650
get to c.|
|

2941
01:14:11,590 --> 01:14:12,735
0,400 540,785 785,905 905,1025 1025,1145
Because you need to know
因为你需要知道兄弟指针仍然有效，那么这就是正确的，正确的节点，这就是你要寻找的正确节点，对吗？你知道，如果有更新，因为你把它保持在读模式，没有人可以更新它。所以你知道，没有人会用一些，你知道的，一些其他新版本的东西来代替b。它们现在指向其他东西，但您仍然要沿着指针指向您以前认为在那里的任何东西。

2942
01:14:12,735 --> 01:14:13,635
0,135 135,270 270,570 570,795 795,900
that the sibling pointer is

2943
01:14:13,635 --> 01:14:14,670
0,180 180,450 450,705 705,870 870,1035
still valid, then this is

2944
01:14:14,670 --> 01:14:15,950
0,150 150,410 430,690 690,840 840,1280
the right, the right node,

2945
01:14:16,210 --> 01:14:17,115
0,380 380,635 635,740 740,800 800,905
that this is the right

2946
01:14:17,115 --> 01:14:17,990
0,165 165,300 300,375 375,555 555,875
node you'd be looking to,

2947
01:14:18,190 --> 01:14:19,650
0,400 570,830 830,980 980,1220 1220,1460
right? And you know that

2948
01:14:19,650 --> 01:14:20,580
0,150 150,270 270,375 375,600 600,930
if there was an update,

2949
01:14:20,580 --> 01:14:21,555
0,225 225,345 345,480 480,735 735,975
because you hold this in

2950
01:14:21,555 --> 01:14:22,725
0,165 165,375 375,660 660,960 960,1170
read mode, nobody can update

2951
01:14:22,725 --> 01:14:23,685
0,275 325,555 555,645 645,795 795,960
it. So you know that

2952
01:14:23,685 --> 01:14:25,575
0,135 135,315 315,545 775,1175 1555,1890
no one's gonna replace b

2953
01:14:25,575 --> 01:14:27,180
0,195 195,455 985,1260 1260,1455 1455,1605
with something with some, you

2954
01:14:27,180 --> 01:14:27,960
0,105 105,240 240,405 405,585 585,780
know, some other new version

2955
01:14:27,960 --> 01:14:28,635
0,165 165,255 255,360 360,510 510,675
of it. They now point

2956
01:14:28,635 --> 01:14:30,090
0,135 135,315 315,635 955,1275 1275,1455
to something else and but

2957
01:14:30,090 --> 01:14:31,080
0,210 210,345 345,495 495,750 750,990
you're still gonna follow the

2958
01:14:31,080 --> 01:14:32,880
0,300 300,590 1210,1515 1515,1680 1680,1800
pointer to whatever you thought

2959
01:14:32,880 --> 01:14:33,980
0,120 120,240 240,500
was there before.|
|

2960
01:14:33,980 --> 01:14:34,955
0,320 490,720 720,795 795,885 885,975
Right. So you have to
正确的。所以你必须握住门闩，直到你知道你在另一边是安全的。然后你就可以继续释放它了。

2961
01:14:34,955 --> 01:14:35,930
0,135 135,285 285,675 675,855 855,975
hold the latches until you

2962
01:14:35,930 --> 01:14:36,680
0,135 135,375 375,540 540,675 675,750
know you're safe on the

2963
01:14:36,680 --> 01:14:37,895
0,165 165,500 760,1035 1035,1140 1140,1215
other side. Then you can

2964
01:14:37,895 --> 01:14:38,590
0,90 90,165 165,270 270,420 420,695
go ahead and release it.|
|

2965
01:14:39,420 --> 01:14:41,015
0,290 290,545 545,1000 1140,1430 1430,1595
Same thing, it's going from
同样的，它是自上而下的。你需要知道，就像我接下来要跳到的东西是我应该跳到的。

2966
01:14:41,015 --> 01:14:41,885
0,165 165,405 405,615 615,735 735,870
top down. You need to

2967
01:14:41,885 --> 01:14:42,665
0,195 195,360 360,480 480,630 630,780
know that, like the thing

2968
01:14:42,665 --> 01:14:43,780
0,180 180,360 360,570 570,780 780,1115
I'm jumping to next is

2969
01:14:43,830 --> 01:14:44,495
0,245 245,350 350,440 440,515 515,665
what I should be jumping

2970
01:14:44,495 --> 01:14:45,500
0,305
into.|
|

2971
01:14:48,000 --> 01:14:49,100
0,400
Yes.|
是。|

2972
01:14:50,150 --> 01:14:51,460
0,400 750,1055 1055,1280
Essentially to their.|
基本上是对他们的。|

2973
01:14:52,920 --> 01:14:53,980
0,240 240,530 700,1020
This is the.|
这就是。|

2974
01:15:01,250 --> 01:15:02,360
0,400
Yes.|
是。|

2975
01:15:02,360 --> 01:15:03,700
0,150 150,270 270,450 450,975 975,1340
How do you distinguish that?|
你怎么区分这一点呢？|

2976
01:15:08,290 --> 01:15:09,150
0,275 275,440 440,575 575,710 710,860
You want to go to
你想往右走。

2977
01:15:09,150 --> 01:15:10,000
0,105 105,350
the right.|
|

2978
01:15:11,870 --> 01:15:12,740
0,365 365,730
Log on.|
登录。|

2979
01:15:16,390 --> 01:15:17,370
0,275 275,425 425,605 605,770 770,980
This is not the case
这不是我们的情况。

2980
01:15:17,370 --> 01:15:18,240
0,300 300,650
where we.|
|

2981
01:15:19,140 --> 01:15:20,330
0,210 210,345 345,555 555,855 855,1190
Going in the opposite direction.|
往相反的方向走。|

2982
01:15:22,090 --> 01:15:23,070
0,245 245,365 365,530 530,770 770,980
There are two cases. How
有两个案例。你如何区分它们？

2983
01:15:23,070 --> 01:15:24,150
0,75 75,210 210,645 645,900 900,1080
do you distinguish between them?|
|

2984
01:15:24,300 --> 01:15:26,210
0,395 395,710 710,1030 1290,1670 1670,1910
Yeah, so, so question save.
是的，所以，那就省省吧。这是一个类似的问题。

2985
01:15:26,210 --> 01:15:27,875
0,90 90,320 610,855 855,1100 1360,1665
It is a question that

2986
01:15:27,875 --> 01:15:28,820
0,305
like.|
|

2987
01:15:28,990 --> 01:15:30,345
0,365 365,635 635,905 905,1175 1175,1355
Last time, I talked about
上一次，我谈到了像postgres这样的系统如何在内部节点上有兄弟指针，尽管我在这里只显示了叶节点，如果我使用这些内部节点的兄弟指针来跳转。

2988
01:15:30,345 --> 01:15:32,385
0,275 685,1005 1005,1200 1200,1665 1665,2040
how systems like postgres have

2989
01:15:32,385 --> 01:15:34,220
0,420 420,780 780,1035 1035,1275 1275,1835
sibling pointers at inner nodes,

2990
01:15:34,450 --> 01:15:35,450
0,275 275,410 410,575 575,710 710,1000
even though I'm only showing

2991
01:15:36,010 --> 01:15:37,755
0,290 290,530 530,790 1110,1490 1490,1745
leaf nodes here, and if

2992
01:15:37,755 --> 01:15:38,895
0,195 195,450 450,690 690,900 900,1140
I use those inner node

2993
01:15:38,895 --> 01:15:40,380
0,270 270,585 585,750 750,1025
sibling pointers to jump.|
|

2994
01:15:40,380 --> 01:15:42,735
0,150 150,920 1900,2160 2160,2250 2250,2355
Again, horizontally. How do I
再一次，水平地。我怎么才能锁上这些东西，并确保一切正常呢？所以协议，我在这里描述的一切，仍然有效。

2995
01:15:42,735 --> 01:15:43,725
0,150 150,450 450,570 570,795 795,990
take latches on those and

2996
01:15:43,725 --> 01:15:44,550
0,120 120,300 300,480 480,630 630,825
make sure things are still

2997
01:15:44,550 --> 01:15:46,470
0,320 700,945 945,1050 1050,1520 1690,1920
correct? So the protocol, everything

2998
01:15:46,470 --> 01:15:47,385
0,150 150,345 345,495 495,690 690,915
I'm describing here, would still

2999
01:15:47,385 --> 01:15:49,380
0,335
work.|
|

3000
01:15:49,480 --> 01:15:50,700
0,400
If.|
如果。|

3001
01:15:51,530 --> 01:15:52,720
0,290 290,620 620,815 815,1025 1025,1190
For reads it simple, could
为了简单起见，你能把锁扣拿过去吗？

3002
01:15:52,720 --> 01:15:53,380
0,75 75,210 210,375 375,510 510,660
you just take the rel

3003
01:15:53,380 --> 01:15:55,640
0,320 370,770
latch across?|
|

3004
01:15:56,920 --> 01:15:58,530
0,335 335,575 575,845 845,1210 1350,1610
Because anybody else coming above
因为任何高于你的人，一旦你是对的，他们就会看到你的重复，他们会阻止下面的任何东西，在正在进行更新的那棵树的那一边下面。你会被挡住，你把读数记下来。因此，这对于进行更新是很好的。我认为它的工作方式和你遇到的一样。

3005
01:15:58,530 --> 01:15:59,270
0,105 105,240 240,360 360,465 465,740
you, once you are right,

3006
01:15:59,470 --> 01:16:00,705
0,335 335,425 425,530 530,970 990,1235
they'll see your relatch and

3007
01:16:00,705 --> 01:16:02,715
0,210 210,485 925,1185 1185,1445 1645,2010
they'll stop anything below, below

3008
01:16:02,715 --> 01:16:03,770
0,315 315,525 525,615 615,750 750,1055
that side of the tree

3009
01:16:03,910 --> 01:16:04,815
0,260 260,380 380,500 500,665 665,905
that was doing an update.

3010
01:16:04,815 --> 01:16:05,775
0,270 270,420 420,645 645,825 825,960
You'll get blocked, you take

3011
01:16:05,775 --> 01:16:06,830
0,270 270,525 525,645 645,780 780,1055
the take the read down.

3012
01:16:07,030 --> 01:16:08,660
0,245 245,470 470,730 1050,1340 1340,1630
So that's fine for doing

3013
01:16:08,770 --> 01:16:09,795
0,335 335,560 560,710 710,845 845,1025
updates. I think it works

3014
01:16:09,795 --> 01:16:10,815
0,180 180,375 375,645 645,870 870,1020
the same way as you

3015
01:16:10,815 --> 01:16:13,340
0,255 255,635
come across.|
|

3016
01:16:13,340 --> 01:16:14,315
0,260 340,600 600,765 765,855 855,975
If what you're trying to
如果你在下面尝试做的事情不安全，那么你仍然可以拿着那些东西的闩锁。该协议仍然有效，即使你必须水平穿过并下降。

3017
01:16:14,315 --> 01:16:16,330
0,165 165,455 1015,1335 1335,1635 1635,2015
do below is not safe,

3018
01:16:16,830 --> 01:16:17,930
0,260 260,410 410,575 575,740 740,1100
then you still hold latches

3019
01:16:17,930 --> 01:16:19,205
0,105 105,255 255,560 610,870 870,1275
for those things. The protocol

3020
01:16:19,205 --> 01:16:20,030
0,180 180,390 390,600 600,735 735,825
still works, even if you

3021
01:16:20,030 --> 01:16:21,290
0,90 90,315 315,555 555,705 705,1260
have to go across horizontally

3022
01:16:21,290 --> 01:16:22,340
0,195 195,300 300,560
and go down.|
|

3023
01:16:23,530 --> 01:16:24,740
0,290 290,455 455,620 620,770 770,1210
You still have the deadlock
如果每个人都试图垂直攻击你或也攻击你，然后你做了我在这里描述的同样的事情，你仍然会陷入僵局。

3024
01:16:24,820 --> 01:16:25,890
0,335 335,710 710,875 875,950 950,1070
if everyone's trying to go

3025
01:16:25,890 --> 01:16:26,835
0,210 210,540 540,630 630,765 765,945
across vertically on you or

3026
01:16:26,835 --> 01:16:27,830
0,210 210,405 405,555 555,705 705,995
horiz on on you too,

3027
01:16:27,880 --> 01:16:28,575
0,245 245,350 350,455 455,575 575,695
and then you do the

3028
01:16:28,575 --> 01:16:29,480
0,120 120,225 225,405 405,660 660,905
same thing I'm describing here.|
|

3029
01:16:31,000 --> 01:16:32,640
0,305 305,440 440,650 650,970
There's another question. Sorry.|
还有一个问题。抱歉的。|

3030
01:16:34,780 --> 01:16:36,980
0,305 305,610
Okay, cool.|
好的，酷。|

3031
01:16:38,410 --> 01:16:40,120
0,400 420,665 665,910
So, all right.|
所以，好吧。|

3032
01:16:40,380 --> 01:16:42,600
0,260 260,365 365,500 500,790
Just to finish up.|
只是为了做个了结。|

3033
01:16:42,980 --> 01:16:45,280
0,245 245,350 350,610 1890,2135 2135,2300
This is hard and I'm
这很难，我向你展示的是最简单的版本，闩锁和那种保护。

3034
01:16:45,280 --> 01:16:46,315
0,135 135,285 285,560 610,855 855,1035
showing you like the most

3035
01:16:46,315 --> 01:16:47,530
0,360 360,570 570,750 750,945 945,1215
simplest version to do, latch

3036
01:16:47,530 --> 01:16:51,360
0,470 730,1130 1600,1950 1950,2300
crapping and that protection.|
|

3037
01:16:51,540 --> 01:16:52,840
0,580
There.|
那里。|

3038
01:16:53,300 --> 01:16:53,875
0,305 305,365 365,425 425,470 470,575
We're not going to cover
我们不会在这节课中讨论这一点，但还有更复杂的方案。你可以拿到处女锁，是吗？您可以延迟更新。你可以做bpsilon树的事情，在那里你延迟事情。你还可以做很多其他的事情。BW树是非常免费的。微软的B B PLUS TREE。这真是一场噩梦。

3039
01:16:53,875 --> 01:16:54,565
0,120 120,210 210,315 315,450 450,690
this in this class, but

3040
01:16:54,565 --> 01:16:56,245
0,455 595,870 870,1005 1005,1265 1315,1680
there's way more complicated schemes.

3041
01:16:56,245 --> 01:16:57,360
0,90 90,180 180,300 300,540 540,1115
You can have virgin latches,

3042
01:16:57,800 --> 01:17:00,550
0,400 570,815 815,935 935,1210 2400,2750
eh? You can have delayed

3043
01:17:00,550 --> 01:17:01,840
0,350 640,885 885,990 990,1125 1125,1290
updates. You can do the

3044
01:17:01,840 --> 01:17:02,890
0,450 450,630 630,810 810,930 930,1050
bpsilon tree stuff where you

3045
01:17:02,890 --> 01:17:04,120
0,165 165,440 760,1065 1065,1125 1125,1230
delay things. There's a bunch

3046
01:17:04,120 --> 01:17:04,690
0,75 75,195 195,375 375,480 480,570
of other stuff you can

3047
01:17:04,690 --> 01:17:06,910
0,135 135,410 1720,1965 1965,2055 2055,2220
do this. The B W

3048
01:17:06,910 --> 01:17:07,885
0,180 180,285 285,405 405,645 645,975
tree is a lot free.

3049
01:17:07,885 --> 01:17:08,950
0,300 300,525 525,720 720,915 915,1065
B B plus tree from

3050
01:17:08,950 --> 01:17:10,800
0,260 820,1125 1125,1170 1170,1350 1350,1850
Microsoft. That's a whole nightmare.|
|

3051
01:17:13,040 --> 01:17:14,110
0,275 275,410 410,560 560,845 845,1070
Again, this is hard, but
再说一次，这很难，但这很好，因为这就像你上这门课，这就是为什么，你知道，你不想让你的，你的随机的脚本程序员在你的数据库系统中构建你的，你的，你的数据结构。你们不希望看到像你们这样的学生知道他们在做什么，并确保他们不会造成问题。所以我们再谈一次哈希表。今天我们来谈谈B，B+。但是这种想法的技巧，就像一切都朝着同一个方向发展，或者我一拿不到东西就自杀，然后像这样重新启动，这与嗯.

3052
01:17:14,110 --> 01:17:14,965
0,75 75,210 210,465 465,705 705,855
this is good because this

3053
01:17:14,965 --> 01:17:16,345
0,275 295,695 865,1110 1110,1230 1230,1380
is like you take this

3054
01:17:16,345 --> 01:17:17,550
0,225 225,555 555,795 795,930 930,1205
class and this is why,

3055
01:17:17,900 --> 01:17:18,745
0,245 245,395 395,545 545,725 725,845
you know, you don't want

3056
01:17:18,745 --> 01:17:20,370
0,255 255,495 495,675 675,1080 1080,1625
your, your random javascript programmer

3057
01:17:20,600 --> 01:17:22,300
0,320 320,560 560,880 1140,1580 1580,1700
building your, your flrated, your

3058
01:17:22,300 --> 01:17:23,245
0,165 165,435 435,645 645,750 750,945
data structures in your database

3059
01:17:23,245 --> 01:17:24,985
0,335 655,1055 1135,1485 1485,1605 1605,1740
systems. You wantt see you

3060
01:17:24,985 --> 01:17:26,140
0,150 150,285 285,405 405,665 895,1155
students like you guys that

3061
01:17:26,140 --> 01:17:26,650
0,120 120,210 210,270 270,360 360,510
know what the hell they're

3062
01:17:26,650 --> 01:17:27,895
0,230 280,660 660,915 915,1035 1035,1245
doing and make sure that

3063
01:17:27,895 --> 01:17:30,160
0,225 225,390 390,525 525,815 2005,2265
they don't cause problems. And

3064
01:17:30,160 --> 01:17:31,450
0,260 610,915 915,1080 1080,1185 1185,1290
so again we talk about

3065
01:17:31,450 --> 01:17:32,305
0,210 210,405 405,585 585,705 705,855
hash table. We talk about

3066
01:17:32,305 --> 01:17:34,015
0,275 325,600 600,840 840,1205 1465,1710
B B plus today. But

3067
01:17:34,015 --> 01:17:35,215
0,135 135,425 475,735 735,960 960,1200
these techniques of this idea

3068
01:17:35,215 --> 01:17:36,205
0,135 135,375 375,690 690,840 840,990
of like everything's going the

3069
01:17:36,205 --> 01:17:37,345
0,180 180,515 535,780 780,915 915,1140
same direction or I kill

3070
01:17:37,345 --> 01:17:37,975
0,210 210,330 330,435 435,525 525,630
myself as soon as I

3071
01:17:37,975 --> 01:17:39,420
0,210 210,330 330,605 745,1005 1005,1445
can't get something and restart

3072
01:17:39,650 --> 01:17:40,720
0,290 290,470 470,650 650,815 815,1070
like this is, this is

3073
01:17:40,720 --> 01:17:43,160
0,375 375,770 1270,1670
relevant to uh.|
|

3074
01:17:43,340 --> 01:17:44,230
0,380 380,605 605,710 710,785 785,890
To a bunch of other
系统中的其他数据结构也是如此。

3075
01:17:44,230 --> 01:17:45,490
0,195 195,500 550,840 840,1065 1065,1260
data structures in systems as

3076
01:17:45,490 --> 01:17:47,060
0,260
well.|
|

3077
01:17:47,520 --> 01:17:48,305
0,260 260,350 350,500 500,680 680,785
I feel like we should
我觉得我们应该把这门课叫作自杀。你要参与其中，不需要有人抱怨说，治愈你自己很多。抱歉，对吧？所以。

3078
01:17:48,305 --> 01:17:49,940
0,135 135,315 315,600 600,995 1315,1635
just call this course, kill

3079
01:17:49,940 --> 01:17:53,585
0,320 550,950 3190,3435 3435,3525 3525,3645
yourself. Is you to get

3080
01:17:53,585 --> 01:17:56,840
0,675 675,905 2335,2715 2715,3015 3015,3255
involved't need one somebody did

3081
01:17:56,840 --> 01:17:58,145
0,270 270,525 525,780 780,1065 1065,1305
complain that did say cure

3082
01:17:58,145 --> 01:18:00,695
0,165 165,270 270,515 1705,2105 2245,2550
yourself a lot. Sorry, right?

3083
01:18:00,695 --> 01:18:01,580
0,305
So.|
|

3084
01:18:01,680 --> 01:18:03,800
0,400 1050,1385 1385,1685 1685,1955 1955,2120
So next class we're talking
因此，下一节课我们将讨论排序或排序聚合。因此，在这一点上，我们要向上移动。现在我们实际上可以开始执行查询了。太棒了，对吧？所以我周一不会在这里，或者我不会教jne patelll做另一位教授。他将于星期一开始教书，然后是星期三，也就是下周。他和我都走了。我要去纽约参加后期会议。我将在那里做一个主题演讲。Aboutase可能不得不和Pro谈谈。

3085
01:18:03,800 --> 01:18:05,230
0,285 285,720 720,855 855,975 975,1430
about sorting or sort aggregations.

3086
01:18:05,280 --> 01:18:07,085
0,335 335,590 590,910 1320,1655 1655,1805
So this point we're moving

3087
01:18:07,085 --> 01:18:08,495
0,150 150,285 285,575 925,1245 1245,1410
up the stack. Now we

3088
01:18:08,495 --> 01:18:09,730
0,135 135,270 270,480 480,795 795,1235
can actually start executing queries.

3089
01:18:09,960 --> 01:18:12,875
0,400 450,850 1890,2290 2370,2675 2675,2915
Fantastic, right? So I won't

3090
01:18:12,875 --> 01:18:14,510
0,120 120,330 330,665 745,1145 1315,1635
be here on monday or

3091
01:18:14,510 --> 01:18:16,535
0,225 225,300 300,495 495,855 855,2025
I'm not teaching jne patelll

3092
01:18:16,535 --> 01:18:17,540
0,150 150,315 315,450 450,720 720,1005
be the other professor. He's

3093
01:18:17,540 --> 01:18:18,430
0,45 45,120 120,270 270,525 525,890
going to start teaching on

3094
01:18:18,510 --> 01:18:20,810
0,400 1170,1430 1430,1625 1625,1960 1980,2300
monday and then wednesday, next

3095
01:18:20,810 --> 01:18:21,980
0,320 580,825 825,930 930,1050 1050,1170
week. He and I are

3096
01:18:21,980 --> 01:18:23,165
0,240 240,570 570,855 855,1020 1020,1185
both gone. I'm going to

3097
01:18:23,165 --> 01:18:24,095
0,105 105,315 315,615 615,825 825,930
the post conference in new

3098
01:18:24,095 --> 01:18:24,920
0,135 135,330 330,450 450,585 585,825
York. I'm giving a keynote

3099
01:18:24,920 --> 01:18:28,085
0,180 180,860 2560,2835 2835,2970 2970,3165
there. Aboutases might have to

3100
01:18:28,085 --> 01:18:31,120
0,210 210,360 360,635
talk to Pro.|
|

3101
01:18:31,120 --> 01:18:31,930
0,120 120,345 345,585 585,690 690,810
But like we'll have one
但就像我的一名P G学生一样，我的头号P G学生Matt Butucevic将在下周三教授关节方面的课程。好的，EM，然后Jines是很棒的。吉恩斯问他关于在印度长大的事情，因为在他加入我的团队之前，他讲了一些疯狂的故事。他过去每天早上在上学的公交车上打架。想着刀子会问他这件事。好的，然后我们将，我们将谈论期中考试。

3102
01:18:31,930 --> 01:18:32,485
0,60 60,165 165,300 300,420 420,555
of my P G students,

3103
01:18:32,485 --> 01:18:33,160
0,135 135,270 270,420 420,555 555,675
my number one P G

3104
01:18:33,160 --> 01:18:34,150
0,135 135,330 330,765 765,885 885,990
student Matt butucevic will be

3105
01:18:34,150 --> 01:18:35,230
0,225 225,480 480,690 690,900 900,1080
teaching on wednesday next week

3106
01:18:35,230 --> 01:18:37,900
0,270 270,830 970,1370 1690,2090 2380,2670
about joints. Okay EM and

3107
01:18:37,900 --> 01:18:40,560
0,290 1360,1770 1770,1995 1995,2220 2220,2660
then jines is awesome. Jines

3108
01:18:41,180 --> 01:18:42,370
0,290 290,470 470,695 695,935 935,1190
asked him about growing up

3109
01:18:42,370 --> 01:18:44,950
0,225 225,500 580,980 2080,2400 2400,2580
in India because before he

3110
01:18:44,950 --> 01:18:45,475
0,120 120,225 225,345 345,450 450,525
joined his team me he

3111
01:18:45,475 --> 01:18:46,270
0,105 105,270 270,495 495,690 690,795
was telling crazy stories. He

3112
01:18:46,270 --> 01:18:46,780
0,75 75,150 150,210 210,300 300,510
used to get in fights

3113
01:18:46,780 --> 01:18:47,580
0,135 135,330 330,465 465,555 555,800
every morning on the bus

3114
01:18:47,600 --> 01:18:49,660
0,400 420,710 710,1000 1745,1925 1925,2060
going to school. Think CA

3115
01:18:49,660 --> 01:18:52,060
0,260 1690,1950 1950,2070 2070,2205 2205,2400
knife ask him about it.

3116
01:18:52,060 --> 01:18:53,740
0,320 580,840 840,1080 1080,1455 1455,1680
Okay, and then we'll, we'll

3117
01:18:53,740 --> 01:18:54,780
0,75 75,165 165,240 240,645 645,1040
talk about the midterm on.|
|

3118
01:18:56,010 --> 01:18:57,020
0,320 320,530 530,665 665,770 770,1010
On next week as well
下周也是，好的，现在听着，我是罂粟花，他妈的钩子28克，取决于你还没打到暴徒，但还是要闭嘴我用夹子的底部打你，告诉你，抬头告诉你，让我看看它是什么，我把你的脸打回去，我有块积木板，兽医不能追踪，就像是大便，你不能在多米尼加人那里系花边，你们不能叫我多米尼加黑色偷偷摸摸的黑色皮革羊皮鞋，我整个黑色肮脏的8号送你去酒吧，你得到了你的萨瓦塔纳溜冰，这是你的第一个错误，我为你等待，等待我的等待，韦比生活得很棒。

3119
01:18:57,020 --> 01:19:17,525
0,380 19210,19500 19500,19790 20020,20385 20385,20505
okay now listen I'm the

3120
01:19:17,525 --> 01:19:19,150
0,360 360,510 510,675 675,1275 1275,1625
poppy with the motherfuck hook

3121
01:19:19,470 --> 01:19:21,170
0,530 530,725 725,1060 1140,1475 1475,1700
28 a gram depending on

3122
01:19:21,170 --> 01:19:22,595
0,165 165,480 480,830 940,1200 1200,1425
if it's up you ain't

3123
01:19:22,595 --> 01:19:23,825
0,120 120,270 270,465 465,785 925,1230
hit the mob yet still

3124
01:19:23,825 --> 01:19:24,905
0,195 195,390 390,570 570,795 795,1080
got to shut up I

3125
01:19:24,905 --> 01:19:25,820
0,255 255,390 390,510 510,675 675,915
smack you with the bottom

3126
01:19:25,820 --> 01:19:26,735
0,210 210,390 390,600 600,750 750,915
of the clip to tell

3127
01:19:26,735 --> 01:19:27,950
0,165 165,360 360,665 775,1065 1065,1215
you look up show me

3128
01:19:27,950 --> 01:19:28,910
0,105 105,240 240,450 450,735 735,960
what it sa at for

3129
01:19:28,910 --> 01:19:30,005
0,150 150,330 330,540 540,795 795,1095
I blow your face back

3130
01:19:30,005 --> 01:19:31,325
0,240 240,375 375,540 540,1020 1020,1320
I got a blockboard taps

3131
01:19:31,325 --> 01:19:33,110
0,240 240,570 570,885 885,1110 1110,1785
the vets can't trace thatyl

3132
01:19:33,110 --> 01:19:34,340
0,165 165,405 405,705 705,945 945,1230
is like t for poop

3133
01:19:34,340 --> 01:19:35,405
0,225 225,540 540,735 735,915 915,1065
you can't lace that at

3134
01:19:35,405 --> 01:19:36,995
0,150 150,915 915,1170 1170,1335 1335,1590
the Dominican or you guys

3135
01:19:36,995 --> 01:19:38,915
0,255 255,420 420,1140 1140,1500 1500,1920
call me Dominican black sclly

3136
01:19:38,915 --> 01:19:40,730
0,255 255,675 675,960 960,1305 1305,1815
black leather black sued timberins

3137
01:19:40,730 --> 01:19:42,050
0,195 195,450 450,765 765,1080 1080,1320
my whole black dirty eight

3138
01:19:42,050 --> 01:19:42,875
0,195 195,375 375,540 540,675 675,825
to send you to the

3139
01:19:42,875 --> 01:19:44,225
0,270 270,635 775,1050 1050,1185 1185,1350
pur gates you get your

3140
01:19:44,225 --> 01:19:45,560
0,585 585,855 855,1020 1020,1230 1230,1335
savatana skate and that's your

3141
01:19:45,560 --> 01:19:48,590
0,260 280,680 880,1280 1570,1970 2740,3030
first mistake I for you

3142
01:19:48,590 --> 01:19:50,615
0,290 370,770 1150,1470 1470,1785 1785,2025
wait my wait the the

3143
01:19:50,615 --> 01:19:56,400
0,365 2485,2865 2865,3245
webby living great.|
|
