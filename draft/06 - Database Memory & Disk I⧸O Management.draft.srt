1
00:00:26,650 --> 00:00:31,430
0,400 400,3150 3150,3470 3470,3665 3665,3940 4380,4780
2PL, {how,was,the} concert on Saturday.| {It,went,well},
2PL ，周六的演唱会怎么样？|很好，会给一群演讲者[]。

2
00:00:31,660 --> 00:00:32,925
0,290 290,695 695,860 860,1025 1025,1265
{it,might,be} [redline] a bunch of

3
00:00:32,925 --> 00:00:36,495
0,335 335,1825 1825,2100 2100,2375 3115,3390 3390,3570
speakers.| {What,does,it,mean,the,redline,speaders}?| I mean if the
|你说的[]演讲者是什么意思？|我的意思是，如果演讲者可以 100% 地工作，

4
00:00:36,495 --> 00:00:37,740
0,255 255,605 625,930 930,1110 1110,1245
speaker can work at like

5
00:00:37,740 --> 00:00:39,380
0,105 105,330 330,710 910,1275 1275,1640
a {100% -},| {you,will} {working,them,at}
|你会让他们达到 200% 。

6
00:00:39,550 --> 00:00:42,660
0,490 930,1205 1205,1480 2490,2840 2840,3110
200%.| {Did,you} {break,them}?| Next time
|你打破了吗？|也许下一次可以。

7
00:00:42,660 --> 00:00:45,170
0,320 430,765 765,1100 1100,1960 1960,2235 2235,2510
maybe.| Okay, nice, {how,many,people} showed up?|
|好的，有多少人？|

8
00:00:45,490 --> 00:00:47,040
0,245 245,490 660,920 920,1100 1100,1550
Two hundred.| Two hundred, that's
两百。|两百，太令人惊讶了。

9
00:00:47,040 --> 00:00:48,180
0,225 225,590 640,885 885,990 990,1140
impressive.| Okay and your next
|好的，你的下一场演出是什么时候？

10
00:00:48,180 --> 00:00:51,450
0,135 135,255 255,530 1090,1490 2950,3270
show is when?| {October\,,after,the,fall,break}.| That's
|十月份，在秋休之后。|那是校外的事。

11
00:00:51,450 --> 00:00:53,010
0,120 120,360 360,710 1120,1425 1425,1560
off campus though.| We'll post
|我们会把它张贴在 Piazza 上。

12
00:00:53,010 --> 00:00:54,630
0,240 240,450 450,860 970,1350 1350,1620
that on Piazza.| {All,right\,,guys}, {a,lot}
|好的，大家，有很多东西要讲，

13
00:00:54,630 --> 00:00:56,295
0,150 150,410 880,1155 1155,1305 1305,1665
to cover,| some quick administrative
|一些快速管理的事情，我很快讲一下。

14
00:00:56,295 --> 00:00:58,940
0,210 210,435 435,755 1165,1565 2245,2645
things, go quickly.| {} So
|所以家庭作业 #2 已经放出，

15
00:00:59,170 --> 00:01:00,360
0,400 600,965 965,1160
the homework {#2

16
00:01:00,360 --> 00:01:01,755
0,165 165,390 390,540 540,800 1090,1395
-} is been out,| we
|我们把截止日期推迟到了 10 月 4 日，

17
00:01:01,755 --> 00:01:02,760
0,315 315,450 450,615 615,825 825,1005
bumped the due date to

18
00:01:02,760 --> 00:01:04,380
0,260 580,915 915,1250 1270,1530 1530,1620
be October 4th,| because we
|因为我们不想让它和项目 #1 的截止日期排在同一天，

19
00:01:04,380 --> 00:01:04,920
0,135 135,180 180,300 300,435 435,540
didn't want to have it

20
00:01:04,920 --> 00:01:06,570
0,180 180,420 420,770 1210,1470 1470,1650
lined up on the same

21
00:01:06,570 --> 00:01:07,560
0,210 210,375 375,600 600,825 825,990
date that project #1 is

22
00:01:07,560 --> 00:01:10,905
0,290 1510,1910 1930,2265 2265,2600 3100,3345
due,| so the material part
|所以问题的材料部分，

23
00:01:10,905 --> 00:01:11,430
0,60 60,105 105,210 210,345 345,525
of the problem,| I also
|我也做的是劳动节的日程安排，

24
00:01:11,430 --> 00:01:12,120
0,90 90,180 180,330 330,600 600,690
do is the scheduling with

25
00:01:12,120 --> 00:01:13,350
0,165 165,405 405,740 850,1080 1080,1230
Labor Day everything,| so the
|所以家庭作业的材料讨论，我们下周讨论，

26
00:01:13,350 --> 00:01:14,865
0,255 255,465 465,675 675,1010 1090,1515
material of that homework discusses

27
00:01:14,865 --> 00:01:15,855
0,180 180,420 420,585 585,780 780,990
things we'll discuss next week,|
|

28
00:01:15,855 --> 00:01:16,830
0,150 150,270 270,630 630,795 795,975
so we postpone that a
我们把这推迟了一天，

29
00:01:16,830 --> 00:01:18,270
0,290 610,855 855,975 975,1185 1185,1440
day| and then project #1
|然后项目 #1 仍在正轨上，我们截止 10 月 2 日，

30
00:01:18,270 --> 00:01:19,250
0,165 165,300 300,510 510,705 705,980
still on track, we due

31
00:01:19,330 --> 00:01:21,045
0,365 365,730 1080,1385 1385,1550 1550,1715
October 2nd| and again that's
|也是在星期天，

32
00:01:21,045 --> 00:01:22,290
0,75 75,195 195,455 775,1065 1065,1245
on a Sunday,| we're having
|星期一下午 6：30 ，我们将举行问答会议，

33
00:01:22,290 --> 00:01:23,180
0,225 225,345 345,435 435,585 585,890
the {Q&A - -} session

34
00:01:23,290 --> 00:01:26,400
0,400 1230,1595 1595,1960 2580,2915 2915,3110
this today, Monday at {6:30pm

35
00:01:26,400 --> 00:01:27,945
0,180 345,590 820,1095 1095,1350 1350,1545
- -}| and that'll be
|这将是在 Zoom 上，张贴在 Piazza 上，

36
00:01:27,945 --> 00:01:29,775
0,365 415,795 795,1125 1125,1305 1305,1830
on, on Zoom and that's

37
00:01:29,775 --> 00:01:30,860
0,60 60,180 180,315 315,495 495,1085
a post on that Piazza|
|

38
00:01:31,120 --> 00:01:32,415
0,275 275,500 500,850 870,1115 1115,1295
and then as for all
至于所有的项目，

39
00:01:32,415 --> 00:01:33,705
0,180 180,420 420,750 750,975 975,1290
the projects,| again, there won't
|周日不会有任何办公时间，

40
00:01:33,705 --> 00:01:35,580
0,275 715,1115 1135,1395 1395,1605 1605,1875
be any office hours on

41
00:01:35,580 --> 00:01:37,140
0,630 630,885 885,1110 1110,1350 1350,1560
Sundays,| when the project is
|当项目到期时，

42
00:01:37,140 --> 00:01:38,175
0,290 490,735 735,870 870,930 930,1035
due,| but there'll be a
|但是会有一个特别的办公时间会议，在周六，在它到期之前，

43
00:01:38,175 --> 00:01:40,365
0,275 775,1020 1020,1215 1215,1565 1915,2190
special office hours session on

44
00:01:40,365 --> 00:01:41,690
0,180 180,485 505,825 825,1065 1065,1325
the Saturday, before it's due,|
|

45
00:01:42,070 --> 00:01:43,755
0,350 350,700 930,1205 1205,1415 1415,1685
on campus, with like four
大约下午 3-5 点之间有 4 个助教，

46
00:01:43,755 --> 00:01:46,005
0,180 180,425 1015,1415 1855,2115 2115,2250
{TAs -}, between 3 and

47
00:01:46,005 --> 00:01:47,490
0,180 330,575 1045,1290 1290,1380 1380,1485
{5pm -},| this is meant
|这就像是一种强制功能，

48
00:01:47,490 --> 00:01:48,240
0,90 90,180 180,285 285,405 405,750
to be like a forcing

49
00:01:48,240 --> 00:01:49,430
0,290 310,555 555,660 660,855 855,1190
function| for you guys actually
|让你们真正开始工作，

50
00:01:49,510 --> 00:01:50,415
0,275 275,440 440,560 560,650 650,905
start working on the project|
|

51
00:01:50,415 --> 00:01:51,705
0,225 225,345 345,540 540,845 1015,1290
instead of showing up the
而不是在到期日期的办公时间表示，

52
00:01:51,705 --> 00:01:52,890
0,275 325,630 630,840 840,1005 1005,1185
dates due to office hours,|
|

53
00:01:52,890 --> 00:01:54,480
0,210 210,500 640,990 990,1320 1320,1590
saying you doesn't compile, right,|
说你没有编译，|

54
00:01:54,480 --> 00:01:56,115
0,290 700,960 960,1095 1095,1370 1390,1635
like we want you, we
我们希望你尽快开始，好吗？

55
00:01:56,115 --> 00:01:57,000
0,135 135,255 255,360 360,570 570,885
want you to start sooner

56
00:01:57,000 --> 00:01:58,820
0,270 270,420 420,680 940,1340
rather than later, okay?|
|

57
00:01:59,930 --> 00:02:01,195
0,455 455,575 575,770 770,950 950,1265
Somebody's already gotten, I think,
我想有些人已经百分之百地完成了项目一，

58
00:02:01,195 --> 00:02:01,975
0,225 225,345 345,435 435,540 540,780
already gotten a {100% -}

59
00:02:01,975 --> 00:02:03,865
0,365 805,1140 1140,1425 1425,1680 1680,1890
on project #1,| even though
|虽然今天的讲座讨论的是项目一，

60
00:02:03,865 --> 00:02:05,455
0,360 360,635 685,1095 1095,1305 1305,1590
today's lecture discusses project #1,|
|

61
00:02:05,455 --> 00:02:09,880
0,335 1045,1445
so impressive.|
所以，令人印象深刻。|

62
00:02:10,180 --> 00:02:11,040
0,320 320,485 485,575 575,680 680,860
Sorry, how much you expected
抱歉，你期望什么是多少？

63
00:02:11,040 --> 00:02:16,230
0,320 4450,4725 4725,4890 4890,5055 5055,5190
what?| His question is,| how
|他的问题是，|我们应该花多长时间来完成整个项目，

64
00:02:16,230 --> 00:02:17,460
0,150 150,440 610,855 855,1005 1005,1230
much time should we expect

65
00:02:17,460 --> 00:02:18,590
0,240 240,465 465,645 645,825 825,1130
to complete the entire project,|
|

66
00:02:19,840 --> 00:02:20,880
0,275 275,395 395,590 590,860 860,1040
I mean, it depends on
我想，这取决于你的背景，

67
00:02:20,880 --> 00:02:22,170
0,120 120,380 520,885 885,1110 1110,1290
your background,| like some people
|比如有些人用 C++ ，没有问题，

68
00:02:22,170 --> 00:02:22,935
0,210 210,345 345,465 465,585 585,765
ripped through {C++ - -},

69
00:02:22,935 --> 00:02:24,140
0,165 165,405 405,645 645,855 855,1205
no problems,| other people struggle,
|而其他人在挣扎，

70
00:02:24,670 --> 00:02:27,555
0,400 1770,2120 2120,2360 2360,2570 2570,2885
right,| project #1 is, is,
|项目一是，

71
00:02:27,555 --> 00:02:29,085
0,395 955,1185 1185,1260 1260,1410 1410,1530
is,| I mean it's more
|我的意思是它比项目零的工作量更大，

72
00:02:29,085 --> 00:02:30,390
0,150 150,270 270,450 450,785 955,1305
work than project zero,| it's
|它没有项目一那么糟糕，

73
00:02:30,390 --> 00:02:31,430
0,150 150,345 345,510 510,705 705,1040
less [worse] than project #1,|
|

74
00:02:31,510 --> 00:02:33,590
0,365 365,640 1350,1670 1670,1790 1790,2080
it's reasonable,| it's not bad.|
这是合理的，|它不是很糟糕。|

75
00:02:34,870 --> 00:02:37,080
0,290 290,580
Any {other,questions}?|
还有其他问题吗？|

76
00:02:38,060 --> 00:02:38,740
0,230 230,380 380,530 530,590 590,680
All right, so a bunch
好的，还有一些其他课外活动，

77
00:02:38,740 --> 00:02:41,005
0,75 75,195 195,420 420,740 1570,2265
of other things, that extracurricular

78
00:02:41,005 --> 00:02:42,160
0,305 505,765 765,870 870,975 975,1155
things,| that you can do
|你们可以在课程中做，

79
00:02:42,160 --> 00:02:44,050
0,165 165,285 285,560 1120,1520 1570,1890
in the class,| today, we're
|今天，我们将进行另一场研讨会演讲，

80
00:02:44,050 --> 00:02:45,930
0,195 195,495 495,1010 1090,1485 1485,1880
having another Seminar talk| from
|来自 CMU 的 Dana Van Aken ，

81
00:02:46,160 --> 00:02:47,680
0,400 540,920 920,1145 1145,1430 1430,1520
from {CMU -} Dana Van

82
00:02:47,680 --> 00:02:49,680
0,410 820,1155 1155,1365 1365,1500 1500,2000
Aken,| just talk about OtterTune
|谈谈 OtterTune 和我参与的初创公司，

83
00:02:49,880 --> 00:02:50,845
0,260 260,395 395,650 650,755 755,965
and the startup that I'm

84
00:02:50,845 --> 00:02:52,195
0,180 180,485 685,960 960,1155 1155,1350
involved in,| then next week,
|下周，我们将有 PostgresML 的联合创始人之一，

85
00:02:52,195 --> 00:02:53,635
0,195 195,425 1045,1290 1290,1365 1365,1440
we'll have one of the

86
00:02:53,635 --> 00:02:54,840
0,120 120,405 405,525 525,735 735,1205
{co-founders -} of {PostgresML -},|
|

87
00:02:55,220 --> 00:02:58,930
0,275 275,2615 2615,2830 3330,3635 3635,3710
this is's a, it's a
这是 Postgres 的[托管]版本，

88
00:02:58,930 --> 00:03:00,310
0,315 315,510 510,705 705,1170 1170,1380
hosted version of Postgres,| where
|他们在那里放置 UDF ，

89
00:03:00,310 --> 00:03:01,570
0,210 210,480 480,800 880,1155 1155,1260
they they put {[UDFs] -

90
00:03:01,570 --> 00:03:02,380
0,210 210,435 435,645 645,705 705,810
-}| or you can make
|或者你可以在直接使用 SQL 进行类似于 PyTorch 的调用，

91
00:03:02,380 --> 00:03:03,370
0,120 120,225 225,360 360,570 570,990
you can make like PyTorch

92
00:03:03,370 --> 00:03:04,890
0,210 210,510 510,795 795,1050 1050,1520
calls directly in, in SQL,|
|

93
00:03:05,390 --> 00:03:06,415
0,305 305,470 470,590 590,815 815,1025
they also been working on
他们还做了 Postgres 代理，叫做 PgCat ，

94
00:03:06,415 --> 00:03:07,705
0,150 150,540 540,975 975,1140 1140,1290
a Postgres proxy called {PgCat

95
00:03:07,705 --> 00:03:09,430
0,150 150,425 1165,1485 1485,1590 1590,1725
- -},| that's written in
|是用 Rust 写成的，很受欢迎，

96
00:03:09,430 --> 00:03:10,945
0,210 210,420 420,540 540,1160 1240,1515
rust, engaged in popularity,| and
|然后在接下来的一周，

97
00:03:10,945 --> 00:03:12,030
0,225 225,435 435,570 570,765 765,1085
then the week after that,|
|

98
00:03:12,170 --> 00:03:13,555
0,275 275,425 425,545 545,970 1050,1385
actually not the 18th, October
实际上不是 18 日，而是 10 月 2 日，|

99
00:03:13,555 --> 00:03:16,285
0,335 1525,1800 1800,1995 1995,2315 2425,2730
2nd,| we'll have the {CTO
|我们将有 Weaviate 的 CTO 和联合创始人，

100
00:03:16,285 --> 00:03:17,590
0,150 150,255 255,390 390,705 705,1305
-} and {co-founder -} {of,Weaviate}|
|

101
00:03:17,590 --> 00:03:18,810
0,210 210,270 270,375 375,585 585,1220
one of these vector databases,|
Weaviate 是一个向量数据库，|

102
00:03:19,400 --> 00:03:20,095
0,275 275,380 380,455 455,575 575,695
come give a talk with
在 Zoom 上给我们演讲。

103
00:03:20,095 --> 00:03:21,200
0,120 120,300 300,635
us on Zoom.|
|

104
00:03:21,920 --> 00:03:23,300
0,400
Okay.|
好的。|

105
00:03:23,300 --> 00:03:25,150
0,350 640,900 900,1005 1005,1250 1270,1850
Yes.| { - - -}
是的。|

106
00:03:25,200 --> 00:03:26,615
0,400 480,740 740,860 860,1120 1140,1415

107
00:03:26,615 --> 00:03:27,740
0,195 195,375 375,480 480,675 675,1125
{His,question} is,| {is,there} any internship,
它的问题是，|这些公司中有没有实习机会，

108
00:03:27,740 --> 00:03:28,490
0,300 300,540 540,660 660,705 705,750
any opportunities for any of

109
00:03:28,490 --> 00:03:33,830
0,75 75,320 820,1170 1170,1520 5050,5340
these companies,| absolutely, yes,| they
|当然有，|他们想出一种最好的联系方式，

110
00:03:33,830 --> 00:03:34,625
0,150 150,240 240,375 375,555 555,795
figure out a best way

111
00:03:34,625 --> 00:03:35,770
0,195 195,285 285,465 465,765 765,1145
{for,you} to contact them,| but,
|但是，没错，所有这些公司都是为了招聘。

112
00:03:36,060 --> 00:03:38,500
0,400 1290,1610 1610,1930 1950,2195 2195,2440
yes, all {the,companies} to hiring.|
|

113
00:03:41,490 --> 00:03:42,320
0,260 260,350 350,470 470,650 650,830
So there was two big
上周有两条重大的数据库新闻，

114
00:03:42,320 --> 00:03:43,205
0,255 255,510 510,645 645,735 735,885
database news in the last

115
00:03:43,205 --> 00:03:44,180
0,305 355,615 615,720 720,825 825,975
week,| since we last have
|自从我们上节课以来，

116
00:03:44,180 --> 00:03:46,120
0,290 730,1130 1270,1545 1545,1680 1680,1940
class,| {did,anybody} know they were?|
|有人知道它们是什么吗？|

117
00:03:51,600 --> 00:03:54,950
0,400 420,710 710,935 935,1270 3060,3350
Postgres release version 16,| is
Postgres 发布了版本 16 ，|并不是一个很大的游戏规则改变者，

118
00:03:54,950 --> 00:03:56,230
0,165 165,330 330,525 525,765 765,1280
not a big game changer,|
|

119
00:03:56,310 --> 00:03:57,110
0,290 290,455 455,575 575,695 695,800
in terms of like they
他们没有令人惊叹的新功能，

120
00:03:57,110 --> 00:03:58,055
0,120 120,195 195,440 580,825 825,945
don't have like you know,

121
00:03:58,055 --> 00:03:59,105
0,225 225,435 435,675 675,975 975,1050
amazing new features,| it's a
|它有很多改进之处，

122
00:03:59,105 --> 00:04:00,190
0,90 90,165 165,585 585,765 765,1085
lot of refinement and improvements,|
|

123
00:04:00,990 --> 00:04:03,560
0,290 290,410 410,530 530,760 2220,2570
they're nice to {haves -},
很高兴他们有，它是，

124
00:04:03,560 --> 00:04:06,185
0,420 420,830 1600,1860 1860,2120 2350,2625
it's, it's, it [],| a
|游戏规则的改变者的改进是，

125
00:04:06,185 --> 00:04:07,565
0,225 225,645 645,885 885,1155 1155,1380
game changer improvements be like,|
|

126
00:04:07,565 --> 00:04:08,600
0,165 165,345 345,645 645,900 900,1035
in my opinion, is when
在我看来，是他们为 WHERE 子句增加及时编译时，

127
00:04:08,600 --> 00:04:09,665
0,120 120,380 520,795 795,930 930,1065
they added just in time

128
00:04:09,665 --> 00:04:11,420
0,515 535,870 870,1110 1110,1590 1590,1755
compilation for WHERE clauses,| which
|我们将在几周内讨论，

129
00:04:11,420 --> 00:04:12,920
0,150 150,380 1030,1275 1275,1380 1380,1500
we'll cover in a few

130
00:04:12,920 --> 00:04:15,170
0,260 670,1070 1300,1935 1935,2100 2100,2250
weeks,| {} deduplication for B
|对 B 树重复数据删除是不错的，

131
00:04:15,170 --> 00:04:15,940
0,165 165,315 315,435 435,525 525,770
trees is kind of nice,|
|

132
00:04:16,290 --> 00:04:17,060
0,320 320,410 410,530 530,635 635,770
there's a bunch of {I/O
有一堆 I/O 的东西还没有准备好投入生产，

133
00:04:17,060 --> 00:04:18,850
0,270 270,600 600,1110 1110,1410 1410,1790
-} stuff that's still not

134
00:04:18,900 --> 00:04:21,980
0,400 810,1100 1100,1280 1280,1570 2820,3080
in ready for production,| which
|我们今天会稍微讨论一下，

135
00:04:21,980 --> 00:04:22,385
0,150 150,225 225,285 285,330 330,405
we'll talk about a little

136
00:04:22,385 --> 00:04:24,180
0,105 105,365 715,1020 1020,1325
about today,| but like,
|但是，有是不错的，

137
00:04:24,220 --> 00:04:25,005
0,335 335,395 395,530 530,650 650,785
it's a nice to have,|
|

138
00:04:25,005 --> 00:04:26,130
0,345 345,495 495,690 690,900 900,1125
Postgres has been putting out
Postgres 每年发布一次，这是一件很好的事情。

139
00:04:26,130 --> 00:04:26,790
0,285 285,405 405,510 510,585 585,660
releases once a year and

140
00:04:26,790 --> 00:04:27,350
0,105 105,165 165,255 255,330 330,560
it's been kind of nice.|
|

141
00:04:27,520 --> 00:04:28,785
0,245 245,365 365,845 845,1025 1025,1265
And then Databricks announced,| they
然后， Databricks 宣布，|他们以 5 亿美元的价格融资了第 I 轮，

142
00:04:28,785 --> 00:04:30,750
0,255 255,480 480,765 765,1145 1645,1965
raised a series I for

143
00:04:30,750 --> 00:04:33,615
0,420 420,660 660,980 2140,2540 2560,2865
500 million dollars| with a
|估值为 430 亿美元，

144
00:04:33,615 --> 00:04:35,960
0,480 480,720 720,990 990,1595 1945,2345
43 billion Dollar valuation, {}|
|

145
00:04:37,060 --> 00:04:37,790
0,290 290,335 335,395 395,485 485,730
that's a lot of money
这么多钱是不言而喻的，

146
00:04:39,160 --> 00:04:40,610
0,290 290,455 455,605 605,880 1050,1450
goes goes without saying, {}|
|

147
00:04:41,260 --> 00:04:42,270
0,320 320,500 500,665 665,755 755,1010
yeah, I don't, I don't,|
是的，我没有，|

148
00:04:42,270 --> 00:04:43,370
0,330 330,525 525,660 660,825 825,1100
Snowflake didn't raise this amount,
Snowflake 在 IPO 之前没有筹集到这个数额，

149
00:04:43,630 --> 00:04:45,255
0,290 290,580 1050,1370 1370,1535 1535,1625
this amount before they went

150
00:04:45,255 --> 00:04:48,020
0,455 505,905 1735,2135 2155,2520 2520,2765
IPO,| but anyway, they're hiring.|
|但不管怎样，他们都在招人。|

151
00:04:49,720 --> 00:04:51,260
0,260 260,455 455,790 990,1265 1265,1540
All right, so, all right.|
好的，所以，好的。|

152
00:04:52,570 --> 00:04:55,905
0,260 260,485 485,850 2490,2890 2970,3335
So last class, was we
上一节课，我们结束了关于数据库系统存储方面的讨论，

153
00:04:55,905 --> 00:04:57,045
0,285 285,465 465,615 615,855 855,1140
finished up the discussion on

154
00:04:57,045 --> 00:04:58,995
0,335 595,995 1435,1680 1680,1785 1785,1950
the storage aspect of database

155
00:04:58,995 --> 00:05:00,150
0,255 255,465 465,615 615,840 840,1155
systems| and was really focusing
|重点是数据库系统如何在磁盘中表示数据，

156
00:05:00,150 --> 00:05:02,085
0,380 850,1245 1245,1485 1485,1680 1680,1935
on how the database system

157
00:05:02,085 --> 00:05:04,040
0,165 165,255 255,315 315,545 1555,1955
is going to represent data

158
00:05:04,150 --> 00:05:05,955
0,400 450,755 755,1330 1410,1670 1670,1805
in, in disk,| we talk
|我们讨论了面向 tuple 存储，日志结构存储和索引组织存储，

159
00:05:05,955 --> 00:05:06,705
0,165 165,315 315,450 450,585 585,750
about the {tuple-oriented -}

160
00:05:06,705 --> 00:05:08,535
0,285 285,570 570,825 825,1175 1555,1830
storage, {log-structure -} storage, the

161
00:05:08,535 --> 00:05:10,080
0,135 135,360 360,725 805,1205 1255,1545
{index-organized -} storage,| right now
|现在我们知道这些文件在磁盘上是什么样子，

162
00:05:10,080 --> 00:05:10,785
0,135 135,225 225,300 300,435 435,705
we know what these files

163
00:05:10,785 --> 00:05:11,955
0,240 240,515 535,825 825,1020 1020,1170
look like on disk,| how
|它们是如何被分解成页面的，

164
00:05:11,955 --> 00:05:12,770
0,135 135,255 255,390 390,525 525,815
they're broken up into pages,|
|

165
00:05:13,550 --> 00:05:15,580
0,320 320,640 1110,1655 1655,1850 1850,2030
and so today's class and
所以今天的课程和以后的课程是关于，

166
00:05:15,580 --> 00:05:17,070
0,165 165,405 405,740 850,1170 1170,1490
going forward is really about|
|

167
00:05:17,360 --> 00:05:19,000
0,260 260,350 350,580 1140,1430 1430,1640
how do we get those
我们如何从磁盘中获取这些页面，

168
00:05:19,000 --> 00:05:20,770
0,240 240,450 450,980 1330,1620 1620,1770
pages from disk,| bring those
|将这些页面放入内存，

169
00:05:20,770 --> 00:05:22,375
0,180 180,500 520,780 780,1040 1300,1605
into memory,| and then do
|然后对它们进行一些操作。

170
00:05:22,375 --> 00:05:23,900
0,225 225,420 420,695
something with them.|
|

171
00:05:24,050 --> 00:05:25,510
0,275 275,395 395,640 1050,1295 1295,1460
And of course, the whole
当然，我们试图在这个概念性系统中建立的整个目标是，

172
00:05:25,510 --> 00:05:26,485
0,300 300,585 585,750 750,900 900,975
goal of what we're trying

173
00:05:26,485 --> 00:05:27,670
0,120 120,330 330,510 510,675 675,1185
to build in this conceptual

174
00:05:27,670 --> 00:05:28,860
0,210 210,420 420,615 615,885 885,1190
system we're talking about is|
|

175
00:05:29,330 --> 00:05:30,480
0,305 305,470 470,620 620,830 830,1150
having a database system that
拥有一个数据库系统，它给人一种错觉，

176
00:05:30,920 --> 00:05:31,960
0,275 275,395 395,725 725,935 935,1040
gives the illusion,| that we
|我们拥有比实际拥有更多的内存，

177
00:05:31,960 --> 00:05:32,875
0,150 150,315 315,525 525,720 720,915
have more memory than we

178
00:05:32,875 --> 00:05:35,095
0,335 595,995 1525,1785 1785,1995 1995,2220
actually have,| the database is
|数据库比内存中的大小更大，

179
00:05:35,095 --> 00:05:35,935
0,240 240,465 465,600 600,735 735,840
larger than what fits in

180
00:05:35,935 --> 00:05:37,480
0,245 535,885 885,1155 1155,1380 1380,1545
memory,| we want to make
|我们想让它看起来像可以在内存中容纳一切。

181
00:05:37,480 --> 00:05:38,170
0,120 120,255 255,390 390,525 525,690
it look like we could

182
00:05:38,170 --> 00:05:39,640
0,225 225,405 405,495 495,740 1210,1470
fit everything in memory.| So
|所以今天真正的主题是，

183
00:05:39,640 --> 00:05:40,585
0,195 195,405 405,570 570,765 765,945
today is really about,| how
|我们如何从磁盘中获取我们需要的东西，那些页面，

184
00:05:40,585 --> 00:05:41,365
0,120 120,240 240,435 435,645 645,780
do we go get the

185
00:05:41,365 --> 00:05:42,565
0,135 135,285 285,545 565,930 930,1200
things we need from disk,

186
00:05:42,565 --> 00:05:44,110
0,210 210,515 985,1245 1245,1380 1380,1545
those pages,| bring them into
|将它们带入内存，

187
00:05:44,110 --> 00:05:45,385
0,290 310,570 570,720 720,975 975,1275
memory,| and then make decisions
|然后决定如何删除它们，

188
00:05:45,385 --> 00:05:46,470
0,195 195,300 300,480 480,750 750,1085
on how to remove them|
|

189
00:05:46,790 --> 00:05:47,850
0,245 245,365 365,500 500,710 710,1060
in order to save space
以便在我们想要引入新东西时节省空间。

190
00:05:47,960 --> 00:05:48,690
0,245 245,335 335,425 425,500 500,730
when we want to bring

191
00:05:48,710 --> 00:05:50,080
0,290 290,470 470,760
new things in.|
|

192
00:05:50,940 --> 00:05:52,740
0,400
{All,right}.|
好的。|

193
00:05:53,070 --> 00:05:55,610
0,400 510,1120 1500,1865 1865,2230 2250,2540
So there's two key aspects
所以，我们必须考虑两个关键方面，

194
00:05:55,610 --> 00:05:56,705
0,180 180,285 285,480 480,810 810,1095
we have to consider| in
|在做出任何有关如何在磁盘中来回移动数据的决策时。

195
00:05:56,705 --> 00:05:58,160
0,285 285,600 600,840 840,1085 1165,1455
any decisions we're making on

196
00:05:58,160 --> 00:05:59,060
0,180 180,330 330,480 480,690 690,900
how we move data back

197
00:05:59,060 --> 00:06:00,860
0,150 150,270 270,390 390,890
and forth in disk.|
|

198
00:06:00,860 --> 00:06:02,420
0,210 210,420 420,770 1150,1440 1440,1560
The first is where do
第一个是，我们希望将页面写到磁盘上的什么位置，

199
00:06:02,420 --> 00:06:02,915
0,75 75,165 165,255 255,360 360,495
we want to write our

200
00:06:02,915 --> 00:06:04,385
0,210 210,435 435,965 985,1245 1245,1470
pages on disk| and how
|以及如何布局它们，

201
00:06:04,385 --> 00:06:05,480
0,225 225,485 595,885 885,1005 1005,1095
can we lay them out|
|

202
00:06:05,480 --> 00:06:06,305
0,120 120,240 240,360 360,570 570,825
in such a way that
以一种我们可以最大限度地增加执行顺序 I/O 的数量的方法，

203
00:06:06,305 --> 00:06:07,355
0,150 150,270 270,795 795,960 960,1050
we can maximize the amount

204
00:06:07,355 --> 00:06:08,255
0,105 105,390 390,675 675,810 810,900
of sequential io we are

205
00:06:08,255 --> 00:06:09,320
0,245 385,630 630,720 720,855 855,1065
doing,| instead of doing random
|而不是执行随机 I/O 。

206
00:06:09,320 --> 00:06:10,560
0,500
I/O.|
|

207
00:06:10,560 --> 00:06:12,750
0,320 910,1310 1390,1725 1725,1995 1995,2190
{} And the idea here
这里的想法是，

208
00:06:12,750 --> 00:06:13,470
0,135 135,315 315,480 480,600 600,720
is that,| we want to
|我们希望将要一起使用的页面保留在磁盘上，

209
00:06:13,470 --> 00:06:14,400
0,165 165,435 435,690 690,840 840,930
keep pages that are going

210
00:06:14,400 --> 00:06:17,205
0,120 120,390 390,770 1510,1910 2500,2805
to used together,| possibly close
|可能在物理上彼此接近，

211
00:06:17,205 --> 00:06:18,150
0,120 120,180 180,360 360,675 675,945
to each other physically on

212
00:06:18,150 --> 00:06:21,075
0,560 790,1065 1065,1340 1480,1880 1880,2650 2650,2925
disk,| so that {when,something}, when a
|这样当查询运行或某个任务在我们的数据库系统内运行时，

213
00:06:21,075 --> 00:06:22,020
0,210 210,390 390,555 555,735 735,945
query is running or some

214
00:06:22,020 --> 00:06:22,920
0,240 240,435 435,645 645,825 825,900
task is running inside of

215
00:06:22,920 --> 00:06:23,745
0,75 75,270 270,555 555,735 735,825
our database system,| we have
|我们必须获取大量页面，

216
00:06:23,745 --> 00:06:24,375
0,75 75,180 180,375 375,525 525,630
to go fetch a bunch

217
00:06:24,375 --> 00:06:25,770
0,105 105,365 925,1170 1170,1260 1260,1395
of pages,| we want those
|我们希望这些页面是连续的，

218
00:06:25,770 --> 00:06:26,655
0,210 210,345 345,435 435,780 780,885
pages to be sequential,| when
|当我们把那些页面放入内存时。

219
00:06:26,655 --> 00:06:27,330
0,120 120,255 255,390 390,540 540,675
we, when we bring those

220
00:06:27,330 --> 00:06:28,580
0,180 180,500
into memory.|
|

221
00:06:29,300 --> 00:06:30,235
0,245 245,335 335,485 485,710 710,935
Then the next thing to
然后要考虑的下一件事是，

222
00:06:30,235 --> 00:06:32,065
0,195 195,485 1225,1530 1530,1695 1695,1830
consider is,| when we have
|我们何时必须读取内存中的内容，

223
00:06:32,065 --> 00:06:32,830
0,120 120,255 255,450 450,630 630,765
to go read things in

224
00:06:32,830 --> 00:06:34,680
0,260 640,885 885,990 990,1250 1450,1850
memory,| and this is typically
|这通常是按需完成的，意思是，

225
00:06:34,760 --> 00:06:36,865
0,305 305,575 575,940 990,1390 1800,2105
done on demand, meaning,| we'll
|我们将在稍后看到预取，

226
00:06:36,865 --> 00:06:37,870
0,150 150,555 555,630 630,750 750,1005
see prefetching in a second,|
|

227
00:06:37,870 --> 00:06:38,845
0,240 240,390 390,495 495,750 750,975
but you're not just,| the
但你不仅仅是，|系统只是随机地读取东西，

228
00:06:38,845 --> 00:06:40,135
0,240 240,525 525,720 720,1080 1080,1290
system just go randomly reading

229
00:06:40,135 --> 00:06:41,130
0,240 240,390 390,480 480,660 660,995
things,| because it wants to,|
|因为它想要这样做，|

230
00:06:42,290 --> 00:06:43,300
0,400 420,665 665,875 875,935 935,1010
if you insert a bunch
如果你插入了一堆数据，

231
00:06:43,300 --> 00:06:44,080
0,120 120,375 375,615 615,690 690,780
of data| and then you
|然后你从来没有去读它，

232
00:06:44,080 --> 00:06:44,935
0,150 150,300 300,435 435,615 615,855
never go read it,| it's
|它就不会读回内存，

233
00:06:44,935 --> 00:06:46,170
0,120 120,270 270,545 685,960 960,1235
not gonna go, go read

234
00:06:46,310 --> 00:06:47,920
0,395 395,680 680,970 1230,1505 1505,1610
back into memory| just for
|只是为了[]，

235
00:06:47,920 --> 00:06:48,570
0,75 75,165 165,255 255,375 375,650
the [] of it, right,|
|

236
00:06:49,010 --> 00:06:50,260
0,260 260,520 720,1055 1055,1145 1145,1250
and so it's gonna be
所以，它将按需提供，

237
00:06:50,260 --> 00:06:51,220
0,195 195,480 480,705 705,855 855,960
on demand,| we have to
|我们必须从磁盘中获取东西，并将它们带到内存中。

238
00:06:51,220 --> 00:06:53,365
0,105 105,270 270,560 1540,1830 1830,2145
go get things from disk

239
00:06:53,365 --> 00:06:54,090
0,105 105,225 225,330 330,450 450,725
and bring them to memory.|
|

240
00:06:54,770 --> 00:06:55,810
0,260 260,395 395,530 530,905 905,1040
And then the question's gonna
然后问题是，

241
00:06:55,810 --> 00:06:56,995
0,290 520,825 825,960 960,1065 1065,1185
be,| when do we want
|我们什么时候想要把它从内存中驱逐出去，

242
00:06:56,995 --> 00:06:58,380
0,75 75,435 435,755 805,1095 1095,1385
to evict that from memory,

243
00:06:59,960 --> 00:07:01,120
0,400 540,800 800,920 920,1010 1010,1160
right,| what was the last
|它最后一次访问是什么时候，如何访问，

244
00:07:01,120 --> 00:07:02,310
0,180 180,405 405,690 690,900 900,1190
time it's accesssed, how was

245
00:07:02,330 --> 00:07:03,985
0,320 320,515 515,755 755,1120 1380,1655
access,| was it updated since
|自从我们把它放入内存后它是否更新了，

246
00:07:03,985 --> 00:07:04,645
0,150 150,270 270,360 360,480 480,660
we brought it into memory|
|

247
00:07:04,645 --> 00:07:05,260
0,210 210,345 345,420 420,510 510,615
and therefore we need to
所以我们需要将它写出去，

248
00:07:05,260 --> 00:07:06,595
0,135 135,255 255,500 910,1230 1230,1335
write it out,| we're not
|我们不会谈论，

249
00:07:06,595 --> 00:07:07,690
0,105 105,195 195,330 330,605 865,1095
going to talk about,| how
|如何确保我们能够，

250
00:07:07,690 --> 00:07:08,430
0,75 75,195 195,330 330,465 465,740
to make sure that we

251
00:07:09,440 --> 00:07:10,600
0,400
can,|
|

252
00:07:10,670 --> 00:07:11,935
0,290 290,485 485,790 870,1130 1130,1265
save our changes in case
保存我们的更改，以防发生崩溃或故障，

253
00:07:11,935 --> 00:07:12,790
0,120 120,240 240,510 510,750 750,855
of a crash or a

254
00:07:12,790 --> 00:07:14,170
0,260 730,1065 1065,1185 1185,1290 1290,1380
failure,| we'll talk a little
|我们将在最后讨论这个，

255
00:07:14,170 --> 00:07:15,210
0,210 210,465 465,660 660,795 795,1040
about that at the end,|
|

256
00:07:15,560 --> 00:07:16,590
0,275 275,500 500,695 695,785 785,1030
but that will be {a,foucs},
但这将是期中考试后一节课的主要关注点，

257
00:07:16,820 --> 00:07:19,705
0,335 335,670 750,1150 2310,2645 2645,2885
major focus, for major focus

258
00:07:19,705 --> 00:07:21,130
0,150 150,255 255,515 775,1155 1155,1425
of a lecture after the,

259
00:07:21,130 --> 00:07:22,390
0,150 150,590 700,945 945,1065 1065,1260
the midterm,| this is really
|这实际上是关于，

260
00:07:22,390 --> 00:07:23,500
0,300 300,615 615,810 810,930 930,1110
about,| okay, I got to
|好的，我必须决定要驱逐哪些数据，

261
00:07:23,500 --> 00:07:25,200
0,320 640,930 930,1170 1170,1350 1350,1700
decide what data to evict,|
|

262
00:07:25,400 --> 00:07:26,200
0,260 260,350 350,440 440,575 575,800
how do I make that
我该如何做出这个决定。

263
00:07:26,200 --> 00:07:27,420
0,350
decision.|
|

264
00:07:28,940 --> 00:07:29,755
0,260 260,395 395,545 545,665 665,815
And so this is that
这是我之前展示的同一张图，

265
00:07:29,755 --> 00:07:30,870
0,195 195,585 585,720 720,855 855,1115
same diagram I showed before,|
|

266
00:07:31,760 --> 00:07:33,550
0,245 245,365 365,640 750,1150 1410,1790
what we have the database
我们有数据库文件在磁盘上，

267
00:07:33,550 --> 00:07:34,675
0,315 315,510 510,810 810,915 915,1125
file on disk| and it's
|它被分成了几个页面，

268
00:07:34,675 --> 00:07:35,155
0,135 135,285 285,360 360,405 405,480
broken up to a bunch

269
00:07:35,155 --> 00:07:36,810
0,105 105,365 925,1200 1200,1365 1365,1655
of pages,| and then now
|然后我们今天要讨论的是，

270
00:07:36,860 --> 00:07:37,855
0,260 260,425 425,560 560,725 725,995
what we're talking about today

271
00:07:37,855 --> 00:07:38,845
0,285 285,480 480,675 675,840 840,990
is,| this piece here called
|这个叫做缓冲池的部分，

272
00:07:38,845 --> 00:07:40,645
0,135 135,420 420,695 1315,1710 1710,1800
the buffer pool,| I'll call
|我称之为缓冲池管理器，

273
00:07:40,645 --> 00:07:41,460
0,90 90,180 180,435 435,555 555,815
it the buffer pool manager,|
|

274
00:07:41,600 --> 00:07:42,970
0,365 365,725 725,995 995,1175 1175,1370
some places or some of
某些地方或某些系统称为缓冲池缓存管理器，

275
00:07:42,970 --> 00:07:45,775
0,255 255,585 585,950 2320,2580 2580,2805
systems called the the buffer

276
00:07:45,775 --> 00:07:49,620
0,150 150,455 1555,1890 1890,2225 3355,3845
pool cache, cache manager, {}|
|

277
00:07:49,880 --> 00:07:50,920
0,245 245,380 380,650 650,905 905,1040
they all basically mean the
它们基本上都有相同的意思，

278
00:07:50,920 --> 00:07:52,050
0,165 165,390 390,675 675,825 825,1130
same thing,| it's the memory
|它他是数据库系统从操作系统分配内存，并自行控制。

279
00:07:52,100 --> 00:07:53,125
0,275 275,410 410,635 635,890 890,1025
that the database system is

280
00:07:53,125 --> 00:07:53,935
0,90 90,165 165,525 525,660 660,810
going to allocate from the

281
00:07:53,935 --> 00:07:55,390
0,195 195,485 655,1005 1005,1275 1275,1455
operating system and control on

282
00:07:55,390 --> 00:07:56,280
0,120 120,380
its own.|
|

283
00:07:57,060 --> 00:07:58,030
0,275 275,410 410,545 545,695 695,970
So when you have your
所以当你有了你的执行引擎，

284
00:07:58,230 --> 00:08:00,110
0,320 320,640 1110,1385 1385,1595 1595,1880
execution engine,| it starts doing
|它开始做一些事情，

285
00:08:00,110 --> 00:08:01,955
0,315 315,585 585,1425 1425,1665 1665,1845
something,| like, it's, say it's
|比如，它运行一个查询，

286
00:08:01,955 --> 00:08:03,590
0,135 135,285 285,575 1225,1455 1455,1635
running a query,| It doesn't
|它不一定非得这样，但它是有可能的，

287
00:08:03,590 --> 00:08:04,390
0,165 165,345 345,450 450,540 540,800
have to, but it could,|
|

288
00:08:05,100 --> 00:08:06,020
0,305 305,500 500,665 665,800 800,920
and at some point, it
在某个点上，它说我需要获取第二页，

289
00:08:06,020 --> 00:08:06,800
0,180 180,405 405,555 555,630 630,780
says I need to get

290
00:08:06,800 --> 00:08:09,005
0,225 225,465 465,800 1660,1980 1980,2205
page number two,| so again
|所以我们从磁盘获取页面目录，

291
00:08:09,005 --> 00:08:09,755
0,165 165,315 315,450 450,555 555,750
we go get the page

292
00:08:09,755 --> 00:08:10,955
0,390 390,555 555,900 900,1050 1050,1200
directory from disk,| bring that
|并将其放入内存，

293
00:08:10,955 --> 00:08:11,825
0,150 150,390 390,600 600,765 765,870
into memory,| if it's not
|如果它还不在那里，

294
00:08:11,825 --> 00:08:13,145
0,210 210,545 835,1095 1095,1200 1200,1320
already there,| look on our
|查看我们的页面目录，

295
00:08:13,145 --> 00:08:14,000
0,195 195,540 540,615 615,795 795,855
page directory| and that's going
|它将告诉我们第二页，

296
00:08:14,000 --> 00:08:14,525
0,75 75,150 150,225 225,345 345,525
to tell us our page

297
00:08:14,525 --> 00:08:15,695
0,210 210,465 465,780 780,915 915,1170
number two,| here's the file
|这是在哪里找到该特定页面的文件和偏移量，

298
00:08:15,695 --> 00:08:17,120
0,210 210,435 435,815 1045,1305 1305,1425
and the offset where to

299
00:08:17,120 --> 00:08:18,250
0,165 165,375 375,570 570,795 795,1130
find that that particular page,|
|

300
00:08:18,720 --> 00:08:19,640
0,260 260,425 425,650 650,800 800,920
we go fetch that in
我们将其放入内存中，

301
00:08:19,640 --> 00:08:21,275
0,260 670,915 915,1160 1240,1515 1515,1635
memory,| put into one of
|放入缓冲池中的一个空闲空间，

302
00:08:21,275 --> 00:08:22,805
0,245 625,930 930,1200 1200,1410 1410,1530
our free space in our

303
00:08:22,805 --> 00:08:24,380
0,270 270,545 955,1215 1215,1365 1365,1575
buffer pool| and then give
|然后返回给执行引擎，

304
00:08:24,380 --> 00:08:26,000
0,255 255,590 610,945 945,1275 1275,1620
back the execution engine,| a
|一个指向位于缓冲池中的页面的指针。

305
00:08:26,000 --> 00:08:27,995
0,560 610,855 855,1020 1020,1340 1690,1995
pointer to that page sitting

306
00:08:27,995 --> 00:08:29,240
0,150 150,240 240,510 510,785
in the buffer pool.|
|

307
00:08:31,210 --> 00:08:33,720
0,245 245,490 1170,1580 1580,1840 2220,2510
So now let's say,| again,
现在让我们假设，|我们运行某种驱逐策略、替换政策，

308
00:08:33,720 --> 00:08:34,760
0,165 165,375 375,615 615,780 780,1040
we run some kind of

309
00:08:35,020 --> 00:08:36,825
0,440 440,790 960,1355 1355,1595 1595,1805
eviction policy, replacement policy| and
|无论出于什么原因，我们决定删除第二页，

310
00:08:36,825 --> 00:08:38,085
0,180 180,465 465,735 735,990 990,1260
we decide to remove page

311
00:08:38,085 --> 00:08:39,675
0,335 445,765 765,1005 1005,1320 1320,1590
two, for whatever reason,| because
|因为我们需要更多空间，

312
00:08:39,675 --> 00:08:41,010
0,120 120,270 270,480 480,785 1075,1335
we need more space,| we
|我们运行一堆其他数据，

313
00:08:41,010 --> 00:08:41,520
0,120 120,210 210,300 300,390 390,510
run a bunch of other

314
00:08:41,520 --> 00:08:43,545
0,210 210,390 390,600 600,830 1750,2025
data,| it doesn't matter,| but
|这都无关紧要，|但是现在，当执行引擎回来，

315
00:08:43,545 --> 00:08:44,760
0,210 210,405 405,645 645,945 945,1215
now when the execution engine

316
00:08:44,760 --> 00:08:45,690
0,240 240,435 435,600 600,750 750,930
comes back| and says I
|并说给我第二页时，

317
00:08:45,690 --> 00:08:46,700
0,135 135,255 255,450 450,690 690,1010
give me page two again,|
|

318
00:08:47,480 --> 00:08:48,245
0,180 180,300 300,435 435,600 600,765
it's not in memory,| you
它不在内存中，|你必须到磁盘上获取它，

319
00:08:48,245 --> 00:08:49,310
0,90 90,180 180,425 565,840 840,1065
got to go to disk

320
00:08:49,310 --> 00:08:50,645
0,105 105,255 255,530 820,1110 1110,1335
and get it,| but this
|但这一次它可能会落在我们的缓冲池中的不同位置，

321
00:08:50,645 --> 00:08:51,725
0,270 270,525 525,705 705,870 870,1080
time it actually might land

322
00:08:51,725 --> 00:08:53,710
0,150 150,270 270,545 625,1025 1585,1985
in a different location in

323
00:08:53,820 --> 00:08:55,560
0,400 480,890 890,1150
our buffer pool,|
|

324
00:08:55,950 --> 00:08:57,590
0,400 480,755 755,935 935,1240 1320,1640
and again, our system, the
我们的系统，执行引擎，

325
00:08:57,590 --> 00:08:58,625
0,210 210,450 450,735 735,900 900,1035
execution engine,| all the other
|缓冲池之上的系统的所有其他部分，

326
00:08:58,625 --> 00:08:59,435
0,180 180,285 285,360 360,570 570,810
parts of the system above

327
00:08:59,435 --> 00:09:01,060
0,135 135,405 405,665 1045,1335 1335,1625
the buffer pool,| they should
|它们显然不应该，不关心它现在在不同的位置。

328
00:09:01,080 --> 00:09:03,470
0,350 350,680 680,1060 1650,2045 2045,2390
obviously not be, not, not

329
00:09:03,470 --> 00:09:04,445
0,405 405,555 555,750 750,870 870,975
cared that it's now in

330
00:09:04,445 --> 00:09:05,900
0,105 105,360 360,755
a different location.|
|

331
00:09:06,780 --> 00:09:07,805
0,275 275,425 425,635 635,845 845,1025
This is different than {mmap
这和 mmap 不一样，

332
00:09:07,805 --> 00:09:09,170
0,305 565,900 900,1095 1095,1230 1230,1365
-}, right,| if you {mmap
|如果你 mmap 一个文件，内存映射文件，

333
00:09:09,170 --> 00:09:10,055
0,120 120,270 270,540 540,750 750,885
-} a file, the memory

334
00:09:10,055 --> 00:09:11,540
0,210 210,515 1045,1290 1290,1380 1380,1485
map file,| when you bring
|当你把它带到你的地址空间，

335
00:09:11,540 --> 00:09:12,305
0,120 120,210 210,330 330,525 525,765
that in your address space,|
|

336
00:09:12,305 --> 00:09:14,510
0,495 495,660 660,935 1195,1595 1885,2205
anytime you jump to that
任何时候你跳到那个 mmap 文件地址空间，

337
00:09:14,510 --> 00:09:15,470
0,165 165,270 270,450 450,705 705,960
sort of mmap file address

338
00:09:15,470 --> 00:09:17,045
0,320 730,1125 1125,1290 1290,1425 1425,1575
space,| you're always gonna get
|你总是会得到相同的页面，

339
00:09:17,045 --> 00:09:18,520
0,135 135,330 330,665 985,1230 1230,1475
the same page| or the
|或者操作系统会为你保证这一点，

340
00:09:18,570 --> 00:09:20,255
0,365 365,605 605,880 1140,1430 1430,1685
operating system is gonna guarantee

341
00:09:20,255 --> 00:09:21,485
0,255 255,435 435,725 865,1110 1110,1230
that for you,| it may
|当你访问它时，它可能不在内存中，

342
00:09:21,485 --> 00:09:22,295
0,150 150,285 285,435 435,645 645,810
not be in memory when

343
00:09:22,295 --> 00:09:23,075
0,225 225,480 480,600 600,690 690,780
you access it| and you
|你安装它，获取它，

344
00:09:23,075 --> 00:09:25,370
0,245 265,600 600,1085 1765,2010 2010,2295
get get installed, get fetches

345
00:09:25,370 --> 00:09:26,495
0,260 460,690 690,870 870,1020 1020,1125
in,| but it's always gonna
|但它总是在同一个地址空间中。

346
00:09:26,495 --> 00:09:27,110
0,75 75,135 135,225 225,390 390,615
be in the same address

347
00:09:27,110 --> 00:09:28,040
0,320
space.|
|

348
00:09:28,050 --> 00:09:29,090
0,275 275,485 485,725 725,935 935,1040
In our system, we're not
在我们的系统中，我们不会这样做，

349
00:09:29,090 --> 00:09:29,825
0,120 120,210 210,360 360,540 540,735
going to do that,| the
|相同的页面可以位于不同的位置，

350
00:09:29,825 --> 00:09:30,740
0,285 285,600 600,765 765,825 825,915
same page can be in

351
00:09:30,740 --> 00:09:32,030
0,240 240,615 615,930 930,1110 1110,1290
different locations,| every time it's
|每次它调入和调出内存时，

352
00:09:32,030 --> 00:09:32,600
0,135 135,255 255,345 345,465 465,570
brought in and out of

353
00:09:32,600 --> 00:09:33,560
0,230
memory,|
|

354
00:09:34,290 --> 00:09:35,590
0,245 245,490 540,815 815,995 995,1300
because we need that freedom,|
因为我们需要这种自由，|

355
00:09:35,640 --> 00:09:37,115
0,400 630,905 905,1100 1100,1400 1400,1475
because who knows what's going
因为谁知道内存中会有什么，

356
00:09:37,115 --> 00:09:37,610
0,90 90,165 165,240 240,375 375,495
to be in memory,| the
|下一次我们去取页面时。

357
00:09:37,610 --> 00:09:38,450
0,120 120,375 375,600 600,705 705,840
next time we go fetch

358
00:09:38,450 --> 00:09:39,520
0,105 105,350
a page.|
|

359
00:09:40,630 --> 00:09:41,505
0,260 260,410 410,560 560,695 695,875
So again, this is much
这与调用 malloc 有很大不同，

360
00:09:41,505 --> 00:09:44,295
0,180 180,455 1255,1605 1605,2135 2515,2790
different than calling malloc,| you
|你调用 malloc ，

361
00:09:44,295 --> 00:09:45,930
0,180 180,695 1075,1335 1335,1485 1485,1635
call malloc,| the OS is
|操作系统为你处理这一切，

362
00:09:45,930 --> 00:09:46,575
0,165 165,315 315,390 390,480 480,645
taking care of this all

363
00:09:46,575 --> 00:09:48,330
0,165 165,425 895,1185 1185,1470 1470,1755
for you,| the database system
|数据库系统管理所有这些内存，

364
00:09:48,330 --> 00:09:50,000
0,290 670,1020 1020,1245 1245,1395 1395,1670
is managing all this memory,|
|

365
00:09:50,740 --> 00:09:51,370
0,135 135,255 255,405 405,525 525,630
because as we see as
因为正如我们所看到的那样，

366
00:09:51,370 --> 00:09:52,330
0,105 105,240 240,435 435,765 765,960
we go along,| it's always
|它总是处于更好的位置，

367
00:09:52,330 --> 00:09:52,660
0,90 90,135 135,180 180,240 240,330
going to be in a

368
00:09:52,660 --> 00:09:54,100
0,195 195,530 940,1185 1185,1305 1305,1440
better position| to make the
|以做出如何优化这一点的最佳决定。

369
00:09:54,100 --> 00:09:55,195
0,210 210,495 495,675 675,825 825,1095
best decision how to optimize

370
00:09:55,195 --> 00:09:56,380
0,305
this.|
|

371
00:09:57,370 --> 00:09:58,485
0,305 305,485 485,620 620,920 920,1115
{All,right}, so for today's agenda,|
好的，在今天的议程中，|

372
00:09:58,485 --> 00:09:59,385
0,180 180,210 210,425 505,765 765,900
we're going to talk about
我们将从高级别讨论缓冲区管理器是什么，

373
00:09:59,385 --> 00:10:00,375
0,315 315,420 420,495 495,735 735,990
{high,level,of} what a buffer manager

374
00:10:00,375 --> 00:10:02,880
0,365 625,960 960,1295 1465,2045 2245,2505
is,| talk some optimizations we
|讨论一些我们可以添加的优化，

375
00:10:02,880 --> 00:10:05,100
0,195 195,450 450,630 630,890 1960,2220
can add to it,| the
|顺序改变了，

376
00:10:05,100 --> 00:10:06,030
0,225 225,450 450,660 660,780 780,930
order actually switched,| then we'll
|然后我们将讨论缓冲区替换策略，

377
00:10:06,030 --> 00:10:07,280
0,105 105,255 255,615 615,975 975,1250
talk about buffer replacement policies,|
|

378
00:10:07,900 --> 00:10:08,955
0,275 275,440 440,590 590,725 725,1055
then Disk {I/O -} scheduling,|
然后磁盘 I/O 调度，|

379
00:10:08,955 --> 00:10:09,885
0,135 135,240 240,420 420,600 600,930
and then we'll briefly mention
然后我们会简单地提到，

380
00:10:09,885 --> 00:10:11,820
0,395 625,960 960,1140 1140,1410 1410,1935
that,| there's other memory pools
|还有其他内存池在我们的数据库系统中，

381
00:10:11,820 --> 00:10:13,620
0,380 550,950
in, {}

382
00:10:13,720 --> 00:10:14,820
0,305 305,455 455,560 560,785 785,1100
in, in our database system,|
|

383
00:10:14,820 --> 00:10:16,125
0,255 255,435 435,585 585,860 1000,1305
that may not be always
可能并不总是得到缓冲池管理器，

384
00:10:16,125 --> 00:10:17,100
0,315 315,510 510,705 705,825 825,975
backed by a buffer pool

385
00:10:17,100 --> 00:10:19,725
0,290 500,1510 1510,1755 1755,2160 2160,2400 2400,2625
manager,| {might,be,like} an ephemeral cache for
|可能是某些东西的[临时缓存]。

386
00:10:19,725 --> 00:10:21,040
0,180 180,485
certain things.|
|

387
00:10:21,660 --> 00:10:22,715
0,245 245,490 570,920 920,980 980,1055
So again, I'm going to
所以，我将它称为缓冲池管理器，

388
00:10:22,715 --> 00:10:23,410
0,75 75,135 135,195 195,465 465,695
call it a {buffer,pool} manager,|
|

389
00:10:23,430 --> 00:10:24,545
0,275 275,620 620,755 755,875 875,1115
the textbook calls a buffer
教科书中称其为缓冲区管理器，

390
00:10:24,545 --> 00:10:27,485
0,245 745,1035 1035,1325 2365,2820 2820,2940
manager,| I think Oracle might
|我想 Oracle 可能会把它称为缓冲区缓存，

391
00:10:27,485 --> 00:10:28,775
0,165 165,300 300,525 525,785 1015,1290
call the buffer cache,| we're
|我们都在讨论相同的东西。

392
00:10:28,775 --> 00:10:29,390
0,120 120,270 270,360 360,465 465,615
all talking about the same

393
00:10:29,390 --> 00:10:30,720
0,290
thing.|
|

394
00:10:32,220 --> 00:10:32,930
0,215 215,275 275,380 380,530 530,710
So at a high level,
所以，在高级别上，看起来是这样的，

395
00:10:32,930 --> 00:10:34,655
0,150 150,285 285,560 1210,1470 1470,1725
looks like this,| again, it's
|这只是我们从操作系统分配的一个内存区域，

396
00:10:34,655 --> 00:10:35,770
0,255 255,495 495,690 690,855 855,1115
just a region of memory

397
00:10:35,940 --> 00:10:37,685
0,400 780,1085 1085,1475 1475,1595 1595,1745
that we've allocated from the

398
00:10:37,685 --> 00:10:39,310
0,305 865,1155 1155,1320 1320,1380 1380,1625
OS| and we're going to
|我们将其逻辑地分成固定大小的页面，

399
00:10:39,630 --> 00:10:41,020
0,620 620,830 830,935 935,1085 1085,1390
logically chunk it up into

400
00:10:41,340 --> 00:10:43,145
0,275 275,470 470,790 1260,1565 1565,1805
fixed size pages,| again based
|根据数据库系统的页面大小，

401
00:10:43,145 --> 00:10:44,510
0,195 195,330 330,570 570,935 1045,1365
on the page size of

402
00:10:44,510 --> 00:10:45,980
0,165 165,375 375,740
the database system,

403
00:10:45,980 --> 00:10:48,290
0,320 820,1080 1080,1215 1215,1490 1870,2310
right,| we said 8, Postgres
|我们说 Postgres 是 8 千字节，

404
00:10:48,290 --> 00:10:49,760
0,120 120,270 270,795 795,1245 1245,1470
is 8 kilobytes,| MySQL 16
|MySQL 是 16 千字节，可以有压缩大小，

405
00:10:49,760 --> 00:10:51,185
0,510 510,630 630,795 795,1095 1095,1425
kilobytes, could have compression sizes,

406
00:10:51,185 --> 00:10:53,105
0,395 895,1245 1245,1455 1455,1740 1740,1920
right,| doesn't matter,| we're breaking
|无关紧要，|我们根据这些页面大小对其进行了细分。

407
00:10:53,105 --> 00:10:54,635
0,180 180,425 1045,1305 1305,1410 1410,1530
it up based on those

408
00:10:54,635 --> 00:10:56,000
0,135 135,425
page sizes.|
|

409
00:10:56,120 --> 00:10:58,300
0,275 275,550 1050,1450 1560,1940 1940,2180
And then an entry or
然后在我们的缓冲池内存中的一个条目或位置，

410
00:10:58,300 --> 00:11:00,450
0,255 255,650 910,1245 1245,1580 1750,2150
a location in our {buffer,pool}

411
00:11:00,470 --> 00:11:02,215
0,400 870,1160 1160,1310 1310,1460 1460,1745
memory,| that we could use
|我们可以用它来安装页面，

412
00:11:02,215 --> 00:11:03,480
0,330 330,615 615,855 855,1005 1005,1265
to, to install a page,|
|

413
00:11:04,100 --> 00:11:04,735
0,275 275,320 320,395 395,515 515,635
we're going to call that
我们把它称为 frame 。

414
00:11:04,735 --> 00:11:06,160
0,180 180,515
a frame.|
|

415
00:11:06,420 --> 00:11:07,685
0,260 260,520 660,905 905,1070 1070,1265
So think the system boots
所以，考虑系统启动，

416
00:11:07,685 --> 00:11:09,230
0,195 195,375 375,555 555,1085 1285,1545
up,| it calls malloc, gets
|它调用 malloc ，获取一堆内存，

417
00:11:09,230 --> 00:11:10,520
0,90 90,195 195,330 330,590 1000,1290
a bunch of memory| and
|然后说将其拆分，并将其划分为 frame ，

418
00:11:10,520 --> 00:11:11,765
0,290 520,825 825,1005 1005,1110 1110,1245
then say break it up

419
00:11:11,765 --> 00:11:12,560
0,270 270,495 495,570 570,630 630,795
and divide it up into

420
00:11:12,560 --> 00:11:14,765
0,350 700,960 960,1140 1140,1460 1930,2205
frames,| and then as the
|然后，随着数据库系统或执行引擎的其他部分或任何东西开始请求页面，

421
00:11:14,765 --> 00:11:15,785
0,225 225,465 465,600 600,765 765,1020
database system or other parts

422
00:11:15,785 --> 00:11:16,820
0,195 195,390 390,645 645,870 870,1035
of the the execution engine

423
00:11:16,820 --> 00:11:19,390
0,150 150,440 1240,1640 1840,2280 2280,2570
or whatever start requesting pages,|
|

424
00:11:20,070 --> 00:11:20,765
0,305 305,350 350,410 410,500 500,695
we're going to make an
我们要将这些页面从磁盘复制到内存中，

425
00:11:20,765 --> 00:11:22,300
0,330 330,725 775,1050 1050,1230 1230,1535
exact copy of the pages

426
00:11:22,830 --> 00:11:24,860
0,320 320,880 900,1250 1250,1600 1740,2030
from disk into memory| and,
|然后放入其中一个 frame 中，

427
00:11:24,860 --> 00:11:25,535
0,210 210,375 375,435 435,540 540,675
and put it into one

428
00:11:25,535 --> 00:11:27,020
0,75 75,210 210,545 1045,1305 1305,1485
of these frames,| the reason
|我们之所以称之为 frame ，

429
00:11:27,020 --> 00:11:27,485
0,150 150,225 225,300 300,375 375,465
why we have to call

430
00:11:27,485 --> 00:11:28,505
0,135 135,405 405,660 660,840 840,1020
it frames is,| because we're
|因为我们的术语快用完了，

431
00:11:28,505 --> 00:11:29,915
0,120 120,270 270,390 390,665 1135,1410
running out of terms,| I
|我不能称它为页面，

432
00:11:29,915 --> 00:11:30,560
0,195 195,255 255,315 315,405 405,645
can't call it a page,|
|

433
00:11:30,560 --> 00:11:31,280
0,285 285,360 360,405 405,510 510,720
can't call it a block,|
也不能称其为块，|

434
00:11:31,280 --> 00:11:32,110
0,165 165,315 315,390 390,540 540,830
because we've already used that,|
因为我们已经使用过了，|

435
00:11:32,490 --> 00:11:33,395
0,320 320,395 395,470 470,590 590,905
can't call it a slot,|
不能称之为插槽，|

436
00:11:33,395 --> 00:11:34,310
0,330 330,495 495,570 570,675 675,915
because we have a slot
因为我们有 slot array ，

437
00:11:34,310 --> 00:11:35,945
0,320 640,1005 1005,1260 1260,1410 1410,1635
array,| so for whatever reason,
|无论出于什么原因，我们称其为 frame 。

438
00:11:35,945 --> 00:11:36,515
0,270 270,315 315,390 390,465 465,570
we're to call it a

439
00:11:36,515 --> 00:11:37,300
0,275
frame.|
|

440
00:11:38,630 --> 00:11:39,670
0,230 230,320 320,425 425,670 780,1040
All right, so again, so
好的，有人需要页面一，

441
00:11:39,670 --> 00:11:41,050
0,180 180,390 390,585 585,890 1120,1380
somebody needs page one,| then
|然后我们在缓冲池中找到一个空闲的 frame ，

442
00:11:41,050 --> 00:11:42,190
0,120 120,285 285,555 555,870 870,1140
we go find a free

443
00:11:42,190 --> 00:11:43,170
0,225 225,360 360,450 450,720 720,980
frame in our buffer pool|
|

444
00:11:43,310 --> 00:11:44,185
0,245 245,335 335,455 455,665 665,875
and we just copy that
然后将磁盘上的页面复制到内存中，

445
00:11:44,185 --> 00:11:45,360
0,195 195,420 420,750 750,885 885,1175
page on disk into memory,|
|

446
00:11:46,290 --> 00:11:47,390
0,305 305,515 515,740 740,935 935,1100
same thing here,| I need
这里也是一样，|我需要页面三，

447
00:11:47,390 --> 00:11:48,830
0,255 255,620 880,1170 1170,1305 1305,1440
page three,| find a free
|找一个空位，

448
00:11:48,830 --> 00:11:49,985
0,320 460,720 720,870 870,1035 1035,1155
slot,| and I copy it
|然后把它复制到内存中，

449
00:11:49,985 --> 00:11:51,340
0,135 135,345 345,665
into memory here,|
|

450
00:11:51,550 --> 00:11:52,905
0,260 260,470 470,820 960,1220 1220,1355
but again, here we can
但是，我们在这里可以看到，

451
00:11:52,905 --> 00:11:54,285
0,135 135,395 715,1050 1050,1245 1245,1380
see that,| page one and
|页面一和页面三在磁盘上不是连续的，

452
00:11:54,285 --> 00:11:55,650
0,225 225,450 450,615 615,810 810,1365
page three are not contiguous

453
00:11:55,650 --> 00:11:57,375
0,195 195,800 1120,1365 1365,1530 1530,1725
on disk,| because it's page
|因为页面二在它们之间，

454
00:11:57,375 --> 00:11:58,650
0,225 225,420 420,615 615,905 1015,1275
two in between them,| but
|但当我们将其放入缓冲池并将其放入内存时，

455
00:11:58,650 --> 00:11:59,205
0,135 135,285 285,405 405,480 480,555
when we put it in

456
00:11:59,205 --> 00:11:59,925
0,120 120,420 420,525 525,615 615,720
our buffer pool and bring

457
00:11:59,925 --> 00:12:01,365
0,60 60,105 105,180 180,425 1165,1440
it in a memory,| again,
|我们可以自由地将其放在我们想要的任何位置，

458
00:12:01,365 --> 00:12:02,175
0,225 225,360 360,495 495,600 600,810
we're free to put it

459
00:12:02,175 --> 00:12:03,180
0,210 210,435 435,735 735,900 900,1005
in any location that we

460
00:12:03,180 --> 00:12:04,000
0,260
want,|
|

461
00:12:04,220 --> 00:12:05,920
0,260 260,515 515,760
it doesn't matter.|
这无所谓。|

462
00:12:07,710 --> 00:12:09,665
0,245 245,490 840,1160 1160,1480 1560,1955
So now when dirty,| when
所以，现在当出现脏页的时候，|如果我们修改了这些页面中的一个，

463
00:12:09,665 --> 00:12:12,695
0,395 1885,2175 2175,2355 2355,2880 2880,3030
if if we modify one

464
00:12:12,695 --> 00:12:14,825
0,75 75,210 210,515 1615,1950 1950,2130
of these pages,| we're not
|我们不需要立即将数据刷新回磁盘，

465
00:12:14,825 --> 00:12:16,400
0,335 445,1020 1020,1185 1185,1410 1410,1575
gonna, we're not required to

466
00:12:16,400 --> 00:12:17,240
0,195 195,330 330,495 495,690 690,840
flush the data back to

467
00:12:17,240 --> 00:12:18,575
0,240 240,420 420,740 910,1185 1185,1335
disk right away,| and again
|我们将在期中考试结束后讨论耐久性和恢复，

468
00:12:18,575 --> 00:12:19,895
0,135 135,285 285,540 540,1065 1065,1320
we will cover durability and

469
00:12:19,895 --> 00:12:21,605
0,285 285,665 1045,1320 1320,1530 1530,1710
and recovery late after the

470
00:12:21,605 --> 00:12:22,850
0,425 655,915 915,1035 1035,1125 1125,1245
midterm,| but this is a
|但这是透写缓存和回写缓存之间的关键区别，

471
00:12:22,850 --> 00:12:24,200
0,180 180,470 520,920 1000,1260 1260,1350
key difference then between like

472
00:12:24,200 --> 00:12:24,980
0,90 90,240 240,420 420,630 630,780
a write through cache or

473
00:12:24,980 --> 00:12:26,740
0,90 90,255 255,465 465,770 1360,1760
a write back cache, right,|
|

474
00:12:27,120 --> 00:12:28,055
0,245 245,395 395,575 575,785 785,935
the write through cache in
透写缓存在操作系统中，

475
00:12:28,055 --> 00:12:28,955
0,120 120,375 375,600 600,720 720,900
the OS,| when you write
|当你将某些内容写入缓存时，

476
00:12:28,955 --> 00:12:31,295
0,305 1195,1500 1500,1635 1635,1895 2065,2340
something to the cache,| it
|它也会立即被写出到磁盘，

477
00:12:31,295 --> 00:12:32,585
0,210 210,480 480,815 865,1140 1140,1290
then gets immediately written out

478
00:12:32,585 --> 00:12:33,780
0,135 135,315 315,420 420,695
the disk as well,|
|

479
00:12:33,780 --> 00:12:34,755
0,180 180,270 270,435 435,660 660,975
in a write back cache,|
在回写缓存中，|

480
00:12:34,755 --> 00:12:35,870
0,345 345,510 510,645 645,810 810,1115
we'll write it in memory,|
我们会将其写入内存，|

481
00:12:36,760 --> 00:12:37,755
0,245 245,380 380,575 575,845 845,995
but we're not required to
但我们不需要立即将其写回，

482
00:12:37,755 --> 00:12:38,490
0,90 90,180 180,330 330,540 540,735
write it back right away,|
|

483
00:12:38,490 --> 00:12:39,120
0,180 180,255 255,330 330,420 420,630
we'll do it at some,
我们将在以后的某个时候做这件事，

484
00:12:39,120 --> 00:12:40,770
0,255 255,495 495,1500 1500,1560 1560,1650
some later point,| {there,be} a
|一个后台线程或一个驱逐策略做这件事。

485
00:12:40,770 --> 00:12:41,970
0,260 310,675 675,885 885,960 960,1200
background thread or an eviction

486
00:12:41,970 --> 00:12:43,580
0,285 285,525 525,630 630,890
policy that do this.|
|

487
00:12:43,740 --> 00:12:44,765
0,260 260,485 485,710 710,920 920,1025
And so we won't talk
所以我们今天不会讨论这个，

488
00:12:44,765 --> 00:12:45,860
0,105 105,255 255,540 540,795 795,1095
about this today,| but there'll,
|但是这里会有，

489
00:12:45,860 --> 00:12:47,090
0,240 240,315 315,560 820,1065 1065,1230
there'll be a,| think of
|考虑有一个单独的日志文件，预写日志，

490
00:12:47,090 --> 00:12:48,275
0,180 180,375 375,630 630,900 900,1185
there a separate log file,

491
00:12:48,275 --> 00:12:50,240
0,225 225,390 390,665 1375,1800 1800,1965
write ahead log,| that'll keep
|它将跟踪我们所做的更改，

492
00:12:50,240 --> 00:12:51,215
0,210 210,360 360,510 510,750 750,975
track of what changes we

493
00:12:51,215 --> 00:12:52,820
0,275 895,1170 1170,1335 1335,1440 1440,1605
made,| and we'll make sure
|我们将确保将它刷新到磁盘，

494
00:12:52,820 --> 00:12:53,645
0,195 195,375 375,525 525,720 720,825
that thing gets flushed a

495
00:12:53,645 --> 00:12:54,770
0,270 270,465 465,675 675,855 855,1125
disk,| before our dirty pages
|在我们的脏页刷新之前，

496
00:12:54,770 --> 00:12:55,700
0,350
do,|
|

497
00:12:56,540 --> 00:12:57,685
0,400 600,890 890,950 950,1025 1025,1145
we don't have to know
现在我们不必知道这个，

498
00:12:57,685 --> 00:12:59,410
0,165 165,300 300,465 465,785 1465,1725
that for now,| just to
|只需记住，即使我们可以更新页面，

499
00:12:59,410 --> 00:13:00,550
0,135 135,525 525,705 705,930 930,1140
be mindful that even though

500
00:13:00,550 --> 00:13:01,945
0,150 150,345 345,585 585,890 1120,1395
we may update pages,| we're
|我们也不需要立即将它们写回，在内存中。

501
00:13:01,945 --> 00:13:02,605
0,150 150,360 360,465 465,555 555,660
not required to write them

502
00:13:02,605 --> 00:13:03,720
0,150 150,345 345,615 615,855 855,1115
back right away in memory.|
|

503
00:13:06,490 --> 00:13:07,635
0,290 290,440 440,605 605,860 860,1145
I said that the internal
我说过，我们要使用的内部数据结构，

504
00:13:07,635 --> 00:13:08,550
0,300 300,585 585,810 810,840 840,915
data structure, we're going to

505
00:13:08,550 --> 00:13:09,435
0,165 165,315 315,465 465,660 660,885
use| to keep track of
|用来跟踪 frame 中实际内容（的内部数据结构），

506
00:13:09,435 --> 00:13:10,815
0,335 505,855 855,1080 1080,1215 1215,1380
what is actually in our

507
00:13:10,815 --> 00:13:12,060
0,335 745,1020 1020,1125 1125,1170 1170,1245
frames| is going to be
|将被称为页表，

508
00:13:12,060 --> 00:13:13,920
0,150 150,300 300,495 495,830 1600,1860
called the page table,| again,
|操作系统也有自己的页表，

509
00:13:13,920 --> 00:13:14,655
0,165 165,345 345,480 480,585 585,735
the OS has its own

510
00:13:14,655 --> 00:13:15,510
0,210 210,450 450,645 645,750 750,855
page table,| this is the
|这是数据库页表，

511
00:13:15,510 --> 00:13:17,060
0,260 430,720 720,1005 1005,1305 1305,1550
database page table,| it's better.|
|这样更好。|

512
00:13:18,460 --> 00:13:19,575
0,260 260,395 395,620 620,875 875,1115
And so it's typically going
它通常是一个固定大小的哈希表，

513
00:13:19,575 --> 00:13:20,505
0,75 75,240 240,480 480,690 690,930
to be a fixed size

514
00:13:20,505 --> 00:13:23,160
0,330 330,605 2125,2385 2385,2505 2505,2655
hash table,| that is just
|它只是在跟踪，

515
00:13:23,160 --> 00:13:24,260
0,195 195,390 390,555 555,840 840,1100
keeping track of,| here's the,
|这是我所有的 frame ，

516
00:13:24,460 --> 00:13:26,120
0,335 335,410 410,560 560,880 1260,1660
here's all my frames, right,|
|

517
00:13:26,440 --> 00:13:27,440
0,275 275,410 410,560 560,725 725,1000
identified by some frame ID|
由某个 frame ID 标识，|

518
00:13:27,910 --> 00:13:30,045
0,290 290,580 750,1220 1220,1510 1800,2135
and then here's the, here's
然后这是页面信息，

519
00:13:30,045 --> 00:13:32,175
0,245 625,1025 1045,1395 1395,1800 1800,2130
the page information,| that's, that's
|当前驻留在页面中，

520
00:13:32,175 --> 00:13:33,960
0,195 195,630 630,915 915,1205
currently residing in that,

521
00:13:34,900 --> 00:13:36,210
0,245 245,380 380,670 960,1220 1220,1310
in that page,| I could
|我可以只是指向该页面实际位置的指针，

522
00:13:36,210 --> 00:13:37,020
0,75 75,150 150,255 255,585 585,810
just be a pointer to

523
00:13:37,020 --> 00:13:37,920
0,210 210,345 345,480 480,645 645,900
where that page is actually

524
00:13:37,920 --> 00:13:39,120
0,350
located,|
|

525
00:13:39,120 --> 00:13:39,675
0,195 195,270 270,330 330,390 390,555
and we I have to
我们必须用 latch 来保护这个页表，

526
00:13:39,675 --> 00:13:41,390
0,240 240,545 685,990 990,1295 1315,1715
protect this page table with

527
00:13:41,740 --> 00:13:43,245
0,260 260,380 380,670 1050,1295 1295,1505
with a latch,| which I'll
|稍后我会描述一下，

528
00:13:43,245 --> 00:13:44,040
0,180 180,285 285,360 360,585 585,795
describe in a second,| think
|把它想象成一个 mutex ，

529
00:13:44,040 --> 00:13:44,685
0,60 60,120 120,210 210,435 435,645
of a { -}, like

530
00:13:44,685 --> 00:13:46,605
0,90 90,515 925,1325 1345,1680 1680,1920
a mutex,| that allows us
|它允许我们有多个线程或多个 worker

531
00:13:46,605 --> 00:13:48,750
0,150 150,330 330,665 835,1475 1855,2145
to have multiple threads or

532
00:13:48,750 --> 00:13:51,525
0,240 240,590 1870,2295 2295,2505 2505,2775
multiple workers| accessing the the
|在同一时间访问页表，

533
00:13:51,525 --> 00:13:52,290
0,240 240,405 405,570 570,675 675,765
the page table, at the

534
00:13:52,290 --> 00:13:53,490
0,165 165,470 820,1050 1050,1155 1155,1200
same time,| I don't want
|我不想使用术语线程，

535
00:13:53,490 --> 00:13:54,855
0,60 60,165 165,440 670,1200 1200,1365
to use term threads| and
|最好使用术语 worker ，

536
00:13:54,855 --> 00:13:55,905
0,305 415,735 735,840 840,945 945,1050
it's, it's better to use

537
00:13:55,905 --> 00:13:57,015
0,195 195,515 595,870 870,990 990,1110
terms workers,| because like in
|因为比如在 Postgres 中，在旧的系统中，

538
00:13:57,015 --> 00:13:59,355
0,485 745,1005 1005,1230 1230,1595 2095,2340
Postgres, in older systems,| they
|它们不是多线程的，它们是多进程的，

539
00:13:59,355 --> 00:14:00,530
0,180 180,315 315,420 420,660 660,1175
don't, they're not multi threaded,

540
00:14:00,700 --> 00:14:02,570
0,365 365,545 545,880 1320,1595 1595,1870
they're multi process| and so,
|但是想法仍然是一样的，

541
00:14:02,740 --> 00:14:03,720
0,335 335,590 590,755 755,860 860,980
but the idea is still

542
00:14:03,720 --> 00:14:04,410
0,120 120,315 315,525 525,630 630,690
the same,| we want to
|我们想要确保，

543
00:14:04,410 --> 00:14:05,025
0,120 120,270 270,360 360,435 435,615
make sure that,| if there's
|如果有多个 worker 访问和更新东西，

544
00:14:05,025 --> 00:14:06,345
0,180 180,510 510,915 915,1095 1095,1320
multiple workers touching things and

545
00:14:06,345 --> 00:14:07,845
0,255 255,515 685,945 945,1290 1290,1500
updating things,| they don't, they
|他们没有，

546
00:14:07,845 --> 00:14:09,660
0,165 165,395 1285,1545 1545,1725 1725,1815
don't have,| when we're in
|当我们处于临界区时，我们不会破坏东西。

547
00:14:09,660 --> 00:14:10,875
0,120 120,345 345,690 690,990 990,1215
the critical sections, we don't

548
00:14:10,875 --> 00:14:11,800
0,135 135,425
break things.|
|

549
00:14:13,290 --> 00:14:14,840
0,395 395,725 725,1040 1040,1325 1325,1550
So in addition to keeping
所以，除了跟踪，

550
00:14:14,840 --> 00:14:15,680
0,195 195,330 330,465 465,705 705,840
track of like,| here's the,
|这里是指向缓冲池和 frame 中的页面的指针，

551
00:14:15,680 --> 00:14:16,720
0,180 180,525 525,630 630,750 750,1040
the pointer to the page

552
00:14:17,400 --> 00:14:18,290
0,275 275,410 410,650 650,770 770,890
in our buffer pool and

553
00:14:18,290 --> 00:14:19,625
0,120 120,255 255,530 940,1230 1230,1335
in the frame,| we're also
|我们还将拥有附加元数据，

554
00:14:19,625 --> 00:14:20,750
0,90 90,135 135,240 240,480 480,1125
going to have additional metadata|
|

555
00:14:20,750 --> 00:14:22,145
0,255 255,615 615,900 900,1155 1155,1395
about how the pages are
关于页面在整个系统中的使用方式。

556
00:14:22,145 --> 00:14:24,340
0,210 210,545 1405,1740 1740,1935 1935,2195
being used throughout the system.|
|

557
00:14:25,300 --> 00:14:26,070
0,260 260,380 380,530 530,680 680,770
So the first thing we
所以，我们首先有的是一个脏标志，

558
00:14:26,070 --> 00:14:27,000
0,75 75,320 430,705 705,825 825,930
would have obviously is a

559
00:14:27,000 --> 00:14:28,050
0,225 225,525 525,735 735,885 885,1050
dirty flag,| that tells us
|它告诉我们查询是否更新了该页面，

560
00:14:28,050 --> 00:14:29,955
0,270 270,650 1090,1410 1410,1650 1650,1905
whether a query has updated

561
00:14:29,955 --> 00:14:31,050
0,165 165,425 445,720 720,870 870,1095
a page| since we last
|自从上次将页面放入内存以来，

562
00:14:31,050 --> 00:14:32,970
0,195 195,270 270,420 420,740 1570,1920
brought it into memory,| we'll
|我们还将有一个 Pin 或引用计数器，

563
00:14:32,970 --> 00:14:33,960
0,135 135,315 315,600 600,840 840,990
also have a Pin or

564
00:14:33,960 --> 00:14:35,835
0,240 240,620 1060,1395 1395,1650 1650,1875
reference counter,| that keeps track
|用来跟踪 worker 的数量，

565
00:14:35,835 --> 00:14:38,145
0,180 180,345 345,630 630,1025 2035,2310
of the number of, number

566
00:14:38,145 --> 00:14:40,425
0,135 135,395 1045,1445 1675,2025 2025,2280
of workers,| that require this
|它们需要该页面保留在内存中，

567
00:14:40,425 --> 00:14:41,510
0,240 240,480 480,675 675,825 825,1085
page to remain in memory|
|

568
00:14:42,100 --> 00:14:43,305
0,395 395,650 650,815 815,1100 1100,1205
and therefore it can't be
因此它不能被驱逐，当我们运行驱逐策略时，

569
00:14:43,305 --> 00:14:44,340
0,375 375,615 615,735 735,870 870,1035
evicted when we run our

570
00:14:44,340 --> 00:14:46,785
0,330 330,680 1690,2010 2010,2220 2220,2445
eviction policy, right,| so {for,each}
|所以每个页面，这里的页面三，

571
00:14:46,785 --> 00:14:49,365
0,335 1225,1560 1560,1785 1785,2075 2305,2580
page, page three here,| say
|比如在这个给定的时间有一些查询访问它，

572
00:14:49,365 --> 00:14:50,685
0,180 180,330 330,600 600,935 955,1320
there's some query that is

573
00:14:50,685 --> 00:14:52,050
0,375 375,635 805,1065 1065,1185 1185,1365
accessing it at this given

574
00:14:52,050 --> 00:14:53,550
0,320 730,1020 1020,1170 1170,1305 1305,1500
time,| so in our page
|所以，在我们的页表中，我们有一个小的计数器，

575
00:14:53,550 --> 00:14:54,360
0,240 240,435 435,555 555,645 645,810
table we have a little

576
00:14:54,360 --> 00:14:55,650
0,255 255,590 760,1080 1080,1140 1140,1290
counter,| says there's at least
|表示至少有一个 worker 在访问它，

577
00:14:55,650 --> 00:14:56,680
0,225 225,530
one worker,

578
00:14:57,205 --> 00:14:58,840
0,195 195,540 540,785
that's accessing it,|
|

579
00:14:59,740 --> 00:15:01,100
0,275 275,455 455,710 710,1010 1010,1360
and then now say if
然后现在，如果一个出现了另一个查询，

580
00:15:01,570 --> 00:15:02,860
0,400
a,

581
00:15:03,050 --> 00:15:04,710
0,305 305,515 515,680 680,970 1260,1660
another query comes along| and
|寻找不在我们的页表中的另一个页面，

582
00:15:04,850 --> 00:15:06,055
0,290 290,515 515,740 740,935 935,1205
was looking for another page,

583
00:15:06,055 --> 00:15:07,195
0,300 300,435 435,720 720,975 975,1140
that's not in our page

584
00:15:07,195 --> 00:15:09,190
0,305 1225,1545 1545,1680 1680,1815 1815,1995
table,| we'll put a latch
|我们会放一个 latch 在它上面，保护它，

585
00:15:09,190 --> 00:15:10,660
0,165 165,390 390,630 630,920 1180,1470
on it, protect it,| go
|去取我们需要的数据，

586
00:15:10,660 --> 00:15:11,550
0,225 225,375 375,510 510,645 645,890
fetch the data we need,|
|

587
00:15:11,630 --> 00:15:12,385
0,245 245,365 365,515 515,635 635,755
in this case we need
在这种情况下，我们需要页面二，

588
00:15:12,385 --> 00:15:14,020
0,210 210,545 715,1050 1050,1365 1365,1635
page two,| we update a
|我们更新缓冲池中的空闲 frame ，

589
00:15:14,020 --> 00:15:15,055
0,210 210,510 510,735 735,885 885,1035
free frame in our, in

590
00:15:15,055 --> 00:15:16,570
0,105 105,360 360,605 1075,1350 1350,1515
our buffer pool,| update the
|更新页表以指向该缓冲池，

591
00:15:16,570 --> 00:15:17,635
0,225 225,465 465,615 615,810 810,1065
page table to now point

592
00:15:17,635 --> 00:15:19,285
0,150 150,270 270,555 555,815 1375,1650
to this buffer pool,| update
|更新任何我们需要了解的元数据，

593
00:15:19,285 --> 00:15:20,590
0,255 255,945 945,1050 1050,1170 1170,1305
any metadata we need to

594
00:15:20,590 --> 00:15:22,280
0,165 165,390 390,690 690,1070
know about it,| like,
|比如，谁访问了它，

595
00:15:22,410 --> 00:15:23,645
0,395 395,725 725,890 890,1085 1085,1235
who accessed it,| when they
|他们最后一次访问它的时间等等，

596
00:15:23,645 --> 00:15:25,190
0,270 270,600 600,845 1075,1365 1365,1545
last accessed it and so

597
00:15:25,190 --> 00:15:27,220
0,290 940,1200 1200,1380 1380,1665 1665,2030
forth,| and then once this
|然后，一旦该查询完成了对页表的更新所需的任何操作，

598
00:15:27,900 --> 00:15:29,255
0,365 365,590 590,800 800,1070 1070,1355
query is done doing whatever

599
00:15:29,255 --> 00:15:30,185
0,300 300,540 540,705 705,840 840,930
its update needs to the

600
00:15:30,185 --> 00:15:31,400
0,135 135,425 655,915 915,1050 1050,1215
page table,| we can release
|我们就可以释放 latch ，

601
00:15:31,400 --> 00:15:33,650
0,150 150,440 1030,1430 1480,1880 1900,2250
the latch,| return that worker
|将 worker 返回到正在执行的任何操作，

602
00:15:33,650 --> 00:15:35,110
0,270 270,590 790,1065 1065,1200 1200,1460
back to whatever is doing,|
|

603
00:15:35,430 --> 00:15:36,380
0,245 245,335 335,485 485,710 710,950
and then now any other
然后现在任何其他查找页面二的 worker

604
00:15:36,380 --> 00:15:37,460
0,225 225,390 390,570 570,825 825,1080
worker that comes along looking

605
00:15:37,460 --> 00:15:38,735
0,180 180,360 360,680 820,1095 1095,1275
for page two| will find
|都将在此页表中找到它。

606
00:15:38,735 --> 00:15:39,850
0,255 255,480 480,645 645,825 825,1115
it in this page table.|
|

607
00:15:44,030 --> 00:15:45,920
0,290 290,485 485,790
Pretty simple, right?|
很简单，对吧？|

608
00:15:48,550 --> 00:15:49,580
0,230 230,335 335,530 530,740 740,1030
So I used this term
所以我用了 latch 这个词，

609
00:15:49,960 --> 00:15:53,340
0,430 1470,1870 2640,3110 3110,3230 3230,3380
latch| and purposely did not
|故意不说锁，

610
00:15:53,340 --> 00:15:54,780
0,225 225,560
say lock,|
|

611
00:15:55,450 --> 00:15:57,700
0,245 245,335 335,530 530,880
{anyone -} guess why.|
有人猜猜为什么。|

612
00:15:58,890 --> 00:16:00,680
0,400 780,1160 1160,1475 1475,1670 1670,1790
Yes.| { - - -}
是的。|

613
00:16:00,680 --> 00:16:02,050
0,260 310,585 585,795 795,1050 1050,1370

614
00:16:02,620 --> 00:16:03,675
0,260 260,395 395,545 545,740 740,1055
He says the standard locks
他说，我们拥有的标准锁，

615
00:16:03,675 --> 00:16:05,220
0,105 105,240 240,515 1105,1470 1470,1545
that we have,| locks and
|锁和 latch 是不同的，

616
00:16:05,220 --> 00:16:05,955
0,195 195,285 285,405 405,540 540,735
latches we have are different,|
|

617
00:16:05,955 --> 00:16:07,010
0,255 255,450 450,615 615,780 780,1055
different from who or what.|
不同于谁或什么。|

618
00:16:08,880 --> 00:16:09,810
0,120 120,270 270,495 495,735 735,930

619
00:16:09,810 --> 00:16:11,160
0,225 225,540 540,1320

620
00:16:16,560 --> 00:16:17,650
0,305 305,500 500,635 635,785 785,1090

621
00:16:19,570 --> 00:16:21,000
0,245 245,380 380,670 1020,1295 1295,1430
So he says,| he said
所以他说，|他说， latch 有一些数据库魔力，

622
00:16:21,000 --> 00:16:23,240
0,150 150,620 1150,1470 1470,1935 1935,2240
that there's that latches have

623
00:16:23,260 --> 00:16:26,505
0,400 630,1030 1740,2140 2730,3095 3095,3245
some database magic,| that's better
|这比锁更适合我们的目的。

624
00:16:26,505 --> 00:16:27,860
0,135 135,225 225,465 465,780 780,1355
for our purposes versus locks.|
|

625
00:16:29,740 --> 00:16:31,400
0,275 275,550
Not quite.|
不完全是。|

626
00:16:31,720 --> 00:16:36,030
0,400 3510,3770 3770,3905 3905,4085 4085,4310
Yes.| He said locks for
是的。|他说有锁是用户空间的，

627
00:16:36,030 --> 00:16:38,310
0,285 285,650 1420,1820 1900,2160 2160,2280
user space,| {} I mean,
|我的意思是，数据库系统在用户空间运行，

628
00:16:38,310 --> 00:16:39,270
0,120 120,300 300,555 555,780 780,960
the database system is running

629
00:16:39,270 --> 00:16:40,170
0,150 150,330 330,585 585,750 750,900
in user space,| but it's
|但是为了数据库中的逻辑内容，是的。

630
00:16:40,170 --> 00:16:41,895
0,780 780,1350 1350,1530 1530,1650 1650,1725
for logical things in the

631
00:16:41,895 --> 00:16:43,920
0,245 475,780 780,1085 1615,1890 1890,2025
database, correct, yes.| {So,right}, so
|所以这会让人们绊倒，

632
00:16:43,920 --> 00:16:44,820
0,165 165,360 360,540 540,750 750,900
this trips people up,| when
|当他们来自更像是操作系统背景的时候。

633
00:16:44,820 --> 00:16:45,795
0,120 120,300 300,510 510,765 765,975
they come from like like

634
00:16:45,795 --> 00:16:48,015
0,105 105,330 330,695 715,1115 1855,2220
a more OS background.| So
|所以，在数据库世界中，

635
00:16:48,015 --> 00:16:49,170
0,240 240,375 375,635 685,1005 1005,1155
in the database world,| we
|我们有锁和 latch 之间的区别，

636
00:16:49,170 --> 00:16:50,355
0,90 90,225 225,600 600,840 840,1185
have this distinction between locks

637
00:16:50,355 --> 00:16:51,580
0,135 135,635
and latches,|
|

638
00:16:51,580 --> 00:16:52,810
0,180 180,375 375,840 840,1020 1020,1230
so a locks to protect
锁用来保护我们数据库中的这些更高级别的概念或对象，

639
00:16:52,810 --> 00:16:54,330
0,225 225,480 480,735 735,1275 1275,1520
these higher level concepts or

640
00:16:55,130 --> 00:16:56,740
0,335 335,515 515,635 635,910 1290,1610
objects in our database,| a
|一个 tuple ，一张表，一个数据库，

641
00:16:56,740 --> 00:16:59,130
0,320 850,1155 1155,1460 1810,2100 2100,2390
tuple, a table, a database,|
|

642
00:16:59,720 --> 00:17:00,760
0,260 260,425 425,725 725,845 845,1040
I take locks on these
我在这些东西上使用锁，

643
00:17:00,760 --> 00:17:02,740
0,320 1060,1335 1335,1590 1590,1785 1785,1980
things,| and {what,will} happen is,|
|接下来会发生的是，|

644
00:17:02,740 --> 00:17:03,595
0,90 90,300 300,450 450,585 585,855
we haven't discussed what transactions
我们还没有讨论什么是事务，

645
00:17:03,595 --> 00:17:04,420
0,270 270,405 405,555 555,705 705,825
are just yet,| but think
|但是想象一下，我想要进行多次更新，

646
00:17:04,420 --> 00:17:04,990
0,120 120,240 240,360 360,465 465,570
of like I want to

647
00:17:04,990 --> 00:17:06,550
0,135 135,410 550,950 1150,1440 1440,1560
do multiple updates,| it's like
|就像是 SQL 查询的多次往返，

648
00:17:06,550 --> 00:17:07,780
0,255 255,570 570,825 825,975 975,1230
multiple round trips of SQL

649
00:17:07,780 --> 00:17:09,475
0,440 670,945 945,1220 1330,1575 1575,1695
queries,| and so if I
|如果我对某个东西加锁，

650
00:17:09,475 --> 00:17:10,500
0,135 135,285 285,495 495,720 720,1025
take a lock on something,|
|

651
00:17:10,880 --> 00:17:11,860
0,290 290,440 440,605 605,815 815,980
I want to hold it
我想在事务期间持有它，

652
00:17:11,860 --> 00:17:12,895
0,120 120,255 255,530 610,870 870,1035
for the length of that

653
00:17:12,895 --> 00:17:14,280
0,305
transaction,|
|

654
00:17:14,350 --> 00:17:16,035
0,350 350,700 1020,1325 1325,1460 1460,1685
and because, he's saying user
因为，他说的是用户空间，

655
00:17:16,035 --> 00:17:16,920
0,255 255,405 405,540 540,660 660,885
space,| but it's like the
|但这就像是应用程序创建了这些锁，

656
00:17:16,920 --> 00:17:18,255
0,285 285,620 670,915 915,1035 1035,1335
application is the one that's

657
00:17:18,255 --> 00:17:20,235
0,425 865,1200 1200,1425 1425,1770 1770,1980
that's creating these locks| or
|或者数据库系统代表应用程序创建了这些锁，

658
00:17:20,235 --> 00:17:21,150
0,210 210,345 345,630 630,765 765,915
the database system creating these

659
00:17:21,150 --> 00:17:21,870
0,180 180,240 240,345 345,540 540,720
locks on the behalf of

660
00:17:21,870 --> 00:17:23,835
0,210 210,560 1060,1410 1410,1725 1725,1965
the application,| we assume that
|我们假设他们是愚蠢的，

661
00:17:23,835 --> 00:17:25,455
0,270 270,575 985,1320 1320,1500 1500,1620
they're stupid| and therefore we
|因此我们需要确保它们不会出现死锁或其他问题，

662
00:17:25,455 --> 00:17:26,325
0,120 120,210 210,390 390,645 645,870
need to make sure that

663
00:17:26,325 --> 00:17:27,660
0,195 195,540 540,765 765,1245 1245,1335
they don't have deadlocks or

664
00:17:27,660 --> 00:17:29,280
0,195 195,530 1240,1470 1470,1530 1530,1620
other problems,| so we have
|所以我们必须有这些额外的保护机制，

665
00:17:29,280 --> 00:17:30,165
0,90 90,180 180,330 330,585 585,885
to have these additional protection

666
00:17:30,165 --> 00:17:31,970
0,540 540,690 690,840 840,1145 1405,1805
mechanisms| to make sure that
|以确保 Javascript 程序员不会做他们不应该做的事情。

667
00:17:32,020 --> 00:17:33,630
0,260 260,680 680,1145 1145,1445 1445,1610
the Javascript programmer doesn't do

668
00:17:33,630 --> 00:17:34,610
0,210 210,405 405,615 615,720 720,980
something they shouldn't be doing,

669
00:17:34,870 --> 00:17:35,920
0,400
right.|
|

670
00:17:36,170 --> 00:17:37,740
0,665 665,890 890,1025 1025,1235 1235,1570
Latches are the low level
latch 是低级内部原语，

671
00:17:37,760 --> 00:17:39,370
0,335 335,1310 1310,1460 1460,1520 1520,1610
internal primitives,| we're going to
|我们使用它来保护数据库系统的关键部分，

672
00:17:39,370 --> 00:17:40,465
0,210 210,465 465,675 675,855 855,1095
use to protect the critical

673
00:17:40,465 --> 00:17:42,270
0,365 745,1005 1005,1155 1155,1425 1425,1805
sections of our database system,

674
00:17:43,070 --> 00:17:44,065
0,305 305,470 470,650 650,830 830,995
right,| and these are what
|这些是数据库系统开发人员使用的，

675
00:17:44,065 --> 00:17:45,325
0,150 150,345 345,690 690,1050 1050,1260
the database system developers are

676
00:17:45,325 --> 00:17:46,060
0,165 165,345 345,435 435,510 510,735
using,| you had {} use
|你项目零中使用了，

677
00:17:46,060 --> 00:17:47,970
0,330 330,680 910,1260 1260,1560 1560,1910
in, in project #0, right,|
|

678
00:17:48,440 --> 00:17:49,140
0,245 245,320 320,380 380,455 455,700
you have to take a
你必须使用 mutex ，

679
00:17:49,160 --> 00:17:50,815
0,580 840,1145 1145,1325 1325,1460 1460,1655
mutex, right,| so a latch
|所以， latch 就像一个低级别的 mutex 。

680
00:17:50,815 --> 00:17:51,985
0,195 195,485 625,870 870,990 990,1170
is basically like a low

681
00:17:51,985 --> 00:17:53,580
0,305 325,905
level mutex,

682
00:17:54,090 --> 00:17:56,450
0,400 1080,1480 1590,1955 1955,2195 2195,2360
right.| And because, this is
|因为，这意味着，

683
00:17:56,450 --> 00:17:57,605
0,180 180,300 300,530 610,1065 1065,1155
meant to be,| latches are
|latch 被数据库系统开发人员使用，也就是我们，

684
00:17:57,605 --> 00:17:58,655
0,150 150,405 405,675 675,855 855,1050
being used by the database

685
00:17:58,655 --> 00:18:01,490
0,270 270,605 1135,1455 1455,1775 2515,2835
system developers, meaning us, right,|
|

686
00:18:01,490 --> 00:18:02,560
0,315 315,510 510,675 675,795 795,1070
it's not going to have
它不会有我们需要的死锁检测和其他保护机制，

687
00:18:02,760 --> 00:18:05,165
0,400 1140,1490 1490,1715 1715,2075 2075,2405
the, the, the deadlock detection

688
00:18:05,165 --> 00:18:06,290
0,75 75,240 240,480 480,990 990,1125
and other protection mechanisms we

689
00:18:06,290 --> 00:18:07,730
0,210 210,560 940,1215 1215,1380 1380,1440
need,| because if we're the
|因为如果我们是构建数据库系统的人，

690
00:18:07,730 --> 00:18:08,620
0,105 105,270 270,405 405,570 570,890
ones building a database system,|
|

691
00:18:08,730 --> 00:18:09,455
0,245 245,350 350,440 440,560 560,725
we need to be smart
我们需要足够聪明，以确保我们不会有死锁。

692
00:18:09,455 --> 00:18:10,055
0,135 135,225 225,330 330,480 480,600
enough to make sure we

693
00:18:10,055 --> 00:18:11,620
0,255 255,435 435,1055
don't have deadlocks.|
|

694
00:18:12,110 --> 00:18:13,240
0,275 275,410 410,770 770,935 935,1130
And so latches are really
所以， latch 意味着快速进出临界区，

695
00:18:13,240 --> 00:18:14,185
0,165 165,270 270,375 375,645 645,945
meant to be like quick

696
00:18:14,185 --> 00:18:15,535
0,150 150,240 240,485 715,1050 1050,1350
in and out critical section,|
|

697
00:18:15,535 --> 00:18:16,620
0,240 240,435 435,630 630,795 795,1085
do something and release it,|
做一些事情，然后释放它，|

698
00:18:16,790 --> 00:18:18,010
0,305 305,500 500,665 665,890 890,1220
and we need to through
我们需要通过程序员[纪律]，我们必须，

699
00:18:18,010 --> 00:18:19,900
0,380 700,1200 1200,1455 1455,1710 1710,1890
through programmer discipline, we need,|
|

700
00:18:19,900 --> 00:18:20,590
0,240 240,330 330,450 450,585 585,690
we're the ones, we have
我们必须确保我们不会有死锁，

701
00:18:20,590 --> 00:18:21,670
0,90 90,210 210,405 405,710 850,1080
to make sure that, we

702
00:18:21,670 --> 00:18:23,460
0,195 195,375 375,465 465,1040
don't, don't have deadlocks,|
|

703
00:18:24,140 --> 00:18:25,240
0,275 275,410 410,545 545,890 890,1100
now, this is confusing,| because
现在，这是令人困惑的，|因为在 C++ 标准库中，

704
00:18:25,240 --> 00:18:26,365
0,120 120,315 315,645 645,960 960,1125
this is also in {C++

705
00:18:26,365 --> 00:18:27,900
0,120 120,395 835,1095 1095,1245 1245,1535
- -} the standard library,|
|

706
00:18:28,190 --> 00:18:29,530
0,425 425,730 810,1070 1070,1205 1205,1340
there's also, they use the
他们也使用术语 latch ，

707
00:18:29,530 --> 00:18:30,850
0,150 150,620 820,1065 1065,1230 1230,1320
term latches,| but that's just
|但只是一个 countdown barrier ，

708
00:18:30,850 --> 00:18:32,380
0,135 135,480 480,980 1120,1365 1365,1530
a countdown barrier,| we don't
|我们不想这样，我们不需要那个，

709
00:18:32,380 --> 00:18:33,055
0,120 120,300 300,435 435,570 570,675
want that, we don't need

710
00:18:33,055 --> 00:18:34,045
0,225 225,450 450,495 495,705 705,990
that,| we're going to roll
|我们要轮询 latch ，

711
00:18:34,045 --> 00:18:35,620
0,165 165,635 835,1200 1200,1365 1365,1575
around latches,| we'll see this
|下周，我们会更多地看到这个，

712
00:18:35,620 --> 00:18:36,400
0,210 210,405 405,585 585,690 690,780
more next week,| when we
|当我们讨论 B+ 树的索引并发控制时，

713
00:18:36,400 --> 00:18:37,480
0,165 165,450 450,705 705,855 855,1080
talk about index {concurrency -}

714
00:18:37,480 --> 00:18:38,760
0,350 430,690 690,810 810,975 975,1280
control for {B+ -} trees,|
|

715
00:18:40,400 --> 00:18:41,350
0,165 165,240 240,390 390,630 630,950
but for now, just assume
但就目前而言，你可以将其视为 mutex ，

716
00:18:41,610 --> 00:18:42,320
0,245 245,365 365,500 500,605 605,710
you can treat it as

717
00:18:42,320 --> 00:18:43,620
0,105 105,500
a mutex,|
|

718
00:18:44,560 --> 00:18:45,135
0,230 230,365 365,425 425,485 485,575
we don't want to use
我们不想使用操作系统的 mutex ，

719
00:18:45,135 --> 00:18:46,050
0,105 105,240 240,600 600,795 795,915
the OS metux,| that has
|它有其他问题，

720
00:18:46,050 --> 00:18:47,100
0,165 165,470 490,780 780,900 900,1050
other problems,| we'll cover that
|我们稍后会讲到。

721
00:18:47,100 --> 00:18:48,580
0,260
later.|
|

722
00:18:50,450 --> 00:18:52,000
0,380 380,760 810,1115 1115,1340 1340,1550
{All,right}, again, another importantent distinction,|
好的，另一个重要的区别，|

723
00:18:52,000 --> 00:18:53,140
0,180 180,300 300,450 450,710 880,1140
I've already said this,| between
我已经说过，|在页面目录和页表之间（的区别）。

724
00:18:53,140 --> 00:18:53,890
0,120 120,300 300,585 585,645 645,750
the page directory and the

725
00:18:53,890 --> 00:18:55,585
0,165 165,470 790,1080 1080,1335 1335,1695
page table.| The page directory
|页面目录只是磁盘的驻留映射，

726
00:18:55,585 --> 00:18:57,055
0,150 150,420 420,785 955,1260 1260,1470
is just the the a

727
00:18:57,055 --> 00:18:59,740
0,360 360,845 1615,2175 2175,2445 2445,2685
disk residenton mapping| between page
|在页面 id 与它们在物理磁盘上、实际文件上的位置之间，

728
00:18:59,740 --> 00:19:02,410
0,590 1150,1515 1515,1880 1930,2330 2380,2670
IDs and their locations on

729
00:19:02,410 --> 00:19:03,610
0,165 165,440 460,915 915,1050 1050,1200
the physical disk on, on

730
00:19:03,610 --> 00:19:05,635
0,150 150,330 330,620 640,1040 1780,2025
the actual files themselves,| but
|但页表将是内存中的短暂映射，

731
00:19:05,635 --> 00:19:06,685
0,150 150,435 435,750 750,945 945,1050
the page table is gonna

732
00:19:06,685 --> 00:19:07,825
0,90 90,195 195,690 690,855 855,1140
be this ephemeral in memory

733
00:19:07,825 --> 00:19:09,835
0,345 345,935 1345,1650 1650,1830 1830,2010
memory mapping,| that we use
|我们使用它来标识给定的页面 id ，

734
00:19:09,835 --> 00:19:11,230
0,300 300,695 925,1140 1140,1200 1200,1395
to identify for a given

735
00:19:11,230 --> 00:19:13,140
0,240 240,530 940,1380 1380,1575 1575,1910
page id,| here's the frame
|这是 frame 实际所在的位置，

736
00:19:13,310 --> 00:19:15,040
0,260 260,500 500,790 840,1240 1500,1730
where it's actually located| and
|如果它不在我们的页表中，

737
00:19:15,040 --> 00:19:15,940
0,60 60,225 225,495 495,750 750,900
if it's not in our

738
00:19:15,940 --> 00:19:16,885
0,210 210,450 450,630 630,795 795,945
page table,| we know we
|我们知道我们必须在页面目录中查找，

739
00:19:16,885 --> 00:19:17,410
0,120 120,240 240,330 330,420 420,525
have to look in the

740
00:19:17,410 --> 00:19:18,280
0,195 195,525 525,600 600,705 705,870
page directory| to go find
|以找到它在磁盘上的位置，

741
00:19:18,280 --> 00:19:19,530
0,225 225,420 420,540 540,690 690,1250
where it is on disk|
|

742
00:19:19,730 --> 00:19:20,700
0,275 275,455 455,620 620,725 725,970
and go bring it in,
并将其带入进来。|

743
00:19:21,590 --> 00:19:23,100
0,400
right.|
|

744
00:19:23,500 --> 00:19:24,540
0,275 275,470 470,635 635,770 770,1040
So most of the time
所以，在大多数情况下，查询将命中页表，

745
00:19:24,540 --> 00:19:25,410
0,360 360,645 645,765 765,825 825,870
the query is going to

746
00:19:25,410 --> 00:19:26,250
0,135 135,330 330,495 495,645 645,840
be hitting up the page

747
00:19:26,250 --> 00:19:27,345
0,320 490,705 705,810 810,945 945,1095
table,| but it's only when
|但只有在页表表示不存在的情况下，

748
00:19:27,345 --> 00:19:28,365
0,120 120,285 285,480 480,690 690,1020
the page table says something's

749
00:19:28,365 --> 00:19:29,490
0,90 90,365 595,840 840,960 960,1125
not there,| then there needs
|然后需要有一些机制，

750
00:19:29,490 --> 00:19:31,230
0,120 120,255 255,450 450,740 1480,1740
to be some mechanism through,|
|

751
00:19:31,230 --> 00:19:32,055
0,135 135,270 270,465 465,720 720,825
like the disk scheduler or
比如磁盘调度器或其他东西，

752
00:19:32,055 --> 00:19:33,110
0,225 225,435 435,630 630,810 810,1055
something,| that says, all right,
|比如，好的，让我看看页面目录，

753
00:19:33,130 --> 00:19:33,660
0,230 230,305 305,380 380,440 440,530
let me look at the

754
00:19:33,660 --> 00:19:34,755
0,150 150,440 670,900 900,990 990,1095
page directory,| let me go
|让我去取磁盘上的页面，

755
00:19:34,755 --> 00:19:35,685
0,105 105,360 360,675 675,810 810,930
get the fetch the page

756
00:19:35,685 --> 00:19:36,465
0,135 135,390 390,480 480,630 630,780
from disk| and then put
|然后把它放到页表中。

757
00:19:36,465 --> 00:19:37,580
0,90 90,335 415,660 660,810 810,1115
it into the page table.|
|

758
00:19:38,590 --> 00:19:39,680
0,400
Okay?|
好的？|

759
00:19:40,560 --> 00:19:41,300
0,230 230,290 290,470 470,605 605,740
So what I've shown you
到目前为止，我向你展示的是一个基本的页表，

760
00:19:41,300 --> 00:19:42,250
0,150 150,360 360,555 555,690 690,950
so far is a basic

761
00:19:42,270 --> 00:19:44,015
0,320 320,640 1140,1445 1445,1505 1505,1745
page table,| it's a hash
|这是一个哈希表，一些额外的元数据，

762
00:19:44,015 --> 00:19:46,430
0,275 445,675 675,825 825,1535 2125,2415
table, some extra metadata,| if
|如果页面在那里，

763
00:19:46,430 --> 00:19:48,080
0,150 150,300 300,450 450,710 1390,1650
the page is there,| for
|对于给定的页面 id ，

764
00:19:48,080 --> 00:19:49,145
0,135 135,330 330,620 730,975 975,1065
given page id,| you get
|你得到指向它的指针，

765
00:19:49,145 --> 00:19:50,080
0,120 120,270 270,540 540,675 675,935
back a pointer to it,|
|

766
00:19:50,160 --> 00:19:51,305
0,230 230,395 395,560 560,860 860,1145
if it's not there,| there's
如果它不在那里，|有某种机制可以从磁盘获取它，

767
00:19:51,305 --> 00:19:52,330
0,105 105,365 385,615 615,735 735,1025
some mechanism to go get

768
00:19:52,470 --> 00:19:53,800
0,245 245,320 320,425 425,910 930,1330
get it from disk,| then
|然后将其安装到一个空闲的 frame 中，

769
00:19:53,880 --> 00:19:55,250
0,275 275,395 395,640 690,1070 1070,1370
install it into a free

770
00:19:55,250 --> 00:19:56,795
0,320 700,1005 1005,1185 1185,1350 1350,1545
frame,| then the page table
|然后页表具有该条目。

771
00:19:56,795 --> 00:19:58,320
0,255 255,510 510,720 720,1025
has has the entry,

772
00:19:58,690 --> 00:19:59,920
0,400
right.|
|

773
00:19:59,920 --> 00:20:00,700
0,225 225,375 375,540 540,675 675,780
But this is going to
但这将是一个巨大的瓶颈，

774
00:20:00,700 --> 00:20:02,545
0,260 1330,1590 1590,1710 1710,1800 1800,1845
be, this is going to

775
00:20:02,545 --> 00:20:03,625
0,45 45,120 120,255 255,840 840,1080
be a big bottleneck| unless
|除非我们聪明地利用我们所知道的信息，

776
00:20:03,625 --> 00:20:05,100
0,360 360,660 660,915 915,1155 1155,1475
we're clever and smart about

777
00:20:05,270 --> 00:20:06,630
0,410 410,620 620,860 860,1055 1055,1360
exploiting the information we know|
|

778
00:20:06,980 --> 00:20:08,370
0,335 335,560 560,740 740,1010 1010,1390
about what is going on
关于数据库系统中发生的事情，

779
00:20:08,390 --> 00:20:10,160
0,260 260,380 380,590 590,940
inside our database system,|
|

780
00:20:12,290 --> 00:20:13,135
0,230 230,335 335,440 440,575 575,845
for us, to make decisions,|
对于我们来说，我们要决定，|

781
00:20:13,135 --> 00:20:13,960
0,240 240,360 360,435 435,495 495,825
how we want to allocate
如何分配东西，

782
00:20:13,960 --> 00:20:16,135
0,240 240,590 670,1005 1005,1340 1900,2175
things| and and decide who
|决定谁得到什么页面，什么时间，什么位置，

783
00:20:16,135 --> 00:20:17,320
0,210 210,480 480,735 735,960 960,1185
gets what page, at what

784
00:20:17,320 --> 00:20:19,330
0,210 210,405 405,690 690,1070 1690,2010
time and what location| and
|以及我们决定如何驱逐东西，

785
00:20:19,330 --> 00:20:20,095
0,195 195,345 345,510 510,675 675,765
what how we decide to

786
00:20:20,095 --> 00:20:21,415
0,225 225,515 925,1170 1170,1245 1245,1320
evict things,| because if we
|因为如果我们不利用这些信息，

787
00:20:21,415 --> 00:20:22,285
0,270 270,510 510,675 675,825 825,870
don't do, we don't want

788
00:20:22,285 --> 00:20:23,155
0,120 120,330 330,480 480,690 690,870
to exploit the information,| we
|我们知道我们的查询想要做什么，

789
00:20:23,155 --> 00:20:24,130
0,180 180,375 375,525 525,675 675,975
know about what our queries

790
00:20:24,130 --> 00:20:25,225
0,120 120,240 240,500 670,930 930,1095
want to do,| what our
|我们的数据是什么样子，

791
00:20:25,225 --> 00:20:26,305
0,240 240,495 495,735 735,900 900,1080
data looks like,| what our
|我们的访问模式是什么，

792
00:20:26,305 --> 00:20:28,060
0,210 210,405 405,725 1315,1590 1590,1755
access patterns are,| then we're
|那么我们并不比操作系统更好。

793
00:20:28,060 --> 00:20:28,980
0,120 120,315 315,480 480,630 630,920
no better than the OS,|
|

794
00:20:29,680 --> 00:20:30,790
0,240 240,405 405,660 660,870 870,1110
the OS doesn't see anything
操作系统没有看到我们的数据系统内部发生任何事情，

795
00:20:30,790 --> 00:20:31,795
0,180 180,470 520,765 765,855 855,1005
going on inside our database

796
00:20:31,795 --> 00:20:33,760
0,305 715,1115 1525,1755 1755,1845 1845,1965
system,| so, you know, if
|所以，如果我们只是盲目地接受请求，然后把它们拿出来，

797
00:20:33,760 --> 00:20:36,265
0,150 150,405 405,1010 1270,1670 2170,2505
we just blindly go take

798
00:20:36,265 --> 00:20:37,015
0,270 270,420 420,540 540,660 660,750
requests and go take them

799
00:20:37,015 --> 00:20:38,770
0,245 1045,1365 1365,1485 1485,1635 1635,1755
out,| we're no better than
|我们并不比操作系统好多少。

800
00:20:38,770 --> 00:20:39,980
0,165 165,470
the OS,

801
00:20:40,180 --> 00:20:41,300
0,400
right.|
|

802
00:20:41,950 --> 00:20:43,590
0,400 780,1055 1055,1175 1175,1355 1355,1640
So some of these techniques
所以，我们将讨论一些技术，一些优化，

803
00:20:43,590 --> 00:20:45,380
0,285 285,450 450,770 970,1290 1290,1790
we'll talk about, these optimizations,|
|

804
00:20:47,710 --> 00:20:48,795
0,380 380,620 620,725 725,800 800,1085
this is going to motivate
这将激励我们为什么需要编写自己的缓冲池管理器，

805
00:20:48,795 --> 00:20:49,515
0,210 210,360 360,450 450,555 555,720
why we need to write

806
00:20:49,515 --> 00:20:50,510
0,180 180,345 345,645 645,750 750,995
our own buffer pool manager,|
|

807
00:20:50,740 --> 00:20:51,525
0,260 260,365 365,500 500,560 560,785
why we don't want {to,use}
为什么我们不想要使用操作系统，

808
00:20:51,525 --> 00:20:53,460
0,395 1495,1755 1755,1830 1830,1875 1875,1935
OS,| and it would be
|它将是一些策略的组合，

809
00:20:53,460 --> 00:20:56,160
0,120 120,410 640,1040 1720,2120 2350,2700
a combination of policies,| that
|影响所有同时运行的查询（的策略），

810
00:20:56,160 --> 00:20:57,975
0,270 270,540 540,890 1240,1695 1695,1815
will affect all queries of

811
00:20:57,975 --> 00:20:58,790
0,120 120,225 225,315 315,495 495,815
running at the same time,|
|

812
00:21:00,610 --> 00:21:01,515
0,290 290,440 440,530 530,665 665,905
or it could be things
或者，它可能只会帮助单个查询本身，

813
00:21:01,515 --> 00:21:02,595
0,195 195,300 300,510 510,810 810,1080
that are gonna just help

814
00:21:02,595 --> 00:21:04,605
0,335 745,1080 1080,1365 1365,1680 1680,2010
a, a single query by

815
00:21:04,605 --> 00:21:06,570
0,395 685,990 990,1290 1290,1605 1605,1965
itself,| maybe not necessarily worrying
|可能不一定担心同时运行的其他查询，

816
00:21:06,570 --> 00:21:07,425
0,180 180,405 405,705 705,780 780,855
about other queries that are

817
00:21:07,425 --> 00:21:08,805
0,150 150,300 300,465 465,785 1135,1380
running the same time,| but
|但我们可以隔离对该查询所做的决策，

818
00:21:08,805 --> 00:21:11,100
0,105 105,285 285,1020 1020,1415 1945,2295
we can isolate the decisions

819
00:21:11,100 --> 00:21:11,970
0,225 225,390 390,525 525,645 645,870
we make for that query,|
|

820
00:21:11,970 --> 00:21:12,800
0,165 165,225 225,300 300,540 540,830
so that they don't try
以便它们不会影响其他查询。

821
00:21:12,820 --> 00:21:14,500
0,275 275,425 425,575 575,850
not to affect others,

822
00:21:15,390 --> 00:21:16,600
0,400
right.|
|

823
00:21:16,820 --> 00:21:18,670
0,400 1140,1505 1505,1640 1640,1760 1760,1850
And I'm not going to
我不会说这些方法中的一种会比另一种更好，

824
00:21:18,670 --> 00:21:19,480
0,165 165,345 345,450 450,570 570,810
say one of these approaches

825
00:21:19,480 --> 00:21:20,250
0,180 180,255 255,390 390,525 525,770
can be better than another,|
|

826
00:21:20,690 --> 00:21:21,775
0,335 335,515 515,650 650,815 815,1085
but you will see that
但你会在我们进行的过程中看到，

827
00:21:21,775 --> 00:21:23,400
0,255 255,345 345,450 450,725
as we go along,|
|

828
00:21:23,440 --> 00:21:24,615
0,350 350,530 530,695 695,935 935,1175
all the major database systems
所有主流的数据库系统都将使用它们的某种组合，

829
00:21:24,615 --> 00:21:25,230
0,180 180,255 255,300 300,405 405,615
are going to use some

830
00:21:25,230 --> 00:21:26,750
0,320 730,990 990,1140 1140,1275 1275,1520
combination of all of them,|
|

831
00:21:26,950 --> 00:21:28,350
0,290 290,440 440,530 530,760 1110,1400
or some of them, most
或者它们中的一些，或者大多数，

832
00:21:28,350 --> 00:21:29,280
0,135 135,380
of them,

833
00:21:29,710 --> 00:21:31,370
0,400 780,1010 1010,1115 1115,1385 1385,1660
right,| so I can't say
|我不能说哪一个是首先要实现的最重要的一个，

834
00:21:31,570 --> 00:21:33,135
0,260 260,520 930,1250 1250,1445 1445,1565
you know which one is

835
00:21:33,135 --> 00:21:33,765
0,75 75,210 210,390 390,510 510,630
the most important one to

836
00:21:33,765 --> 00:21:36,390
0,195 195,515 865,1265 1885,2550 2550,2625
implement first,| but we'll see
|但是随着我们进行，我们将会看到。

837
00:21:36,390 --> 00:21:37,540
0,90 90,195 195,330 330,620
as we go along.|
|

838
00:21:39,220 --> 00:21:39,925
0,150 150,315 315,480 480,585 585,705
All right, so the things
好的。所以我要说的是，

839
00:21:39,925 --> 00:21:41,635
0,120 120,210 210,315 315,575 1405,1710
I talk about is,| using
|使用多缓冲池，

840
00:21:41,635 --> 00:21:43,090
0,480 480,725 865,1110 1110,1320 1320,1455
{multiple,buffer} pools,| actually, that's probably
|这可能是我说的第一个，

841
00:21:43,090 --> 00:21:43,915
0,135 135,270 270,510 510,720 720,825
the first one I take

842
00:21:43,915 --> 00:21:45,000
0,120 120,225 225,315 315,575 685,1085
back,| what I said,| {multiple,buffer}
|正如我所说的，|首先，多缓冲池是明显要做的，

843
00:21:45,020 --> 00:21:46,300
0,400 540,890 890,1085 1085,1190 1190,1280
pools is obvious thing to

844
00:21:46,300 --> 00:21:47,590
0,105 105,380 880,1170 1170,1230 1230,1290
do first,| we'll see what
|我们看看它是什么样子的，

845
00:21:47,590 --> 00:21:48,835
0,75 75,195 195,470 610,1155 1155,1245
that looks like,| pre-fetching is
|预取是更复杂的，扫描共享，然后是缓冲池旁路。

846
00:21:48,835 --> 00:21:50,305
0,120 120,395 685,1005 1005,1275 1275,1470
more complicated, scan sharing and

847
00:21:50,305 --> 00:21:52,020
0,150 150,510 510,1025
then {buffer,pool} bypass.|
|

848
00:21:53,630 --> 00:21:55,180
0,365 365,730
{All,right}, so,
好的，我在开头分享的玩具例子，

849
00:21:55,180 --> 00:21:56,515
0,350 610,930 930,1110 1110,1230 1230,1335
my toy example I shared

850
00:21:56,515 --> 00:21:57,460
0,120 120,395 505,750 750,855 855,945
the beginning,| we said there
|我们说只有一个页表，一组 frame ，

851
00:21:57,460 --> 00:21:58,960
0,105 105,285 285,510 510,830 1210,1500
was one page table, one

852
00:21:58,960 --> 00:22:00,130
0,150 150,270 270,560 790,1050 1050,1170
set of frames,| and that
|整个系统就是这样。

853
00:22:00,130 --> 00:22:00,805
0,120 120,240 240,345 345,465 465,675
was it for the entire

854
00:22:00,805 --> 00:22:01,840
0,335
system,

855
00:22:01,840 --> 00:22:04,255
0,320 910,1170 1170,1335 1335,1640 2050,2415
right.| But then again, because
|但又说回来，因为有多个 worker 同时运行，

856
00:22:04,255 --> 00:22:06,010
0,315 315,525 525,875 1375,1650 1650,1755
there's multiple workers running at

857
00:22:06,010 --> 00:22:06,790
0,75 75,240 240,480 480,660 660,780
the same time,| we had
|我们必须使用这些 latch 来保护数据结构，

858
00:22:06,790 --> 00:22:07,975
0,135 135,375 375,630 630,1020 1020,1185
to use these latches to

859
00:22:07,975 --> 00:22:09,660
0,195 195,345 345,540 540,875 1285,1685
protect the data structure,| and
|对于大量 CPU 核心或同时运行的大量 worker ，

860
00:22:09,680 --> 00:22:11,080
0,400 540,845 845,1070 1070,1265 1265,1400
for a large number of

861
00:22:11,080 --> 00:22:12,730
0,435 435,1040 1120,1380 1380,1530 1530,1650
CPU cores or large number

862
00:22:12,730 --> 00:22:13,405
0,75 75,270 270,495 495,600 600,675
of workers running at the

863
00:22:13,405 --> 00:22:15,160
0,150 150,455 805,1185 1185,1635 1635,1755
same time,| those latches are
|这些 latch 将成为瓶颈。

864
00:22:15,160 --> 00:22:16,140
0,90 90,180 180,285 285,390 390,980
going to become a bottleneck,

865
00:22:17,290 --> 00:22:19,290
0,400 570,875 875,1180 1350,1685 1685,2000
right.| We can, because it's
|我们可以，因为它是固定的，

866
00:22:19,290 --> 00:22:21,015
0,290 940,1230 1230,1380 1380,1545 1545,1725
fixed,| assuming the page table
|假设页表是固定大小，

867
00:22:21,015 --> 00:22:22,635
0,135 135,300 300,605 1255,1485 1485,1620
is fixed size,| we don't
|我们不必为整个页表设置 latch ，

868
00:22:22,635 --> 00:22:23,175
0,60 60,135 135,225 225,345 345,540
have to have a latch

869
00:22:23,175 --> 00:22:24,170
0,150 150,255 255,435 435,675 675,995
for the entire page table,|
|

870
00:22:24,700 --> 00:22:26,180
0,305 305,575 575,890 890,1175 1175,1480
have latch for individual pages
为单个页面或哈希表中的位置设置 latch ，

871
00:22:26,530 --> 00:22:28,800
0,400 690,1090 1590,1940 1940,2150 2150,2270
or, or locations in, in

872
00:22:28,800 --> 00:22:29,895
0,105 105,255 255,500 670,915 915,1095
the hash table,| but even
|但即使这样，

873
00:22:29,895 --> 00:22:30,870
0,225 225,450 450,780 780,870 870,975
then,| if everybody's trying to
|如果每个人都想获取相同的少量页面，

874
00:22:30,870 --> 00:22:32,775
0,195 195,465 465,705 705,1010 1630,1905
go get the same small

875
00:22:32,775 --> 00:22:34,740
0,120 120,240 240,515 1105,1505 1645,1965
number of pages,| then those
|那么这些 latch 将成为一个瓶颈。

876
00:22:34,740 --> 00:22:35,790
0,360 360,465 465,585 585,810 810,1050
latches are gonna be a,

877
00:22:35,790 --> 00:22:37,180
0,165 165,740
a bottleneck,

878
00:22:37,180 --> 00:22:40,530
0,350 1330,1730 2560,2820 2820,3015 3015,3350
right.| So an easy way
|所以缓解这种争用点的一个简单方法是，

879
00:22:40,640 --> 00:22:43,680
0,400 840,1580 1580,1960 2190,2675 2675,3040
to alleviate this contention point

880
00:22:43,910 --> 00:22:45,175
0,335 335,485 485,605 605,875 875,1265
is| to have multiple buffer
|拥有多个缓冲池，

881
00:22:45,175 --> 00:22:46,200
0,395
pools,|
|

882
00:22:46,200 --> 00:22:47,130
0,180 180,270 270,405 405,795 795,930
so I still allocate the
所以我仍然分配相同数量的内存，

883
00:22:47,130 --> 00:22:48,300
0,150 150,300 300,405 405,650 940,1170
same amount of memory,| so
|所以我必须在启动时告知数据库系统，

884
00:22:48,300 --> 00:22:48,765
0,60 60,135 135,240 240,360 360,465
I have to tell the

885
00:22:48,765 --> 00:22:49,635
0,150 150,420 420,630 630,735 735,870
database system when I boot

886
00:22:49,635 --> 00:22:51,120
0,245 295,570 570,750 750,1055 1195,1485
up,| I want 10 gigs
|我想要 10GB 的内存，对我的缓冲池，

887
00:22:51,120 --> 00:22:52,400
0,75 75,320 320,520 520,780 780,1035 1035,1280
of memory, for my buffer pool,|
|

888
00:22:52,780 --> 00:22:53,415
0,245 245,365 365,410 410,500 500,635
but I'm going to take
但是我要用这 10GB ，

889
00:22:53,415 --> 00:22:54,330
0,180 180,390 390,720 720,810 810,915
those 10 gigs| and I
|我可以把它分成大小相等的块，

890
00:22:54,330 --> 00:22:58,050
0,180 180,405 405,570 570,830 3400,3720
can divide it into equal

891
00:22:58,050 --> 00:22:59,400
0,240 240,770
size chunks,|
|

892
00:22:59,400 --> 00:23:00,345
0,225 225,390 390,615 615,810 810,945
and then now have a
然后，现在它们每个都有一个单独的页表。

893
00:23:00,345 --> 00:23:01,275
0,210 210,450 450,660 660,810 810,930
separate page table for each

894
00:23:01,275 --> 00:23:02,340
0,120 120,365
of them.|
|

895
00:23:04,360 --> 00:23:06,050
0,320 320,470 470,800 800,1120 1290,1690
It also ensures that,| that
它还确保，|对于特定数据结构上的特定访问模式，

896
00:23:06,430 --> 00:23:09,330
0,400 1290,1690 2100,2375 2375,2600 2600,2900
for certain access patterns on

897
00:23:09,330 --> 00:23:11,100
0,350 430,765 765,1080 1080,1425 1425,1770
certain data structure,| sorry, certain
|抱歉，数据库中的特定对象，

898
00:23:11,100 --> 00:23:12,945
0,240 240,345 345,435 435,680 1570,1845
objects in the database,| I
|我可以有不同的策略，

899
00:23:12,945 --> 00:23:14,355
0,150 150,375 375,690 690,1055 1135,1410
can have different policies,| that
|可以影响一个缓冲池或另一个，

900
00:23:14,355 --> 00:23:15,360
0,165 165,375 375,585 585,870 870,1005
can affect one buffer pool

901
00:23:15,360 --> 00:23:17,025
0,270 270,650 940,1245 1245,1470 1470,1665
versus another,| based on how
|根据我知道对象将被使用的方式。

902
00:23:17,025 --> 00:23:18,015
0,165 165,360 360,630 630,870 870,990
I know that object is

903
00:23:18,015 --> 00:23:19,360
0,105 105,210 210,345 345,635
going to be used.|
|

904
00:23:19,600 --> 00:23:20,565
0,275 275,425 425,605 605,800 800,965
So for example, in, in
例如，在 DB2 中，

905
00:23:20,715 --> 00:23:21,840
0,150 150,345 540,690 690,885 885,1125
{DB2 -},| {DB2 -} probably
|DB2 可能具有最复杂的缓冲池管理配置，

906
00:23:21,840 --> 00:23:23,370
0,240 240,525 525,780 780,960 960,1530
has the the most sophisticated

907
00:23:23,370 --> 00:23:26,745
0,285 285,650 1810,2360 2920,3225 3225,3375
{buffer,pool} management configurations,| where you
|你可以定义一个表空间，

908
00:23:26,745 --> 00:23:28,110
0,240 240,555 555,855 855,1125 1125,1365
can actually define a table

909
00:23:28,110 --> 00:23:29,340
0,350
space,|
|

910
00:23:30,190 --> 00:23:32,490
0,380 380,605 605,1120 1680,2060 2060,2300
like a namespace,| and that
与名称空间类似，|并且由给定的缓冲池支持，

911
00:23:32,490 --> 00:23:33,285
0,150 150,450 450,555 555,645 645,795
is backed by a given

912
00:23:33,285 --> 00:23:34,515
0,285 285,545 685,930 930,1065 1065,1230
buffer pool,| you can set
|你可以设置该缓冲池的页面大小，

913
00:23:34,515 --> 00:23:35,730
0,165 165,345 345,585 585,935 955,1215
what the page size should

914
00:23:35,730 --> 00:23:36,650
0,135 135,255 255,375 375,645 645,920
be for that buffer pool|
|

915
00:23:36,850 --> 00:23:37,800
0,260 260,365 365,485 485,680 680,950
and you can tell which
并且你可以知道该缓冲池将管理哪些表或哪些索引。

916
00:23:37,800 --> 00:23:38,985
0,330 330,540 540,645 645,885 885,1185
tables will be managed or

917
00:23:38,985 --> 00:23:39,885
0,345 345,420 420,510 510,690 690,900
indexes will be managed by

918
00:23:39,885 --> 00:23:41,100
0,135 135,405 405,665
that buffer pool.|
|

919
00:23:41,440 --> 00:23:42,270
0,230 230,395 395,515 515,650 650,830
So let's say you have
假设你有一个主要用于随机访问的表，

920
00:23:42,270 --> 00:23:43,700
0,225 225,465 465,750 750,1065 1065,1430
like one table that is

921
00:23:44,350 --> 00:23:46,340
0,400 750,1115 1115,1475 1475,1730 1730,1990
is primarily used for random

922
00:23:46,390 --> 00:23:47,805
0,400 750,980 980,1055 1055,1205 1205,1415
access,| you could have some
|你可以有一些策略，

923
00:23:47,805 --> 00:23:49,430
0,305 325,690 690,995 1015,1320 1320,1625
policies,| eviction policies based on,
|驱逐政策基于最好的随机访问，

924
00:23:50,230 --> 00:23:51,585
0,245 245,350 350,610 660,1010 1010,1355
you know, for that, that's

925
00:23:51,585 --> 00:23:53,115
0,225 225,330 330,575 595,995 1285,1530
optimal for random access,| then
|然后，你有另一个缓冲池，

926
00:23:53,115 --> 00:23:54,030
0,75 75,180 180,405 405,645 645,915
you have another, another buffer

927
00:23:54,030 --> 00:23:54,945
0,150 150,450 450,630 630,750 750,915
pool,| that's for these other
|用于其他进行顺序扫描的表，

928
00:23:54,945 --> 00:23:56,130
0,240 240,495 495,600 600,945 945,1185
tables, you're doing sequential scans,|
|

929
00:23:56,130 --> 00:23:57,120
0,225 225,360 360,480 480,630 630,990
so you have different buffer
所以，你对该顺序扫描有不同的缓冲区策略，

930
00:23:57,120 --> 00:23:58,245
0,345 345,585 585,690 690,975 975,1125
policies for that sequential scan,|
|

931
00:23:58,245 --> 00:23:59,415
0,195 195,375 375,615 615,930 930,1170
maybe use larger page page
也许可以使用更大的页面大小。

932
00:23:59,415 --> 00:24:02,160
0,305 925,1325 2215,2505 2505,2640 2640,2745
sizes, right.| As far as
|据我所知， DB2 是唯一一个允许你这样做的，

933
00:24:02,160 --> 00:24:02,865
0,120 120,270 405,525 525,630 630,705
I know, {DB2 -} is

934
00:24:02,865 --> 00:24:03,435
0,90 90,225 225,360 360,450 450,570
the only one that lets

935
00:24:03,435 --> 00:24:04,140
0,150 150,300 300,435 435,540 540,705
you do this,| I haven't
|我还没有看到 Postgres ， MySQL 肯定不能做这个，

936
00:24:04,140 --> 00:24:05,460
0,260 490,765 765,930 930,1095 1095,1320
seen {Postgres -}, {MySQL -}

937
00:24:05,460 --> 00:24:07,660
0,165 165,360 360,450 450,710
certainly can't do this,|
|

938
00:24:07,780 --> 00:24:08,805
0,215 215,430 480,785 785,875 875,1025
and I don't know about
我不知道其他企业的情况，

939
00:24:08,805 --> 00:24:10,110
0,105 105,335 445,750 750,1050 1050,1305
the other enterprise ones,| but
|但像 DB2 是非常复杂的。

940
00:24:10,110 --> 00:24:11,355
0,260 430,690 690,945 945,1095 1095,1245
like the {DB2 -} one

941
00:24:11,355 --> 00:24:13,520
0,275 475,780 780,1445
is very sophisticated.|
|

942
00:24:13,520 --> 00:24:15,215
0,195 195,450 450,830 1150,1500 1500,1695
And again, this allows you
同样，这允许你定义缓冲池管理，

943
00:24:15,215 --> 00:24:16,400
0,120 120,600 600,795 795,1065 1065,1185
to customize the buffer pool

944
00:24:16,400 --> 00:24:18,185
0,260 490,780 780,1070 1180,1500 1500,1785
management| for exactly how that
|针对对象的确切使用方式。

945
00:24:18,185 --> 00:24:19,160
0,360 360,645 645,780 780,870 870,975
object is going to be

946
00:24:19,160 --> 00:24:20,200
0,260
used.|
|

947
00:24:21,370 --> 00:24:22,155
0,260 260,350 350,470 470,635 635,785
Now the question is,| how
现在的问题是，|如何在运行时发现应该使用哪个缓冲池管理器。

948
00:24:22,155 --> 00:24:24,110
0,105 105,210 210,485 1165,1440 1440,1955
do you find at runtime

949
00:24:24,430 --> 00:24:26,730
0,400 1290,1670 1670,1775 1775,2020 2040,2300
what buffer pool manager should

950
00:24:26,730 --> 00:24:27,960
0,105 105,350
you use.|
|

951
00:24:28,090 --> 00:24:28,740
0,230 230,350 350,425 425,515 515,650
So let's say a really
让我们举一个非常简单的例子，

952
00:24:28,740 --> 00:24:29,505
0,195 195,390 390,540 540,645 645,765
simple example,| here I have
|这里我有两个缓冲池，

953
00:24:29,505 --> 00:24:31,815
0,135 135,375 375,785 1945,2205 2205,2310
two buffer pools| and so
|所以我可以做的第一件事是，

954
00:24:31,815 --> 00:24:32,385
0,90 90,225 225,375 375,480 480,570
the first thing I can

955
00:24:32,385 --> 00:24:33,540
0,120 120,255 255,450 450,785 895,1155
just do is, is,| as
|就像我说的，在 DB2 案例中，

956
00:24:33,540 --> 00:24:34,365
0,150 150,315 315,465 465,600 600,825
I said in the {DB2

957
00:24:34,365 --> 00:24:35,535
0,165 165,390 390,585 585,810 810,1170
-} case,| I can assign
|我可以分配一个缓冲池来支持给定的对象，

958
00:24:35,535 --> 00:24:37,035
0,255 255,510 510,755 955,1275 1275,1500
a buffer pool [do to]

959
00:24:37,035 --> 00:24:38,910
0,305 625,930 930,1235 1405,1695 1695,1875
back a given object| based
|根据某种标识符，

960
00:24:38,910 --> 00:24:39,920
0,165 165,300 300,390 390,510 510,1010
on some kind of identifier,|
|

961
00:24:40,120 --> 00:24:41,640
0,335 335,670 840,1115 1115,1280 1280,1520
like table one, two, three,
比如表 1 2 3 等等，这是缓冲区一，|

962
00:24:41,640 --> 00:24:43,440
0,300 300,650 850,1215 1215,1515 1515,1800
table, whatever, that's {buffer,pool} #1|

963
00:24:43,440 --> 00:24:44,775
0,345 345,690 690,960 960,1155 1155,1335
and all, all other tables
所有其他的表是缓冲区二。

964
00:24:44,775 --> 00:24:46,180
0,150 150,375 375,525 525,815
are buffer pool #2.|
|

965
00:24:46,470 --> 00:24:47,960
0,245 245,380 380,910 1140,1385 1385,1490
So, now runtime, when I
所以，在运行时，当我有一个请求时，

966
00:24:47,960 --> 00:24:49,385
0,255 255,585 585,920 1000,1260 1260,1425
have a request,| this is
|这显然不是 SQL ，

967
00:24:49,385 --> 00:24:50,915
0,195 195,405 405,875 1045,1320 1320,1530
obviously not SQL,| but somehow
|但我通过索引查找，

968
00:24:50,915 --> 00:24:53,210
0,210 210,485 1555,1905 1905,2145 2145,2295
I got through index look

969
00:24:53,210 --> 00:24:54,185
0,255 255,525 525,690 690,855 855,975
up,| I figured out that
|我想我要查找记录一二三，

970
00:24:54,185 --> 00:24:54,635
0,90 90,165 165,225 225,315 315,450
I want to look at

971
00:24:54,635 --> 00:24:56,260
0,195 195,405 405,600 600,905
record one, two, three,|
|

972
00:24:56,260 --> 00:24:57,190
0,105 105,225 225,390 390,675 675,930
and we saw before how
我们在前面看到了如何将记录 ID 分解为其单独的组成部分，

973
00:24:57,190 --> 00:24:57,910
0,105 105,225 225,390 390,540 540,720
we can break the record

974
00:24:57,910 --> 00:24:59,790
0,315 315,710 850,1185 1185,1500 1500,1880
ID into its individual components,|
|

975
00:25:00,260 --> 00:25:01,705
0,320 320,640 660,1010 1010,1235 1235,1445
usually like a page ID
通常如页面 ID 或插槽编号，

976
00:25:01,705 --> 00:25:03,235
0,165 165,255 255,435 435,725 1285,1530
or a slot number,| but
|但是对于 SQL Server ，

977
00:25:03,235 --> 00:25:04,030
0,75 75,180 180,315 315,570 570,795
in case a SQL Server,|
|

978
00:25:04,030 --> 00:25:06,400
0,255 255,435 435,710 1870,2160 2160,2370
it also had a file
它也有文件号或对象 ID ，

979
00:25:06,400 --> 00:25:08,620
0,240 240,525 525,735 735,980 1960,2220
number or object ID,| so
|我们可以对记录 ID 使用这个，

980
00:25:08,620 --> 00:25:09,625
0,105 105,210 210,420 420,750 750,1005
we can use this from

981
00:25:09,625 --> 00:25:11,080
0,135 135,315 315,635
the record ID,|
|

982
00:25:11,080 --> 00:25:11,830
0,150 150,405 405,540 540,645 645,750
then you'll look up and
然后你会查看说，

983
00:25:11,830 --> 00:25:14,275
0,195 195,530 790,1020 1020,1250 2050,2445
say,| okay, you know, object
|好的，对象 4 5 6 ，它由缓冲区一管理，

984
00:25:14,275 --> 00:25:15,835
0,270 270,465 465,785 1015,1410 1410,1560
four, five, six, that's managed

985
00:25:15,835 --> 00:25:16,945
0,165 165,450 450,705 705,915 915,1110
by buffer #1,| and then
|然后将请求发送到那个缓冲池，

986
00:25:16,945 --> 00:25:18,325
0,225 225,450 450,735 735,1085 1105,1380
send the request to that

987
00:25:18,325 --> 00:25:19,380
0,255 255,515
buffer pool,|
|

988
00:25:19,450 --> 00:25:20,475
0,275 275,455 455,650 650,875 875,1025
and all the requests for
而对其他对象的所有请求可能会结束到另一个缓冲池，

989
00:25:20,475 --> 00:25:21,735
0,180 180,510 510,825 825,1020 1020,1260
other other objects may end

990
00:25:21,735 --> 00:25:22,950
0,225 225,375 375,675 675,935 985,1215
to another buffer pool,| and
|我已经将它们隔离，

991
00:25:22,950 --> 00:25:24,570
0,150 150,570 570,890 1180,1440 1440,1620
I've isolated them,| so that
|以便它们之间的最后争用较少。

992
00:25:24,570 --> 00:25:26,430
0,945 945,1080 1080,1275 1275,1650 1650,1860
there's less last contention between

993
00:25:26,430 --> 00:25:27,740
0,120 120,210 210,285 285,530
the two of them.|
|

994
00:25:29,110 --> 00:25:30,645
0,260 260,530 530,740 740,1060 1140,1535
The simplest approach,| then, is
最简单的方法，|MySQL 所做的那样，

995
00:25:30,645 --> 00:25:31,395
0,225 225,300 300,390 390,510 510,750
to do, what {MySQL -}

996
00:25:31,395 --> 00:25:32,865
0,245 595,915 915,1095 1095,1260 1260,1470
does is,| you just take
|你只需获取记录 ID ，

997
00:25:32,865 --> 00:25:34,560
0,195 195,360 360,540 540,845 1285,1695
the the record ID,| hash
|对其进行散列，修改你拥有的缓冲池管理器编号，

998
00:25:34,560 --> 00:25:35,990
0,240 240,765 765,885 885,1080 1080,1430
it, modify the number of

999
00:25:36,040 --> 00:25:37,860
0,350 350,695 695,950 950,1210 1560,1820
{buffer,pool} managers you have| and
|这会告诉你要转到哪个（管理器），

1000
00:25:37,860 --> 00:25:38,850
0,150 150,345 345,615 615,855 855,990
that tells you which one

1001
00:25:38,850 --> 00:25:39,900
0,105 105,240 240,530
you go to,

1002
00:25:40,310 --> 00:25:41,540
0,400
right,|
|

1003
00:25:41,870 --> 00:25:43,720
0,305 305,610 930,1330 1560,1790 1790,1850
pretty simple.| Yes.| { -}
很简单。|是的。|

1004
00:25:43,720 --> 00:25:45,430
0,120 120,405 405,1020 1020,1530 1530,1710

1005
00:25:45,430 --> 00:25:47,120
0,260 370,770

1006
00:25:47,160 --> 00:25:48,230
0,305 305,590 590,815 815,920 920,1070
Yeah, so, so he said
是的，所以他说的问题是，

1007
00:25:48,230 --> 00:25:49,115
0,240 240,420 420,555 555,765 765,885
that the question is,| do
|你是否必须静态地分配每个缓冲池有多少内存，

1008
00:25:49,115 --> 00:25:50,105
0,60 60,150 150,255 255,645 645,990
you have to statically allocate

1009
00:25:50,105 --> 00:25:51,395
0,165 165,425 535,870 870,1080 1080,1290
how much memory each buffer

1010
00:25:51,395 --> 00:25:54,610
0,245 1045,1445 2035,2435 2695,2955 2955,3215
pool has,| yes, and so
|是的，在 Postgres MySQL 中，在大多数系统中，

1011
00:25:54,810 --> 00:25:57,515
0,400 780,1085 1085,1715 1715,2200 2400,2705
in in Postgres, MySQL, in

1012
00:25:57,515 --> 00:25:58,955
0,240 240,540 540,780 780,1055 1135,1440
most systems,| you cannot change
|你无法更改缓冲池的大小，

1013
00:25:58,955 --> 00:25:59,615
0,165 165,300 300,405 405,480 480,660
the size of the buffer

1014
00:25:59,615 --> 00:26:00,770
0,240 240,585 585,825 825,1020 1020,1155
pool| without actually having to
|如果不重新启动整个系统，

1015
00:26:00,770 --> 00:26:02,300
0,240 240,375 375,555 555,860
restart the entire system,|
|

1016
00:26:02,400 --> 00:26:03,860
0,245 245,440 440,790 840,1160 1160,1460
actually, in that all the
事实上，所有的开源系统都有这个限制，

1017
00:26:03,860 --> 00:26:05,225
0,255 255,435 435,740 880,1170 1170,1365
open source systems have that

1018
00:26:05,225 --> 00:26:07,370
0,515 895,1245 1245,1575 1575,1935 1935,2145
limitation,| the commercial systems could
|商业系统可以是一种聪明的，

1019
00:26:07,370 --> 00:26:08,440
0,105 105,240 240,390 390,675 675,1070
be kind of clever| and
|比如，我认为在 Oracle 中，

1020
00:26:09,590 --> 00:26:10,660
0,320 320,485 485,575 575,680 680,1070
like I think in Oracle,|
|

1021
00:26:10,660 --> 00:26:11,305
0,90 90,210 210,345 345,480 480,645
you can, you can increase
你可以增加缓冲池大小，

1022
00:26:11,305 --> 00:26:13,495
0,120 120,390 390,725 1255,1655 1825,2190
the {buffer,pool} size| and it'll
|它将分配内存，

1023
00:26:13,495 --> 00:26:14,490
0,345 345,465 465,630 630,765 765,995
allocate the memory| and then
|然后缓慢增加并将页面从一页迁移到下一页，

1024
00:26:14,780 --> 00:26:16,465
0,400 420,860 860,1100 1100,1460 1460,1685
slowly increment and migrate pages

1025
00:26:16,465 --> 00:26:18,205
0,335 355,755 865,1265 1405,1650 1650,1740
over from page to the

1026
00:26:18,205 --> 00:26:19,915
0,245 475,875 1045,1350 1350,1440 1440,1710
next, right,| that's a tricky
|这是一件棘手的事情，

1027
00:26:19,915 --> 00:26:21,070
0,150 150,300 300,480 480,785 865,1155
thing,| but most systems are
|但大多数系统都是静态分配的。

1028
00:26:21,070 --> 00:26:24,000
0,555 555,1160
statically allocated.|
|

1029
00:26:24,000 --> 00:26:25,100
0,300 300,585 585,735 735,840 840,1100

1030
00:26:26,290 --> 00:26:30,975
0,580 4050,4325 4325,4430 4430,4520 4520,4685
{}| Yeah, so his question
|是的，所以他的问题是，

1031
00:26:30,975 --> 00:26:32,865
0,305 925,1170 1170,1415 1495,1740 1740,1890
is could this,| could this
|这是否意味着你潜在地浪费内存，

1032
00:26:32,865 --> 00:26:34,620
0,225 225,545 745,1110 1110,1365 1365,1755
mean that you potentially wasting

1033
00:26:34,620 --> 00:26:35,850
0,240 240,495 495,645 645,1005 1005,1230
memory,| if you partition say
|如果你按表分区，

1034
00:26:35,850 --> 00:26:38,115
0,150 150,440 1690,1965 1965,2100 2100,2265
by table,| so for example,
|例如，如果我，

1035
00:26:38,115 --> 00:26:39,080
0,165 165,375 375,555 555,675 675,965
if I, if I say,|
|

1036
00:26:39,430 --> 00:26:40,245
0,260 260,380 380,485 485,590 590,815
I make a new buffer
如果我创建了一个新的缓冲池，

1037
00:26:40,245 --> 00:26:41,505
0,245 385,660 660,885 885,1125 1125,1260
pool,| I put, I say
|假设它有 10GB ，

1038
00:26:41,505 --> 00:26:42,690
0,90 90,240 240,450 450,935 955,1185
it has 10 gigs| and
|我说你要管理这个表，

1039
00:26:42,690 --> 00:26:43,380
0,90 90,240 240,420 420,510 510,690
I say you're gonna manage

1040
00:26:43,380 --> 00:26:44,835
0,210 210,500 970,1200 1200,1290 1290,1455
this table,| but I don't
|但我没有在那个表中放任何数据，

1041
00:26:44,835 --> 00:26:45,675
0,105 105,300 300,540 540,690 690,840
put any data in that

1042
00:26:45,675 --> 00:26:47,210
0,305 595,840 840,945 945,1245 1245,1535
table,| is that wasting space,|
|这是在浪费空间吗，|

1043
00:26:47,620 --> 00:26:48,760
0,400
yes,|
是的，|

1044
00:26:49,250 --> 00:26:50,170
0,245 245,380 380,530 530,695 695,920
but like the database system
但是数据库系统做的是你想做的，

1045
00:26:50,170 --> 00:26:50,980
0,240 240,450 450,585 585,675 675,810
did exactly what you wanted

1046
00:26:50,980 --> 00:26:52,900
0,135 135,380 1270,1530 1530,1710 1710,1920
to do,| the human was
|人类是愚蠢的，

1047
00:26:52,900 --> 00:26:55,315
0,290 1420,1995 1995,2145 2145,2250 2250,2415
stupid, right,| I mean, there's
|我是说，这里没有，

1048
00:26:55,315 --> 00:26:56,140
0,245
not,|
|

1049
00:26:56,870 --> 00:26:57,925
0,290 290,440 440,560 560,815 815,1055
yeah, because the problem, it
是的，因为问题，它不知道，

1050
00:26:57,925 --> 00:26:59,410
0,285 285,605 835,1095 1095,1275 1275,1485
doesn't know,| you think, okay,
|你在想，好的，只在需要需求的时候分配它，

1051
00:26:59,410 --> 00:27:01,000
0,210 210,450 450,900 900,1160 1270,1590
well, only allocate it when

1052
00:27:01,000 --> 00:27:02,580
0,240 240,465 465,770 1060,1320 1320,1580
demand is needed,| but like,
|但是就像，为了容纳愚蠢的人而做出的工程努力的数量，

1053
00:27:03,870 --> 00:27:05,570
0,400 630,920 920,1100 1100,1385 1385,1700
{} the amount of engineering

1054
00:27:05,570 --> 00:27:06,950
0,320 370,750 750,1020 1020,1155 1155,1380
effort to, to sort of

1055
00:27:06,950 --> 00:27:09,035
0,620 700,1020 1020,1340 1570,1905 1905,2085
accommodate stupid people,| it's probably
|那样的话可能就不值得了。

1056
00:27:09,035 --> 00:27:09,650
0,180 180,330 330,435 435,495 495,615
not worth it in that

1057
00:27:09,650 --> 00:27:11,255
0,290 340,740 880,1170 1170,1395 1395,1605
case, right.| If you're using
|如果你使用的是 DB2 ，

1058
00:27:11,480 --> 00:27:12,635
0,150 150,330 330,540 540,860 880,1155
{DB2 -},| in theory, you
|理论上，你知道，

1059
00:27:12,635 --> 00:27:14,195
0,275 655,915 915,1095 1095,1320 1320,1560
know,| if you're calling create
|如果你调用 create buffer pool 命令来执行它，

1060
00:27:14,195 --> 00:27:15,050
0,255 255,360 360,510 510,720 720,855
buffer pool the command to

1061
00:27:15,050 --> 00:27:15,815
0,75 75,285 285,525 525,660 660,765
do it,| you kind of
|你应该知道自己在做什么。

1062
00:27:15,815 --> 00:27:16,400
0,90 90,180 180,315 315,450 450,585
should be knowing what you're

1063
00:27:16,400 --> 00:27:18,820
0,230 1090,1470 1470,1850
doing, right, like.|
|

1064
00:27:23,460 --> 00:27:24,830
0,260 260,520 570,830 830,1090 1110,1370
All right, so again, in
好的，在我看来，

1065
00:27:24,830 --> 00:27:25,745
0,150 150,435 435,690 690,810 810,915
my opinion,| I think about
|我想我所说的，

1066
00:27:25,745 --> 00:27:26,525
0,75 75,180 180,375 375,570 570,780
what I said,| this is
|这是你做的第一个优化，

1067
00:27:26,525 --> 00:27:27,605
0,180 180,285 285,465 465,855 855,1080
actually the first optimization you

1068
00:27:27,605 --> 00:27:29,315
0,275 535,935 1015,1305 1305,1455 1455,1710
do| to scale your {buffer,pool}
|以扩大你的缓冲池管理器，

1069
00:27:29,315 --> 00:27:30,770
0,275 445,735 735,1020 1020,1215 1215,1455
manager,| because it's not that
|因为这不是那么多的工作，

1070
00:27:30,770 --> 00:27:32,300
0,270 270,525 525,830 1000,1260 1260,1530
much, much work,| the hashing
|哈希可能也是最容易做的，

1071
00:27:32,300 --> 00:27:33,365
0,195 195,405 405,615 615,900 900,1065
one probably the easiest one

1072
00:27:33,365 --> 00:27:34,760
0,120 120,365 415,690 690,965
to do as well,|
|

1073
00:27:36,280 --> 00:27:37,305
0,245 245,410 410,575 575,800 800,1025
because there's no central data
因为没有中央数据结构可以说，

1074
00:27:37,305 --> 00:27:38,385
0,225 225,405 405,660 660,945 945,1080
structure to say,| okay, for
|好的，对于这个对象，转到这个，

1075
00:27:38,385 --> 00:27:39,630
0,180 180,510 510,885 885,1110 1110,1245
this object, go to this

1076
00:27:39,630 --> 00:27:40,815
0,285 285,540 540,705 705,960 960,1185
one,| you just hash it
|你只需对它进行哈希，就完成了。

1077
00:27:40,815 --> 00:27:42,040
0,210 210,345 345,575
and you're done.|
|

1078
00:27:44,320 --> 00:27:45,360
0,245 245,440 440,815 815,950 950,1040
The next optimization we can
我们可以做的下一个优化是预取，

1079
00:27:45,360 --> 00:27:46,880
0,120 120,270 270,830
do is pre-fetching,|
|

1080
00:27:47,550 --> 00:27:48,335
0,260 260,365 365,530 530,680 680,785
again, the OS to do
操作系统也做预取，

1081
00:27:48,335 --> 00:27:52,295
0,575 1975,2310 2310,2555 3265,3645 3645,3960
pre-fetching,| we'll see for simple
|我们将看到，在简单的情况下，

1082
00:27:52,295 --> 00:27:53,690
0,335 385,615 615,765 765,960 960,1395
cases,| where you're doing sequential
|当你在执行顺序扫描时，

1083
00:27:53,690 --> 00:27:55,385
0,760 760,960 960,1050 1050,1215 1215,1440 1440,1695
scans,| we'll see one case, where
|我们将看到一个无法执行预取的情况。

1084
00:27:55,385 --> 00:27:56,765
0,240 240,510 510,600 600,845 1135,1380
it can't do it.| So
|所以基本的想法是，

1085
00:27:56,765 --> 00:27:57,700
0,75 75,300 300,540 540,660 660,935
the basic idea is that,|
|

1086
00:27:58,540 --> 00:27:59,820
0,260 490,750 750,870 870,990 990,1280
if you run a query|
如果你运行一个查询，|

1087
00:28:00,590 --> 00:28:01,510
0,275 275,395 395,515 515,665 665,920
and it has to start
它必须开始访问表中的数据，

1088
00:28:01,510 --> 00:28:04,320
0,500 1240,1640 1720,2120 2260,2535 2535,2810
accessing data in your table,|
|

1089
00:28:05,570 --> 00:28:06,385
0,350 350,425 425,590 590,740 740,815
it's going to open up
它将打开一个 cursor ，

1090
00:28:06,385 --> 00:28:09,235
0,120 120,575 1075,1475 2125,2475 2475,2850
a cursor,| that start scanning
|开始逐个扫描页面，

1091
00:28:09,235 --> 00:28:10,120
0,180 180,345 345,555 555,765 765,885
through the page one by

1092
00:28:10,120 --> 00:28:13,345
0,260 1510,1800 1800,2090 2650,2970 2970,3225
one,| and so assuming this
|所以，假设在我们的示例中，

1093
00:28:13,345 --> 00:28:14,260
0,180 180,300 300,480 480,720 720,915
in our example here,| our
|我们的缓冲池是空的，

1094
00:28:14,260 --> 00:28:16,080
0,225 225,470 550,810 810,1070 1420,1820
buffer pool is empty,| so
|所以，它看到的第一个页面是 page0 ，

1095
00:28:16,100 --> 00:28:18,235
0,290 290,545 545,910 1650,1970 1970,2135
the very first page that

1096
00:28:18,235 --> 00:28:20,020
0,120 120,395 655,960 960,1265 1465,1785
it sees {page0 -},| it's
|它不在缓冲池中，

1097
00:28:20,020 --> 00:28:20,760
0,90 90,180 180,255 255,480 480,740
not in the buffer pool,|
|

1098
00:28:20,930 --> 00:28:21,820
0,230 230,440 440,680 680,785 785,890
so we again, we just
所以，我们只是去复制并把它放进去，

1099
00:28:21,820 --> 00:28:22,630
0,150 150,390 390,585 585,690 690,810
go copy and put that

1100
00:28:22,630 --> 00:28:23,420
0,260
in,|
|

1101
00:28:23,430 --> 00:28:24,455
0,245 245,365 365,545 545,815 815,1025
then we scan along,| we
然后随着我们扫描，|我们需要 page1 ， page1 不在那里，

1102
00:28:24,455 --> 00:28:25,595
0,120 120,300 300,525 525,810 810,1140
need {page1 -}, {page1,is -}

1103
00:28:25,595 --> 00:28:27,185
0,120 120,425 745,1035 1035,1290 1290,1590
not there,| so go go
|所以继续并复制它，

1104
00:28:27,185 --> 00:28:28,150
0,225 225,360 360,465 465,645 645,965
goes ahead and copy that,|
|

1105
00:28:28,770 --> 00:28:29,810
0,275 275,470 470,650 650,815 815,1040
but now the database system
但现在数据库系统可以聪明地说，

1106
00:28:29,810 --> 00:28:30,725
0,150 150,300 300,525 525,690 690,915
can be smart and say,|
|

1107
00:28:30,725 --> 00:28:32,740
0,300 300,635 1195,1515 1515,1680 1680,2015
okay, well, you've read page0,
好的，你已经读取 page0 page1 ，

1108
00:28:32,910 --> 00:28:34,205
0,320 320,545 545,770 770,1055 1055,1295
read {page1 -},| it's very
|很可能你会读 page2, page3 等等，

1109
00:28:34,205 --> 00:28:35,345
0,300 300,540 540,630 630,840 840,1140
likely you're gonna read page

1110
00:28:35,345 --> 00:28:37,250
0,330 330,695 1015,1365 1365,1680 1680,1905
2, 3 and, and so

1111
00:28:37,250 --> 00:28:38,855
0,120 120,285 285,590 1210,1470 1470,1605
and so forth,| so let
|所以让我预取这些（页面），

1112
00:28:38,855 --> 00:28:39,890
0,120 120,270 270,510 510,795 795,1035
me go ahead and {pre-fetch

1113
00:28:39,890 --> 00:28:41,440
0,240 240,450 450,740
-} those guys,|
|

1114
00:28:41,870 --> 00:28:43,825
0,400 1110,1355 1355,1520 1520,1730 1730,1955
while the database system is
当数据库系统处理 page1 时，

1115
00:28:43,825 --> 00:28:45,900
0,335 505,840 840,1175
processing {page1 -},|
|

1116
00:28:46,090 --> 00:28:47,580
0,275 275,530 530,910 930,1250 1250,1490
all right, go get {page2
好的，去拿 page2 page3 ，把它放进去，

1117
00:28:47,580 --> 00:28:48,555
0,225 225,435 435,660 660,840 840,975
-}, {page3 -}, put it

1118
00:28:48,555 --> 00:28:50,355
0,275 895,1155 1155,1380 1380,1620 1620,1800
in,| so that by the
|这样当你处理完 page1 时，

1119
00:28:50,355 --> 00:28:53,115
0,255 255,525 525,785 1045,1445 2455,2760
time you're finished processing {page1

1120
00:28:53,115 --> 00:28:54,300
0,305 595,855 855,975 975,1080 1080,1185
-}| and you come to
|你来到 page2 ，

1121
00:28:54,300 --> 00:28:55,230
0,165 165,390 390,555 555,645 645,930
{page2 -},| [] and behold,
|你正在寻找的页面，

1122
00:28:55,230 --> 00:28:56,910
0,180 180,345 345,540 540,770 1450,1680
the page you're looking,| the
|你需要的下一页已经在那里了，

1123
00:28:56,910 --> 00:28:57,660
0,120 120,270 270,375 375,540 540,750
next page you need is

1124
00:28:57,660 --> 00:28:58,760
0,195 195,500
already there,

1125
00:29:00,480 --> 00:29:01,520
0,290 290,440 440,575 575,815 815,1040
right,| and just do this
|从头到尾一直这样做。

1126
00:29:01,520 --> 00:29:02,075
0,105 105,195 195,300 300,435 435,555
all the way down the

1127
00:29:02,075 --> 00:29:03,635
0,245 445,845 985,1245 1245,1470 1470,1560
line, right.| We haven't talked
|我们还没有讨论如何执行查询，

1128
00:29:03,635 --> 00:29:04,460
0,105 105,210 210,360 360,540 540,825
about how we execute queries

1129
00:29:04,460 --> 00:29:06,005
0,150 150,440 670,990 990,1290 1290,1545
just yet,| but typically the
|但通常它的工作方式是，

1130
00:29:06,005 --> 00:29:06,970
0,150 150,285 285,480 480,690 690,965
way it works is that,|
|

1131
00:29:07,530 --> 00:29:09,785
0,400 690,980 980,1145 1145,1420 1950,2255
you request a page,| it's
你请求一个页面，|它在其中有一堆 tuple ，

1132
00:29:09,785 --> 00:29:10,070
0,45 45,90 90,150 150,210 210,285
going to have a bunch

1133
00:29:10,070 --> 00:29:11,225
0,120 120,360 360,480 480,740 910,1155
of tuples in it,| you
|你在这 tuple 中的数据上进行某种计算，

1134
00:29:11,225 --> 00:29:12,790
0,245 565,855 855,990 990,1080 1080,1565
do some kind of computation

1135
00:29:12,960 --> 00:29:14,090
0,290 290,425 425,670 720,1040 1040,1130
inside the data, that's in

1136
00:29:14,090 --> 00:29:15,605
0,135 135,560 850,1125 1125,1305 1305,1515
those tuples,| and then when
|然后当你完成后，

1137
00:29:15,605 --> 00:29:17,165
0,225 225,485 1015,1305 1305,1455 1455,1560
you're done,| go get the
|转到下一页，

1138
00:29:17,165 --> 00:29:19,390
0,150 150,455 1345,1620 1620,1905 1905,2225
next page,| as you're doing
|当你沿着查找计划树的叶子节点进行扫描时。

1139
00:29:19,560 --> 00:29:20,810
0,320 320,545 545,850 870,1115 1115,1250
your scan along the leaf

1140
00:29:20,810 --> 00:29:21,530
0,225 225,300 300,375 375,555 555,720
nodes of the query plan

1141
00:29:21,530 --> 00:29:22,440
0,320
tree.|
|

1142
00:29:22,440 --> 00:29:23,790
0,240 240,500 640,990 990,1155 1155,1350
And so it's not like
所以，我们并不是盲目地翻阅页面，

1143
00:29:23,790 --> 00:29:24,960
0,180 180,315 315,750 750,1035 1035,1170
we're just blindly ripping through

1144
00:29:24,960 --> 00:29:26,475
0,135 135,410 910,1185 1185,1365 1365,1515
the pages| and say, you
|然后说，获取，获取，获取，获取，

1145
00:29:26,475 --> 00:29:27,440
0,120 120,285 285,465 465,660 660,965
know, get, get, get, get,|
|

1146
00:29:27,910 --> 00:29:29,835
0,350 350,640 1230,1520 1520,1715 1715,1925
it get some think time,
它得到一些思考时间，做一些计算，

1147
00:29:29,835 --> 00:29:31,770
0,165 165,270 270,665 1345,1665 1665,1935
do some compute,| then go
|然后去拿下一页，

1148
00:29:31,770 --> 00:29:32,655
0,210 210,315 315,465 465,690 690,885
get the next page,| and
|所以思考时间就是数据库系统说的，

1149
00:29:32,655 --> 00:29:33,600
0,135 135,300 300,510 510,735 735,945
so that think time is

1150
00:29:33,600 --> 00:29:34,635
0,225 225,420 420,585 585,825 825,1035
where the database system say,|
|

1151
00:29:34,635 --> 00:29:35,415
0,180 180,360 360,510 510,645 645,780
I I have some time
我有一些时间继续，

1152
00:29:35,415 --> 00:29:36,285
0,120 120,225 225,345 345,525 525,870
to go ahead| and pre-fetch
|去预取你需要的东西。

1153
00:29:36,285 --> 00:29:37,155
0,165 165,330 330,540 540,705 705,870
the things that that you're

1154
00:29:37,155 --> 00:29:37,940
0,335
needing,

1155
00:29:38,550 --> 00:29:39,760
0,400
right.|
|

1156
00:29:39,960 --> 00:29:40,850
0,260 260,485 485,740 740,800 800,890
And I don't have the
我这里没有图表，

1157
00:29:40,850 --> 00:29:41,735
0,330 330,510 510,645 645,750 750,885
diagram here,| but this is
|但这就是为什么我们以前有那个[钉住]机制，

1158
00:29:41,735 --> 00:29:43,000
0,150 150,285 285,465 465,785 865,1265
why we have that, that

1159
00:29:43,500 --> 00:29:46,010
0,520 750,1150 1260,1660 1890,2255 2255,2510
[pinning] mechanism before, right,| I
|我显然不想取 page1 ，

1160
00:29:46,010 --> 00:29:46,925
0,285 285,495 495,735 735,825 825,915
don't obviously don't want to

1161
00:29:46,925 --> 00:29:48,875
0,150 150,315 315,570 570,935 1615,1950
fetch in {page1 -},| then
|然后数据库系统说，在后台线程中，

1162
00:29:48,875 --> 00:29:50,045
0,195 195,360 360,555 555,845 925,1170
the database system says, in

1163
00:29:50,045 --> 00:29:50,975
0,105 105,330 330,645 645,840 840,930
a background thread,| okay, let
|好的，让我去预取 page3 和 page2 ，

1164
00:29:50,975 --> 00:29:52,595
0,90 90,335 445,990 990,1355 1375,1620
me go prefetch {page3 -}

1165
00:29:52,595 --> 00:29:53,675
0,135 135,425 625,870 870,960 960,1080
and 2| and it goes
|它会交换 page1 ，

1166
00:29:53,675 --> 00:29:54,695
0,150 150,360 360,570 570,795 795,1020
and swaps out {page1 -},|
|

1167
00:29:54,695 --> 00:29:55,810
0,165 165,330 330,525 525,855 855,1115
while you're still accessing it,
当你仍然访问它时，

1168
00:29:55,920 --> 00:29:57,160
0,320 320,530 530,725 725,935 935,1240
right,| the pin will will,
|[钉住]机制将防止这种情况发生。

1169
00:29:57,420 --> 00:29:58,895
0,290 290,530 530,790 810,1175 1175,1475
the [pinning] mechanism will prevent

1170
00:29:58,895 --> 00:29:59,660
0,335
that.|
|

1171
00:30:00,290 --> 00:30:01,460
0,400
Yes.|
是的。|

1172
00:30:02,620 --> 00:30:03,585
0,260 260,410 410,560 560,695 695,965

1173
00:30:03,585 --> 00:30:05,835
0,375 375,755 895,1320 1320,1595 1975,2250

1174
00:30:05,835 --> 00:30:06,880
0,150 150,345 345,665

1175
00:30:07,020 --> 00:30:08,465
0,275 275,500 500,850 1050,1310 1310,1445
This question,| {} good point,
这个问题，|说得好，谢谢，

1176
00:30:08,465 --> 00:30:09,790
0,135 135,395 595,855 855,1020 1020,1325
thank you,| his question is,|
|他的问题是，|

1177
00:30:10,140 --> 00:30:11,375
0,260 260,395 395,670 780,1055 1055,1235
is it possible for different
不同的缓冲池是否可能保存相同的页面，

1178
00:30:11,375 --> 00:30:13,085
0,455 925,1260 1260,1455 1455,1575 1575,1710
buffer, buffer pools to hold

1179
00:30:13,085 --> 00:30:14,940
0,135 135,300 300,605 835,1235
the same page,| no.|
|不会。|

1180
00:30:14,940 --> 00:30:15,630
0,195 195,390 390,510 510,600 600,690
It's, it's always been a
它总是多一个[匹配]，

1181
00:30:15,630 --> 00:30:16,815
0,150 150,300 300,735 735,930 930,1185
one more [correspondent],| every page
|每个页面只能存在于一个缓冲池中，

1182
00:30:16,815 --> 00:30:17,595
0,150 150,330 330,525 525,645 645,780
can only exist in one

1183
00:30:17,595 --> 00:30:19,020
0,255 255,515 925,1185 1185,1305 1305,1425
buffer pool,| because think about
|因为考虑一下如果你允许这个会发生什么，

1184
00:30:19,020 --> 00:30:19,905
0,120 120,240 240,480 480,735 735,885
what would happen if you

1185
00:30:19,905 --> 00:30:22,660
0,195 195,435 435,755
allowed that, right,|
|

1186
00:30:23,070 --> 00:30:24,275
0,400 570,845 845,980 980,1085 1085,1205
well, you could have the
好的，你可以把页表指向相同的页面，

1187
00:30:24,275 --> 00:30:25,420
0,165 165,390 390,660 660,870 870,1145
page table pointed the same,

1188
00:30:26,700 --> 00:30:28,090
0,305 305,470 470,620 620,910 990,1390
point to the same page,|
|

1189
00:30:28,860 --> 00:30:29,795
0,260 260,425 425,680 680,875 875,935
{} different page point to
不同的页面指向相同的页面，

1190
00:30:29,795 --> 00:30:31,030
0,60 60,210 210,515 745,990 990,1235
the same page,| but then
|但取决于元数据的位置，

1191
00:30:31,050 --> 00:30:32,345
0,305 305,470 470,590 590,1115 1115,1295
depending where the metadata is,|
|

1192
00:30:32,345 --> 00:30:33,770
0,195 195,300 300,510 510,875 1135,1425
like the reference counter, the
如引用计数器、[插针]标记和类似的东西，

1193
00:30:33,770 --> 00:30:35,105
0,290 610,1020 1020,1095 1095,1200 1200,1335
pin marker and things like

1194
00:30:35,105 --> 00:30:37,685
0,275 1675,1935 1935,2070 2070,2415 2415,2580
that,| like if that's separate
|如果这是单独的页面，

1195
00:30:37,685 --> 00:30:39,010
0,150 150,345 345,630 630,960 960,1325
and separate pages,| then then
|那么一个缓冲池可能会说，

1196
00:30:39,240 --> 00:30:40,340
0,320 320,605 605,710 710,860 860,1100
one buffer pool may say,|
|

1197
00:30:40,340 --> 00:30:41,525
0,270 270,465 465,750 750,945 945,1185
okay, no one's access {to,it},|
好的，没有人访问它了，|

1198
00:30:41,525 --> 00:30:42,155
0,195 195,315 315,450 450,525 525,630
let me, let me go
让我把它交换出去，

1199
00:30:42,155 --> 00:30:43,070
0,180 180,300 300,545 625,855 855,915
swap it out,| but the
|但另一个页表被固定了，

1200
00:30:43,070 --> 00:30:44,045
0,135 135,330 330,540 540,735 735,975
other page table has it,

1201
00:30:44,045 --> 00:30:45,080
0,255 255,420 420,780 780,960 960,1035
has it pinned| and you
|你可能会错过它。

1202
00:30:45,080 --> 00:30:46,100
0,105 105,270 270,560
would miss that.|
|

1203
00:30:46,500 --> 00:30:47,650
0,305 305,530 530,695 695,845 845,1150
So yeah, for that reason,|
所以，出于这个原因，|

1204
00:30:48,690 --> 00:30:49,960
0,290 290,365 365,500 500,665 665,1270
it's a one one correspondent.|
这是一对一的匹配。|

1205
00:30:52,430 --> 00:30:52,925
0,60 60,105 105,195 195,345 345,495
That's a good point, thank
这是很好的观点，谢谢。

1206
00:30:52,925 --> 00:30:53,720
0,275
you.|
|

1207
00:30:54,490 --> 00:30:56,010
0,350 350,590 590,785 785,1090 1260,1520
Yes.| { - - -}
是的。|

1208
00:30:56,010 --> 00:30:56,560
0,165 165,470

1209
00:30:58,590 --> 00:30:59,465
0,260 260,395 395,530 530,695 695,875
This question is,| what's the
这个问题是，|pin counter 和 latch 之间的关系是什么，

1210
00:30:59,465 --> 00:31:00,440
0,300 300,495 495,630 630,795 795,975
relation between a pin counter

1211
00:31:00,440 --> 00:31:01,565
0,120 120,180 180,440 610,915 915,1125
and a latch,| a pin
|一个 pin counter 只表示，

1212
00:31:01,565 --> 00:31:03,905
0,270 270,510 510,750 750,1115 1795,2340
counter just says that,| there's
|这里有一些，

1213
00:31:03,905 --> 00:31:06,100
0,335
some,

1214
00:31:06,170 --> 00:31:07,900
0,400
some,|
|

1215
00:31:08,870 --> 00:31:10,885
0,400 1200,1460 1460,1595 1595,1850 1850,2015
so, the pin counter says,|
所以， pin counter 表示，|

1216
00:31:10,885 --> 00:31:13,555
0,270 270,575 1105,1505 1855,2280 2280,2670
there's some worker that's accessing
有一些 worker 正在访问这个页面，

1217
00:31:13,555 --> 00:31:15,070
0,240 240,575 955,1185 1185,1350 1350,1515
this page,| but I'm not
|但我现在不在页表中，

1218
00:31:15,070 --> 00:31:15,940
0,180 180,315 315,495 495,705 705,870
in the page table,| right
|我正在做的，

1219
00:31:15,940 --> 00:31:16,920
0,150 150,285 285,480 480,660 660,980
now, when I'm doing it,

1220
00:31:17,090 --> 00:31:18,600
0,400 510,770 770,890 890,1040 1040,1510
right,| I get the pointer
|我会将指针指向页面，

1221
00:31:18,800 --> 00:31:20,020
0,260 260,380 380,640 900,1130 1130,1220
to the page,| go back
|返回到我的原始图表。

1222
00:31:20,020 --> 00:31:21,380
0,90 90,165 165,300 300,740
to my original diagram.|
|

1223
00:31:25,050 --> 00:31:26,650
0,275 275,410 410,545 545,820 1200,1600
Right, going back here,| so
好的，回到这里，|所以我不在页表上，

1224
00:31:27,390 --> 00:31:28,055
0,215 215,305 305,365 365,485 485,665
I don't on the page

1225
00:31:28,055 --> 00:31:29,540
0,225 225,390 390,635 985,1275 1275,1485
table,| but like this guy
|但就像这个说的，

1226
00:31:29,540 --> 00:31:30,670
0,210 210,345 345,480 480,750 750,1130
says,| give me page #2,|
|给我页面二，|

1227
00:31:31,080 --> 00:31:32,195
0,320 320,485 485,620 620,905 905,1115
I take a latch in
我在页表中使用 latch ，

1228
00:31:32,195 --> 00:31:33,620
0,150 150,405 405,755 1015,1275 1275,1425
the page table| to go
|去获取指向那个页面的指针，

1229
00:31:33,620 --> 00:31:34,630
0,150 150,285 285,585 585,735 735,1010
get the pointer to that,

1230
00:31:34,920 --> 00:31:37,020
0,400 570,875 875,1180
to that page,|
|

1231
00:31:37,020 --> 00:31:38,565
0,90 90,350 910,1230 1230,1425 1425,1545
and then before I get
然后在我把指针放回我的执行引擎之前，

1232
00:31:38,565 --> 00:31:39,885
0,120 120,450 450,755 895,1155 1155,1320
the pointer back to my

1233
00:31:39,885 --> 00:31:41,420
0,195 195,485 595,990 990,1260 1260,1535
execution engine,| I pin it,|
|我把它[钉住]，|

1234
00:31:42,390 --> 00:31:43,400
0,320 320,530 530,710 710,845 845,1010
because now I'm not inside
因为现在我不在页表中，

1235
00:31:43,400 --> 00:31:44,180
0,105 105,225 225,405 405,600 600,780
the page table,| because the
|因为 latch 保护数据结构，

1236
00:31:44,180 --> 00:31:45,920
0,180 180,470 970,1290 1290,1455 1455,1740
pin is latch of protecting

1237
00:31:45,920 --> 00:31:46,820
0,105 105,300 300,600 600,780 780,900
the data structure,| but I'm
|但我不在数据结构中，

1238
00:31:46,820 --> 00:31:47,620
0,105 105,210 210,285 285,465 465,800
out of the data structure,|
|

1239
00:31:47,940 --> 00:31:48,820
0,245 245,335 335,455 455,605 605,880
but I have a reference
但我有一个对页面的引用，

1240
00:31:48,960 --> 00:31:50,480
0,260 260,395 395,670 990,1310 1310,1520
to the page,| so the
|所以， pin 应该表明，

1241
00:31:50,480 --> 00:31:51,340
0,165 165,315 315,450 450,585 585,860
pin is supposed to say,|
|

1242
00:31:51,480 --> 00:31:52,520
0,290 290,500 500,680 680,845 845,1040
someone is actually reading this
有人读取这个页面，

1243
00:31:52,520 --> 00:31:53,915
0,290 640,900 900,1065 1065,1215 1215,1395
page| and then when I'm
|然后当我完成它时，

1244
00:31:53,915 --> 00:31:55,010
0,245 295,570 570,705 705,900 900,1095
done, done with it,| I
|我可以递减引用计数器，

1245
00:31:55,010 --> 00:31:56,350
0,105 105,350 460,855 855,1095 1095,1340
can then {}, you know,

1246
00:31:56,430 --> 00:31:58,055
0,350 350,530 530,785 785,1120 1290,1625
decrement the reference counter,| which
|这可能会解锁或释放 pin ，

1247
00:31:58,055 --> 00:31:59,990
0,335 355,795 795,960 960,1235 1615,1935
potentially unlock the or release

1248
00:31:59,990 --> 00:32:01,870
0,210 210,500 1120,1380 1380,1560 1560,1880
the pin,| and then now
|然后现在缓冲池管理器可以决定，

1249
00:32:02,010 --> 00:32:03,490
0,350 350,695 695,920 920,1175 1175,1480
the {buffer,pool} manager can decide,|
|

1250
00:32:03,540 --> 00:32:05,210
0,400 450,740 740,1030 1080,1430 1430,1670
okay, I know for this
好的，我知道对于这个页面二，

1251
00:32:05,210 --> 00:32:06,650
0,225 225,560 790,1110 1110,1290 1290,1440
page #2,| nobody has it
|没有人将其钉住，

1252
00:32:06,650 --> 00:32:07,775
0,285 285,450 450,600 600,1005 1005,1125
pinned,| there's nobody referencing it,|
|没有人引用它，|

1253
00:32:07,775 --> 00:32:08,525
0,105 105,315 315,555 555,660 660,750
so it's, I'm free to
所以我可以自由地驱逐它。

1254
00:32:08,525 --> 00:32:09,340
0,225 225,515
evict it.|
|

1255
00:32:10,160 --> 00:32:11,290
0,275 275,410 410,560 560,845 845,1130
So again, the latch protects
所以， latch 保护数据结构，

1256
00:32:11,290 --> 00:32:12,325
0,105 105,255 255,480 480,720 720,1035
the data structure,| the pin
|pin 保护页面。

1257
00:32:12,325 --> 00:32:13,915
0,330 330,600 600,720 720,995 1285,1590
pin protects the page.| Yes.|
|是的。|

1258
00:32:13,915 --> 00:32:14,635
0,165 165,285 285,375 375,495 495,720

1259
00:32:14,635 --> 00:32:16,300
0,335 655,915 915,1080 1080,1350 1350,1665

1260
00:32:16,300 --> 00:32:17,920
0,270 270,620 940,1245 1245,1395 1395,1620

1261
00:32:17,920 --> 00:32:18,445
0,105 105,180 180,300 300,420 420,525

1262
00:32:18,445 --> 00:32:20,160
0,555 555,1125 1125,1415

1263
00:32:20,740 --> 00:32:21,890
0,305 305,515 515,695 695,860 860,1150
{All,right}, question is that, the,
好的，问题是。

1264
00:32:21,910 --> 00:32:24,960
0,400 1650,2045 2045,2435 2435,2810 2810,3050
the.| {Page,tables} like separate from
|页表是从缓冲池中分离出来的？

1265
00:32:24,960 --> 00:32:26,430
0,120 120,375 375,650 1060,1335 1335,1470
the buffer pool?| It is
|它就是缓冲池。

1266
00:32:26,430 --> 00:32:27,735
0,90 90,300 300,560 880,1155 1155,1305
the buffer pool.| I guess
|我想是。

1267
00:32:27,735 --> 00:32:28,540
0,275
like.|
|

1268
00:32:29,270 --> 00:32:30,280
0,350 350,560 560,680 680,785 785,1010
Yeah, this is like a
是的，这是一张图表，

1269
00:32:30,280 --> 00:32:31,940
0,480 480,705 705,950
diagram,| but like,
|但它在这个盒子中，这个怎么样。

1270
00:32:32,560 --> 00:32:33,900
0,380 380,530 530,740 740,1060 1080,1340
it's in this box, how

1271
00:32:33,900 --> 00:32:36,920
0,120 120,380 1720,2120 2440,2730 2730,3020
about that.| Right, these are,
|这些是 frame ，

1272
00:32:37,000 --> 00:32:38,820
0,275 275,395 395,515 515,820 1590,1820
these are the frames,| there
|这里还有一些其他的页表数据结构。

1273
00:32:38,820 --> 00:32:39,795
0,90 90,195 195,405 405,690 690,975
are some other page table

1274
00:32:39,795 --> 00:32:41,600
0,255 255,450 450,755
data structure here.|
|

1275
00:32:43,440 --> 00:32:45,520
0,400 420,1145 1145,1355 1355,1745 1745,2080

1276
00:32:45,600 --> 00:32:46,840
0,400 540,875 875,1190

1277
00:32:48,040 --> 00:32:48,915
0,260 260,365 365,470 470,665 665,875

1278
00:32:48,915 --> 00:32:49,460
0,275

1279
00:32:50,300 --> 00:32:51,580
0,400

1280
00:32:54,290 --> 00:32:56,010
0,245 245,365 365,560 560,880 1320,1720
So his question is,| does
所以，他的问题是，|缓冲池管理器是否需要访问查询计划，

1281
00:32:56,450 --> 00:32:57,730
0,245 245,530 530,740 740,1040 1040,1280
the {buffer,pool} manager have access

1282
00:32:57,730 --> 00:32:59,010
0,135 135,225 225,420 420,740 880,1280
to the query plan,| no,
|不，因为我们有这些层，

1283
00:32:59,510 --> 00:33:01,060
0,400 930,1205 1205,1325 1325,1415 1415,1550
right, because we have these

1284
00:33:01,060 --> 00:33:02,365
0,470 670,930 930,1050 1050,1185 1185,1305
layers,| but you can send
|但你可以给它发提示，

1285
00:33:02,365 --> 00:33:04,600
0,135 135,605 1435,1755 1755,1950 1950,2235
it hints,| {BusTub -} doesn't
|BusTub 不支持这些提示，

1286
00:33:04,600 --> 00:33:05,425
0,165 165,315 315,570 570,705 705,825
support those hints,| but you
|但你可以向它发送提示，

1287
00:33:05,425 --> 00:33:06,130
0,135 135,285 285,390 390,585 585,705
can send it hints,| like
|比如，我正在访问这个页面，

1288
00:33:06,130 --> 00:33:07,410
0,255 255,525 525,840 840,990 990,1280
I'm, I'm accessing this page,|
|

1289
00:33:09,350 --> 00:33:10,870
0,400 630,1010 1010,1220 1220,1400 1400,1520
and here's likely the next
这是我接下来要访问的页面，

1290
00:33:10,870 --> 00:33:11,620
0,195 195,390 390,450 450,585 585,750
pages I'm going to access

1291
00:33:11,620 --> 00:33:13,330
0,135 135,410 820,1220 1330,1590 1590,1710
as well,| yes, then you
|是的，然后你说了一些关于静态的事情？

1292
00:33:13,330 --> 00:33:19,810
0,150 150,330 330,495 495,800 6130,6480
said something about static?| {}
|

1293
00:33:19,810 --> 00:33:21,240
0,285 285,600 600,915 915,1140 1140,1430

1294
00:33:22,050 --> 00:33:23,060
0,230 230,275 275,320 320,485 485,1010
What do you might [statically]
从[静态]角度看，可能知道什么？

1295
00:33:23,060 --> 00:33:27,380
0,260
know?|
|

1296
00:33:27,570 --> 00:33:28,680
0,400

1297
00:33:29,630 --> 00:33:31,105
0,305 305,485 485,760 810,1210 1230,1475

1298
00:33:31,105 --> 00:33:31,820
0,120 120,270 270,545

1299
00:33:34,560 --> 00:33:35,530
0,305 305,425 425,500 500,665 665,970
Okay, so his question is,|
好的，所以他的问题是，|

1300
00:33:36,540 --> 00:33:37,235
0,245 245,335 335,410 410,530 530,695
if I have a SELECT
如果我有一个 SELECT 查询，

1301
00:33:37,235 --> 00:33:40,910
0,305 2305,3165 3165,3405 3405,3525 3525,3675
query,| who's figuring out what
|正在计算预取，

1302
00:33:40,910 --> 00:33:41,795
0,105 105,450 450,660 660,825 825,885
the prefetch,| maybe that's what
|也许这是你真正想问的，

1303
00:33:41,795 --> 00:33:43,700
0,180 180,345 345,635 1465,1755 1755,1905
you're really asking,| this has
|这必须对执行引擎，

1304
00:33:43,700 --> 00:33:45,360
0,195 195,420 420,600 600,890
to {[],the} execution engine,|
|

1305
00:33:46,000 --> 00:33:47,520
0,245 245,470 470,730 810,1250 1250,1520
the {buffer,pool} manager doesn't know
缓冲池管理器不知道，

1306
00:33:47,520 --> 00:33:48,800
0,380
about,|
|

1307
00:33:50,610 --> 00:33:51,710
0,350 350,500 500,695 695,905 905,1100
it's just, yeah, it's, it's
它只是，是的，这是一种[部门]职责，

1308
00:33:51,710 --> 00:33:53,560
0,135 135,375 375,765 765,1370 1450,1850
sort of division responsibilities,| like
|比如[]管理器不应该推断，

1309
00:33:53,640 --> 00:33:55,160
0,245 245,395 395,640 900,1355 1355,1520
the [] manager shouldn't have

1310
00:33:55,160 --> 00:33:56,930
0,240 240,620 1090,1440 1440,1635 1635,1770
to infer,| like for this
|比如对于这个表上的查询计划，我将要读取的页面，

1311
00:33:56,930 --> 00:33:58,130
0,240 240,495 495,720 720,930 930,1200
query plan on on this

1312
00:33:58,130 --> 00:33:59,180
0,350 400,690 690,840 840,930 930,1050
table, what page that I'm

1313
00:33:59,180 --> 00:34:00,170
0,90 90,350 370,645 645,810 810,990
gonna read,| that all comes
|这一切都归结到下面，

1314
00:34:00,170 --> 00:34:01,400
0,195 195,500 730,975 975,1080 1080,1230
down below,| because you think
|因为你也想过，那是，

1315
00:34:01,400 --> 00:34:02,380
0,150 150,270 270,435 435,735 735,980
about it too, that's where,|
|

1316
00:34:02,490 --> 00:34:03,590
0,305 305,530 530,785 785,995 995,1100
the {execution -} has to
执行必须直到需要读取哪一页，

1317
00:34:03,590 --> 00:34:04,205
0,75 75,195 195,345 345,480 480,615
know what page it needs

1318
00:34:04,205 --> 00:34:04,940
0,120 120,300 300,510 510,630 630,735
to read anyway,| because as
|因为这样才能读取它们，

1319
00:34:04,940 --> 00:34:06,020
0,120 120,255 255,530
to read them,|
|

1320
00:34:06,170 --> 00:34:07,585
0,305 305,530 530,755 755,1060 1080,1415
so all that logic is
所以所有的逻辑都在系统的这一部分，

1321
00:34:07,585 --> 00:34:08,310
0,180 180,300 300,420 420,495 495,725
in that part of the

1322
00:34:08,420 --> 00:34:09,550
0,400 510,755 755,890 890,995 995,1130
system,| which we'll cover in
|我们将在两周内讨论。

1323
00:34:09,550 --> 00:34:16,585
0,105 105,350 3880,4280 6430,6795 6795,7035
two weeks.| Yeah, {execution,engine} should
|是的，执行引擎应该会说，

1324
00:34:16,585 --> 00:34:18,595
0,275 505,900 900,1305 1305,1655 1675,2010
say,| I'm fetching {page1 -}
|我现在正在取回 page1 ，

1325
00:34:18,595 --> 00:34:19,585
0,300 300,510 510,660 660,810 810,990
now,| but by the way,
|但顺便说一句，我也会取回 page2 和 page3 ，

1326
00:34:19,585 --> 00:34:20,740
0,255 255,375 375,600 600,915 915,1155
I'm also gonna fetch page

1327
00:34:20,740 --> 00:34:22,105
0,165 165,315 315,620 970,1230 1230,1365
2 and 3, right,| because
|因为想象一下，

1328
00:34:22,105 --> 00:34:22,975
0,150 150,285 285,390 390,615 615,870
think about it,| like you
|你可以有一个，

1329
00:34:22,975 --> 00:34:24,900
0,165 165,345 345,600 600,965
could have a {},|
|

1330
00:34:25,430 --> 00:34:26,260
0,260 260,365 365,485 485,665 665,830
you could have like, in
比如在你的 SELECT 语句中，在这个查询里，

1331
00:34:26,260 --> 00:34:27,250
0,165 165,375 375,645 645,870 870,990
your SELECT clause, in the

1332
00:34:27,250 --> 00:34:28,315
0,210 210,530 670,915 915,990 990,1065
query here,| you could have
|你可以有一个 LIMIT 10 ，

1333
00:34:28,315 --> 00:34:30,760
0,135 135,425 655,1055 1675,2075 2155,2445
a LIMIT 10, right,| with
|没有 WHERE 语句，

1334
00:34:30,760 --> 00:34:32,370
0,195 195,435 435,585 585,800 1210,1610
no where {clause -},| so
|在第一页中，我得到五个 tuple ，

1335
00:34:32,990 --> 00:34:34,270
0,275 275,425 425,665 665,1025 1025,1280
in the first page I

1336
00:34:34,270 --> 00:34:35,410
0,210 210,495 495,870 870,1005 1005,1140
got five tuples,| in the
|在第二页中，

1337
00:34:35,410 --> 00:34:37,195
0,240 240,590 970,1370 1390,1665 1665,1785
second page,| or {page0 -},
|或者在 page0 中，我获得五个 tuple ，

1338
00:34:37,195 --> 00:34:38,380
0,90 90,210 210,390 390,785 865,1185
I got five twoils,| in
|在 page1 ，我得到五个 tuple ，

1339
00:34:38,380 --> 00:34:39,385
0,240 240,450 450,585 585,765 765,1005
{page1 -}, I got two

1340
00:34:39,385 --> 00:34:41,230
0,195 195,485 1195,1425 1425,1605 1605,1845
{tuples -},| therefore, I know
|因此，我知道我必须读取更多页面，

1341
00:34:41,230 --> 00:34:41,770
0,180 180,255 255,345 345,435 435,540
I'm gonna have to read

1342
00:34:41,770 --> 00:34:42,610
0,150 150,435 435,660 660,720 720,840
more pages,| so you can
|这样你能提前发送提示或类似的东西。

1343
00:34:42,610 --> 00:34:43,560
0,150 150,300 300,525 525,705 705,950
send that hint, you know,

1344
00:34:43,610 --> 00:34:44,290
0,260 260,365 365,470 470,575 575,680
ahead of time or something

1345
00:34:44,290 --> 00:34:45,140
0,135 135,410
like that.|
|

1346
00:34:46,310 --> 00:34:47,365
0,245 245,455 455,560 560,755 755,1055
Again, that's the beauty of
再次，这就是拥有像 SQL 这样的声明性语言的好处，

1347
00:34:47,365 --> 00:34:48,655
0,255 255,375 375,810 810,1095 1095,1290
having a declarative language like

1348
00:34:48,655 --> 00:34:50,290
0,315 315,465 465,645 645,965 1345,1635
SQL,| where you know what
|你可以提前知道要做什么，

1349
00:34:50,290 --> 00:34:50,995
0,180 180,270 270,375 375,540 540,705
you're going to do ahead

1350
00:34:50,995 --> 00:34:52,100
0,105 105,365
of time,

1351
00:34:52,270 --> 00:34:54,330
0,305 305,440 440,670 1710,1955 1955,2060
right,| at least at a
|至少在高级别上，

1352
00:34:54,330 --> 00:34:56,400
0,150 150,440 580,900 900,1220
high level,| with enough,
|你有足够的信息来做出这样的决定。

1353
00:34:56,400 --> 00:34:57,495
0,150 150,270 270,560 640,945 945,1095
you have enough information where

1354
00:34:57,495 --> 00:34:58,395
0,150 150,390 390,615 615,780 780,900
you could make these kind

1355
00:34:58,395 --> 00:34:59,660
0,150 150,455
of decisions.|
|

1356
00:35:00,270 --> 00:35:02,110
0,400 570,970 1200,1430 1430,1550 1550,1840

1357
00:35:02,130 --> 00:35:02,800
0,610

1358
00:35:10,400 --> 00:35:12,310
0,215 215,430 450,755 755,1060 1680,1910
So the question is,| do
所以问题是，|你是否永远不预取页面，

1359
00:35:12,310 --> 00:35:13,470
0,105 105,360 360,615 615,840 840,1160
you never {pre-fetch -} pages|
|

1360
00:35:14,720 --> 00:35:15,910
0,275 275,530 530,785 785,1010 1010,1190
unless you're absolutely certain you're
除非你绝对确定你会需要它们，

1361
00:35:15,910 --> 00:35:17,245
0,105 105,240 240,375 375,650 1060,1335
going to need them,| maybe
|也许这就是你要问的？

1362
00:35:17,245 --> 00:35:18,380
0,165 165,225 225,330 330,545
that's what you're asking?|
|

1363
00:35:19,645 --> 00:35:20,890
0,150 150,425 775,1020 1020,1110 1110,1245
Actually, I don't. I don't
事实上，我不知道他们有多激进，是的，

1364
00:35:20,890 --> 00:35:22,050
0,195 195,435 435,705 705,900 900,1160
know how aggressive they are,

1365
00:35:22,640 --> 00:35:25,620
0,380
yeah,|
|

1366
00:35:27,040 --> 00:35:28,530
0,400 480,830 830,1160 1160,1385 1385,1490
the commercial systems do this
商业系统在这方面做得要好得多，

1367
00:35:28,530 --> 00:35:29,600
0,150 150,375 375,570 570,765 765,1070
much better| and they obviously
|他们显然是闭源的，

1368
00:35:29,740 --> 00:35:32,220
0,335 335,670
closed source,|
|

1369
00:35:34,130 --> 00:35:35,035
0,245 245,410 410,635 635,770 770,905
so schedule scans is pretty
所以，对于索引扫描来说，计划扫描非常容易，

1370
00:35:35,035 --> 00:35:37,555
0,275 865,1215 1215,1470 1470,1805 2215,2520
easy for index scans,| next
|下一张幻灯片，

1371
00:35:37,555 --> 00:35:38,740
0,305
slide,|
|

1372
00:35:38,740 --> 00:35:39,955
0,210 210,510 510,750 750,990 990,1215
this one can be kind
这个问题也可能有点棘手，

1373
00:35:39,955 --> 00:35:41,310
0,135 135,405 405,555 555,875 955,1355
of tricky as well,| because,
|因为，你可能无法预取，

1374
00:35:43,120 --> 00:35:43,845
0,260 260,395 395,530 530,620 620,725
you may not be able

1375
00:35:43,845 --> 00:35:45,440
0,180 180,725
to prefetch,|
|

1376
00:35:45,450 --> 00:35:48,380
0,400 450,850 930,1330 1380,1780 2610,2930
without following along the the
如果不跟着页面走，

1377
00:35:48,380 --> 00:35:50,710
0,320 880,1170 1170,1460 1840,2085 2085,2330
pages as much,| you may,
|你可能就不会跳到前面去，

1378
00:35:50,850 --> 00:35:51,605
0,275 275,395 395,485 485,590 590,755
may not be to jump

1379
00:35:51,605 --> 00:35:52,520
0,210 210,390 390,525 525,660 660,915
ahead,| so I think in
|我认为在索引扫描中，预取稍微保守一些，

1380
00:35:52,520 --> 00:35:54,110
0,270 270,590 850,1155 1155,1530 1530,1590
index scans, the prefetching is

1381
00:35:54,110 --> 00:35:55,145
0,45 45,120 120,300 300,600 600,1035
a bit more conservative,| sequential
|顺序扫描，你可以跳得更远。

1382
00:35:55,145 --> 00:35:56,675
0,275 565,855 855,1020 1020,1290 1290,1530
scan, you could just, you

1383
00:35:56,675 --> 00:35:57,665
0,135 135,285 285,405 405,665 745,990
know, you can jump a

1384
00:35:57,665 --> 00:35:58,880
0,120 120,545
lot farther.|
|

1385
00:36:00,080 --> 00:36:00,910
0,245 245,395 395,470 470,605 605,830
We haven't been talking about,|
我们还没有讨论，|

1386
00:36:00,910 --> 00:36:02,560
0,350 820,1170 1170,1365 1365,1545 1545,1650
like there's all a bunch
还有一大堆其他因素，

1387
00:36:02,560 --> 00:36:03,660
0,90 90,210 210,480 480,780 780,1100
of other factors, too,| as
|总是在数据库中，

1388
00:36:04,340 --> 00:36:05,365
0,275 275,380 380,470 470,590 590,1025
always the case in databases,|
|

1389
00:36:05,365 --> 00:36:08,200
0,275 835,1505
like there's,
比如，有多版本控制，

1390
00:36:08,200 --> 00:36:09,610
0,270 270,360 360,585 585,1200 1200,1410
there's like multi versioning,| so
|所以谁知道是不是，

1391
00:36:09,610 --> 00:36:10,975
0,150 150,420 420,750 750,1100 1120,1365
who knows whether like,| you
|我要读的下一个页面有 10 个 tuple ，

1392
00:36:10,975 --> 00:36:11,845
0,135 135,360 360,540 540,690 690,870
know, yes, the next page

1393
00:36:11,845 --> 00:36:12,745
0,180 180,255 255,435 435,675 675,900
I'm gonna read has 10

1394
00:36:12,745 --> 00:36:14,130
0,165 165,330 330,600 600,965 985,1385
{tuples -},| but like only
|但可能只有三个是可见的，

1395
00:36:14,150 --> 00:36:15,595
0,290 290,440 440,560 560,820 1140,1445
three may be visible,| it's
|这很复杂。

1396
00:36:15,595 --> 00:36:16,660
0,245
complicated.|
|

1397
00:36:18,380 --> 00:36:19,920
0,290 290,485 485,790
All right, so,
好的，回到这里，

1398
00:36:19,930 --> 00:36:21,020
0,260 260,380 380,545 545,770 770,1090
going back here,| sequential scans,
|顺序扫描，操作系统可以在某种程度上做到这个，

1399
00:36:21,070 --> 00:36:22,005
0,335 335,545 545,695 695,830 830,935
the OS can kind of

1400
00:36:22,005 --> 00:36:23,655
0,105 105,365 1075,1350 1350,1485 1485,1650
do this,| assuming your pages
|假设你的页面是连续的，

1401
00:36:23,655 --> 00:36:25,710
0,150 150,695 865,1200 1200,1535 1765,2055
are contiguous,| the OS read
|操作系统预读可以在某种程度上解决这一问题，

1402
00:36:25,710 --> 00:36:26,745
0,195 195,450 450,720 720,915 915,1035
ahead can can kind of

1403
00:36:26,745 --> 00:36:28,035
0,135 135,285 285,545 895,1140 1140,1290
figure this out,| what it
|它不能做的是，

1404
00:36:28,035 --> 00:36:30,170
0,375 375,665 865,1265 1285,1685 1735,2135
can't do is| infer the
|推断页面物理表示的逻辑数据结构，

1405
00:36:30,400 --> 00:36:32,805
0,400 570,1190 1190,1430 1430,1780 2130,2405
the logical data structure that

1406
00:36:32,805 --> 00:36:34,280
0,150 150,375 375,720 720,1095 1095,1475
the pages represent physically represent|
|

1407
00:36:35,050 --> 00:36:36,470
0,305 305,725 725,980 980,1160 1160,1420
and prefetch according to that,|
并根据它进行预取，|

1408
00:36:37,240 --> 00:36:38,510
0,290 290,485 485,650 650,965 965,1270
because again, it doesn't know
因为它不知道 B+ 树是什么，

1409
00:36:38,680 --> 00:36:39,465
0,260 260,365 365,485 485,650 650,785
what {} {B+ -} tree

1410
00:36:39,465 --> 00:36:40,005
0,150 150,360 360,405 405,465 465,540
is,| doesn't know what a
|不知道哈希表是什么，

1411
00:36:40,005 --> 00:36:40,995
0,255 255,435 435,705 705,885 885,990
hash table is,| at least
|至少在页面级别，

1412
00:36:40,995 --> 00:36:41,700
0,120 120,270 270,420 420,525 525,705
in the at the page

1413
00:36:41,700 --> 00:36:42,500
0,320
level,|
|

1414
00:36:42,510 --> 00:36:43,640
0,275 275,470 470,695 695,905 905,1130
but we do, because we're
但我们能，因为我们是数据库系统，

1415
00:36:43,640 --> 00:36:45,890
0,75 75,195 195,470 730,1050 1050,2250
the database system,| we, we're
|我们真正运行它。

1416
00:36:45,890 --> 00:36:46,840
0,60 60,255 255,495 495,660 660,950
the ones actually running it.|
|

1417
00:36:48,080 --> 00:36:48,655
0,320 320,380 380,440 440,500 500,575
Let's say, I have a
假设我有一个查询，

1418
00:36:48,655 --> 00:36:49,480
0,180 180,330 330,480 480,675 675,825
query,| like the SELECT *
|比如 SELECT * FORM A WHERE val BETWEEN 100 AND 250 ，

1419
00:36:49,480 --> 00:36:50,320
0,120 120,375 375,630 630,765 765,840
FROM A WHERE { -}

1420
00:36:50,320 --> 00:36:51,865
0,260 280,680 880,1170 1170,1380 1380,1545
val BETWEEN {100,AND -} {250

1421
00:36:51,865 --> 00:36:53,500
0,90 90,195 195,455 925,1325 1345,1635
- - -},| and I
|我可以通过做索引扫描来实现这个，

1422
00:36:53,500 --> 00:36:54,750
0,180 180,360 360,555 555,855 855,1250
can do this, by reading,

1423
00:36:55,520 --> 00:36:58,570
0,400 570,970 1320,1960 2640,2885 2885,3050
{by,doing} an {index,scan},| we haven't
|我们还没有讨论过 B+ 树，

1424
00:36:58,570 --> 00:36:59,185
0,60 60,150 150,285 285,450 450,615
talked about {B+ -} trees

1425
00:36:59,185 --> 00:37:00,250
0,225 225,435 435,600 600,975 975,1065
yet,| but again it's a
|但是，它是一种树数据结构，

1426
00:37:00,250 --> 00:37:01,210
0,120 120,300 300,570 570,795 795,960
tree data structure,| that shouldn't
|对于这门课上的任何人来说都不应该是陌生的，

1427
00:37:01,210 --> 00:37:01,915
0,120 120,315 315,510 510,630 630,705
be foreign to anyone in

1428
00:37:01,915 --> 00:37:03,415
0,135 135,425 805,1065 1065,1245 1245,1500
this class,| and then assume
|然后假设沿着叶节点，

1429
00:37:03,415 --> 00:37:04,830
0,300 300,555 555,690 690,855 855,1415
that along the leaf nodes,|
|

1430
00:37:05,120 --> 00:37:07,150
0,380 380,620 620,880 1080,1480 1590,2030
the the values are sorted
基于键对值进行排序。

1431
00:37:07,150 --> 00:37:08,040
0,180 180,360 360,510 510,630 630,890
based on on the key,

1432
00:37:08,620 --> 00:37:11,685
0,400 1200,1600 1650,1955 1955,2260 2760,3065
right.| So, to to do
|所以，为了运行这个特定的查询，

1433
00:37:11,685 --> 00:37:13,010
0,305 385,645 645,780 780,975 975,1325
this run this particular query,|
|

1434
00:37:13,240 --> 00:37:13,905
0,260 260,380 380,485 485,575 575,665
I had to sort of
我必须对根节点进行排序，

1435
00:37:13,905 --> 00:37:15,210
0,105 105,255 255,725 745,1125 1125,1305
the root node,| that's {page0
|这是 page0 ，我去拿它，

1436
00:37:15,210 --> 00:37:16,290
0,320 340,600 600,735 735,885 885,1080
-}, I go get that,|
|

1437
00:37:16,290 --> 00:37:17,210
0,270 270,465 465,540 540,645 645,920
put that in my database,
把它放到我的数据库里，放到我的缓冲池里，

1438
00:37:17,290 --> 00:37:18,120
0,260 260,365 365,425 425,530 530,830
put that in my buffer

1439
00:37:18,120 --> 00:37:20,055
0,260 760,1140 1140,1425 1425,1725 1725,1935
pool,| then I traverse down
|然后我向下走到树的这一边，

1440
00:37:20,055 --> 00:37:20,700
0,135 135,270 270,435 435,525 525,645
to this side of the

1441
00:37:20,700 --> 00:37:22,610
0,290 400,675 675,950 1270,1590 1590,1910
tree,| I get {page1 -},
|我得到 page1 ，把它放到我的缓冲池里，

1442
00:37:23,050 --> 00:37:23,865
0,245 245,365 365,455 455,545 545,815
put that in my buffer

1443
00:37:23,865 --> 00:37:25,410
0,275 715,960 960,1110 1110,1320 1320,1545
pool,| but then now I'm
|但现在我要跳到这里的这个叶节点，

1444
00:37:25,410 --> 00:37:26,220
0,135 135,330 330,525 525,675 675,810
gonna jump down to this

1445
00:37:26,220 --> 00:37:28,005
0,210 210,510 510,800 1150,1485 1485,1785
leaf node here| and {}
|因为我有这个 WHERE 子句，

1446
00:37:28,005 --> 00:37:29,190
0,330 330,555 555,690 690,930 930,1185
because I have this this

1447
00:37:29,190 --> 00:37:30,465
0,225 225,525 525,825 825,1080 1080,1275
WHERE clause,| that is gonna
|要读取这么多记录，

1448
00:37:30,465 --> 00:37:32,415
0,305 745,1145 1375,1605 1605,1725 1725,1950
be reading, you know, so

1449
00:37:32,415 --> 00:37:33,590
0,180 180,375 375,585 585,810 810,1175
so many, so many records,|
|

1450
00:37:34,210 --> 00:37:35,055
0,305 305,485 485,635 635,770 770,845
I know I need to
我知道我至少要到 page5 ，

1451
00:37:35,055 --> 00:37:35,835
0,60 60,210 210,420 420,600 600,780
at least go to over

1452
00:37:35,835 --> 00:37:37,540
0,240 240,465 465,720 720,1085
to to {page5 -},

1453
00:37:38,020 --> 00:37:40,605
0,400 930,1330 1710,2105 2105,2315 2315,2585
right,| so I'll go get
|所以，我得到，抱歉，我得到 page3 ，

1454
00:37:40,605 --> 00:37:41,925
0,305 445,810 810,1035 1035,1170 1170,1320
page, sorry, I will get

1455
00:37:41,925 --> 00:37:43,520
0,210 210,545 625,1025 1045,1320 1320,1595
{page3 -},| but also can
|但也可以潜在地预取 page5 ，

1456
00:37:43,630 --> 00:37:46,840
0,400 1230,1745 1745,2030 2030,2380
potentially prefetch {page5 -},|
|

1457
00:37:46,840 --> 00:37:48,310
0,195 195,470 550,930 930,1215 1215,1470
but again, the operating system
但是同样，操作系统不能做到这个，不能知道这个，

1458
00:37:48,520 --> 00:37:49,435
0,120 120,270 270,480 660,765 765,915
can't do this, can't know

1459
00:37:49,435 --> 00:37:50,820
0,240 240,575
this,| because,
|因为， page3 和 page5 不是连续的，

1460
00:37:50,820 --> 00:37:51,750
0,240 240,420 420,540 540,720 720,930
{page3 -} and {page5 -}

1461
00:37:51,750 --> 00:37:53,460
0,135 135,270 270,920
are not contiguous,|
|

1462
00:37:53,760 --> 00:37:55,145
0,260 260,470 470,740 740,1060 1080,1385
the database system knows,| because
数据库系统知道，|因为它知道如果我至少获得了 index-page3 ，

1463
00:37:55,145 --> 00:37:56,990
0,195 195,480 480,875 1495,1740 1740,1845
it knows that if I

1464
00:37:56,990 --> 00:37:57,815
0,135 135,270 270,420 420,600 600,825
least get the {index-page3 -

1465
00:37:57,815 --> 00:37:59,410
0,335 505,780 780,915 915,1095 1095,1595
-},| I have a sibling
|我就有一个兄弟指针，一个页面 ID ，

1466
00:37:59,760 --> 00:38:02,060
0,580 1170,1475 1475,1655 1655,1930 2070,2300
pointer, a page ID,| so
|所以我知道我要读取的下一个页面，

1467
00:38:02,060 --> 00:38:03,155
0,135 135,360 360,645 645,870 870,1095
I know what the next

1468
00:38:03,155 --> 00:38:03,875
0,270 270,450 450,615 615,660 660,720
next page I'm going to

1469
00:38:03,875 --> 00:38:04,955
0,120 120,395 415,735 735,915 915,1080
read| over along the leaf
|在我扫描时，沿着叶节点，

1470
00:38:04,955 --> 00:38:06,430
0,300 300,545 595,915 915,1155 1155,1475
nodes as I scan across,|
|

1471
00:38:06,720 --> 00:38:07,430
0,305 305,440 440,515 515,605 605,710
so therefore I can go
所以我可以继续，并进行预取，

1472
00:38:07,430 --> 00:38:09,000
0,105 105,225 225,555 555,890
ahead and prefetch that,|
|

1473
00:38:09,380 --> 00:38:10,675
0,335 335,560 680,785 785,1040 1040,1295
even though it's not in
即使它不是按其他页面的顺序排列的，

1474
00:38:10,675 --> 00:38:12,100
0,375 375,635 895,1170 1170,1275 1275,1425
sequential order of the other

1475
00:38:12,100 --> 00:38:13,360
0,320
pages,|
|

1476
00:38:15,720 --> 00:38:16,790
0,275 275,470 470,590 590,800 800,1070
and there's just another example,|
这又是另一个例子，|

1477
00:38:16,790 --> 00:38:17,420
0,270 270,420 420,495 495,555 555,630
why we want to do
为什么我们要在数据库系统而不是操作系统端做这个。

1478
00:38:17,420 --> 00:38:18,050
0,105 105,195 195,375 375,555 555,630
this on the side of

1479
00:38:18,050 --> 00:38:18,680
0,60 60,180 180,375 375,525 525,630
the database system and not

1480
00:38:18,680 --> 00:38:19,860
0,150 150,440
the OS.|
|

1481
00:38:24,050 --> 00:38:24,985
0,230 230,395 395,740 740,875 875,935
The next optimization we can
我们可以做的下一个优化是扫描共享，

1482
00:38:24,985 --> 00:38:26,010
0,90 90,195 195,405 405,690 690,1025
do is called scan sharing,|
|

1483
00:38:26,880 --> 00:38:28,700
0,285 285,585 585,1035 1035,1370 1420,1820
sometimes called synchronized scans in
在一些较旧的系统中，有时称为同步扫描。

1484
00:38:28,960 --> 00:38:29,810
0,230 230,290 290,365 365,530 530,850
some of the older systems.|
|

1485
00:38:30,280 --> 00:38:31,760
0,260 260,515 515,815 815,1100 1100,1480
The basic idea here is
这里的基本思想是显示一系列查询，

1486
00:38:31,960 --> 00:38:32,880
0,260 260,395 395,515 515,755 755,920
a bunch of queries show

1487
00:38:32,880 --> 00:38:33,840
0,290
up,|
|

1488
00:38:33,840 --> 00:38:34,545
0,165 165,285 285,435 435,600 600,705
they want to access to
他们想要访问同一张表，

1489
00:38:34,545 --> 00:38:36,555
0,105 105,285 285,605 1645,1905 1905,2010
the same table,| one of
|其中一个开始扫描页面，

1490
00:38:36,555 --> 00:38:38,130
0,105 105,285 285,605 1105,1365 1365,1575
them gets started and start

1491
00:38:38,130 --> 00:38:40,155
0,360 360,465 465,570 570,830 1750,2025
scanning through the pages,| and
|我们可以认识到，他们需要相同的数据，

1492
00:38:40,155 --> 00:38:43,440
0,135 135,255 255,515 625,1025 3025,3285
we can recognize that they

1493
00:38:43,440 --> 00:38:44,985
0,120 120,240 240,390 390,680 1060,1545
need the same data,| so
|所以，我们返回给它们，

1494
00:38:44,985 --> 00:38:45,950
0,240 240,390 390,585 585,720 720,965
[piggy] back off of them|
|

1495
00:38:46,180 --> 00:38:47,430
0,245 245,395 395,740 740,1055 1055,1250
and our cursor attaches their
我们的游标连接到他们的游标上，

1496
00:38:47,430 --> 00:38:48,660
0,500 580,855 855,975 975,1095 1095,1230
cursor| and we read the
|我们同时读取相同的页面，

1497
00:38:48,660 --> 00:38:50,160
0,165 165,470 970,1230 1230,1350 1350,1500
same pages at the same

1498
00:38:50,160 --> 00:38:51,160
0,290
time,|
|

1499
00:38:51,570 --> 00:38:54,035
0,245 245,490 840,1240 1890,2135 2135,2465
so we remove the redundant
所以我们去掉了多余的 I/O 。

1500
00:38:54,035 --> 00:38:55,280
0,395
I/O.|
|

1501
00:38:55,410 --> 00:38:56,300
0,260 260,380 380,515 515,680 680,890
So this is different than
所以这和结果缓存是不同的，

1502
00:38:56,300 --> 00:38:58,505
0,240 240,770 1120,1520 1840,2100 2100,2205
result caching,| {} which we
|我们不想在这个学期谈论，

1503
00:38:58,505 --> 00:38:58,955
0,120 120,165 165,240 240,345 345,450
won't want to talk about

1504
00:38:58,955 --> 00:38:59,945
0,105 105,345 345,555 555,720 720,990
the semester,| {} result caching,
|结果缓存，是查询出现，我计算出了一些答案，

1505
00:38:59,945 --> 00:39:02,290
0,245 775,1140 1140,1380 1380,1685 1945,2345
basically query shows up, {}

1506
00:39:02,640 --> 00:39:04,565
0,275 275,560 560,710 710,970 1560,1925
I compute some answer,| I
|我将结果保存在缓存中，

1507
00:39:04,565 --> 00:39:05,855
0,345 345,675 675,975 975,1170 1170,1290
save that result in a

1508
00:39:05,855 --> 00:39:07,790
0,305 865,1245 1245,1500 1500,1755 1755,1935
cache,| query, same query shows
|同样的查询再次出现，

1509
00:39:07,790 --> 00:39:09,800
0,195 195,530 1090,1470 1470,1785 1785,2010
up again,| potentially slightly different,
|可能略有不同，这很难做到，

1510
00:39:09,800 --> 00:39:10,490
0,150 150,270 270,420 420,555 555,690
which is harder to do,|
|

1511
00:39:10,490 --> 00:39:11,195
0,150 150,270 270,375 375,495 495,705
but say the same query
但假设相同的查询再次出现，

1512
00:39:11,195 --> 00:39:12,545
0,165 165,315 315,605 835,1260 1260,1350
shows up again,| I have
|我必须重新运行查询，

1513
00:39:12,545 --> 00:39:13,265
0,90 90,315 315,405 405,585 585,720
to rerun the query,| I
|我只是把结果发回去，

1514
00:39:13,265 --> 00:39:14,060
0,120 120,255 255,375 375,570 570,795
just, I just send, send

1515
00:39:14,060 --> 00:39:15,220
0,195 195,375 375,650
the result back.|
|

1516
00:39:15,440 --> 00:39:16,885
0,335 335,620 620,970 990,1280 1280,1445
The scan sharing is really
扫描共享实际上是在访问方法的低物理级别，

1517
00:39:16,885 --> 00:39:18,010
0,135 135,255 255,495 495,840 840,1125
at the low physical levels

1518
00:39:18,010 --> 00:39:18,955
0,180 180,360 360,540 540,735 735,945
of the access method,| how
|我们扫描页面的方式，

1519
00:39:18,955 --> 00:39:19,920
0,210 210,360 360,600 600,705 705,965
we're actually scanning the pages,|
|

1520
00:39:20,240 --> 00:39:21,750
0,245 245,350 350,590 590,970 1110,1510
we can recognize that,| the
我们可以认识到，|两个查询需要读取相同的内容，

1521
00:39:21,830 --> 00:39:22,675
0,260 260,500 500,605 605,710 710,845
two queries need to read

1522
00:39:22,675 --> 00:39:24,330
0,135 135,330 330,665 925,1290 1290,1655
the same thing| and therefore,
|所以，我们可以在执行过程中重用任何页面并获取它们，

1523
00:39:25,520 --> 00:39:26,650
0,305 305,455 455,590 590,935 935,1130
we, we can reuse any

1524
00:39:26,650 --> 00:39:29,350
0,320 2020,2295 2295,2430 2430,2565 2565,2700
pages as we go along

1525
00:39:29,350 --> 00:39:30,625
0,105 105,270 270,560 970,1200 1200,1275
and fetch them,| so we
|这样就不会有试图同时读取相同页面的冲突游标。

1526
00:39:30,625 --> 00:39:32,125
0,180 180,390 390,990 990,1365 1365,1500
don't have conflicting cursors trying

1527
00:39:32,125 --> 00:39:32,740
0,90 90,180 180,285 285,420 420,615
to read the same pages

1528
00:39:32,740 --> 00:39:33,960
0,180 180,315 315,495 495,800
at the same time.|
|

1529
00:39:36,510 --> 00:39:37,565
0,305 305,455 455,545 545,695 695,1055
{All,right}, so this is repeating
好的，这是重复我刚才所说的，

1530
00:39:37,565 --> 00:39:38,890
0,225 225,330 330,465 465,755 925,1325
what I just said, {}|
|

1531
00:39:39,150 --> 00:39:41,915
0,400 840,1240 1770,2210 2210,2435 2435,2765
for the {DB2 -}, SQL
对于 DB2, SQL Server, Teradata 和 Postgres ，

1532
00:39:41,915 --> 00:39:43,910
0,225 225,720 720,855 855,1415 1615,1995
Server, Teradata and Postgres,| they
|他们支持完全扫描共享，

1533
00:39:43,910 --> 00:39:47,600
0,360 360,740 970,1370 2890,3290 3340,3690
actually support the full scan

1534
00:39:47,600 --> 00:39:49,625
0,350 850,1155 1155,1500 1500,1650 1650,2025
sharing,| for queries that aren't
|对于不完全相同的查询，

1535
00:39:49,625 --> 00:39:51,185
0,255 255,510 510,815 1255,1485 1485,1560
exactly the same,| but at
|但至少它们正在读取相同的表。

1536
00:39:51,185 --> 00:39:52,505
0,135 135,485 565,900 900,1095 1095,1320
least they're, they're reading the

1537
00:39:52,505 --> 00:39:53,920
0,210 210,545
same tables.|
|

1538
00:39:54,370 --> 00:39:56,160
0,305 305,940 1080,1340 1340,1550 1550,1790
In Oracle, they only support
在 Oracle 中，它们只支持看起来完全相同的查询的游标共享，

1539
00:39:56,160 --> 00:39:58,275
0,315 315,570 570,950 1600,1995 1995,2115
cursor sharing for queries that

1540
00:39:58,275 --> 00:39:59,330
0,105 105,225 225,420 420,690 690,1055
show up that look exactly

1541
00:39:59,380 --> 00:40:00,920
0,275 275,550 690,950 950,1175 1175,1540
the same,| I mean literally
|我的意思是字面上完全相同，

1542
00:40:01,030 --> 00:40:02,085
0,320 320,500 500,665 665,830 830,1055
exactly the same,| because they're
|因为他们是对字符串做哈希，看看是否有匹配，

1543
00:40:02,085 --> 00:40:04,590
0,305 325,995 1225,1545 1545,1865 2185,2505
basically hashing the string, seeing

1544
00:40:04,590 --> 00:40:06,510
0,285 285,555 555,630 630,890 1660,1920
whether there's a match,| like
|如果你查看文档，

1545
00:40:06,510 --> 00:40:07,020
0,90 90,180 180,315 315,435 435,510
if you go look at

1546
00:40:07,020 --> 00:40:08,565
0,135 135,650 1090,1350 1350,1455 1455,1545
the documentation,| like, if you
|例如，如果你有 SELECT * FROM employees 这样的查询，

1547
00:40:08,565 --> 00:40:09,795
0,135 135,495 495,765 765,1050 1050,1230
have queries like SELECT *

1548
00:40:09,795 --> 00:40:11,670
0,180 180,485 1105,1425 1425,1650 1650,1875
FROM employees,| SELECT * FROM
|SELECT * FROM Employees ，大写字母 E ，

1549
00:40:11,670 --> 00:40:12,650
0,225 225,345 345,420 420,630 630,980
Employees of the capital E|
|

1550
00:40:12,910 --> 00:40:14,010
0,245 245,320 320,530 530,845 845,1100
or an extra space before
或者有额外的空格在 FROM 子句前，

1551
00:40:14,010 --> 00:40:15,870
0,165 165,330 330,650 1210,1545 1545,1860
the FROM clause,| these won't
|它们不会匹配，

1552
00:40:15,870 --> 00:40:17,160
0,260 310,660 660,855 855,975 975,1290
match,| because when you hash
|因为当你对字符串进行哈希时，它们并不相同，

1553
00:40:17,160 --> 00:40:18,435
0,180 180,500 700,1020 1020,1125 1125,1275
the strings they're not the

1554
00:40:18,435 --> 00:40:19,350
0,275 385,615 615,675 675,780 780,915
same,| so it has to
|所以，它必须是完全相同的查询，在完全相同的时间运行，

1555
00:40:19,350 --> 00:40:20,310
0,165 165,315 315,480 480,735 735,960
literally be the exact same

1556
00:40:20,310 --> 00:40:21,045
0,225 225,375 375,435 435,540 540,735
query, run at the exact

1557
00:40:21,045 --> 00:40:22,635
0,195 195,485 805,1095 1095,1350 1350,1590
same time| and and then
|然后它们可以共享它。

1558
00:40:22,635 --> 00:40:23,600
0,135 135,270 270,420 420,695
they can share it.|
|

1559
00:40:25,360 --> 00:40:26,595
0,290 290,725 725,830 830,965 965,1235
So conception looks like this,|
所以构思看起来是这样的，|

1560
00:40:26,595 --> 00:40:28,320
0,315 315,540 540,720 720,995 1405,1725
so say I have query
假设我有查询一，

1561
00:40:28,320 --> 00:40:30,465
0,225 225,620 790,1035 1035,1280 1600,2145
1,| let's do a summation
|让我们对表 A 中的 val 列进行求和，

1562
00:40:30,465 --> 00:40:32,240
0,395 535,795 795,1005 1005,1355 1375,1775
on the val column from

1563
00:40:32,890 --> 00:40:36,015
0,305 305,610 1230,1630 2580,3005 3005,3125
table A,| so attaches a
|所以将游标附加到页面上，

1564
00:40:36,015 --> 00:40:37,065
0,300 300,405 405,495 495,750 750,1050
cursor to the pages,| starts
|开始读取它们，并将它们提取到缓冲池中，

1565
00:40:37,065 --> 00:40:38,055
0,195 195,405 405,750 750,840 840,990
reading them, fetching them into

1566
00:40:38,055 --> 00:40:40,275
0,150 150,360 360,605 1795,2085 2085,2220
the buffer pool,| first thing
|它首先获取 page0 ，它不在那里，

1567
00:40:40,275 --> 00:40:41,250
0,90 90,255 255,465 465,705 705,975
it gets {page0 -}, that's

1568
00:40:41,250 --> 00:40:42,915
0,120 120,410 1120,1395 1395,1530 1530,1665
not there,| so puts that
|所以把它放在内存中，转到 page2 ，等等，

1569
00:40:42,915 --> 00:40:44,115
0,120 120,365 625,915 915,1080 1080,1200
in memory, goes down to

1570
00:40:44,115 --> 00:40:45,170
0,150 150,405 405,615 615,765 765,1055
{page2 -}, and so forth,

1571
00:40:45,970 --> 00:40:46,845
0,380 380,605 605,695 695,785 785,875
right,| so now we get
|现在我们获取 page3 ，

1572
00:40:46,845 --> 00:40:49,230
0,90 90,270 270,605 925,1325 2155,2385
to {page3 -},| and we
|我们还没有讨论驱逐策略，

1573
00:40:49,230 --> 00:40:49,920
0,165 165,270 270,390 390,465 465,690
haven't talked about the eviction

1574
00:40:49,920 --> 00:40:51,045
0,300 300,585 585,795 795,990 990,1125
policy,| but {page0 -} is
|但 page0 是最后一个用过的，

1575
00:40:51,045 --> 00:40:51,950
0,105 105,285 285,480 480,630 630,905
the last one was used,|
|

1576
00:40:52,330 --> 00:40:53,370
0,245 245,335 335,470 470,725 725,1040
so we go ahead and
所以我们继续，把 page0 逐出，然后放入 page3 ，

1577
00:40:53,370 --> 00:40:54,675
0,500 520,825 825,1035 1035,1200 1200,1305
evict {page0 -} and put

1578
00:40:54,675 --> 00:40:56,020
0,105 105,285 285,605
in {page3 -},|
|

1579
00:40:56,370 --> 00:40:57,760
0,245 245,440 440,875 875,1085 1085,1390
but, now Q2 shows up,|
但是现在， Q2 出现了，|

1580
00:40:58,480 --> 00:40:59,340
0,225 225,375 375,510 510,615 615,860
wants to compute an average
希望在同一张表上计算平均值而不是求和，

1581
00:40:59,360 --> 00:41:01,300
0,380 380,760 810,1330 1530,1805 1805,1940
instead of summation on the

1582
00:41:01,300 --> 00:41:03,685
0,180 180,450 450,800 1480,1880 2110,2385
same table, though,| so the
|所以简单的做法是，

1583
00:41:03,685 --> 00:41:04,660
0,390 390,555 555,675 675,795 795,975
naive thing to do is,|
|

1584
00:41:04,660 --> 00:41:05,665
0,195 195,360 360,615 615,840 840,1005
have it start at the
让它从开头开始，

1585
00:41:05,665 --> 00:41:06,790
0,240 240,435 435,660 660,915 915,1125
beginning,| just like the first
|就像第一个光标一样，

1586
00:41:06,790 --> 00:41:08,380
0,500 640,900 900,1095 1095,1350 1350,1590
cursor,| and just scan down
|只需同时向下扫描，并读取页面，

1587
00:41:08,380 --> 00:41:09,190
0,180 180,285 285,390 390,600 600,810
and read the pages at

1588
00:41:09,190 --> 00:41:11,320
0,105 105,255 255,560
the same time,|
|

1589
00:41:11,510 --> 00:41:12,580
0,305 305,500 500,665 665,815 815,1070
but obviously this is stupid,|
但这显然是愚蠢的，|

1590
00:41:12,580 --> 00:41:14,760
0,380 1180,1440 1440,1575 1575,1815 1815,2180
because in this scenario here,|
因为在这种情况下，|

1591
00:41:15,350 --> 00:41:16,945
0,290 290,560 560,940 1080,1370 1370,1595
we just, the {Q2 -}
我们只需要， Q2 需要读取 page0 ，

1592
00:41:16,945 --> 00:41:17,970
0,225 225,360 360,510 510,720 720,1025
needs to read {page0 -},|
|

1593
00:41:18,140 --> 00:41:19,270
0,305 305,500 500,710 710,935 935,1130
but {Q1 -} just got
但 Q1 刚刚将其从缓冲池中逐出，

1594
00:41:19,270 --> 00:41:20,305
0,165 165,465 465,660 660,765 765,1035
that evicted from the buffer

1595
00:41:20,305 --> 00:41:21,200
0,275
pool,

1596
00:41:21,390 --> 00:41:23,180
0,320 320,640 690,1090 1350,1640 1640,1790
right,| so the first thing
|所以我们在这里要做的第一件事是，

1597
00:41:23,180 --> 00:41:24,010
0,105 105,195 195,330 330,525 525,830
we would do here is,|
|

1598
00:41:24,930 --> 00:41:25,655
0,260 260,365 365,455 455,560 560,725
if you want to {Q2
如果你想要 Q2 ，

1599
00:41:25,655 --> 00:41:27,095
0,305 355,585 585,815 865,1215 1215,1440
-},| we {had,to,evict} {page2 -},
|我们必须逐出 page2 ，放入 page0 ，

1600
00:41:27,095 --> 00:41:28,510
0,135 135,395 565,870 870,1095 1095,1415
to put {page0 -} in,|
|

1601
00:41:28,710 --> 00:41:30,110
0,275 275,550 720,1025 1025,1235 1235,1400
but again, we just got
但是，我们刚刚逐出了 page0 ，

1602
00:41:30,110 --> 00:41:31,540
0,105 105,195 195,360 360,680
rid of {page0 -},|
|

1603
00:41:31,580 --> 00:41:32,425
0,260 260,380 380,560 560,740 740,845
so the better thing to
所以，更好的做法是，

1604
00:41:32,425 --> 00:41:33,670
0,180 180,390 390,570 570,875 925,1245
do is,| you attach {Q2
|你将 Q2 附加到 Q1 上，

1605
00:41:33,670 --> 00:41:35,485
0,225 225,390 390,540 540,830 1570,1815
-} to {Q1 -},| again
|在扫描表格时的最低级别，

1606
00:41:35,485 --> 00:41:36,370
0,105 105,225 225,420 420,675 675,885
at the lowest level as

1607
00:41:36,370 --> 00:41:39,060
0,195 195,435 435,770 1480,1880
you scan the table,|
|

1608
00:41:39,060 --> 00:41:40,590
0,150 150,440 850,1125 1125,1305 1305,1530
and let {Q2 -} ride
让 Q2 随着 Q1 ，

1609
00:41:40,590 --> 00:41:42,285
0,285 285,525 525,800 1240,1530 1530,1695
along {Q1 -},| see all
|看到它看到的所有页面，并相应地处理它们，

1610
00:41:42,285 --> 00:41:43,170
0,135 135,330 330,525 525,675 675,885
the pages that it sees

1611
00:41:43,170 --> 00:41:45,255
0,195 195,450 450,810 810,1430 1810,2085
and processes them accordingly,| and
|然后 Q1 消失了，

1612
00:41:45,255 --> 00:41:46,515
0,270 270,540 540,705 705,930 930,1260
then {Q1 -} goes away,|
|

1613
00:41:46,515 --> 00:41:48,030
0,240 240,375 375,570 570,875 955,1515
but then {Q2 -} recognizes,|
但是 Q2 意识到，|

1614
00:41:48,030 --> 00:41:48,960
0,350 370,675 675,720 720,810 810,930
oh, there's a bunch of
哦，在表的顶部有一堆我遗漏的页面，

1615
00:41:48,960 --> 00:41:49,890
0,180 180,345 345,585 585,840 840,930
pages at the top of

1616
00:41:49,890 --> 00:41:50,630
0,90 90,255 255,390 390,480 480,740
the table that I missed,|
|

1617
00:41:51,280 --> 00:41:52,305
0,245 245,335 335,440 440,680 680,1025
let me go back and
让我返回并获取所有这些，

1618
00:41:52,305 --> 00:41:53,300
0,255 255,435 435,570 570,705 705,995
and get get all those|
|

1619
00:41:54,610 --> 00:41:55,670
0,260 260,380 380,620 620,755 755,1060
and then compute my query.|
然后计算我的查询。|

1620
00:41:57,640 --> 00:41:58,940
0,400
{All,right},|
好的，|

1621
00:42:01,050 --> 00:42:01,800
0,60 60,180 180,390 390,600 600,750
what's the potential problem with
这有什么潜在的问题？

1622
00:42:01,800 --> 00:42:02,960
0,260
this?|
|

1623
00:42:05,480 --> 00:42:07,020
0,400
Yes.|
是的。|

1624
00:42:07,245 --> 00:42:07,850
0,45 45,105 105,195 195,330 330,605
So it's hard to implement,
所以，它很难实现，没那么难。

1625
00:42:09,780 --> 00:42:11,220
0,275 275,410 410,670
not that hard.|
|

1626
00:42:12,900 --> 00:42:15,360
0,320 320,575 575,1100 1100,1390

1627
00:42:15,400 --> 00:42:16,500
0,335 335,545 545,665 665,995 995,1100

1628
00:42:16,500 --> 00:42:17,260
0,105 105,350

1629
00:42:17,870 --> 00:42:18,880
0,290 290,425 425,515 515,815 815,1010
Says if the aggregate function
说明如果聚合函数依赖于数据的顺序，同样，关系模型不依赖于数据顺序，如果没有函数，则是。

1630
00:42:18,880 --> 00:42:19,600
0,225 225,345 345,435 435,645 645,720
depends on the ordering of

1631
00:42:19,600 --> 00:42:21,310
0,120 120,410 1000,1305 1305,1470 1470,1710
the data, which again, relational

1632
00:42:21,310 --> 00:42:23,770
0,225 225,435 435,950 2080,2340 2340,2460
model, it doesn't, with no

1633
00:42:23,770 --> 00:42:26,080
0,240 240,620
functions, yes.|
|

1634
00:42:26,305 --> 00:42:26,875
0,75 75,240 240,360 360,420 420,570
You're close to it, but
你接近了，但基本上是说你有一个限制条款。

1635
00:42:26,875 --> 00:42:27,955
0,305 475,735 735,840 840,930 930,1080
basically say you had a

1636
00:42:27,955 --> 00:42:29,560
0,240 240,605
limit clause.|
|

1637
00:42:29,670 --> 00:42:31,070
0,400 660,1010 1010,1235 1235,1340 1340,1400
Right, right. I want to
对，对。我想要得到前100个Tour，然后计算它的平均值。同样，关系模型也是无序的。因此，从技术上讲，这是正确的。如果Q2从第0页开始，而不是从第3页开始，它又得到了102个以上的部分，平均。这两个答案在技术上都是正确的。从应用程序的角度来看，这看起来很糟糕，因为现在您收到了查询。同一查询在两个不同的时间显示不同的结果。

1638
00:42:31,070 --> 00:42:32,170
0,60 60,150 150,300 300,660 660,1100
get the first 100 twoils

1639
00:42:32,700 --> 00:42:33,620
0,275 275,500 500,590 590,740 740,920
and compute the average on

1640
00:42:33,620 --> 00:42:36,880
0,260 1750,2025 2025,2280 2280,2565 2565,3260
that. Again, relational models unordered.

1641
00:42:37,110 --> 00:42:38,975
0,365 365,710 710,1070 1070,1390 1530,1865
So technically it's correct. If

1642
00:42:38,975 --> 00:42:40,220
0,255 255,570 570,855 855,1035 1035,1245
q two starts at page

1643
00:42:40,220 --> 00:42:42,370
0,320 520,885 885,1200 1200,1550 1750,2150
zero versus page three, and

1644
00:42:42,540 --> 00:42:43,730
0,305 305,470 470,590 590,1010 1010,1190
again it gets 102 plus

1645
00:42:43,730 --> 00:42:45,575
0,195 195,315 315,560 1180,1530 1530,1845
piece, the average. Both answers

1646
00:42:45,575 --> 00:42:47,480
0,240 240,515 595,995 1405,1665 1665,1905
are technically correct. From the

1647
00:42:47,480 --> 00:42:48,875
0,380 430,780 780,1020 1020,1200 1200,1395
application perspective, this looks fucked

1648
00:42:48,875 --> 00:42:49,625
0,180 180,390 390,525 525,630 630,750
up because now you got

1649
00:42:49,625 --> 00:42:51,350
0,405 405,675 675,870 870,1205 1435,1725
queries. The same query at

1650
00:42:51,350 --> 00:42:52,385
0,135 135,270 270,560 730,960 960,1035
two different times show up

1651
00:42:52,385 --> 00:42:53,680
0,90 90,285 285,635
with different results.|
|

1652
00:42:53,780 --> 00:42:54,865
0,350 350,545 545,665 665,875 875,1085
So I was being glib
所以我是油嘴滑舌的，我说，哦，是的，这并不是很难实现，因为你附加了光标。

1653
00:42:54,865 --> 00:42:55,495
0,90 90,195 195,315 315,480 480,630
and I said, oh yeah,

1654
00:42:55,495 --> 00:42:56,035
0,135 135,225 225,330 330,420 420,540
it's not that hard to

1655
00:42:56,035 --> 00:42:56,980
0,210 210,405 405,585 585,795 795,945
implement because you attach the

1656
00:42:56,980 --> 00:42:58,140
0,470
cursor.|
|

1657
00:42:58,330 --> 00:43:00,420
0,350 350,620 620,920 920,1210 1770,2090
Again, if there's no if
同样，如果没有如果没有排序约束，这很容易。但是，如果您需要确保您的查询一遍又一遍地产生相同的结果，那么这可能有点棘手。

1658
00:43:00,420 --> 00:43:02,190
0,270 270,465 465,885 885,1485 1485,1770
there's no ordering constraints, it's

1659
00:43:02,190 --> 00:43:03,345
0,230 520,780 780,915 915,1035 1035,1155
easy. But if you need

1660
00:43:03,345 --> 00:43:04,400
0,105 105,255 255,495 495,735 735,1055
to make sure that your

1661
00:43:04,780 --> 00:43:07,005
0,610 810,1210 1560,1820 1820,2000 2000,2225
queries produce the same results

1662
00:43:07,005 --> 00:43:08,180
0,165 165,255 255,375 375,665 775,1175
over and over again, then

1663
00:43:08,530 --> 00:43:09,420
0,275 275,395 395,575 575,755 755,890
this can be a bit

1664
00:43:09,420 --> 00:43:10,920
0,410
tricky.|
|

1665
00:43:11,650 --> 00:43:12,270
0,215 215,320 320,470 470,560 560,620
This is part of the
这也是我不想抨击甲骨文的部分原因。比如，最容易做的事情是，如果是完全相同的查询，我会进行游标共享。

1666
00:43:12,270 --> 00:43:13,155
0,225 225,465 465,585 585,720 720,885
reason, again, I'm not trying

1667
00:43:13,155 --> 00:43:14,295
0,75 75,225 225,725 745,1020 1020,1140
to bash Oracle. Like, the

1668
00:43:14,295 --> 00:43:15,090
0,330 330,465 465,570 570,675 675,795
easiest thing to do is

1669
00:43:15,090 --> 00:43:15,980
0,90 90,255 255,390 390,570 570,890
if it's exact same query,

1670
00:43:16,060 --> 00:43:17,680
0,320 320,410 410,680 680,940
I'll do cursor sharing.|
|

1671
00:43:17,950 --> 00:43:18,915
0,320 320,650 650,755 755,845 845,965
The tricky thing is to
棘手的事情是弄清楚，理解查询实际想要做的事情的语义，然后确定何时将一个游标连接到另一个游标是安全的，然后如何可能返回并根据需要获得更多结果。

1672
00:43:18,915 --> 00:43:20,295
0,150 150,425 625,990 990,1230 1230,1380
figure out, to understand the

1673
00:43:20,295 --> 00:43:21,495
0,585 585,675 675,765 765,885 885,1200
semantics of what the queries

1674
00:43:21,495 --> 00:43:22,920
0,225 225,420 420,600 600,875 1165,1425
actually wants to do, to

1675
00:43:22,920 --> 00:43:24,060
0,260 340,675 675,870 870,990 990,1140
then identify when is it

1676
00:43:24,060 --> 00:43:26,070
0,290 310,645 645,960 960,1340 1780,2010
safe to attach the, you

1677
00:43:26,070 --> 00:43:27,320
0,230 250,540 540,840 840,975 975,1250
know, one cursor to another

1678
00:43:28,060 --> 00:43:28,935
0,275 275,440 440,620 620,740 740,875
and then how to maybe

1679
00:43:28,935 --> 00:43:30,045
0,180 180,375 375,600 600,825 825,1110
go back and and get

1680
00:43:30,045 --> 00:43:31,860
0,270 270,465 465,630 630,905
more results as needed.|
|

1681
00:43:36,730 --> 00:43:39,700
0,400 570,845 845,1085 1085,1450
So this is a.|
所以这是一个。|

1682
00:43:41,320 --> 00:43:43,560
0,400 420,665 665,890 890,1270 1920,2240
Going sort of extreme scan
一种极端的扫描共享是一种称为连续扫描共享的想法。首先，我也要说，没有真正的系统可以做到这一点，但我只是喜欢它，因为这是一种思考如何构建系统的不同方式。

1683
00:43:43,560 --> 00:43:45,360
0,320 610,885 885,1160 1210,1515 1515,1800
sharing is this idea called

1684
00:43:45,360 --> 00:43:47,145
0,330 330,600 600,920 1360,1695 1695,1785
continuous scan sharing. I'll say

1685
00:43:47,145 --> 00:43:48,590
0,135 135,345 345,570 570,875 1045,1445
up front, too, that no

1686
00:43:49,060 --> 00:43:50,925
0,350 350,650 650,935 935,1270 1590,1865
real system does this, but

1687
00:43:50,925 --> 00:43:51,540
0,135 135,270 270,405 405,510 510,615
I just like it because

1688
00:43:51,540 --> 00:43:52,170
0,150 150,195 195,330 330,510 510,630
it's a different way to

1689
00:43:52,170 --> 00:43:52,740
0,120 120,255 255,375 375,465 465,570
think about how to build

1690
00:43:52,740 --> 00:43:53,840
0,120 120,380
a system.|
|

1691
00:43:54,000 --> 00:43:55,430
0,400 660,1010 1010,1220 1220,1340 1340,1430
So again, going back to
因此，再次回到他的观点上，他说实施扫描将是困难的。分享，保护，潜在的，是的，对吗？但如果你只是做了最愚蠢的事呢？

1692
00:43:55,430 --> 00:43:56,030
0,120 120,300 300,450 450,540 540,600
his point, he said it

1693
00:43:56,030 --> 00:43:56,710
0,60 60,165 165,300 300,420 420,680
would be hard to implement

1694
00:43:57,180 --> 00:43:59,165
0,275 275,470 470,790 1230,1715 1715,1985
the scan. Sharing, protecting, potentially,

1695
00:43:59,165 --> 00:44:01,325
0,335 745,1145 1705,1965 1965,2070 2070,2160
yes, right? But what if

1696
00:44:01,325 --> 00:44:02,255
0,105 105,255 255,450 450,615 615,930
you just did the dumbest

1697
00:44:02,255 --> 00:44:04,120
0,305
thing?|
|

1698
00:44:04,640 --> 00:44:06,810
0,400 1080,1445 1445,1640 1640,1865 1865,2170
Just everything due scan sharing
因为光标一直在运行，所以所有的东西都应该扫描共享。所以它真的会一页接一页地读，把它放到你的缓冲池里，然后当你读完了，L就会回来，重新来一遍。

1699
00:44:07,160 --> 00:44:08,800
0,400 630,905 905,1265 1265,1400 1400,1640
because the cursor just running

1700
00:44:08,800 --> 00:44:10,660
0,300 300,510 510,770 1540,1770 1770,1860
all the time. So it

1701
00:44:10,660 --> 00:44:12,010
0,255 255,630 630,825 825,1080 1080,1350
literally reads one page after

1702
00:44:12,010 --> 00:44:13,480
0,350 790,1080 1080,1230 1230,1350 1350,1470
another, brings that into your

1703
00:44:13,480 --> 00:44:15,790
0,255 255,530 790,1080 1080,1370 1930,2310
buffer pool and then when

1704
00:44:15,790 --> 00:44:17,770
0,315 315,560 1270,1560 1560,1755 1755,1980
you're done, just l back

1705
00:44:17,770 --> 00:44:18,760
0,315 315,615 615,780 780,885 885,990
around and does it all

1706
00:44:18,760 --> 00:44:19,880
0,195 195,530
over again.|
|

1707
00:44:19,950 --> 00:44:21,155
0,260 260,520 570,815 815,935 935,1205
So now when a query
所以现在当一个查询出现时，你只是在它进行的时候突然出现，然后得到你需要的东西，然后你离开，你就完成了。

1708
00:44:21,155 --> 00:44:22,745
0,255 255,545 985,1245 1245,1410 1410,1590
shows up, you just kind

1709
00:44:22,745 --> 00:44:25,430
0,275 415,750 750,1085 1225,1625 2305,2685
of pop along whenever it's

1710
00:44:25,430 --> 00:44:26,270
0,240 240,465 465,585 585,720 720,840
going and then get what

1711
00:44:26,270 --> 00:44:26,930
0,105 105,285 285,465 465,555 555,660
you need and then you

1712
00:44:26,930 --> 00:44:27,640
0,120 120,240 240,330 330,480 480,710
go away and you're done.|
|

1713
00:44:32,080 --> 00:44:33,200
0,320 320,485 485,590 590,785 785,1120
Good idea or bad idea?|
好主意还是坏主意？|

1714
00:44:34,970 --> 00:44:37,380
0,260 260,520 960,1265 1265,1570
With that heard bad.|
听起来很糟糕。|

1715
00:44:37,380 --> 00:44:39,615
0,260 1090,1410 1410,1605 1605,1940 1960,2235
Why? You're probably doing a
为什么？你可能做了很多额外的阅读。

1716
00:44:39,615 --> 00:44:41,140
0,150 150,270 270,510 510,1025
lot of extra reads.|
|

1717
00:44:41,700 --> 00:44:42,620
0,275 275,485 485,665 665,755 755,920
Need it. I guess it
我需要它。我想这要看是否。

1718
00:44:42,620 --> 00:44:44,100
0,240 240,465 465,770
depends on if.|
|

1719
00:44:44,440 --> 00:44:45,630
0,380 380,665 665,860 860,980 980,1190
So assuming it's ol lab,
因此，假设这是一个完整的实验室，假设每个查询都在执行，可能是全表扫描，或者几乎是全表扫描。

1720
00:44:45,630 --> 00:44:46,610
0,210 210,420 420,630 630,735 735,980
assuming every query is doing,

1721
00:44:46,780 --> 00:44:47,760
0,275 275,410 410,560 560,770 770,980
maybe a full table scan

1722
00:44:47,760 --> 00:44:48,840
0,290 370,615 615,720 720,870 870,1080
or almost a full table

1723
00:44:48,840 --> 00:44:49,680
0,320
scan.|
|

1724
00:44:50,700 --> 00:44:51,360
0,210 210,285 285,360 360,480 480,660
Or if we have some
或者，如果我们有一些桌子只是坐在那里，我们只是站在那里，那永远不是通道。那你们有桌子吗？所以你，你可能会说，你知道，游标不会被触发，直到查询显示它触及了表。

1725
00:44:51,360 --> 00:44:52,425
0,225 225,435 435,645 645,900 900,1065
table just sitting around and

1726
00:44:52,425 --> 00:44:53,310
0,135 135,270 270,525 525,750 750,885
we're just standing through it,

1727
00:44:53,310 --> 00:44:54,495
0,225 225,450 450,825 825,1080 1080,1185
that's never access. So would

1728
00:44:54,495 --> 00:44:55,605
0,75 75,135 135,210 210,455 835,1110
you have a table? So

1729
00:44:55,605 --> 00:44:56,480
0,150 150,285 285,375 375,540 540,875
you, you could maybe say,

1730
00:44:56,560 --> 00:44:57,765
0,230 230,320 320,425 425,845 845,1205
you know, the cursor doesn't

1731
00:44:57,765 --> 00:44:58,845
0,120 120,345 345,540 540,765 765,1080
get fired until the query

1732
00:44:58,845 --> 00:44:59,780
0,150 150,300 300,570 570,675 675,935
shows that touches the table.|
|

1733
00:45:00,970 --> 00:45:01,960
0,400
That.|
那。|

1734
00:45:02,020 --> 00:45:03,050
0,305 305,455 455,575 575,740 740,1030
Involves a lot of bringing.|
牵涉到很多的带来。|

1735
00:45:03,640 --> 00:45:04,860
0,165 165,360 360,680 700,960 960,1220
Is into memory and then
存入内存，然后立即将其删除。

1736
00:45:04,910 --> 00:45:06,080
0,380 380,515 515,680 680,970
deleting them right after.|
|

1737
00:45:06,800 --> 00:45:08,080
0,320 320,640
Yeah, but.|
是啊，但是。|

1738
00:45:08,410 --> 00:45:09,920
0,400
Ah.|
阿。|

1739
00:45:11,340 --> 00:45:12,540
0,400
Well.|
井。|

1740
00:45:13,200 --> 00:45:13,820
0,260 260,380 380,470 470,545 545,620
Say you have to do
假设您无论如何都要为一个完整的表格扫描器执行此操作，因为表格无论如何都无法放入内存中。

1741
00:45:13,820 --> 00:45:14,405
0,135 135,285 285,405 405,480 480,585
that anyway for a full

1742
00:45:14,405 --> 00:45:15,125
0,180 180,420 420,510 510,600 600,720
table scanner because the table

1743
00:45:15,125 --> 00:45:16,030
0,210 210,285 285,345 345,540 540,905
doesn't fit in memory anyway.|
|

1744
00:45:19,600 --> 00:45:21,300
0,400
So.|
所以。|

1745
00:45:21,430 --> 00:45:24,140
0,400
Yes.|
是。|

1746
00:45:24,540 --> 00:45:25,510
0,290 290,380 380,515 515,695 695,970
It's hard to skip around
在某些方面，很难很好地跳过。而且，它也让你的，你的运行时间有点确定性，对吧？因为你知道在页码结束的地方至少是n，对吧？

1747
00:45:26,340 --> 00:45:27,395
0,305 305,485 485,620 620,830 830,1055
well in some ways. Also,

1748
00:45:27,395 --> 00:45:28,835
0,210 210,405 405,600 600,935 1075,1440
too, it makes your, your

1749
00:45:28,835 --> 00:45:30,170
0,270 270,480 480,630 630,765 765,1335
run time kind of deterministic,

1750
00:45:30,170 --> 00:45:31,175
0,255 255,465 465,600 600,765 765,1005
right? Coz you know it's

1751
00:45:31,175 --> 00:45:33,275
0,120 120,395 1315,1590 1590,1800 1800,2100
gonna be at least n

1752
00:45:33,275 --> 00:45:33,935
0,195 195,255 255,390 390,525 525,660
where it ends the number

1753
00:45:33,935 --> 00:45:36,100
0,305 985,1385
pages, right?|
|

1754
00:45:36,230 --> 00:45:37,720
0,380 380,485 485,650 650,970 1110,1490
That's just for scans. Joins
那只是扫描用的。加入我们的号角，另一个我们还没有谈论过的野兽。

1755
00:45:37,720 --> 00:45:38,350
0,90 90,210 210,360 360,525 525,630
our horn, other beast we

1756
00:45:38,350 --> 00:45:41,080
0,150 150,240 240,375 375,650
haven't talked about yet.|
|

1757
00:45:41,180 --> 00:45:42,310
0,260 260,425 425,590 590,845 845,1130
If it's on prem, you've
如果它在Prem上，你已经支付了硬件费用，忽略了能源成本，那么你知道这是可以接受的，但如果它在云中运行，你实际上是按IOP付费的，那么这实际上很糟糕。

1758
00:45:42,310 --> 00:45:43,020
0,120 120,285 285,390 390,465 465,710
already paid for the hardware,

1759
00:45:43,340 --> 00:45:44,980
0,515 515,770 770,1010 1010,1390 1410,1640
ignoring energy costs, then you

1760
00:45:44,980 --> 00:45:45,595
0,90 90,210 210,345 345,465 465,615
know this is kind of

1761
00:45:45,595 --> 00:45:46,840
0,305 625,870 870,945 945,1095 1095,1245
okay, but if it's running

1762
00:45:46,840 --> 00:45:47,785
0,120 120,225 225,480 480,750 750,945
in the cloud you actually

1763
00:45:47,785 --> 00:45:48,805
0,225 225,405 405,765 765,915 915,1020
paying per iop then this

1764
00:45:48,805 --> 00:45:50,200
0,180 180,375 375,635
is actually terrible.|
|

1765
00:45:50,200 --> 00:45:51,505
0,315 315,710 760,1050 1050,1200 1200,1305
Right, because you end up
是的，因为你最终读取的数据比你实际需要的要多。我是说，我知道只有一个原型能做到这一点，它出自H H苏黎世，名为Kerkin，他们专门为电信业务构建了它，在那里他们需要确定性的查询运行时间。

1766
00:45:51,505 --> 00:45:52,405
0,150 150,330 330,510 510,675 675,900
reading more data than you

1767
00:45:52,405 --> 00:45:54,070
0,345 345,600 600,875 1375,1605 1605,1665
potentially actually need. So I

1768
00:45:54,070 --> 00:45:55,350
0,75 75,195 195,450 450,740 880,1280
was saying there's only one

1769
00:45:55,400 --> 00:45:56,620
0,620 620,755 755,905 905,1055 1055,1220
prototype I know that did

1770
00:45:56,620 --> 00:45:57,780
0,290 310,570 570,735 735,900 900,1160
this out of out of

1771
00:45:57,920 --> 00:45:59,620
0,305 305,500 500,940 1050,1310 1310,1700
H H Zurich called kerkin

1772
00:45:59,620 --> 00:46:01,555
0,320 1330,1575 1575,1695 1695,1830 1830,1935
though, and they built it

1773
00:46:01,555 --> 00:46:03,715
0,245 385,750 750,1115 1435,1935 1935,2160
specifically for a telecom business

1774
00:46:03,715 --> 00:46:05,395
0,195 195,315 315,575 625,1290 1290,1680
where they needed deterministic runtimes

1775
00:46:05,395 --> 00:46:06,600
0,150 150,605
of queries.|
|

1776
00:46:06,600 --> 00:46:07,875
0,260 640,900 900,1020 1020,1140 1140,1275
EM, but this was a
嗯，但这是几年前的事了，是另一个原型。它也有同样的事情。所以这是一个有趣的想法。这是一种不同的方式来思考一个非正统的系统。我喜欢送一个不一样的礼物。我喜欢数据库。有太多不同的方法可以再次解决同样的问题。

1777
00:46:07,875 --> 00:46:10,455
0,135 135,285 285,435 435,695 2305,2580
few years ago and was

1778
00:46:10,455 --> 00:46:11,235
0,180 180,495 495,570 570,675 675,780
another prototype. It had the

1779
00:46:11,235 --> 00:46:12,375
0,135 135,270 270,360 360,605 805,1140
same kind of thing. So

1780
00:46:12,375 --> 00:46:13,260
0,225 225,390 390,630 630,765 765,885
it's an interesting idea. It's

1781
00:46:13,260 --> 00:46:13,755
0,75 75,210 210,345 345,420 420,495
a different way to think

1782
00:46:13,755 --> 00:46:16,010
0,90 90,195 195,375 375,1620 1620,2255
of a system that's unorthodox.

1783
00:46:16,630 --> 00:46:18,230
0,320 320,545 545,830 830,1205 1205,1600
I like present a different.

1784
00:46:19,360 --> 00:46:20,445
0,260 260,380 380,815 815,995 995,1085
I love databases. There's so

1785
00:46:20,445 --> 00:46:21,200
0,75 75,195 195,360 360,495 495,755
many different ways to solve

1786
00:46:21,340 --> 00:46:25,320
0,245 245,380 380,670 750,1150
the same problem again.|
|

1787
00:46:27,590 --> 00:46:28,540
0,245 245,425 425,755 755,860 860,950
So last optimization you talk
因此，您最后谈到的优化称为缓冲区拉出旁路。

1788
00:46:28,540 --> 00:46:29,290
0,105 105,195 195,330 330,615 615,750
about is called buffer pull

1789
00:46:29,290 --> 00:46:30,660
0,470
bypass.|
|

1790
00:46:30,910 --> 00:46:32,160
0,335 335,605 605,875 875,1085 1085,1250
And the idea here is
这里的想法是。

1791
00:46:32,160 --> 00:46:33,900
0,290
that.|
|

1792
00:46:34,060 --> 00:46:35,280
0,260 260,410 410,650 650,905 905,1220
If we have a query
如果我们有一个运行顺序扫描的查询。

1793
00:46:35,445 --> 00:46:36,680
0,90 90,300 300,555 555,870 870,1235
that's running a sequential scan.|
|

1794
00:46:38,280 --> 00:46:39,005
0,245 245,365 365,485 485,605 605,725
You know, we had to
你知道，我们必须把磁盘上的东西放到内存中，但也许我们不想把它放到我们的缓冲池中，因为人们需要支付页面中缓冲池的维护成本，取一个闩锁，更新东西等等，对吗？而且，如果我们进行顺序扫描，我们刚刚读取的数据可能实际上并不有用。嗯，它对我们的查询没有用处，因为我们将按顺序扫描。我们只会上一次餐桌。

1795
00:46:39,005 --> 00:46:39,950
0,135 135,345 345,540 540,675 675,945
bring things off a disk

1796
00:46:39,950 --> 00:46:41,855
0,150 150,470 970,1335 1335,1665 1665,1905
into memory, but maybe we

1797
00:46:41,855 --> 00:46:42,740
0,300 300,450 450,600 600,750 750,885
don't want to put it

1798
00:46:42,740 --> 00:46:44,800
0,210 210,450 450,780 780,1070 1660,2060
into our buffer pool because

1799
00:46:45,150 --> 00:46:46,070
0,305 305,455 455,590 590,785 785,920
one need to pay for

1800
00:46:46,070 --> 00:46:46,745
0,60 60,255 255,495 495,600 600,675
the maintenance cost of the

1801
00:46:46,745 --> 00:46:48,365
0,210 210,455 715,1110 1110,1365 1365,1620
buffer pool in the page,

1802
00:46:48,365 --> 00:46:49,505
0,240 240,345 345,635 685,960 960,1140
take a latch, update things

1803
00:46:49,505 --> 00:46:50,530
0,255 255,480 480,615 615,750 750,1025
and stuff and so forth,

1804
00:46:50,580 --> 00:46:52,475
0,400 990,1265 1265,1535 1535,1790 1790,1895
right? And then also too,

1805
00:46:52,475 --> 00:46:53,440
0,75 75,180 180,300 300,690 690,965
if we're doing sequential scan,

1806
00:46:53,910 --> 00:46:55,280
0,400 570,845 845,1040 1040,1205 1205,1370
the the data we just

1807
00:46:55,280 --> 00:46:56,435
0,320 340,630 630,870 870,1050 1050,1155
read may not actually be

1808
00:46:56,435 --> 00:46:57,860
0,275 925,1155 1155,1260 1260,1335 1335,1425
useful. Well, it's not gonna

1809
00:46:57,860 --> 00:46:58,625
0,60 60,225 225,405 405,525 525,765
be useful for our query

1810
00:46:58,625 --> 00:46:59,945
0,180 180,405 405,600 600,1020 1020,1320
because we're going sequentially scan.

1811
00:46:59,945 --> 00:47:00,650
0,300 300,390 390,480 480,525 525,705
We're only going to be

1812
00:47:00,650 --> 00:47:02,660
0,350 550,840 840,1050 1050,1370
the the table once.|
|

1813
00:47:03,510 --> 00:47:06,110
0,400 1740,2000 2000,2120 2120,2345 2345,2600
Usually and so rather than
通常如此，而不是拥有所有这些不同的。

1814
00:47:06,110 --> 00:47:08,640
0,255 255,540 540,750 750,1040
having all these different.|
|

1815
00:47:08,890 --> 00:47:10,490
0,290 290,580 960,1205 1205,1325 1325,1600
These different, you know, workers
这些不同的，你知道，工作人员运行相同的时间，做随机扫描和污染页面表。

1816
00:47:10,510 --> 00:47:11,910
0,275 275,395 395,545 545,830 830,1400
running the same time, doingential

1817
00:47:11,910 --> 00:47:13,380
0,290 310,615 615,1010 1030,1290 1290,1470
scans and polluting the page

1818
00:47:13,380 --> 00:47:14,480
0,320
table.|
|

1819
00:47:14,480 --> 00:47:15,800
0,150 150,300 300,450 450,710 1060,1320
What if we just give
如果我们只给每个工人自己的一小部分会怎么样？

1820
00:47:15,800 --> 00:47:17,590
0,195 195,530 970,1245 1245,1455 1455,1790
every worker its own little?|
|

1821
00:47:18,660 --> 00:47:20,950
0,260 260,365 365,610 1800,2045 2045,2290
Piece of memory, like a
一段记忆，就像一个工作记忆。然后，我们读到的任何一页，我们都会放入那个工人的记忆中。是的，你可以有复制品。只有当它是只读的时，它才起作用。你不能写东西。

1822
00:47:21,420 --> 00:47:23,870
0,320 320,640 1170,1445 1445,1720 2100,2450
working memory. And then any

1823
00:47:23,870 --> 00:47:25,445
0,270 270,480 480,770 1180,1455 1455,1575
page we read, we put

1824
00:47:25,445 --> 00:47:26,890
0,165 165,485 505,810 810,1200 1200,1445
into that, that worker's memory.

1825
00:47:27,420 --> 00:47:28,600
0,305 305,455 455,545 545,665 665,1180
Yes, you could have duplicates.

1826
00:47:28,800 --> 00:47:29,660
0,275 275,425 425,590 590,710 710,860
It only works if it's

1827
00:47:29,660 --> 00:47:30,605
0,135 135,390 390,630 630,825 825,945
read only. You can't do

1828
00:47:30,605 --> 00:47:32,440
0,275
writes.|
|

1829
00:47:32,440 --> 00:47:33,055
0,120 120,285 285,405 405,540 540,615
And that way it's just
这样一来，它就像一个循环缓冲区。我们只是不断地加满油，绕来绕去。

1830
00:47:33,055 --> 00:47:33,880
0,90 90,195 195,480 480,750 750,825
like a circular buffer. We

1831
00:47:33,880 --> 00:47:34,810
0,105 105,330 330,615 615,720 720,930
just keep filling up and

1832
00:47:34,810 --> 00:47:36,420
0,270 270,590
wrap around.|
|

1833
00:47:37,030 --> 00:47:37,995
0,305 305,455 455,575 575,710 710,965
So a bunch of systems
所以很多系统都支持这个Oracle秘密服务器，Postgres和Formics。我认为这起源于信息学，他们称之为轻扫描，轻的意思，因为同样，你不会触及缓冲池中的那种重量级页面表。

1834
00:47:37,995 --> 00:47:39,810
0,285 285,575 985,1410 1410,1575 1575,1815
support this Oracle secret server,

1835
00:47:39,810 --> 00:47:41,835
0,530 610,1010 1090,1610 1660,1905 1905,2025
postgres and formics. I think

1836
00:47:41,835 --> 00:47:43,875
0,210 210,780 780,1265 1675,1920 1920,2040
this originated informics and they

1837
00:47:43,875 --> 00:47:45,405
0,120 120,225 225,405 405,755 1255,1530
call it light scans, light

1838
00:47:45,405 --> 00:47:46,515
0,180 180,360 360,495 495,735 735,1110
meaning, because again, you don't

1839
00:47:46,515 --> 00:47:47,685
0,195 195,450 450,615 615,750 750,1170
touch that sort of heavyweight

1840
00:47:47,685 --> 00:47:48,420
0,210 210,375 375,465 465,540 540,735
page table in the buffer

1841
00:47:48,420 --> 00:47:49,320
0,260
pool.|
|

1842
00:47:49,610 --> 00:47:50,710
0,350 350,620 620,845 845,995 995,1100
And the idea here is
这里的想法是，我可能不会污染我的页表，因为我需要的数据，但我需要的数据是我本地的。

1843
00:47:50,710 --> 00:47:52,930
0,180 180,375 375,650 910,1310 1900,2220
that I can potentially not

1844
00:47:52,930 --> 00:47:54,160
0,240 240,390 390,600 600,915 915,1230
pollute my page table because

1845
00:47:54,160 --> 00:47:56,365
0,180 180,345 345,540 540,830 1930,2205
the data I need, but

1846
00:47:56,365 --> 00:47:57,090
0,120 120,240 240,375 375,480 480,725
the data I need is

1847
00:47:57,470 --> 00:47:58,980
0,245 245,490 690,1055 1055,1265 1265,1510
sort of local to me.|
|

1848
00:47:59,700 --> 00:48:00,965
0,245 245,490 570,845 845,1175 1175,1265
Of course, the downside of
当然，这样做的缺点是你失去了两个人同时需要相同的页面，或者一个接一个的共享能力。那么您就失去了重用的可能性。但同样，这是我们可以进行的另一种优化，因为我们准确地控制了。

1849
00:48:00,965 --> 00:48:02,045
0,135 135,285 285,420 420,695 775,1080
this is that you lose

1850
00:48:02,045 --> 00:48:03,605
0,180 180,375 375,695 715,1115 1165,1560
the sharing capability of two,

1851
00:48:03,605 --> 00:48:05,105
0,395 625,975 975,1200 1200,1335 1335,1500
two workers need the same

1852
00:48:05,105 --> 00:48:06,160
0,270 270,480 480,585 585,750 750,1055
pages at the same time,

1853
00:48:06,630 --> 00:48:08,290
0,400 570,935 935,1160 1160,1340 1340,1660
or one soon after another.

1854
00:48:08,670 --> 00:48:10,865
0,400 660,920 920,1085 1085,1390 1770,2195
Then you lose that reuse

1855
00:48:10,865 --> 00:48:13,475
0,305 1525,1785 1785,2010 2010,2355 2355,2610
possibility. But again, it's another

1856
00:48:13,475 --> 00:48:14,570
0,435 435,615 615,735 735,870 870,1095
optimization that we can do

1857
00:48:14,570 --> 00:48:15,860
0,225 225,435 435,735 735,1050 1050,1290
because we control exactly what

1858
00:48:15,860 --> 00:48:16,780
0,290
the.|
|

1859
00:48:16,930 --> 00:48:18,135
0,215 215,430 510,785 785,935 935,1205
You know what the queries
你知道查询是什么，实际上知道它们实际执行和触及的是什么。

1860
00:48:18,135 --> 00:48:19,980
0,135 135,390 390,755 1375,1650 1650,1845
are, actually know what they're

1861
00:48:19,980 --> 00:48:21,600
0,210 210,555 555,720 720,1130
actually executing and touching.|
|

1862
00:48:24,150 --> 00:48:25,460
0,400
Right.|
正确的。|

1863
00:48:26,060 --> 00:48:27,115
0,365 365,620 620,755 755,860 860,1055
So we sort of dance
所以我们在某种程度上绕过了这个想法。

1864
00:48:27,115 --> 00:48:29,120
0,195 195,390 390,675 675,1025
around this idea of.|
|

1865
00:48:29,120 --> 00:48:30,680
0,465 465,740 790,1035 1035,1365 1365,1560
Evicting data or addicting pages
从我们的缓冲池中驱逐数据或令人上瘾的页面。所以现在我们要谈谈我们到底要怎么做。你需要知道这一点，因为这是第一个项目。

1866
00:48:30,680 --> 00:48:32,165
0,165 165,270 270,450 450,770 1240,1485
from our buff pool. So

1867
00:48:32,165 --> 00:48:32,630
0,105 105,210 210,285 285,360 360,465
now we got to talk

1868
00:48:32,630 --> 00:48:33,515
0,165 165,375 375,645 645,795 795,885
about how we're actually going

1869
00:48:33,515 --> 00:48:34,565
0,105 105,210 210,455 655,915 915,1050
to do it. You need

1870
00:48:34,565 --> 00:48:35,750
0,120 120,255 255,465 465,785 835,1185
to know this because it's

1871
00:48:35,750 --> 00:48:37,860
0,195 195,530
project one.|
|

1872
00:48:37,930 --> 00:48:39,160
0,400
So.|
所以。|

1873
00:48:39,550 --> 00:48:41,880
0,400 720,1120 1230,1630 1650,2045 2045,2330
When the execution says, okay,
当执行程序说，好的，我要把一个页面放到内存中，我要放进一个框架，如果没有空闲的框架，它必须决定要驱逐什么。这是一个，这不应该是开创性的。

1874
00:48:41,880 --> 00:48:42,960
0,270 270,465 465,660 660,870 870,1080
I'm bringing a page into

1875
00:48:42,960 --> 00:48:44,265
0,290 760,1080 1080,1140 1140,1215 1215,1305
memory, I'm going to put

1876
00:48:44,265 --> 00:48:47,100
0,135 135,315 315,605 2185,2520 2520,2835
into a frame, if there's

1877
00:48:47,100 --> 00:48:48,300
0,195 195,450 450,795 795,1050 1050,1200
no free frames, it has

1878
00:48:48,300 --> 00:48:49,550
0,180 180,470 490,780 780,900 900,1250
to decide what to evict.

1879
00:48:50,500 --> 00:48:52,590
0,275 275,490 1260,1660 1740,1985 1985,2090
It's a, this should not

1880
00:48:52,590 --> 00:48:53,680
0,135 135,710
be groundbreaking.|
|

1881
00:48:55,260 --> 00:48:57,620
0,380 430,830 1360,1710 1710,2010 2010,2360
So the budget if different.|
因此，如果预算不同的话。|

1882
00:48:58,960 --> 00:49:00,285
0,365 365,665 665,995 995,1235 1235,1325
Metrics or objectives we have
我们在驱逐政策中必须考虑的指标或目标将取决于我们实施数据库系统的各种因素。

1883
00:49:00,285 --> 00:49:02,040
0,195 195,545 895,1245 1245,1455 1455,1755
to consider in our eviction

1884
00:49:02,040 --> 00:49:03,750
0,350 850,1245 1245,1320 1320,1455 1455,1710
policy that's going to depend

1885
00:49:03,750 --> 00:49:06,015
0,350 520,900 900,1280 1330,1730 1960,2265
on various factors of our

1886
00:49:06,015 --> 00:49:07,070
0,270 270,465 465,555 555,735 735,1055
implementation of our database system.|
|

1887
00:49:07,980 --> 00:49:09,050
0,305 305,545 545,755 755,860 860,1070
Obviously, we want our eviction
显然，我们希望我们的驱逐政策是正确的，对吗？我们不想驱逐一页。然后马上就来。那一页是最多的，你知道，最常用的东西，因此我们一遍又一遍地从磁盘上读写它。这会是件坏事吗？

1888
00:49:09,050 --> 00:49:10,790
0,270 270,465 465,630 630,950 1480,1740
policy to be correct, right?

1889
00:49:10,790 --> 00:49:11,375
0,105 105,240 240,300 300,360 360,585
We don't want to evict

1890
00:49:11,375 --> 00:49:12,590
0,165 165,420 420,705 705,975 975,1215
a page. Then immediately. That

1891
00:49:12,590 --> 00:49:13,370
0,165 165,300 300,405 405,600 600,780
page is the most, you

1892
00:49:13,370 --> 00:49:14,375
0,210 210,435 435,570 570,780 780,1005
know, the most used thing,

1893
00:49:14,375 --> 00:49:15,530
0,225 225,420 420,645 645,930 930,1155
and therefore we keep reading

1894
00:49:15,530 --> 00:49:16,310
0,135 135,270 270,420 420,555 555,780
and writing it from disk

1895
00:49:16,310 --> 00:49:17,195
0,105 105,195 195,300 300,590 640,885
over and over again. Could

1896
00:49:17,195 --> 00:49:18,380
0,105 105,210 210,455
that be bad?|
|

1897
00:49:19,410 --> 00:49:20,860
0,290 290,580 690,920 920,1130 1130,1450
We want our eviction policy
我们希望我们的驱逐政策是快速的。

1898
00:49:20,970 --> 00:49:22,600
0,245 245,380 380,670
to be fast.|
|

1899
00:49:22,600 --> 00:49:23,640
0,210 210,390 390,540 540,780 780,1040
Right. We, we don't want,
正确的。我们，我们不想，你知道，这是一个，我们使用的是MP完全算法或指数算法。我们不想花三秒钟来决定使用哪一页，因为监视器会从磁盘上读取它。一开始，这会快得多。

1900
00:49:23,810 --> 00:49:25,570
0,245 245,490 630,935 935,1150 1470,1760
you know, it's a, we're

1901
00:49:25,570 --> 00:49:26,950
0,135 135,300 300,690 690,1005 1005,1380
using an mp complete algorithm

1902
00:49:26,950 --> 00:49:28,630
0,290 550,1215 1215,1455 1455,1545 1545,1680
or exponential algorithm. We don't

1903
00:49:28,630 --> 00:49:29,620
0,75 75,210 210,465 465,720 720,990
want to take three seconds

1904
00:49:29,620 --> 00:49:30,790
0,285 285,480 480,645 645,795 795,1170
to decide what page toict

1905
00:49:30,790 --> 00:49:32,560
0,320 760,1230 1230,1485 1485,1680 1680,1770
because monitors go read it

1906
00:49:32,560 --> 00:49:33,535
0,105 105,405 405,675 675,915 915,975
from disk. That would have

1907
00:49:33,535 --> 00:49:34,090
0,60 60,165 165,360 360,495 495,555
a lot faster in the

1908
00:49:34,090 --> 00:49:35,100
0,120 120,410
first place.|
|

1909
00:49:35,520 --> 00:49:36,425
0,305 305,485 485,590 590,710 710,905
And related to this, we
与此相关的是，我们也不想支付维护元数据的大成本。我们需要跟踪页面是如何被访问的，这样我们才能决定访问什么。

1910
00:49:36,425 --> 00:49:37,910
0,150 150,315 315,390 390,635 1225,1485
also don't want to pay

1911
00:49:37,910 --> 00:49:39,280
0,135 135,410 520,870 870,1095 1095,1370
a big cost of maintaining

1912
00:49:39,450 --> 00:49:40,610
0,275 275,725 725,830 830,995 995,1160
the metadata. We need to

1913
00:49:40,610 --> 00:49:41,990
0,150 150,315 315,495 495,800 1060,1380
keep track of how pages

1914
00:49:41,990 --> 00:49:43,550
0,180 180,435 435,1010 1180,1425 1425,1560
are being accessed so that

1915
00:49:43,550 --> 00:49:44,350
0,135 135,225 225,345 345,510 510,800
we can make a decision

1916
00:49:44,520 --> 00:49:46,500
0,290 290,760
what toit.|
|

1917
00:49:47,800 --> 00:49:48,480
0,245 245,350 350,485 485,605 605,680
So again, this is the
因此，这又是计算机科学中最古老的问题。

1918
00:49:48,480 --> 00:49:49,730
0,165 165,480 480,750 750,945 945,1250
oldest problem in computer science.|
|

1919
00:49:50,750 --> 00:49:51,850
0,335 335,590 590,800 800,950 950,1100
The oldest problem in computer
计算机科学中最古老的问题是命名某个东西或命名一个系统。我们可以谈谈公共汽车站是怎么命名的，但是。

1920
00:49:51,850 --> 00:49:52,930
0,195 195,375 375,690 690,900 900,1080
science is naming something or

1921
00:49:52,930 --> 00:49:54,775
0,210 210,315 315,590 1540,1770 1770,1845
naming a system. We can

1922
00:49:54,775 --> 00:49:55,315
0,75 75,135 135,225 225,375 375,540
talk about how bus stop

1923
00:49:55,315 --> 00:49:57,340
0,150 150,360 360,695
got named, but.|
|

1924
00:49:57,920 --> 00:49:58,930
0,350 350,545 545,650 650,755 755,1010
Like everyone has a caching
就像每个人都有一张缓存纸一样，我想我有两张。

1925
00:49:58,930 --> 00:50:00,370
0,260 850,1125 1125,1245 1245,1320 1320,1440
paper, I think I have

1926
00:50:00,370 --> 00:50:02,500
0,290
two.|
|

1927
00:50:03,310 --> 00:50:05,355
0,400 750,995 995,1240 1560,1835 1835,2045
So the most obvious easy
所以最明显容易做的事情是L你最近最少使用吗？这里的基本思想是维护一个时间戳或跟踪一个链接，链接是页面最后一次被触摸的时间的链表。

1928
00:50:05,355 --> 00:50:06,600
0,195 195,315 315,495 495,815 985,1245
thing to do is do

1929
00:50:06,600 --> 00:50:07,560
0,135 135,270 270,465 465,690 690,960
L R U least recently

1930
00:50:07,560 --> 00:50:09,750
0,380 1150,1395 1395,1640 1690,1995 1995,2190
use? The basic idea here

1931
00:50:09,750 --> 00:50:10,935
0,165 165,405 405,720 720,960 960,1185
is just maintain a time

1932
00:50:10,935 --> 00:50:12,120
0,300 300,555 555,720 720,960 960,1185
stamp or keep track a

1933
00:50:12,120 --> 00:50:13,310
0,150 150,315 315,480 480,770 790,1190
link, a linked list of

1934
00:50:13,750 --> 00:50:16,140
0,400 1320,1655 1655,1955 1955,2195 2195,2390
when when pages were last

1935
00:50:16,140 --> 00:50:17,140
0,320
touched.|
|

1936
00:50:17,330 --> 00:50:18,445
0,260 260,395 395,500 500,730 810,1115
And then when it comes
然后，当需要驱逐页面时，我们只需转到链表的末尾，然后弹出、弹出那里的任何内容。你也知道有一段时间没人访问过了。我们继续前进，把它赶走。

1937
00:50:18,445 --> 00:50:19,290
0,180 180,285 285,480 480,600 600,845
time to evict a page,

1938
00:50:19,520 --> 00:50:20,410
0,245 245,365 365,575 575,755 755,890
we just go to the

1939
00:50:20,410 --> 00:50:21,205
0,195 195,390 390,540 540,645 645,795
tail end of the linked

1940
00:50:21,205 --> 00:50:23,485
0,305 775,1175 1435,1815 1815,2115 2115,2280
list and pop, pop whatever

1941
00:50:23,485 --> 00:50:24,880
0,105 105,300 300,635 1075,1305 1305,1395
is there. And you know

1942
00:50:24,880 --> 00:50:25,690
0,150 150,300 300,465 465,600 600,810
that one hasn't been accessed

1943
00:50:25,690 --> 00:50:26,650
0,75 75,150 150,380 610,855 855,960
in a while. We go

1944
00:50:26,650 --> 00:50:27,840
0,90 90,150 150,375 375,650
ahead and evict it.|
|

1945
00:50:28,260 --> 00:50:29,720
0,245 245,490 600,950 950,1190 1190,1460
So say here q one
假设Q1想要接触第一页，第一页已经在我们的链接列表中了。因此，我们只是将其移到前面，移到头部，然后现在假设另一个查询想要访问第五页，但第五页不在内存中。因此，我们继续进行第二页。

1946
00:50:29,720 --> 00:50:30,820
0,270 270,420 420,585 585,795 795,1100
wants to touch page one,

1947
00:50:32,250 --> 00:50:33,185
0,290 290,455 455,605 605,785 785,935
page one is already in

1948
00:50:33,185 --> 00:50:34,445
0,135 135,330 330,635 955,1185 1185,1260
our linked list. So we

1949
00:50:34,445 --> 00:50:34,940
0,105 105,210 210,300 300,390 390,495
just move it to the

1950
00:50:34,940 --> 00:50:37,730
0,260 790,1035 1035,1125 1125,1370 2530,2790
front, to the head, and

1951
00:50:37,730 --> 00:50:38,735
0,165 165,390 390,600 600,795 795,1005
then now say another query

1952
00:50:38,735 --> 00:50:40,655
0,150 150,425 625,1025 1405,1695 1695,1920
wants to touch access page

1953
00:50:40,655 --> 00:50:41,750
0,300 300,525 525,690 690,915 915,1095
five, but page five is

1954
00:50:41,750 --> 00:50:43,025
0,120 120,210 210,440 880,1155 1155,1275
not in memory. So we

1955
00:50:43,025 --> 00:50:45,970
0,135 135,425 2005,2340 2340,2610 2610,2945
go ahead and page two.|
|

1956
00:50:46,750 --> 00:50:47,400
0,90 90,150 150,255 255,390 390,650
Because it's at the end.|
因为它已经结束了。|

1957
00:50:48,000 --> 00:50:48,980
0,260
Right.|
正确的。|

1958
00:50:50,780 --> 00:50:52,210
0,260 260,350 350,455 455,730 1140,1430
This should not be news
这对任何人来说都不应该是新闻。

1959
00:50:52,210 --> 00:50:53,280
0,180 180,470
to anyone.|
|

1960
00:50:54,450 --> 00:50:56,360
0,400 450,770 770,1055 1055,1420 1650,1910
So another way to achieve
因此，在不跟踪该链表中的实际时间戳的情况下实现相同目的的另一种方法是使用一种称为时钟的近似算法。

1961
00:50:56,360 --> 00:50:57,610
0,120 120,300 300,540 540,855 855,1250
the same thing without tracking

1962
00:50:57,750 --> 00:50:58,790
0,275 275,440 440,650 650,935 935,1040
the actual time stamps in

1963
00:50:58,790 --> 00:51:00,515
0,135 135,315 315,620 1360,1620 1620,1725
this linked list is to

1964
00:51:00,515 --> 00:51:02,375
0,105 105,270 270,845 865,1355 1495,1860
use an approximation algorithm called

1965
00:51:02,375 --> 00:51:03,480
0,365
clock.|
|

1966
00:51:03,580 --> 00:51:04,290
0,260 260,365 365,470 470,575 575,710
Who here has heard a
在座的谁以前听到过闹钟？

1967
00:51:04,290 --> 00:51:05,660
0,195 195,500
clock before?|
|

1968
00:51:06,450 --> 00:51:09,140
0,275 275,410 410,635 635,1000
Less than five, OK?|
不到五个，好吗？|

1969
00:51:09,180 --> 00:51:10,295
0,260 260,425 425,730 750,995 995,1115
And so clock a clock
因此，时钟时钟也在使用一系列其他系统。我认为Linux将其用于页面缓存或页面表。他们使用多指针时钟，我们不需要知道这一点。但这里的基本思想是，不是像L R U中那样跟踪页面的确切顺序，相反，我们只为我们用来跟踪的每个页面提供一个简单的引用位。

1970
00:51:10,295 --> 00:51:11,060
0,210 210,450 450,585 585,675 675,765
is using a bunch of

1971
00:51:11,060 --> 00:51:11,945
0,135 135,360 360,555 555,735 735,885
other systems as well. I

1972
00:51:11,945 --> 00:51:13,310
0,135 135,420 420,660 660,1025 1105,1365
think Linux uses this for

1973
00:51:13,310 --> 00:51:15,110
0,150 150,330 330,650 1390,1650 1650,1800
its page cache or page

1974
00:51:15,110 --> 00:51:17,180
0,290 1420,1680 1680,1800 1800,1905 1905,2070
table. They use a multi

1975
00:51:17,180 --> 00:51:19,550
0,225 225,450 450,770 2020,2250 2250,2370
hand clock, which we don't

1976
00:51:19,550 --> 00:51:20,230
0,75 75,180 180,285 285,405 405,680
need to know about that.

1977
00:51:20,250 --> 00:51:21,155
0,245 245,320 320,500 500,755 755,905
But the basic idea here

1978
00:51:21,155 --> 00:51:22,265
0,105 105,365 565,825 825,930 930,1110
is that instead of keeping

1979
00:51:22,265 --> 00:51:23,345
0,240 240,435 435,630 630,825 825,1080
track of like the exact

1980
00:51:23,345 --> 00:51:25,540
0,465 465,755 955,1355 1585,1890 1890,2195
ordering of of of pages

1981
00:51:25,800 --> 00:51:27,800
0,290 290,455 455,605 605,880 1680,2000
in L R U, instead

1982
00:51:27,800 --> 00:51:30,155
0,165 165,315 315,620 850,1250 2080,2355
we just give a use

1983
00:51:30,155 --> 00:51:31,850
0,165 165,450 450,825 825,1205 1465,1695
a simple reference bit for

1984
00:51:31,850 --> 00:51:33,425
0,165 165,500 1060,1305 1305,1410 1410,1575
every page that we use

1985
00:51:33,425 --> 00:51:34,760
0,150 150,285 285,450 450,725
to keep track of.|
|

1986
00:51:35,550 --> 00:51:36,575
0,275 275,410 410,545 545,770 770,1025
We set the one whenever
每当它被访问时，只要它被写入红色，我们就设置1。

1987
00:51:36,575 --> 00:51:37,820
0,315 315,705 705,885 885,1080 1080,1245
it's accessed, whenever it's written

1988
00:51:37,820 --> 00:51:39,620
0,320 430,735 735,1040
to a red.|
|

1989
00:51:39,900 --> 00:51:40,790
0,245 245,410 410,635 635,785 785,890
And the idea here is
这里的想法是，我们将有这个时钟，扫一扫，看看我们所有的页面。如果设置为1的位将其设置为0，如果它被设置为0，则我们继续并驱逐它。

1990
00:51:40,790 --> 00:51:42,910
0,150 150,345 345,510 510,830 1480,2120
that we'll have this clockand

1991
00:51:42,930 --> 00:51:43,835
0,365 365,575 575,725 725,815 815,905
sweep around and look at

1992
00:51:43,835 --> 00:51:45,560
0,105 105,240 240,515 1165,1515 1515,1725
all our pages. And if

1993
00:51:45,560 --> 00:51:46,510
0,120 120,315 315,525 525,675 675,950
the bit set to one

1994
00:51:46,830 --> 00:51:48,185
0,245 245,350 350,470 470,730 1110,1355
set it to zero, if

1995
00:51:48,185 --> 00:51:49,025
0,135 135,330 330,495 495,630 630,840
it is set to zero,

1996
00:51:49,025 --> 00:51:49,610
0,180 180,270 270,390 390,510 510,585
then we go ahead and

1997
00:51:49,610 --> 00:51:50,520
0,210 210,500
evict it.|
|

1998
00:51:51,220 --> 00:51:51,960
0,290 290,440 440,545 545,635 635,740
Right. So say we have
正确的。假设我们有四页，我们得到我的比特参考比特。我们设定了零。

1999
00:51:51,960 --> 00:51:53,660
0,150 150,440 940,1260 1260,1440 1440,1700
four pages, we get my

2000
00:51:53,710 --> 00:51:54,930
0,335 335,635 635,920 920,1100 1100,1220
bit reference bit. We set

2001
00:51:54,930 --> 00:51:56,200
0,135 135,410
the zero.|
|

2002
00:51:56,510 --> 00:51:58,045
0,260 260,455 455,790 960,1280 1280,1535
And then, say page one
然后，假设第一页被查询访问，我们继续并将引用位设置为1。

2003
00:51:58,045 --> 00:51:59,310
0,335 355,705 705,825 825,960 960,1265
gets accessed by a query,

2004
00:51:59,630 --> 00:52:00,370
0,275 275,440 440,560 560,635 635,740
we go ahead and set

2005
00:52:00,370 --> 00:52:01,260
0,90 90,270 270,480 480,615 615,890
the reference bit to one.|
|

2006
00:52:02,190 --> 00:52:03,250
0,245 245,350 350,560 560,815 815,1060
And then now let's say
现在让我们假设另一个查询想要一个不在缓冲池中的页面，所以我们必须决定要使用这四个中的哪一个。

2007
00:52:03,840 --> 00:52:05,465
0,305 305,545 545,850 1110,1385 1385,1625
another query wants a page

2008
00:52:05,465 --> 00:52:06,185
0,255 255,345 345,420 420,480 480,720
that's not in a buffer

2009
00:52:06,185 --> 00:52:07,085
0,245 385,615 615,690 690,780 780,900
pool, so we got to

2010
00:52:07,085 --> 00:52:08,180
0,275 385,645 645,750 750,900 900,1095
decide which of these four

2011
00:52:08,180 --> 00:52:09,560
0,135 135,225 225,650
we want toict.|
|

2012
00:52:09,560 --> 00:52:10,565
0,195 195,300 300,495 495,765 765,1005
So we go ahead and
所以我们继续前进，时钟从某个起点开始。

2013
00:52:10,565 --> 00:52:11,915
0,180 180,375 375,695 865,1155 1155,1350
the clock starts at some

2014
00:52:11,915 --> 00:52:13,240
0,240 240,575
starting point.|
|

2015
00:52:13,430 --> 00:52:14,200
0,260 260,395 395,515 515,590 590,770
It looks at the reference
它查看参考位。如果它设置为1，我们将其设置为0，然后转到这里的下一个。在第二页，参考位设置为零。因此，我们知道时钟最后一次扫视它并寻找要驱逐的页面时，它没有被碰过。

2016
00:52:14,200 --> 00:52:14,935
0,255 255,390 390,510 510,600 600,735
bit. If it's set to

2017
00:52:14,935 --> 00:52:16,090
0,275 535,810 810,930 930,1035 1035,1155
one, we set it to

2018
00:52:16,090 --> 00:52:17,365
0,260 640,900 900,1035 1035,1155 1155,1275
zero and then move on

2019
00:52:17,365 --> 00:52:18,595
0,105 105,180 180,330 330,635 955,1230
to the next one in

2020
00:52:18,595 --> 00:52:19,510
0,135 135,270 270,495 495,765 765,915
here. At page two, the

2021
00:52:19,510 --> 00:52:20,230
0,165 165,345 345,450 450,570 570,720
reference bit is set to

2022
00:52:20,230 --> 00:52:21,760
0,290 700,1005 1005,1170 1170,1305 1305,1530
zero. So therefore we know

2023
00:52:21,760 --> 00:52:22,660
0,195 195,360 360,555 555,705 705,900
the last time the clock

2024
00:52:22,660 --> 00:52:23,620
0,240 240,345 345,555 555,765 765,960
swept it around and looked

2025
00:52:23,620 --> 00:52:25,855
0,300 300,600 600,765 765,1100 1960,2235
for pages to evict, it

2026
00:52:25,855 --> 00:52:27,220
0,315 315,605
wasn't touched.|
|

2027
00:52:27,220 --> 00:52:29,005
0,315 315,680 1150,1440 1440,1605 1605,1785
So therefore, this is safe
因此，这是可以安全驱逐的。

2028
00:52:29,005 --> 00:52:30,280
0,135 135,485
to evict.|
|

2029
00:52:30,280 --> 00:52:30,880
0,180 180,270 270,330 330,450 450,600
We go ahead and remove
我们继续把它移走，用另一个取代它。

2030
00:52:30,880 --> 00:52:31,780
0,260 280,540 540,630 630,735 735,900
it, replace it with another

2031
00:52:31,780 --> 00:52:32,760
0,290
one.|
|

2032
00:52:32,760 --> 00:52:33,800
0,150 150,330 330,600 600,795 795,1040
And then say the other
然后说另一页第三页和第四页，他们访问了周围的时钟，将他们的位设置为0，然后一直到这里。然后现在我们回到第一页，它不像你最后一次看到它时那样被访问。所以我们就选这个吧。

2033
00:52:33,940 --> 00:52:35,000
0,320 320,485 485,590 590,755 755,1060
page three and four, they

2034
00:52:35,110 --> 00:52:36,770
0,580 690,950 950,1130 1130,1385 1385,1660
accessed the clock suots around,

2035
00:52:36,940 --> 00:52:38,060
0,305 305,500 500,695 695,860 860,1120
sets their bit to zero,

2036
00:52:38,590 --> 00:52:39,285
0,245 245,365 365,515 515,620 620,695
and then so far to

2037
00:52:39,285 --> 00:52:40,040
0,105 105,210 210,360 360,510 510,755
come to here. And then

2038
00:52:40,360 --> 00:52:41,130
0,260 260,410 410,500 500,605 605,770
now we're back to page

2039
00:52:41,130 --> 00:52:42,690
0,320 670,930 930,1260 1260,1485 1485,1560
one, it wasn't accessed as

2040
00:52:42,690 --> 00:52:43,260
0,90 90,195 195,330 330,435 435,570
the last time you saw

2041
00:52:43,260 --> 00:52:44,205
0,290 400,630 630,720 720,840 840,945
it. So we go ahead

2042
00:52:44,205 --> 00:52:45,560
0,105 105,240 240,390 390,665
and pick this one.|
|

2043
00:52:48,620 --> 00:52:49,405
0,260 260,365 365,440 440,605 605,785
This is a good idea
这是一个好主意，还是一个坏主意。

2044
00:52:49,405 --> 00:52:50,740
0,75 75,150 150,360 360,725
or a bad idea.|
|

2045
00:52:53,630 --> 00:52:54,840
0,290 290,515 515,740 740,920 920,1210
It seems good in that
这似乎很好，因为它允许我们拥有更少的存储空间，因为我们只需要一个比特，但缺点似乎是它将被驱逐，即使我们不需要空间。

2046
00:52:55,040 --> 00:52:57,280
0,400 750,1150 1230,1610 1610,1970 1970,2240
it allows us to have

2047
00:52:57,280 --> 00:52:58,315
0,135 135,240 240,435 435,765 765,1035
a lot less storage since

2048
00:52:58,315 --> 00:52:59,050
0,120 120,210 210,345 345,525 525,735
we only need one bit

2049
00:52:59,050 --> 00:53:00,985
0,320 460,860 880,1185 1185,1725 1725,1935
per, but the downside seems

2050
00:53:00,985 --> 00:53:02,185
0,210 210,450 450,645 645,855 855,1200
like it's going to evict,

2051
00:53:02,185 --> 00:53:03,205
0,240 240,435 435,585 585,840 840,1020
even if we don't need

2052
00:53:03,205 --> 00:53:03,800
0,195 195,485
the room.|
|

2053
00:53:04,700 --> 00:53:06,190
0,230 230,335 335,545 545,880 1140,1490
So we might have like
所以我们可能想要更少的点击量。所以，他的第一部分是正确的。第一部分说这很好，因为元数据的开销很低，因为它只是每页一位。你可以把它存储为一个连续的大的拟合向量，这很容易做到。但是你说的第二个你可能会驱逐你不应该，不应该，不应该驱逐的东西。时钟只会运行，就像你只在你需要驱逐的时候开始扫地一样。因此，它不只是一直在运行后台。是啊，我们不想这么做。

2054
00:53:06,190 --> 00:53:08,035
0,285 285,620 850,1140 1140,1430 1600,1845
fewer hits. So, so he

2055
00:53:08,035 --> 00:53:08,605
0,105 105,210 210,330 330,450 450,570
got the first part right.

2056
00:53:08,605 --> 00:53:09,880
0,120 120,225 225,390 390,695 985,1275
The first part said this

2057
00:53:09,880 --> 00:53:11,440
0,195 195,500 550,945 945,1215 1215,1560
is nice because the metadat

2058
00:53:11,440 --> 00:53:12,655
0,330 330,495 495,750 750,975 975,1215
overhead is low because it's

2059
00:53:12,655 --> 00:53:13,770
0,150 150,360 360,615 615,825 825,1115
just a bit per page.

2060
00:53:14,030 --> 00:53:14,890
0,290 290,440 440,545 545,665 665,860
You store that as a

2061
00:53:14,890 --> 00:53:16,075
0,180 180,330 330,720 720,960 960,1185
as a contiguous big fit

2062
00:53:16,075 --> 00:53:17,430
0,305 445,795 795,945 945,1110 1110,1355
vector that's easy to do.

2063
00:53:17,900 --> 00:53:18,715
0,260 260,395 395,560 560,710 710,815
But then the second one

2064
00:53:18,715 --> 00:53:19,390
0,105 105,285 285,465 465,570 570,675
you said like you might

2065
00:53:19,390 --> 00:53:20,340
0,240 240,435 435,555 555,615 615,950
evict things that you don't,

2066
00:53:20,360 --> 00:53:22,030
0,485 485,935 935,1145 1145,1430 1430,1670
shouldn't, shouldn't need evict. The

2067
00:53:22,030 --> 00:53:23,155
0,195 195,465 465,780 780,1005 1005,1125
clock only runs like you

2068
00:53:23,155 --> 00:53:24,340
0,195 195,435 435,615 615,885 885,1185
only start the, the, the

2069
00:53:24,340 --> 00:53:25,585
0,410 670,930 930,1035 1035,1140 1140,1245
sweep whenever you need to

2070
00:53:25,585 --> 00:53:26,830
0,365 715,930 930,1035 1035,1110 1110,1245
evict. So it's not just

2071
00:53:26,830 --> 00:53:27,625
0,210 210,360 360,510 510,690 690,795
running the background all the

2072
00:53:27,625 --> 00:53:29,245
0,245 595,995 1225,1455 1455,1575 1575,1620
time. Yeah, we don't want

2073
00:53:29,245 --> 00:53:30,080
0,30 30,120 120,395
to do that.|
|

2074
00:53:32,630 --> 00:53:33,920
0,400
Yes.|
是。|

2075
00:53:35,660 --> 00:53:36,940
0,230 790,1190
Frequency of.|
频率。|

2076
00:53:39,380 --> 00:53:40,405
0,320 320,500 500,665 665,875 875,1025
Yes, so he said, and
是的，他是这么说的，他说的没错。

2077
00:53:40,480 --> 00:53:42,620
0,120 120,410 1000,1400
he's correct that.|
|

2078
00:53:43,180 --> 00:53:44,400
0,320 320,515 515,665 665,890 890,1220
In case of clock and
在时钟和实际L R U的情况下，他们都有这个问题。我们没有跟踪页面被访问的频率。

2079
00:53:44,400 --> 00:53:45,195
0,225 225,330 330,465 465,645 645,795
actually L R U, they

2080
00:53:45,195 --> 00:53:46,635
0,120 120,240 240,375 375,665 1135,1440
both have this problem. We're

2081
00:53:46,635 --> 00:53:47,640
0,165 165,450 450,690 690,840 840,1005
not keeping track of the

2082
00:53:47,640 --> 00:53:50,565
0,320 430,830 2170,2475 2475,2685 2685,2925
frequency in which pages are

2083
00:53:50,565 --> 00:53:51,600
0,455
accessed.|
|

2084
00:53:52,030 --> 00:53:52,935
0,275 275,395 395,560 560,755 755,905
And so this makes them
因此，这使得他们容易受到两个问题的影响。

2085
00:53:52,935 --> 00:53:55,040
0,630 630,870 870,1020 1020,1295
susceptible to two problems.|
|

2086
00:53:55,040 --> 00:53:56,195
0,225 225,420 420,645 645,855 855,1155
So the first one is
第一个是他在这里说的，就像时钟和卢一样，我们现在只跟踪它们被访问的时间，而不是它们被访问的频率。在这两种情况下，它们也容易受到一种称为顺序洪水的问题的影响。

2087
00:53:56,195 --> 00:53:57,040
0,210 210,315 315,435 435,570 570,845
what he said down here,

2088
00:53:57,120 --> 00:53:58,475
0,400 420,695 695,905 905,1130 1130,1355
like in both clock and

2089
00:53:58,475 --> 00:53:59,675
0,315 315,495 495,630 630,915 915,1200
Lou, we're only tracking when

2090
00:53:59,675 --> 00:54:01,550
0,330 330,705 705,995 1315,1635 1635,1875
they're accessed now, not how

2091
00:54:01,550 --> 00:54:03,800
0,255 255,450 450,660 660,1130 1990,2250
often they were accessed. And

2092
00:54:03,800 --> 00:54:05,030
0,165 165,405 405,740 760,1035 1035,1230
in both cases also too,

2093
00:54:05,030 --> 00:54:06,725
0,240 240,870 870,1185 1185,1440 1440,1695
they're susceptible to a problem

2094
00:54:06,725 --> 00:54:08,780
0,365 385,900 900,1355
called sequential flooding.|
|

2095
00:54:09,280 --> 00:54:10,185
0,275 275,425 425,545 545,665 665,905
And this is the problem
这就是问题所在？

2096
00:54:10,185 --> 00:54:11,640
0,365
where?|
|

2097
00:54:11,760 --> 00:54:12,920
0,75 75,150 150,360 360,840 840,1160
If we're running sequential scans.|
如果我们在进行顺序扫描。|

2098
00:54:14,090 --> 00:54:15,085
0,260 260,425 425,575 575,755 755,995
We gotta go fetch pages
我们必须从放入缓冲池的磁盘中获取页面，但如果我们跟踪它们最后一次被使用的时间，那么我刚获得的用于顺序扫描的最后一个页面就是最近使用的页面。但对于顺序扫描，它实际上是最有用的，也是最不有用的。

2099
00:54:15,085 --> 00:54:16,345
0,225 225,630 630,780 780,1005 1005,1260
from disk put into our

2100
00:54:16,345 --> 00:54:18,190
0,270 270,545 1075,1410 1410,1605 1605,1845
buffer pool, but if we're

2101
00:54:18,190 --> 00:54:19,330
0,270 270,525 525,735 735,975 975,1140
tracking the last time they

2102
00:54:19,330 --> 00:54:21,595
0,135 135,410 940,1340 1720,1995 1995,2265
were used, the the last

2103
00:54:21,595 --> 00:54:22,810
0,345 345,570 570,735 735,975 975,1215
page I just got got

2104
00:54:22,810 --> 00:54:24,235
0,120 120,210 210,510 510,800 1120,1425
for my sequential scan is

2105
00:54:24,235 --> 00:54:25,080
0,135 135,270 270,435 435,600 600,845
the most one that's recently

2106
00:54:25,100 --> 00:54:26,545
0,400 660,920 920,1025 1025,1130 1130,1445
used. But for that sequential

2107
00:54:26,545 --> 00:54:27,805
0,180 180,465 465,780 780,1020 1020,1260
scan, it's actually the most

2108
00:54:27,805 --> 00:54:30,000
0,360 360,725 1225,1560 1560,1845 1845,2195
useful one, least useful one.|
|

2109
00:54:30,590 --> 00:54:31,360
0,260 260,380 380,515 515,650 650,770
Because it just the page
因为这只是正在阅读的那一页，我不打算回去再读一遍。

2110
00:54:31,360 --> 00:54:32,155
0,105 105,240 240,465 630,690 690,795
that is read, I'm not

2111
00:54:32,155 --> 00:54:32,620
0,90 90,135 135,210 210,330 330,465
going to go back and

2112
00:54:32,620 --> 00:54:33,940
0,135 135,285 285,560
read it again.|
|

2113
00:54:34,870 --> 00:54:36,405
0,400 810,1055 1055,1160 1160,1310 1310,1535
Right. And in some cases,
正确的。在某些情况下，对于许多工作负载，这有点像您想要最近使用的工作负载。

2114
00:54:36,405 --> 00:54:37,770
0,335 415,675 675,1020 1020,1230 1230,1365
for lot workloads, it's kind

2115
00:54:37,770 --> 00:54:38,390
0,105 105,195 195,285 285,375 375,620
of like you want the

2116
00:54:38,470 --> 00:54:40,320
0,305 305,605 605,950 950,1300
most recently used one.|
|

2117
00:54:40,410 --> 00:54:41,985
0,60 60,290 1030,1260 1260,1365 1365,1575
It's A S A gross
这是S的粗略估计，但是。

2118
00:54:41,985 --> 00:54:43,540
0,510 510,845
approximation, but.|
|

2119
00:54:44,125 --> 00:54:44,860
0,255 255,390 390,465 465,585 585,735
Another way to think about
换一种方式来考虑，对了，就像这样，我有一个查询指向一个从表中选择的星星，但我们只会得到一个ID或一条记录，并说它在第0页。

2120
00:54:44,860 --> 00:54:46,555
0,260 820,1185 1185,1455 1455,1590 1590,1695
it, right again, so like

2121
00:54:46,555 --> 00:54:47,910
0,275 625,870 870,960 960,1050 1050,1355
this, I have a query

2122
00:54:47,930 --> 00:54:48,835
0,260 260,350 350,440 440,605 605,905
went to a select star

2123
00:54:48,835 --> 00:54:50,485
0,395 475,735 735,995 1255,1500 1500,1650
from a table, but we're

2124
00:54:50,485 --> 00:54:50,995
0,105 105,225 225,285 285,375 375,510
only going to get one

2125
00:54:50,995 --> 00:54:52,630
0,275 445,720 720,870 870,1145 1375,1635
ID or one record and

2126
00:54:52,630 --> 00:54:53,910
0,135 135,330 330,560 670,975 975,1280
say that's in page zero.|
|

2127
00:54:55,020 --> 00:54:56,120
0,230 230,460 540,785 785,920 920,1100
So we go put page
所以我们把零页放在我们的，我们的缓冲池里。然后，我们的olac查询将扫描整个表并获取整个表中的所有页面。但当它到了第三页，我们就没有空间了。因此，对于这些页面，最近最少使用的页面是第0页。所以我要继续下去，把它驱逐出去。

2128
00:54:56,120 --> 00:54:57,455
0,210 210,435 435,600 600,860 1090,1335
zero in in our, in

2129
00:54:57,455 --> 00:54:58,760
0,105 105,270 270,575 895,1170 1170,1305
our buff pool. Then we

2130
00:54:58,760 --> 00:54:59,915
0,165 165,330 330,675 675,915 915,1155
have our olac query that's

2131
00:54:59,915 --> 00:55:01,145
0,75 75,240 240,575 625,960 960,1230
going to scan the entire

2132
00:55:01,145 --> 00:55:02,540
0,335 595,870 870,1035 1035,1245 1245,1395
table and go fetch all

2133
00:55:02,540 --> 00:55:03,500
0,120 120,315 315,525 525,735 735,960
the pages at the entire

2134
00:55:03,500 --> 00:55:05,825
0,290 880,1280 1870,2130 2130,2220 2220,2325
table. But when it gets

2135
00:55:05,825 --> 00:55:06,695
0,135 135,330 330,600 600,765 765,870
to page three, we don't

2136
00:55:06,695 --> 00:55:08,020
0,45 45,180 180,485 805,1065 1065,1325
have any space. So in

2137
00:55:08,580 --> 00:55:10,115
0,260 260,485 485,800 800,1150 1260,1535
for these pages here, the

2138
00:55:10,115 --> 00:55:13,205
0,275 1885,2250 2250,2565 2565,2865 2865,3090
least recently used page is

2139
00:55:13,205 --> 00:55:14,660
0,195 195,515 1045,1275 1275,1410 1410,1455
page zero. So I'm going

2140
00:55:14,660 --> 00:55:15,515
0,75 75,225 225,435 435,600 600,855
to go ahead and evict

2141
00:55:15,515 --> 00:55:16,420
0,305
that.|
|

2142
00:55:16,860 --> 00:55:17,860
0,260 260,365 365,470 470,665 665,1000
And put in page three,
放在第三页，但如果出现另一个查询，它会做第一个人做的相同的事情，得到第一页或一次，记录第一页中的一页。

2143
00:55:18,450 --> 00:55:20,480
0,400 1020,1325 1325,1565 1565,1850 1850,2030
but if another query comes

2144
00:55:20,480 --> 00:55:21,200
0,180 180,300 300,420 420,570 570,720
along, it does the same

2145
00:55:21,200 --> 00:55:22,010
0,165 165,300 300,465 465,660 660,810
thing the first guy did

2146
00:55:22,010 --> 00:55:23,165
0,135 135,330 330,585 585,855 855,1155
and goes gets page one

2147
00:55:23,165 --> 00:55:24,215
0,210 210,360 360,555 555,780 780,1050
or once once, record one

2148
00:55:24,215 --> 00:55:25,620
0,195 195,360 360,665
in page one.|
|

2149
00:55:26,005 --> 00:55:27,085
0,210 210,510 510,750 750,915 915,1080
That's actually the page I
这实际上就是我想要的页面。

2150
00:55:27,085 --> 00:55:28,240
0,275
wanted.|
|

2151
00:55:28,240 --> 00:55:29,620
0,180 180,470 970,1200 1200,1275 1275,1380
I need but I just
我需要，但我只是上瘾了。

2152
00:55:29,620 --> 00:55:30,980
0,285 285,620
addicted it.|
|

2153
00:55:31,070 --> 00:55:31,840
0,245 245,365 365,485 485,590 590,770
So this is the worst
所以这是你能做的最糟糕的事了。

2154
00:55:31,840 --> 00:55:33,740
0,320 460,720 720,840 840,1100
thing you could do.|
|

2155
00:55:34,870 --> 00:55:36,280
0,400
Right.|
正确的。|

2156
00:55:37,320 --> 00:55:38,750
0,245 245,365 365,725 725,1150 1170,1430
And so sequential flooding is
因此，顺序泛洪是一个问题，因为，如果我们执行大多数这些点查询，然后突然出现一个查询，它将摧毁我们在我们的In ouru或时钟元数据中收集的任何有用信息。

2157
00:55:38,750 --> 00:55:40,115
0,105 105,350 370,660 660,950 1090,1365
a problem because, again, if

2158
00:55:40,115 --> 00:55:41,300
0,275 535,825 825,960 960,1050 1050,1185
we do most of these

2159
00:55:41,300 --> 00:55:42,890
0,195 195,680 1090,1350 1350,1455 1455,1590
point queries and then all

2160
00:55:42,890 --> 00:55:44,080
0,195 195,450 450,735 735,915 915,1190
sudden a quer shows up,

2161
00:55:44,370 --> 00:55:45,520
0,320 320,395 395,560 560,815 815,1150
it's going to blow away

2162
00:55:45,660 --> 00:55:47,240
0,335 335,665 665,995 995,1310 1310,1580
any useful information we've collected

2163
00:55:47,240 --> 00:55:48,785
0,240 240,465 465,675 675,1275 1275,1545
in our in ouru or

2164
00:55:48,785 --> 00:55:50,580
0,335 625,1355
clock metadata.|
|

2165
00:55:52,840 --> 00:55:54,315
0,400 450,845 845,1190 1190,1370 1370,1475
So the solution to this
那么解决这个问题的办法就叫L英国吗？这里的想法是，您只需跟踪页面最近k次的访问次数。

2166
00:55:54,315 --> 00:55:55,880
0,275 535,840 840,1065 1065,1275 1275,1565
is called L U K?

2167
00:55:56,920 --> 00:55:57,825
0,305 305,515 515,680 680,800 800,905
The idea here is you

2168
00:55:57,825 --> 00:55:58,730
0,105 105,270 270,495 495,660 660,905
just keep track of the

2169
00:55:58,930 --> 00:56:00,500
0,380 380,710 710,1040 1040,1295 1295,1570
last k times a page

2170
00:56:00,520 --> 00:56:02,120
0,395 395,970
was accessed.|
|

2171
00:56:02,130 --> 00:56:02,930
0,275 275,410 410,515 515,605 605,800
And then when it comes
然后，当决定驱逐什么时，您计算上次、上次或k次访问之间的时间间隔。

2172
00:56:02,930 --> 00:56:04,505
0,330 330,710 910,1245 1245,1455 1455,1575
time to decide what to

2173
00:56:04,505 --> 00:56:07,570
0,425 1075,1380 1380,1785 1785,2105 2365,3065
evict, you compute the interval

2174
00:56:07,650 --> 00:56:09,845
0,335 335,590 590,860 860,1210 1890,2195
between the last time, last

2175
00:56:09,845 --> 00:56:11,630
0,305 415,815 1105,1395 1395,1590 1590,1785
time or the k times

2176
00:56:11,630 --> 00:56:13,020
0,120 120,300 300,830
it was accessed.|
|

2177
00:56:13,020 --> 00:56:14,265
0,330 330,630 630,855 855,1065 1065,1245
And whatever one has the
任何一个人有最大的间隔，也就是它被访问的时间，k减去1或k减去2倍这个间隔就是最大的。然后你知道它很可能在未来不会被使用，因此你可以，你可以继续并移除它。

2178
00:56:14,265 --> 00:56:16,010
0,240 240,845 985,1275 1275,1455 1455,1745
largest interval, meaning the time

2179
00:56:16,060 --> 00:56:18,555
0,260 260,520 930,1420 2010,2285 2285,2495
it was accessed, k minus

2180
00:56:18,555 --> 00:56:19,425
0,210 210,345 345,480 480,675 675,870
one or k minus two

2181
00:56:19,425 --> 00:56:21,075
0,275 835,1125 1125,1410 1410,1515 1515,1650
times that interval is the

2182
00:56:21,075 --> 00:56:22,890
0,275 295,555 555,705 705,995 1435,1815
largest. Then you know that

2183
00:56:22,890 --> 00:56:24,060
0,330 330,590 610,855 855,990 990,1170
it's likely to not be

2184
00:56:24,060 --> 00:56:25,160
0,270 270,540 540,705 705,840 840,1100
used in in the future

2185
00:56:25,720 --> 00:56:27,165
0,395 395,710 710,920 920,1205 1205,1445
and therefore you can, you

2186
00:56:27,165 --> 00:56:27,735
0,90 90,195 195,300 300,420 420,570
can go ahead and remove

2187
00:56:27,735 --> 00:56:28,500
0,275
it.|
|

2188
00:56:29,610 --> 00:56:31,210
0,260 260,515 515,1235 1235,1340 1340,1600
You think regularu is basically
你认为Regaru基本上就是英国，其中k等于1？

2189
00:56:31,640 --> 00:56:32,710
0,195 195,375 375,555 555,765 765,1070
UK, where k equals one?|
|

2190
00:56:33,820 --> 00:56:35,000
0,400
Right.|
正确的。|

2191
00:56:35,120 --> 00:56:36,940
0,400 720,1010 1010,1250 1250,1550 1550,1820
Uh, and with two or
呃，对于两个或三个或其他任何东西，大多数系统使用两个，如果你能用这个的话。他们只会记录最近两次的情况。我要说的是，这两者之间的时间是多少？我选最大的那个。

2192
00:56:36,940 --> 00:56:37,915
0,180 180,345 345,555 555,750 750,975
three or whatever, most systems

2193
00:56:37,915 --> 00:56:38,605
0,240 240,405 405,510 510,615 615,690
use two, if you can

2194
00:56:38,605 --> 00:56:39,700
0,120 120,395 505,780 780,930 930,1095
use this. They just keep

2195
00:56:39,700 --> 00:56:40,825
0,180 180,345 345,615 615,885 885,1125
track of like the last

2196
00:56:40,825 --> 00:56:41,880
0,255 255,480 480,645 645,810 810,1055
two times. And I'd say

2197
00:56:42,020 --> 00:56:42,970
0,320 320,410 410,605 605,815 815,950
what's the time between the

2198
00:56:42,970 --> 00:56:43,540
0,105 105,195 195,345 345,480 480,570
two of those? And I

2199
00:56:43,540 --> 00:56:44,380
0,135 135,255 255,495 495,735 735,840
take the one that is

2200
00:56:44,380 --> 00:56:45,500
0,105 105,350
the largest.|
|

2201
00:56:46,630 --> 00:56:48,020
0,290 290,580
And so.|
所以。|

2202
00:56:48,210 --> 00:56:49,670
0,260 260,395 395,530 530,790 870,1460
Of course, this is susceptible
当然，这很容易受到另一个问题的影响。

2203
00:56:49,670 --> 00:56:51,640
0,135 135,330 330,650 760,1160
to another problem where.|
|

2204
00:56:51,640 --> 00:56:53,410
0,320 1000,1260 1260,1455 1455,1590 1590,1770
I I fetch a page
我取了一个页面，但我还没有访问过它两次，所以间隔基本上是亲和力。

2205
00:56:53,410 --> 00:56:56,725
0,320 2020,2420 2470,2730 2730,3060 3060,3315
in and I haven't accessed

2206
00:56:56,725 --> 00:56:58,260
0,225 225,540 540,810 810,1140 1140,1535
it twice yet, so the

2207
00:56:58,790 --> 00:57:01,960
0,440 440,650 650,890 890,1480
interval is essentially affinity.|
|

2208
00:57:01,970 --> 00:57:02,785
0,275 275,425 425,545 545,665 665,815
And then it go ahead
然后它继续前进，立即被驱逐，但说这实际上是热门页面。我想把它留在记忆中，但因为我一直在驱逐它，我失去了它。我没有这方面的任何历史。

2209
00:57:02,785 --> 00:57:03,745
0,120 120,240 240,405 405,600 600,960
and get gets immediately evicted,

2210
00:57:03,745 --> 00:57:04,855
0,315 315,540 540,795 795,1005 1005,1110
but say that actually is

2211
00:57:04,855 --> 00:57:05,560
0,135 135,315 315,510 510,615 615,705
the hot page. And I

2212
00:57:05,560 --> 00:57:06,115
0,105 105,210 210,330 330,450 450,555
want to keep that in

2213
00:57:06,115 --> 00:57:07,645
0,245 835,1140 1140,1305 1305,1425 1425,1530
memory, but because I keep

2214
00:57:07,645 --> 00:57:09,150
0,405 405,525 525,720 720,1055 1105,1505
evicting it, I lose that.

2215
00:57:09,200 --> 00:57:09,955
0,245 245,365 365,425 425,545 545,755
I don't have any history

2216
00:57:09,955 --> 00:57:10,940
0,210 210,485
of it.|
|

2217
00:57:11,100 --> 00:57:11,900
0,230 230,305 305,440 440,605 605,800
So the way to solve
所以解决这个问题的方法是在内存中维护一个哈希表来跟踪，这是我在磁盘上清除的最后几个页面。这是它们被访问的时候，TIM戳，所以当我取回一个页面时，它刚刚被删除，我现在至少有它的历史，而不是假设它是无穷大的。

2218
00:57:11,900 --> 00:57:13,090
0,210 210,360 360,620 640,915 915,1190
this is that you maintain

2219
00:57:13,410 --> 00:57:15,580
0,400 1080,1340 1340,1535 1535,1880 1880,2170
a in memory hash table

2220
00:57:16,110 --> 00:57:18,395
0,400 840,1130 1130,1295 1295,1570 1920,2285
that keeps track of, here's

2221
00:57:18,395 --> 00:57:19,475
0,105 105,315 315,585 585,870 870,1080
the last couple pages that

2222
00:57:19,475 --> 00:57:21,680
0,120 120,425 1015,1415 1555,1875 1875,2205
I've evicted, uh, on disk.

2223
00:57:21,680 --> 00:57:22,655
0,105 105,330 330,560 580,885 885,975
And here's the here's when

2224
00:57:22,655 --> 00:57:23,735
0,90 90,285 285,675 675,885 885,1080
they were accessed, the Tim

2225
00:57:23,735 --> 00:57:25,040
0,305 595,840 840,990 990,1155 1155,1305
stamp, so that when I

2226
00:57:25,040 --> 00:57:26,045
0,210 210,375 375,570 570,795 795,1005
fetch a page back in

2227
00:57:26,045 --> 00:57:26,980
0,180 180,285 285,390 390,600 600,935
after it was just removed,

2228
00:57:27,180 --> 00:57:28,145
0,275 275,455 455,680 680,860 860,965
I least now have a

2229
00:57:28,145 --> 00:57:29,165
0,210 210,450 450,615 615,780 780,1020
history for it and not

2230
00:57:29,165 --> 00:57:30,380
0,255 255,390 390,675 675,960 960,1215
assume that it's that it's

2231
00:57:30,380 --> 00:57:31,360
0,560
infinity.|
|

2232
00:57:32,600 --> 00:57:33,715
0,260 260,485 485,740 740,905 905,1115
And that means that over
这意味着随着时间的推移，当您知道页面第一次被放入内存的时间时，您将能够获得计算页面正确间隔所需的信息。

2233
00:57:33,715 --> 00:57:34,885
0,335 505,990 990,1035 1035,1095 1095,1170
time, you'll be able to

2234
00:57:34,885 --> 00:57:35,970
0,210 210,465 465,615 615,780 780,1085
get information you need to

2235
00:57:36,020 --> 00:57:37,615
0,425 425,575 575,770 770,1270 1320,1595
compute the correct interval for

2236
00:57:37,615 --> 00:57:39,280
0,275 565,965 1135,1380 1380,1515 1515,1665
pages when you know when

2237
00:57:39,280 --> 00:57:39,895
0,135 135,285 285,405 405,540 540,615
the first time they're brought

2238
00:57:39,895 --> 00:57:40,900
0,105 105,365
into memory.|
|

2239
00:57:41,740 --> 00:57:43,035
0,290 290,470 470,710 710,905 905,1295
And again, it's self correcting
再一次，它是自我修正的，因为如果我把一些东西放入内存，然后再也不去取它，它就会从我的临时缓存中被删除，每当我再次需要它的时候，我就不会有那个历史了。我也不知道，我应该告诉你的。

2240
00:57:43,035 --> 00:57:43,680
0,195 195,330 330,405 405,510 510,645
because again, if I bring

2241
00:57:43,680 --> 00:57:44,415
0,135 135,255 255,435 435,600 600,735
something into memory but then

2242
00:57:44,415 --> 00:57:45,350
0,210 210,360 360,495 495,645 645,935
never go fetch it again,

2243
00:57:45,910 --> 00:57:47,025
0,380 380,545 545,830 830,1025 1025,1115
it'll get removed from my

2244
00:57:47,025 --> 00:57:50,190
0,455 985,1415 2095,2495 2755,3030 3030,3165
eemeral cache and whenever I

2245
00:57:50,190 --> 00:57:51,240
0,120 120,255 255,435 435,720 720,1050
need it again, I won't

2246
00:57:51,240 --> 00:57:52,065
0,90 90,210 210,470 490,750 750,825
have that history. And I

2247
00:57:52,065 --> 00:57:53,480
0,120 120,195 195,455 835,1080 1080,1415
don't know, I should haveict.|
|

2248
00:57:56,510 --> 00:57:57,475
0,320 320,395 395,560 560,815 815,965
It's a simple solution to
这是一个简单问题的简单解决方案。令人惊讶的是，这是直到90年代才发明的，据我所知，只有postgres和SQL服务器真正做到了这一点。

2249
00:57:57,475 --> 00:57:58,750
0,60 60,225 225,545 625,1140 1140,1275
a simple problem. Surprisingly, this

2250
00:57:58,750 --> 00:57:59,485
0,135 135,315 315,510 510,645 645,735
was not invented until the

2251
00:57:59,485 --> 00:58:02,275
0,425 2155,2430 2430,2580 2580,2700 2700,2790
nineties and as far as

2252
00:58:02,275 --> 00:58:03,190
0,75 75,150 150,270 270,465 465,915
I can tell, only postgres

2253
00:58:03,190 --> 00:58:04,165
0,210 210,465 465,660 660,855 855,975
and sql server actually do

2254
00:58:04,165 --> 00:58:05,580
0,275
this.|
|

2255
00:58:06,140 --> 00:58:07,600
0,400 870,1145 1145,1220 1220,1295 1295,1460
And this' why I like
这就是为什么我喜欢开放源码的东西，因为实际上在2002年有一篇给Postgres人的邮件列表记录帖子说，嘿，这个L英国看起来是个好主意，我们应该把它做好。

2256
00:58:07,600 --> 00:58:09,070
0,180 180,330 330,525 525,830 1090,1470
open source things, because there's

2257
00:58:09,070 --> 00:58:10,285
0,150 150,410 550,795 795,1065 1065,1215
actually the the mailing list

2258
00:58:10,285 --> 00:58:11,770
0,305 355,755 865,1095 1095,1170 1170,1485
Rec post for the postgres

2259
00:58:11,770 --> 00:58:13,825
0,290 460,795 795,1380 1380,1670 1780,2055
people in 2002 saying hey,

2260
00:58:13,825 --> 00:58:14,605
0,135 135,300 300,480 480,630 630,780
this L U K seems

2261
00:58:14,605 --> 00:58:15,310
0,105 105,195 195,360 360,555 555,705
like a good idea, we

2262
00:58:15,310 --> 00:58:17,140
0,120 120,225 225,470 490,890
should do it right.|
|

2263
00:58:17,150 --> 00:58:18,760
0,260 260,410 410,605 605,910
And they implement it.|
他们实施了这一计划。|

2264
00:58:19,880 --> 00:58:20,890
0,245 245,395 395,650 650,845 845,1010
So my sql doesn't do
所以我的SQL不能做我定义的L或英国，但他们使用了一种近似的方法，他们这样做的方式是，他们逻辑地划分L R U页面列表的链表，他们有两个不同的部分或区域，比如，年轻区域，旧区域。

2265
00:58:20,890 --> 00:58:22,240
0,315 315,570 570,690 840,1050 1050,1350
exactly l or UK as

2266
00:58:22,240 --> 00:58:23,065
0,285 285,480 480,615 615,705 705,825
I define, but they use

2267
00:58:23,065 --> 00:58:24,180
0,165 165,285 285,420 420,840 840,1115
a sort of approximate one

2268
00:58:25,010 --> 00:58:25,900
0,260 260,380 380,560 560,740 740,890
and the way they do

2269
00:58:25,900 --> 00:58:28,645
0,180 180,330 330,555 555,920 2080,2745
this is that they logically

2270
00:58:28,645 --> 00:58:30,090
0,255 255,555 555,855 855,1110 1110,1445
divide up the linked list

2271
00:58:30,230 --> 00:58:32,425
0,400 900,1300 1530,1880 1880,2075 2075,2195
for the the the L

2272
00:58:32,425 --> 00:58:33,990
0,135 135,395 415,815 955,1260 1260,1565
R U page page list

2273
00:58:35,630 --> 00:58:36,715
0,290 290,455 455,695 695,905 905,1085
and they have two different

2274
00:58:36,715 --> 00:58:37,870
0,330 330,585 585,825 825,1050 1050,1155
sections or regions they have

2275
00:58:37,870 --> 00:58:39,505
0,150 150,345 345,650 970,1365 1365,1635
like the the, the, the

2276
00:58:39,505 --> 00:58:40,650
0,195 195,465 465,660 660,825 825,1145
young region, the old region.|
|

2277
00:58:41,350 --> 00:58:42,090
0,275 275,395 395,500 500,605 605,740
And for each of these
对于这两个不同的区域，你有一个不同的头指针。

2278
00:58:42,090 --> 00:58:43,335
0,180 180,375 375,680 700,1005 1005,1245
two different regions, you have

2279
00:58:43,335 --> 00:58:45,140
0,315 315,540 540,765 765,1235
a different head pointer.|
|

2280
00:58:45,360 --> 00:58:46,595
0,400 420,665 665,770 770,1115 1115,1235
Where you would insert new
您可以在其中插入新条目。

2281
00:58:46,595 --> 00:58:47,860
0,455
entries.|
|

2282
00:58:48,120 --> 00:58:49,175
0,230 230,410 410,590 590,845 845,1055
So let's say that I
假设我有一个问题。我曾经摸过第一页，它不在我的记忆中。因此，我必须将其放入我的缓冲池中。当我想要将它添加到我的链表中时，因为第一页还不在链表中，我会将它添加到旧区域中，并将其插入到头指针所在的位置。因此，它将驱逐第八页，并将第一页放在那里。

2283
00:58:49,175 --> 00:58:50,165
0,275 295,570 570,765 765,900 900,990
have a query. I once

2284
00:58:50,165 --> 00:58:51,440
0,90 90,225 225,435 435,755 955,1275
to touch page one, it's

2285
00:58:51,440 --> 00:58:52,330
0,105 105,225 225,420 420,630 630,890
not in memory I got.

2286
00:58:52,410 --> 00:58:53,405
0,230 230,460 630,860 860,920 920,995
So I therefore I have

2287
00:58:53,405 --> 00:58:54,095
0,105 105,210 210,285 285,450 450,690
to put it into my

2288
00:58:54,095 --> 00:58:55,670
0,300 300,575 1105,1380 1380,1485 1485,1575
buffer pool. And when I

2289
00:58:55,670 --> 00:58:56,285
0,90 90,150 150,300 300,495 495,615
want to add it to

2290
00:58:56,285 --> 00:58:58,240
0,150 150,345 345,525 525,815 1555,1955
my linked list here, because

2291
00:58:58,560 --> 00:58:59,525
0,305 305,455 455,560 560,725 725,965
page one is not already

2292
00:58:59,525 --> 00:59:00,950
0,195 195,315 315,495 495,815 1105,1425
in the linked list, I'm

2293
00:59:00,950 --> 00:59:01,690
0,75 75,150 150,285 285,465 465,740
going to add it to

2294
00:59:01,740 --> 00:59:03,575
0,275 275,500 500,850 1350,1580 1580,1835
the old region and I'll

2295
00:59:03,575 --> 00:59:05,045
0,435 435,675 675,900 900,1170 1170,1470
insert it where the head

2296
00:59:05,045 --> 00:59:06,995
0,270 270,515 865,1125 1125,1385 1675,1950
pointer is. So it will

2297
00:59:06,995 --> 00:59:08,645
0,345 345,585 585,905 1195,1470 1470,1650
evict page eight and put

2298
00:59:08,645 --> 00:59:09,980
0,210 210,420 420,725
page one there.|
|

2299
00:59:11,340 --> 00:59:14,330
0,365 365,730 2160,2525 2525,2810 2810,2990
Now if if page one
现在，如果第一页再也不被访问，它将缓慢地到达链表的末尾，然后被逐出。

2300
00:59:14,330 --> 00:59:15,590
0,120 120,360 360,690 690,930 930,1260
is never accessed again, it'll

2301
00:59:15,590 --> 00:59:16,355
0,180 180,345 345,465 465,630 630,765
slowly make its way to

2302
00:59:16,355 --> 00:59:17,465
0,105 105,315 315,630 630,930 930,1110
the end of the the

2303
00:59:17,465 --> 00:59:19,655
0,135 135,425 715,1115 1375,1775 1945,2190
linked list and then get

2304
00:59:19,655 --> 00:59:20,680
0,335
evicted.|
|

2305
00:59:21,130 --> 00:59:22,230
0,230 230,320 320,500 500,920 920,1100
But if say, Q2 comes
但如果Q2出现了，它又一次触及了第一页。

2306
00:59:22,230 --> 00:59:22,995
0,165 165,270 270,360 360,600 600,765
along and it touches page

2307
00:59:22,995 --> 00:59:24,360
0,210 210,515
one again.|
|

2308
00:59:24,360 --> 00:59:25,680
0,315 315,710 790,1080 1080,1200 1200,1320
We would identify that it
我们会发现它已经存在于我的My链接列表中，并且位于旧区域中，因此我将把它放在年轻列表的首位。

2309
00:59:25,680 --> 00:59:27,560
0,270 270,650 700,990 990,1280 1480,1880
already exists in my my

2310
00:59:28,360 --> 00:59:29,730
0,290 290,580 750,1010 1010,1220 1220,1370
linked list and it's in

2311
00:59:29,730 --> 00:59:32,310
0,165 165,440 970,1370 2050,2385 2385,2580
the old region, so therefore

2312
00:59:32,310 --> 00:59:33,225
0,165 165,255 255,375 375,645 645,915
I'll put it at the

2313
00:59:33,225 --> 00:59:34,070
0,150 150,270 270,375 375,540 540,845
head of the young list.|
|

2314
00:59:34,780 --> 00:59:36,085
0,240 240,390 390,650 700,1080 1080,1305
Right, and then slide everyone
对，然后把所有人都推出去。

2315
00:59:36,085 --> 00:59:36,980
0,245
out.|
|

2316
00:59:37,970 --> 00:59:38,965
0,245 245,335 335,530 530,845 845,995
So again, it's approximate L
所以，这又是近似的L英国，因为我并没有真正跟踪，比如，它被访问的时间间隔。但只要知道它是在年轻人和老年人之间的界限，我就知道它很可能是最近才被访问的。

2317
00:59:38,965 --> 00:59:39,745
0,180 180,360 360,510 510,660 660,780
U K because I'm not

2318
00:59:39,745 --> 00:59:40,690
0,225 225,450 450,630 630,765 765,945
really keeping track of like

2319
00:59:40,690 --> 00:59:42,190
0,320 400,645 645,990 990,1260 1260,1500
the the intervals between when

2320
00:59:42,190 --> 00:59:43,380
0,135 135,210 210,375 375,810 810,1190
when it was accessed before.

2321
00:59:44,060 --> 00:59:45,190
0,275 275,470 470,725 725,920 920,1130
But just knowing that it's

2322
00:59:45,190 --> 00:59:46,495
0,225 225,450 450,960 960,1185 1185,1305
within this boundary of the

2323
00:59:46,495 --> 00:59:47,335
0,120 120,315 315,570 570,735 735,840
young versus old that I

2324
00:59:47,335 --> 00:59:50,185
0,150 150,360 360,635 2455,2715 2715,2850
know it's like it was

2325
00:59:50,185 --> 00:59:51,810
0,225 225,575 685,1005 1005,1245 1245,1625
most likely accessed more recently.|
|

2326
00:59:53,110 --> 00:59:54,720
0,365 365,620 620,910 1110,1370 1370,1610
Whereas over here, you haven't
而在这里，你以前从未见过它。

2327
00:59:54,720 --> 00:59:55,860
0,105 105,195 195,440
seen it before.|
|

2328
00:59:55,860 --> 00:59:57,410
0,320 670,975 975,1080 1080,1245 1245,1550
You haven't seen before it
在它被添加到列表之前，你还没有看到过。

2329
00:59:57,460 --> 00:59:58,910
0,275 275,550 900,1145 1145,1220 1220,1450
was added to the list.|
|

2330
01:00:04,630 --> 01:00:06,540
0,400
So.|
所以。|

2331
01:00:08,570 --> 01:00:09,790
0,245 245,335 335,485 485,790 930,1220
I would say also, going
我还要说，回到L K，你还可以做很多其他的优化。

2332
01:00:09,790 --> 01:00:10,680
0,150 150,240 240,315 315,525 525,890
back to the L K,

2333
01:00:10,730 --> 01:00:11,755
0,320 320,470 470,680 680,815 815,1025
there's a bunch of other

2334
01:00:11,755 --> 01:00:14,920
0,465 465,705 705,870 870,1175
optimizations you can do.|
|

2335
01:00:15,170 --> 01:00:16,210
0,320 320,620 620,755 755,920 920,1040
That sql server does, but
SQL服务器可以，但我不认为postgres可以跟踪时间？多么。

2336
01:00:16,210 --> 01:00:17,130
0,60 60,180 180,300 300,645 645,920
I don't think postgres does

2337
01:00:17,450 --> 01:00:19,435
0,400 870,1145 1145,1385 1385,1700 1700,1985
where you can keep track

2338
01:00:19,435 --> 01:00:22,340
0,335 475,875 1555,1955
of when? How.|
|

2339
01:00:22,470 --> 01:00:23,765
0,335 335,545 545,815 815,1190 1190,1295
Of who is accessing or
谁正在访问或引用页面，然后可以确定您是否会，您可能会说，访问计入不同的引用，因此应该更新时间间隔。举个例子，如果我在同一个事务中有两个不同的查询，访问相同的页面，那么这两个查询在同一个事务中，因此它们应该被认为是不同的吗？

2340
01:00:23,765 --> 01:00:25,565
0,375 375,510 510,785 1375,1650 1650,1800
referencing a page and then

2341
01:00:25,565 --> 01:00:27,575
0,180 180,435 435,785 1285,1665 1665,2010
that can determine whether you

2342
01:00:27,575 --> 01:00:29,240
0,300 300,495 495,690 690,1025 1285,1665
would, you would say an

2343
01:00:29,240 --> 01:00:30,515
0,285 285,600 600,720 720,960 960,1275
access counts for a distinct

2344
01:00:30,515 --> 01:00:32,000
0,335 535,855 855,1020 1020,1215 1215,1485
reference and therefore should update

2345
01:00:32,000 --> 01:00:33,395
0,180 180,590 820,1050 1050,1185 1185,1395
the interval. So an example

2346
01:00:33,395 --> 01:00:35,140
0,165 165,425 775,1140 1140,1425 1425,1745
would be if I have

2347
01:00:35,400 --> 01:00:38,135
0,335 335,560 560,830 830,1210 2400,2735
within the same transaction two

2348
01:00:38,135 --> 01:00:39,710
0,285 285,815 925,1200 1200,1350 1350,1575
separate queries, access the same

2349
01:00:39,710 --> 01:00:41,480
0,350 1030,1290 1290,1560 1560,1650 1650,1770
page, well that's in the

2350
01:00:41,480 --> 01:00:43,475
0,180 180,500 730,1080 1080,1430 1750,1995
same transaction, so therefore should

2351
01:00:43,475 --> 01:00:45,220
0,150 150,360 360,660 660,1055
they be considered distinct?|
|

2352
01:00:45,230 --> 01:00:46,620
0,260 260,520
Or not.|
或者不去。|

2353
01:00:46,740 --> 01:00:48,040
0,275 275,485 485,695 695,965 965,1300
If there's two separate transactions,
如果有两个独立的事务，那么这个页面很可能是热门的，因为有一堆事务在访问它，我想是这样的。

2354
01:00:48,270 --> 01:00:49,580
0,395 395,725 725,890 890,1115 1115,1310
then it's very likely this

2355
01:00:49,580 --> 01:00:50,585
0,195 195,405 405,645 645,870 870,1005
page is hot because a

2356
01:00:50,585 --> 01:00:51,680
0,105 105,240 240,480 480,765 765,1095
bunch of transactions are accessing

2357
01:00:51,680 --> 01:00:52,750
0,260 370,615 615,720 720,825 825,1070
it, I think of like.|
|

2358
01:00:55,190 --> 01:00:56,455
0,290 290,455 455,605 605,880 930,1265
If you log into Amazon
如果你登录亚马逊，更新你的账户信息，不管出于什么原因，这笔交易都会更新你的记录两次，嗯，这是在同一笔交易中完成的，这是考虑两次访问还是一次访问？

2359
01:00:56,455 --> 01:00:57,865
0,195 195,315 315,510 510,845 1165,1410
and you go update, you

2360
01:00:57,865 --> 01:00:59,190
0,165 165,450 450,720 720,975 975,1325
know, your, your account information

2361
01:00:59,570 --> 01:01:00,955
0,320 320,640 810,1115 1115,1265 1265,1385
and say for whatever reason

2362
01:01:00,955 --> 01:01:02,665
0,165 165,455 595,945 945,1295 1315,1710
that transaction updates your record

2363
01:01:02,665 --> 01:01:04,090
0,395 745,1005 1005,1230 1230,1335 1335,1425
twice, well, that's done in

2364
01:01:04,090 --> 01:01:05,140
0,90 90,255 255,560 580,840 840,1050
the same transaction, is that

2365
01:01:05,140 --> 01:01:06,750
0,270 270,590 730,1140 1140,1320 1320,1610
consider two accesses or one?|
|

2366
01:01:07,880 --> 01:01:09,010
0,230 230,350 350,605 605,815 995,1130
And in sql server, they'll
在SQL服务器中，他们会考虑这一点。

2367
01:01:09,010 --> 01:01:10,540
0,195 195,390 390,710
consider that one.|
|

2368
01:01:10,540 --> 01:01:11,650
0,255 255,375 375,510 510,885 885,1110
I think in postgres they
我认为在波斯格雷斯，他们也考虑到了这一点。

2369
01:01:11,650 --> 01:01:13,160
0,210 210,450 450,800
consider that, too.|
|

2370
01:01:14,660 --> 01:01:16,270
0,400 630,1030 1200,1460 1460,1550 1550,1610
Right. Again, you know, a
正确的。再一次，你知道，一大堆奇特的东西，因为你知道数据系统是如何访问页面的。

2371
01:01:16,270 --> 01:01:17,005
0,105 105,225 225,390 390,600 600,735
bunch of fancy things because

2372
01:01:17,005 --> 01:01:20,470
0,150 150,405 405,755 3055,3315 3315,3465
you know how the data

2373
01:01:20,470 --> 01:01:22,440
0,180 180,405 405,840 840,1220
system is accessing pages.|
|

2374
01:01:27,370 --> 01:01:28,350
0,305 305,365 365,470 470,665 665,980
There's a bunch of policies
有一堆政策你可以用来做决定。

2375
01:01:28,350 --> 01:01:29,510
0,225 225,360 360,585 585,765 765,1160
you can do for deciding.|
|

2376
01:01:31,710 --> 01:01:32,680
0,275 275,425 425,545 545,680 680,970
To relate to this like.|
像这样联系在一起。|

2377
01:01:33,940 --> 01:01:35,235
0,245 245,335 335,515 515,910 930,1295
For a given query, what
对于给定的查询，如果这与相关，我应该喜欢哪个页面？

2378
01:01:35,235 --> 01:01:38,330
0,285 285,450 615,935 2395,2745 2745,3095
page should I've like if

2379
01:01:38,710 --> 01:01:39,950
0,260 260,485 485,785 785,980 980,1240
this is related to the

2380
01:01:40,000 --> 01:01:41,600
0,400
the?|
|

2381
01:01:41,960 --> 01:01:43,195
0,400 450,680 680,815 815,995 995,1235
The sort of the private
在一些系统中，你可以说，好的，这是一种私人现金。

2382
01:01:43,195 --> 01:01:44,920
0,365 655,930 930,1205 1285,1560 1560,1725
cash like in, in some

2383
01:01:44,920 --> 01:01:45,790
0,225 225,405 405,510 510,705 705,870
systems, you can say, all

2384
01:01:45,790 --> 01:01:47,880
0,230 550,1035 1035,1310
right, here's a.|
|

2385
01:01:47,950 --> 01:01:50,000
0,350 350,920 920,1130 1130,1420 1650,2050
Some subset of the pages
我创建的页面的某个子集，它们由缓冲池支持。

2386
01:01:50,680 --> 01:01:51,945
0,305 305,440 440,920 920,1100 1100,1265
that I Ming, they're being

2387
01:01:51,945 --> 01:01:53,090
0,345 345,480 480,600 600,870 870,1145
backed by the buffer pool.|
|

2388
01:01:53,820 --> 01:01:54,885
0,260 370,600 600,735 735,885 885,1065
Right, but I'm keeping track
对，但我在追踪我访问的是哪几个。然后我可以给水牛经理一个提示，如果你没有更多的空间，这是我知道我正在访问的页面，我不再需要它们了。因此，你可以继续驱逐他们。现在，DAT是否决定问题，是否驱逐他们，取决于执行情况。

2389
01:01:54,885 --> 01:01:56,150
0,120 120,240 240,420 420,780 780,1265
of which ones I'm accessing.

2390
01:01:56,440 --> 01:01:57,210
0,260 260,380 380,500 500,635 635,770
So then I can give

2391
01:01:57,210 --> 01:01:58,200
0,150 150,435 435,645 645,735 735,990
a hint to the buffalo

2392
01:01:58,200 --> 01:01:59,985
0,255 255,650 1360,1605 1605,1680 1680,1785
manager say if you don't

2393
01:01:59,985 --> 01:02:00,825
0,45 45,120 120,270 270,540 540,840
have any more space, here's

2394
01:02:00,825 --> 01:02:01,755
0,90 90,270 270,465 465,645 645,930
the pages where I know

2395
01:02:01,755 --> 01:02:04,185
0,510 510,935 1885,2130 2130,2235 2235,2430
I'm accessing and I don't

2396
01:02:04,185 --> 01:02:05,445
0,105 105,255 255,545 865,1140 1140,1260
need them again. Therefore, you

2397
01:02:05,445 --> 01:02:06,240
0,120 120,270 270,420 420,555 555,795
can go ahead and evict

2398
01:02:06,240 --> 01:02:07,515
0,290 580,870 870,1035 1035,1155 1155,1275
them. Now, whether or not

2399
01:02:07,515 --> 01:02:09,720
0,120 120,330 330,815 1585,1920 1920,2205
the dat decides issue, evict

2400
01:02:09,720 --> 01:02:10,995
0,105 105,195 195,440 730,1065 1065,1275
them or not, depends on

2401
01:02:10,995 --> 01:02:12,440
0,180 180,485
the implementation.|
|

2402
01:02:14,740 --> 01:02:15,795
0,215 215,320 320,455 455,680 680,1055
You can also maintain priority
您还可以维护有关页面类型或您知道该页面代表EM的对象的优先级提示。然后这个信息被提供给数据系统，你知道的，水牛管理者决定是否应该驱逐一些东西。

2403
01:02:15,795 --> 01:02:17,880
0,465 465,785 1405,1695 1695,1890 1890,2085
hints about what the type

2404
01:02:17,880 --> 01:02:19,860
0,195 195,500 1210,1610 1660,1890 1890,1980
of page or you know

2405
01:02:19,860 --> 01:02:20,790
0,135 135,390 390,630 630,765 765,930
what the object that page

2406
01:02:20,790 --> 01:02:23,505
0,290 1060,1460 1900,2190 2190,2445 2445,2715
represents EM. And then this

2407
01:02:23,505 --> 01:02:24,390
0,285 285,570 570,705 705,765 765,885
is provided to the data

2408
01:02:24,390 --> 01:02:25,290
0,180 180,330 330,525 525,690 690,900
system to say, you know,

2409
01:02:25,290 --> 01:02:26,565
0,225 225,435 435,680 700,1035 1035,1275
the buffalo manager whether something

2410
01:02:26,565 --> 01:02:27,290
0,135 135,180 180,405 405,480 480,725
should be evicted or not.|
|

2411
01:02:27,910 --> 01:02:29,805
0,400 780,1130 1130,1445 1445,1715 1715,1895
So the classic example would
所以经典的例子是，如果我有一串页面的索引，并且任何查询总是插入新的记录，而这些记录只是增加了索引所基于的大小，那么我知道我将总是命中树的右侧，因此我可能希望将这些页面保留在内存中。我不在乎第二页会不会被赶走，因为我主要会更新第六页的内容。

2412
01:02:29,805 --> 01:02:30,480
0,165 165,300 300,405 405,510 510,675
be if I have an

2413
01:02:30,480 --> 01:02:31,845
0,320 820,1050 1050,1125 1125,1230 1230,1365
index of a bunch of

2414
01:02:31,845 --> 01:02:34,890
0,275 1735,2135 2275,2565 2565,2880 2880,3045
pages and any queries that

2415
01:02:34,890 --> 01:02:35,990
0,195 195,300 300,660 660,810 810,1100
always be inserting new records

2416
01:02:36,640 --> 01:02:38,265
0,365 365,605 605,880 1080,1415 1415,1625
that are just increasing the

2417
01:02:38,265 --> 01:02:40,425
0,225 225,525 525,810 810,1145 1855,2160
size of the, the, the

2418
01:02:40,425 --> 01:02:42,345
0,300 300,570 570,845 1015,1415 1645,1920
data or the value that

2419
01:02:42,345 --> 01:02:43,340
0,180 180,345 345,480 480,675 675,995
the index is based on,

2420
01:02:43,660 --> 01:02:44,745
0,365 365,635 635,815 815,995 995,1085
then I know I'm gonna

2421
01:02:44,745 --> 01:02:46,520
0,165 165,360 360,585 585,935 1375,1775
be always hitting the, the,

2422
01:02:46,570 --> 01:02:47,415
0,275 275,455 455,620 620,710 710,845
the right side of the

2423
01:02:47,415 --> 01:02:49,185
0,305 715,1095 1095,1425 1425,1650 1650,1770
tree and therefore maybe I

2424
01:02:49,185 --> 01:02:50,370
0,120 120,300 300,605 625,975 975,1185
wanna keep those pages in

2425
01:02:50,370 --> 01:02:51,615
0,260 490,750 750,870 870,1110 1110,1245
memory. And I don't care

2426
01:02:51,615 --> 01:02:52,785
0,240 240,570 570,870 870,1050 1050,1170
if if page two over

2427
01:02:52,785 --> 01:02:54,200
0,165 165,360 360,540 540,935 1015,1415
here gets gets evicted because

2428
01:02:54,490 --> 01:02:55,605
0,335 335,500 500,665 665,815 815,1115
I'm mostly gonna be updating

2429
01:02:55,605 --> 01:02:56,840
0,195 195,450 450,690 690,915 915,1235
things on on page six.|
|

2430
01:02:57,410 --> 01:02:58,700
0,400
Right.|
正确的。|

2431
01:02:59,490 --> 01:03:00,740
0,245 245,590 590,740 740,1000 1020,1250
Or likewise, if I do
或者类似地，如果我执行一系列必须使用索引的SELECT查询，那么，我知道他们总是要访问的第一件事是索引中的根页面。因此，这应该得到比其他国家更高的优先地位。

2432
01:03:00,740 --> 01:03:02,080
0,75 75,180 180,440 580,870 870,1340
a bunch of select queries

2433
01:03:02,880 --> 01:03:03,530
0,230 230,305 305,410 410,515 515,650
that I have to use

2434
01:03:03,530 --> 01:03:04,930
0,165 165,440 670,900 900,1065 1065,1400
the index, well, I know

2435
01:03:04,950 --> 01:03:06,680
0,400 690,1025 1025,1265 1265,1505 1505,1730
the, the, the very first

2436
01:03:06,680 --> 01:03:07,415
0,150 150,345 345,480 480,570 570,735
thing they're always going to

2437
01:03:07,415 --> 01:03:08,270
0,210 210,360 360,495 495,660 660,855
access is the root page

2438
01:03:08,270 --> 01:03:09,710
0,135 135,285 285,590 940,1245 1245,1440
in the index. So therefore

2439
01:03:09,710 --> 01:03:10,460
0,195 195,330 330,405 405,540 540,750
that should be given higher

2440
01:03:10,460 --> 01:03:13,000
0,320 850,1250 1270,1575 1575,1880
priority than other ones.|
|

2441
01:03:13,100 --> 01:03:14,140
0,275 275,515 515,785 785,950 950,1040
Now, these seem kind of
现在，这些看起来像是像L或K或其他机制的创可贴，它们是一种，对吗？所以这就像是把它想象成一个灯针，或者说，嘿，你真的不应该驱逐这个，但如果你必须这样做，是的，你可以。但是，你知道，请不要这样做。

2442
01:03:14,140 --> 01:03:15,790
0,150 150,420 420,765 765,1040 1330,1650
like band AIDS over like

2443
01:03:15,790 --> 01:03:16,825
0,165 165,285 285,450 450,735 735,1035
L R U K or

2444
01:03:16,825 --> 01:03:18,865
0,240 240,495 495,1115 1645,1905 1905,2040
or other mechanisms and they

2445
01:03:18,865 --> 01:03:20,875
0,150 150,285 285,545 985,1385 1735,2010
kind of are, right? And

2446
01:03:20,875 --> 01:03:21,715
0,135 135,315 315,510 510,735 735,840
so it's like think of

2447
01:03:21,715 --> 01:03:22,750
0,120 120,270 270,450 450,735 735,1035
like as a light pin

2448
01:03:22,750 --> 01:03:24,760
0,320 670,1050 1050,1290 1290,1550 1750,2010
or to tell this, hey,

2449
01:03:24,760 --> 01:03:25,675
0,120 120,315 315,540 540,720 720,915
you really probably shouldn't evict

2450
01:03:25,675 --> 01:03:26,335
0,150 150,270 270,345 345,450 450,660
this, but if you have

2451
01:03:26,335 --> 01:03:28,170
0,210 210,390 390,585 585,875 1435,1835
to, yes you can. But

2452
01:03:28,490 --> 01:03:29,790
0,365 365,560 560,665 665,860 860,1300
please, you know, please don't.|
|

2453
01:03:31,290 --> 01:03:32,870
0,260 260,520 750,1085 1085,1280 1280,1580
But again, there's just additional
但再说一次，除了u跟踪之外，系统已经在做其他事情了。

2454
01:03:32,870 --> 01:03:35,030
0,380 580,980 1270,1650 1650,1920 1920,2160
things beyond the u tracking

2455
01:03:35,030 --> 01:03:35,765
0,195 195,300 300,435 435,570 570,735
that the system is already

2456
01:03:35,765 --> 01:03:36,840
0,305
doing.|
|

2457
01:03:38,650 --> 01:03:39,825
0,245 245,410 410,680 680,980 980,1175
The big challenge, though, when
然而，当涉及到受害者页面时，最大的挑战是它们是否肮脏。

2458
01:03:39,825 --> 01:03:40,700
0,90 90,225 225,360 360,540 540,875
it comes to victim pages

2459
01:03:40,750 --> 01:03:41,835
0,275 275,470 470,740 740,920 920,1085
is whether they're dirty or

2460
01:03:41,835 --> 01:03:42,800
0,245
not.|
|

2461
01:03:43,050 --> 01:03:44,150
0,260 260,395 395,815 815,965 965,1100
So the easiest thing to
因此，最简单的做法是如果我所有的页面都是干净的。

2462
01:03:44,150 --> 01:03:45,035
0,135 135,300 300,465 465,660 660,885
do is if all my

2463
01:03:45,035 --> 01:03:46,760
0,300 300,615 615,935
pages are clean.|
|

2464
01:03:47,340 --> 01:03:48,365
0,305 305,665 665,830 830,935 935,1025
To evict them from the
把它们赶出水牛就是。

2465
01:03:48,365 --> 01:03:49,680
0,285 285,545
buffalo is.|
|

2466
01:03:49,680 --> 01:03:50,690
0,195 195,300 300,540 540,765 765,1010
To do nothing, you just
如果什么都不做，只需将页面引用放在页表中。您需要覆盖以前存在的任何内容。

2467
01:03:50,740 --> 01:03:52,230
0,305 305,610 750,1055 1055,1310 1310,1490
drop the page reference in

2468
01:03:52,230 --> 01:03:53,490
0,75 75,225 225,530 910,1155 1155,1260
the page table. You need

2469
01:03:53,490 --> 01:03:54,360
0,105 105,495 495,660 660,750 750,870
to overwrite whatever was there

2470
01:03:54,360 --> 01:03:55,380
0,260
before.|
|

2471
01:03:55,420 --> 01:03:56,385
0,380 380,620 620,725 815,890 890,965
Right, because you don't need
对，因为您不需要将其刷新回磁盘。

2472
01:03:56,385 --> 01:03:57,105
0,150 150,330 330,435 435,585 585,720
to flush it back to

2473
01:03:57,105 --> 01:03:58,160
0,485
disk.|
|

2474
01:03:58,770 --> 01:04:00,740
0,350 350,700 1020,1415 1415,1760 1760,1970
If, though, if all the
但是，如果所有的页面都是脏的，或者你想要驱逐的那一页是脏的，那么你必须把它写到磁盘上，确保它是耐用的和安全的，我们将在本学期晚些时候讨论这一点，然后你可以继续说，好的，这个框架现在是免费的，你可以继续并重新使用它。

2475
01:04:00,740 --> 01:04:02,195
0,180 180,360 360,620 1090,1350 1350,1455
pages are dirty or the

2476
01:04:02,195 --> 01:04:02,930
0,105 105,210 210,285 285,555 555,735
one you want evict is

2477
01:04:02,930 --> 01:04:04,340
0,290 790,1065 1065,1200 1200,1305 1305,1410
dirty, then you got to

2478
01:04:04,340 --> 01:04:05,795
0,150 150,330 330,525 525,1130 1150,1455
write that to disk, make

2479
01:04:05,795 --> 01:04:07,520
0,135 135,360 360,965 1045,1395 1395,1725
sure it's durable and safe,

2480
01:04:07,520 --> 01:04:08,330
0,255 255,390 390,555 555,720 720,810
which we cover later in

2481
01:04:08,330 --> 01:04:09,800
0,60 60,350 670,1070 1150,1380 1380,1470
the semester before you can

2482
01:04:09,800 --> 01:04:11,060
0,180 180,480 480,780 780,1035 1035,1260
go ahead and say, okay,

2483
01:04:11,060 --> 01:04:12,460
0,290 400,690 690,840 840,1050 1050,1400
this frame is now free,

2484
01:04:12,960 --> 01:04:13,715
0,230 230,320 320,470 470,620 620,755
you can go ahead and

2485
01:04:13,715 --> 01:04:15,460
0,275 355,795 795,1085
and reuse it.|
|

2486
01:04:16,310 --> 01:04:17,470
0,365 365,500 500,635 635,905 905,1160
It's actually more complicated than
它实际上比这复杂得多，因为您实际上必须确保日志记录首先被刷新到磁盘，然后才能刷新日志引用所述的脏页。

2487
01:04:17,470 --> 01:04:18,385
0,180 180,465 465,720 720,840 840,915
that because you actually have

2488
01:04:18,385 --> 01:04:19,330
0,105 105,315 315,525 525,675 675,945
to write sure the log

2489
01:04:19,330 --> 01:04:20,515
0,300 300,525 525,765 765,885 885,1185
record is flushed to disk

2490
01:04:20,515 --> 01:04:22,045
0,275 625,1005 1005,1230 1230,1350 1350,1530
first before you can flush

2491
01:04:22,045 --> 01:04:22,960
0,135 135,315 315,615 615,825 825,915
the dirty page that the

2492
01:04:22,960 --> 01:04:25,360
0,150 150,440 1090,1425 1425,1760
log reference talks about.|
|

2493
01:04:25,610 --> 01:04:26,580
0,260 260,380 380,530 530,695 695,970
We will cover that later.
我们将在稍后讨论这一点。因此，这很难做到的原因是，考虑到我们刚刚谈到的所有事情，这些优先顺序的暗示，不同的政策，英国的东西，情况可能就是这样。可能的情况是，您要驱逐的页面是脏的。

2494
01:04:27,470 --> 01:04:28,390
0,305 305,455 455,605 605,785 785,920
So the reason why this

2495
01:04:28,390 --> 01:04:29,050
0,105 105,300 300,375 375,480 480,660
is tricky to do is

2496
01:04:29,050 --> 01:04:29,920
0,225 225,405 405,570 570,720 720,870
because it may be the

2497
01:04:29,920 --> 01:04:30,850
0,225 225,450 450,660 660,825 825,930
case given all the things

2498
01:04:30,850 --> 01:04:31,450
0,90 90,180 180,330 330,465 465,600
we just talked about, these

2499
01:04:31,450 --> 01:04:33,180
0,285 285,860 970,1215 1215,1395 1395,1730
priority hints, the different policies,

2500
01:04:33,770 --> 01:04:35,890
0,400 1020,1310 1310,1600 1710,1970 1970,2120
the UK stuff. It may

2501
01:04:35,890 --> 01:04:36,925
0,150 150,300 300,525 525,750 750,1035
be the case that the

2502
01:04:36,925 --> 01:04:38,100
0,345 345,555 555,690 690,780 780,1175
page you want to evict

2503
01:04:38,690 --> 01:04:40,220
0,350 350,700
is dirty.|
|

2504
01:04:40,530 --> 01:04:41,360
0,260 260,350 350,530 530,740 740,830
And so that is going
因此，这将需要，您知道，磁盘刷新，但可能第二次。

2505
01:04:41,360 --> 01:04:42,830
0,120 120,410 790,1050 1050,1260 1260,1470
to require, you know, a

2506
01:04:42,830 --> 01:04:44,555
0,270 270,590 1150,1395 1395,1530 1530,1725
disk flush, but maybe the

2507
01:04:44,555 --> 01:04:45,680
0,305
second.|
|

2508
01:04:46,110 --> 01:04:47,045
0,260 260,455 455,680 680,830 830,935
The second page you could
你本可以拥有的第二页是干净的。

2509
01:04:47,045 --> 01:04:48,640
0,105 105,285 285,525 525,845
have ve is clean.|
|

2510
01:04:49,220 --> 01:04:50,740
0,305 305,470 470,730 960,1430 1430,1520
So should you violate the
那么，在这种情况下，你是否应该违反L或英国的规定，因为你试图尽快把事情弄清楚。

2511
01:04:50,740 --> 01:04:51,550
0,75 75,180 315,510 510,675 675,810
l or UK in that

2512
01:04:51,550 --> 01:04:52,960
0,240 240,590 880,1230 1230,1335 1335,1410
case because you're trying to

2513
01:04:52,960 --> 01:04:53,545
0,90 90,210 210,345 345,465 465,585
get things out as fast

2514
01:04:53,545 --> 01:04:55,140
0,165 165,455
as possible.|
|

2515
01:04:55,140 --> 01:04:56,100
0,260
Right.|
正确的。|

2516
01:04:56,920 --> 01:04:58,035
0,320 320,575 575,755 755,905 905,1115
Different systems do different things.
不同的系统做不同的事情。这就是为什么企业系统比开源系统要好得多，因为他们有所有这些元数据，他们有所有这些复杂的算法来做出这些决定，因为这实际上取决于硬件的速度。

2517
01:04:58,035 --> 01:04:58,815
0,150 150,255 255,390 390,555 555,780
And this is why the

2518
01:04:58,815 --> 01:04:59,685
0,225 225,435 435,600 600,720 720,870
enterprise systems are much better

2519
01:04:59,685 --> 01:05:00,450
0,120 120,285 285,465 465,615 615,765
than the, than the open

2520
01:05:00,450 --> 01:05:01,845
0,135 135,405 405,800 820,1140 1140,1395
source systems, because they have

2521
01:05:01,845 --> 01:05:02,835
0,210 210,360 360,705 705,840 840,990
all this metada they have

2522
01:05:02,835 --> 01:05:04,080
0,135 135,255 255,720 720,1005 1005,1245
all these sophisticated algorithms to

2523
01:05:04,080 --> 01:05:05,940
0,270 270,510 510,860 1480,1710 1710,1860
make these decisions, because it

2524
01:05:05,940 --> 01:05:06,915
0,240 240,435 435,630 630,840 840,975
actually depends on the speed

2525
01:05:06,915 --> 01:05:08,060
0,75 75,150 150,395
of the hardware.|
|

2526
01:05:08,200 --> 01:05:09,270
0,290 290,515 515,710 710,845 845,1070
Right, if if your disk
对，如果你的磁盘非常快，是的，我会把它写出来，你知道，我会马上写出脏页，因为这将是相当便宜的操作。但如果我的磁盘真的很慢，或者我必须通过网络写入某个速度较慢的设备，那么当我必须在我需要的时刻驱逐一些东西时，可能我想要最大限度地减少我必须执行的磁盘权利的数量。

2527
01:05:09,270 --> 01:05:10,170
0,105 105,285 285,555 555,780 780,900
is super fast and yeah,

2528
01:05:10,170 --> 01:05:10,740
0,180 180,270 270,360 360,450 450,570
I'll write it out the

2529
01:05:10,740 --> 01:05:11,625
0,240 240,465 465,600 600,780 780,885
disc, you know, I'll write

2530
01:05:11,625 --> 01:05:12,390
0,120 120,255 255,420 420,585 585,765
a dirty page out right

2531
01:05:12,390 --> 01:05:14,240
0,290 550,950 1180,1530 1530,1605 1605,1850
away because that's going be

2532
01:05:14,800 --> 01:05:16,965
0,395 395,1000 1020,1420 1860,2090 2090,2165
fairly inexpensive operation. But if

2533
01:05:16,965 --> 01:05:18,075
0,135 135,375 375,495 495,780 780,1110
my disk is really slow

2534
01:05:18,075 --> 01:05:18,705
0,150 150,225 225,375 375,510 510,630
or I gotta write over

2535
01:05:18,705 --> 01:05:19,905
0,150 150,425 535,810 810,975 975,1200
the network to some slow

2536
01:05:19,905 --> 01:05:21,765
0,335 895,1245 1245,1530 1530,1740 1740,1860
device, then maybe I want

2537
01:05:21,765 --> 01:05:23,400
0,105 105,570 570,965 1135,1425 1425,1635
to minimize the amount of

2538
01:05:23,400 --> 01:05:24,120
0,255 255,375 375,495 495,600 600,720
disk rights I have to

2539
01:05:24,120 --> 01:05:25,305
0,260 520,795 795,960 960,1110 1110,1185
do when I have to

2540
01:05:25,305 --> 01:05:26,445
0,225 225,515 535,810 810,975 975,1140
evict something the exact moment

2541
01:05:26,445 --> 01:05:27,760
0,150 150,285 285,420 420,695
I I need a.|
|

2542
01:05:28,070 --> 01:05:29,170
0,230 230,440 440,785 785,995 995,1100
You know, I I need
你知道，我我需要一个空间。

2543
01:05:29,170 --> 01:05:30,340
0,135 135,410
a space.|
|

2544
01:05:31,240 --> 01:05:32,250
0,245 245,395 395,605 605,860 860,1010
So there's no, there's no
所以没有，这个问题没有简单的答案。

2545
01:05:32,250 --> 01:05:34,540
0,240 240,465 465,615 615,860
easy answer to this.|
|

2546
01:05:35,220 --> 01:05:36,020
0,245 245,380 380,530 530,665 665,800
You know, if all your
你知道，如果你所有的页面都是脏的，你需要挑选一个，你必须写出来。

2547
01:05:36,020 --> 01:05:37,580
0,165 165,330 330,590 1210,1470 1470,1560
pages are dirty and you

2548
01:05:37,580 --> 01:05:38,225
0,90 90,180 180,300 300,495 495,645
need to pick one, you

2549
01:05:38,225 --> 01:05:39,320
0,105 105,210 210,315 315,575
have to write it.|
|

2550
01:05:41,665 --> 01:05:42,190
0,90 90,195 195,315 315,420 420,525
But what's one way to
但是，有什么方法可以避免这个问题呢？

2551
01:05:42,190 --> 01:05:43,480
0,135 135,285 285,560
avoid this problem?|
|

2552
01:05:43,570 --> 01:05:44,535
0,245 245,395 395,620 620,800 800,965
Do not have the right
当您想要访问页面时，在关键路径上没有正确的视图。

2553
01:05:44,535 --> 01:05:45,380
0,150 150,240 240,330 330,510 510,845
view on the critical path

2554
01:05:45,490 --> 01:05:46,155
0,230 230,305 305,380 380,515 515,665
when you want to access

2555
01:05:46,155 --> 01:05:47,300
0,105 105,365
a page.|
|

2556
01:05:52,530 --> 01:05:54,580
0,365 365,730 900,1300
Background writing, right?|
背景写作，对吧？|

2557
01:05:55,950 --> 01:05:57,710
0,365 365,820 1140,1400 1400,1550 1550,1760
Right. There's, you could have
正确的。有，你可以在后台有一个单独的线程。只需浏览一下你的支付表，找出什么是脏的，确保日志再次在磁盘上。我们稍后会讲述这一点。但假设有，你必须引用，首先登录，找到肮脏的页面，然后继续，并将它们写出来。

2558
01:05:57,710 --> 01:05:59,450
0,180 180,405 405,770 1360,1620 1620,1740
a separate thread in the

2559
01:05:59,450 --> 01:06:00,515
0,260 280,600 600,825 825,960 960,1065
background. Just walk through your

2560
01:06:00,515 --> 01:06:02,165
0,210 210,545 895,1185 1185,1365 1365,1650
pay table, figure out what's

2561
01:06:02,165 --> 01:06:03,815
0,275 715,1050 1050,1275 1275,1425 1425,1650
dirty, make sure the log

2562
01:06:03,815 --> 01:06:05,795
0,300 300,635 835,1140 1140,1655 1705,1980
is is on disk again.

2563
01:06:05,795 --> 01:06:06,740
0,165 165,270 270,420 420,675 675,945
We'll cover that later. But

2564
01:06:06,740 --> 01:06:07,630
0,165 165,435 435,585 585,660 660,890
assume there's, you have to

2565
01:06:07,980 --> 01:06:10,205
0,305 305,530 530,850 1560,1925 1925,2225
quote, log first, find pages

2566
01:06:10,205 --> 01:06:11,375
0,165 165,255 255,515 745,1020 1020,1170
that are dirty and go

2567
01:06:11,375 --> 01:06:12,215
0,180 180,390 390,570 570,720 720,840
ahead and, and write them

2568
01:06:12,215 --> 01:06:13,040
0,245
out.|
|

2569
01:06:14,810 --> 01:06:15,535
0,230 230,320 320,410 410,545 545,725
And then you just flip
然后你只需翻一翻，说这个页面现在是干净的，这样当驱逐算法运行时，它说，好的，我必须驱逐一些东西，现在有一堆干净的页面选项，可以写出来。

2570
01:06:15,535 --> 01:06:16,375
0,150 150,345 345,525 525,675 675,840
the bit to say this

2571
01:06:16,375 --> 01:06:17,605
0,150 150,285 285,435 435,725 985,1230
page is now clean so

2572
01:06:17,605 --> 01:06:18,570
0,135 135,315 315,435 435,660 660,965
that when the eviction algorith

2573
01:06:18,710 --> 01:06:19,885
0,400 420,650 650,740 740,935 935,1175
runs and it says, okay,

2574
01:06:19,885 --> 01:06:20,670
0,165 165,285 285,360 360,510 510,785
I have to evict something

2575
01:06:20,900 --> 01:06:21,580
0,290 290,425 425,500 500,590 590,680
now has a bunch of

2576
01:06:21,580 --> 01:06:22,510
0,210 210,465 465,660 660,825 825,930
options of pages that are

2577
01:06:22,510 --> 01:06:23,640
0,150 150,440 460,720 720,855 855,1130
clean, that could write out.|
|

2578
01:06:24,500 --> 01:06:25,795
0,260 260,520 540,830 830,1055 1055,1295
Or, sorry, not just drop,
或者，对不起，不只是放下，你知道，写任何东西。

2579
01:06:25,795 --> 01:06:27,280
0,150 150,255 255,465 465,815
you know, write anything.|
|

2580
01:06:30,150 --> 01:06:31,145
0,260 260,425 425,650 650,800 800,995
But now there's this trade
但现在存在这样的权衡，比如，我的系统是否应该积极地写出脏页，可能会干扰试图运行一半应用程序的查询和事务。

2581
01:06:31,145 --> 01:06:32,120
0,195 195,405 405,630 630,825 825,975
off between like, should I

2582
01:06:32,120 --> 01:06:33,440
0,240 240,480 480,675 675,900 900,1320
have my system be aggressively

2583
01:06:33,440 --> 01:06:34,505
0,150 150,315 315,510 510,795 795,1065
writing out dirty pages, maybe

2584
01:06:34,505 --> 01:06:35,920
0,450 450,630 630,975 975,1140 1140,1415
interfering with queries and transactions

2585
01:06:35,940 --> 01:06:37,180
0,230 230,335 335,470 470,730 840,1240
that are trying to run

2586
01:06:37,290 --> 01:06:39,540
0,365 365,605 605,815 815,1150
things half the application.|
|

2587
01:06:39,540 --> 01:06:41,400
0,225 225,405 405,650 1450,1710 1710,1860
Or should I? You know,
或者我应该这么做？你知道，我是不是应该推迟一下？但现在的问题是，在某个时候，我需要获得空闲空间，而我所有的页面都是脏的。

2588
01:06:41,400 --> 01:06:42,825
0,135 135,360 360,660 660,980 1180,1425
should I delay that? But

2589
01:06:42,825 --> 01:06:43,485
0,120 120,270 270,390 390,525 525,660
then now the problem is

2590
01:06:43,485 --> 01:06:44,460
0,135 135,405 405,675 675,840 840,975
at some point I need

2591
01:06:44,460 --> 01:06:45,945
0,105 105,300 300,555 555,860 1240,1485
to get free space and

2592
01:06:45,945 --> 01:06:46,850
0,105 105,255 255,450 450,630 630,905
all my pages are dirty.|
|

2593
01:06:48,950 --> 01:06:49,730
0,75 75,165 165,315 315,510 510,780
It's a super hard problem
这是一个超级难的问题，没有简单的答案。

2594
01:06:49,730 --> 01:06:51,430
0,330 850,1095 1095,1215 1215,1395 1395,1700
and there's no easy answer.|
|

2595
01:06:54,580 --> 01:06:55,425
0,275 275,425 425,560 560,710 710,845
But all the systems are
但所有的系统都会有某种机制来进行这种背景写作。

2596
01:06:55,425 --> 01:06:56,120
0,75 75,135 135,255 255,420 420,695
going to have some mechanism

2597
01:06:56,230 --> 01:06:57,210
0,260 260,485 485,740 740,875 875,980
to do this kind of

2598
01:06:57,210 --> 01:06:58,460
0,210 210,560
background writing.|
|

2599
01:07:00,540 --> 01:07:01,865
0,275 275,395 395,730 750,1250 1250,1325
Then we haven't. Checkpoints are
那么我们没有。检查站是一个完全不同的野兽检查站。你把所有东西都冲了出来，但这是会发生的。

2600
01:07:01,865 --> 01:07:02,720
0,75 75,165 165,315 315,510 510,855
a whole other beast checkpoints.

2601
01:07:02,720 --> 01:07:04,475
0,105 105,375 375,600 600,860 1510,1755
You flush everything out, but

2602
01:07:04,475 --> 01:07:06,360
0,210 210,575
that happens.|
|

2603
01:07:06,520 --> 01:07:09,580
0,400 810,1210 1710,2110
Every. Every minutes.|
每个。每分钟。|

2604
01:07:10,380 --> 01:07:11,780
0,275 275,440 440,730
Not every second.|
不是每一秒都是。|

2605
01:07:14,710 --> 01:07:15,880
0,400
Okay.|
好吧。|

2606
01:07:18,330 --> 01:07:19,740
0,335 335,670
Right, so.|
对，所以。|

2607
01:07:20,440 --> 01:07:21,180
0,275 275,395 395,515 515,650 650,740
Now we start talking a
现在，我们开始讨论一下何时进行这些磁盘写入和读取。我们得谈谈我们到底要怎么做。

2608
01:07:21,180 --> 01:07:21,885
0,75 75,180 180,405 405,615 615,705
little bit about when we

2609
01:07:21,885 --> 01:07:22,605
0,105 105,225 225,465 465,600 600,720
do these disk writes and

2610
01:07:22,605 --> 01:07:23,310
0,150 150,480 480,570 570,645 645,705
disc reads. We got to

2611
01:07:23,310 --> 01:07:24,510
0,105 105,380 670,930 930,1035 1035,1200
talk about how are we

2612
01:07:24,510 --> 01:07:25,700
0,320 430,690 690,810 810,930 930,1190
actually going to do that.|
|

2613
01:07:27,540 --> 01:07:29,570
0,400 450,710 710,905 905,1240 1680,2030
And for this one, when
对于这一次，当我们对文件系统进行读写调用时，假设我们在文件上运行，而不是在原始分区上运行。

2614
01:07:29,570 --> 01:07:30,755
0,350 550,795 795,915 915,1065 1065,1185
we, you know, when we

2615
01:07:30,755 --> 01:07:31,900
0,245 355,600 600,690 690,840 840,1145
make read and write calls

2616
01:07:32,100 --> 01:07:34,715
0,400 1080,1355 1355,1565 1565,1900 2310,2615
to the file system, assuming

2617
01:07:34,715 --> 01:07:35,680
0,225 225,345 345,555 555,720 720,965
we're running on the file,

2618
01:07:35,700 --> 01:07:37,820
0,320 320,530 530,725 725,1210
not, not raw partitions.|
|

2619
01:07:38,390 --> 01:07:39,190
0,275 275,320 320,410 410,530 530,800
There's a bunch of layers
我们的数据系统下面有很多层，比如操作系统、文件系统和硬件。

2620
01:07:39,190 --> 01:07:40,045
0,225 225,465 465,615 615,705 705,855
below us in our data

2621
01:07:40,045 --> 01:07:41,905
0,305 325,585 585,750 750,1055 1615,1860
system, like the OS and

2622
01:07:41,905 --> 01:07:42,925
0,90 90,255 255,510 510,810 810,1020
the file system and the

2623
01:07:42,925 --> 01:07:44,140
0,245
hardware.|
|

2624
01:07:44,620 --> 01:07:45,690
0,440 440,545 545,710 710,905 905,1070
That's gonna be clever and
这将是聪明的，并试图通过重新排序和批处理IO请求来最大化我们可以实现的带宽量。

2625
01:07:45,690 --> 01:07:47,565
0,120 120,380 1090,1665 1665,1800 1800,1875
try to maximize the amount

2626
01:07:47,565 --> 01:07:48,900
0,105 105,465 465,755 865,1170 1170,1335
of bandwidth we that that

2627
01:07:48,900 --> 01:07:51,060
0,180 180,450 450,800 1390,2025 2025,2160
can achieve by reordering and

2628
01:07:51,060 --> 01:07:52,340
0,330 330,525 525,750 750,945 945,1280
batching our I O requests.|
|

2629
01:07:53,540 --> 01:07:54,220
0,230 230,290 290,350 350,470 470,680
Part of the reason why
这些现代磁盘驱动器或固态硬盘或和V、M、E驱动器速度如此之快的部分原因。因为它们有很长的队列，所以它们可以进行并行请求。因此，如果你一次只读一次，那会非常慢，但你可以把事情分批处理，并确保你读的是一堆连续的数据。事情会变得很快的。

2630
01:07:54,220 --> 01:07:55,870
0,320 340,600 600,860 1090,1440 1440,1650
these the modern disk drives

2631
01:07:55,870 --> 01:07:57,295
0,285 285,870 870,1005 1005,1245 1245,1425
or ssds or and V

2632
01:07:57,295 --> 01:07:58,495
0,90 90,285 285,605 775,1050 1050,1200
M E drives are so

2633
01:07:58,495 --> 01:07:59,580
0,275 325,585 585,705 705,825 825,1085
fast. Because they have these

2634
01:07:59,630 --> 01:08:00,520
0,335 335,650 650,740 740,800 800,890
long queues, they can do

2635
01:08:00,520 --> 01:08:02,410
0,260 670,1100 1540,1755 1755,1815 1815,1890
parallel requests. So if you

2636
01:08:02,410 --> 01:08:03,340
0,180 180,405 405,600 600,795 795,930
just do one read at

2637
01:08:03,340 --> 01:08:04,105
0,135 135,375 375,690 690,735 735,765
a time that's going to

2638
01:08:04,105 --> 01:08:04,855
0,90 90,300 300,525 525,660 660,750
be super slow, but you

2639
01:08:04,855 --> 01:08:06,175
0,105 105,300 300,495 495,785 1075,1320
can batch things up and

2640
01:08:06,175 --> 01:08:06,970
0,150 150,315 315,435 435,645 645,795
make sure that you're reading

2641
01:08:06,970 --> 01:08:07,890
0,135 135,240 240,330 330,660 660,920
a bunch of contiguous data.

2642
01:08:08,270 --> 01:08:09,240
0,275 275,395 395,500 500,665 665,970
Things will be really fast.|
|

2643
01:08:10,940 --> 01:08:12,120
0,245 245,350 350,590 590,875 875,1180
But the challenge is, though,
但挑战是，数据系统下面的这些不同的系统层。

2644
01:08:12,590 --> 01:08:13,705
0,320 320,575 575,920 920,1010 1010,1115
these different layers of the

2645
01:08:13,705 --> 01:08:14,910
0,195 195,495 495,720 720,885 885,1205
system below the data system.|
|

2646
01:08:16,470 --> 01:08:17,750
0,410 410,605 605,800 800,965 965,1280
Don't know what the requests
不知道这些请求实际上对应于数据c的读写和某个位置或某个地址的页面。他们不知道。哦，这是来自后台编写器的，或者这是索引的，或者这是我现在需要运行的查询的。

2647
01:08:17,750 --> 01:08:19,865
0,380 460,860 940,1340 1540,1875 1875,2115
actually correspond to data c

2648
01:08:19,865 --> 01:08:20,680
0,240 240,330 330,435 435,555 555,815
reads and writes and pages

2649
01:08:20,730 --> 01:08:21,800
0,275 275,485 485,740 740,905 905,1070
at some location or some

2650
01:08:21,800 --> 01:08:23,525
0,320 790,1035 1035,1230 1230,1455 1455,1725
address. They don't know. Oh,

2651
01:08:23,525 --> 01:08:24,200
0,135 135,210 210,315 315,435 435,675
this is from the background

2652
01:08:24,200 --> 01:08:25,355
0,380 580,840 840,945 945,1050 1050,1155
writer or this is for

2653
01:08:25,355 --> 01:08:26,195
0,180 180,435 435,615 615,720 720,840
an index or this is

2654
01:08:26,195 --> 01:08:27,280
0,135 135,255 255,545 625,855 855,1085
for the query that I

2655
01:08:27,420 --> 01:08:28,480
0,260 260,380 380,560 560,770 770,1060
need to run right now.|
|

2656
01:08:30,400 --> 01:08:31,860
0,350 350,575 575,850 930,1250 1250,1460
So you can play some
因此，您可以在Linux中使用设置IO优先级来玩一些游戏，但这基本上是一把大锤。您唯一真正能做的就是更改PER上的io优先级。

2657
01:08:31,860 --> 01:08:34,490
0,290 400,800 1570,1920 1920,2175 2175,2630
games with in in Linux

2658
01:08:34,720 --> 01:08:35,780
0,320 320,470 470,575 575,755 755,1060
setting the I O priority,

2659
01:08:36,280 --> 01:08:37,860
0,260 260,530 530,770 770,1010 1010,1580
but that's basically a sledgehammer.

2660
01:08:37,860 --> 01:08:38,415
0,135 135,255 255,390 390,480 480,555
The only thing you can

2661
01:08:38,415 --> 01:08:39,870
0,165 165,390 390,695 835,1155 1155,1455
really do is change the

2662
01:08:39,870 --> 01:08:41,240
0,405 405,680 700,960 960,1095 1095,1370
io priority on a per.|
|

2663
01:08:42,040 --> 01:08:44,155
0,285 285,590 790,1190 1630,1890 1890,2115
Per process level, you can't
对于每个进程级别，您不能对每个请求执行此操作，这才是我们真正想要的。

2664
01:08:44,155 --> 01:08:44,905
0,90 90,195 195,375 375,570 570,750
do it on a per

2665
01:08:44,905 --> 01:08:46,060
0,285 285,665 685,945 945,1050 1050,1155
single request, which is what

2666
01:08:46,060 --> 01:08:47,360
0,135 135,330 330,650
we really want.|
|

2667
01:08:48,560 --> 01:08:49,450
0,365 365,575 575,665 665,785 785,890
So if you read the
因此，如果你阅读了大量不同的数据库系统的文档，他们会告诉你，所有人都放弃默认的Linux调度程序，也就是票价调度程序，要么使用Deadline，要么使用简单的FIFO队列，不使用OP。

2668
01:08:49,450 --> 01:08:50,515
0,435 435,660 660,750 750,855 855,1065
documentation bunch of different database

2669
01:08:50,515 --> 01:08:51,490
0,330 330,615 615,780 780,900 900,975
systems, they tell you to

2670
01:08:51,490 --> 01:08:52,900
0,150 150,330 330,590 790,1155 1155,1410
all get off the default

2671
01:08:52,900 --> 01:08:54,820
0,285 285,770 1480,1725 1725,1815 1815,1920
Linux scheduler, which is the

2672
01:08:54,820 --> 01:08:56,260
0,165 165,620 730,1020 1020,1230 1230,1440
fare scheduler, and either use

2673
01:08:56,260 --> 01:08:58,015
0,435 435,770 880,1155 1155,1365 1365,1755
deadline or the simple fifo

2674
01:08:58,015 --> 01:09:00,520
0,270 270,450 450,585 585,845
queue and no op.|
|

2675
01:09:00,710 --> 01:09:02,100
0,290 290,440 440,725 725,1010 1010,1390
Because they don't want the
因为他们不想要数据系统，他们不想让操作系统做一堆数据无法控制的事情。

2676
01:09:02,630 --> 01:09:03,715
0,260 260,470 470,785 785,980 980,1085
the data system, they don't

2677
01:09:03,715 --> 01:09:04,390
0,75 75,225 225,375 375,540 540,675
want the operating system to

2678
01:09:04,390 --> 01:09:04,885
0,60 60,120 120,210 210,345 345,495
do a bunch of stuff

2679
01:09:04,885 --> 01:09:07,740
0,225 225,575 955,1245 1245,1535 2455,2855
that that, that the data

2680
01:09:07,760 --> 01:09:09,240
0,425 425,760
can't control.|
|

2681
01:09:10,750 --> 01:09:11,520
0,245 245,335 335,425 425,575 575,770
So this is why, in
这就是为什么，在大多数数据系统中，他们将在上方拥有自己的小填充层。

2682
01:09:11,520 --> 01:09:12,540
0,210 210,465 465,750 750,975 975,1020
most data systems, they're going

2683
01:09:12,540 --> 01:09:13,500
0,120 120,345 345,540 540,705 705,960
to have their own little

2684
01:09:13,500 --> 01:09:15,050
0,255 255,450 450,720 720,1070 1150,1550
SHIM layer right above the.|
|

2685
01:09:17,590 --> 01:09:19,320
0,320 320,640
The OS.|
操作系统。|

2686
01:09:19,320 --> 01:09:20,235
0,315 315,390 390,435 435,585 585,915
That's going to be responsible
这将负责跟踪缓冲区管理器中哪些未完成的读写请求，并决定如何将它们组合在一起以优化性能。

2687
01:09:20,235 --> 01:09:22,245
0,395 505,840 840,1065 1065,1355 1645,2010
for keeping track of what

2688
01:09:22,245 --> 01:09:23,895
0,390 390,750 750,1140 1140,1425 1425,1650
requests are outstanding for reads

2689
01:09:23,895 --> 01:09:25,245
0,105 105,365 715,975 975,1080 1080,1350
and writes from the buffer

2690
01:09:25,245 --> 01:09:27,945
0,305 1645,2010 2010,2325 2325,2550 2550,2700
manager and decide how to

2691
01:09:27,945 --> 01:09:29,955
0,150 150,375 375,720 720,1115 1555,2010
put things together to optimize

2692
01:09:29,955 --> 01:09:31,060
0,365
performance.|
|

2693
01:09:31,840 --> 01:09:33,560
0,400 810,1175 1175,1385 1385,1475 1475,1720
And basically you think of
基本上，您考虑基于多种不同的因素来确定这些不同IO请求的优先级，因为同样，我们知道查询试图做什么。我们知道缓冲池中有哪些页面。我们知道什么是脏的，什么不是脏的。我们知道什么是未解决的请求。

2694
01:09:33,610 --> 01:09:35,220
0,395 395,485 485,730 990,1370 1370,1610
determining the priorities for these

2695
01:09:35,220 --> 01:09:36,765
0,135 135,450 450,800 970,1275 1275,1545
different io requests based on

2696
01:09:36,765 --> 01:09:38,180
0,285 285,840 840,930 930,1095 1095,1415
a multitude of different factors

2697
01:09:38,680 --> 01:09:40,035
0,305 305,515 515,725 725,1030 1080,1355
because again, we know what

2698
01:09:40,035 --> 01:09:40,965
0,120 120,465 465,690 690,825 825,930
the queries are trying to

2699
01:09:40,965 --> 01:09:42,240
0,245 385,660 660,825 825,1035 1035,1275
do. We know what pages

2700
01:09:42,240 --> 01:09:43,070
0,150 150,210 210,300 300,570 570,830
are in a buffer pool.

2701
01:09:43,120 --> 01:09:44,100
0,260 260,380 380,605 605,800 800,980
We know what's dirty and

2702
01:09:44,100 --> 01:09:45,105
0,165 165,405 405,615 615,750 750,1005
not dirty. We know what

2703
01:09:45,105 --> 01:09:46,780
0,240 240,390 390,630 630,995
are the outstanding requests.|
|

2704
01:09:47,970 --> 01:09:48,860
0,290 290,470 470,635 635,770 770,890
And so to try to
因此，为了跟踪顺序IO和随机IO之类的东西，请求是基于关键路径的，比如查询现在就需要这样做，或者这就像是后台工作背景？背景作家，因此，你知道，可能会有较低的优先级。

2705
01:09:48,860 --> 01:09:49,505
0,135 135,285 285,390 390,495 495,645
keep track of things like

2706
01:09:49,505 --> 01:09:50,645
0,315 315,705 705,810 810,945 945,1140
what's sequential I O versus

2707
01:09:50,645 --> 01:09:53,075
0,240 240,420 420,695 1885,2190 2190,2430
random I O is the

2708
01:09:53,075 --> 01:09:54,020
0,270 270,495 495,630 630,735 735,945
request based on the critical

2709
01:09:54,020 --> 01:09:55,265
0,330 330,570 570,720 720,990 990,1245
path, like a query needs

2710
01:09:55,265 --> 01:09:56,990
0,195 195,390 390,695 1375,1620 1620,1725
this right now or is

2711
01:09:56,990 --> 01:09:58,000
0,120 120,225 225,330 330,590 610,1010
this like a background job

2712
01:09:58,020 --> 01:09:59,650
0,400 540,875 875,1070 1070,1280 1280,1630
background? The, the background writer

2713
01:09:59,970 --> 01:10:01,370
0,365 365,730 930,1175 1175,1280 1280,1400
and therefore, you know, could

2714
01:10:01,370 --> 01:10:03,120
0,120 120,225 225,390 390,710
have a lower priority.|
|

2715
01:10:03,370 --> 01:10:04,920
0,260 260,410 410,695 695,1120 1320,1550
The data we're accessing for
我们正在访问的表、索引、日志记录的数据。同样，我们希望尽可能快地刷新日志。

2716
01:10:04,920 --> 01:10:07,050
0,135 135,440 550,930 930,1310 1780,2130
a table, an index, log

2717
01:10:07,050 --> 01:10:08,370
0,350 640,885 885,990 990,1245 1245,1320
records. Again, the logs we

2718
01:10:08,370 --> 01:10:09,015
0,75 75,195 195,375 375,510 510,645
want to flush as fast

2719
01:10:09,015 --> 01:10:10,260
0,165 165,455
as possible.|
|

2720
01:10:10,330 --> 01:10:11,540
0,260 260,395 395,515 515,935 935,1210
Is it for ephemeral data?|
它是针对短暂数据的吗？|

2721
01:10:12,670 --> 01:10:13,575
0,275 275,440 440,590 590,770 770,905
Like if if it's a
例如，如果是对优先级较低的表的顺序扫描，那么可能会随机访问索引，因为当您遍历b+树时，您会在向下移动时持有闩锁，因此这将阻止其他线程同时运行。但是，如果您的扫描队列查询速度稍慢一些，从技术上讲，您可能不会干扰同时运行的其他查询。

2722
01:10:13,575 --> 01:10:14,750
0,390 390,600 600,765 765,885 885,1175
sequencential scan for a table

2723
01:10:15,550 --> 01:10:16,590
0,485 485,605 605,725 725,830 830,1040
that's gonna have a lower

2724
01:10:16,590 --> 01:10:18,300
0,350 430,690 690,900 900,1250 1360,1710
priority, then maybe random access

2725
01:10:18,300 --> 01:10:19,815
0,350 370,770 790,1095 1095,1320 1320,1515
for index, because as you

2726
01:10:19,815 --> 01:10:20,930
0,285 285,435 435,585 585,795 795,1115
traverse your b plus tree,

2727
01:10:21,070 --> 01:10:22,605
0,320 320,530 530,1130 1130,1400 1400,1535
you're holding latches as you

2728
01:10:22,605 --> 01:10:24,315
0,135 135,425 1015,1335 1335,1515 1515,1710
go down and therefore that's

2729
01:10:24,315 --> 01:10:25,455
0,90 90,255 255,555 555,990 990,1140
going prevent other threads from

2730
01:10:25,455 --> 01:10:26,325
0,180 180,330 330,465 465,690 690,870
running the same time. But

2731
01:10:26,325 --> 01:10:27,990
0,90 90,225 225,575 835,1235 1375,1665
if you query your scan

2732
01:10:27,990 --> 01:10:28,650
0,195 195,315 315,405 405,510 510,660
quer is a little bit

2733
01:10:28,650 --> 01:10:30,930
0,320 730,1095 1095,1400 1780,2100 2100,2280
slower, you're technically potentially not

2734
01:10:30,930 --> 01:10:31,980
0,390 390,525 525,675 675,945 945,1050
interfering with other queries running

2735
01:10:31,980 --> 01:10:33,100
0,105 105,195 195,330 330,620
at the same time.|
|

2736
01:10:33,420 --> 01:10:34,505
0,275 275,470 470,605 605,875 875,1085
Well, that's not true because
这不是真的，因为当你运行查询和事务时，你会拿到锁，所以没有，你知道，没有简单的答案。

2737
01:10:34,505 --> 01:10:35,680
0,135 135,360 360,555 555,705 705,1175
you take, you take locks

2738
01:10:36,120 --> 01:10:37,700
0,260 260,380 380,640 1110,1475 1475,1580
when you run queries and

2739
01:10:37,700 --> 01:10:39,965
0,260 580,980 1510,1845 1845,2055 2055,2265
transactions, so there's no, you

2740
01:10:39,965 --> 01:10:40,805
0,105 105,270 270,390 390,570 570,840
know, there's no easy answer

2741
01:10:40,805 --> 01:10:41,880
0,365
for.|
|

2742
01:10:41,890 --> 01:10:43,590
0,400 900,1175 1175,1310 1310,1505 1505,1700
When one be faster than
当一个比另一个更快时，你不能仅仅因为它是一个索引，因为它又是一个表，操作系统不知道它是一个索引页还是一个表页。

2743
01:10:43,590 --> 01:10:44,580
0,240 240,480 480,630 630,795 795,990
another, you can't just because

2744
01:10:44,580 --> 01:10:45,420
0,165 165,285 285,495 495,660 660,840
it's an index, because it's

2745
01:10:45,420 --> 01:10:46,770
0,105 105,380 760,1020 1020,1185 1185,1350
a table again, the OS

2746
01:10:46,770 --> 01:10:47,580
0,255 255,435 435,585 585,705 705,810
doesn't know that it's an

2747
01:10:47,580 --> 01:10:48,495
0,180 180,360 360,570 570,750 750,915
index page versus a table

2748
01:10:48,495 --> 01:10:49,520
0,305
page.|
|

2749
01:10:50,200 --> 01:10:51,420
0,410 410,590 590,830 830,1070 1070,1220
There's also sometimes in some
有时，在一些系统中，您可以让SL服务级别协议或服务级别目标(如我的查询)必须在特定的最后期限内以特定的延迟运行。

2750
01:10:51,420 --> 01:10:52,500
0,285 285,540 540,645 645,855 855,1080
systems you can have sl

2751
01:10:52,500 --> 01:10:54,570
0,210 210,480 480,705 705,1130 1810,2070
a service level agreements or

2752
01:10:54,570 --> 01:10:56,100
0,165 165,405 405,740 970,1290 1290,1530
service level objectives like my

2753
01:10:56,100 --> 01:10:57,060
0,285 285,375 375,510 510,720 720,960
queries have to run within

2754
01:10:57,060 --> 01:10:58,350
0,180 180,360 360,830 910,1170 1170,1290
a certain deadline at a

2755
01:10:58,350 --> 01:10:59,660
0,165 165,740
certain latency.|
|

2756
01:10:59,750 --> 01:11:00,685
0,245 245,350 350,560 560,785 785,935
And the typical way you
这样做的典型方式是，您有不同的用户帐户，并为一个用户帐户赋予比另一个用户帐户更高的优先级。与一样，前端应用程序具有比夜间报告作业更高的优先级。

2757
01:11:00,685 --> 01:11:01,390
0,135 135,270 270,375 375,480 480,705
do this is you have

2758
01:11:01,390 --> 01:11:02,740
0,270 270,555 555,885 885,1125 1125,1350
different user account and give

2759
01:11:02,740 --> 01:11:03,955
0,240 240,450 450,660 660,885 885,1215
one user account higher priority

2760
01:11:03,955 --> 01:11:05,940
0,300 300,510 510,750 750,1085 1585,1985
than another user account. Like

2761
01:11:05,960 --> 01:11:07,210
0,365 365,605 605,740 740,965 965,1250
the, the front end application

2762
01:11:07,210 --> 01:11:08,155
0,165 165,255 255,420 420,705 705,945
has a higher priority than

2763
01:11:08,155 --> 01:11:09,625
0,275 505,750 750,870 870,1215 1215,1470
like, you know, nightly reporting

2764
01:11:09,625 --> 01:11:10,780
0,335
jobs.|
|

2765
01:11:10,850 --> 01:11:11,680
0,260 260,395 395,530 530,680 680,830
And you do that based
您可以根据用户角色来执行此操作。

2766
01:11:11,680 --> 01:11:13,280
0,120 120,315 315,650
on user roles.|
|

2767
01:11:16,860 --> 01:11:19,355
0,400 840,1240 1890,2225 2225,2405 2405,2495
So the way we can
因此，我们可以获得更好的性能并试图避免操作系统的某些干扰的方法是使用所谓的直接IO。

2768
01:11:19,355 --> 01:11:20,345
0,120 120,330 330,600 600,840 840,990
get better performance and try

2769
01:11:20,345 --> 01:11:21,430
0,165 165,465 465,705 705,825 825,1085
to avoid some of this

2770
01:11:22,560 --> 01:11:25,235
0,670 720,1025 1025,1250 1250,1570 2340,2675
interference from the OS is

2771
01:11:25,235 --> 01:11:26,165
0,165 165,285 285,510 510,705 705,930
to use what's called direct

2772
01:11:26,165 --> 01:11:27,240
0,165 165,455
I O.|
|

2773
01:11:28,040 --> 01:11:29,160
0,400
So.|
所以。|

2774
01:11:29,360 --> 01:11:30,610
0,305 305,470 470,725 725,1025 1025,1250
All your disk operations for
在很大程度上，您的所有磁盘操作都必须通过OS API，除非您正在执行类似于直接绕过内核到硬件设备的操作，但大多数系统不会这样做。

2775
01:11:30,610 --> 01:11:31,045
0,60 60,165 165,285 285,375 375,435
the most part, are going

2776
01:11:31,045 --> 01:11:31,800
0,45 45,135 135,240 240,420 420,755
to have to go through

2777
01:11:32,150 --> 01:11:34,045
0,290 290,455 455,1000 1440,1715 1715,1895
the OS API, unless you're

2778
01:11:34,045 --> 01:11:35,370
0,165 165,420 420,600 600,845 925,1325
doing like, you know, direct

2779
01:11:35,750 --> 01:11:37,210
0,335 335,710 710,1040 1040,1265 1265,1460
kernel bypass to the hardware

2780
01:11:37,210 --> 01:11:38,980
0,350 730,1065 1065,1290 1290,1515 1515,1770
device, but most systems don't

2781
01:11:38,980 --> 01:11:40,960
0,90 90,350
do that.|
|

2782
01:11:41,100 --> 01:11:42,470
0,400 510,845 845,1100 1100,1265 1265,1370
And the idea here is
这里的想法是，我们不希望操作系统维护自己的缓存，称为页面缓存，因为我们不希望操作系统缓冲我们的读取和写入。

2783
01:11:42,470 --> 01:11:43,490
0,135 135,300 300,660 660,810 810,1020
that we don't want the

2784
01:11:43,490 --> 01:11:44,510
0,225 225,375 375,600 600,840 840,1020
OS to maintain its own

2785
01:11:44,510 --> 01:11:46,090
0,350 700,975 975,1110 1110,1260 1260,1580
cache, called the page cache,

2786
01:11:46,650 --> 01:11:48,140
0,290 290,455 455,830 830,1120 1170,1490
because we don't want the

2787
01:11:48,140 --> 01:11:49,505
0,300 300,570 570,915 915,1080 1080,1365
OS to buffer our reads

2788
01:11:49,505 --> 01:11:50,760
0,120 120,395
and writes.|
|

2789
01:11:50,770 --> 01:11:51,435
0,260 260,365 365,440 440,530 530,665
We want to do that
我们希望完全靠我们自己做到这一点。

2790
01:11:51,435 --> 01:11:53,440
0,275 325,725 805,1205
all entirely ourselves.|
|

2791
01:11:53,480 --> 01:11:54,220
0,290 290,455 455,590 590,680 680,740
Because again, we want to
再说一次，我们希望完全控制硬件。

2792
01:11:54,220 --> 01:11:55,750
0,120 120,375 375,740 1150,1410 1410,1530
have full control of the

2793
01:11:55,750 --> 01:11:56,820
0,260
hardware.|
|

2794
01:11:57,380 --> 01:11:58,075
0,230 230,350 350,485 485,575 575,695
So the idea is like
所以这个想法是这样的。如果我对文件系统执行读取，那么操作系统会说，哦，让我在操作系统中维护我自己的小缓冲池，跨操作系统全局运行的所有进程。然后我会将我需要的数据存储在我的页面缓存中，然后下一次我进行读取时，我会为我的页面缓存获取这些数据。

2795
01:11:58,075 --> 01:11:58,720
0,150 150,270 270,390 390,510 510,645
this. If I do a

2796
01:11:58,720 --> 01:12:01,530
0,290 1870,2145 2145,2280 2280,2475 2475,2810
read against the file system,

2797
01:12:02,420 --> 01:12:03,415
0,305 305,515 515,710 710,860 860,995
well, the OS is gonna

2798
01:12:03,415 --> 01:12:04,710
0,165 165,455 655,900 900,1020 1020,1295
say, oh, let me go

2799
01:12:05,120 --> 01:12:06,400
0,380 380,620 620,785 785,980 980,1280
maintain my own little buffer

2800
01:12:06,400 --> 01:12:08,370
0,260 850,1140 1140,1395 1395,1665 1665,1970
pool in, in the OS

2801
01:12:08,900 --> 01:12:11,220
0,400 720,1085 1085,1450 1800,2060 2060,2320
across all all the processes

2802
01:12:11,270 --> 01:12:12,810
0,400 630,950 950,1115 1115,1250 1250,1540
running global for the OS.

2803
01:12:13,490 --> 01:12:14,965
0,290 290,575 575,875 875,1175 1175,1475
And then I will store

2804
01:12:14,965 --> 01:12:16,075
0,165 165,300 300,465 465,755 775,1110
the data I need you're

2805
01:12:16,075 --> 01:12:16,855
0,180 180,390 390,465 465,585 585,780
asking for in my page

2806
01:12:16,855 --> 01:12:18,145
0,335 745,990 990,1050 1050,1125 1125,1290
cache and then the next

2807
01:12:18,145 --> 01:12:18,870
0,165 165,270 270,360 360,465 465,725
time I do a read,

2808
01:12:18,950 --> 01:12:19,675
0,320 320,380 380,455 455,530 530,725
I'll get it for my,

2809
01:12:19,675 --> 01:12:21,120
0,210 210,360 360,555 555,875
for my page cache.|
|

2810
01:12:21,610 --> 01:12:22,545
0,320 320,545 545,710 710,815 815,935
So instead we want to
因此，我们想要绕过这一点，绕过它，直接进入硬件，而不是让操作系统缓冲任何东西。

2811
01:12:22,545 --> 01:12:24,060
0,495 495,765 765,960 960,1215 1215,1515
bypass this and go around

2812
01:12:24,060 --> 01:12:25,515
0,165 165,410 670,1005 1005,1275 1275,1455
it and go directly to

2813
01:12:25,515 --> 01:12:27,855
0,90 90,335 925,1325 1495,1895 2035,2340
the hardware and not have

2814
01:12:27,855 --> 01:12:29,680
0,180 180,390 390,870 870,1265
the OS buffer anything.|
|

2815
01:12:30,880 --> 01:12:32,520
0,290 290,560 560,940 1110,1430 1430,1640
So most systems use direct
所以大多数系统使用直接I/O，默认情况下大多数系统使用直接O。

2816
01:12:32,520 --> 01:12:33,555
0,165 165,300 300,435 435,710 730,1035
I O most systems use

2817
01:12:33,555 --> 01:12:35,220
0,195 195,345 345,540 540,875
direct o by default.|
|

2818
01:12:35,560 --> 01:12:36,375
0,215 215,305 305,470 470,635 635,815
There is only one system
只有一个系统不是这样的。

2819
01:12:36,375 --> 01:12:37,720
0,165 165,300 300,575
that does not.|
|

2820
01:12:39,200 --> 01:12:39,880
0,245 245,350 350,485 485,605 605,680
Me to guess what it
让我猜猜这是什么。

2821
01:12:39,880 --> 01:12:40,840
0,230
is.|
|

2822
01:12:41,840 --> 01:12:43,860
0,275 275,470 470,665 665,940
Say single story now.|
现在说一个故事。|

2823
01:12:44,470 --> 01:12:45,840
0,275 275,455 455,760
I see now.|
我现在明白了。|

2824
01:12:46,135 --> 01:12:47,500
0,75 75,545
It's postgres.|
是波斯格雷斯。|

2825
01:12:47,500 --> 01:12:48,820
0,330 330,885 885,1095 1095,1245 1245,1320
Right postgres because it's a
对，因为它是八十年代的遗物。他们严重依赖S页面缓存。

2826
01:12:48,820 --> 01:12:51,460
0,345 345,510 510,615 615,1040 2290,2640
relic from the eighties. They

2827
01:12:51,460 --> 01:12:52,360
0,270 270,510 510,675 675,765 765,900
rely heavily on the s

2828
01:12:52,360 --> 01:12:53,660
0,180 180,500
page cache.|
|

2829
01:12:53,670 --> 01:12:55,490
0,260 260,520 1020,1310 1310,1580 1580,1820
It calls. And so when
它在召唤。因此，当您在postgres中分配您设置的缓冲池时，它大约是机器上内存量的3040%。我的SQL和所有其他数据库系统都会告诉您使用机箱中可用内存的80%，因为在Postgres中，他们想要一些内存用于页面缓存和操作系统，一些内存用于数据库系统。

2830
01:12:55,490 --> 01:12:56,300
0,120 120,375 375,465 465,675 675,810
you allocate a buffer pool

2831
01:12:56,300 --> 01:12:57,665
0,180 180,680 850,1110 1110,1215 1215,1365
in postgres you set, it's

2832
01:12:57,665 --> 01:12:58,850
0,195 195,545 565,870 870,1065 1065,1185
like thirty forty percent of

2833
01:12:58,850 --> 01:12:59,405
0,60 60,135 135,225 225,360 360,555
the amount of memory that's

2834
01:12:59,405 --> 01:13:01,190
0,75 75,180 180,425 1225,1530 1530,1785
on the box. My sql

2835
01:13:01,190 --> 01:13:02,030
0,60 60,165 165,345 345,585 585,840
and every other database system

2836
01:13:02,030 --> 01:13:02,990
0,165 165,270 270,435 435,840 840,960
tells you use 80% of

2837
01:13:02,990 --> 01:13:04,250
0,75 75,320 670,1020 1020,1155 1155,1260
the memory that's available in

2838
01:13:04,250 --> 01:13:05,825
0,75 75,320 790,1065 1065,1215 1215,1575
the box because in postgres

2839
01:13:05,825 --> 01:13:06,500
0,150 150,330 330,495 495,600 600,675
they want some of the

2840
01:13:06,500 --> 01:13:07,385
0,225 225,465 465,600 600,735 735,885
memory to be for the

2841
01:13:07,385 --> 01:13:08,165
0,150 150,285 285,510 510,660 660,780
the page cache and the

2842
01:13:08,165 --> 01:13:09,155
0,275 445,675 675,735 735,810 810,990
OS, some of the memory

2843
01:13:09,155 --> 01:13:10,560
0,195 195,300 300,480 480,815
for the database system.|
|

2844
01:13:11,130 --> 01:13:11,795
0,245 245,365 365,425 425,545 545,665
So what's the problem with
那么，这有什么问题呢？嗯，现在我得到了我的页面的多余复印件。操作系统将拥有我的页面的副本，我的数据系统将拥有我的页面的副本。读和写都是一样的。

2845
01:13:11,795 --> 01:13:13,145
0,245 745,1005 1005,1125 1125,1245 1245,1350
this? Well, now I got

2846
01:13:13,145 --> 01:13:14,230
0,345 345,600 600,675 675,795 795,1085
redundant copies of my pages.

2847
01:13:14,790 --> 01:13:15,485
0,290 290,455 455,575 575,650 650,695
The OS is going to

2848
01:13:15,485 --> 01:13:15,950
0,60 60,150 150,270 270,360 360,465
have a copy of my

2849
01:13:15,950 --> 01:13:16,700
0,195 195,330 330,420 420,600 600,750
page, and my data system

2850
01:13:16,700 --> 01:13:17,165
0,75 75,165 165,270 270,375 375,465
is going to have a

2851
01:13:17,165 --> 01:13:18,575
0,135 135,255 255,375 375,665 1135,1410
copy of my page. Same

2852
01:13:18,575 --> 01:13:19,490
0,150 150,360 360,615 615,825 825,915
thing for both reads and

2853
01:13:19,490 --> 01:13:20,520
0,260
writes.|
|

2854
01:13:20,670 --> 01:13:22,150
0,245 245,380 380,670 750,1115 1115,1480
And then the, the, the,
然后，数据系统将有自己的策略来决定如何驱逐哪些页面。但是，仅仅因为我在我的数据库系统中从我的缓冲池中驱逐它，操作系统就可以随心所欲地决定驱逐。

2855
01:13:22,440 --> 01:13:23,240
0,245 245,425 425,620 620,725 725,800
the data system is going

2856
01:13:23,240 --> 01:13:24,250
0,60 60,135 135,255 255,530 610,1010
to have its own policy

2857
01:13:24,780 --> 01:13:25,895
0,290 290,425 425,575 575,860 860,1115
of how to decide what

2858
01:13:25,895 --> 01:13:27,410
0,180 180,330 330,665 1105,1365 1365,1515
pages to evict. But then,

2859
01:13:27,410 --> 01:13:28,220
0,210 210,390 390,495 495,690 690,810
just because I evict it

2860
01:13:28,220 --> 01:13:29,210
0,105 105,255 255,555 555,780 780,990
from my buffer pool in

2861
01:13:29,210 --> 01:13:30,310
0,195 195,375 375,525 525,765 765,1100
my in my database system,

2862
01:13:30,600 --> 01:13:31,780
0,290 290,455 455,620 620,785 785,1180
the OS can decide evict

2863
01:13:31,980 --> 01:13:33,640
0,335 335,545 545,755 755,1090
anyway it wants to.|
|

2864
01:13:33,680 --> 01:13:34,600
0,260 260,380 380,485 485,710 710,920
And again, it doesn't know
再说一次，它不知道页面实际上代表了什么。

2865
01:13:34,600 --> 01:13:35,550
0,165 165,270 270,495 495,705 705,950
what the pages actually represent.|
|

2866
01:13:37,350 --> 01:13:38,675
0,260 260,515 515,890 890,1130 1130,1325
And then you also lose
然后，除非你很小心，否则你也会失去控制，当东西真的被冲出磁盘的时候。

2867
01:13:38,675 --> 01:13:40,115
0,335 385,720 720,1055 1075,1320 1320,1440
control when things actually get

2868
01:13:40,115 --> 01:13:41,090
0,210 210,315 315,435 435,810 810,975
flushed out the disk, unless

2869
01:13:41,090 --> 01:13:42,420
0,180 180,440
you're careful.|
|

2870
01:13:44,670 --> 01:13:45,820
0,400
So.|
所以。|

2871
01:13:45,990 --> 01:13:46,655
0,320 320,380 380,470 470,575 575,665
Let's see how far you
让我们看看你们能在这里得到这些答案，即使你没有上过操作系统课程。

2872
01:13:46,655 --> 01:13:47,630
0,105 105,210 210,455 505,780 780,975
guys can get these answers

2873
01:13:47,630 --> 01:13:48,335
0,225 225,390 390,495 495,570 570,705
here, even if you haven't

2874
01:13:48,335 --> 01:13:49,760
0,120 120,240 240,375 375,665
taken the OS class.|
|

2875
01:13:49,760 --> 01:13:50,690
0,285 285,450 450,570 570,720 720,930
So if you call f
所以，如果你按f键，会发生什么？

2876
01:13:50,690 --> 01:13:52,400
0,210 210,360 360,620
right, what happens?|
|

2877
01:13:53,900 --> 01:13:55,260
0,275 275,395 395,485 485,730 960,1360
I open a file, right
我打开一个文件，对说我希望我的数据库文件。我让我的缓冲区经理在另一个查询中带来一个页面来更新它。页面脏了。我调用f Right将那一页写出磁盘。会发生什么事？

2878
01:13:55,370 --> 01:13:56,340
0,305 305,470 470,575 575,695 695,970
say I hope my database

2879
01:13:56,510 --> 01:13:58,600
0,400 960,1360 1560,1820 1820,1925 1925,2090
file. I have my buff

2880
01:13:58,600 --> 01:13:59,610
0,255 255,450 450,555 555,705 705,1010
manager bring a page in

2881
01:14:00,440 --> 01:14:02,545
0,400 600,995 995,1265 1265,1570 1830,2105
another query updates it. The

2882
01:14:02,545 --> 01:14:03,730
0,150 150,285 285,545 775,1035 1035,1185
page is dirty. I call

2883
01:14:03,730 --> 01:14:04,420
0,180 180,345 345,450 450,555 555,690
f right to write that

2884
01:14:04,420 --> 01:14:05,260
0,120 120,240 240,360 360,690 690,840
page out the disk. What

2885
01:14:05,260 --> 01:14:06,280
0,260
happens?|
|

2886
01:14:08,590 --> 01:14:09,285
0,260 260,350 350,425 425,515 515,695
Assuming we were not using
假设我们没有使用直接IO。

2887
01:14:09,285 --> 01:14:10,440
0,210 210,360 360,635
direct I O.|
|

2888
01:14:12,830 --> 01:14:13,765
0,275 275,485 485,710 710,845 845,935
The page lands in the
页面位于操作系统页面缓存中，因为操作系统试图变得更聪明，并试图让事情变得更快，对吗？

2889
01:14:13,765 --> 01:14:15,415
0,165 165,375 375,695 1225,1485 1485,1650
OS page cache because the

2890
01:14:15,415 --> 01:14:16,030
0,165 165,300 300,435 435,540 540,615
operating system is trying to

2891
01:14:16,030 --> 01:14:16,630
0,120 120,300 300,450 450,540 540,600
be clever and trying to

2892
01:14:16,630 --> 01:14:17,520
0,105 105,270 270,495 495,660 660,890
make things fast for you,

2893
01:14:17,570 --> 01:14:18,720
0,400
right?|
|

2894
01:14:19,990 --> 01:14:20,985
0,245 245,425 425,590 590,710 710,995
So is it on disk
那么它已经存储在磁盘上了吗？当我得到当我得到当f写返回时，是我的，是我的数据保存吗？

2895
01:14:20,985 --> 01:14:22,185
0,245 355,690 690,870 870,1035 1035,1200
yet? When I get when

2896
01:14:22,185 --> 01:14:23,295
0,90 90,285 285,600 600,855 855,1110
I get when f write

2897
01:14:23,295 --> 01:14:24,945
0,365 445,780 780,1005 1005,1295 1405,1650
returns, is is my, is

2898
01:14:24,945 --> 01:14:26,380
0,120 120,330 330,665
my data save?|
|

2899
01:14:26,390 --> 01:14:28,000
0,400 1080,1325 1400,1460 1460,1535 1535,1610
No, because it's in the
不，因为它在美国页面缓存中。

2900
01:14:28,000 --> 01:14:29,400
0,135 135,330 330,650
us page cache.|
|

2901
01:14:29,400 --> 01:14:29,805
0,120 120,225 225,300 300,360 360,405
When is it going to
它将在什么时候刷新磁盘？

2902
01:14:29,805 --> 01:14:30,740
0,75 75,225 225,345 345,465 465,935
be flush out the disk?|
|

2903
01:14:32,610 --> 01:14:33,605
0,260 260,365 365,515 515,845 845,995
When the o decides to
当组织决定把它做好的时候。

2904
01:14:33,605 --> 01:14:35,520
0,105 105,365 685,1085
do it right.|
|

2905
01:14:36,080 --> 01:14:37,480
0,400 540,890 890,1145 1145,1310 1310,1400
But that we want to
但我们想要确保我们的东西在磁盘上，那么我们叫S同步什么？

2906
01:14:37,480 --> 01:14:38,110
0,120 120,255 255,360 360,510 510,630
make sure our thing on

2907
01:14:38,110 --> 01:14:38,845
0,375 375,510 510,600 600,645 645,735
disk, so what do we

2908
01:14:38,845 --> 01:14:40,300
0,225 225,480 480,845
call s sync?|
|

2909
01:14:41,330 --> 01:14:42,270
0,230 230,305 305,440 440,665 665,940
What does f sync do?|
F同步是做什么的？|

2910
01:14:44,290 --> 01:14:47,835
0,430 960,1280 1280,1570 2910,3230 3230,3545
Flush, flush, what dirty pages
刷新，刷新，清除磁盘上的脏页面，您就可以变得聪明了。你差不多是这样的。范围，对吧？并不总是起作用，然后对f同步的调用将被阻止。

2911
01:14:47,835 --> 01:14:48,585
0,270 270,405 405,660 660,720 720,750
out the disk and you

2912
01:14:48,585 --> 01:14:49,485
0,60 60,225 225,480 480,690 690,900
can be clever. You kind

2913
01:14:49,485 --> 01:14:50,720
0,165 165,240 240,360 360,840 840,1235
kind of do. Ranges, right?

2914
01:14:50,950 --> 01:14:53,430
0,320 320,455 455,730 1980,2255 2255,2480
Doesn't always work and then

2915
01:14:53,430 --> 01:14:54,435
0,270 270,525 525,675 675,795 795,1005
the call to f sync

2916
01:14:54,435 --> 01:14:55,640
0,150 150,455
will block.|
|

2917
01:14:55,940 --> 01:14:57,990
0,400 1050,1310 1310,1490 1490,1730 1730,2050
Until the hardware comes access,
在硬件访问之前，您的数据是持久的。

2918
01:14:58,220 --> 01:14:59,940
0,260 260,410 410,545 545,1090
your data is persistent.|
|

2919
01:15:00,130 --> 01:15:01,050
0,260 260,410 410,620 620,785 785,920
Now, the hardware can play
现在，硬件也可以玩游戏了，因为有时硬件下面有一个小电池。所以你会得到你的权利，那仍然是坐着的，易失性的记忆。但如果有一种力量，你可以，你可以发送回复，我得到了，我得到了你的权利。但随后就会出现断电。有足够的电池电量，然后确保它被写入磁盘，对吗？所以它不是。

2920
01:15:01,050 --> 01:15:02,085
0,240 240,495 495,660 660,855 855,1035
games too, because sometimes the

2921
01:15:02,085 --> 01:15:02,940
0,195 195,405 405,480 480,585 585,855
hardware has a little battery

2922
01:15:02,940 --> 01:15:04,755
0,285 285,590 970,1365 1365,1695 1695,1815
down there. So you'll get

2923
01:15:04,755 --> 01:15:05,820
0,150 150,375 375,675 675,840 840,1065
your rights, that's still sitting,

2924
01:15:05,820 --> 01:15:07,200
0,390 390,650 910,1140 1140,1215 1215,1380
volatile memory. But if there's

2925
01:15:07,200 --> 01:15:08,280
0,120 120,405 405,705 705,915 915,1080
a power and you, you

2926
01:15:08,280 --> 01:15:09,075
0,195 195,375 375,510 510,645 645,795
can, you can send in

2927
01:15:09,075 --> 01:15:10,005
0,195 195,390 390,570 570,765 765,930
response to, I got, I

2928
01:15:10,005 --> 01:15:11,265
0,105 105,240 240,515 925,1170 1170,1260
got your right. But then

2929
01:15:11,265 --> 01:15:12,210
0,135 135,240 240,450 450,705 705,945
there's a power loss. There's

2930
01:15:12,210 --> 01:15:13,605
0,150 150,405 405,735 735,1130 1150,1395
just enough battery juice to

2931
01:15:13,605 --> 01:15:14,420
0,195 195,420 420,525 525,585 585,815
then make sure it gets

2932
01:15:14,470 --> 01:15:15,980
0,290 290,455 455,590 590,1115 1115,1510
gets written to disk, right?

2933
01:15:16,570 --> 01:15:18,560
0,380 380,860 860,1240
So it's not.|
|

2934
01:15:18,560 --> 01:15:19,775
0,350 610,900 900,1035 1035,1125 1125,1215
Not always me on the
在那个时刻，我并不总是在NAND闪存上，但是。

2935
01:15:19,775 --> 01:15:20,890
0,195 195,420 420,585 585,780 780,1115
nand flash at that point,

2936
01:15:21,090 --> 01:15:22,040
0,400
but.|
|

2937
01:15:22,235 --> 01:15:23,620
0,165 165,240 240,375 375,665
Typically, that's good enough.|
通常，这已经足够好了。|

2938
01:15:24,230 --> 01:15:25,165
0,260 260,380 380,575 575,770 770,935
But what happens if f
但是，如果f同步调用失败会发生什么呢？FFSync说我不能为你做什么？

2939
01:15:25,165 --> 01:15:26,995
0,195 195,330 330,480 480,755 1585,1830
sync calls a failure? What

2940
01:15:26,995 --> 01:15:27,775
0,105 105,270 270,480 480,630 630,780
F F sync says I

2941
01:15:27,775 --> 01:15:28,530
0,225 225,300 300,405 405,510 510,755
can't do it for you?|
|

2942
01:15:30,630 --> 01:15:31,940
0,245 245,320 320,440 440,730
What does that mean?|
那是什么意思？|

2943
01:15:36,030 --> 01:15:37,120
0,275 275,380 380,530 530,815 815,1090
Say the OS doesn't crash.
假设操作系统没有崩溃。同步只是返回一个错误。

2944
01:15:38,040 --> 01:15:39,220
0,455 455,620 620,815 815,935 935,1180
Sync just returns an error.|
|

2945
01:15:44,660 --> 01:15:46,340
0,305 305,730
In Linux.|
在Linux上。|

2946
01:15:46,340 --> 01:15:46,925
0,240 240,300 300,360 360,465 465,585
It's going to Mark the
它会标明脏页是干净的。这不是内核恐慌。它说这些页面是干净的，即使f同步失败了。然后再次调用f同步。它将拥有你想要写的那些页面。那张光盘穿过了你的f，对吗？它会回来说，是的，我拿到了。

2947
01:15:46,925 --> 01:15:48,845
0,150 150,375 375,570 570,845 1585,1920
dirty pages are clean. It's

2948
01:15:48,845 --> 01:15:49,760
0,90 90,195 195,435 435,765 765,915
not a kernel panic. It

2949
01:15:49,760 --> 01:15:50,800
0,195 195,405 405,585 585,765 765,1040
says these pages are clean,

2950
01:15:51,240 --> 01:15:52,240
0,275 275,410 410,545 545,725 725,1000
even though f sync failed.

2951
01:15:52,890 --> 01:15:53,630
0,245 245,335 335,440 440,575 575,740
And then you call f

2952
01:15:53,630 --> 01:15:55,600
0,285 285,650 1240,1605 1605,1710 1710,1970
sync again. It's going to

2953
01:15:55,800 --> 01:15:56,735
0,275 275,440 440,680 680,860 860,935
own those pages that you

2954
01:15:56,735 --> 01:15:57,370
0,90 90,150 150,240 240,375 375,635
want to write. That disc

2955
01:15:57,510 --> 01:15:58,450
0,290 290,410 410,485 485,635 635,940
put through your f, right?

2956
01:15:58,740 --> 01:15:59,480
0,365 365,440 440,515 515,620 620,740
It's going to come back

2957
01:15:59,480 --> 01:16:00,155
0,105 105,210 210,360 360,525 525,675
and say, yep, I got

2958
01:16:00,155 --> 01:16:00,920
0,275
them.|
|

2959
01:16:01,190 --> 01:16:02,920
0,90 90,350 1125,1185 1185,1290 1290,1730
They're clean, it's on disk.|
它们是干净的，在磁盘上。|

2960
01:16:03,560 --> 01:16:04,330
0,45 45,90 90,360 360,540 540,770
But it's aligned to you.|
但它与你保持一致。|

2961
01:16:05,440 --> 01:16:06,740
0,400
Right.|
正确的。|

2962
01:16:06,900 --> 01:16:07,700
0,260 260,365 365,470 470,650 650,800
Why is it lying to
它为什么要对你撒谎？

2963
01:16:07,700 --> 01:16:08,800
0,230
you?|
|

2964
01:16:11,090 --> 01:16:12,235
0,275 275,410 410,710 710,950 950,1145
Because the kernel developers are
因为内核开发人员担心有人拔出美国B棒，对吗？然后f同步失败，在它的页面表中有一堆污秽的页面被标记为脏的，这些页面再也不会回来了，因为你再也不会把U盘放回去了，对吗？

2965
01:16:12,235 --> 01:16:13,240
0,180 180,435 435,675 675,870 870,1005
worried about someone pulling out

2966
01:16:13,240 --> 01:16:15,060
0,120 225,345 345,555 555,890 1420,1820
a US b stick, right?

2967
01:16:15,440 --> 01:16:16,495
0,275 275,425 425,560 560,755 755,1055
And then the f sync

2968
01:16:16,495 --> 01:16:18,025
0,545 715,1035 1035,1260 1260,1410 1410,1530
failing and having a bunch

2969
01:16:18,025 --> 01:16:20,490
0,275 1045,1445 1555,1890 1890,2145 2145,2465
of dirt pages marked dirty

2970
01:16:20,840 --> 01:16:21,805
0,275 275,425 425,560 560,725 725,965
in its in its page

2971
01:16:21,805 --> 01:16:23,185
0,335 655,900 900,1020 1020,1200 1200,1380
table that are never gonna

2972
01:16:23,185 --> 01:16:24,445
0,275 385,645 645,840 840,1095 1095,1260
get come back again because

2973
01:16:24,445 --> 01:16:24,955
0,120 120,195 195,300 300,405 405,510
you're never gonna put the

2974
01:16:24,955 --> 01:16:26,100
0,345 345,510 510,675 675,855 855,1145
usb stick back in again,

2975
01:16:26,390 --> 01:16:27,500
0,400
right?|
|

2976
01:16:27,630 --> 01:16:28,325
0,245 245,365 365,470 470,560 560,695
Is that the right thing
这对数据库来说是正确的吗？不，对，我们不是在用U盘。

2977
01:16:28,325 --> 01:16:31,715
0,135 135,725 1615,2015 2095,2495 3085,3390
for databases? No, right, we're

2978
01:16:31,715 --> 01:16:33,275
0,75 75,335 835,1095 1095,1215 1215,1560
not running off a usb

2979
01:16:33,275 --> 01:16:34,460
0,305
stick.|
|

2980
01:16:35,150 --> 01:16:36,325
0,260 260,455 455,680 680,890 890,1175
So again, we need full
因此，我们需要完全控制一切，以确保我们做的事情是正确的。

2981
01:16:36,325 --> 01:16:37,495
0,300 300,635 715,975 975,1065 1065,1170
control of everything to make

2982
01:16:37,495 --> 01:16:38,310
0,120 120,240 240,345 345,525 525,815
sure we're doing things right.|
|

2983
01:16:39,220 --> 01:16:40,740
0,225 225,450 450,645 645,950 1120,1520
Well, it turns out that
原来，二十年来人们都不知道那个同步信号是这样坏掉的。

2984
01:16:41,090 --> 01:16:42,610
0,305 305,560 560,785 785,1150 1200,1520
people didn't know that that

2985
01:16:42,610 --> 01:16:43,480
0,210 210,375 375,495 495,705 705,870
f sync was broken in

2986
01:16:43,480 --> 01:16:44,880
0,120 120,410 430,795 795,1080 1080,1400
this way for twenty years.|
|

2987
01:16:45,890 --> 01:16:48,040
0,260 260,395 395,880 1350,1750 1890,2150
So in 2018 eh, there
所以在2018年，呃，有一起名为f sync gate的丑闻，在postg嘉宾邮件列表上有人报告说，嘿，postgres丢失了我的一些数据。但是我，你知道的，我从来没有遇到过内核恐慌。我从来没有失败过。

2988
01:16:48,040 --> 01:16:49,405
0,120 120,380 520,945 945,1140 1140,1365
was a scandal called f

2989
01:16:49,405 --> 01:16:51,580
0,240 240,515 775,1170 1170,1565 1915,2175
sync gate where someone on

2990
01:16:51,580 --> 01:16:52,530
0,105 105,315 315,405 405,690 690,950
the postg guest mailing list

2991
01:16:53,210 --> 01:16:55,150
0,335 335,670 1020,1475 1475,1730 1730,1940
reported, hey, postgres lost some

2992
01:16:55,150 --> 01:16:57,145
0,75 75,210 210,500 1420,1755 1755,1995
of my data. But I,

2993
01:16:57,145 --> 01:16:57,745
0,165 165,255 255,330 330,465 465,600
you know, I never got

2994
01:16:57,745 --> 01:16:58,735
0,105 105,345 345,600 600,780 780,990
a kernel panic. I never

2995
01:16:58,735 --> 01:17:00,200
0,120 120,330 330,695
had a failure.|
|

2996
01:17:00,200 --> 01:17:01,550
0,150 150,255 255,435 435,740 1030,1350
And it turns out, because
事实证明，因为S是同步的。

2997
01:17:01,550 --> 01:17:03,000
0,270 270,740
s sync.|
|

2998
01:17:03,000 --> 01:17:04,010
0,210 210,330 330,465 465,675 675,1010
On all these database systems,
在所有这些数据库系统上，他们会调用f同步，f同步会返回错误，他们只是将其放入While循环中，并再次调用它。然后f sync回来说，是的，我得到了它，因为他们标记了你的页面是脏的，需要清理，尽管它们从来没有写过。

2999
01:17:04,060 --> 01:17:05,070
0,260 260,380 380,530 530,740 740,1010
they would call f sync,

3000
01:17:05,070 --> 01:17:05,805
0,180 180,345 345,480 480,630 630,735
f sync would return to

3001
01:17:05,805 --> 01:17:06,765
0,245 385,645 645,735 735,840 840,960
error and they just put

3002
01:17:06,765 --> 01:17:07,550
0,75 75,150 150,255 255,450 450,785
it in a while loop

3003
01:17:07,840 --> 01:17:09,495
0,305 305,485 485,650 650,940 1410,1655
and call it again. And

3004
01:17:09,495 --> 01:17:10,380
0,210 210,465 465,645 645,765 765,885
then f sync came back

3005
01:17:10,380 --> 01:17:11,070
0,90 90,210 210,375 375,525 525,690
and said, yep, I got

3006
01:17:11,070 --> 01:17:11,940
0,240 240,450 450,570 570,720 720,870
it because they marked out

3007
01:17:11,940 --> 01:17:13,095
0,135 135,410 520,780 780,915 915,1155
your pages that were dirty

3008
01:17:13,095 --> 01:17:13,995
0,240 240,435 435,645 645,795 795,900
to clean even though they

3009
01:17:13,995 --> 01:17:15,180
0,105 105,255 255,545
were never written.|
|

3010
01:17:15,460 --> 01:17:16,440
0,305 305,380 380,530 530,860 860,980
It's not just postgres had
不仅仅是Postgres有这个问题，我的SQL也有这个问题。魔神数据库也有这个问题，于是给老虎装了一堆其他的系统。

3011
01:17:16,440 --> 01:17:17,175
0,120 120,270 270,435 435,645 645,735
this problem, my sql had

3012
01:17:17,175 --> 01:17:18,165
0,120 120,345 345,690 690,885 885,990
this problem. Mongod DB had

3013
01:17:18,165 --> 01:17:19,130
0,120 120,285 285,450 450,645 645,965
this problem and wire tiger

3014
01:17:19,360 --> 01:17:20,270
0,245 245,365 365,470 470,605 605,910
a bunch of other systems.|
|

3015
01:17:21,140 --> 01:17:21,860
0,225 225,390 390,540 540,615 615,720
So now what do they
那么现在他们要做什么呢？

3016
01:17:21,860 --> 01:17:22,960
0,260
do?|
|

3017
01:17:22,960 --> 01:17:24,430
0,345 345,615 615,825 825,1185 1185,1470
Well, if sync fails, then
嗯，如果同步失败，那么系统就会崩溃，然后你就得弄清楚到底是怎么回事。

3018
01:17:24,430 --> 01:17:25,735
0,255 255,375 375,540 540,1080 1080,1305
then the system crashes, and

3019
01:17:25,735 --> 01:17:26,215
0,90 90,195 195,300 300,375 375,480
then you got to go

3020
01:17:26,215 --> 01:17:27,270
0,135 135,360 360,645 645,765 765,1055
figure out what's going on.|
|

3021
01:17:28,310 --> 01:17:29,635
0,260 260,410 410,620 620,940 1020,1325
But for twenty years, people
但二十年来，人们并不知道这是一个问题。

3022
01:17:29,785 --> 01:17:30,385
0,60 60,165 165,345 345,495 495,600
didn't know this was an

3023
01:17:30,385 --> 01:17:31,360
0,245
issue.|
|

3024
01:17:33,010 --> 01:17:34,320
0,400
Right.|
正确的。|

3025
01:17:34,320 --> 01:17:35,475
0,270 270,525 525,765 765,915 915,1155
And so this is not
所以这不是页面缓存的问题，而是我们需要确保完全控制从磁盘读取和写入内存的内容，以及当我们将内容写出磁盘时，我们希望确保它实际上是安全和正确的。

3026
01:17:35,475 --> 01:17:36,735
0,225 225,465 465,795 795,1035 1035,1260
an issue of the page

3027
01:17:36,735 --> 01:17:38,055
0,365 475,825 825,1050 1050,1155 1155,1320
cache, but this is an

3028
01:17:38,055 --> 01:17:39,705
0,330 330,725 1045,1320 1320,1500 1500,1650
example where we need to

3029
01:17:39,705 --> 01:17:40,545
0,135 135,285 285,390 390,540 540,840
make sure we have full

3030
01:17:40,545 --> 01:17:42,465
0,315 315,555 555,875 1105,1505 1585,1920
control of what is getting

3031
01:17:42,465 --> 01:17:43,500
0,240 240,405 405,585 585,795 795,1035
read and written from disk

3032
01:17:43,500 --> 01:17:45,105
0,120 120,410 940,1200 1200,1380 1380,1605
into memory, and that when

3033
01:17:45,105 --> 01:17:46,170
0,195 195,420 420,705 705,930 930,1065
we write things out the

3034
01:17:46,170 --> 01:17:47,145
0,345 345,615 615,795 795,870 870,975
disk, we want to make

3035
01:17:47,145 --> 01:17:48,080
0,150 150,270 270,480 480,660 660,935
sure that it's actually safe

3036
01:17:48,400 --> 01:17:49,620
0,335 335,670
and correct.|
|

3037
01:17:49,930 --> 01:17:51,045
0,260 260,365 365,545 545,860 860,1115
And that the OS can
操作系统可能会对我们撒谎，因为操作系统不关心数据库，因为操作系统担心，你知道，有人带着U盘或其他什么东西，因为它试图成为一个通用系统。

3038
01:17:51,045 --> 01:17:52,095
0,165 165,285 285,515 565,840 840,1050
lie to us because the

3039
01:17:52,095 --> 01:17:53,420
0,240 240,495 495,600 600,705 705,1325
OS doesn't care about databases,

3040
01:17:53,890 --> 01:17:54,720
0,245 245,380 380,530 530,650 650,830
because the OS is worried

3041
01:17:54,720 --> 01:17:56,760
0,320 850,1095 1095,1245 1245,1550 1780,2040
about, you know, somebody with

3042
01:17:56,760 --> 01:17:58,280
0,105 105,540 540,840 840,1170 1170,1520
a usb stick or whatever,

3043
01:17:58,870 --> 01:17:59,550
0,245 245,410 410,500 500,605 605,680
because it's trying to be

3044
01:17:59,550 --> 01:18:01,200
0,105 105,330 330,615 615,950
a general purpose system.|
|

3045
01:18:01,210 --> 01:18:01,845
0,260 260,365 365,470 470,560 560,635
And so we need to
因此，我们需要确保我们作为日常系统开发人员，将机制放在适当的位置，以确保我们不会，我们不会被搞砸。

3046
01:18:01,845 --> 01:18:03,075
0,165 165,405 405,720 720,1050 1050,1230
make sure that we, as

3047
01:18:03,075 --> 01:18:04,845
0,90 90,210 210,435 435,785 1525,1770
a daily system developers, put

3048
01:18:04,845 --> 01:18:05,820
0,90 90,540 540,675 675,840 840,975
the mechanisms in place to

3049
01:18:05,820 --> 01:18:06,540
0,120 120,285 285,420 420,540 540,720
make sure that we don't,

3050
01:18:06,540 --> 01:18:08,120
0,120 120,270 270,405 405,830
we don't get screwed.|
|

3051
01:18:10,590 --> 01:18:11,640
0,400
Okay.|
好吧。|

3052
01:18:12,370 --> 01:18:14,235
0,245 245,490 690,1090 1320,1640 1640,1865
All right. So there's marble
好的。所以除了我们所说的以外，还有其他的大理石洞。想想看，连接的临时缓存之类的东西。我们稍后会看到这一点。好吧?

3053
01:18:14,235 --> 01:18:15,750
0,240 240,510 510,815 895,1290 1290,1515
holes other than than what

3054
01:18:15,750 --> 01:18:16,995
0,135 135,240 240,530 850,1095 1095,1245
we've talked about. Just think,

3055
01:18:16,995 --> 01:18:18,315
0,390 390,780 780,960 960,1230 1230,1320
ephemeral caches for joins and

3056
01:18:18,315 --> 01:18:19,110
0,105 105,210 210,420 420,720 720,795
things like that. We'll see

3057
01:18:19,110 --> 01:18:20,820
0,90 90,350 760,1160
that later. Okay?|
|

3058
01:18:20,820 --> 01:18:22,530
0,290 820,1200 1200,1455 1455,1575 1575,1710
So we always be better
所以我们总是比操作系统更好，不管Linux的人怎么说OS的人说什么。这是因为我们知道查询计划要做什么。我们知道查询如何访问数据，我们总是可以做更好的事情。

3059
01:18:22,530 --> 01:18:23,850
0,120 120,240 240,420 420,710 1060,1320
than the operating system, despite

3060
01:18:23,850 --> 01:18:24,770
0,105 105,195 195,420 420,600 600,920
what the Linux people say

3061
01:18:25,390 --> 01:18:27,890
0,260 260,380 380,560 560,880 2100,2500
the OS people say. And

3062
01:18:28,180 --> 01:18:29,355
0,320 320,455 455,620 620,905 905,1175
it's because we know what

3063
01:18:29,355 --> 01:18:30,570
0,135 135,345 345,665 805,1080 1080,1215
the query plans are want

3064
01:18:30,570 --> 01:18:31,380
0,105 105,255 255,420 420,555 555,810
to do. We know how

3065
01:18:31,380 --> 01:18:33,345
0,645 645,825 825,1035 1035,1310 1570,1965
queries want access data and

3066
01:18:33,345 --> 01:18:34,350
0,240 240,375 375,525 525,735 735,1005
we can always do better

3067
01:18:34,350 --> 01:18:35,980
0,320
things.|
|

3068
01:18:35,980 --> 01:18:37,285
0,225 225,375 375,585 585,890 1090,1305
Hash tables next class. But
下一节课是哈希表。但让我非常非常快地谈谈第一个项目。很明显，您将在公共汽车浴缸中实现这一点。所以你有三个部分L R U K替换策略，一个磁盘时间表，一个非常原始的，然后是实际的水牛管理器实例本身。

3069
01:18:37,285 --> 01:18:37,765
0,60 60,135 135,210 210,315 315,480
let me talk about project

3070
01:18:37,765 --> 01:18:39,270
0,180 180,330 330,480 480,755 1105,1505
one very, very quickly. So

3071
01:18:39,530 --> 01:18:40,630
0,290 290,395 395,755 755,905 905,1100
you'll be implementing this in

3072
01:18:40,630 --> 01:18:42,115
0,195 195,495 495,890 1120,1380 1380,1485
bus tub obviously. And so

3073
01:18:42,115 --> 01:18:43,735
0,75 75,225 225,450 450,755 1345,1620
you have three parts L

3074
01:18:43,735 --> 01:18:44,760
0,135 135,255 255,435 435,765 765,1025
R U K replacement policy,

3075
01:18:45,470 --> 01:18:46,555
0,275 275,530 530,740 740,920 920,1085
a disk schedule, a very

3076
01:18:46,555 --> 01:18:47,800
0,375 375,615 615,855 855,1035 1035,1245
primitive one, and then the

3077
01:18:47,800 --> 01:18:49,200
0,135 135,360 360,620 640,1020 1020,1400
actual buffalo manager instance itself.|
|

3078
01:18:50,380 --> 01:18:52,500
0,225 225,590
Oh shit.|
哦，妈的。|

3079
01:18:53,020 --> 01:18:54,230
0,395 395,650 650,755 755,905 905,1210
So for the first one,
因此，对于第一个，您需要一个单独的类来实现它。基本上跟踪所有页面，然后就有了要实现的人工智能。它说我需要给我，给我一页，给它。

3080
01:18:54,610 --> 01:18:55,785
0,320 320,455 455,665 665,905 905,1175
there'll be a separate class

3081
01:18:55,785 --> 01:18:56,570
0,150 150,195 195,285 285,465 465,785
that you need to implement

3082
01:18:56,800 --> 01:18:57,885
0,245 245,485 485,785 785,965 965,1085
that. Basically keep track of

3083
01:18:57,885 --> 01:18:59,610
0,105 105,360 360,755 1165,1455 1455,1725
all the pages and then

3084
01:18:59,610 --> 01:19:01,170
0,300 300,530 700,945 945,1350 1350,1560
there'll be an AI to

3085
01:19:01,170 --> 01:19:02,150
0,165 165,285 285,480 480,705 705,980
implement. It says I need

3086
01:19:02,320 --> 01:19:03,135
0,260 260,455 455,635 635,710 710,815
give me, give me a

3087
01:19:03,135 --> 01:19:04,480
0,180 180,665
page, toit.|
|

3088
01:19:04,480 --> 01:19:05,230
0,210 210,315 315,435 435,555 555,750
So you sort of implement
因此，您可以先实现它，然后在那里实现。

3089
01:19:05,230 --> 01:19:06,475
0,240 240,555 555,810 810,945 945,1245
that first and then there

3090
01:19:06,475 --> 01:19:08,300
0,455
there.|
|

3091
01:19:08,310 --> 01:19:09,770
0,550 630,875 875,980 980,1265 1265,1460
There's, you know, there's test
有，你知道，有测试，以确保这是真正正确的工作。如果在您检查时没有任何页面被触及，则始终返回最低的页面ID，因为同样，您必须修复一些东西。

3092
01:19:09,770 --> 01:19:10,370
0,120 120,225 225,360 360,465 465,600
to make sure this is

3093
01:19:10,370 --> 01:19:11,720
0,135 135,285 285,590 820,1155 1155,1350
actually working correctly. If none

3094
01:19:11,720 --> 01:19:12,635
0,90 90,210 210,495 495,750 750,915
of the pages have been

3095
01:19:12,635 --> 01:19:14,435
0,305 1075,1350 1350,1470 1470,1605 1605,1800
touched that time you check,

3096
01:19:14,435 --> 01:19:15,635
0,240 240,525 525,840 840,1050 1050,1200
then always return the lowest

3097
01:19:15,635 --> 01:19:17,060
0,180 180,455 565,840 840,1115 1165,1425
page ID because again, you

3098
01:19:17,060 --> 01:19:18,540
0,120 120,240 240,390 390,680
got to fix something.|
|

3099
01:19:18,970 --> 01:19:19,980
0,260 260,440 440,665 665,860 860,1010
And so you decide what
因此，你可以根据这一点来决定该怎么想。

3100
01:19:19,980 --> 01:19:20,810
0,120 120,270 270,435 435,570 570,830
to think based on that.|
|

3101
01:19:22,470 --> 01:19:24,560
0,365 365,665 665,1000 1530,1835 1835,2090
Next, implement as a disk
接下来，实现为磁盘调度器。基本上，您将同时处理一组请求或不同的线程，然后让单个队列决定应用原因权限的顺序。

3102
01:19:24,560 --> 01:19:25,715
0,410 430,765 765,945 945,1050 1050,1155
scheduler. Basically you going take

3103
01:19:25,715 --> 01:19:26,555
0,90 90,225 225,450 450,705 705,840
a bunch of requests or

3104
01:19:26,555 --> 01:19:27,455
0,165 165,525 525,660 660,750 750,900
different threads at the same

3105
01:19:27,455 --> 01:19:28,715
0,305 565,825 825,960 960,1095 1095,1260
time and then have a

3106
01:19:28,715 --> 01:19:31,115
0,285 285,705 705,1085 1825,2160 2160,2400
single queue decide in which

3107
01:19:31,115 --> 01:19:33,440
0,225 225,405 405,585 585,905 2065,2325
order you should apply the

3108
01:19:33,440 --> 01:19:34,760
0,195 195,530
reason rights.|
|

3109
01:19:35,510 --> 01:19:36,370
0,275 275,395 395,515 515,680 680,860
And the way you implement
通过c+Promise AI Promise构造，a pi将会有一个回调机制。这是一个函数，一旦页面，请求者正在等待的数据可用，您就可以回调该数据。它不会是真正的异步。I/O，但Co，Co基本上发出请求的线程将在此回调上阻塞。但这将是做更复杂事情的基石。

3110
01:19:36,370 --> 01:19:37,795
0,210 210,360 360,450 450,800 1120,1425
this, the a pi, there

3111
01:19:37,795 --> 01:19:38,760
0,135 135,195 195,315 315,675 675,965
will be a callback mechanism

3112
01:19:38,870 --> 01:19:40,890
0,400 450,850 960,1205 1205,1450 1620,2020
through the c plus promise

3113
01:19:40,910 --> 01:19:43,270
0,670 840,1175 1175,1660 2010,2255 2255,2360
AI promise constructs. And this

3114
01:19:43,270 --> 01:19:44,275
0,105 105,210 210,420 420,615 615,1005
is a function you invoke

3115
01:19:44,275 --> 01:19:46,405
0,330 330,660 660,945 945,1235 1885,2130
once the the page, the

3116
01:19:46,405 --> 01:19:49,240
0,245 355,755 2035,2355 2355,2640 2640,2835
data that the requester is

3117
01:19:49,240 --> 01:19:51,040
0,195 195,420 420,630 630,950 1540,1800
waiting for is available and

3118
01:19:51,040 --> 01:19:52,375
0,120 120,255 255,405 405,680 1030,1335
you call that back. It's

3119
01:19:52,375 --> 01:19:52,855
0,90 90,180 180,225 225,330 330,480
not going to be true

3120
01:19:52,855 --> 01:19:55,645
0,450 450,585 585,875 2425,2655 2655,2790
asynchronous. I O, but it

3121
01:19:55,645 --> 01:19:57,355
0,305 355,755 775,1065 1065,1355 1375,1710
th Co, Co basically the

3122
01:19:57,355 --> 01:19:58,210
0,240 240,405 405,525 525,690 690,855
thread that makes the request

3123
01:19:58,210 --> 01:19:59,260
0,165 165,470 490,750 750,885 885,1050
will block on this call

3124
01:19:59,260 --> 01:20:00,625
0,290 790,1035 1035,1155 1155,1275 1275,1365
back. But this would be

3125
01:20:00,625 --> 01:20:01,315
0,105 105,285 285,480 480,600 600,690
the building block to do

3126
01:20:01,315 --> 01:20:02,720
0,120 120,585 585,875
more sophisticated things.|
|

3127
01:20:02,760 --> 01:20:03,725
0,245 245,380 380,545 545,755 755,965
So make sure that what
因此，请确保您在这里构建的代码是线程安全的。

3128
01:20:03,725 --> 01:20:05,015
0,135 135,300 300,605 775,1080 1080,1290
you build here is thread

3129
01:20:05,015 --> 01:20:06,180
0,305
safe.|
|

3130
01:20:06,580 --> 01:20:07,500
0,290 290,440 440,560 560,665 665,920
Last thing is the buffer
最后一件事是缓冲区管理器本身，这将建立在L U K实现的基础上，并在您的磁盘调度器中。您还可以维护内部数据结构，以便使用磁盘调度来读写数据，并跟踪哪些页面是空闲的，以及何时访问这些页面。而每年总是让人犯错的一件事是，在你钉和解钉的时候，确保你得到了正确的顺序。

3131
01:20:07,500 --> 01:20:09,075
0,290 370,770 1120,1380 1380,1500 1500,1575
manager itself and this will

3132
01:20:09,075 --> 01:20:09,690
0,90 90,225 225,345 345,480 480,615
be built on top of

3133
01:20:09,690 --> 01:20:10,670
0,105 105,240 240,435 435,660 660,980
the L U K implementation

3134
01:20:10,810 --> 01:20:12,020
0,320 320,485 485,590 590,785 785,1210
and in your disk scheduler.

3135
01:20:12,310 --> 01:20:13,800
0,400 570,815 815,1060 1080,1340 1340,1490
And you maintain the internal

3136
01:20:13,800 --> 01:20:15,210
0,225 225,555 555,950 1030,1305 1305,1410
data structure to read and

3137
01:20:15,210 --> 01:20:16,425
0,120 120,410 640,915 915,1035 1035,1215
write data using the disk

3138
01:20:16,425 --> 01:20:17,310
0,240 240,495 495,630 630,780 780,885
schedule and keep track of

3139
01:20:17,310 --> 01:20:18,015
0,75 75,240 240,435 435,585 585,705
what pages are free and

3140
01:20:18,015 --> 01:20:19,515
0,90 90,330 330,785 1105,1365 1365,1500
when they're accessed. And the

3141
01:20:19,515 --> 01:20:20,250
0,135 135,270 270,420 420,585 585,735
thing that always trips up

3142
01:20:20,250 --> 01:20:21,045
0,180 180,360 360,525 525,660 660,795
people every year is make

3143
01:20:21,045 --> 01:20:22,095
0,150 150,285 285,420 420,660 660,1050
sure you get the ordering

3144
01:20:22,095 --> 01:20:24,105
0,455 1285,1530 1530,1695 1695,1905 1905,2010
correctlyory when you're pinning and

3145
01:20:24,105 --> 01:20:25,100
0,545
unpinning.|
|

3146
01:20:26,350 --> 01:20:29,145
0,400 600,1000 1890,2290 2460,2705 2705,2795
So eh, six might not
所以，嗯，6可能不是正确的数字，但不要更改任何其他文件，因为所有内容都会被覆盖。当你把它装入等级范围时。这些项目是累积性的。我们不会编写解决方案，然后将所有内容发布到Piazza上，就像在零号项目中一样，你必须确保你有良好的代码质量。因此，请确保您运行、制作、格式化，然后选中clang整洁。因为如果你不这样做，你上传灰色范围，你会得到零。

3147
01:20:29,145 --> 01:20:29,745
0,90 90,165 165,270 270,450 450,600
be the right number, but

3148
01:20:29,745 --> 01:20:30,980
0,210 210,450 450,690 690,900 900,1235
don't change any other file

3149
01:20:31,900 --> 01:20:32,820
0,335 335,515 515,620 620,725 725,920
because everything will get over

3150
01:20:32,820 --> 01:20:33,900
0,600 600,750 750,870 870,990 990,1080
overwritten. When you load it

3151
01:20:33,900 --> 01:20:35,070
0,75 75,225 225,435 435,740 910,1170
up into grade scope. The

3152
01:20:35,070 --> 01:20:36,465
0,180 180,495 495,1035 1035,1230 1230,1395
projects are cumulative. We won't

3153
01:20:36,465 --> 01:20:38,475
0,90 90,365 865,1265 1615,1860 1860,2010
be writing solutions and then

3154
01:20:38,475 --> 01:20:40,500
0,305 355,690 690,1025 1435,1725 1725,2025
post everything on on piazza

3155
01:20:40,500 --> 01:20:42,135
0,90 90,195 195,345 345,650 1360,1635
as you go along, like

3156
01:20:42,135 --> 01:20:43,005
0,150 150,390 390,675 675,825 825,870
in project zero, you have

3157
01:20:43,005 --> 01:20:43,470
0,45 45,150 150,270 270,360 360,465
to make sure you have

3158
01:20:43,470 --> 01:20:44,745
0,165 165,375 375,680 910,1155 1155,1275
good code quality. So make

3159
01:20:44,745 --> 01:20:45,645
0,105 105,195 195,360 360,585 585,900
sure you run, make, format

3160
01:20:45,645 --> 01:20:47,840
0,255 255,515 1195,1485 1485,1695 1695,2195
and then check clang tidy.

3161
01:20:48,430 --> 01:20:49,620
0,365 365,575 575,785 785,1085 1085,1190
Because if you don't do

3162
01:20:49,620 --> 01:20:50,385
0,180 180,330 330,405 405,645 645,765
this and you upload the

3163
01:20:50,385 --> 01:20:51,570
0,150 150,455 715,1035 1035,1095 1095,1185
gray scope, you'll get a

3164
01:20:51,570 --> 01:20:52,380
0,260
zero.|
|

3165
01:20:52,470 --> 01:20:56,225
0,400 1470,1730 1730,1850 1850,2110 3510,3755
EM, we are having for
嗯，我们有这个项目和所有其他项目，将有额外的学分。有一个排行榜，上面有超出核心要求的额外任务，然后当你的东西在年级范围内时，你会得到排名，然后排名前20的学生将获得这个项目的加分。

3166
01:20:56,225 --> 01:20:57,020
0,165 165,405 405,570 570,690 690,795
this project and all the

3167
01:20:57,020 --> 01:20:57,785
0,120 120,330 330,525 525,585 585,765
other projects, there'll be extra

3168
01:20:57,785 --> 01:20:59,015
0,285 285,645 645,750 750,975 975,1230
credit. There's a leader board

3169
01:20:59,015 --> 01:21:00,890
0,270 270,525 525,810 810,1205 1615,1875
with the additional tasks that

3170
01:21:00,890 --> 01:21:01,990
0,195 195,420 420,570 570,765 765,1100
go beyond the core requirements

3171
01:21:02,520 --> 01:21:03,560
0,245 245,350 350,530 530,665 665,1040
and then you'll get ranked

3172
01:21:03,560 --> 01:21:05,135
0,150 150,410 1090,1350 1350,1455 1455,1575
when you your thing on

3173
01:21:05,135 --> 01:21:06,680
0,195 195,515 865,1110 1110,1260 1260,1545
grade scope and then the

3174
01:21:06,680 --> 01:21:07,865
0,255 255,435 435,675 675,960 960,1185
the top twenty students will

3175
01:21:07,865 --> 01:21:09,680
0,275 895,1155 1155,1305 1305,1635 1635,1815
get will get bonus points

3176
01:21:09,680 --> 01:21:10,860
0,165 165,300 300,590
for this project.|
|

3177
01:21:10,860 --> 01:21:11,565
0,240 240,345 345,420 420,510 510,705
And this will be available
这将适用于所有四个项目，然后在学期末的学生有最高的奖励分数，所有的学生都将获得一件限量版BUSUB连帽衫。因为是限量版，所以你得填一张税单。他们花了5000美元，而且看起来你能处理好这方面的文书工作。但这是非常可取的。不要到处抄袭，因为灰色示波器又一次有自动房间检查器，我们去找Randosol GitHub。我们把他们当作假学生，如果你抄袭他们，你会得到是的，现在听着，我是罂粟花，他妈的钩子28克，这取决于你是否还没有打击暴徒，但仍然必须闭嘴。我用垫底的母亲打你。

3178
01:21:11,565 --> 01:21:13,080
0,180 180,330 330,510 510,785 1255,1515
for all four projects and

3179
01:21:13,080 --> 01:21:13,830
0,135 135,300 300,480 480,645 645,750
then the student at the

3180
01:21:13,830 --> 01:21:14,550
0,75 75,150 150,210 210,465 465,720
end of the semester has

3181
01:21:14,550 --> 01:21:16,340
0,290 430,705 705,855 855,1130 1390,1790
the has the highest score

3182
01:21:17,110 --> 01:21:18,390
0,275 275,560 560,740 740,1010 1010,1280
of bonus points and all

3183
01:21:18,390 --> 01:21:19,260
0,195 195,420 420,615 615,720 720,870
the students will get a

3184
01:21:19,260 --> 01:21:21,945
0,240 240,570 570,1035 1035,1430 2440,2685
limited edition busub hoodie. You

3185
01:21:21,945 --> 01:21:22,410
0,90 90,180 180,255 255,330 330,465
have to fill out a

3186
01:21:22,410 --> 01:21:23,520
0,255 255,585 585,795 795,930 930,1110
tax form because they're limited

3187
01:21:23,520 --> 01:21:25,320
0,350 670,930 930,1095 1095,1500 1500,1800
edition. They cost 5000 dollars

3188
01:21:25,320 --> 01:21:26,190
0,255 255,465 465,660 660,765 765,870
and again seem you will

3189
01:21:26,190 --> 01:21:28,275
0,165 165,470 1420,1665 1665,1980 1980,2085
handle that the paperwork for

3190
01:21:28,275 --> 01:21:30,650
0,245 265,495 495,1515 1515,1770 1770,2375
that. But it's highly desirable.

3191
01:21:31,330 --> 01:21:33,210
0,395 395,740 740,1010 1010,1480 1590,1880
Don around don't plagiarize because

3192
01:21:33,210 --> 01:21:35,295
0,290 670,1070 1420,1740 1740,1935 1935,2085
again the gray scope has

3193
01:21:35,295 --> 01:21:36,920
0,225 225,575 625,945 945,1155 1155,1625
the automatic pl room checker

3194
01:21:37,060 --> 01:21:37,950
0,260 260,365 365,515 515,725 725,890
and we go find the

3195
01:21:37,950 --> 01:21:39,600
0,525 525,980 1180,1440 1440,1560 1560,1650
randosol github. We put them

3196
01:21:39,600 --> 01:21:40,545
0,120 120,330 330,615 615,840 840,945
as fake students and if

3197
01:21:40,545 --> 01:21:42,380
0,120 120,330 330,665 895,1185 1185,1835
you copy them you'll getged

3198
01:22:00,670 --> 01:22:02,445
0,400 450,755 755,1060 1290,1655 1655,1775
yeah, now listen, I'm the

3199
01:22:02,445 --> 01:22:04,070
0,360 360,510 510,675 675,1350 1350,1625
poppy with the motherfucking hook

3200
01:22:04,390 --> 01:22:06,090
0,530 530,725 725,1060 1140,1475 1475,1700
28 a gram depending on

3201
01:22:06,090 --> 01:22:07,635
0,165 165,530 940,1200 1200,1425 1425,1545
if it's you ain't hit

3202
01:22:07,635 --> 01:22:08,940
0,150 150,345 345,665 805,1110 1110,1305
the mob yet still got

3203
01:22:08,940 --> 01:22:10,080
0,195 195,375 375,600 600,885 885,1140
to shut up. I smack

3204
01:22:10,080 --> 01:22:11,090
0,135 135,255 255,420 420,660 660,1010
you with the bottom mother.|
|

3205
01:22:11,140 --> 01:22:12,300
0,270 270,495 495,675 675,870 870,1160
Let tell you look up
让我告诉你抬起头来，让我看看你的脸被打回去有多安全。我拿到了兽医无法追踪的积木板窃听器。Thatyl是大便的T。你不能在多米尼加，或者你们叫我多米尼加黑皮黑皮革黑松木，我整个黑色肮脏的8号把你送到佩尔大门。你得到了中国的冠军，这是你的第一个错误。我自始至终都在称重。

3206
01:22:12,440 --> 01:22:13,330
0,275 275,425 425,545 545,680 680,890
show me what a safe

3207
01:22:13,330 --> 01:22:14,350
0,270 270,480 480,645 645,825 825,1020
at for a blow your

3208
01:22:14,350 --> 01:22:15,475
0,270 270,585 585,810 810,945 945,1125
face back. I got a

3209
01:22:15,475 --> 01:22:17,140
0,465 465,765 765,1005 1005,1335 1335,1665
blockboard taps the vets can't

3210
01:22:17,140 --> 01:22:18,730
0,210 210,870 870,1035 1035,1275 1275,1590
trace. Thatyl is like t

3211
01:22:18,730 --> 01:22:19,990
0,255 255,525 525,765 765,1065 1065,1260
for poop. You can't lace

3212
01:22:19,990 --> 01:22:21,490
0,165 165,330 330,480 480,1245 1245,1500
that at the Dominican or

3213
01:22:21,490 --> 01:22:23,050
0,165 165,420 420,675 675,825 825,1560
you guys call me Dominican

3214
01:22:23,050 --> 01:22:24,790
0,345 345,780 780,1050 1050,1455 1455,1740
black sclly black leather black

3215
01:22:24,790 --> 01:22:26,425
0,345 345,855 855,1050 1050,1305 1305,1635
sued timberins my whole black

3216
01:22:26,425 --> 01:22:27,520
0,300 300,525 525,735 735,930 930,1095
dirty eight to send you

3217
01:22:27,520 --> 01:22:28,855
0,135 135,285 285,555 555,920 1060,1335
to the per gates. You

3218
01:22:28,855 --> 01:22:30,160
0,135 135,630 630,870 870,1155 1155,1305
get youravat China skate and

3219
01:22:30,160 --> 01:22:31,740
0,195 195,315 315,585 585,980 1180,1580
that's your first mistake. I

3220
01:22:32,360 --> 01:22:35,280
0,400 1020,1420 1500,1900 2280,2600 2600,2920
take weight my weight the

3221
01:22:35,300 --> 01:22:43,915
0,400
through.|
|
