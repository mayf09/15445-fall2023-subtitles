1
00:00:25,360 --> 00:00:27,620
0,350 350,620 620,1150 1560,1985 1985,2260
Thank you, DJ, {that's,great -}.|
谢谢， DJ ，太好了。|

2
00:00:28,260 --> 00:00:30,185
0,400 450,725 725,875 875,1150 1590,1925
So did you have any
那么，你还有没有观众，

3
00:00:30,185 --> 00:00:33,290
0,545 565,965 1705,2105 2485,2895 2895,3105
takers| for your tiki bar
|在你的 tiki 酒吧和其他你必须去做的表演？

4
00:00:33,290 --> 00:00:34,625
0,255 255,450 450,585 585,795 795,1335
thing and the other performances

5
00:00:34,625 --> 00:00:39,040
0,135 135,255 255,515 1105,1505
that you had? {}|
|

6
00:00:40,090 --> 00:00:42,045
0,400 570,875 875,1205 1205,1480 1620,1955
Okay, okay, that's great.| {All,right\,
好的，太好了。|好的，所以我们要开始了，

7
00:00:42,045 --> 00:00:43,830
0,335 595,995 1165,1515 1515,1635 1635,1785
so -} we're going to

8
00:00:43,830 --> 00:00:47,415
0,165 165,470 670,1070 2860,3255 3255,3585
get started| and needed to
|需要清理上一节课的一些东西。

9
00:00:47,415 --> 00:00:48,675
0,225 225,495 495,765 765,990 990,1260
clean up a couple things

10
00:00:48,675 --> 00:00:51,225
0,335 535,870 870,1185 1185,1565 2215,2550
that from {last,lecture -}.| Remember
|记得这张幻灯片，

11
00:00:51,225 --> 00:00:52,200
0,255 255,525 525,750 750,870 870,975
this slide,| where we are
|我们查看交错，

12
00:00:52,200 --> 00:00:55,230
0,225 225,590 790,1190 1780,2745 2745,3030
looking at the interleaving,| when
|我们考虑调度时。

13
00:00:55,230 --> 00:00:56,450
0,105 105,180 180,390 390,660 660,1220
we are thinking about schedules.|
|

14
00:00:57,140 --> 00:00:58,360
0,315 315,570 570,705 705,900 900,1220
And we had this schedule,|
我们有这个调度，|

15
00:00:58,860 --> 00:01:00,700
0,290 290,485 485,790 900,1300 1440,1840
and this schedule is actually
这个调度是一个正确的调度，

16
00:01:00,900 --> 00:01:03,125
0,380 380,710 710,1060 1680,1985 1985,2225
a correct schedule, right,| even
|尽管这是交错的，

17
00:01:03,125 --> 00:01:05,000
0,195 195,330 330,480 480,1295 1525,1875
though that is interleaving,| because
|因为 T1 修改 A ，

18
00:01:05,000 --> 00:01:06,260
0,270 270,590
{T1 -}

19
00:01:06,260 --> 00:01:08,180
0,240 240,585 585,855 855,1130
makes change to A,|
|

20
00:01:08,180 --> 00:01:10,340
0,350 670,1005 1005,1340 1480,1845 1845,2160
then {T2 -} makes change
然后 T2 通过给予 6% 的利息来修改 A ，

21
00:01:10,340 --> 00:01:11,420
0,195 195,360 360,570 570,810 810,1080
to A by giving {6%

22
00:01:11,420 --> 00:01:13,160
0,320 610,1010
-} interest,|
|

23
00:01:13,450 --> 00:01:14,520
0,275 275,440 440,665 665,890 890,1070
T1 then comes back and
然后 T1 回来，修改 B ，

24
00:01:14,520 --> 00:01:15,945
0,210 210,530 550,825 825,1100 1120,1425
makes changes to B,| so
|把 100 美元从 A 放到 B ，

25
00:01:15,945 --> 00:01:17,085
0,225 225,465 465,600 600,825 825,1140
puts back the 100 dollars

26
00:01:17,085 --> 00:01:18,540
0,240 240,420 420,585 585,845 1165,1455
from A to B,| so
|现在 A 和 B 的和是一致的，

27
00:01:18,540 --> 00:01:19,755
0,210 210,420 420,615 615,920 940,1215
now A and B, the

28
00:01:19,755 --> 00:01:20,870
0,180 180,345 345,480 480,735 735,1115
sum of that is consistent,|
|

29
00:01:21,550 --> 00:01:23,070
0,400 600,920 920,1130 1130,1325 1325,1520
{so,now -} when {T2 -}
所以现在当 T2 添加 6% 的利息给 B ，这是正确的，

30
00:01:23,070 --> 00:01:24,650
0,290 370,675 675,945 945,1245 1245,1580
goes and add {6% -}

31
00:01:24,880 --> 00:01:26,120
0,320 320,485 485,635 635,890 890,1240
interest to B, this correct,|
|

32
00:01:26,320 --> 00:01:27,830
0,320 320,500 500,620 620,740 740,1510
even though there was interleaving,
即使有交错，交错也是安全的，

33
00:01:27,940 --> 00:01:29,715
0,290 290,920 920,1145 1145,1480 1500,1775
that interleaving was safe| and
|你最终通过两种合法的方式之一，

34
00:01:29,715 --> 00:01:30,990
0,120 120,285 285,540 540,875 985,1275
you ended up with one

35
00:01:30,990 --> 00:01:32,510
0,165 165,315 315,555 555,1230 1230,1520
of the two legitimate ways|
|

36
00:01:32,710 --> 00:01:33,720
0,275 275,470 470,650 650,800 800,1010
in which to do this
做这个事务，

37
00:01:33,720 --> 00:01:36,225
0,320 1360,1650 1650,1815 1815,2090 2200,2505
transaction,| because you had the
|因为你在数据库中有正确的最终值。

38
00:01:36,225 --> 00:01:38,400
0,305 385,785 985,1385 1735,2025 2025,2175
right final value in the

39
00:01:38,400 --> 00:01:39,380
0,260
database.|
|

40
00:01:39,540 --> 00:01:41,165
0,400 690,1025 1025,1295 1295,1490 1490,1625
Okay, so even though this
好的，所以即使这种交错，

41
00:01:41,165 --> 00:01:42,890
0,660 660,870 870,1170 1170,1485 1485,1725
interleaving| at first seems like,
|第一次看起来，它应该不会奏效，

42
00:01:42,890 --> 00:01:44,020
0,195 195,375 375,675 675,840 840,1130
oh, it shouldn't work out,|
|

43
00:01:44,790 --> 00:01:46,940
0,320 320,590 590,940 1230,1630 1800,2150
if this B happened before
如果这个 B 发生在读取 B 之前，

44
00:01:46,940 --> 00:01:47,870
0,240 240,465 465,585 585,750 750,930
this read of B,| then
|我们就得[离开]了。

45
00:01:47,870 --> 00:01:49,200
0,150 150,285 285,405 405,650
we would be off.|
|

46
00:01:49,910 --> 00:01:50,970
0,305 305,485 485,620 620,770 770,1060
Okay, does that make sense?|
好的，这能理解吗？|

47
00:01:55,390 --> 00:01:56,430
0,245 245,425 425,680 680,875 875,1040
The bottom value will still
下面的值仍然是一样的，

48
00:01:56,430 --> 00:01:57,330
0,135 135,225 225,435 435,705 705,900
be the same,| because this
|因为这和运行 T1 在 T2 之前是一样的，

49
00:01:57,330 --> 00:01:58,365
0,180 180,330 330,510 510,765 765,1035
is the same as having

50
00:01:58,365 --> 00:01:59,715
0,335 445,735 735,915 915,1140 1140,1350
run {T1 -} followed by

51
00:01:59,715 --> 00:02:00,600
0,165 165,450 450,660 660,750 750,885
{T2 -},| that's the whole
|这就是重点，

52
00:02:00,600 --> 00:02:02,120
0,290 370,675 675,930 930,1200 1200,1520
point,| {this,schedule -} is okay,
|这个调度没有问题。

53
00:02:03,170 --> 00:02:04,870
0,305 305,610 660,1060 1260,1520 1520,1700
right.| {So\,,some\, -} the main
|所以，重点是一些交错是可以的，

54
00:02:04,870 --> 00:02:06,370
0,240 240,450 450,645 645,1290 1290,1500
point is some interleaving is

55
00:02:06,370 --> 00:02:08,100
0,350 400,690 690,1290 1290,1440 1440,1730
okay,| some interleaving is not,|
|一些交错是不可以的，|

56
00:02:08,210 --> 00:02:09,430
0,275 275,410 410,605 605,935 935,1220
and the whole purpose with
我们今天讨论的整个目的是，

57
00:02:09,430 --> 00:02:10,375
0,165 165,345 345,495 495,735 735,945
what we'll talk about today

58
00:02:10,375 --> 00:02:12,240
0,275 295,585 585,795 795,1115 1465,1865
is,| when to determine,| well,
|什么时候确定好，|有没有一种机制来确定如何让一切都安全。

59
00:02:12,380 --> 00:02:13,900
0,290 290,455 455,590 590,850 1260,1520
is there a mechanism to

60
00:02:13,900 --> 00:02:14,785
0,105 105,285 285,555 555,765 765,885
go and determine how to

61
00:02:14,785 --> 00:02:16,200
0,240 240,525 525,815
make everything safe.|
|

62
00:02:16,870 --> 00:02:18,650
0,260 260,410 410,680 680,1060 1380,1780
Okay, the next slide was
好的，下一张幻灯片是不安全的，

63
00:02:18,970 --> 00:02:20,300
0,395 395,650 650,800 800,1010 1010,1330
something that is not safe,|
|

64
00:02:20,680 --> 00:02:22,935
0,275 275,470 470,790 1650,1985 1985,2255
which is essentially {T1 -}
本质上是 T1 开始修改 A ，

65
00:02:22,935 --> 00:02:24,360
0,300 300,525 525,705 705,1025 1135,1425
starts to make change to

66
00:02:24,360 --> 00:02:25,380
0,290
A,|
|

67
00:02:25,380 --> 00:02:27,105
0,270 270,555 555,890 1000,1400 1420,1725
then {T2 -} starts to
然后 T2 开始修改 A 和 B ，

68
00:02:27,105 --> 00:02:28,380
0,225 225,510 510,750 750,990 990,1275
make changes to both A

69
00:02:28,380 --> 00:02:29,640
0,225 225,530
and B,|
|

70
00:02:29,640 --> 00:02:30,500
0,105 105,255 255,405 405,570 570,860
and then {T1 -} makes
然后 T1 在其事务中对 B 进行所需的剩余更改，

71
00:02:30,700 --> 00:02:31,965
0,335 335,635 635,905 905,1070 1070,1265
the remaining change it needed

72
00:02:31,965 --> 00:02:32,780
0,180 180,285 285,390 390,525 525,815
to make in its transaction

73
00:02:32,890 --> 00:02:34,860
0,260 260,520 750,1055 1055,1360 1620,1970
to B,| and so that
|所以 A 的值被 T2 看到，

74
00:02:34,860 --> 00:02:36,390
0,350 460,765 765,1050 1050,1320 1320,1530
value for A was seen

75
00:02:36,390 --> 00:02:38,060
0,210 210,405 910,1215 1215,1395 1395,1670
by {T2 -},| the final
|A 和 B 的值的最终结果不对应于任何一个串行调度。

76
00:02:38,530 --> 00:02:39,675
0,380 380,635 635,755 755,935 935,1145
result for the values of

77
00:02:39,675 --> 00:02:40,760
0,135 135,285 285,495 495,810 810,1085
A and B doesn't correspond

78
00:02:40,900 --> 00:02:42,030
0,290 290,530 530,785 785,980 980,1130
to any one of the

79
00:02:42,030 --> 00:02:43,560
0,330 330,750 750,1070
serial schedules.| Yep.|
|是的。|

80
00:02:44,440 --> 00:02:45,560
0,275 275,410 410,530 530,875 875,1120

81
00:02:46,180 --> 00:02:47,475
0,365 365,695 695,980 980,1160 1160,1295

82
00:02:47,475 --> 00:02:48,810
0,225 225,540 540,840 840,1110 1110,1335

83
00:02:48,810 --> 00:02:49,610
0,165 165,300 300,435 435,555 555,800

84
00:02:49,630 --> 00:02:50,260
0,320 320,590

85
00:02:51,460 --> 00:02:53,140
0,350 400,690 690,980 1300,1620 1620,1680

86
00:02:53,140 --> 00:02:53,760
0,60 60,180 180,330 330,570

87
00:02:54,910 --> 00:02:56,085
0,290 290,530 530,755 755,935 935,1175
We talked about that last
我们上一节课讨论了这个，

88
00:02:56,085 --> 00:02:56,805
0,225 225,375 375,495 495,600 600,720
class,| but let me go
|让我回到那节课上。

89
00:02:56,805 --> 00:02:58,215
0,180 180,360 360,540 540,845 1015,1410
back to that, right.| So,
|所以整个定义，

90
00:02:58,215 --> 00:02:59,700
0,285 285,495 495,815 985,1245 1245,1485
the whole definition,| because it's
|因为它很重要，

91
00:02:59,700 --> 00:03:00,975
0,285 285,525 525,660 660,950 1000,1275
important,| the whole definition of
|串行调度的整个定义是，

92
00:03:00,975 --> 00:03:02,940
0,480 480,785 1405,1695 1695,1845 1845,1965
serial schedule is that,| if
|如果我有这两个事务， T1 T2 ，

93
00:03:02,940 --> 00:03:04,010
0,180 180,315 315,540 540,765 765,1070
I've got these two transactions,

94
00:03:04,360 --> 00:03:06,380
0,290 455,605 605,770 770,1060
{T1 -} {T2 -},|
|

95
00:03:06,380 --> 00:03:08,420
0,350 700,1005 1005,1310 1360,1740 1740,2040
and I can have a
我可以有一个调度，

96
00:03:08,420 --> 00:03:10,700
0,320 670,975 975,1280 1720,2040 2040,2280
schedule,| in which {T1 -}
|T1 在 T2 之前，

97
00:03:10,700 --> 00:03:12,050
0,255 255,540 540,765 765,930 930,1350
runs followed by {T2 -},|
|

98
00:03:12,050 --> 00:03:13,340
0,240 240,470 490,765 765,990 990,1290
I'll get a certain number,|
我会得到一个确定的数字，|

99
00:03:13,340 --> 00:03:15,425
0,255 255,510 510,1070 1210,1610 1780,2085
or vice versa.| {So\,,here -}
反之亦然。|这是图表，

100
00:03:15,425 --> 00:03:16,775
0,180 180,390 390,930 930,1140 1140,1350
is the diagram,| which will
|它将以不同的形式再次返回，

101
00:03:16,775 --> 00:03:17,750
0,150 150,360 360,630 630,840 840,975
come back again in a

102
00:03:17,750 --> 00:03:20,345
0,225 225,590 970,1370 1900,2265 2265,2595
different form,| { - -} in
|在 40 分钟左右。

103
00:03:20,345 --> 00:03:21,380
0,285 285,495 495,630 630,810 810,1035
the, in a little bit

104
00:03:21,380 --> 00:03:22,505
0,210 210,420 420,630 630,900 900,1125
in about 40 minutes {from,now

105
00:03:22,505 --> 00:03:23,810
0,275 595,855 855,975 975,1125 1125,1305
-}.| Let me just go
|让我来看看我们有串行调度的那张幻灯片，

106
00:03:23,810 --> 00:03:24,920
0,150 150,360 360,660 660,900 900,1110
to that slide in which

107
00:03:24,920 --> 00:03:26,920
0,195 195,420 420,770 1150,1695 1695,2000
we had the serial schedule,|
|

108
00:03:28,840 --> 00:03:30,580
0,365 365,695 695,1060
skip, skip, skip.|
跳过，跳过，跳过。|

109
00:03:31,000 --> 00:03:31,630
0,240 240,360 360,450 450,525 525,630

110
00:03:31,630 --> 00:03:32,665
0,135 135,300 300,570 570,810 810,1035

111
00:03:32,665 --> 00:03:34,000
0,390 390,525 525,690 690,965 1015,1335

112
00:03:34,680 --> 00:03:35,775
0,195 195,375 375,600 600,870 870,1095

113
00:03:35,775 --> 00:03:37,035
0,135 135,330 330,555 555,845 955,1260

114
00:03:37,035 --> 00:03:37,320
0,255

115
00:03:38,830 --> 00:03:40,770
0,400 420,920 920,1270 1410,1730 1730,1940
Yeah, that's,| so okay, {so,this
是的，那是，|好的，这就是正确的概念。

116
00:03:40,770 --> 00:03:42,195
0,165 165,345 345,650 760,1125 1125,1425
-} is the notion of

117
00:03:42,195 --> 00:03:43,380
0,545
correctness.|
|

118
00:03:43,380 --> 00:03:45,340
0,330 330,585 585,825 825,1190
So the question is,|
所以问题是，|

119
00:03:45,340 --> 00:03:46,300
0,180 180,360 360,585 585,795 795,960
{T1 -} followed by {T2
T1 在 T2 之前，

120
00:03:46,300 --> 00:03:47,190
0,165 165,315 315,450 450,600 600,890
-},| there were two possible
|数据库有两种可能的方式结束。

121
00:03:47,210 --> 00:03:48,270
0,320 320,515 515,665 665,800 800,1060
ways in which the database

122
00:03:48,320 --> 00:03:49,470
0,260 260,395 395,575 575,815 815,1150
could end up with, right.|
|

123
00:03:50,080 --> 00:03:50,800
0,180 180,345 345,465 465,570 570,720
And what we are saying
我们要说的是，

124
00:03:50,800 --> 00:03:51,790
0,210 210,465 465,660 660,795 795,990
is,| both of them are
|它们两个都是正确的，

125
00:03:51,790 --> 00:03:53,455
0,320 580,900 900,1095 1095,1350 1350,1665
correct,| {both,are -} now correct,|
|两个都是正确的，|

126
00:03:53,455 --> 00:03:54,750
0,210 210,315 315,540 540,915 915,1295
because we are operating under
因为我们是在可串行化的假设下操作的，

127
00:03:55,490 --> 00:03:57,925
0,400 630,1640 1640,2105 2105,2285 2285,2435
the serializable assumption,| that these
|假设这些都是可串行化的冲突，

128
00:03:57,925 --> 00:03:59,890
0,150 150,570 570,1355 1555,1830 1830,1965
are conflicts serializable,| if we
|如果我们说严格的可串行化，

129
00:03:59,890 --> 00:04:01,630
0,150 150,300 300,525 525,1005 1005,1740
were to say strictly serializable,|
|

130
00:04:01,630 --> 00:04:02,770
0,225 225,510 510,675 675,900 900,1140
that there's only one order
只有一个顺序， T1 在 T2 之前，

131
00:04:02,770 --> 00:04:03,730
0,225 225,375 375,600 600,810 810,960
{T1 -} followed by {T2

132
00:04:03,730 --> 00:04:04,780
0,240 240,480 480,645 645,810 810,1050
-},| because {T1 -} started
|因为 T1 首先开始，

133
00:04:04,780 --> 00:04:06,760
0,350 670,945 945,1110 1110,1400
first,| that would be
|那是一种并发控制更具限制性的形式，

134
00:04:06,760 --> 00:04:09,300
0,180 180,530 670,1230 1230,1550 2140,2540
a more restrictive form of

135
00:04:09,320 --> 00:04:11,470
0,395 395,1130 1130,1480 1710,2000 2000,2150
{} concurrency control| and we
|我们不会允许事务彼此重叠的情况下有那么多的并行性，

136
00:04:11,470 --> 00:04:13,225
0,345 345,645 645,900 900,1125 1125,1755
wouldn't allow as much parallelism

137
00:04:13,225 --> 00:04:14,695
0,165 165,455 535,1200 1200,1335 1335,1470
with transactions overlapping with each

138
00:04:14,695 --> 00:04:16,180
0,275 535,810 810,1050 1050,1215 1215,1485
other.| {So,we're -} doing something
|所以我们在做一些看起来很有趣的事情，

139
00:04:16,180 --> 00:04:17,760
0,240 240,480 480,830 970,1335 1335,1580
that seems funny,| we're saying,
|我们在说，这是可以的，

140
00:04:18,080 --> 00:04:20,080
0,500 500,850 930,1330 1500,1805 1805,2000
it's okay,| if {T1 -}
|如果 T1 先进来，

141
00:04:20,080 --> 00:04:21,535
0,210 210,525 525,870 870,1200 1200,1455
came first,| but the way
|但是数据库状态的方式看起来是，

142
00:04:21,535 --> 00:04:22,765
0,150 150,315 315,465 465,725 835,1230
in which the database state

143
00:04:22,765 --> 00:04:24,505
0,395 775,1110 1110,1335 1335,1530 1530,1740
is looks like,| {T2 -}
|T2 运行在 T1 之前，

144
00:04:24,505 --> 00:04:25,675
0,210 210,405 405,570 570,825 825,1170
ran all of it, followed

145
00:04:25,675 --> 00:04:27,250
0,240 240,420 835,1155 1155,1365 1365,1575
by {T1 -},| that order
|这个顺序是可以的。

146
00:04:27,250 --> 00:04:28,170
0,240 240,435 435,585 585,690 690,920
{is,okay -}.| So we are
|所以，我们接受这个小的差异，

147
00:04:28,190 --> 00:04:29,540
0,605 605,910
accepting that

148
00:04:29,650 --> 00:04:31,575
0,350 350,1240 1350,1625 1625,1760 1760,1925
little discrepancy,| because we want
|因为我们想要允许更多的并行化，

149
00:04:31,575 --> 00:04:33,540
0,180 180,330 330,480 480,1235 1675,1965
to allow more parallelization,| if
|如果我们不想，

150
00:04:33,540 --> 00:04:34,530
0,195 195,510 510,690 690,870 870,990
we didn't want to,| we
|我们可以做一些事情，

151
00:04:34,530 --> 00:04:35,625
0,135 135,315 315,620 700,960 960,1095
could do something,| {we,can -}
|我们可以提出一种新的并发控制协议，

152
00:04:35,625 --> 00:04:36,240
0,135 135,270 270,405 405,510 510,615
come up with a new

153
00:04:36,240 --> 00:04:37,785
0,510 510,705 705,1110 1110,1275 1275,1545
concurrency control protocol,| in which
|其中一个简单的，

154
00:04:37,785 --> 00:04:39,200
0,255 255,495 495,875
a simple one,|
|

155
00:04:39,200 --> 00:04:40,145
0,225 225,360 360,480 480,705 705,945
not a good idea,| but
不是一个好主意，|但是一个简单的，

156
00:04:40,145 --> 00:04:40,955
0,135 135,330 330,540 540,675 675,810
a simple one,| that will
|可以与这个直观的概念一起工作，

157
00:04:40,955 --> 00:04:42,455
0,195 195,375 375,635 655,1290 1290,1500
work with that intuitive notion

158
00:04:42,455 --> 00:04:43,685
0,225 225,515 535,825 825,1005 1005,1230
is,| say, if {T1 -}
|比如，如果 T1 在 T2 之前到达，

159
00:04:43,685 --> 00:04:45,275
0,480 480,765 765,960 960,1265 1315,1590
arrives before {T2 -},| {T1
|T1 锁定整个数据库，

160
00:04:45,275 --> 00:04:46,600
0,210 210,615 615,795 795,1020 1020,1325
-} locks the entire database,|
|

161
00:04:47,420 --> 00:04:48,215
0,135 135,285 285,450 450,600 600,795
and then {T2 -} runs,|
然后 T2 运行，|

162
00:04:48,215 --> 00:04:49,420
0,225 225,390 390,600 600,870 870,1205
{that,was -} the default mechanism
这是我们获得隔离属性的默认机制，

163
00:04:50,010 --> 00:04:51,040
0,290 290,470 470,605 605,740 740,1030
by which we would get

164
00:04:51,210 --> 00:04:53,150
0,380 380,1040 1040,1385 1385,1715 1715,1940
this isolation property,| but it
|但它会奏效的，

165
00:04:53,150 --> 00:04:54,545
0,165 165,440 820,1080 1080,1215 1215,1395
{would,work -},| everything would seem
|一切似乎都合乎逻辑，

166
00:04:54,545 --> 00:04:56,795
0,665 835,1170 1170,1395 1395,1890 1890,2250
logical,| but you wouldn't allow
|但你不会允许系统中有足够的并行性。

167
00:04:56,795 --> 00:04:58,360
0,270 270,915 915,1155 1155,1305 1305,1565
enough parallelism in the system.|
|

168
00:04:59,180 --> 00:05:00,325
0,230 230,305 305,425 425,700 750,1145
Okay, and as I mentioned
好的，就像我上次提到的，

169
00:05:00,325 --> 00:05:03,085
0,345 345,695 895,1295 1585,2315 2425,2760
last time is,| Spanner has
|Spanner 有这样的概念，

170
00:05:03,085 --> 00:05:04,825
0,240 240,545 625,1025 1255,1560 1560,1740
this notion,| where this {T1
|这个 T1 在 T2 前面，感觉很奇怪，

171
00:05:04,825 --> 00:05:05,665
0,165 165,390 390,585 585,720 720,840
-} followed by {T2 -}

172
00:05:05,665 --> 00:05:07,080
0,120 120,345 345,695 715,1065 1065,1415
is feeling odd, right,| because
|因为我们说一个调度，

173
00:05:07,190 --> 00:05:08,410
0,260 260,395 395,640 660,965 965,1220
we are saying a schedule|
|

174
00:05:08,410 --> 00:05:10,375
0,225 225,420 420,675 675,1010 1240,1965
in which {T2 -} finishes
T2 完成并更改数据库状态， T1 运行，

175
00:05:10,375 --> 00:05:11,560
0,315 315,630 630,885 885,1035 1035,1185
and changes the state of

176
00:05:11,560 --> 00:05:12,595
0,105 105,345 345,630 630,810 810,1035
the database and {T1 -}

177
00:05:12,595 --> 00:05:14,940
0,335 865,1265 1315,1620 1620,1925 1945,2345
runs| is a fine final
|对数据库来说是一个好的最终状态，

178
00:05:14,960 --> 00:05:16,360
0,290 290,455 455,575 575,820 1110,1400
state for the database,| {that,seems
|这似乎很奇怪，

179
00:05:16,360 --> 00:05:17,410
0,195 195,450 450,675 675,825 825,1050
-} odd,| because {T1 -}
|因为在我们所有的例子中， T1 都是首先到达的，

180
00:05:17,410 --> 00:05:18,565
0,330 330,570 570,825 825,975 975,1155
arrives first in all the

181
00:05:18,565 --> 00:05:20,545
0,300 300,555 555,815 1165,1485 1485,1980
examples we have,| so Spanner
|所以 Spanner 有一个额外的严格可串行化的概念，

182
00:05:20,545 --> 00:05:23,280
0,240 240,575 805,1205 1495,1895 2335,2735
has this additional notion of

183
00:05:23,330 --> 00:05:25,540
0,320 320,1115 1115,1325 1325,1630 1860,2210
strict serializable,| in which it
|它说，

184
00:05:25,540 --> 00:05:27,010
0,350 520,810 810,1005 1005,1260 1260,1470
says,| if they arrive in
|如果它们以特定的顺序到达，

185
00:05:27,010 --> 00:05:28,180
0,120 120,330 330,675 675,990 990,1170
a certain order,| then we
|那么我们会使它更有意义，

186
00:05:28,180 --> 00:05:29,620
0,150 150,440 490,795 795,1100 1120,1440
will actually make it more

187
00:05:29,620 --> 00:05:31,735
0,320 760,1110 1110,1380 1380,1605 1605,2115
meaningful,| while still {along,parallelism -},|
|同时仍然是并行的，|

188
00:05:31,735 --> 00:05:33,000
0,165 165,600 600,765 765,960 960,1265
the protocol is really complicated|
协议真的很复杂，|

189
00:05:33,230 --> 00:05:34,810
0,275 275,550 570,920 920,1250 1250,1580
and I flash that slide
我切换幻灯片到最后，

190
00:05:34,810 --> 00:05:36,160
0,255 255,435 435,710 880,1155 1155,1350
at the end| to say
|如果你感兴趣，去看看那篇论文，

191
00:05:36,160 --> 00:05:37,255
0,180 180,420 420,675 675,930 930,1095
if you're interested, go take

192
00:05:37,255 --> 00:05:38,220
0,150 150,300 300,465 465,660 660,965
a look at that paper|
|

193
00:05:38,540 --> 00:05:39,640
0,290 290,545 545,695 695,875 875,1100
and there's all kinds of
有各种各样有趣的东西，

194
00:05:39,640 --> 00:05:41,410
0,350 370,705 705,930 930,1380 1380,1770
interesting stuff| and {CockroachDB -}
|CockroachDB 是 Spanner 类似的，

195
00:05:41,410 --> 00:05:42,865
0,330 330,690 690,960 960,1125 1125,1455
is Spanner like,| but doesn't
|但不需要 Spanner 要求的原子钟，

196
00:05:42,865 --> 00:05:44,620
0,335 475,720 720,1155 1155,1545 1545,1755
require the atomic clocks that

197
00:05:44,620 --> 00:05:45,870
0,450 450,690 690,885 885,1005 1005,1250
Spanner requires,| that they actually
|原子钟是 Google 保持数据中心同步的，

198
00:05:45,890 --> 00:05:47,250
0,365 365,650 650,830 830,1025 1025,1360
Google keeps the data centers

199
00:05:47,630 --> 00:05:49,345
0,670 720,1055 1055,1445 1445,1565 1565,1715
synced,| the clocks on each
|每个数据中心的时钟同步，

200
00:05:49,345 --> 00:05:50,485
0,150 150,330 330,615 615,840 840,1140
{of,those -} sync,| that allows
|这使他们能够计算出我应该保留一个事务多少，

201
00:05:50,485 --> 00:05:51,670
0,210 210,330 330,510 510,845 895,1185
them to figure out how

202
00:05:51,670 --> 00:05:52,600
0,210 210,405 405,540 540,720 720,930
much should I hold back

203
00:05:52,600 --> 00:05:53,980
0,165 165,440 940,1200 1200,1290 1290,1380
a transaction,| so that I
|这样我就可以知道，

204
00:05:53,980 --> 00:05:55,090
0,150 150,440 550,840 840,990 990,1110
can know,| if some of
|如果一些事务在它之前实时开始，

205
00:05:55,090 --> 00:05:56,440
0,120 120,380 550,885 885,1125 1125,1350
the transactions started in real

206
00:05:56,440 --> 00:05:57,625
0,300 300,585 585,855 855,1095 1095,1185
time before it,| so that
|以便我以相同的时间顺序[退出]，

207
00:05:57,625 --> 00:05:58,450
0,150 150,390 390,555 555,660 660,825
I retire in the same

208
00:05:58,450 --> 00:05:59,320
0,210 210,500
time order,|
|

209
00:05:59,600 --> 00:06:01,615
0,260 260,455 455,700 1260,1660 1710,2015
because it's complicated| and take
因为它很复杂，|会在高级数据库课程讲解。

210
00:06:01,615 --> 00:06:02,845
0,195 195,390 390,695 715,1035 1035,1230
the advanced database class for

211
00:06:02,845 --> 00:06:03,985
0,165 165,330 330,555 555,870 870,1140
that.| {But,the -} confusion you're
|但你们的困惑和你们问的问题是，

212
00:06:03,985 --> 00:06:04,900
0,135 135,315 315,435 435,675 675,915
having and the questions that

213
00:06:04,900 --> 00:06:05,770
0,120 120,255 255,390 390,615 615,870
you guys are asking is

214
00:06:05,770 --> 00:06:07,170
0,285 285,705 705,825 825,1050 1050,1400
like,| doesn't it seem feel
|这不觉得奇怪吗，

215
00:06:07,190 --> 00:06:09,160
0,400 840,1145 1145,1400 1400,1670 1670,1970
weird,| it does feel weird,|
|这确实感觉很奇怪，|

216
00:06:09,160 --> 00:06:10,330
0,270 270,390 390,600 600,900 900,1170
because we are operating under
因为我们是在冲突串行化这个更宽松的概念下操作的，

217
00:06:10,330 --> 00:06:12,900
0,350 400,800 820,1460 1480,1880 2170,2570
this more relaxed notion of

218
00:06:13,490 --> 00:06:15,295
0,400 450,1130 1130,1355 1355,1490 1490,1805
conflict serializable,| we're saying, we'll
|我们说我们会允许这些调度，

219
00:06:15,295 --> 00:06:17,620
0,225 225,450 450,995 1315,1715
allow these schedules,| because
|因为我们需要的性能足够高，

220
00:06:17,810 --> 00:06:19,795
0,400 1140,1505 1505,1745 1745,1865 1865,1985
the performance that we need

221
00:06:19,795 --> 00:06:20,920
0,150 150,360 360,695 715,990 990,1125
is high enough,| and the
|语义的变化也是合理的，

222
00:06:20,920 --> 00:06:22,350
0,165 165,345 345,810 810,1065 1065,1430
change in semantics is reasonable,|
|

223
00:06:22,550 --> 00:06:23,785
0,290 290,440 440,700 750,1070 1070,1235
that we think applications are
我们认为应用程序会很好地接受它。

224
00:06:23,785 --> 00:06:24,415
0,105 105,210 210,300 300,450 450,630
going to be fine with

225
00:06:24,415 --> 00:06:25,120
0,275
it.|
|

226
00:06:25,380 --> 00:06:26,480
0,350 350,560 560,695 695,905 905,1100

227
00:06:26,480 --> 00:06:27,580
0,165 165,450 450,690 690,825 825,1100

228
00:06:27,600 --> 00:06:28,820
0,305 305,610
|

229
00:06:29,500 --> 00:06:31,890
0,335 335,560 560,850 1290,1690 2070,2390

230
00:06:32,430 --> 00:06:33,920
0,400 600,875 875,1025 1025,1250 1250,1490
Yeah, {so,the -} question is,|
好的，所以问题是，|

231
00:06:33,920 --> 00:06:35,165
0,225 225,450 450,705 705,930 930,1245
what's the universe of solutions,|
解决方案的[宇宙]是什么，|

232
00:06:35,165 --> 00:06:36,230
0,240 240,450 450,645 645,870 870,1065
if there's a universe of
如果有一系列的调度，

233
00:06:36,230 --> 00:06:37,900
0,560 640,915 915,1080 1080,1320 1320,1670
schedules,| they will mirror that,|
|它们会反映出来，|

234
00:06:38,100 --> 00:06:39,680
0,305 305,590 590,1310 1310,1445 1445,1580
because conflict serializable will give
因为冲突可串行化将为最终数据库提供一组潜在的解决方案，

235
00:06:39,680 --> 00:06:41,140
0,120 120,330 330,540 540,800 1060,1460
a certain set of potential

236
00:06:41,220 --> 00:06:42,280
0,350 350,560 560,665 665,785 785,1060
solutions for the end database,

237
00:06:42,390 --> 00:06:43,130
0,275 275,410 410,500 500,590 590,740
right,| if you have two
|如果你有两个事务，

238
00:06:43,130 --> 00:06:44,615
0,290 640,975 975,1170 1170,1305 1305,1485
transactions,| any one of those
|这两个中的任何一个，

239
00:06:44,615 --> 00:06:45,620
0,300 300,570 570,690 690,810 810,1005
two,| if there are three,
|如果有三个，那么它的排列，

240
00:06:45,620 --> 00:06:47,350
0,180 180,705 705,915 915,1190 1330,1730
the permutation of that,| so
|所以，它还体现了数据库的最终状态，

241
00:06:47,430 --> 00:06:49,115
0,305 305,545 545,1130 1130,1430 1430,1685
it also embodies what's final

242
00:06:49,115 --> 00:06:50,120
0,270 270,405 405,510 510,750 750,1005
state of {the,database -},| if
|如果有并发操作，

243
00:06:50,120 --> 00:06:51,365
0,90 90,195 195,570 570,855 855,1245
you had concurrent actions,| they
|它们会相互镜像。

244
00:06:51,365 --> 00:06:52,860
0,285 285,525 525,750 750,1025
they mirror each other.|
|

245
00:06:53,010 --> 00:06:53,960
0,350 350,560 560,695 695,815 815,950

246
00:06:53,960 --> 00:06:55,000
0,210 210,480 480,830

247
00:06:55,670 --> 00:06:56,790
0,260 260,485 485,710 710,845 845,1120
If I understand your question
如果我对你的问题理解正确，

248
00:06:56,810 --> 00:06:58,290
0,335 335,755 755,965 965,1175 1175,1480
correct,| it's about like,| what
|那就是，|关于数据库中最终值的属性，你能说些什么，

249
00:06:58,400 --> 00:06:59,350
0,305 305,470 470,635 635,815 815,950
can you say about the

250
00:06:59,350 --> 00:07:00,520
0,255 255,510 510,630 630,840 840,1170
properties of the final values

251
00:07:00,520 --> 00:07:02,160
0,240 240,345 345,590 910,1275 1275,1640
in the database,| they exactly
|它们正是这个的定义，

252
00:07:02,180 --> 00:07:03,445
0,350 350,560 560,820 870,1130 1130,1265
are the definition of this,|
|

253
00:07:03,445 --> 00:07:04,720
0,195 195,285 285,420 420,540 540,785
they're one the same.|
它们是一样的。|

254
00:07:06,080 --> 00:07:07,645
0,290 290,580 660,1010 1010,1325 1325,1565
All right, other questions on
好的，还有其他问题吗，

255
00:07:07,645 --> 00:07:08,760
0,225 225,480 480,660 660,825 825,1115
this| before we move on
|在我们进入今天的话题之前？

256
00:07:09,020 --> 00:07:10,470
0,395 395,650 650,860 860,1130 1130,1450
to the topic for today?|
|

257
00:07:11,910 --> 00:07:12,845
0,350 350,470 470,650 650,800 800,935
We'll come back to this
我们将以不同的形式返回到这个图表，

258
00:07:12,845 --> 00:07:14,710
0,485 505,905 925,1215 1215,1485 1485,1865
diagram in a different form,|
|

259
00:07:15,090 --> 00:07:17,530
0,400 450,1060 1560,1895 1895,2135 2135,2440
so let's close this out|
所以让我们关闭这个图表，|

260
00:07:17,610 --> 00:07:19,265
0,400 750,1055 1055,1265 1265,1445 1445,1655
and bring up the next
并打开下一个幻灯片。

261
00:07:19,265 --> 00:07:20,300
0,335
deck.|
|

262
00:07:21,870 --> 00:07:22,955
0,275 275,410 410,605 605,830 830,1085
All right, so today we'll
好的，那么今天我们将讨论两相锁定。

263
00:07:22,955 --> 00:07:25,030
0,225 225,605 955,1260 1260,1515 1515,2075
talk about two phase locking.|
|

264
00:07:25,620 --> 00:07:28,140
0,380 1000,1400 1810,2145 2145,2370 2370,2520
And the part that we
而我们将担心的部分是，我们如何实现所有这些机制。我们在上一张幻灯片中讨论了依赖图，但在我们进入今天的主题之前，只有一个要求项目3推迟日期的请求，因为我们需要几天时间才能将其提交给您。所以我们把它推迟了七天。希望你不需要所有的七天，但如果你需要，你就有了。

265
00:07:28,140 --> 00:07:30,930
0,260 1120,1485 1485,1815 1815,2180 2500,2790
will worry about is how

266
00:07:30,930 --> 00:07:31,650
0,150 150,270 270,435 435,600 600,720
do we make all of

267
00:07:31,650 --> 00:07:32,970
0,150 150,690 690,945 945,1155 1155,1320
these mechanisms happen. {We,talked -}

268
00:07:32,970 --> 00:07:34,215
0,225 225,660 660,1005 1005,1125 1125,1245
about dependence graphs in the

269
00:07:34,215 --> 00:07:35,625
0,195 195,545 685,1020 1020,1245 1245,1410
last slide, but before we

270
00:07:35,625 --> 00:07:37,520
0,225 225,495 495,780 780,1025 1495,1895
jump into today's topic, just

271
00:07:37,600 --> 00:07:38,610
0,260 260,380 380,560 560,800 800,1010
there was a request for

272
00:07:38,610 --> 00:07:39,795
0,270 270,570 570,765 765,945 945,1185
project three to push back

273
00:07:39,795 --> 00:07:40,740
0,195 195,450 450,720 720,840 840,945
the date because we were

274
00:07:40,740 --> 00:07:41,790
0,120 120,240 240,390 390,680 760,1050
a few days out in

275
00:07:41,790 --> 00:07:42,675
0,225 225,450 450,585 585,720 720,885
getting that to {you.,So -}

276
00:07:42,675 --> 00:07:43,425
0,135 135,270 270,420 420,585 585,750
we moved it back by

277
00:07:43,425 --> 00:07:44,955
0,210 210,545 835,1185 1185,1380 1380,1530
{seven,days. -} Hopefully, you don't

278
00:07:44,955 --> 00:07:45,810
0,105 105,240 240,375 375,570 570,855
need all the seven days,

279
00:07:45,810 --> 00:07:46,635
0,225 225,375 375,510 510,660 660,825
but if you do, you

280
00:07:46,635 --> 00:07:47,560
0,180 180,485
have it.|
|

281
00:07:47,810 --> 00:07:48,745
0,275 275,425 425,620 620,815 815,935
As I mentioned in the
正如我在上一节课中提到的，项目中有很多可移动的部分，所以不要等到截止日期前两天才去做。

282
00:07:48,745 --> 00:07:50,035
0,210 210,575 745,990 990,1095 1095,1290
last class, there are lots

283
00:07:50,035 --> 00:07:51,100
0,225 225,450 450,735 735,945 945,1065
of moving parts in the

284
00:07:51,100 --> 00:07:52,765
0,260 580,855 855,1110 1110,1365 1365,1665
project, so don't wait till

285
00:07:52,765 --> 00:07:53,680
0,195 195,360 360,570 570,780 780,915
like two days before the

286
00:07:53,680 --> 00:07:55,040
0,300 300,450 450,570 570,830
deadline to do it.|
|

287
00:07:55,040 --> 00:07:56,630
0,180 180,500 520,870 870,1220 1300,1590
It will seem harder than
如果你等那么久，这看起来会比实际情况更难。好的，先把简单的东西去掉。

288
00:07:56,630 --> 00:07:57,935
0,210 210,530 640,915 915,1065 1065,1305
it is if you wait

289
00:07:57,935 --> 00:07:59,525
0,300 300,635 955,1245 1245,1425 1425,1590
that long. {Okay,,knock -} out

290
00:07:59,525 --> 00:08:01,280
0,135 135,360 360,690 690,1055
the simple things first.|
|

291
00:08:01,710 --> 00:08:04,340
0,380 380,760 1620,2015 2015,2330 2330,2630
Hum four got pushed out
《哼唱4》今天早些时候被赶了出来，预计在11月12日发布。

292
00:08:04,340 --> 00:08:07,000
0,380 850,1250 1450,1850 1930,2385 2385,2660
earlier today and that's due

293
00:08:07,050 --> 00:08:08,560
0,350 350,650 650,1120
on november 12th.|
|

294
00:08:10,390 --> 00:08:12,440
0,290 290,455 455,880 1050,1450 1650,2050
Okay, so let's jump into
好的，让我们跳到今天的话题上。

295
00:08:12,550 --> 00:08:14,360
0,275 275,515 515,815 815,1150
the topic for today.|
|

296
00:08:14,360 --> 00:08:16,025
0,195 195,470 610,1005 1005,1380 1380,1665
We will concern ourselves with
我们将关注我们想要允许的这种冲突的可序列化的时间表类。

297
00:08:16,025 --> 00:08:18,920
0,270 270,635 805,1835 2275,2625 2625,2895
this conflict serializable class of

298
00:08:18,920 --> 00:08:20,045
0,480 480,675 675,795 795,945 945,1125
schedules that we want to

299
00:08:20,045 --> 00:08:20,960
0,275
allow.|
|

300
00:08:21,160 --> 00:08:22,395
0,365 365,650 650,815 815,995 995,1235
And remember, we also talked
记住，我们还讨论了视图可序列化，其中如果我稍微了解一些应用程序语义，我可以允许更多的时间表。这往往很难执行和实践。没人会这么做。但教科书上有这样的规定，这样你就能知道那些东西是什么。理解这一点很好，但我们将专注于冲突的可序列化，以及我们如何使其发挥作用？

301
00:08:22,395 --> 00:08:23,880
0,225 225,465 465,1215 1215,1350 1350,1485
about view serializable in which

302
00:08:23,880 --> 00:08:24,570
0,120 120,285 285,450 450,555 555,690
if I knew a little

303
00:08:24,570 --> 00:08:26,130
0,180 180,330 330,555 555,885 885,1560
bit about the application semantics,

304
00:08:26,130 --> 00:08:27,150
0,240 240,435 435,660 660,840 840,1020
I could allow a few

305
00:08:27,150 --> 00:08:29,115
0,240 240,830 1120,1485 1485,1860 1860,1965
more schedules. {That,tends -} to

306
00:08:29,115 --> 00:08:30,135
0,105 105,285 285,540 540,795 795,1020
be very hard to enforce

307
00:08:30,135 --> 00:08:31,260
0,195 195,485 505,780 780,930 930,1125
and {practice.,No -} one {does,that.

308
00:08:31,260 --> 00:08:32,745
0,320 400,675 675,825 825,1305 1305,1485
-} But the textbooks have

309
00:08:32,745 --> 00:08:33,990
0,305 385,675 675,855 855,1035 1035,1245
it so that you just

310
00:08:33,990 --> 00:08:35,810
0,255 255,590 820,1170 1170,1470 1470,1820
know what {those,things -} are.

311
00:08:36,130 --> 00:08:38,510
0,500 500,725 725,1025 1025,1420 1980,2380
It's good to understand that,

312
00:08:38,650 --> 00:08:39,870
0,275 275,500 500,695 695,950 950,1220
but we'll focus on conflict

313
00:08:39,870 --> 00:08:41,580
0,920 970,1260 1260,1440 1440,1590 1590,1710
serializable and how do we

314
00:08:41,580 --> 00:08:42,700
0,150 150,345 345,650
make that work?|
|

315
00:08:42,740 --> 00:08:44,190
0,380 380,710 710,980 980,1175 1175,1450
So last class, we said.|
所以最后一节课，我们说。|

316
00:08:45,060 --> 00:08:46,175
0,290 290,530 530,800 800,980 980,1115
If you start to draw
如果你开始画依赖图，你会看到一个循环。这下可麻烦了。

317
00:08:46,175 --> 00:08:47,360
0,165 165,555 555,825 825,1050 1050,1185
the dependence graph, you see

318
00:08:47,360 --> 00:08:48,245
0,120 120,380 430,660 660,750 750,885
a cycle. {We,are -} in

319
00:08:48,245 --> 00:08:49,120
0,275
trouble.|
|

320
00:08:49,280 --> 00:08:50,500
0,320 320,640 720,995 995,1115 1115,1220
Right. {But,how -} do you
正确的。但你如何绘制周期，我们在时间表完成后绘制周期，所以就像，现在太晚了吗？你如何确保循环不会形成，也就是给我们这个我们正在寻找的正确性的概念，对吗？什么时候交错操作是安全的？这就是我们要讨论的问题。有多种方法可以做到这一点。

321
00:08:50,500 --> 00:08:52,165
0,150 150,440 580,980 1150,1440 1440,1665
draw the cycle and we're

322
00:08:52,165 --> 00:08:53,350
0,150 150,315 315,540 540,900 900,1185
drawing the cycle after the

323
00:08:53,350 --> 00:08:54,700
0,285 285,585 585,890 970,1215 1215,1350
schedule was done, so it's

324
00:08:54,700 --> 00:08:55,470
0,90 90,210 210,345 345,495 495,770
like, is it too late?

325
00:08:55,700 --> 00:08:56,640
0,260 260,380 380,485 485,635 635,940
How do you make sure

326
00:08:56,870 --> 00:08:58,230
0,290 290,455 455,845 845,1115 1115,1360
that the cyclecles don't form,

327
00:08:58,580 --> 00:09:00,325
0,640 810,1115 1115,1325 1325,1520 1520,1745
aka give us this notion

328
00:09:00,325 --> 00:09:01,660
0,270 270,735 735,945 945,1155 1155,1335
of correctness that we're looking

329
00:09:01,660 --> 00:09:03,025
0,350 520,855 855,1080 1080,1230 1230,1365
for, right? When is it

330
00:09:03,025 --> 00:09:04,390
0,210 210,390 390,825 825,1055 1105,1365
safe to interleave actions? So

331
00:09:04,390 --> 00:09:05,370
0,195 195,315 315,510 510,675 675,980
that's what we'll talk {about.,And

332
00:09:05,630 --> 00:09:08,095
0,400 1560,1820 1820,1910 1910,2140 2160,2465
-} there are multiple ways

333
00:09:08,095 --> 00:09:08,980
0,165 165,285 285,545
to do it.|
|

334
00:09:08,980 --> 00:09:09,960
0,165 165,285 285,450 450,645 645,980
We're going to talk about.|
我们要谈的是。|

335
00:09:10,740 --> 00:09:12,980
0,650 650,875 875,1040 1040,1300
Locks as a mechanism.|
锁作为一种机械装置。|

336
00:09:12,980 --> 00:09:14,440
0,120 120,240 240,465 465,830
To do that today.|
今天才能做到这一点。|

337
00:09:14,440 --> 00:09:15,310
0,135 135,225 225,360 360,585 585,870
And if you remember last
如果你还记得上一节课，我们说过有两大类算法。

338
00:09:15,310 --> 00:09:16,270
0,300 300,510 510,675 675,840 840,960
class, we said there are

339
00:09:16,270 --> 00:09:18,390
0,260 280,675 675,1065 1065,1350 1350,2120
two broad classes of algorithms.|
|

340
00:09:19,080 --> 00:09:20,370
0,225 225,435 435,1035 1035,1185 1185,1290
One is pessimistic and the
一个是悲观的，一个是乐观的。锁是乐观的。很抱歉，锁是悲观的，他们将试图阻止一个循环在很早的时候形成。当我们谈到乐观的，啊，简约控制协议时，在下一节课你会看到他们会做相反的事情。他们会说让一切都过去吧。

341
00:09:20,370 --> 00:09:22,200
0,120 120,285 285,435 435,710 1360,1830
other one is optimistic. {Locks,are

342
00:09:22,200 --> 00:09:24,090
0,150 150,440 1180,1575 1575,1695 1695,1890
-} {optimistic.,Locks -} are sorry

343
00:09:24,090 --> 00:09:26,715
0,470 820,1170 1170,1520 2050,2385 2385,2625
pessim they will try to

344
00:09:26,715 --> 00:09:28,275
0,285 285,525 525,765 765,1020 1020,1560
stop a cycle from forming

345
00:09:28,275 --> 00:09:29,820
0,345 345,645 645,995 1135,1410 1410,1545
very {early,on. -} And when

346
00:09:29,820 --> 00:09:31,490
0,120 120,285 285,465 465,740 1270,1670
we talk about optimistic, ah,

347
00:09:31,780 --> 00:09:33,255
0,650 650,845 845,1265 1265,1370 1370,1475
conccy control protocols, in the

348
00:09:33,255 --> 00:09:34,590
0,165 165,485 625,975 975,1125 1125,1335
next class you'll see they

349
00:09:34,590 --> 00:09:35,670
0,195 195,375 375,495 495,740 760,1080
will {do,the -} opposite. They'll

350
00:09:35,670 --> 00:09:37,060
0,90 90,315 315,555 555,830
say let everything go.|
|

351
00:09:37,280 --> 00:09:38,290
0,335 335,560 560,710 710,860 860,1010
And in the end I
最后我会检查有没有什么不安全的地方。我知道如何避开不安全的部分。

352
00:09:38,290 --> 00:09:39,670
0,135 135,410 670,960 960,1185 1185,1380
will check if something is

353
00:09:39,670 --> 00:09:40,840
0,525 525,690 690,855 855,1020 1020,1170
unsafe. {I,know -} how to

354
00:09:40,840 --> 00:09:41,875
0,150 150,345 345,510 510,615 615,1035
back out of the unsafe

355
00:09:41,875 --> 00:09:42,900
0,245
parts.|
|

356
00:09:43,520 --> 00:09:45,370
0,290 290,635 635,910 1350,1655 1655,1850
And locking says if two
锁的意思是，如果两个东西试图相互冲突，哦，它们很可能会做坏事。让我在第一次接触时就阻止他们。这就是我们今天要讨论的，基于锁的悲观主义。

357
00:09:45,370 --> 00:09:46,240
0,180 180,345 345,510 510,645 645,870
things are trying to conflict

358
00:09:46,240 --> 00:09:47,260
0,240 240,375 375,555 555,795 795,1020
with each other, oh, they

359
00:09:47,260 --> 00:09:48,445
0,195 195,500 520,795 795,975 975,1185
will probably do bad things.

360
00:09:48,445 --> 00:09:49,600
0,165 165,300 300,480 480,785 865,1155
{Let,me -} stop them at

361
00:09:49,600 --> 00:09:51,460
0,240 240,590 1060,1380 1380,1695 1695,1860
first {touch.,So -} that's what

362
00:09:51,460 --> 00:09:52,530
0,150 150,285 285,480 480,735 735,1070
we will talk about today,

363
00:09:52,610 --> 00:09:55,340
0,380 380,760 900,1300 1350,2230
the lock based pessimistic.|
|

364
00:09:55,340 --> 00:09:57,340
0,525 525,750 750,1430
Conccy control mechanisms.|
连结控制机制。|

365
00:09:57,690 --> 00:09:58,690
0,290 290,455 455,590 590,725 725,1000
So what does it mean?|
那么这意味着什么呢？|

366
00:09:59,340 --> 00:10:00,630
0,300 300,480 480,690 690,855 855,1290
You've played around with latches,
你已经玩弄了闩锁，这是你在第一次C++作业中做的。当时，您正在保护内存中的数据结构。您设置了一个机制，即闩锁机制，因此，如果两个线程试图进行可能会破坏数据结构的更改，则会使其处于损坏状态。这是不会发生的。

367
00:10:00,630 --> 00:10:01,350
0,195 195,330 330,450 450,585 585,720
which you did in your

368
00:10:01,350 --> 00:10:02,445
0,180 180,435 435,675 675,870 870,1095
very first c plus plus

369
00:10:02,445 --> 00:10:03,510
0,450 450,600 600,765 765,930 930,1065
assignment. {At,that -} time, you

370
00:10:03,510 --> 00:10:04,790
0,195 195,570 570,690 690,915 915,1280
were protecting a data structure

371
00:10:05,110 --> 00:10:07,160
0,320 320,640 930,1235 1235,1540 1650,2050
in {memory.,You -} put a

372
00:10:07,450 --> 00:10:09,735
0,400 780,1055 1055,1280 1280,1600 2010,2285
mechanism, the latch mechanism, so

373
00:10:09,735 --> 00:10:10,755
0,180 180,420 420,750 750,855 855,1020
that two threads, if they're

374
00:10:10,755 --> 00:10:12,195
0,135 135,285 285,435 435,725 1135,1440
trying to make changes that

375
00:10:12,195 --> 00:10:13,290
0,195 195,465 465,750 750,900 900,1095
would have destroyed the data

376
00:10:13,290 --> 00:10:14,175
0,315 315,555 555,675 675,780 780,885
structure, left it in a

377
00:10:14,175 --> 00:10:15,740
0,285 285,605 685,990 990,1290 1290,1565
{corrupt,state. -} That doesn't happen.|
|

378
00:10:16,420 --> 00:10:17,800
0,345 345,620 730,1005 1005,1185 1185,1380
Locks do the same thing
除了用于数据库以外，锁做的是相同的事情。

379
00:10:17,800 --> 00:10:19,500
0,165 165,330 330,620 670,1070
but for database stuff.|
|

380
00:10:19,500 --> 00:10:20,865
0,240 240,540 540,1005 1005,1230 1230,1365
And what locks the way
你用锁的方式做事情的锁是想象我有一个时间表，在那里我读写对象。所以你在这里看到两个交易t1t2我们要做的就是。

381
00:10:20,865 --> 00:10:21,930
0,150 150,300 300,555 555,855 855,1065
you would do things with

382
00:10:21,930 --> 00:10:23,145
0,315 315,560 610,960 960,1140 1140,1215
locks is imagine I have

383
00:10:23,145 --> 00:10:24,195
0,120 120,395 445,705 705,885 885,1050
a schedule where I'm reading

384
00:10:24,195 --> 00:10:25,580
0,195 195,420 420,755 835,1110 1110,1385
and writing objects. {So,here -}

385
00:10:25,810 --> 00:10:27,795
0,290 290,580 960,1265 1265,1570 1710,1985
you see two transactions t

386
00:10:27,945 --> 00:10:29,775
0,150 150,330 985,1335 1335,1575 1575,1830
1 t 2 what we'll

387
00:10:29,775 --> 00:10:31,280
0,150 150,360 360,540 540,815
do is we will.|
|

388
00:10:31,280 --> 00:10:32,660
0,225 225,770
Put locks.|
把锁上。|

389
00:10:32,700 --> 00:10:33,890
0,320 320,530 530,755 755,995 995,1190
Before we read or write
在读取或写入对象之前，我们将获取锁。

390
00:10:33,890 --> 00:10:35,555
0,150 150,410 880,1155 1155,1350 1350,1665
an object, we will acquire

391
00:10:35,555 --> 00:10:36,740
0,225 225,485
the lock.|
|

392
00:10:36,900 --> 00:10:38,675
0,320 320,500 500,760 840,1240 1470,1775
Before we make that read
在我们进行该读或写操作之前。

393
00:10:38,675 --> 00:10:40,180
0,195 195,480 480,875
or write operation.|
|

394
00:10:40,180 --> 00:10:41,215
0,300 300,510 510,780 780,915 915,1035
Okay, and locks will come
好的，锁会有不同的形式。我们稍后会讲到这一点。现在，假设在我们读a之前，我们将应用锁，正如您所看到的，事务t 1在它进一步向下移动时，在它完成了对锁进行更改所需的所有东西之后，它并没有像我们一直使用的闩锁那样解锁。

395
00:10:41,215 --> 00:10:42,430
0,120 120,345 345,695 715,1080 1080,1215
in different forms. {We'll,get -}

396
00:10:42,430 --> 00:10:43,165
0,150 150,285 285,420 420,525 525,735
to that in a {second.,For

397
00:10:43,165 --> 00:10:44,875
0,240 240,405 405,660 660,1025 1405,1710
-} now, just assume before

398
00:10:44,875 --> 00:10:46,225
0,195 195,405 405,725 865,1140 1140,1350
we read a we will

399
00:10:46,225 --> 00:10:47,455
0,240 240,405 405,665 835,1095 1095,1230
apply the lock and as

400
00:10:47,455 --> 00:10:49,320
0,135 135,300 300,605 1225,1545 1545,1865
you see transaction t one

401
00:10:49,400 --> 00:10:50,590
0,290 290,455 455,725 725,1010 1010,1190
as it goes a bit

402
00:10:50,590 --> 00:10:52,210
0,255 255,620 880,1245 1245,1470 1470,1620
further down, after it is

403
00:10:52,210 --> 00:10:53,185
0,210 210,405 405,600 600,810 810,975
done with all the stuff

404
00:10:53,185 --> 00:10:54,300
0,150 150,390 390,615 615,795 795,1115
it needed to make changes

405
00:10:54,350 --> 00:10:55,975
0,380 380,635 635,910 960,1250 1250,1625
to the lock, it doesn't

406
00:10:55,975 --> 00:10:57,610
0,390 390,875 955,1260 1260,1455 1455,1635
didn't unlock pretty much like

407
00:10:57,610 --> 00:10:59,035
0,165 165,360 360,465 465,740 1090,1425
what we've been using with

408
00:10:59,035 --> 00:11:00,740
0,210 210,750 750,1115
the latches in.|
|

409
00:11:00,780 --> 00:11:01,865
0,275 275,395 395,590 590,890 890,1085
And the data structures you
和您试图保护的数据结构，类似地，t 2将遵循相同的协议。所以实际上就是这样的。

410
00:11:01,865 --> 00:11:03,110
0,120 120,285 285,510 510,845 955,1245
are trying to protect, and

411
00:11:03,110 --> 00:11:04,295
0,480 480,630 630,810 810,975 975,1185
similarly, t two will follow

412
00:11:04,295 --> 00:11:06,100
0,210 210,390 390,965 1195,1500 1500,1805
that same protocol. {And,so -}

413
00:11:06,210 --> 00:11:08,320
0,400 630,1040 1040,1300
effectively there's this.|
|

414
00:11:08,360 --> 00:11:10,240
0,350 350,700 1020,1325 1325,1715 1715,1880
Lock manager, which maintains a
锁管理器，它维护一个数据结构。

415
00:11:10,240 --> 00:11:11,640
0,240 240,620
data structure.|
|

416
00:11:11,640 --> 00:11:13,220
0,165 165,420 420,615 615,950 1180,1580
And it's going to get
它会收到这样的请求：这是我要锁定的对象。

417
00:11:13,300 --> 00:11:14,925
0,395 395,650 650,940 1110,1505 1505,1625
requests for saying, here's the

418
00:11:14,925 --> 00:11:16,370
0,275 565,840 840,1020 1020,1185 1185,1445
object I want to lock.|
|

419
00:11:16,980 --> 00:11:17,625
0,120 120,270 270,465 465,555 555,645
And as you'll see in
正如你将在稍后看到的，它还会有关于它想要锁定的模式的信息，独占和共享，并说，这就是我，我是事务t，请为我锁定这个对象。

420
00:11:17,625 --> 00:11:18,780
0,90 90,240 240,540 540,990 990,1155
a little bit, it'll also

421
00:11:18,780 --> 00:11:19,905
0,285 285,585 585,780 780,915 915,1125
have information about the mode

422
00:11:19,905 --> 00:11:20,790
0,210 210,360 360,525 525,720 720,885
in which it wants to

423
00:11:20,790 --> 00:11:22,665
0,260 310,705 705,945 945,1220 1540,1875
lock, exclusive and shared and

424
00:11:22,665 --> 00:11:23,745
0,165 165,585 585,735 735,885 885,1080
saying, here's who I am,

425
00:11:23,745 --> 00:11:25,830
0,315 315,575 715,1115 1285,1685 1765,2085
I'm transaction t and please

426
00:11:25,830 --> 00:11:27,050
0,210 210,375 375,630 630,915 915,1220
lock this object for me.|
|

427
00:11:27,420 --> 00:11:28,395
0,225 225,405 405,585 585,780 780,975
We won't get into the
我们不会深入到锁管理器的细节，但它通常被组织为关于被锁定的对象ID的哈希表，然后它将跟踪所有锁持有者或。

428
00:11:28,395 --> 00:11:29,235
0,210 210,360 360,510 510,660 660,840
details of what that lock

429
00:11:29,235 --> 00:11:30,525
0,285 285,600 600,885 885,1095 1095,1290
manager looks like, but it's

430
00:11:30,525 --> 00:11:31,860
0,245 445,720 720,870 870,1005 1005,1335
often organized as a hash

431
00:11:31,860 --> 00:11:33,930
0,260 670,1035 1035,1305 1305,1610 1690,2070
table on the object ID

432
00:11:33,930 --> 00:11:35,415
0,255 255,405 405,585 585,890 1150,1485
that is being locked, and

433
00:11:35,415 --> 00:11:36,525
0,195 195,465 465,645 645,885 885,1110
then it'll keep track of

434
00:11:36,525 --> 00:11:38,390
0,305 355,630 630,825 825,1385 1465,1865
all the lock holders or.|
|

435
00:11:38,980 --> 00:11:41,860
0,620 910,1310 1480,1875 1875,2300 2560,2880
Holders who are requests to
持有者是请求成为已被放入挂起队列的锁持有者的持有者，这就是关于锁数据结构的所有内容。如何保持这一点并有效地做到这一点，是一个超级有趣的话题。如果你对这些细节感兴趣，我们可以在线下谈。

436
00:11:41,860 --> 00:11:43,210
0,210 210,390 390,890 940,1215 1215,1350
become lock holders that have

437
00:11:43,210 --> 00:11:44,050
0,120 120,255 255,390 390,495 495,840
been put on the pending

438
00:11:44,050 --> 00:11:45,415
0,410 460,795 795,945 945,1215 1215,1365
queue, that's all I'll say

439
00:11:45,415 --> 00:11:46,530
0,180 180,315 315,480 480,750 750,1115
about the lock data structure.

440
00:11:46,640 --> 00:11:47,980
0,290 290,440 440,700 750,1100 1100,1340
{How,to -} maintain that and

441
00:11:47,980 --> 00:11:49,495
0,165 165,360 360,1070 1090,1365 1365,1515
do that efficiently is a

442
00:11:49,495 --> 00:11:50,970
0,275 295,660 660,975 975,1200 1200,1475
super interesting {topic.,If -} you

443
00:11:50,990 --> 00:11:52,225
0,365 365,605 605,740 740,965 965,1235
are interested in those details,

444
00:11:52,225 --> 00:11:53,640
0,165 165,300 300,465 465,965
we can talk offline.|
|

445
00:11:53,640 --> 00:11:54,950
0,255 255,525 525,885 885,1020 1020,1310
Okay, so it's a structure
好的，所以这是一个用来跟踪锁的结构。然后在这里的某个时刻，例如，第二个锁定请求是针对同一对象的。A已经被事务t 1持有，所以这就是锁管理器要做的事情。它会说，哎呀，这是你提出的要求。

446
00:11:55,000 --> 00:11:56,040
0,335 335,470 470,605 605,785 785,1040
that's going to keep track

447
00:11:56,040 --> 00:11:57,390
0,210 210,360 360,830 880,1185 1185,1350
of the locks. {And,then -}

448
00:11:57,390 --> 00:11:58,515
0,150 150,345 345,600 600,885 885,1125
at some point here, for

449
00:11:58,515 --> 00:12:00,110
0,255 255,495 495,765 765,1145 1195,1595
example, that second lock request

450
00:12:00,580 --> 00:12:01,725
0,350 350,560 560,665 665,830 830,1145
is to the same {object.,A

451
00:12:01,725 --> 00:12:03,830
0,395 925,1305 1305,1590 1590,1800 1800,2105
-} a is being held

452
00:12:04,210 --> 00:12:05,690
0,320 320,530 530,820 900,1190 1190,1480
already by transaction t one,

453
00:12:05,710 --> 00:12:06,480
0,245 245,425 425,530 530,635 635,770
so that's what the lock

454
00:12:06,480 --> 00:12:07,815
0,270 270,525 525,765 765,1140 1140,1335
manager {will,do. -} It'll say,

455
00:12:07,815 --> 00:12:09,650
0,575 865,1125 1125,1260 1260,1485 1485,1835
whoops, you made that request.|
|

456
00:12:10,400 --> 00:12:11,440
0,275 275,545 545,710 710,845 845,1040
I can't grant you that
我不能答应你的要求。因此事务T 2被阻塞，直到来自T 1解锁请求进入的稍后时间点，锁现在打开，且T 2可以获得该请求。就像你用插销做的一样。锁在这里为数据库对象做这件事，好的。

457
00:12:11,440 --> 00:12:12,985
0,350 460,750 750,1040 1120,1395 1395,1545
request. {So,transaction -} t two

458
00:12:12,985 --> 00:12:14,965
0,240 240,605 1075,1455 1455,1725 1725,1980
gets blocked till that later

459
00:12:14,965 --> 00:12:16,285
0,255 255,435 435,725 925,1200 1200,1320
point in time when the

460
00:12:16,285 --> 00:12:17,725
0,465 465,765 765,960 960,1140 1140,1440
unlock request from t one

461
00:12:17,725 --> 00:12:19,225
0,330 330,665 805,1065 1065,1335 1335,1500
comes in, the locks now

462
00:12:19,225 --> 00:12:21,145
0,305 775,1155 1155,1455 1455,1695 1695,1920
open and t two can

463
00:12:21,145 --> 00:12:22,720
0,195 195,480 480,780 780,1085 1195,1575
get that {request.,So -} same

464
00:12:22,720 --> 00:12:23,860
0,345 345,615 615,780 780,945 945,1140
thing as you have {with,latches.

465
00:12:23,860 --> 00:12:25,740
0,560 820,1215 1215,1350 1350,1560 1560,1880
-} Locks are doing this

466
00:12:26,120 --> 00:12:28,800
0,400 570,950 950,1330 1350,1750 2280,2680
here for database objects, okay.|
|

467
00:12:29,160 --> 00:12:30,110
0,275 275,425 425,575 575,740 740,950
As I said, for now
正如我所说的，目前您只能假设这些对象a、b和c是记录，但在类的末尾，我们将讨论以不同的粒度锁定。

468
00:12:30,110 --> 00:12:31,460
0,180 180,300 300,525 525,890 1060,1350
you can just assume these

469
00:12:31,460 --> 00:12:32,600
0,285 285,585 585,750 750,900 900,1140
objects a b and c

470
00:12:32,600 --> 00:12:34,100
0,285 285,620 880,1185 1185,1380 1380,1500
are records, but towards the

471
00:12:34,100 --> 00:12:34,835
0,90 90,210 210,330 330,495 495,735
end of the class we'll

472
00:12:34,835 --> 00:12:36,665
0,165 165,485 895,1380 1380,1560 1560,1830
talk about locking at different

473
00:12:36,665 --> 00:12:38,200
0,965
granularities.|
|

474
00:12:38,200 --> 00:12:39,450
0,225 225,480 480,735 735,960 960,1250
And so on. {This,transaction -}
诸若此类。该事务将被处理，锁管理器将完成其任务。

475
00:12:39,500 --> 00:12:40,900
0,275 275,550 570,970 990,1250 1250,1400
will process, and the lock

476
00:12:40,900 --> 00:12:42,000
0,255 255,495 495,630 630,795 795,1100
manager will do its thing.|
|

477
00:12:42,630 --> 00:12:43,685
0,275 275,425 425,635 635,860 860,1055
All right, so today we'll
好的，那么今天我们将讨论这些不同的锁类型。

478
00:12:43,685 --> 00:12:44,645
0,150 150,315 315,450 450,690 690,960
talk about these different lock

479
00:12:44,645 --> 00:12:45,720
0,305
types.|
|

480
00:12:45,720 --> 00:12:46,800
0,150 150,315 315,480 480,600 600,1080
We talk about the protocol
我们讨论称为两相锁定的协议。

481
00:12:46,800 --> 00:12:48,480
0,225 225,420 420,630 630,1160
called two phase locking.|
|

482
00:12:48,480 --> 00:12:50,000
0,360 360,630 630,945 945,1200 1200,1520
And then we'll talk about
然后，我们将讨论在执行称为死锁的锁定时可能发生的一些不好的事情，以及我们如何解决这一问题。如果时间允许，我们将达到分层锁定，即在树、整个数据库、表、页、记录甚至记录中的列的不同级别进行锁定。

483
00:12:50,020 --> 00:12:50,895
0,275 275,425 425,545 545,695 695,875
some of the bad things

484
00:12:50,895 --> 00:12:52,065
0,135 135,270 270,545 745,1020 1020,1170
that can happen when you

485
00:12:52,065 --> 00:12:53,580
0,150 150,555 555,795 795,1380 1380,1515
do locking called deadlocks and

486
00:12:53,580 --> 00:12:55,070
0,210 210,530 640,960 960,1185 1185,1490
how we get around that.

487
00:12:55,240 --> 00:12:57,015
0,305 305,610 840,1145 1145,1535 1535,1775
{And,then -} time permitting, we'll

488
00:12:57,015 --> 00:12:58,425
0,120 120,255 255,435 435,1080 1080,1410
get to the hierarchical locking

489
00:12:58,425 --> 00:12:59,840
0,165 165,435 435,795 795,1095 1095,1415
where we lock at different

490
00:13:00,010 --> 00:13:02,205
0,400 510,785 785,935 935,1210 1890,2195
levels in the tree, entire

491
00:13:02,205 --> 00:13:04,130
0,305 625,915 915,1205 1345,1635 1635,1925
database, a table, a page,

492
00:13:04,330 --> 00:13:05,685
0,305 305,610 720,1010 1010,1205 1205,1355
a record or even a

493
00:13:05,685 --> 00:13:06,980
0,245 265,540 540,675 675,935
column in a record.|
|

494
00:13:09,000 --> 00:13:10,440
0,305 305,485 485,760
Before we go.|
在我们走之前。|

495
00:13:10,700 --> 00:13:11,830
0,275 275,470 470,620 620,875 875,1130
If you've taken an operating
如果你上过操作系统课，你可能会发现这里的术语令人困惑。在这里，当数据库人员谈论锁时，他们谈论的是您为保护对象所做的事情，即位于磁盘上且在内存中的寿命超过其寿命的数据库对象。

496
00:13:11,830 --> 00:13:13,615
0,300 300,680 940,1335 1335,1530 1530,1785
system class, you'll probably find

497
00:13:13,615 --> 00:13:15,600
0,165 165,960 960,1260 1260,1500 1500,1985
the terminology over here confusing.

498
00:13:16,100 --> 00:13:18,070
0,400 690,995 995,1300 1350,1685 1685,1970
{Where,when -} database folks talk

499
00:13:18,070 --> 00:13:20,100
0,300 300,980 1120,1485 1485,1680 1680,2030
about locks, they're talking about

500
00:13:20,210 --> 00:13:22,045
0,400 480,800 800,1190 1190,1475 1475,1835
things that you're doing to

501
00:13:22,045 --> 00:13:24,550
0,365 565,965 1345,1745 1855,2235 2235,2505
protect objects, database objects that

502
00:13:24,550 --> 00:13:25,750
0,165 165,330 330,795 795,1050 1050,1200
sit on disk and have

503
00:13:25,750 --> 00:13:28,315
0,120 120,680 1030,1430 1960,2310 2310,2565
a lifespan beyond its life

504
00:13:28,315 --> 00:13:29,440
0,195 195,485
in memory.|
|

505
00:13:29,450 --> 00:13:30,620
0,400
Um.|
恩。|

506
00:13:30,660 --> 00:13:32,540
0,290 290,580 660,1430 1430,1715 1715,1880
We call latches as the
我们称闩锁为我们想要在内存中保护的东西。好的，所以这个术语非常重要。所以让我们来看看它们的不同之处。在很长一段时间里，数据库人员永远无法与操作系统人员交谈，因为你会进入80岁的S，90岁的S，你会说解锁东西。对他们来说，锁定与闭锁是一样的，术语是相去甚远的，但这是。

507
00:13:32,540 --> 00:13:33,410
0,180 180,375 375,495 495,645 645,870
things that we want to

508
00:13:33,410 --> 00:13:35,420
0,195 195,345 345,620 1180,1580 1660,2010
protect in memory. {Okay,,so -}

509
00:13:35,420 --> 00:13:36,970
0,240 240,855 855,915 915,1155 1155,1550
this terminology is super {important.,So

510
00:13:37,740 --> 00:13:38,890
0,275 275,500 500,620 620,830 830,1150
-} let's just go through

511
00:13:39,060 --> 00:13:40,670
0,290 290,440 440,700 810,1210 1320,1610
what the {differences,are. -} And

512
00:13:40,670 --> 00:13:42,020
0,150 150,270 270,525 525,920 1090,1350
for the longest time the

513
00:13:42,020 --> 00:13:43,190
0,260 280,585 585,780 780,975 975,1170
database folks could never talk

514
00:13:43,190 --> 00:13:44,345
0,135 135,285 285,510 510,795 795,1155
to the operating system folks

515
00:13:44,345 --> 00:13:45,350
0,255 255,480 480,690 690,900 900,1005
because you'd get into in

516
00:13:45,350 --> 00:13:46,310
0,105 105,240 240,420 420,825 825,960
{the,like} 80 s 90 s

517
00:13:46,310 --> 00:13:47,825
0,135 135,360 360,615 615,1320 1320,1515
and you'd {say,unlocking -} stuff.

518
00:13:47,825 --> 00:13:48,590
0,180 180,330 330,480 480,615 615,765
And for them it was

519
00:13:48,590 --> 00:13:49,400
0,315 315,420 420,525 525,645 645,810
locking is the same as

520
00:13:49,400 --> 00:13:51,455
0,530 580,980 1030,1290 1290,1890 1890,2055
latching and the terminology was

521
00:13:51,455 --> 00:13:52,445
0,210 210,390 390,585 585,810 810,990
just way off, but this

522
00:13:52,445 --> 00:13:53,120
0,275
is.|
|

523
00:13:53,400 --> 00:13:54,335
0,275 275,395 395,545 545,710 710,935
Even if you become an
即使你是操作系统专家，也要尽量用更好的措辞，对吗？因为他们，他们是非常不同的。啊，是这样。

524
00:13:54,335 --> 00:13:55,895
0,270 270,555 555,935 1135,1425 1425,1560
operating systems person, try to

525
00:13:55,895 --> 00:13:56,870
0,120 120,255 255,450 450,720 720,975
use the better terms, right?

526
00:13:56,870 --> 00:13:58,000
0,195 195,450 450,705 705,840 840,1130
Because they're, they're very different.

527
00:13:58,530 --> 00:14:00,100
0,395 395,790
{Ah,,so. -}|
|

528
00:14:00,100 --> 00:14:02,950
0,620 880,1170 1170,1460 1480,2270 2500,2850
Locks are database concepts. {They,try
锁是数据库概念。他们试图分离用户事务。T1c2，我们正在努力防止所有这些并发事务彼此踩到脚趾。

529
00:14:02,950 --> 00:14:04,470
0,255 255,435 435,710 760,1140 1140,1520
-} to separate user transactions.

530
00:14:04,670 --> 00:14:05,620
0,260 260,410 410,575 575,755 755,950
The t 1 c two,

531
00:14:05,620 --> 00:14:06,415
0,210 210,375 375,495 495,660 660,795
we are trying to keep

532
00:14:06,415 --> 00:14:07,620
0,135 135,345 345,540 540,915 915,1205
all these concurrent transactions from

533
00:14:07,730 --> 00:14:08,890
0,305 305,620 620,740 740,860 860,1160
stepping on each other's toes.

534
00:14:08,890 --> 00:14:09,860
0,470
|
|

535
00:14:09,860 --> 00:14:11,360
0,560 760,1050 1050,1230 1230,1365 1365,1500
Latches are trying to keep
锁存器正试图防止在内存中的公共数据结构上执行的线程相互踩到对方的门。类似的事情，但在他们试图做的事情上，他们的水平非常不同。

536
00:14:11,360 --> 00:14:12,665
0,210 210,600 600,720 720,960 960,1305
the threads that are executing

537
00:14:12,665 --> 00:14:13,655
0,105 105,210 210,405 405,705 705,990
on a common data structure

538
00:14:13,655 --> 00:14:15,275
0,210 210,485 865,1170 1170,1500 1500,1620
in memory from stepping on

539
00:14:15,275 --> 00:14:17,050
0,135 135,450 450,695 955,1355 1375,1775
each other's doors. {Similar,things, -}

540
00:14:17,220 --> 00:14:19,210
0,380 380,760 990,1325 1325,1625 1625,1990
but at very different levels

541
00:14:19,500 --> 00:14:20,345
0,290 290,455 455,605 605,740 740,845
in terms of what they

542
00:14:20,345 --> 00:14:21,480
0,105 105,270 270,420 420,665
are trying to do.|
|

543
00:14:21,930 --> 00:14:23,045
0,395 395,515 515,665 665,875 875,1115
Locks are trying to protect
锁试图保护数据库内容。锁存器试图保护内存数据结构中的一些内容。

544
00:14:23,045 --> 00:14:24,860
0,165 165,425 475,1085 1195,1695 1695,1815
the database contents. {Latches,are -}

545
00:14:24,860 --> 00:14:25,700
0,135 135,315 315,510 510,675 675,840
trying to protect some in

546
00:14:25,700 --> 00:14:27,320
0,240 240,555 555,920
memory data structure.|
|

547
00:14:27,870 --> 00:14:28,985
0,275 275,635 635,830 830,950 950,1115
The duration of a lock
锁的持续时间是整个事务，而锁存的持续时间只针对程序员写入的临界区。

548
00:14:28,985 --> 00:14:31,025
0,180 180,375 375,645 645,995 1675,2040
is the entire transaction, whereas

549
00:14:31,025 --> 00:14:32,800
0,225 225,635 925,1260 1260,1470 1470,1775
the duration of the latch

550
00:14:32,820 --> 00:14:33,950
0,350 350,605 605,770 770,890 890,1130
is just for the critical

551
00:14:33,950 --> 00:14:35,740
0,380 460,735 735,885 885,1515 1515,1790
sections that the programmer writes.|
|

552
00:14:36,510 --> 00:14:37,535
0,275 275,455 455,635 635,845 845,1025
Now you're starting to see
现在你开始看到一些差异，随着我们进一步深入了解锁的不同模式，这些差异将会出现。通常，锁有几十种不同的模式。今天我们将简要讨论这一点。

553
00:14:37,535 --> 00:14:38,525
0,180 180,315 315,420 420,665 745,990
some of the differences that

554
00:14:38,525 --> 00:14:39,245
0,90 90,210 210,375 375,615 615,720
are going to emerge as

555
00:14:39,245 --> 00:14:40,895
0,135 135,285 285,525 525,875 1375,1650
we go further down the

556
00:14:40,895 --> 00:14:42,200
0,240 240,645 645,765 765,885 885,1305
different modes for the locks.

557
00:14:42,200 --> 00:14:44,195
0,360 360,765 765,1040 1390,1845 1845,1995
{Often,locks -} have dozens of

558
00:14:44,195 --> 00:14:45,440
0,210 210,645 645,900 900,1050 1050,1245
different {modes.,We'll -} talk about

559
00:14:45,440 --> 00:14:47,220
0,195 195,500 790,1190
that briefly today.|
|

560
00:14:47,220 --> 00:14:48,830
0,405 405,825 825,960 960,1215 1215,1610
Locks latches are typically simple
锁存通常是简单的读和写，尽管锁存在许多编程环境中也开始变得更加复杂，除了其中不同级别的用户和写入。

561
00:14:48,910 --> 00:14:50,475
0,290 290,470 470,760 900,1205 1205,1565
read and write, though latches

562
00:14:50,475 --> 00:14:51,645
0,180 180,480 480,810 810,1020 1020,1170
have also started to become

563
00:14:51,645 --> 00:14:53,510
0,195 195,935 1045,1335 1335,1545 1545,1865
more sophisticated in many programming

564
00:14:53,650 --> 00:14:55,320
0,640 870,1160 1160,1325 1325,1490 1490,1670
environments besides user and writes

565
00:14:55,320 --> 00:14:56,480
0,165 165,390 390,675 675,885 885,1160
at different levels in there.|
|

566
00:14:57,100 --> 00:14:58,035
0,275 275,455 455,590 590,785 785,935
And we'll talk about that
在这堂课的最后，我们将在锁的背景下讨论这一点。

567
00:14:58,035 --> 00:14:59,270
0,180 180,330 330,525 525,765 765,1235
within the context of locks

568
00:14:59,440 --> 00:15:00,270
0,290 290,410 410,515 515,665 665,830
towards the end of this

569
00:15:00,270 --> 00:15:01,260
0,290
lecture.|
|

570
00:15:01,660 --> 00:15:03,540
0,700 810,1100 1100,1310 1310,1670 1670,1880
Locks end up needing some
当获得的锁遇到问题时，锁最终需要某种机制，这样就不能取得任何进展。这在锁定场景中称为死锁，我们将讨论处理该问题的机制。

571
00:15:03,540 --> 00:15:05,055
0,320 700,975 975,1110 1110,1305 1305,1515
mechanism when you get into

572
00:15:05,055 --> 00:15:06,300
0,225 225,465 465,885 885,1050 1050,1245
trouble with locks that are

573
00:15:06,300 --> 00:15:07,365
0,240 240,420 420,570 570,780 780,1065
acquired so that no progress

574
00:15:07,365 --> 00:15:08,445
0,255 255,390 390,600 600,930 930,1080
can be made. {It's,called -}

575
00:15:08,445 --> 00:15:10,050
0,675 675,930 930,1050 1050,1350 1350,1605
deadlocks in the locking scenario,

576
00:15:10,050 --> 00:15:11,325
0,255 255,420 420,555 555,735 735,1275
and we'll talk about mechanisms

577
00:15:11,325 --> 00:15:12,640
0,165 165,330 330,510 510,785
to deal with that.|
|

578
00:15:12,640 --> 00:15:14,110
0,555 555,720 720,855 855,1110 1110,1470
Latches the way you avoid
锁定的方式可以避免出现这样的情况：一个线程抢占了一个资源，另一个线程抢占了另一个资源，现在它们试图请求相反的资源集。他们会陷入困境的。用闩锁避免这种情况的方法是说，作为程序员，我会编写代码，这样它就永远不会发生。

579
00:15:14,110 --> 00:15:15,880
0,380 460,825 825,1190 1300,1590 1590,1770
that situation where a thread

580
00:15:15,880 --> 00:15:17,245
0,165 165,405 405,600 600,950 1030,1365
has grabbed a resource, another

581
00:15:17,245 --> 00:15:18,720
0,225 225,420 420,750 750,1055 1075,1475
thread has grabbed another resource

582
00:15:18,890 --> 00:15:19,915
0,290 290,500 500,725 725,905 905,1025
and now they try to

583
00:15:19,915 --> 00:15:20,980
0,180 180,405 405,540 540,785 805,1065
ask for the opposite set

584
00:15:20,980 --> 00:15:22,690
0,210 210,560 790,1095 1095,1380 1380,1710
of resource. {They,will -} get

585
00:15:22,690 --> 00:15:24,120
0,225 225,500 730,990 990,1140 1140,1430
into {trouble.,The -} way you

586
00:15:24,230 --> 00:15:25,945
0,305 305,575 575,845 845,1420 1440,1715
avoid that with latches is

587
00:15:25,945 --> 00:15:26,800
0,135 135,315 315,540 540,720 720,855
you say I as a

588
00:15:26,800 --> 00:15:28,255
0,465 465,645 645,945 945,1215 1215,1455
programmer will write the code

589
00:15:28,255 --> 00:15:29,310
0,240 240,375 375,525 525,735 735,1055
so that it never happens.|
|

590
00:15:29,940 --> 00:15:31,190
0,195 195,330 330,420 420,945 945,1250
So it's the programmer's responsibility.|
所以这是程序员的责任。|

591
00:15:32,870 --> 00:15:34,165
0,380 380,650 650,800 800,1055 1055,1295
Database guys are nice. {We,actually
数据库的人都很好。我们实际上投入了系统机制，以便在这种情况发生时，我们可以抓住它并摆脱它。

592
00:15:34,165 --> 00:15:35,110
0,210 210,495 495,660 660,750 750,945
-} put into the system

593
00:15:35,110 --> 00:15:36,160
0,350 400,660 660,780 780,915 915,1050
mechanism so that if that

594
00:15:36,160 --> 00:15:37,165
0,210 210,420 420,555 555,735 735,1005
happens, we can catch it

595
00:15:37,165 --> 00:15:38,220
0,270 270,450 450,615 615,780 780,1055
and come out of that.|
|

596
00:15:38,720 --> 00:15:39,905
0,270 270,600 600,840 840,1005 1005,1185
And typically when you're using
通常，当你在一些C++代码中使用锁存时，你会说，我会一直遵循一个序列，我会做动作a，然后是b，然后是c，这样你就永远不会陷入这种死锁的情况。但是去做这件事是程序员的责任，对吧。

597
00:15:39,905 --> 00:15:41,075
0,435 435,585 585,765 765,960 960,1170
latches in some c plus

598
00:15:41,075 --> 00:15:42,665
0,225 225,480 480,750 750,1085 1315,1590
plus code, for example, you

599
00:15:42,665 --> 00:15:44,150
0,150 150,315 315,725 895,1215 1215,1485
will say I'll always follow

600
00:15:44,150 --> 00:15:45,230
0,195 195,420 420,735 735,840 840,1080
a sequence, I'll do action

601
00:15:45,230 --> 00:15:46,625
0,330 330,645 645,885 885,1095 1095,1395
a followed by b, followed

602
00:15:46,625 --> 00:15:47,690
0,255 255,545 565,825 825,945 945,1065
by c, so that you

603
00:15:47,690 --> 00:15:48,785
0,135 135,330 330,525 525,750 750,1095
can never end up in

604
00:15:48,785 --> 00:15:50,255
0,270 270,755 805,1125 1125,1290 1290,1470
this deadlock situation. {But,it's -}

605
00:15:50,255 --> 00:15:52,700
0,210 210,1005 1005,1325 1975,2250 2250,2445
the programmer's responsibility to go

606
00:15:52,700 --> 00:15:54,060
0,240 240,435 435,615 615,920
and do that, right.|
|

607
00:15:54,870 --> 00:15:56,795
0,425 425,560 560,785 785,1445 1445,1925
Locks have these inbuilt deadlock
锁有这些内置的死锁机制，可以让您在进入死锁时摆脱麻烦。

608
00:15:56,795 --> 00:15:57,995
0,585 585,780 780,945 945,1080 1080,1200
mechanisms that allow you to

609
00:15:57,995 --> 00:15:59,090
0,105 105,225 225,375 375,665 775,1095
get out of that trouble

610
00:15:59,090 --> 00:16:00,070
0,180 180,300 300,525 525,735 735,980
if you get into that.|
|

611
00:16:00,600 --> 00:16:02,205
0,225 225,375 375,855 855,1110 1110,1605
And the mechanisms for deadlocks,
而死锁的机制，正如我们将看到的，程序员在使用闩锁时必须执行等待和超时机制。

612
00:16:02,205 --> 00:16:02,880
0,120 120,330 330,420 420,525 525,675
as we'll see, a wait

613
00:16:02,880 --> 00:16:05,085
0,210 210,420 420,750 750,1430 1630,2205
for and timeout mechanisms programmers

614
00:16:05,085 --> 00:16:06,740
0,150 150,285 285,420 420,695 1255,1655
have to do that in

615
00:16:06,970 --> 00:16:08,760
0,290 290,470 470,650 650,1240
when they're using latches.|
|

616
00:16:08,900 --> 00:16:10,495
0,610 630,950 950,1220 1220,1445 1445,1595
Locks the state for the
锁住了州里的锁，谁有什么？锁管理器中保存的用户请求的内容。对于锁存，当你在你的c++代码中写它的时候，它会在一些受保护的数据结构中，对吗？您可能会使用一个变量来跟踪该闩锁对象，这就是您要做的。因此，锁存在内存中，可以保护线程不会陷入麻烦。需要大量的程序员纪律来确保您不会陷入麻烦。

617
00:16:10,495 --> 00:16:12,640
0,525 525,810 810,1065 1065,1415 1735,2145
locks, who has what? What's

618
00:16:12,640 --> 00:16:13,930
0,225 225,630 630,765 765,1020 1020,1290
been requested by who is

619
00:16:13,930 --> 00:16:14,820
0,165 165,315 315,435 435,585 585,890
kept in the lock manager.

620
00:16:15,380 --> 00:16:16,750
0,350 350,650 650,1085 1085,1205 1205,1370
{And,for -} latches when you're

621
00:16:16,750 --> 00:16:17,440
0,135 135,300 300,420 420,540 540,690
writing that in your c

622
00:16:17,440 --> 00:16:18,880
0,210 210,435 435,740 970,1305 1305,1440
plus plus code, it's going

623
00:16:18,880 --> 00:16:19,660
0,120 120,180 180,270 270,480 480,780
to be in some protected

624
00:16:19,660 --> 00:16:20,920
0,345 345,720 720,975 975,1110 1110,1260
data structure, right? You might

625
00:16:20,920 --> 00:16:22,945
0,290 790,1080 1080,1370 1540,1815 1815,2025
have a variable that you're

626
00:16:22,945 --> 00:16:24,330
0,245 445,720 720,900 900,1095 1095,1385
using to keep track of

627
00:16:24,680 --> 00:16:27,895
0,400 600,1030 1980,2380 2700,2990 2990,3215
that latch object and that's

628
00:16:27,895 --> 00:16:29,275
0,120 120,270 270,420 420,695 835,1380
what you {do.,So -} latches

629
00:16:29,275 --> 00:16:31,105
0,255 255,585 585,935 1165,1500 1500,1830
are in memory protect threads

630
00:16:31,105 --> 00:16:32,650
0,150 150,405 405,660 660,935 1255,1545
from getting {into,trouble. -} A

631
00:16:32,650 --> 00:16:34,765
0,255 255,510 510,1190 1330,1730 1840,2115
lot of programmer discipline is

632
00:16:34,765 --> 00:16:35,905
0,275 475,750 750,900 900,1035 1035,1140
needed to make sure you

633
00:16:35,905 --> 00:16:37,160
0,195 195,360 360,555 555,815
don't get into trouble.|
|

634
00:16:37,200 --> 00:16:39,515
0,400 780,1325 1325,1520 1520,1840 1920,2315
Ah, locks are for things
啊，锁是为磁盘上的东西设置的，这样它们就可以保持更长的时间。如果你记得这张图，我们有一张图表，根据到达物体所需的时间与内存中的时间，有很多个数量级。因此，锁将被保持更长的时间，并且它们有更多与其关联的机制，例如死锁检测问题。

635
00:16:39,515 --> 00:16:40,910
0,345 345,585 585,765 765,1140 1140,1395
that are on disk so

636
00:16:40,910 --> 00:16:41,795
0,255 255,405 405,585 585,765 765,885
they get held for a

637
00:16:41,795 --> 00:16:43,085
0,225 225,480 480,630 630,905 1015,1290
longer amount of time. {If,you

638
00:16:43,085 --> 00:16:45,680
0,165 165,455 805,1205 1255,1655 2335,2595
-} remember the graph, the

639
00:16:45,680 --> 00:16:46,505
0,180 180,375 375,510 510,660 660,825
chart that we had in

640
00:16:46,505 --> 00:16:47,645
0,195 195,510 510,765 765,930 930,1140
terms of how much time

641
00:16:47,645 --> 00:16:49,220
0,165 165,300 300,465 465,755 1285,1575
does it take to reach

642
00:16:49,220 --> 00:16:50,345
0,150 150,375 375,630 630,855 855,1125
an object on this versus

643
00:16:50,345 --> 00:16:51,230
0,210 210,420 420,615 615,735 735,885
in memory, there were many

644
00:16:51,230 --> 00:16:52,925
0,255 255,495 495,1100 1120,1410 1410,1695
orders of {magnitude.,So -} locks

645
00:16:52,925 --> 00:16:53,555
0,105 105,240 240,360 360,465 465,630
are going to be held

646
00:16:53,555 --> 00:16:54,910
0,225 225,545 565,870 870,1065 1065,1355
for longer amounts of time

647
00:16:55,140 --> 00:16:56,000
0,290 290,425 425,530 530,665 665,860
and they have a lot

648
00:16:56,000 --> 00:16:57,590
0,225 225,810 810,1155 1155,1425 1425,1590
more mechanisms associated with them,

649
00:16:57,590 --> 00:16:59,740
0,180 180,600 600,1160 1180,1580
like deadlock detection question.|
|

650
00:17:06,560 --> 00:17:07,750
0,335 335,560 560,815 815,1025 1025,1190
Very good question. {So,what's -}
问得好。那么，锁管理器和受保护的数据结构有什么不同，我提到的锁管理器，这个哈希表是什么？

651
00:17:07,750 --> 00:17:08,560
0,75 75,315 315,570 570,675 675,810
the difference between the lock

652
00:17:08,560 --> 00:17:10,795
0,290 490,890 1000,1400 1600,1935 1935,2235
manager and the protected data

653
00:17:10,795 --> 00:17:12,400
0,365 685,945 945,1125 1125,1395 1395,1605
structure, the lock manager that

654
00:17:12,400 --> 00:17:13,195
0,120 120,330 330,540 540,660 660,795
I mentioned, which is this

655
00:17:13,195 --> 00:17:14,420
0,285 285,545
hash table?|
|

656
00:17:14,460 --> 00:17:16,040
0,320 320,530 530,820 900,1265 1265,1580
Will be written and protected
将被写入并由闩锁保护。所以现在他是一个锁管理器，由一个完全兼容的闩锁保护。锁管理器仍在内存中。它是内存中的数据结构。多个事务正在尝试访问它，因此您将使用闩锁来保护锁管理器。

657
00:17:16,040 --> 00:17:17,480
0,195 195,300 300,590 1030,1305 1305,1440
by a latch. {So,now -}

658
00:17:17,480 --> 00:17:18,695
0,195 195,315 315,525 525,840 840,1215
he's the lock manager that's

659
00:17:18,695 --> 00:17:19,670
0,255 255,450 450,540 540,765 765,975
protected by a latch which

660
00:17:19,670 --> 00:17:21,590
0,120 120,270 270,870 870,1160 1570,1920
is all {compatible.,Still, -} lock

661
00:17:21,590 --> 00:17:22,840
0,345 345,600 600,780 780,975 975,1250
manager is sitting {in,memory. -}

662
00:17:23,160 --> 00:17:24,785
0,365 365,610 720,1025 1025,1295 1295,1625
It's a in {memory,data -}

663
00:17:24,785 --> 00:17:27,365
0,365 625,1025 1135,1535 1675,2075 2275,2580
structure. Multiple transactions are trying

664
00:17:27,365 --> 00:17:29,315
0,305 745,1050 1050,1355 1435,1695 1695,1950
to access it, so you'll

665
00:17:29,315 --> 00:17:30,910
0,210 210,405 405,675 675,1055 1195,1595
protect the lock manager by

666
00:17:30,990 --> 00:17:32,400
0,290 290,610
a latch.|
|

667
00:17:32,580 --> 00:17:33,470
0,275 275,410 410,530 530,665 665,890
Which is an in memory
这是记忆中的东西。所以它们兼容一个锁存器，受保护的数据结构，你知道的。所以这些并不是不相容的。数据库，您将实际看到闩锁。LockMatch就是一个很好的例子，因为它本身是锁定的，而您可能不想在整个锁表上放置一个闩锁。因此，您将在它的一些块上设置闩锁，这样单个请求就不会阻塞所有人，否则锁管理器将成为瓶颈。

668
00:17:33,470 --> 00:17:34,910
0,240 240,405 405,600 600,1200 1200,1440
stuff. {So,they're -} compatible a

669
00:17:34,910 --> 00:17:36,850
0,320 610,960 960,1260 1260,1575 1575,1940
latch, the protected data structure

670
00:17:37,080 --> 00:17:38,120
0,395 395,665 665,800 800,920 920,1040
the, you {know.,So -} these

671
00:17:38,120 --> 00:17:39,350
0,135 135,285 285,870 870,990 990,1230
are {not,incompatible. -} The database

672
00:17:39,350 --> 00:17:41,180
0,315 315,525 525,765 765,1280 1330,1830
you'll {actually,see -} latches. Lockmatch

673
00:17:41,180 --> 00:17:42,260
0,150 150,270 270,465 465,800 820,1080
is a great example because

674
00:17:42,260 --> 00:17:43,925
0,195 195,435 435,740 790,1425 1425,1665
that itself is latched and

675
00:17:43,925 --> 00:17:44,765
0,150 150,345 345,585 585,705 705,840
you probably don't want to

676
00:17:44,765 --> 00:17:45,425
0,105 105,210 210,360 360,495 495,660
put a latch on {the,entire

677
00:17:45,425 --> 00:17:46,715
0,225 225,450 450,755 895,1125 1125,1290
-} lock table. So you'll

678
00:17:46,715 --> 00:17:48,815
0,150 150,665 985,1365 1365,1695 1695,2100
put latches on some chunks

679
00:17:48,815 --> 00:17:50,105
0,135 135,330 330,510 510,785 1015,1290
of it so that a

680
00:17:50,105 --> 00:17:51,620
0,275 385,660 660,945 945,1215 1215,1515
single request doesn't block everyone

681
00:17:51,620 --> 00:17:52,745
0,180 180,390 390,600 600,795 795,1125
because otherwise the lock manager

682
00:17:52,745 --> 00:17:54,180
0,300 300,465 465,585 585,1205
will become the bottleneck.|
|

683
00:17:54,940 --> 00:17:56,460
0,365 365,560 560,910 1110,1385 1385,1520
What's the difference between the?|
两者之间有什么不同？|

684
00:17:59,500 --> 00:18:00,975
0,275 275,550 600,1025 1025,1205 1205,1475
They are protecting very different
他们保护的是截然不同的东西。因此，考虑一下锁管理器。它是在保护记忆中的结构，是的。

685
00:18:00,975 --> 00:18:02,430
0,300 300,635 715,1065 1065,1305 1305,1455
things. {So,think -} about the

686
00:18:02,430 --> 00:18:03,600
0,165 165,390 390,705 705,1035 1035,1170
lock {manager.,It's -} protecting an

687
00:18:03,600 --> 00:18:05,300
0,180 180,465 465,860 1120,1520
in memory structure, yeah.|
|

688
00:18:05,410 --> 00:18:06,900
0,365 365,695 695,980 980,1220 1220,1490
And the lock manager is
并且锁管理器正在保护记录A和记录B，即在缓冲池中。它可能会被逐出并放在磁盘上，但锁仍被持有。

689
00:18:06,900 --> 00:18:08,280
0,405 405,555 555,795 795,1125 1125,1380
protecting the record a and

690
00:18:08,280 --> 00:18:10,380
0,240 240,590 970,1335 1335,1700 1810,2100
record b that is, in

691
00:18:10,380 --> 00:18:11,430
0,135 135,435 435,675 675,915 915,1050
the buffer pool. {It,may -}

692
00:18:11,430 --> 00:18:12,405
0,120 120,465 465,720 720,855 855,975
get evicted and go on

693
00:18:12,405 --> 00:18:13,200
0,255 255,360 360,480 480,615 615,795
disk, but the lock is

694
00:18:13,200 --> 00:18:14,220
0,165 165,440
still held.|
|

695
00:18:14,220 --> 00:18:15,470
0,255 255,405 405,680 700,975 975,1250
Till the transaction is done.|
直到交易完成。|

696
00:18:16,160 --> 00:18:17,140
0,400
Okay.|
好吧。|

697
00:18:18,380 --> 00:18:19,480
0,275 275,425 425,620 620,785 785,1100
And now there's a related
现在有一个相关的问题，比如，这些锁什么时候会有闩锁？当你明确地以程序员的身份获得你的时候，你会说，在这种模式下获取这个闩锁吗？

698
00:18:19,480 --> 00:18:20,800
0,330 330,555 555,825 825,1140 1140,1320
question is like, when do

699
00:18:20,800 --> 00:18:22,450
0,165 165,495 495,720 720,1070 1360,1650
these locks get acquired a

700
00:18:22,450 --> 00:18:23,640
0,270 270,480 480,630 630,870 870,1190
latch? When you acquire you

701
00:18:23,660 --> 00:18:24,970
0,530 530,605 605,710 710,1115 1115,1310
explicitly as a programmer writing

702
00:18:24,970 --> 00:18:25,930
0,165 165,360 360,555 555,705 705,960
a code to say, acquire

703
00:18:25,930 --> 00:18:27,450
0,225 225,560 760,1035 1035,1215 1215,1520
this latch in this mode?|
|

704
00:18:28,210 --> 00:18:29,820
0,455 455,590 590,845 845,1090 1260,1610
Locks, as we'll see, get
正如我们将看到的，锁是被获取的。

705
00:18:29,820 --> 00:18:31,020
0,350
acquired.|
|

706
00:18:31,060 --> 00:18:32,870
0,890 890,1010 1010,1130 1130,1390 1410,1810
Implicitly by the database system,
由数据库系统隐式执行，在极少数情况下，您以程序员的身份显式地在SQL中指定Grab This Lock。

707
00:18:33,340 --> 00:18:35,055
0,335 335,815 815,1130 1130,1400 1400,1715
and you're in very rare

708
00:18:35,055 --> 00:18:36,960
0,365 595,1125 1125,1230 1230,1365 1365,1905
cases, explicitly as a programmer

709
00:18:36,960 --> 00:18:38,550
0,150 150,585 585,1110 1110,1380 1380,1590
in sql specifying grab this

710
00:18:38,550 --> 00:18:39,380
0,290
lock.|
|

711
00:18:39,840 --> 00:18:40,865
0,260 260,380 380,800 800,935 935,1025
And the simplest way you
最简单的方法是，如果您在页面级别锁定，则可以理解这一点。

712
00:18:40,865 --> 00:18:42,215
0,240 240,540 540,845 895,1155 1155,1350
can understand that if you're

713
00:18:42,215 --> 00:18:43,240
0,240 240,360 360,480 480,675 675,1025
locking at the page level.|
|

714
00:18:43,930 --> 00:18:45,555
0,400 750,1040 1040,1340 1340,1475 1475,1625
Is your buffer pool that
你写的缓冲池，想象一下，对缓冲池的调用也说，嘿，请识别你是哪个事务。还有一个参数。顺便说一句，告诉我您是读锁还是排他锁，在这种情况下，调用页面的缓冲区管理器本身就可以代表事务工作向锁管理器发出请求。

715
00:18:45,555 --> 00:18:47,160
0,150 150,425 835,1200 1200,1425 1425,1605
you wrote imagine the call

716
00:18:47,160 --> 00:18:48,135
0,165 165,255 255,525 525,690 690,975
to the buffer pool also

717
00:18:48,135 --> 00:18:49,830
0,395 475,795 795,1115 1255,1530 1530,1695
said, hey, please identify which

718
00:18:49,830 --> 00:18:51,075
0,290 370,630 630,855 855,1095 1095,1245
transaction you are. {One,more -}

719
00:18:51,075 --> 00:18:52,590
0,515 775,1065 1065,1245 1245,1395 1395,1515
{parameter.,And -} oh by the

720
00:18:52,590 --> 00:18:53,505
0,150 150,345 345,555 555,765 765,915
way, tell me whether you

721
00:18:53,505 --> 00:18:54,405
0,105 105,225 225,390 390,645 645,900
are a read lock or

722
00:18:54,405 --> 00:18:56,220
0,305 325,735 735,1115 1285,1605 1605,1815
a exclusive lock, in which

723
00:18:56,220 --> 00:18:58,515
0,290 400,690 690,1190 1450,1850 1960,2295
case the buffer manager called

724
00:18:58,515 --> 00:19:00,000
0,195 195,300 300,545 685,1085 1135,1485
to the page can itself

725
00:19:00,000 --> 00:19:01,185
0,285 285,525 525,705 705,930 930,1185
go and make the request

726
00:19:01,185 --> 00:19:02,145
0,150 150,240 240,390 390,660 660,960
to the lock manager on

727
00:19:02,145 --> 00:19:03,800
0,335 355,645 645,810 810,1085 1255,1655
behalf of the transactions work.|
|

728
00:19:04,280 --> 00:19:05,330
0,345 345,615 615,780 780,915 915,1050
So that is at the
因此，这是在页面级别。在创纪录的水平上，情况变得更加复杂。但这就是数据库的编写方式，即在发生数据访问的适当时间点，锁定请求将被内置到其中。因此，作为一名数据库程序员，您不必将锁定请求放在代码中。正确的抽象将负责输入该请求。

729
00:19:05,330 --> 00:19:06,230
0,195 195,450 450,630 630,735 735,900
page level. {At,the -} record

730
00:19:06,230 --> 00:19:07,240
0,225 225,390 390,555 555,735 735,1010
level, it gets more {complicated.,But

731
00:19:07,440 --> 00:19:08,350
0,275 275,485 485,575 575,665 665,910
-} that's how a database

732
00:19:08,370 --> 00:19:10,265
0,305 305,610 870,1190 1190,1510 1530,1895
is written, is that at

733
00:19:10,265 --> 00:19:11,500
0,365 385,705 705,885 885,990 990,1235
appropriate points where the data

734
00:19:11,520 --> 00:19:13,220
0,260 260,520 720,995 995,1415 1415,1700
access happen, the locking request

735
00:19:13,220 --> 00:19:14,165
0,195 195,315 315,450 450,720 720,945
will be in built {into,that.

736
00:19:14,165 --> 00:19:15,110
0,245 295,570 570,705 705,825 825,945
-} So you as a

737
00:19:15,110 --> 00:19:16,490
0,260 310,945 945,1155 1155,1260 1260,1380
database programmer don't have to

738
00:19:16,490 --> 00:19:17,525
0,165 165,450 450,720 720,870 870,1035
put lock request all {over,your

739
00:19:17,525 --> 00:19:19,235
0,165 165,425 595,870 870,1145 1165,1710
-} code. The right abstraction

740
00:19:19,235 --> 00:19:19,955
0,150 150,300 300,435 435,555 555,720
will take care of putting

741
00:19:19,955 --> 00:19:21,320
0,180 180,405 405,755
in that request.|
|

742
00:19:21,630 --> 00:19:22,640
0,275 275,395 395,560 560,815 815,1010
And the page level stuff
页面级的东西是最容易理解的，因为你们已经编写了一个缓冲池，所以可以看到它是如何工作的。

743
00:19:22,640 --> 00:19:23,830
0,120 120,240 240,585 585,825 825,1190
is the easiest to understand

744
00:19:23,910 --> 00:19:24,755
0,275 275,395 395,515 515,665 665,845
because you guys have written

745
00:19:24,755 --> 00:19:25,580
0,150 150,420 420,600 600,735 735,825
a buffer pool so you

746
00:19:25,580 --> 00:19:26,315
0,120 120,255 255,405 405,570 570,735
can see how that would

747
00:19:26,315 --> 00:19:26,920
0,275
work.|
|

748
00:19:27,210 --> 00:19:28,415
0,335 335,605 605,860 860,1070 1070,1205
Okay, record level would go
好的，当您到达文件时，记录级别将略低于记录的访问路径，当您在此项目中编写所有这些插入调用和其他内容时，您会开始考虑，哦，如果我有一个事务管理系统，顺便说一句，作为下一个项目，我会把它放在哪里？它会在这些级别中的一个级别，好吗？

749
00:19:28,415 --> 00:19:29,390
0,90 90,255 255,510 510,765 765,975
a little bit below at

750
00:19:29,390 --> 00:19:31,055
0,270 270,540 540,830 1060,1425 1425,1665
the access path for the

751
00:19:31,055 --> 00:19:31,970
0,255 255,495 495,615 615,765 765,915
record when you get to

752
00:19:31,970 --> 00:19:33,560
0,105 105,350 760,1125 1125,1380 1380,1590
the file and as you're

753
00:19:33,560 --> 00:19:34,730
0,150 150,345 345,510 510,900 900,1170
writing all this insert calls

754
00:19:34,730 --> 00:19:35,705
0,225 225,450 450,675 675,825 825,975
and other stuff in this

755
00:19:35,705 --> 00:19:37,175
0,275 505,780 780,1035 1035,1320 1320,1470
project, you will start to

756
00:19:37,175 --> 00:19:38,150
0,165 165,345 345,510 510,720 720,975
think about it like, oh,

757
00:19:38,150 --> 00:19:39,040
0,210 210,330 330,450 450,600 600,890
if I had a transaction

758
00:19:39,120 --> 00:19:40,520
0,400 420,820 900,1145 1145,1265 1265,1400
management system, which is by

759
00:19:40,520 --> 00:19:41,420
0,105 105,225 225,495 495,765 765,900
the way, coming as the

760
00:19:41,420 --> 00:19:42,770
0,180 180,500 790,1080 1080,1230 1230,1350
next project, where would I

761
00:19:42,770 --> 00:19:43,670
0,135 135,375 375,615 615,765 765,900
put it? It would be

762
00:19:43,670 --> 00:19:44,500
0,135 135,270 270,390 390,540 540,830
at one of these levels,

763
00:19:44,880 --> 00:19:45,620
0,400
okay?|
|

764
00:19:46,210 --> 00:19:47,680
0,335 335,670
Other questions?|
还有其他问题吗？|

765
00:19:49,760 --> 00:19:50,960
0,305 305,610
All right.|
好的。|

766
00:19:50,960 --> 00:19:52,820
0,350 850,1185 1185,1425 1425,1680 1680,1860
So we already started to
所以我们已经开始暗示锁至少有两种口味，还有更多。

767
00:19:52,820 --> 00:19:54,455
0,300 300,540 540,830 910,1455 1455,1635
allude towards that locks come

768
00:19:54,455 --> 00:19:55,790
0,165 165,360 360,615 615,885 885,1335
in at least two flavors,

769
00:19:55,790 --> 00:19:57,080
0,120 120,210 210,390 390,710
there are many more.|
|

770
00:19:57,080 --> 00:19:58,420
0,165 165,405 405,735 735,1020 1020,1340
A shared lock that says
一个共享锁，说我正在阅读其他人想要阅读的人工智能并不关心。

771
00:19:58,830 --> 00:20:00,785
0,410 410,620 620,970 1320,1670 1670,1955
I'm reading a someone else

772
00:20:00,785 --> 00:20:02,585
0,255 255,435 435,600 1315,1590 1590,1800
wants to read AI don't

773
00:20:02,585 --> 00:20:03,520
0,245
care.|
|

774
00:20:03,520 --> 00:20:05,610
0,210 210,615 615,765 765,1520 1690,2090
The sharedlock is compatible with
共享锁与另一个共享锁兼容，这是兼容性矩阵，正如我们有时会看到的，除了共享锁和独占锁之外，还有更多的锁类型，所以这个兼容性矩阵会变得更大。所有这些都是说，共享锁与共享锁排他锁兼容。如果有人在一个对象上拥有它，你就不能在该对象上获得另一个独占锁。您不能在该对象上获得另一个共享锁。它基本上是在每个人等待它的时候阻止他们。是的，有几种锁。

775
00:20:05,660 --> 00:20:08,440
0,335 335,970 1080,1480 2190,2495 2495,2780
another sharedlock and this is

776
00:20:08,440 --> 00:20:10,960
0,240 240,885 885,1610 1750,2150 2170,2520
the compatibility matrix and as

777
00:20:10,960 --> 00:20:12,100
0,345 345,540 540,870 870,1080 1080,1140
we'll see sometimes there are

778
00:20:12,100 --> 00:20:13,680
0,90 90,285 285,620 910,1245 1245,1580
a lot more lock types

779
00:20:13,730 --> 00:20:15,150
0,305 305,485 485,695 695,1010 1010,1420
besides a shared and exclusive

780
00:20:15,380 --> 00:20:17,065
0,275 275,395 395,515 515,1175 1175,1685
and so this compatibility matrix

781
00:20:17,065 --> 00:20:18,700
0,210 210,435 435,755 1165,1440 1440,1635
can get bigger. {And,all -}

782
00:20:18,700 --> 00:20:20,005
0,195 195,345 345,620 760,1095 1095,1305
this is say says is

783
00:20:20,005 --> 00:20:21,370
0,135 135,375 375,660 660,840 840,1365
a shared lock is compatible

784
00:20:21,370 --> 00:20:22,780
0,135 135,240 240,405 405,740 1000,1410
with a shared lock exclusive

785
00:20:22,780 --> 00:20:23,845
0,285 285,465 465,690 690,930 930,1065
{lock.,If -} someone has it

786
00:20:23,845 --> 00:20:25,285
0,120 120,255 255,515 865,1140 1140,1440
on an object, you can't

787
00:20:25,285 --> 00:20:26,695
0,180 180,510 510,900 900,1185 1185,1410
get another exclusive lock on

788
00:20:26,695 --> 00:20:28,345
0,180 180,455 805,1170 1170,1410 1410,1650
{that,object. -} You you can't

789
00:20:28,345 --> 00:20:29,395
0,165 165,390 390,630 630,870 870,1050
get another shared lock {on,that

790
00:20:29,395 --> 00:20:31,260
0,150 150,425 685,1005 1005,1325 1465,1865
-} object. It basically blocks

791
00:20:31,370 --> 00:20:32,605
0,395 395,665 665,830 830,1010 1010,1235
everyone when {they're,waiting -} for

792
00:20:32,605 --> 00:20:33,640
0,150 150,390 390,705 705,840 840,1035
it. Yep, there's types of

793
00:20:33,640 --> 00:20:34,060
0,290
lock.|
|

794
00:20:34,250 --> 00:20:35,290
0,350 350,635 635,740 740,890 890,1040
Yeah, we'll come to that.
好的，我们会讲到那个的。拿着它就行了。这听起来很奇怪，还有其他类型的锁。所有数据库系统都至少有十几种不同类型的锁，以允许比我们所允许的更多的并行性。因此，首先我们将使用这些简单的锁，并确保一切安全。

795
00:20:35,290 --> 00:20:36,160
0,195 195,375 375,555 555,705 705,870
{Just,hold -} on to {that.,It

796
00:20:36,160 --> 00:20:37,525
0,195 195,420 420,1080 1080,1245 1245,1365
-} sounds bizarre that there

797
00:20:37,525 --> 00:20:38,700
0,90 90,270 270,495 495,675 675,1175
are other kinds {of,locks. {-},There

798
00:20:38,810 --> 00:20:40,510
0,305 305,610 690,1010 1010,1330 1350,1700
-} are. All database systems

799
00:20:40,510 --> 00:20:41,380
0,210 210,330 330,465 465,630 630,870
have at least a dozen

800
00:20:41,380 --> 00:20:42,835
0,285 285,510 510,705 705,1155 1155,1455
different types of locks to

801
00:20:42,835 --> 00:20:44,695
0,195 195,450 450,705 705,1505 1555,1860
allow even more parallelism than

802
00:20:44,695 --> 00:20:45,745
0,165 165,300 300,480 480,780 780,1050
{what,we -} will allow. So

803
00:20:45,745 --> 00:20:46,765
0,195 195,450 450,630 630,855 855,1020
first we'll just work with

804
00:20:46,765 --> 00:20:48,600
0,150 150,405 405,965 1195,1515 1515,1835
these simple locks and make

805
00:20:48,620 --> 00:20:49,760
0,290 290,580
everything safe.|
|

806
00:20:49,770 --> 00:20:51,305
0,320 320,640 660,1040 1040,1235 1235,1535
And then we'll very briefly
然后我们将非常简要地谈论多种不同类型的锁和。

807
00:20:51,305 --> 00:20:52,580
0,270 270,465 465,720 720,1035 1035,1275
talk about multiple different types

808
00:20:52,580 --> 00:20:53,860
0,180 180,435 435,680
of locks and.|
|

809
00:20:53,860 --> 00:20:54,910
0,285 285,390 390,615 615,855 855,1050
There's a vast amount of
这里面有大量的材料。因此，这就像是高级数据库类的插件，我们可以深入到其中，但它允许更多的并行性。因此，让我们只使用这些简单的锁，并尝试首先使其安全。好吧?

810
00:20:54,910 --> 00:20:55,900
0,210 210,375 375,570 570,780 780,990
material in that. {So,again, -}

811
00:20:55,900 --> 00:20:56,800
0,180 180,345 345,510 510,645 645,900
this is like a plug

812
00:20:56,800 --> 00:20:58,555
0,380 460,825 825,1110 1110,1430 1450,1755
for the advanced database class

813
00:20:58,555 --> 00:20:59,350
0,180 180,300 300,420 420,615 615,795
where we can go into

814
00:20:59,350 --> 00:21:00,370
0,240 240,465 465,630 630,780 780,1020
that, but it's to allow

815
00:21:00,370 --> 00:21:01,675
0,225 225,780 780,930 930,1140 1140,1305
more {parallelism.,So -} let's work

816
00:21:01,675 --> 00:21:03,000
0,195 195,390 390,600 600,855 855,1325
with just these simple locks

817
00:21:03,050 --> 00:21:04,000
0,320 320,500 500,620 620,770 770,950
and try and make it

818
00:21:04,000 --> 00:21:05,540
0,210 210,530 880,1280
safe first. Okay?|
|

819
00:21:06,150 --> 00:21:07,360
0,335 335,440 440,590 590,845 845,1210
That's a great question. {Why,many
这是个好问题。为什么有这么多锁？有些系统拥有。

820
00:21:07,920 --> 00:21:09,290
0,335 335,830 830,1055 1055,1160 1160,1370
-} locks? There are systems

821
00:21:09,290 --> 00:21:10,400
0,225 225,500
that have.|
|

822
00:21:10,400 --> 00:21:11,480
0,210 210,465 465,735 735,945 945,1080
Over 50 different types of
超过50种不同类型的锁。

823
00:21:11,480 --> 00:21:12,460
0,410
locks.|
|

824
00:21:13,040 --> 00:21:14,680
0,305 305,455 455,1040 1040,1505 1505,1640
And a compatibility matrix, which
以及一个兼容性矩阵，它将是这样的，以允许更多的并行性。它将允许更多的并行性，我将通过独占锁得到这一点的直觉。在某种程度上，我似乎不认为应该有额外的锁类型，但这里有一个例子。

825
00:21:14,680 --> 00:21:15,265
0,105 105,195 195,300 300,420 420,585
will be like that, to

826
00:21:15,265 --> 00:21:16,855
0,210 210,375 375,1085 1135,1410 1410,1590
allow more parallelism. {It,will -}

827
00:21:16,855 --> 00:21:18,520
0,180 180,330 330,1080 1080,1395 1395,1665
allow more parallelism, and I'll

828
00:21:18,520 --> 00:21:19,345
0,105 105,225 225,300 300,615 615,825
get to the intuition of

829
00:21:19,345 --> 00:21:20,725
0,275 355,630 630,810 810,1095 1095,1380
that with the exclusive {locks.,In

830
00:21:20,725 --> 00:21:21,370
0,105 105,210 210,360 360,510 510,645
-} a little bit, it

831
00:21:21,370 --> 00:21:22,300
0,195 195,420 420,600 600,810 810,930
seems like I don't think

832
00:21:22,300 --> 00:21:23,695
0,150 150,300 300,590 790,1140 1140,1395
there should be additional lock

833
00:21:23,695 --> 00:21:25,200
0,305 505,780 780,1035 1035,1185 1185,1505
types, but here's an example

834
00:21:25,670 --> 00:21:26,760
0,400
the.|
|

835
00:21:26,760 --> 00:21:28,335
0,270 270,585 585,870 870,1190 1300,1575
Different systems over here. {They,will
这里有不同的系统。他们都会以某种形式发布一些关于他们拥有的不同锁类型的信息，以及你在屏幕上看到的闪现。也许我会回到它，让它再次回来，这是已经披露的东西的兼容性矩阵。正如你所看到的，有很多不同类型的锁。这不是一个2乘2的矩阵。这是一个非常非常大的矩阵。

836
00:21:28,335 --> 00:21:29,480
0,135 135,315 315,555 555,810 810,1145
-} all at some form

837
00:21:29,500 --> 00:21:31,545
0,400 690,1090 1170,1570 1620,1910 1910,2045
publish some information about the

838
00:21:31,545 --> 00:21:32,700
0,225 225,525 525,780 780,1005 1005,1155
different lock types that they

839
00:21:32,700 --> 00:21:34,290
0,260 520,920 940,1215 1215,1365 1365,1590
have and what you saw

840
00:21:34,290 --> 00:21:35,715
0,255 255,405 405,600 600,950 1120,1425
flash up on {screen.,Maybe,I'll -

841
00:21:35,715 --> 00:21:36,660
0,255 255,375 375,555 555,765 765,945
-} just go back to

842
00:21:36,660 --> 00:21:37,710
0,260 310,600 600,750 750,885 885,1050
it and let it come

843
00:21:37,710 --> 00:21:39,630
0,240 240,590 790,1125 1125,1305 1305,1920
back again is the compatibility

844
00:21:39,630 --> 00:21:40,905
0,555 555,750 750,975 975,1140 1140,1275
matrix of things that have

845
00:21:40,905 --> 00:21:42,360
0,225 225,605 925,1200 1200,1335 1335,1455
{been,disclosed. -} And as you

846
00:21:42,360 --> 00:21:43,520
0,135 135,410 460,720 720,870 870,1160
can see there are tons

847
00:21:43,570 --> 00:21:45,225
0,290 290,485 485,665 665,940 1350,1655
and tons of {different,lock -}

848
00:21:45,225 --> 00:21:46,170
0,195 195,465 465,645 645,795 795,945
types. It's just not a

849
00:21:46,170 --> 00:21:47,745
0,165 165,330 330,495 495,1130 1150,1575
{two,by -} two matrix. It's

850
00:21:47,745 --> 00:21:49,520
0,165 165,485 505,840 840,1110 1110,1775
a much, much bigger matrix.|
|

851
00:21:50,670 --> 00:21:51,600
0,400
Okay.|
好吧。|

852
00:21:51,600 --> 00:21:52,215
0,135 135,270 270,390 390,510 510,615
And you can take a
你可以看一看。实际上，您可以很容易地找到Postgres的信息。我在最后一张幻灯片中有另一个屏幕截图，但手册在那里，你可以开始在那里看到一些锁定模式。

853
00:21:52,215 --> 00:21:53,235
0,180 180,375 375,495 495,735 735,1020
look. {You,can -} actually find

854
00:21:53,235 --> 00:21:55,860
0,545 685,1035 1035,1320 1320,1925 2395,2625
postgres information pretty {readily.,I -}

855
00:21:55,860 --> 00:21:57,255
0,135 135,390 390,855 855,1140 1140,1395
have another screenshot coming in

856
00:21:57,255 --> 00:21:58,260
0,135 135,345 345,645 645,870 870,1005
the last slide, but the

857
00:21:58,260 --> 00:21:59,250
0,330 330,465 465,630 630,795 795,990
manual is there and you

858
00:21:59,250 --> 00:22:00,045
0,165 165,315 315,510 510,660 660,795
you can start to see

859
00:22:00,045 --> 00:22:00,900
0,135 135,345 345,570 570,705 705,855
some of some of that

860
00:22:00,900 --> 00:22:02,220
0,195 195,495 495,615 615,890
lock modes in there.|
|

861
00:22:02,220 --> 00:22:02,880
0,120 120,240 240,375 375,510 510,660
All of that is to
所有这些都是为了允许更多的并行性。

862
00:22:02,880 --> 00:22:04,480
0,165 165,330 330,1040
allow more parallelism.|
|

863
00:22:04,480 --> 00:22:05,455
0,195 195,450 450,705 705,825 825,975
And make everything we talk
让我们今天谈论的一切也都安全，对吗？所以，但第一个想法是，我们如何正确地使用锁？

864
00:22:05,455 --> 00:22:06,760
0,240 240,450 450,705 705,1035 1035,1305
about today also safe, right?

865
00:22:06,760 --> 00:22:09,235
0,320 1300,1590 1590,1860 1860,2190 2190,2475
So, but the first idea

866
00:22:09,235 --> 00:22:10,045
0,225 225,390 390,555 555,690 690,810
is like, how do we

867
00:22:10,045 --> 00:22:12,040
0,165 165,345 345,815 1015,1415
work with locks correctly?|
|

868
00:22:12,040 --> 00:22:12,925
0,195 195,420 420,555 555,705 705,885
So let's start on that
所以让我们先从这个话题开始。好的，现在只有两种锁定模式。

869
00:22:12,925 --> 00:22:14,725
0,270 270,635 835,1235 1285,1605 1605,1800
topic first. {Okay,,staying -} with

870
00:22:14,725 --> 00:22:15,780
0,180 180,345 345,510 510,795 795,1055
just two lock modes now.|
|

871
00:22:16,410 --> 00:22:19,595
0,400 570,970 1230,1550 1550,1870 2850,3185
Alright, so we will have
好的，那么我们将拥有事务请求锁。

872
00:22:19,595 --> 00:22:21,780
0,335 625,990 990,1595
transaction request locks.|
|

873
00:22:22,440 --> 00:22:23,735
0,290 290,455 455,665 665,980 980,1295
And this is also notion
这也是锁升级的概念，你在这节课上基本上会忽略它。同样，高级数据库类涵盖了这一点，因为有时，例如，如果您使用这个缓冲池，如果您正在查看页面级别，您会在SQL查询中请求页面请求，并且您知道，在一个只扫描所有记录的SQL查询应用程序中。然后，可能在同一事务中的下一个查询中，它说我将更新我看到的一些记录。

874
00:22:23,735 --> 00:22:25,010
0,225 225,515 535,885 885,1065 1065,1275
of lock upgrades, which you're

875
00:22:25,010 --> 00:22:26,060
0,255 255,540 540,720 720,900 900,1050
basically going to ignore in

876
00:22:26,060 --> 00:22:28,775
0,165 165,470 640,1040 2080,2445 2445,2715
this class. {Again,,the -} advanced

877
00:22:28,775 --> 00:22:30,800
0,305 325,645 645,915 915,1265 1735,2025
database class covers that because

878
00:22:30,800 --> 00:22:31,970
0,290 340,600 600,720 720,975 975,1170
sometimes, like if you're take

879
00:22:31,970 --> 00:22:32,870
0,165 165,465 465,615 615,750 750,900
this buffer pool, if you're

880
00:22:32,870 --> 00:22:33,850
0,150 150,330 330,450 450,645 645,980
looking at the page level,

881
00:22:34,050 --> 00:22:35,240
0,275 275,455 455,710 710,995 995,1190
you ask a request for

882
00:22:35,240 --> 00:22:36,245
0,120 120,345 345,570 570,690 690,1005
a page in a sql

883
00:22:36,245 --> 00:22:37,925
0,305 685,1085 1135,1410 1410,1545 1545,1680
query and, you know, in

884
00:22:37,925 --> 00:22:38,945
0,275 295,615 615,795 795,915 915,1020
an application that is a

885
00:22:38,945 --> 00:22:40,070
0,285 285,495 495,690 690,840 840,1125
sql query that just scans

886
00:22:40,070 --> 00:22:41,360
0,285 285,450 450,710 880,1155 1155,1290
all the {records.,And -} then

887
00:22:41,360 --> 00:22:42,580
0,165 165,330 330,465 465,740 790,1220
maybe in the next query

888
00:22:42,630 --> 00:22:43,925
0,275 275,425 425,620 620,940 1020,1295
in that same transaction, it

889
00:22:43,925 --> 00:22:44,765
0,150 150,330 330,435 435,630 630,840
says I'm going to update

890
00:22:44,765 --> 00:22:45,635
0,180 180,315 315,435 435,645 645,870
some of the records I

891
00:22:45,635 --> 00:22:46,280
0,275
saw.|
|

892
00:22:46,280 --> 00:22:47,675
0,180 180,470 610,960 960,1215 1215,1395
Right, so grab all the
好的，那就拿上所有的学生记录。哦，对于B的学生来说，就是B+，对吧？因此，它只会更新它在第一个查询中扫描的一些记录，所以第一个、第一个、第一个查询都是同一事务的一部分。如果您正在执行页面级锁定，则可能只会发出请求将页面取到缓冲池中，而只是获取其上的读锁定。

893
00:22:47,675 --> 00:22:49,220
0,240 240,605 775,1140 1140,1395 1395,1545
student records. {Oh,,and -} for

894
00:22:49,220 --> 00:22:51,905
0,165 165,470 850,1250 1990,2385 2385,2685
the students that have a

895
00:22:51,905 --> 00:22:53,075
0,305 475,750 750,885 885,1005 1005,1170
b, make it a b

896
00:22:53,075 --> 00:22:54,215
0,285 285,570 570,705 705,945 945,1140
plus, right? So it's only

897
00:22:54,215 --> 00:22:55,190
0,225 225,450 450,690 690,855 855,975
going to update some of

898
00:22:55,190 --> 00:22:56,630
0,120 120,380 670,960 960,1155 1155,1440
the records that it scanned

899
00:22:56,630 --> 00:22:57,905
0,90 90,195 195,405 405,770 1000,1275
in the first one, so

900
00:22:57,905 --> 00:23:00,005
0,120 120,365 655,1055 1195,1595 1675,2100
the first, first, first query,

901
00:23:00,005 --> 00:23:00,845
0,330 330,450 450,600 600,735 735,840
it's all part of the

902
00:23:00,845 --> 00:23:02,830
0,150 150,455 1105,1410 1410,1650 1650,1985
same {transaction.,May -} just issue

903
00:23:03,000 --> 00:23:04,390
0,425 425,680 680,890 890,1100 1100,1390
requests to fetch in pages

904
00:23:04,440 --> 00:23:05,330
0,245 245,335 335,605 605,755 755,890
to the buffer pool if

905
00:23:05,330 --> 00:23:06,580
0,180 180,300 300,510 510,750 750,1250
you're doing page level locking

906
00:23:06,810 --> 00:23:08,525
0,320 320,560 560,880 900,1295 1295,1715
and just grab read locks

907
00:23:08,525 --> 00:23:09,300
0,150 150,455
on it.|
|

908
00:23:09,300 --> 00:23:10,185
0,210 210,375 375,555 555,705 705,885
But then some of those
但是其中一些页面存在感兴趣的记录，您想要将其设置为写锁、排他锁。这就是所谓的锁升级。当查询运行时，您不知道接下来会发生什么。

909
00:23:10,185 --> 00:23:11,420
0,285 285,555 555,765 765,960 960,1235
pages in which the records

910
00:23:11,440 --> 00:23:12,870
0,365 365,620 620,800 800,1090 1170,1430
of interest are present, you

911
00:23:12,870 --> 00:23:13,470
0,135 135,255 255,345 345,465 465,600
want to go and make

912
00:23:13,470 --> 00:23:14,940
0,135 135,410 640,975 975,1215 1215,1470
it a write lock, an

913
00:23:14,940 --> 00:23:16,275
0,360 360,735 735,990 990,1200 1200,1335
exclusive lock. {So,that's -} called

914
00:23:16,275 --> 00:23:17,865
0,135 135,395 415,845 1075,1395 1395,1590
a lock {upgrade.,When -} the

915
00:23:17,865 --> 00:23:19,620
0,270 270,510 510,785 1165,1470 1470,1755
query is running, you don't

916
00:23:19,620 --> 00:23:20,490
0,180 180,465 465,570 570,675 675,870
know what's going to happen

917
00:23:20,490 --> 00:23:21,540
0,350
next.|
|

918
00:23:21,830 --> 00:23:23,320
0,275 275,590 590,875 875,1190 1190,1490
When you're creating that operation
当您创建该操作以读取页面时，您知道您想要什么。我想要阅读它，因为我是一个SELECT查询。下一种方法是更新查询。现在，它需要更新一些东西。

919
00:23:23,320 --> 00:23:24,220
0,210 210,360 360,510 510,690 690,900
to read the page, you

920
00:23:24,220 --> 00:23:25,165
0,210 210,420 420,570 570,750 750,945
know what you want. {I,want

921
00:23:25,165 --> 00:23:26,080
0,180 180,330 330,465 465,705 705,915
-} to read it because

922
00:23:26,080 --> 00:23:27,400
0,150 150,300 300,525 525,860 1060,1320
I'm a select {query.,The -}

923
00:23:27,400 --> 00:23:28,330
0,165 165,315 315,420 420,660 660,930
next way is an {update,query.

924
00:23:28,330 --> 00:23:29,335
0,240 240,420 420,555 555,735 735,1005
-} Now it needs to

925
00:23:29,335 --> 00:23:30,620
0,300 300,635
update stuff.|
|

926
00:23:30,620 --> 00:23:32,135
0,255 255,560 880,1170 1170,1335 1335,1515
Right. {So,there -} are this
正确的。所以有了锁升级的概念，这就是我作为一项交易。

927
00:23:32,135 --> 00:23:33,620
0,255 255,510 510,815 925,1290 1290,1485
notion of lock upgrades, which

928
00:23:33,620 --> 00:23:34,330
0,120 120,225 225,330 330,450 450,710
is I as a transaction.|
|

929
00:23:35,960 --> 00:23:36,880
0,290 290,455 455,650 650,815 815,920
Can have asked for a
可以要求一个读锁。顺便说一下，我不是直接问这个问题。有人以我的名义问我。我只是在透露我的行动是什么。我正在读取一个文件，本例中的缓冲池可能会请求读取级别的页面锁定。

930
00:23:36,880 --> 00:23:37,825
0,165 165,470 490,750 750,855 855,945
read lock. {By,the -} way,

931
00:23:37,825 --> 00:23:39,210
0,165 165,285 285,575 685,1035 1035,1385
I'm not asking it {directly.,Someone's

932
00:23:39,500 --> 00:23:41,310
0,530 530,790 870,1175 1175,1445 1445,1810
-} asking on {my,behalf. -}

933
00:23:41,660 --> 00:23:42,940
0,350 350,530 530,950 950,1070 1070,1280
I'm just disclosing what {my,operation

934
00:23:42,940 --> 00:23:43,975
0,270 270,450 450,645 645,825 825,1035
-} is. I'm reading a

935
00:23:43,975 --> 00:23:45,430
0,275 685,960 960,1080 1080,1335 1335,1455
file and the buffer pool

936
00:23:45,430 --> 00:23:46,540
0,135 135,270 270,530 580,885 885,1110
in this case could be

937
00:23:46,540 --> 00:23:47,890
0,315 315,585 585,750 750,1020 1020,1350
asking for read level page

938
00:23:47,890 --> 00:23:48,880
0,530
locks.|
|

939
00:23:49,080 --> 00:23:50,440
0,275 275,440 440,620 620,910 960,1360
And the update transaction says
更新事务表明我将从缓冲池获取此页面，但顺便说一句，我要更改它上的内容，所以请抓取。

940
00:23:50,460 --> 00:23:51,605
0,350 350,500 500,695 695,920 920,1145
I'm getting this page from

941
00:23:51,605 --> 00:23:52,430
0,105 105,345 345,495 495,660 660,825
the buffer pool, but oh,

942
00:23:52,430 --> 00:23:52,955
0,150 150,255 255,330 330,435 435,525
by the way, I'm going

943
00:23:52,955 --> 00:23:53,920
0,105 105,270 270,510 510,690 690,965
to change stuff on it,

944
00:23:54,270 --> 00:23:55,540
0,290 290,580
so grab.|
|

945
00:23:56,000 --> 00:23:57,445
0,410 410,790 810,1100 1100,1250 1250,1445
Exclusive lock at the page
页面级别的独占锁定。

946
00:23:57,445 --> 00:23:58,440
0,335
level.|
|

947
00:23:58,440 --> 00:23:59,600
0,255 255,510 510,645 645,825 825,1160
So in the same transaction.|
所以在同一笔交易中。|

948
00:24:00,700 --> 00:24:01,615
0,210 210,420 420,585 585,765 765,915
First, a call might come
首先，对于读请求，调用可能返回到同一对象a。

949
00:24:01,615 --> 00:24:02,610
0,180 180,330 330,450 450,660 660,995
back to that same object

950
00:24:02,840 --> 00:24:04,530
0,400 570,860 860,1025 1025,1295 1295,1690
a for a read request.|
|

951
00:24:05,280 --> 00:24:06,465
0,135 135,270 270,435 435,740 850,1185
For a read lock and
对于读锁定以及以后，它可能会升级为排他锁，因此会发生这些升级。我们谈论的一切都符合这一计划。没有什么更复杂的事情需要处理了。我们将在很大程度上忽略这一点，但只想让您知道，这些升级正在发生，并且请求的日志流是代表在数据库引擎中的某个适当抽象发送的查询进行的。

952
00:24:06,465 --> 00:24:07,640
0,270 270,525 525,735 735,900 900,1175
later on it may get

953
00:24:07,720 --> 00:24:09,560
0,430 480,740 740,1000 1020,1445 1445,1840
upgraded to an exclusive lock

954
00:24:09,850 --> 00:24:11,535
0,260 260,500 500,830 830,1150 1410,1685
so those upgrades happen. {Everything,we

955
00:24:11,535 --> 00:24:12,780
0,135 135,330 330,660 660,1005 1005,1245
-} talk about works with

956
00:24:12,780 --> 00:24:14,010
0,225 225,560 760,990 990,1080 1080,1230
that {scheme.,There -} are few

957
00:24:14,010 --> 00:24:15,525
0,150 150,710 730,990 990,1185 1185,1515
more complications to {deal,about. -}

958
00:24:15,525 --> 00:24:16,890
0,270 270,420 420,695 835,1140 1140,1365
We will largely ignore that,

959
00:24:16,890 --> 00:24:17,700
0,195 195,360 360,525 525,675 675,810
but just want you to

960
00:24:17,700 --> 00:24:19,370
0,260 430,735 735,1005 1005,1335 1335,1670
know that these upgrades happen

961
00:24:19,690 --> 00:24:20,790
0,305 305,470 470,725 725,995 995,1100
and the log flow of

962
00:24:20,790 --> 00:24:22,140
0,180 180,480 480,735 735,1020 1020,1350
the requests is getting made

963
00:24:22,140 --> 00:24:23,445
0,360 360,630 630,795 795,945 945,1305
on behalf of the queries

964
00:24:23,445 --> 00:24:24,750
0,150 150,300 300,480 480,785 955,1305
that are being sent at

965
00:24:24,750 --> 00:24:26,745
0,330 330,710 910,1580 1600,1875 1875,1995
some appropriate abstraction in the

966
00:24:26,745 --> 00:24:27,880
0,245 265,665
database engine.|
|

967
00:24:28,920 --> 00:24:30,170
0,245 245,490 510,980 980,1085 1085,1250
The database programmer is not
数据库程序员没有在任何地方编写显式的日志调用。

968
00:24:30,170 --> 00:24:31,900
0,290 310,750 750,930 930,1220 1330,1730
writing explicit log calls everywhere.|
|

969
00:24:32,960 --> 00:24:34,075
0,305 305,545 545,725 725,890 890,1115
And lying a little bit,
稍微撒谎一点，当你在BTThree代码中有十几种不同的锁定模式时，你会开始看到BTThree程序员会放入一堆显式的锁调用。所以忽略了那篇文章，对吗？当您进入多个锁定模式时，您会开始看到锁定调用开始出现在特定位置，它可能会说，您知道，排他锁太严格了。这里放了这种较弱形式的排他锁，因为我知道我在做什么，当你在b树中进行锁耦合时，你已经对这种类型的东西有了一些直觉。

970
00:24:34,075 --> 00:24:34,825
0,165 165,270 270,375 375,525 525,750
when you have these dozen

971
00:24:34,825 --> 00:24:35,935
0,285 285,540 540,825 825,960 960,1110
different lock modes in the

972
00:24:35,935 --> 00:24:37,000
0,270 270,390 390,570 570,795 795,1065
BT three code, for example,

973
00:24:37,000 --> 00:24:38,185
0,240 240,435 435,600 600,860 910,1185
you start to see the

974
00:24:38,185 --> 00:24:39,325
0,255 255,360 360,840 840,990 990,1140
BT three programmer will have

975
00:24:39,325 --> 00:24:40,180
0,135 135,255 255,375 375,555 555,855
put in a bunch of

976
00:24:40,180 --> 00:24:42,580
0,420 420,710 820,1220 1540,1860 1860,2400
explicit lock calls. {So,ignored -}

977
00:24:42,580 --> 00:24:43,690
0,210 210,540 540,825 825,990 990,1110
that piece right? When you

978
00:24:43,690 --> 00:24:45,130
0,195 195,480 480,830 880,1170 1170,1440
get into multiple lock modes,

979
00:24:45,130 --> 00:24:45,925
0,150 150,315 315,480 480,630 630,795
then you start to see

980
00:24:45,925 --> 00:24:47,275
0,305 385,780 780,1065 1065,1215 1215,1350
lock calls start to show

981
00:24:47,275 --> 00:24:48,655
0,270 270,585 585,905 955,1260 1260,1380
up in specific places and

982
00:24:48,655 --> 00:24:49,710
0,90 90,270 270,540 540,780 780,1055
it might say, you know,

983
00:24:49,940 --> 00:24:51,265
0,380 380,605 605,800 800,1070 1070,1325
exclusive lock is too {strict.,Here,

984
00:24:51,265 --> 00:24:52,975
0,305 505,810 810,1035 1035,1500 1500,1710
-} put this weaker form

985
00:24:52,975 --> 00:24:54,235
0,270 270,630 630,930 930,1125 1125,1260
of exclusive lock because I

986
00:24:54,235 --> 00:24:55,320
0,195 195,435 435,615 615,840 840,1085
know just what I'm doing

987
00:24:55,520 --> 00:24:56,605
0,275 275,515 515,770 770,935 935,1085
and you already have some

988
00:24:56,605 --> 00:24:57,925
0,450 450,750 750,960 960,1140 1140,1320
intuition for that type of

989
00:24:57,925 --> 00:24:58,720
0,225 225,420 420,555 555,675 675,795
stuff right when you did

990
00:24:58,720 --> 00:24:59,575
0,120 120,285 285,630 630,750 750,855
the lock coupling in the

991
00:24:59,575 --> 00:25:00,400
0,165 165,485
b tree.|
|

992
00:25:00,400 --> 00:25:01,740
0,180 180,420 420,770
It was like.|
就像是。|

993
00:25:01,780 --> 00:25:02,925
0,290 290,470 470,650 650,1010 1010,1145
It was like latches at
这在当时就像是插销，但你可以看到，在某个时候，你可以放开一些东西，并对被引用为不安全表示无所谓。因为你知道，从语义上讲，你只关心树的结构。所以你不需要一直抱着东西。所以就是像这样的把戏被玩弄了。这就是你如何获得这种锁定模式的爆炸性增长。

994
00:25:02,925 --> 00:25:03,945
0,180 180,485 505,765 765,885 885,1020
that time, but you could

995
00:25:03,945 --> 00:25:04,665
0,135 135,255 255,375 375,525 525,720
see how you could let

996
00:25:04,665 --> 00:25:05,655
0,180 180,345 345,585 585,810 810,990
go of something at some

997
00:25:05,655 --> 00:25:07,320
0,305 445,765 765,1035 1035,1380 1380,1665
point and be okay with

998
00:25:07,320 --> 00:25:09,105
0,210 210,420 420,780 780,1530 1530,1785
being quote unquote unsafe. {Because,,you

999
00:25:09,105 --> 00:25:10,560
0,120 120,240 240,1035 1035,1305 1305,1455
-} know, semantically all you

1000
00:25:10,560 --> 00:25:11,370
0,165 165,330 330,450 450,600 600,810
care about is the structure

1001
00:25:11,370 --> 00:25:12,270
0,195 195,330 330,585 585,810 810,900
of the {tree.,So -} you

1002
00:25:12,270 --> 00:25:13,050
0,195 195,315 315,435 435,585 585,780
didn't need to hold on

1003
00:25:13,050 --> 00:25:14,970
0,165 165,360 360,680 1510,1755 1755,1920
to things for the {whole,time.

1004
00:25:14,970 --> 00:25:16,500
0,320 580,825 825,1050 1050,1350 1350,1530
-} So it's tricks like

1005
00:25:16,500 --> 00:25:17,745
0,225 225,450 450,660 660,930 930,1245
that that {get,played -} around.

1006
00:25:17,745 --> 00:25:18,680
0,300 300,405 405,510 510,645 645,935
That's how you get this

1007
00:25:18,790 --> 00:25:20,440
0,350 350,590 590,800 800,1240
explosion of lock modes.|
|

1008
00:25:20,950 --> 00:25:21,860
0,400
Okay.|
好吧。|

1009
00:25:21,860 --> 00:25:22,880
0,165 165,390 390,585 585,765 765,1020
But again, for now, we'll
但同样，现在，我们只讨论常规意义上的锁，锁升级会发生。锁管理器要么批准请求，要么不批准请求，只处理这些共享和排他锁。当升级时，当请求进入时，它将更新这个哈希表结构，该结构由锁存器保护，以跟踪所有已批准的请求和所有挂起的请求。

1010
00:25:22,880 --> 00:25:24,050
0,135 135,345 345,570 570,975 975,1170
just talk about locks in

1011
00:25:24,050 --> 00:25:25,595
0,165 165,435 435,830 940,1260 1260,1545
that regular sense and lock

1012
00:25:25,595 --> 00:25:27,400
0,315 315,635 745,1050 1050,1355 1405,1805
upgrades happen. {Lock,manager -} will

1013
00:25:27,510 --> 00:25:29,420
0,400 480,830 830,1130 1130,1480 1620,1910
either grant the request or

1014
00:25:29,420 --> 00:25:30,650
0,210 210,435 435,675 675,960 960,1230
not grant a request will

1015
00:25:30,650 --> 00:25:31,630
0,165 165,360 360,525 525,690 690,980
play around with just these

1016
00:25:31,710 --> 00:25:33,635
0,320 320,575 575,920 920,1480 1560,1925
shared and exclusive {locks.,And -}

1017
00:25:33,635 --> 00:25:35,590
0,240 240,510 510,935 1375,1665 1665,1955
when an upgrade, when an

1018
00:25:35,640 --> 00:25:36,770
0,290 290,515 515,755 755,965 965,1130
when a request comes in,

1019
00:25:36,770 --> 00:25:37,810
0,180 180,285 285,495 495,735 735,1040
it's going to update this

1020
00:25:37,830 --> 00:25:39,650
0,440 440,695 695,1090 1320,1595 1595,1820
hash table structure, which is

1021
00:25:39,650 --> 00:25:40,985
0,300 300,495 495,600 600,890 1060,1335
protected by a latch, to

1022
00:25:40,985 --> 00:25:41,945
0,180 180,375 375,540 540,720 720,960
keep track of all the

1023
00:25:41,945 --> 00:25:43,030
0,285 285,465 465,600 600,780 780,1085
requests that have been granted

1024
00:25:43,200 --> 00:25:44,240
0,275 275,440 440,650 650,890 890,1040
and all the requests that

1025
00:25:44,240 --> 00:25:45,100
0,120 120,560
are pending.|
|

1026
00:25:46,470 --> 00:25:48,245
0,400 630,1030 1080,1385 1385,1655 1655,1775
Alright, so now let's go
好的，现在让我们回到我们的例子。

1027
00:25:48,245 --> 00:25:50,180
0,275 325,570 570,750 750,1085
back to our example.|
|

1028
00:25:50,360 --> 00:25:51,295
0,275 275,440 440,605 605,740 740,935
We now have two different
我们现在有两种不同类型的锁。

1029
00:25:51,295 --> 00:25:52,740
0,225 225,390 390,875
types of locks.|
|

1030
00:25:52,740 --> 00:25:54,110
0,225 225,390 390,680 790,1080 1080,1370
So on transaction t one,
因此，在事务t1上，它不仅仅发出锁定请求。它会说我有一个X锁请求，因为我正在对它进行更改。我是一个最新的查询。

1031
00:25:54,130 --> 00:25:55,275
0,365 365,500 500,755 755,1010 1010,1145
it's not making just a

1032
00:25:55,275 --> 00:25:56,205
0,225 225,495 495,705 705,810 810,930
lock request. {It's,going -} to

1033
00:25:56,205 --> 00:25:57,210
0,180 180,420 420,615 615,780 780,1005
say I have an X

1034
00:25:57,210 --> 00:25:58,455
0,330 330,675 675,900 900,1065 1065,1245
lock request because I'm making

1035
00:25:58,455 --> 00:25:59,385
0,315 315,540 540,630 630,780 780,930
changes to {it.,I'm -} an

1036
00:25:59,385 --> 00:26:00,600
0,225 225,545
update query.|
|

1037
00:26:00,600 --> 00:26:01,905
0,225 225,450 450,585 585,1065 1065,1305
And then it unlocks it.
然后它就会解锁它。类似地，事务t2具有X锁定请求。事务t1的第二个请求是对a的共享锁定请求，因为它所做的只是读取它。

1038
00:26:01,905 --> 00:26:04,100
0,585 585,875 985,1275 1275,1565 1795,2195
{Similarly,,transaction -} t two has

1039
00:26:04,300 --> 00:26:06,180
0,275 275,485 485,800 800,1180 1590,1880
an X lock {request.,The -}

1040
00:26:06,180 --> 00:26:07,965
0,290 370,735 735,1035 1035,1370 1480,1785
second request from transaction t

1041
00:26:07,965 --> 00:26:09,525
0,305 535,840 840,1005 1005,1230 1230,1560
one is a shared lock

1042
00:26:09,525 --> 00:26:10,590
0,255 255,420 420,645 645,885 885,1065
request for a, because all

1043
00:26:10,590 --> 00:26:11,430
0,150 150,285 285,450 450,630 630,840
it is doing is reading

1044
00:26:11,430 --> 00:26:12,120
0,320
it.|
|

1045
00:26:12,250 --> 00:26:13,710
0,290 290,560 560,830 830,1325 1325,1460
So now our protocols are
所以现在我们的协议略有不同。我们不仅要说锁定解锁，还要说是哪种类型。然后读，我们共享锁与共享锁兼容，锁管理器将发出所有授权和阻塞请求。好的，非常直截了当。到目前为止还没有魔法。

1046
00:26:13,710 --> 00:26:14,880
0,255 255,600 600,855 855,1005 1005,1170
slightly different. {We,are -} not

1047
00:26:14,880 --> 00:26:15,630
0,165 165,330 330,465 465,585 585,750
just going to say lock

1048
00:26:15,630 --> 00:26:16,980
0,530 580,855 855,1005 1005,1140 1140,1350
unlock, but we're also going

1049
00:26:16,980 --> 00:26:18,345
0,135 135,270 270,465 465,770 1090,1365
to say which {type.,And -}

1050
00:26:18,345 --> 00:26:19,590
0,165 165,390 390,635 655,990 990,1245
then reads are we shared

1051
00:26:19,590 --> 00:26:20,790
0,285 285,390 390,885 885,1020 1020,1200
locks are compatible with shared

1052
00:26:20,790 --> 00:26:21,885
0,390 390,585 585,705 705,855 855,1095
locks and the lock manager

1053
00:26:21,885 --> 00:26:22,995
0,195 195,360 360,660 660,945 945,1110
is going to make all

1054
00:26:22,995 --> 00:26:24,560
0,210 210,480 480,735 735,1170 1170,1565
that grant and {blocking,requests. -}

1055
00:26:24,940 --> 00:26:26,940
0,400 420,695 695,905 905,1600 1710,2000
Okay, {so,pretty -} straightforward. No

1056
00:26:26,940 --> 00:26:28,560
0,290 550,855 855,1160
magic so far.|
|

1057
00:26:30,310 --> 00:26:31,680
0,365 365,700
Yup, question.|
是的，我有个问题。|

1058
00:26:34,070 --> 00:26:34,990
0,275 275,440 440,605 605,770 770,920
We will do that in
我们将在一秒钟内做到这一点。我们会的，所以--现在，这是不正确的。所以如果你是这么想的，嘿，笨蛋让它起作用了。这正是我们要说的。这并不意味着你只要遵循我告诉你的那个协议，这还不是一个协议，对吗？只是一个想法，说上锁的东西。

1059
00:26:34,990 --> 00:26:36,790
0,120 120,380 640,930 930,1220 1510,1800
a second. {We,will. {-},So -}

1060
00:26:36,790 --> 00:26:38,065
0,195 195,500 670,945 945,1080 1080,1275
right now, this is {not,correct.

1061
00:26:38,065 --> 00:26:39,520
0,335 775,1020 1020,1140 1140,1350 1350,1455
-} So if that's what

1062
00:26:39,520 --> 00:26:40,405
0,150 150,300 300,495 495,630 630,885
you're thinking is like, hey,

1063
00:26:40,405 --> 00:26:42,085
0,585 585,705 705,840 840,1115 1255,1680
didlocks {make,it -} work. That's

1064
00:26:42,085 --> 00:26:42,990
0,240 240,450 450,555 555,645 645,905
exactly {what,we -} are saying.

1065
00:26:43,160 --> 00:26:44,635
0,305 305,635 635,910 1050,1325 1325,1475
This doesn't mean if you

1066
00:26:44,635 --> 00:26:45,760
0,165 165,375 375,570 570,975 975,1125
just follow that protocol I

1067
00:26:45,760 --> 00:26:46,420
0,150 150,300 300,405 405,525 525,660
told you, which is not

1068
00:26:46,420 --> 00:26:47,545
0,135 135,270 270,705 705,930 930,1125
yet a protocol, right? Just

1069
00:26:47,545 --> 00:26:48,900
0,120 120,365 445,765 765,1020 1020,1355
an idea saying lock stuff.|
|

1070
00:26:49,640 --> 00:26:51,200
0,260 260,395 395,620 620,970
It is not correct.|
这是不正确的。|

1071
00:26:51,200 --> 00:26:52,205
0,315 315,540 540,675 675,810 810,1005
And we will make it
我们将在一秒钟内纠正它。这里就是我们有这个锁定请求的场景。但是看到这个解锁对象a发生在t1中。

1072
00:26:52,205 --> 00:26:53,230
0,210 210,345 345,450 450,660 660,1025
correct in a second. {So,over

1073
00:26:53,340 --> 00:26:55,655
0,350 350,700 1140,1540 1680,2060 2060,2315
-} here is exactly the

1074
00:26:55,655 --> 00:26:58,115
0,275 445,845 1225,1515 1515,1805 2125,2460
scenario where we have this

1075
00:26:58,115 --> 00:26:59,900
0,335 415,810 810,1205 1285,1590 1590,1785
lock {request.,But -} see this

1076
00:26:59,900 --> 00:27:01,480
0,450 450,660 660,950 970,1275 1275,1580
unlock for object a happened

1077
00:27:01,500 --> 00:27:02,780
0,290 290,485 485,790
in t one.|
|

1078
00:27:03,010 --> 00:27:04,520
0,305 305,560 560,875 875,1175 1175,1510
And then that got read
然后它被读了，被写了下来。

1079
00:27:04,660 --> 00:27:07,140
0,305 305,515 515,820 1140,1540
that got written by.|
|

1080
00:27:07,140 --> 00:27:09,120
0,350 670,1005 1005,1340
The t two.|
两个人。|

1081
00:27:09,120 --> 00:27:10,815
0,225 225,530 760,1065 1065,1305 1305,1695
And then t one reads
然后t1重读t2所写的内容。所以很明显，现在如果你画依赖图，我们已经形成了循环，对吗？有一个写写请求。

1082
00:27:10,815 --> 00:27:12,840
0,275 865,1265 1285,1605 1605,1815 1815,2025
back what t two wrote.

1083
00:27:12,840 --> 00:27:13,845
0,195 195,470 520,780 780,885 885,1005
{So,obviously -} now if you

1084
00:27:13,845 --> 00:27:15,510
0,135 135,300 300,660 660,965 1375,1665
draw the dependence graph, we

1085
00:27:15,510 --> 00:27:16,785
0,180 180,375 375,540 540,800 970,1275
have formed the cycle, right?

1086
00:27:16,785 --> 00:27:17,930
0,240 240,345 345,510 510,780 780,1145
There's a write write request.|
|

1087
00:27:18,760 --> 00:27:19,650
0,305 305,470 470,650 650,740 740,890
And then there's a write
然后是写读请求。

1088
00:27:19,650 --> 00:27:21,040
0,285 285,680
read request.|
|

1089
00:27:21,120 --> 00:27:23,500
0,400 840,1240 1590,1895 1895,2090 2090,2380
And we have a schedule
而我们的日程安排却并非如此。

1090
00:27:23,550 --> 00:27:25,000
0,290 290,470 470,760
that is not.|
|

1091
00:27:25,070 --> 00:27:26,755
0,935 935,1175 1175,1385 1385,1535 1535,1685
Serializable right. {That,is -} not
可系列化的权利。这不是可序列化的冲突。所以这是一个糟糕的日程安排。我们不想让这种情况发生。这会使数据库处于不正确的状态。

1092
00:27:26,755 --> 00:27:28,555
0,270 270,1205 1375,1635 1635,1725 1725,1800
conflict {serializable.,So -} this is

1093
00:27:28,555 --> 00:27:29,485
0,90 90,255 255,540 540,750 750,930
a {bad,schedule. -} We don't

1094
00:27:29,485 --> 00:27:30,295
0,120 120,285 285,465 465,645 645,810
want {to,allow -} this. This

1095
00:27:30,295 --> 00:27:32,125
0,275 385,735 735,960 960,1235 1555,1830
is leaves the database in

1096
00:27:32,125 --> 00:27:33,640
0,150 150,630 630,935
an incorrect state.|
|

1097
00:27:33,710 --> 00:27:34,990
0,305 305,610 690,950 950,1115 1115,1280
Okay, so we want to
好的，所以我们想阻止这一切。

1098
00:27:34,990 --> 00:27:36,020
0,165 165,470
stop that.|
|

1099
00:27:36,220 --> 00:27:37,605
0,290 290,580 600,1055 1055,1175 1175,1385
So now locks are not
所以现在光有锁是不够的。

1100
00:27:37,605 --> 00:27:38,640
0,335
enough.|
|

1101
00:27:38,640 --> 00:27:40,240
0,165 165,270 270,360 360,620
But they are necessary.|
但它们是必要的。|

1102
00:27:40,450 --> 00:27:41,490
0,260 260,395 395,560 560,800 800,1040
We need a little bit
我们需要更多一点。

1103
00:27:41,490 --> 00:27:42,440
0,290
more.|
|

1104
00:27:42,440 --> 00:27:43,355
0,210 210,360 360,525 525,720 720,915
And we need this thing
我们需要这种叫做两相锁定的东西。当两相锁定的整个理论出现时，这是一个突破。这是吉姆·格雷和一群IBM人发明的。吉姆·格雷获得了图灵奖。其中很大一部分是基于这篇论文，在这篇论文中，他谈到了两相锁定和严格两相锁定的整个理论，我们稍后会讨论这一点，以及锁的层次结构和所有其他有趣的东西。

1105
00:27:43,355 --> 00:27:45,440
0,305 325,645 645,915 915,1505 1795,2085
called two phase locking. {And,this

1106
00:27:45,440 --> 00:27:47,480
0,180 180,470 670,975 975,1640 1750,2040
-} was a breakthrough when

1107
00:27:47,480 --> 00:27:48,380
0,135 135,285 285,525 525,735 735,900
the whole theory of two

1108
00:27:48,380 --> 00:27:50,180
0,225 225,770 880,1215 1215,1500 1500,1800
phase locking came {about.,Jim -}

1109
00:27:50,180 --> 00:27:51,140
0,285 285,540 540,690 690,810 810,960
gray and a bunch of

1110
00:27:51,140 --> 00:27:53,230
0,420 420,710 730,1110 1110,1490 1690,2090
IBM folks {invented,that. -} And,

1111
00:27:53,640 --> 00:27:54,725
0,290 290,440 440,620 620,815 815,1085
you know, Jim gray got

1112
00:27:54,725 --> 00:27:55,940
0,285 285,630 630,840 840,1020 1020,1215
{a,Turing -} award. A large

1113
00:27:55,940 --> 00:27:56,920
0,210 210,360 360,510 510,690 690,980
part of that was based

1114
00:27:57,030 --> 00:27:58,625
0,290 290,470 470,665 665,970 1320,1595
on this one paper in

1115
00:27:58,625 --> 00:27:59,375
0,150 150,285 285,465 465,645 645,750
which he talks about the

1116
00:27:59,375 --> 00:28:00,365
0,165 165,420 420,630 630,780 780,990
whole theory of two phase

1117
00:28:00,365 --> 00:28:01,790
0,435 435,725 745,1050 1050,1260 1260,1425
locking and the strict two

1118
00:28:01,790 --> 00:28:02,705
0,165 165,450 450,570 570,765 765,915
phase locking, which we'll talk

1119
00:28:02,705 --> 00:28:03,560
0,165 165,300 300,420 420,570 570,855
about in a little bit,

1120
00:28:03,560 --> 00:28:04,925
0,285 285,510 510,1065 1065,1215 1215,1365
and lock hierarchies and all

1121
00:28:04,925 --> 00:28:06,010
0,135 135,255 255,450 450,735 735,1085
of that other fun stuff.|
|

1122
00:28:06,400 --> 00:28:08,210
0,290 290,455 455,650 650,1150 1410,1810
So two, phase locking is
因此，第二，阶段锁定是我们需要开始遵循的协议，以使锁定真正工作，从而为我们提供我们想要的可序列化的调度语义。

1123
00:28:08,260 --> 00:28:10,620
0,400 630,1330 1620,1970 1970,2195 2195,2360
a protocol that we need

1124
00:28:10,620 --> 00:28:12,290
0,165 165,360 360,680 1060,1365 1365,1670
to start following to make

1125
00:28:12,670 --> 00:28:14,805
0,605 605,940 1080,1480 1710,1970 1970,2135
locks actually work to give

1126
00:28:14,805 --> 00:28:17,985
0,225 225,545 805,1740 1740,2045 2545,3180
us the serializable schedule semantics

1127
00:28:17,985 --> 00:28:19,040
0,150 150,300 300,575
that we want.|
|

1128
00:28:20,350 --> 00:28:22,040
0,400 870,1205 1205,1310 1310,1430 1430,1690
So we'll do the following.
因此，我们将执行以下操作。我们会买到锁。到目前为止，这方面没有任何问题。在对对象进行更改之前，我们必须获取锁。

1129
00:28:22,630 --> 00:28:24,270
0,275 275,485 485,830 830,1385 1385,1640
{We,will -} acquire {locks.,There -}

1130
00:28:24,270 --> 00:28:25,245
0,135 135,285 285,510 510,735 735,975
was no problem with that

1131
00:28:25,245 --> 00:28:27,150
0,270 270,575 955,1290 1290,1590 1590,1905
{so,far. -} We must acquire

1132
00:28:27,150 --> 00:28:28,155
0,315 315,495 495,630 630,765 765,1005
locks before we make changes

1133
00:28:28,155 --> 00:28:29,520
0,225 225,330 330,575
to the objects.|
|

1134
00:28:29,520 --> 00:28:31,065
0,240 240,390 390,645 645,1040 1270,1545
But the problem was when
但问题是，当我们获得日志时，我们过早地放弃了它，其他人可能会开始看到错误的数据。问题不是我们把这些锁放错了地方。问题是这种解锁发生得太快了，我们可能会开始看到这一点，啊，事务t 2可能会开始拾取尚未提交的事务的更改。

1135
00:28:31,065 --> 00:28:32,205
0,195 195,450 450,660 660,960 960,1140
we acquired the logs, we

1136
00:28:32,205 --> 00:28:33,195
0,225 225,435 435,615 615,795 795,990
let go of it too

1137
00:28:33,195 --> 00:28:35,700
0,305 775,1175 1345,1745 1885,2205 2205,2505
soon and others could start

1138
00:28:35,700 --> 00:28:38,160
0,380 610,1290 1290,1580 1930,2205 2205,2460
seeing incorrect data. {The,problem -}

1139
00:28:38,160 --> 00:28:40,010
0,330 330,645 645,1010 1270,1560 1560,1850
was not that we have

1140
00:28:40,120 --> 00:28:41,175
0,335 335,665 665,770 770,890 890,1055
these locks in the wrong

1141
00:28:41,175 --> 00:28:42,015
0,180 180,315 315,495 495,690 690,840
{place.,The -} problem is this

1142
00:28:42,015 --> 00:28:43,620
0,390 390,555 555,845 985,1350 1350,1605
unlock of a happened too

1143
00:28:43,620 --> 00:28:45,105
0,290 520,885 885,1110 1110,1275 1275,1485
soon and we could start

1144
00:28:45,105 --> 00:28:46,650
0,165 165,300 300,575 595,995 1255,1545
to see this, ah, the

1145
00:28:46,650 --> 00:28:48,105
0,290 400,690 690,960 960,1245 1245,1455
transaction t two could start

1146
00:28:48,105 --> 00:28:49,410
0,180 180,330 330,605 895,1170 1170,1305
pick up changes of the

1147
00:28:49,410 --> 00:28:50,460
0,260 310,555 555,675 675,825 825,1050
transaction that has not yet

1148
00:28:50,460 --> 00:28:51,200
0,350
committed.|
|

1149
00:28:51,330 --> 00:28:52,400
0,275 275,515 515,650 650,830 830,1070
So that's what two phase
这就是两阶段锁定将要解决的问题，也就是说，我们将一个事务的所有请求分成两个阶段。

1150
00:28:52,400 --> 00:28:53,650
0,390 390,525 525,720 720,945 945,1250
locking is going to solve

1151
00:28:54,030 --> 00:28:55,340
0,290 290,470 470,800 800,1040 1040,1310
and saying we break up

1152
00:28:55,340 --> 00:28:56,860
0,350 520,900 900,1125 1125,1260 1260,1520
all requests from a transaction

1153
00:28:57,060 --> 00:28:58,600
0,305 305,485 485,970
in two phases.|
|

1154
00:28:58,600 --> 00:28:59,670
0,225 225,330 330,465 465,705 705,1070
One is a growing phase
一个是不断增长的阶段，在这个阶段中，他们可以继续向锁管理器发出请求，因为锁管理器将跟踪事务。没有一个人提出了请求，提出了更多请求。诸如此类的事情。事务开始发出第一个解锁请求的分钟数。我要在我的锁管理器里扔一面旗子，说一个人已经离开了。增长阶段现在正处于收缩阶段。

1155
00:28:59,960 --> 00:29:00,820
0,290 290,455 455,590 590,710 710,860
in which they can keep

1156
00:29:00,820 --> 00:29:01,900
0,290 310,660 660,825 825,915 915,1080
making requests to the lock

1157
00:29:01,900 --> 00:29:02,965
0,320 370,645 645,795 795,915 915,1065
manager is as a lock

1158
00:29:02,965 --> 00:29:03,850
0,255 255,450 450,585 585,720 720,885
manager is going to keep

1159
00:29:03,850 --> 00:29:05,530
0,320 460,860 910,1200 1200,1440 1440,1680
track transaction. {T,one -} has

1160
00:29:05,530 --> 00:29:06,670
0,165 165,360 360,615 615,870 870,1140
made a request making more

1161
00:29:06,670 --> 00:29:08,680
0,285 285,525 525,720 720,1010 1690,2010
{request.,Stuff -} {like,that. -} The

1162
00:29:08,680 --> 00:29:10,690
0,320 400,800 1120,1485 1485,1785 1785,2010
minute transaction starts to make

1163
00:29:10,690 --> 00:29:12,730
0,210 210,530 580,1245 1245,1640 1690,2040
and {first,unlock -} request. I'm

1164
00:29:12,730 --> 00:29:13,530
0,105 105,240 240,360 360,510 510,800
going to throw a flag

1165
00:29:13,820 --> 00:29:15,040
0,305 305,485 485,665 665,950 950,1220
in my lock manager and

1166
00:29:15,040 --> 00:29:16,525
0,165 165,330 330,620 850,1200 1200,1485
say {t,one -} has left.

1167
00:29:16,525 --> 00:29:17,620
0,210 210,435 435,705 705,930 930,1095
The growing phase is now

1168
00:29:17,620 --> 00:29:18,960
0,135 135,270 270,585 585,860
in the shrinking phase.|
|

1169
00:29:19,860 --> 00:29:21,430
0,380 380,590 590,860 860,1085 1085,1570
It's starting to release locks
它开始释放锁2阶段协议说，一旦你进入收缩阶段，你不允许要求任何更多的锁。

1170
00:29:22,010 --> 00:29:24,110
0,210 210,420 420,915 915,1220 1750,2100
2 phase protocol says once

1171
00:29:24,110 --> 00:29:25,205
0,240 240,450 450,615 615,735 735,1095
you go into the shrinking

1172
00:29:25,205 --> 00:29:26,675
0,305 535,810 810,990 990,1230 1230,1470
phase, you are not allowed

1173
00:29:26,675 --> 00:29:27,530
0,150 150,330 330,525 525,690 690,855
to ask for any more

1174
00:29:27,530 --> 00:29:28,480
0,440
locks.|
|

1175
00:29:28,760 --> 00:29:29,635
0,260 260,380 380,560 560,725 725,875
If you ask for any
如果你再要锁的话。

1176
00:29:29,635 --> 00:29:30,920
0,180 180,665
more locks.|
|

1177
00:29:30,920 --> 00:29:32,060
0,240 240,390 390,615 615,885 885,1140
The lock manager will reject
锁管理器将拒绝它。您必须中止交易并重新开始。

1178
00:29:32,060 --> 00:29:33,275
0,320 370,615 615,720 720,885 885,1215
it. {You,have -} to abort

1179
00:29:33,275 --> 00:29:34,565
0,195 195,485 595,915 915,1125 1125,1290
the transaction and start all

1180
00:29:34,565 --> 00:29:35,480
0,275
over.|
|

1181
00:29:36,480 --> 00:29:38,000
0,400 750,1025 1025,1175 1175,1325 1325,1520
So why does it work?
那么，它为什么会奏效呢？首先，让我们来看看。那是什么意思？

1182
00:29:38,000 --> 00:29:39,215
0,240 240,525 525,765 765,1050 1050,1215
First, let's see. {What,does -}

1183
00:29:39,215 --> 00:29:40,380
0,180 180,485
that mean?|
|

1184
00:29:40,510 --> 00:29:42,880
0,275 275,550 1080,1385 1385,1690
If I look at.|
如果我看着。|

1185
00:29:42,920 --> 00:29:43,885
0,275 275,455 455,635 635,755 755,965
The life of a single
单个事务的生命周期，如此处所示。

1186
00:29:43,885 --> 00:29:45,070
0,365 505,765 765,900 900,1050 1050,1185
transaction, which is what is

1187
00:29:45,070 --> 00:29:46,320
0,180 180,500
shown here.|
|

1188
00:29:46,330 --> 00:29:47,085
0,260 260,365 365,440 440,530 530,755
And this is a single
这是一个时间在X轴上的单一事务。

1189
00:29:47,085 --> 00:29:48,855
0,365 955,1245 1245,1455 1455,1650 1650,1770
transaction with time on the

1190
00:29:48,855 --> 00:29:50,220
0,135 135,695
X axis.|
|

1191
00:29:50,770 --> 00:29:51,855
0,395 395,650 650,785 785,920 920,1085
Y access is the number
Y Access是锁数。如你所见。它增加锁的第一个阶段是获取锁，获取锁。您知道，可能读请求来自SELECT查询，它到达某个点，然后它停留在所有这些锁中，然后开始丢弃。所以它在这里的这个空间里收缩，一旦收缩，它就不能再回来并开始获得新的锁。

1192
00:29:51,855 --> 00:29:52,650
0,180 180,450 450,555 555,675 675,795
of locks. {As,you -} can

1193
00:29:52,650 --> 00:29:53,805
0,135 135,270 270,510 510,885 885,1155
{see.,The -} first phase where

1194
00:29:53,805 --> 00:29:55,245
0,120 120,330 330,690 690,960 960,1440
it is growing the locks,

1195
00:29:55,245 --> 00:29:56,910
0,420 420,705 705,1080 1080,1365 1365,1665
it's acquiring locks, {acquiring,locks. -}

1196
00:29:56,910 --> 00:29:57,840
0,120 120,270 270,480 480,675 675,930
You know, maybe that read

1197
00:29:57,840 --> 00:29:58,770
0,285 285,465 465,600 600,735 735,930
request has come in the

1198
00:29:58,770 --> 00:30:00,960
0,195 195,500 850,1250 1510,1830 1830,2190
select query and it reaches

1199
00:30:00,960 --> 00:30:02,220
0,120 120,360 360,720 720,990 990,1260
a certain point and then

1200
00:30:02,220 --> 00:30:03,270
0,300 300,555 555,750 750,885 885,1050
it stays with all those

1201
00:30:03,270 --> 00:30:04,580
0,270 270,390 390,600 600,915 915,1310
locks and {then,starts -} dropping.

1202
00:30:04,780 --> 00:30:06,270
0,260 260,365 365,545 545,1120 1170,1490
So it is shrinking in

1203
00:30:06,270 --> 00:30:07,215
0,210 210,435 435,675 675,825 825,945
this space over here and

1204
00:30:07,215 --> 00:30:08,570
0,165 165,360 360,795 795,1065 1065,1355
once it shrinks it cannot

1205
00:30:09,040 --> 00:30:10,260
0,320 320,575 575,800 800,995 995,1220
go back up and start

1206
00:30:10,260 --> 00:30:11,840
0,225 225,525 525,735 735,1190
to acquire new locks.|
|

1207
00:30:12,090 --> 00:30:13,020
0,400
Okay.|
好吧。|

1208
00:30:13,020 --> 00:30:15,260
0,290 700,1100 1420,1710 1710,1920 1920,2240
So for in this case.|
在这种情况下也是如此。|

1209
00:30:16,510 --> 00:30:18,620
0,350 350,700 930,1330
This point. Which?|
这一点。哪一个?|

1210
00:30:18,620 --> 00:30:19,925
0,350 460,735 735,945 945,1155 1155,1305
Is the point at which
它获取所有需要的锁的点称为锁点。

1211
00:30:19,925 --> 00:30:21,170
0,150 150,420 420,915 915,1080 1080,1245
it had grabbed all the

1212
00:30:21,170 --> 00:30:22,265
0,240 240,390 390,630 630,885 885,1095
locks it needed is called

1213
00:30:22,265 --> 00:30:23,560
0,165 165,360 360,695
the lock point.|
|

1214
00:30:23,560 --> 00:30:25,050
0,255 255,435 435,600 600,1215 1215,1490
And it's this magical point,
这就是这个神奇的点，我将回到这个点上来，从幕后产生的依赖图的角度来看，它意味着什么。

1215
00:30:25,190 --> 00:30:26,340
0,275 275,470 470,590 590,815 815,1150
which I'll come back to

1216
00:30:26,360 --> 00:30:27,480
0,305 305,530 530,725 725,860 860,1120
in terms of what it,

1217
00:30:27,590 --> 00:30:29,110
0,350 350,560 560,695 695,970 1230,1520
what, what it means in

1218
00:30:29,110 --> 00:30:30,220
0,165 165,315 315,495 495,870 870,1110
terms of the dependence graph

1219
00:30:30,220 --> 00:30:32,155
0,180 180,315 315,590 760,1370 1630,1935
that is getting induced behind

1220
00:30:32,155 --> 00:30:33,200
0,165 165,425
the scenes.|
|

1221
00:30:33,350 --> 00:30:34,315
0,335 335,530 530,665 665,815 815,965
So everyone with me so
到目前为止，大家都知道两相锁定的协议是什么。

1222
00:30:34,315 --> 00:30:35,050
0,165 165,330 330,465 465,600 600,735
far as to what the

1223
00:30:35,050 --> 00:30:36,190
0,390 390,600 600,795 795,945 945,1140
protocol is for two phase

1224
00:30:36,190 --> 00:30:37,240
0,500
locking.|
|

1225
00:30:37,500 --> 00:30:39,215
0,320 320,635 635,905 905,1180 1380,1715
Right. {So,we -} can go
正确的。所以我们可以往上走然后开始往下走。所以它必须看起来像一座没有山谷的山。它不能拥有这个山谷。

1226
00:30:39,215 --> 00:30:40,400
0,335 355,645 645,825 825,1020 1020,1185
up and then start to

1227
00:30:40,400 --> 00:30:41,345
0,150 150,435 435,660 660,825 825,945
come {down.,So -} it's got

1228
00:30:41,345 --> 00:30:42,490
0,135 135,270 270,420 420,695 745,1145
to look like a mountain

1229
00:30:42,510 --> 00:30:43,910
0,290 290,455 455,905 905,1160 1160,1400
with {no,valleys. -} It cannot

1230
00:30:43,910 --> 00:30:45,380
0,270 270,495 495,800
have this valley.|
|

1231
00:30:46,260 --> 00:30:47,735
0,400 450,740 740,1010 1010,1280 1280,1475
Right, it cannot be. {I,start
对，不可能。我开始到达那个锁点。我开始放下锁，然后又开始往上爬。我不能这么做。

1232
00:30:47,735 --> 00:30:49,300
0,305 415,780 780,1035 1035,1245 1245,1565
-} reaching that lock {point.,I

1233
00:30:49,440 --> 00:30:50,600
0,290 290,500 500,770 770,1055 1055,1160
-} start dropping locks and

1234
00:30:50,600 --> 00:30:51,320
0,135 135,300 300,435 435,540 540,720
I start to go {up,again.

1235
00:30:51,320 --> 00:30:53,040
0,320 340,690 690,915 915,1190
-} Cannot do that.|
|

1236
00:30:53,040 --> 00:30:53,835
0,105 105,225 225,390 390,570 570,795
That will cause us trouble,
那会给我们带来麻烦，引起麻烦。

1237
00:30:53,835 --> 00:30:55,520
0,335 385,735 735,1085
cause cause trouble.|
|

1238
00:30:55,520 --> 00:30:56,800
0,180 180,315 315,750 750,1005 1005,1280
And the intuition is the
直觉是这样的。这是两个阶段二，PL违规，两相锁定违规。我希望你们能自己解决的直觉是，为什么两相锁定是有效的？这是因为如果我有两笔交易。

1239
00:30:56,850 --> 00:30:57,920
0,305 305,455 455,700 720,965 965,1070
is the following. {This,is -}

1240
00:30:57,920 --> 00:30:59,840
0,120 120,285 285,590 1360,1665 1665,1920
a two phase two, pl

1241
00:30:59,840 --> 00:31:01,700
0,590 670,945 945,1125 1125,1455 1455,1860
violation, two phase locking {violation.,The

1242
00:31:01,700 --> 00:31:03,350
0,165 165,620 1090,1365 1365,1500 1500,1650
-} intuition, which I hope

1243
00:31:03,350 --> 00:31:04,235
0,150 150,285 285,450 450,645 645,885
you can work out by

1244
00:31:04,235 --> 00:31:05,840
0,335 565,930 930,1215 1215,1425 1425,1605
yourself is why does two

1245
00:31:05,840 --> 00:31:07,700
0,225 225,630 630,920 1150,1620 1620,1860
phase locking work? It's because

1246
00:31:07,700 --> 00:31:08,830
0,180 180,405 405,570 570,810 810,1130
if I've got two transactions.|
|

1247
00:31:10,000 --> 00:31:11,275
0,270 270,390 390,585 585,890 970,1275
I'll go back to this
我会回到这张幻灯片上。如果我有两个这样的事务是一个事务，另一个事务会有它自己的曲线，对吗？

1248
00:31:11,275 --> 00:31:12,430
0,305 385,660 660,855 855,975 975,1155
slide. {If,I've,got - -} two

1249
00:31:12,430 --> 00:31:13,720
0,290 520,825 825,990 990,1125 1125,1290
transaction like this is one

1250
00:31:13,720 --> 00:31:15,610
0,290 820,1155 1155,1490 1510,1770 1770,1890
transaction, another transaction will have

1251
00:31:15,610 --> 00:31:17,120
0,135 135,315 315,570 570,920
its own curve, right?|
|

1252
00:31:17,530 --> 00:31:19,035
0,290 290,580 750,1025 1025,1355 1355,1505
The transaction that reaches the
最先到达锁定点的事务就是将要到达的事务。

1253
00:31:19,035 --> 00:31:21,045
0,240 240,555 555,905 1555,1845 1845,2010
lock point first is the

1254
00:31:21,045 --> 00:31:22,700
0,210 210,435 435,615 615,905
one that will be.|
|

1255
00:31:22,830 --> 00:31:24,770
0,400 600,1000 1020,1420 1530,1790 1790,1940
The first transaction in that
最终序列计划中的第一个事务。

1256
00:31:24,770 --> 00:31:27,040
0,290 670,1230 1230,1520
final serial schedule.|
|

1257
00:31:27,040 --> 00:31:28,105
0,375 375,630 630,750 750,915 915,1065
So anyone who gets to
因此，任何人谁达到了他们需要的所有锁，他们想要与之冲突，所以就像，谁最先到达山顶？我在你面前，这将决定数据库。

1258
00:31:28,105 --> 00:31:28,915
0,135 135,285 285,510 510,630 630,810
all the locks they need,

1259
00:31:28,915 --> 00:31:29,700
0,165 165,270 270,405 405,540 540,785
that they want to conflict

1260
00:31:29,720 --> 00:31:30,700
0,365 365,575 575,725 725,830 830,980
with, so it's like, who

1261
00:31:30,700 --> 00:31:31,525
0,195 195,390 390,570 570,720 720,825
reached the top of the

1262
00:31:31,525 --> 00:31:33,330
0,195 195,545 625,1245 1245,1500 1500,1805
mountain first? I'm before you

1263
00:31:33,410 --> 00:31:35,185
0,395 395,530 530,740 740,1060 1410,1775
that's going to determine the

1264
00:31:35,185 --> 00:31:36,480
0,365
database.|
|

1265
00:31:36,850 --> 00:31:38,190
0,400 480,785 785,995 995,1175 1175,1340
Update in terms of that
根据该可序列化时间表进行更新。

1266
00:31:38,190 --> 00:31:39,840
0,660 660,950
serializable schedule.|
|

1267
00:31:40,060 --> 00:31:41,270
0,275 275,425 425,695 695,800 800,1210
Okay, so that's the intuition,
好的，这就是直觉，这就是它起作用的原因。

1268
00:31:41,440 --> 00:31:42,500
0,290 290,560 560,665 665,785 785,1060
and that's why it works.|
|

1269
00:31:43,530 --> 00:31:44,460
0,400
Okay.|
好吧。|

1270
00:31:45,530 --> 00:31:46,680
0,400
Question.|
问题来了。|

1271
00:31:51,940 --> 00:31:53,020
0,400
Yeah.|
嗯。|

1272
00:31:57,340 --> 00:31:58,580
0,350 370,770
However you.|
不管你是谁。|

1273
00:31:58,600 --> 00:31:59,680
0,150 150,390 390,615 615,840 840,1080
Making sure that all these
确保所有这些助教都是当地人。

1274
00:31:59,680 --> 00:32:00,930
0,360 360,525 525,750 750,975 975,1250
ta will be the local.|
|

1275
00:32:01,490 --> 00:32:03,130
0,395 395,785 785,1145 1145,1460 1460,1640
Yeah, so the, that's a
是的，所以，这是个很好的问题。所以问题是，我们怎么才能让它先到达锁定点呢？我们不会，啊，这就是将要发生的事情。可以开始做功了，因为我们一看协议就知道了。

1276
00:32:03,130 --> 00:32:05,050
0,270 270,585 585,980 1300,1620 1620,1920
great question. {So,the -} question

1277
00:32:05,050 --> 00:32:06,070
0,360 360,615 615,765 765,885 885,1020
is how are we going

1278
00:32:06,070 --> 00:32:07,570
0,210 210,530 700,1035 1035,1290 1290,1500
to allow t one from

1279
00:32:07,570 --> 00:32:08,880
0,255 255,525 525,750 750,990 990,1310
reaching the lock point first?

1280
00:32:09,110 --> 00:32:10,260
0,275 275,425 425,605 605,830 830,1150
We are not going to,

1281
00:32:10,460 --> 00:32:11,890
0,400 690,1055 1055,1220 1220,1325 1325,1430
ah, here's what's going to

1282
00:32:11,890 --> 00:32:12,610
0,150 150,330 330,450 450,585 585,720
happen. T 1 t two

1283
00:32:12,610 --> 00:32:13,645
0,120 120,375 375,690 690,900 900,1035
can start doing the work

1284
00:32:13,645 --> 00:32:14,800
0,245 505,780 780,915 915,1035 1035,1155
as we look at the

1285
00:32:14,800 --> 00:32:15,655
0,120 120,450 450,585 585,705 705,855
protocol in a little bit

1286
00:32:15,655 --> 00:32:18,420
0,305 745,1125 1125,1500 1500,1895 2365,2765
as soon as t one.

1287
00:32:18,440 --> 00:32:19,440
0,400
|
|

1288
00:32:19,450 --> 00:32:20,445
0,350 350,560 560,680 680,830 830,995
Either one of those t
不管是t1还是t2，他们中的任何一个都先到达一个锁点，如果t2首先到达它的话，顺序就是这样，想象一下t1，t，2在两个线程中运行。

1289
00:32:20,445 --> 00:32:21,405
0,135 135,255 255,405 405,660 660,960
one or t two, either

1290
00:32:21,405 --> 00:32:22,245
0,180 180,285 285,420 420,720 720,840
one of them reaches a

1291
00:32:22,245 --> 00:32:23,655
0,150 150,360 360,665 955,1245 1245,1410
lock point first, that will

1292
00:32:23,655 --> 00:32:24,555
0,135 135,240 240,450 450,705 705,900
be the order if t

1293
00:32:24,555 --> 00:32:26,145
0,180 180,510 510,660 660,935 1255,1590
two reaches it first see

1294
00:32:26,145 --> 00:32:27,090
0,270 270,465 570,690 690,825 825,945
imagine t 1 t two

1295
00:32:27,090 --> 00:32:28,100
0,105 105,240 240,405 405,570 570,1010
are running in two threads.|
|

1296
00:32:28,620 --> 00:32:29,895
0,225 225,390 390,540 540,825 825,1275
And they keep context switching
他们不断地切换上下文或诸如此类的东西，对吗？如果t2首先到达锁定点，就像数据库的最终状态是t2，然后是t1。

1297
00:32:29,895 --> 00:32:31,275
0,210 210,480 480,735 735,1025 1105,1380
or something like that, right?

1298
00:32:31,275 --> 00:32:32,205
0,150 150,285 285,435 435,600 600,930
And if t two reaches

1299
00:32:32,205 --> 00:32:33,765
0,120 120,270 270,480 480,785 1105,1560
the lock point first, it'll

1300
00:32:33,765 --> 00:32:34,800
0,105 105,330 330,570 570,810 810,1035
be like the final state

1301
00:32:34,800 --> 00:32:35,715
0,120 120,240 240,495 495,765 765,915
of the database is t

1302
00:32:35,715 --> 00:32:36,710
0,135 135,345 345,555 555,705 705,995
two followed by t one.|
|

1303
00:32:37,200 --> 00:32:38,235
0,270 270,450 450,615 615,810 810,1035
So we can allow any
所以我们现在可以允许任何任意的交错。

1304
00:32:38,235 --> 00:32:40,460
0,630 630,1215 1215,1505
arbitrary interleaving now.|
|

1305
00:32:40,460 --> 00:32:42,065
0,150 150,315 315,525 525,860 1330,1605
And as long as we
只要我们遵循两阶段协议，这并不重要。无论谁最先达到这一点，都将在这一系列赛程中领先。

1306
00:32:42,065 --> 00:32:43,420
0,225 225,420 420,555 555,765 765,1355
follow the two phase protocol,

1307
00:32:43,470 --> 00:32:45,095
0,470 470,730 750,1115 1115,1490 1490,1625
doesn't matter. {Whoever,reaches -} that

1308
00:32:45,095 --> 00:32:46,000
0,180 180,360 360,525 525,660 660,905
first is going to be

1309
00:32:46,320 --> 00:32:47,590
0,305 305,470 470,605 605,980 980,1270
ahead in that serial schedule.|
|

1310
00:32:49,070 --> 00:32:50,000
0,400
Okay.|
好吧。|

1311
00:32:50,010 --> 00:32:51,080
0,290 290,530 530,650 650,845 845,1070
And that's the beauty is
这就是美是对的。我们不需要对时间做任何其他的事情。让所有的线程都相互运行。让成百上千的人。

1312
00:32:51,080 --> 00:32:52,040
0,285 285,540 540,735 735,840 840,960
right. {We,don't -} have to

1313
00:32:52,040 --> 00:32:53,090
0,210 210,435 435,675 675,915 915,1050
do anything else with the

1314
00:32:53,090 --> 00:32:54,500
0,260 520,825 825,1020 1020,1275 1275,1410
{timing.,Let -} the threads all

1315
00:32:54,500 --> 00:32:55,595
0,195 195,375 375,510 510,770 790,1095
run with {each,other. -} Let

1316
00:32:55,595 --> 00:32:57,560
0,195 195,485 715,1095 1095,1475
there be hundreds of.|
|

1317
00:32:57,630 --> 00:32:59,330
0,640 720,980 980,1115 1115,1370 1370,1700
Threads they can all compete
他们都可以竞争的线索。只要他们都遵循锁定协议2阶段锁定，他们仍然可以追求相同的数据库，锁定生活将会很好。

1318
00:32:59,330 --> 00:33:01,295
0,350 1210,1470 1470,1635 1635,1830 1830,1965
for. {They,can -} still go

1319
00:33:01,295 --> 00:33:02,780
0,165 165,330 330,480 480,785 1195,1485
after the same database as

1320
00:33:02,780 --> 00:33:03,530
0,150 150,285 285,390 390,510 510,750
long as they all follow

1321
00:33:03,530 --> 00:33:04,895
0,225 225,405 405,855 1020,1185 1185,1365
the lock protocol 2 phase

1322
00:33:04,895 --> 00:33:06,170
0,515 595,885 885,1035 1035,1170 1170,1275
locking life is going to

1323
00:33:06,170 --> 00:33:07,000
0,75 75,320
be good.|
|

1324
00:33:08,430 --> 00:33:09,580
0,400
Question.|
问题来了。|

1325
00:33:09,780 --> 00:33:10,815
0,120 120,240 240,495 495,810 810,1035
Is it possible for t
有没有可能让他们拿出他们的证件？

1326
00:33:10,815 --> 00:33:11,745
0,210 210,390 390,555 555,735 735,930
one to reach out their

1327
00:33:11,745 --> 00:33:12,520
0,305
papers?|
|

1328
00:33:14,790 --> 00:33:16,025
0,400 420,770 770,890 890,1040 1040,1235
Yeah, we'll get to that.
好的，我们会讲到那个的。这会导致僵局，我们会讨论这一点。这不能防止僵局，我们有机制在一秒钟内处理这一问题。所以，先别问这个问题。如果它们以相反的顺序进行，有一种情况下，两个相位锁定仍然可能以一种情况而结束，并且没有任何进展。这就是所谓的僵局，我们会打破它的。

1329
00:33:16,025 --> 00:33:17,840
0,300 300,795 795,1020 1020,1505 1525,1815
{That,induces -} a deadlock and

1330
00:33:17,840 --> 00:33:18,725
0,225 225,390 390,585 585,720 720,885
we'll talk about {that.,It -}

1331
00:33:18,725 --> 00:33:20,690
0,285 285,480 480,690 690,1175 1675,1965
won't prevent a deadlock and

1332
00:33:20,690 --> 00:33:21,785
0,120 120,225 225,705 705,900 900,1095
we have mechanisms to deal

1333
00:33:21,785 --> 00:33:22,565
0,165 165,300 300,435 435,555 555,780
with that in {a,second. -}

1334
00:33:22,565 --> 00:33:24,350
0,360 360,675 675,885 885,1175 1495,1785
So {hold,that -} question. If

1335
00:33:24,350 --> 00:33:25,480
0,150 150,285 285,420 420,680 730,1130
they go in opposite order,

1336
00:33:26,040 --> 00:33:27,500
0,410 410,605 605,965 965,1265 1265,1460
there's a case where two

1337
00:33:27,500 --> 00:33:29,090
0,240 240,660 660,870 870,1190 1300,1590
phase locking can still end

1338
00:33:29,090 --> 00:33:30,035
0,150 150,285 285,495 495,750 750,945
up with a situation and

1339
00:33:30,035 --> 00:33:31,085
0,165 165,420 420,660 660,825 825,1050
{no,progress -} is made. That's

1340
00:33:31,085 --> 00:33:32,045
0,135 135,495 495,600 600,795 795,960
called deadlocks, and we'll break

1341
00:33:32,045 --> 00:33:32,700
0,305
it.|
|

1342
00:33:34,730 --> 00:33:36,720
0,365 365,620 620,905 905,1300
Good, good thinking question.|
好的，好的思考问题。|

1343
00:33:42,080 --> 00:33:42,955
0,290 290,440 440,560 560,710 710,875
Yeah, so the question is
是的，所以问题是，你不能获得物体按预设顺序的顺序吗？你可以，但这让它变得很困难。假设我有一个表r1事务正在对其执行文件扫描。另一个是通过索引访问它。我不知道命令会是从哪里来的。该指数可以是非聚集的。所以我不能总是，因为我们想要所有这些通道的效率，我们不能以一种非常严格的方式来诱导秩序。

1344
00:33:42,955 --> 00:33:43,980
0,255 255,405 405,630 630,780 780,1025
couldn't you acquire the order

1345
00:33:44,330 --> 00:33:45,490
0,260 260,470 470,665 665,800 800,1160
the objects in a preset

1346
00:33:45,490 --> 00:33:46,915
0,260 550,855 855,1095 1095,1290 1290,1425
order? You could, but it

1347
00:33:46,915 --> 00:33:48,250
0,135 135,255 255,515 565,960 960,1335
make it difficult. {Imagine,I've,got -

1348
00:33:48,250 --> 00:33:50,665
0,180 180,435 435,735 735,1130 2110,2415
-} a table r 1

1349
00:33:50,665 --> 00:33:51,850
0,305 385,675 675,840 840,975 975,1185
transaction is doing a file

1350
00:33:51,850 --> 00:33:53,020
0,240 240,405 405,680 790,1035 1035,1170
scan on {it.,The -} other

1351
00:33:53,020 --> 00:33:53,935
0,150 150,360 360,675 675,795 795,915
one is accessing it through

1352
00:33:53,935 --> 00:33:55,240
0,210 210,575 655,945 945,1200 1200,1305
{an,index. -} I don't know

1353
00:33:55,240 --> 00:33:55,900
0,120 120,225 225,375 375,540 540,660
what the order is going

1354
00:33:55,900 --> 00:33:56,620
0,105 105,225 225,375 375,540 540,720
{to,come -} from. The {index,could,be

1355
00:33:56,620 --> 00:33:57,940
0,165 165,285 285,980 1000,1230 1230,1320
- -} unclustered. So I

1356
00:33:57,940 --> 00:33:59,395
0,300 300,620 790,1050 1050,1215 1215,1455
can't always, because we want

1357
00:33:59,395 --> 00:34:00,670
0,210 210,465 465,735 735,1095 1095,1275
all these access paths for

1358
00:34:00,670 --> 00:34:02,410
0,320 790,1065 1065,1305 1305,1590 1590,1740
efficiency, we can't induce the

1359
00:34:02,410 --> 00:34:03,685
0,260 490,750 750,855 855,1035 1035,1275
order in a very strict

1360
00:34:03,685 --> 00:34:04,340
0,305
way.|
|

1361
00:34:04,960 --> 00:34:06,030
0,275 275,425 425,590 590,830 830,1070
And that was where in
而这就是你在闩锁中所说的程序必须做到的地方。但是，如果你曾经编写过一个带有闩锁的复杂的c+plus应用程序，你会发现很难让代码的所有部分遵循它们通过数据结构的相同顺序，并且会弹出各种疯狂的错误。

1362
00:34:06,030 --> 00:34:07,125
0,420 420,570 570,705 705,855 855,1095
latches you said the program

1363
00:34:07,125 --> 00:34:08,010
0,240 240,375 375,495 495,645 645,885
has to do that. {But,if

1364
00:34:08,010 --> 00:34:08,925
0,210 210,330 330,525 525,750 750,915
-} you ever write a

1365
00:34:08,925 --> 00:34:10,740
0,275 595,915 915,1140 1140,1445 1465,1815
complex c plus plus application

1366
00:34:10,740 --> 00:34:12,165
0,225 225,690 690,1065 1065,1200 1200,1425
with latches, you'll find it's

1367
00:34:12,165 --> 00:34:13,605
0,165 165,485 835,1095 1095,1245 1245,1440
very hard to get all

1368
00:34:13,605 --> 00:34:14,460
0,210 210,375 375,480 480,660 660,855
parts of the code to

1369
00:34:14,460 --> 00:34:15,705
0,195 195,375 375,525 525,830 970,1245
follow the same order in

1370
00:34:15,705 --> 00:34:16,500
0,150 150,285 285,435 435,585 585,795
which they go through data

1371
00:34:16,500 --> 00:34:17,805
0,315 315,680 700,990 990,1155 1155,1305
structures and all kinds of

1372
00:34:17,805 --> 00:34:19,240
0,210 210,570 570,735 735,1025
crazy bugs pop up.|
|

1373
00:34:21,250 --> 00:34:22,545
0,305 305,610 750,1025 1025,1160 1160,1295
Great question. {I,like -} how
问得好。我喜欢你们的想法。是啊。

1374
00:34:22,545 --> 00:34:23,450
0,120 120,225 225,345 345,555 555,905
you guys are thinking. Yep.|
|

1375
00:34:32,950 --> 00:34:33,930
0,275 275,485 485,710 710,860 860,980
That is correct. {So,the -}
这是正确的。所以问题是，我们可以说，只要每个人都遵循两阶段锁定，最终的时间表是冲突可序列化的，是的，和。

1376
00:34:33,930 --> 00:34:35,385
0,210 210,560 760,1065 1065,1260 1260,1455
question was, can we say

1377
00:34:35,385 --> 00:34:36,750
0,180 180,330 330,525 525,845 1105,1365
that as long as everyone

1378
00:34:36,750 --> 00:34:38,250
0,225 225,480 480,690 690,1220 1240,1500
follows two phase locking, the

1379
00:34:38,250 --> 00:34:40,080
0,240 240,570 570,810 810,1080 1080,1830
final schedule is conflict serializable

1380
00:34:40,080 --> 00:34:41,960
0,290 700,1100
yes, and.|
|

1381
00:34:41,960 --> 00:34:43,205
0,270 270,450 450,645 645,980 1000,1245
It's so, yes, that we
是的，是的，我们不能保证任何关于死锁的事情。死锁仍有可能发生。我们会想办法打破它的。

1382
00:34:43,205 --> 00:34:44,405
0,105 105,240 240,780 780,1035 1035,1200
are not guaranteeing anything about

1383
00:34:44,405 --> 00:34:45,790
0,420 420,795 795,945 945,1110 1110,1385
deadlocks. {Deadlocks,can -} still {happen.,We'll

1384
00:34:46,110 --> 00:34:46,955
0,350 350,470 470,590 590,695 695,845
-} find a way to

1385
00:34:46,955 --> 00:34:47,880
0,165 165,455
break it.|
|

1386
00:34:48,330 --> 00:34:49,740
0,305 305,610 720,1120
Very good, yep.|
很好，是的。|

1387
00:34:49,810 --> 00:34:51,540
0,365 365,730 750,1150
Exactly right. Yep.|
完全正确。是啊。|

1388
00:34:53,460 --> 00:34:54,840
0,290 290,470 470,760
Does this, sorry?|
是这样吗，抱歉？|

1389
00:34:57,480 --> 00:34:59,360
0,400 1140,1430 1430,1580 1580,1715 1715,1880
Ah, which one is not
啊，哪一个不是在缩小这个？这只是一条平坦的线，意思是所有的锁现在都被持有了一段时间。你是这个意思吗？是啊，是啊，是啊。所以我扫描了我的文件，我得到了我所有的锁。现在我只是把它们加起来，因为我有一个聚合的东西，所以它是平的。然后我开始放下锁。

1390
00:34:59,360 --> 00:35:00,605
0,390 390,690 690,945 945,1095 1095,1245
shrinking this? This is just

1391
00:35:00,605 --> 00:35:01,640
0,165 165,390 390,660 660,870 870,1035
a flat line saying all

1392
00:35:01,640 --> 00:35:02,435
0,150 150,375 375,495 495,645 645,795
the locks are now being

1393
00:35:02,435 --> 00:35:03,410
0,225 225,450 450,570 570,735 735,975
held for a little while.

1394
00:35:03,410 --> 00:35:04,175
0,180 180,315 315,450 450,555 555,765
{Is,that -} what you mean?

1395
00:35:04,175 --> 00:35:05,680
0,285 285,585 585,930 930,1200 1200,1505
Yeah, yeah, {yeah.,So,I - -}

1396
00:35:05,970 --> 00:35:07,805
0,515 515,790 810,1210 1290,1610 1610,1835
scanned my file, I acquired

1397
00:35:07,805 --> 00:35:09,125
0,180 180,330 330,785 835,1110 1110,1320
all {my,locks.,Now - -} I'm

1398
00:35:09,125 --> 00:35:10,220
0,210 210,570 570,840 840,975 975,1095
just adding all of them

1399
00:35:10,220 --> 00:35:10,835
0,195 195,375 375,450 450,525 525,615
up because I have an

1400
00:35:10,835 --> 00:35:12,130
0,465 465,675 675,810 810,1020 1020,1295
aggregate stuff, {so,it's,flat. - -}

1401
00:35:12,150 --> 00:35:13,130
0,290 290,455 455,635 635,815 815,980
Then I start to drop

1402
00:35:13,130 --> 00:35:14,140
0,150 150,560
the locks.|
|

1403
00:35:14,280 --> 00:35:15,335
0,305 305,545 545,695 695,860 860,1055
So it's just to show
这只是为了说明锁点是在你到达顶峰的时候，如果你在做某事时拿着锁而停滞不前，那么锁点就是当你达到顶峰的时候。所以这是对这一事件发生时间的非常准确的定义。

1404
00:35:15,335 --> 00:35:16,355
0,255 255,435 435,615 615,840 840,1020
that the lock point is

1405
00:35:16,355 --> 00:35:17,165
0,135 135,270 270,450 450,630 630,810
when you reach the peak

1406
00:35:17,165 --> 00:35:18,290
0,240 240,435 435,555 555,750 750,1125
after that, if you're plateauing

1407
00:35:18,290 --> 00:35:19,115
0,180 180,360 360,510 510,660 660,825
out because you're holding the

1408
00:35:19,115 --> 00:35:20,140
0,285 285,435 435,615 615,735 735,1025
locks while you're doing something,

1409
00:35:20,370 --> 00:35:21,260
0,260 260,410 410,590 590,755 755,890
the lock point is when

1410
00:35:21,260 --> 00:35:22,280
0,120 120,285 285,450 450,710 790,1020
you reach the peak. {So,it's

1411
00:35:22,280 --> 00:35:23,350
0,135 135,195 195,345 345,650 670,1070
-} a very precise definition

1412
00:35:23,760 --> 00:35:24,850
0,275 275,425 425,620 620,815 815,1090
of when that event happened.|
|

1413
00:35:26,130 --> 00:35:27,040
0,400
Okay.|
好吧。|

1414
00:35:29,000 --> 00:35:29,690
0,120 120,225 225,420 420,600 600,690
Is it possible to have
有没有可能在类似的地方画一张图表？

1415
00:35:29,690 --> 00:35:31,060
0,120 120,315 315,540 540,830
a graph where like?|
|

1416
00:35:33,270 --> 00:35:34,715
0,260 260,410 410,755 755,1100 1100,1445
1 then drops everything. {Yes,,absolutely
1然后丢弃所有内容。是的，绝对是这样。这仍然是很好的。

1417
00:35:34,715 --> 00:35:36,680
0,365 1105,1440 1440,1650 1650,1800 1800,1965
-} {that.,That -} will still

1418
00:35:36,680 --> 00:35:37,680
0,135 135,380
be fine.|
|

1419
00:35:37,860 --> 00:35:39,320
0,400 630,935 935,1130 1130,1280 1280,1460
So as long as I'm
所以，只要我要达到顶峰，然后下降，在某个地方就没问题。不，事实上，在某种程度上还不错。是的，你会看到我们需要做一些类似的事情，制作一个更弱的版本。

1420
00:35:39,320 --> 00:35:39,965
0,135 135,270 270,360 360,495 495,645
going to a peak and

1421
00:35:39,965 --> 00:35:41,860
0,165 165,405 405,720 720,965 1495,1895
then dropping, it's fine somewhere.

1422
00:35:42,120 --> 00:35:42,995
0,260 260,440 440,560 560,725 725,875
{No,,it's -} not bad in

1423
00:35:42,995 --> 00:35:44,000
0,165 165,300 300,420 420,690 690,1005
some way, in {fact.,Yeah, -}

1424
00:35:44,000 --> 00:35:44,750
0,240 240,345 345,495 495,630 630,750
you'll see that we will

1425
00:35:44,750 --> 00:35:45,560
0,135 135,270 270,390 390,585 585,810
need to do something like

1426
00:35:45,560 --> 00:35:47,375
0,290 430,830 940,1410 1410,1605 1605,1815
that, a weaker version of

1427
00:35:47,375 --> 00:35:48,520
0,180 180,360 360,635
that to make.|
|

1428
00:35:48,520 --> 00:35:49,765
0,225 225,465 465,765 765,975 975,1245
A certain problem in this
这件事中的某个问题就会消失。好的，两相锁定还有一个小问题，所以请等待两张幻灯片。

1429
00:35:49,765 --> 00:35:51,355
0,330 330,665 985,1245 1245,1440 1440,1590
go away. {Okay,,there's -} still

1430
00:35:51,355 --> 00:35:53,320
0,210 210,465 465,815 1225,1625 1675,1965
one tiny problem in two

1431
00:35:53,320 --> 00:35:54,280
0,195 195,525 525,660 660,795 795,960
phase locking, so wait for

1432
00:35:54,280 --> 00:35:55,500
0,210 210,530
two slides.|
|

1433
00:35:56,050 --> 00:35:57,480
0,320 320,640
Other questions?|
还有其他问题吗？|

1434
00:35:58,600 --> 00:35:59,370
0,245 245,350 350,470 470,620 620,770
Because if you get this
因为如果你有了这种直觉，那么你就有了理解50种不同的锁定模式和所有其他疯狂事情的基础。但如果你没有这种直觉，就不可能有更复杂的东西。

1435
00:35:59,370 --> 00:36:00,330
0,420 420,660 660,765 765,855 855,960
intuition, then you have the

1436
00:36:00,330 --> 00:36:02,460
0,260 400,800 1090,1490 1510,1845 1845,2130
foundation to understand 50 different

1437
00:36:02,460 --> 00:36:03,495
0,255 255,555 555,690 690,870 870,1035
lock modes and all kinds

1438
00:36:03,495 --> 00:36:04,830
0,135 135,315 315,615 615,995 1075,1335
of other crazy stuff. {But,if

1439
00:36:04,830 --> 00:36:05,445
0,105 105,195 195,375 375,480 480,615
-} you don't get this

1440
00:36:05,445 --> 00:36:07,230
0,455 715,1095 1095,1200 1200,1475 1495,1785
intuition, there's no hope of

1441
00:36:07,230 --> 00:36:08,780
0,210 210,390 390,600 600,840 840,1550
getting to something more sophisticated.|
|

1442
00:36:09,750 --> 00:36:11,285
0,305 305,515 515,820 1080,1355 1355,1535
All right, so two phase
好的，所以有两个相位违反峰。很糟糕，对吧？没有山谷。啊，那么现在让我们回到过去。

1443
00:36:11,285 --> 00:36:13,220
0,485 565,990 990,1265 1375,1710 1710,1935
violation peaks. {Bad,right? -} No

1444
00:36:13,220 --> 00:36:16,265
0,470 760,1160 1780,2085 2085,2390 2680,3045
{valleys.,Ah, -} so now let's

1445
00:36:16,265 --> 00:36:17,300
0,120 120,395
go back.|
|

1446
00:36:17,300 --> 00:36:17,930
0,150 150,255 255,390 390,525 525,630
This is going to be
这将是非常微不足道的。看起来你们都明白了。您将获得将被授予的锁。现在，当你收到X锁的第二个请求时，啊，它会被向下推，这样你就不会得到那个请求。而且，啊，你，是的，你会开始看到一些这样的问题。

1447
00:36:17,930 --> 00:36:19,070
0,180 180,630 630,870 870,1020 1020,1140
very trivial. {Looks,like -} all

1448
00:36:19,070 --> 00:36:19,960
0,120 120,240 240,390 390,585 585,890
of you guys got {it.,You'll

1449
00:36:19,980 --> 00:36:21,305
0,425 425,650 650,830 830,1070 1070,1325
-} acquired the lock that

1450
00:36:21,305 --> 00:36:23,450
0,165 165,315 315,605 1075,1475 1825,2145
willll {get,granted. -} Now when

1451
00:36:23,450 --> 00:36:24,890
0,195 195,375 375,615 615,950 1120,1440
you get that second request

1452
00:36:24,890 --> 00:36:26,620
0,195 195,315 315,540 540,920 1330,1730
for the X lock, ah,

1453
00:36:26,880 --> 00:36:28,150
0,290 290,485 485,710 710,950 950,1270
it will get pushed down

1454
00:36:28,560 --> 00:36:30,080
0,400 450,800 800,1040 1040,1370 1370,1520
so that you won't be

1455
00:36:30,080 --> 00:36:32,590
0,270 270,630 630,1010 1360,1760 2110,2510
{granted,that -} request. And, ah,

1456
00:36:32,850 --> 00:36:34,510
0,400 420,820 930,1190 1190,1355 1355,1660
you, yeah, you will start

1457
00:36:34,560 --> 00:36:36,500
0,305 305,610 1380,1655 1655,1805 1805,1940
to see some of that

1458
00:36:36,500 --> 00:36:37,420
0,260
issues.|
|

1459
00:36:37,900 --> 00:36:39,165
0,365 365,545 545,740 740,890 890,1265
What's happening in the dependence
依赖图中发生了什么？这就是被问到的问题，对吗？

1460
00:36:39,165 --> 00:36:40,035
0,225 225,405 405,525 525,660 660,870
graph? That was the question

1461
00:36:40,035 --> 00:36:41,520
0,195 195,330 330,570 570,935
that was asked, right?|
|

1462
00:36:41,770 --> 00:36:43,320
0,335 335,620 620,935 935,1280 1280,1550
The first X lock is
第一个X锁用于事务。请参见依赖关系图。我们有两个t1t2，第二个X锁说，我不能再让你继续前进了。它的基本意思是，如果我让你往前走，我会从t1到t2形成一条弧线，我要杀了它。我甚至不会让这种事发生。如果我不允许这种情况发生，那就有办法了。

1463
00:36:43,320 --> 00:36:44,430
0,150 150,300 300,590 700,945 945,1110
for the transaction. {See,the -}

1464
00:36:44,430 --> 00:36:45,600
0,375 375,585 585,750 750,945 945,1170
dependence {graph.,We -} have two

1465
00:36:45,600 --> 00:36:46,965
0,180 330,480 480,660 660,950 1090,1365
t 1 t two, the

1466
00:36:46,965 --> 00:36:48,465
0,225 225,510 510,780 780,1115 1195,1500
second X lock said, I

1467
00:36:48,465 --> 00:36:49,365
0,315 315,495 495,645 645,765 765,900
can't allow you to go

1468
00:36:49,365 --> 00:36:51,045
0,195 195,515 805,1170 1170,1410 1410,1680
{any,further. -} It's basically saying

1469
00:36:51,045 --> 00:36:51,750
0,135 135,255 255,390 390,525 525,705
if I let you go

1470
00:36:51,750 --> 00:36:53,370
0,320 880,1140 1140,1290 1290,1470 1470,1620
forward, I will form an

1471
00:36:53,370 --> 00:36:54,240
0,270 270,405 405,555 555,720 720,870
arc from t one to

1472
00:36:54,240 --> 00:36:55,575
0,165 165,945 945,1095 1095,1200 1200,1335
t 2. I'm going {to,kill

1473
00:36:55,575 --> 00:36:56,775
0,165 165,485 565,885 885,990 990,1200
-} that. I'm not even

1474
00:36:56,775 --> 00:36:57,710
0,225 225,375 375,510 510,660 660,935
going {to,let,that - -} happen.

1475
00:36:57,910 --> 00:36:58,920
0,275 275,395 395,650 650,830 830,1010
If I don't allow that

1476
00:36:58,920 --> 00:37:00,860
0,150 150,410 700,1005 1005,1310
to happen, there is.|
|

1477
00:37:00,860 --> 00:37:02,050
0,270 270,560 580,825 825,930 930,1190
No cycle to be formed
不会形成循环，因为我被允许不允许弧线发生。

1478
00:37:02,130 --> 00:37:03,965
0,260 260,575 575,860 860,1415 1415,1835
because I'm allowed disallowing arcs

1479
00:37:03,965 --> 00:37:05,060
0,135 135,395
from happening.|
|

1480
00:37:06,480 --> 00:37:07,760
0,290 290,425 425,605 605,695 695,1280
And so it's a pessimistic
所以这是一种悲观的形式，对吗？这是悲观的，因为也许只有一条弧线就可以了。这个周期还没有完成。所以我们稍后会讨论乐观的事情。但这是一种直觉，并连接到所有依赖图的位置，你知道，它何时获得以及为什么这是有意义的，为什么锁定有效是因为它在这些弧线形成的过程中打破了它们。

1481
00:37:07,760 --> 00:37:09,935
0,290 700,1050 1050,1350 1350,1950 1950,2175
form, right? It's pessimistic because

1482
00:37:09,935 --> 00:37:11,180
0,305 325,630 630,810 810,1050 1050,1245
maybe just one arc is

1483
00:37:11,180 --> 00:37:12,455
0,350 520,795 795,975 975,1140 1140,1275
okay. {The,cycle -} has not

1484
00:37:12,455 --> 00:37:13,745
0,240 240,605 715,990 990,1125 1125,1290
been {completed.,And -} so we'll

1485
00:37:13,745 --> 00:37:14,915
0,150 150,315 315,405 405,635 865,1170
talk about the optimistic {stuff,later.

1486
00:37:14,915 --> 00:37:16,010
0,305 385,645 645,840 840,960 960,1095
-} But that's kind of

1487
00:37:16,010 --> 00:37:17,525
0,90 90,500 610,975 975,1335 1335,1515
the intuition and connecting back

1488
00:37:17,525 --> 00:37:18,590
0,150 150,270 270,420 420,630 630,1065
to where all this dependence

1489
00:37:18,590 --> 00:37:20,525
0,285 285,650 1330,1590 1590,1725 1725,1935
graph is, you know, when

1490
00:37:20,525 --> 00:37:22,370
0,225 225,515 985,1350 1350,1635 1635,1845
it gets and why that

1491
00:37:22,370 --> 00:37:23,810
0,210 210,530 550,855 855,1050 1050,1440
makes sense, and why locking

1492
00:37:23,810 --> 00:37:25,145
0,255 255,540 540,765 765,1080 1080,1335
works is because it's breaking

1493
00:37:25,145 --> 00:37:26,375
0,240 240,705 705,960 960,1110 1110,1230
these arcs as they are

1494
00:37:26,375 --> 00:37:27,300
0,195 195,515
getting formed.|
|

1495
00:37:27,570 --> 00:37:29,580
0,335 335,440 440,575 575,850
Let's say I have.|
比方说我有过。|

1496
00:37:29,580 --> 00:37:30,510
0,165 165,315 315,555 555,840 840,930
To these guys, let's say
对于这些人，让我们假设右边的工作人员，就在X之后，锁定a，下一个log b。

1497
00:37:30,510 --> 00:37:31,200
0,105 105,285 285,495 495,600 600,690
the working guy on the

1498
00:37:31,200 --> 00:37:32,505
0,260 490,765 765,990 990,1170 1170,1305
right, right after the X,

1499
00:37:32,505 --> 00:37:33,390
0,195 195,390 390,540 540,690 690,885
lock a, the next log

1500
00:37:33,390 --> 00:37:34,280
0,290
b.|
|

1501
00:37:34,290 --> 00:37:35,320
0,290 290,425 425,530 530,710 710,1030
Right. {So,it -} once be
正确的。曾经是这样，现在也是。

1502
00:37:35,640 --> 00:37:36,020
0,350
and.|
|

1503
00:37:36,120 --> 00:37:37,250
0,275 275,470 470,680 680,875 875,1130
But X lock a won't
但是锁A不会，所以问题是，在X，log，a，t，2有一个X，log，b之后，但是不会被授予，所以它会被回避。是的，这就是为什么我们不用b。

1504
00:37:37,250 --> 00:37:38,120
0,120 120,270 270,390 390,570 570,870
be so the question is

1505
00:37:38,120 --> 00:37:39,575
0,330 330,585 585,795 795,1100 1150,1455
after X log a t

1506
00:37:39,575 --> 00:37:40,460
0,210 210,390 390,525 525,690 690,885
two has an X log

1507
00:37:40,460 --> 00:37:41,375
0,240 240,465 465,630 630,780 780,915
b, but X log a

1508
00:37:41,375 --> 00:37:42,290
0,210 210,315 315,555 555,765 765,915
won't be granted, so it's

1509
00:37:42,290 --> 00:37:43,505
0,90 90,195 195,270 270,590 880,1215
going to be evading. {That's,the

1510
00:37:43,505 --> 00:37:45,095
0,105 105,365 475,875 1165,1440 1440,1590
-} way yes, t one

1511
00:37:45,095 --> 00:37:46,380
0,240 240,420 420,755
isn't using b.|
|

1512
00:37:46,750 --> 00:37:47,940
0,275 275,425 425,905 905,1025 1025,1190
We could, theoretically, if this
从理论上讲，如果这个b步是独立的，我们可以使用。是的，是的。所以--等一下那些僵持的东西是的。但如果你这样做了，如果一个人后来想用b，那可能是不同的。所以你的问题是，哦，如果。

1513
00:37:47,940 --> 00:37:49,140
0,210 210,405 405,645 645,975 975,1200
b step is independent, we

1514
00:37:49,140 --> 00:37:50,265
0,120 120,225 225,470 550,885 885,1125
could be using. {Yeah,,yeah. {-},So

1515
00:37:50,265 --> 00:37:51,000
0,165 165,315 315,480 480,615 615,735
-} hold on for the

1516
00:37:51,000 --> 00:37:52,365
0,420 420,675 675,1020 1020,1230 1230,1365
deadlocked {stuff,,yes. -} But if

1517
00:37:52,365 --> 00:37:53,250
0,135 135,285 285,510 510,720 720,885
you did that and if

1518
00:37:53,250 --> 00:37:54,120
0,165 165,315 315,525 525,705 705,870
t one wanted to use

1519
00:37:54,120 --> 00:37:55,640
0,195 195,470 730,1020 1020,1215 1215,1520
b later, that could {be,a

1520
00:37:56,230 --> 00:37:57,735
0,275 275,515 515,880 900,1220 1220,1505
-} difference. So your question

1521
00:37:57,735 --> 00:37:59,640
0,360 360,755 1195,1595
is, oh if.|
|

1522
00:37:59,640 --> 00:38:01,305
0,300 300,600 600,945 945,1320 1320,1665
T two wanted a and
两个人想要a和b，难道我想要a但它被锁住了吗？我能继续与b取得进展吗？

1523
00:38:01,305 --> 00:38:03,320
0,365 955,1230 1230,1395 1395,1650 1650,2015
b, could it say that

1524
00:38:03,520 --> 00:38:04,470
0,305 305,500 500,635 635,755 755,950
I tried to get a

1525
00:38:04,470 --> 00:38:05,325
0,180 180,300 300,435 435,645 645,855
but it is locked. {Can,I,keep

1526
00:38:05,325 --> 00:38:06,390
0,135 135,285 285,510 510,810 810,1065
- -} making progress with

1527
00:38:06,390 --> 00:38:07,280
0,290
b?|
|

1528
00:38:07,280 --> 00:38:08,705
0,135 135,410 850,1155 1155,1305 1305,1425
It can, and there are
它可以，而且有复杂的协议可以做到这一点。许多不同的锁定模式都会问，你真的想立即使用X锁吗，或者你只是想检查一下你能不能得到它之类的东西？所以我们将学习更复杂的协议，大部分都在高级课程中，但是我们会在这节课的最后提到一些类似的技术。

1529
00:38:08,705 --> 00:38:10,115
0,495 495,930 930,1125 1125,1260 1260,1410
sophisticated protocols that'll do that.

1530
00:38:10,115 --> 00:38:10,895
0,150 150,315 315,450 450,570 570,780
{And,many -} of these different

1531
00:38:10,895 --> 00:38:12,275
0,375 375,615 615,750 750,1025 1105,1380
locking modes will say, do

1532
00:38:12,275 --> 00:38:13,235
0,165 165,405 405,645 645,795 795,960
you really want an X

1533
00:38:13,235 --> 00:38:14,255
0,270 270,570 570,765 765,900 900,1020
lock right away or do

1534
00:38:14,255 --> 00:38:15,005
0,105 105,255 255,435 435,585 585,750
you just want to check

1535
00:38:15,005 --> 00:38:15,890
0,180 180,315 315,465 465,630 630,885
that you can get it

1536
00:38:15,890 --> 00:38:16,835
0,285 285,495 495,675 675,825 825,945
and stuff like that? So

1537
00:38:16,835 --> 00:38:18,350
0,165 165,300 300,605 625,930 930,1515
we'll get to more sophisticated

1538
00:38:18,350 --> 00:38:19,505
0,480 480,660 660,870 870,1020 1020,1155
protocols, most of it in

1539
00:38:19,505 --> 00:38:20,870
0,195 195,465 465,750 750,1050 1050,1365
the advanced class, but we'll

1540
00:38:20,870 --> 00:38:21,755
0,285 285,480 480,600 600,735 735,885
allude to some of those

1541
00:38:21,755 --> 00:38:22,730
0,255 255,495 495,660 660,855 855,975
techniques like that towards the

1542
00:38:22,730 --> 00:38:23,980
0,105 105,240 240,390 390,680
end of this lecture.|
|

1543
00:38:23,980 --> 00:38:25,540
0,260 370,645 645,920 1090,1395 1395,1560
Yeah, one of it's probably
是的，其中一个可能也是高级配置文件，但如果其中一个将是这样的，你会喜欢优先级吗？

1544
00:38:25,540 --> 00:38:26,665
0,225 225,435 435,630 630,885 885,1125
also an advanced profile, but

1545
00:38:26,665 --> 00:38:27,505
0,225 225,450 450,585 585,705 705,840
like, could you do like

1546
00:38:27,505 --> 00:38:28,780
0,275 355,645 645,900 900,1140 1140,1275
priorities if like one of

1547
00:38:28,780 --> 00:38:29,455
0,120 120,255 255,420 420,555 555,675
them is going to be

1548
00:38:29,455 --> 00:38:30,200
0,275
like?|
|

1549
00:38:30,200 --> 00:38:31,265
0,270 270,375 375,630 630,915 915,1065
It's going to lock in
它将被锁定，就像我正在锁定我们将坚持大约一个小时，是的。我们想要确定优先顺序，绝对的。你可以做各种各样的事情，我们将讨论锁定的粒度，你可能会说，如果我有，我正在扫描一个有10亿行的文件，获得10亿个锁是非常昂贵的。

1550
00:38:31,265 --> 00:38:32,525
0,105 105,300 300,780 780,1035 1035,1260
and like i'mlocking either we're

1551
00:38:32,525 --> 00:38:32,945
0,75 75,165 165,255 255,345 345,420
going to hold for like

1552
00:38:32,945 --> 00:38:34,445
0,90 90,335 385,765 765,1145 1255,1500
an hour, yeah. {And,we -}

1553
00:38:34,445 --> 00:38:35,750
0,120 120,240 240,675 675,965 1045,1305
want to prioritize, {absolutely.,You -}

1554
00:38:35,750 --> 00:38:36,515
0,135 135,255 255,405 405,600 600,765
can do all kinds of

1555
00:38:36,515 --> 00:38:37,595
0,270 270,570 570,780 780,915 915,1080
that and we'll talk about

1556
00:38:37,595 --> 00:38:38,825
0,585 585,735 735,1035 1035,1140 1140,1230
granularities of locking where you

1557
00:38:38,825 --> 00:38:39,905
0,135 135,420 420,690 690,900 900,1080
might say, if I've got,

1558
00:38:39,905 --> 00:38:40,925
0,330 330,600 600,705 705,855 855,1020
I'm scanning a file with

1559
00:38:40,925 --> 00:38:43,205
0,135 135,395 715,1445 1735,2100 2100,2280
a billion rows, acquiring a

1560
00:38:43,205 --> 00:38:44,440
0,195 195,510 510,630 630,870 870,1235
billion locks is very expensive.|
|

1561
00:38:45,080 --> 00:38:46,475
0,345 345,585 585,900 900,1155 1155,1395
It's more expensive than reading
这比看唱片要贵。我能做得更好吗？所以要牢牢把握住这一点。

1562
00:38:46,475 --> 00:38:47,660
0,180 180,425 655,915 915,1050 1050,1185
the record. {Can,I,do - -}

1563
00:38:47,660 --> 00:38:48,635
0,195 195,465 465,660 660,810 810,975
something better? So hold on

1564
00:38:48,635 --> 00:38:49,520
0,135 135,395
to that.|
|

1565
00:38:50,900 --> 00:38:52,675
0,380 380,760 1050,1325 1325,1490 1490,1775
Okay, great. {All,right. {-},So -}
好的，太好了。好的，所以--基本上这就是为什么锁定起作用了，因为我们试图打破这些弧线。

1566
00:38:52,675 --> 00:38:54,670
0,395 1105,1425 1425,1620 1620,1770 1770,1995
basically all this is saying

1567
00:38:54,670 --> 00:38:55,975
0,270 270,590 730,1005 1005,1155 1155,1305
is that this is why

1568
00:38:55,975 --> 00:38:57,040
0,300 300,570 570,855 855,975 975,1065
locking works, because we are

1569
00:38:57,040 --> 00:38:58,170
0,135 135,270 270,420 420,600 600,1130
trying to break these arcs.|
|

1570
00:38:59,060 --> 00:39:00,655
0,260 260,425 425,800 800,1120 1320,1595
From the dependence graph that
从我们讨论的依赖图，我们在上一节课中讨论的依赖图，好的。

1571
00:39:00,655 --> 00:39:02,245
0,150 150,360 360,695 745,1095 1095,1590
we talked about, the dependency

1572
00:39:02,245 --> 00:39:03,040
0,165 165,315 315,435 435,615 615,795
graph that we talked about

1573
00:39:03,040 --> 00:39:04,590
0,120 120,225 225,405 405,740 1150,1550
in the last class, okay.|
|

1574
00:39:05,150 --> 00:39:06,260
0,400
So.|
所以。|

1575
00:39:07,280 --> 00:39:09,625
0,290 290,485 485,1000 1200,1600 2070,2345
Two face locking works, but
双面锁定有效，但有一个问题。这个问题被称为级联中止。

1576
00:39:09,625 --> 00:39:10,945
0,135 135,300 300,525 525,845 1015,1320
it has one problem. {That,problem

1577
00:39:10,945 --> 00:39:12,630
0,240 240,450 450,660 660,1215 1215,1685
-} is called cascading aborts.|
|

1578
00:39:13,600 --> 00:39:16,370
0,320 320,1060 1200,1600 2190,2480 2480,2770
Remember databases start a transaction
请记住，数据库使用BEGIN语句启动事务。

1579
00:39:16,630 --> 00:39:18,380
0,275 275,470 470,680 680,970
with the begin statement.|
|

1580
00:39:18,380 --> 00:39:19,700
0,195 195,500
And then?|
后来怎么样了？|

1581
00:39:20,000 --> 00:39:21,295
0,400 510,785 785,965 965,1145 1145,1295
Transaction could end with a
事务可以以提交结束，这意味着进行所有更改并使其成为永久性的。或者，它可能以一个机器人结束，说，哎呀，撤销一切。

1582
00:39:21,295 --> 00:39:22,420
0,270 270,555 555,765 765,960 960,1125
commit, which means make all

1583
00:39:22,420 --> 00:39:23,410
0,135 135,380 400,690 690,855 855,990
the changes and make it

1584
00:39:23,410 --> 00:39:24,565
0,260 580,810 810,900 900,1020 1020,1155
permanent. {Or,it -} could end

1585
00:39:24,565 --> 00:39:25,800
0,180 180,330 330,585 585,750 750,1235
within a bot saying, whoops,

1586
00:39:25,820 --> 00:39:27,280
0,590 590,970
undo everything.|
|

1587
00:39:27,420 --> 00:39:28,550
0,395 395,620 620,860 860,995 995,1130
It's the and you want
这是，您希望在事务中要么全有要么全不执行的组件。

1588
00:39:28,550 --> 00:39:29,315
0,135 135,240 240,390 390,585 585,765
to do this all or

1589
00:39:29,315 --> 00:39:32,520
0,275 595,995 1585,1875 1875,2165
nothing component with transactions.|
|

1590
00:39:32,680 --> 00:39:34,170
0,290 290,545 545,860 860,1205 1205,1490
But the point is a
但问题是，b也有可能发生。事务可能会被中止。

1591
00:39:34,170 --> 00:39:35,960
0,290 370,675 675,980 1000,1395 1395,1790
b can also happen. {Transaction,could

1592
00:39:36,040 --> 00:39:37,560
0,305 305,470 470,850
-} get aborted.|
|

1593
00:39:37,560 --> 00:39:38,490
0,240 240,420 420,585 585,720 720,930
And now, in the presence
现在，在机器人的存在下，你开始有这种情况，即使我遵循两相锁定协议。

1594
00:39:38,490 --> 00:39:40,095
0,225 225,360 360,890 1030,1350 1350,1605
of a bots, you start

1595
00:39:40,095 --> 00:39:42,260
0,210 210,420 420,755 1435,1800 1800,2165
to have this situation where

1596
00:39:42,640 --> 00:39:44,115
0,395 395,665 665,905 905,1150 1170,1475
even if I'm following two

1597
00:39:44,115 --> 00:39:46,060
0,255 255,720 720,1295
phase locking protocol.|
|

1598
00:39:46,070 --> 00:39:47,965
0,275 275,470 470,790 1320,1670 1670,1895
I have a hole that
我把自己挖了一个洞，却出不来。那个洞是什么？让我们用一个例子来说明这一点。

1599
00:39:47,965 --> 00:39:49,675
0,165 165,390 390,755 835,1235 1435,1710
I've dug myself into and

1600
00:39:49,675 --> 00:39:50,500
0,135 135,390 390,510 510,660 660,825
I can't get out of

1601
00:39:50,500 --> 00:39:51,985
0,270 270,630 630,735 735,1010 1120,1485
it. {What's,that -} hole? Let's

1602
00:39:51,985 --> 00:39:53,250
0,450 450,600 600,735 735,930 930,1265
illustrate that with an example.|
|

1603
00:39:54,000 --> 00:39:55,300
0,335 335,620 620,845 845,1010 1010,1300
So here is a schedule
因此，这是一个开始事务t的时间表。

1604
00:39:55,530 --> 00:39:56,855
0,275 275,440 440,730 840,1130 1130,1325
in which transaction t one

1605
00:39:56,855 --> 00:39:58,020
0,305
starts.|
|

1606
00:39:58,220 --> 00:39:59,790
0,350 350,560 560,785 785,965 965,1570
It's following two phase protocol.
它遵循两个阶段的协议。T Two也在做同样的事情。

1607
00:39:59,960 --> 00:40:01,000
0,290 290,425 425,545 545,785 785,1040
{T,two -} is also doing

1608
00:40:01,000 --> 00:40:02,100
0,135 135,380
the same.|
|

1609
00:40:02,100 --> 00:40:03,870
0,230 250,630 630,900 900,1220 1480,1770
And acquires its lock, then
然后拿到它的锁，然后解锁，因为它不再需要啊，任何一个了。对，所以它达到了它的锁定点，现在解锁后，所有两个阶段的锁都说你不能再做任何锁了。

1610
00:40:03,870 --> 00:40:05,145
0,465 465,660 660,885 885,1020 1020,1275
unlocks it because it doesn't

1611
00:40:05,145 --> 00:40:08,450
0,275 685,1085 1675,2070 2070,2465 2905,3305
need ah, any of a

1612
00:40:08,530 --> 00:40:10,335
0,400 600,920 920,1160 1160,1385 1385,1805
anymore. {Right,,so -} it reaches

1613
00:40:10,335 --> 00:40:11,940
0,195 195,450 450,785 1135,1425 1425,1605
its lock point and now

1614
00:40:11,940 --> 00:40:13,380
0,225 225,705 705,1020 1020,1245 1245,1440
after unlock all two phase

1615
00:40:13,380 --> 00:40:14,580
0,360 360,570 570,765 765,1080 1080,1200
locking says you can't do

1616
00:40:14,580 --> 00:40:15,880
0,165 165,345 345,830
any more locks.|
|

1617
00:40:16,040 --> 00:40:17,740
0,395 395,820 870,1250 1250,1535 1535,1700
But it still continues to
但它仍然继续在b上做功，因为它没有解锁b。

1618
00:40:17,740 --> 00:40:18,700
0,120 120,285 285,480 480,735 735,960
do work on b because

1619
00:40:18,700 --> 00:40:20,240
0,120 120,360 360,705 705,950
it hasn't unlocked b.|
|

1620
00:40:21,180 --> 00:40:22,625
0,335 335,670 780,1100 1100,1280 1280,1445
T two gets the lock
TTwo获得了a的锁，因为它被释放了。

1621
00:40:22,625 --> 00:40:23,555
0,180 180,405 405,615 615,735 735,930
for a because that was

1622
00:40:23,555 --> 00:40:24,560
0,335
released.|
|

1623
00:40:24,690 --> 00:40:25,750
0,335 335,530 530,650 650,785 785,1060
Starts to do its work.|
开始发挥它的作用。|

1624
00:40:26,430 --> 00:40:27,785
0,305 305,560 560,845 845,1085 1085,1355
But later on, t one
但后来，一个人继续说，哦，不，有些不对劲，我需要中止。

1625
00:40:27,785 --> 00:40:29,920
0,875 925,1245 1245,1515 1515,1800 1800,2135
proceeds and says, oh no,

1626
00:40:30,510 --> 00:40:32,375
0,575 575,820 1260,1550 1550,1730 1730,1865
something's wrong, I need to

1627
00:40:32,375 --> 00:40:33,260
0,335
abort.|
|

1628
00:40:33,940 --> 00:40:35,820
0,400 1080,1340 1340,1445 1445,1595 1595,1880
Now we are all following
现在我们都在遵循两相锁定。

1629
00:40:35,820 --> 00:40:37,380
0,255 255,465 465,1010
two phase locking.|
|

1630
00:40:37,390 --> 00:40:39,495
0,400 930,1265 1265,1580 1580,1895 1895,2105
But t two has read
但是t2已经读取了一个值，a必须被撤销，所以它是红色的。

1631
00:40:39,495 --> 00:40:40,920
0,135 135,375 375,755 985,1260 1260,1425
a value, a that has

1632
00:40:40,920 --> 00:40:42,090
0,135 135,225 225,650 670,915 915,1170
to be undone, so it's

1633
00:40:42,090 --> 00:40:43,080
0,290
red.|
|

1634
00:40:43,160 --> 00:40:44,515
0,275 275,515 515,880 930,1280 1280,1355
A dirty value. {It's,a -}
肮脏的价值。这是一个肮脏的阅读。

1635
00:40:44,515 --> 00:40:45,680
0,195 195,545
dirty read.|
|

1636
00:40:46,230 --> 00:40:47,520
0,400
No.|
不是的。|

1637
00:40:47,520 --> 00:40:49,050
0,225 225,525 525,945 945,1290 1290,1530
We can't unwind ourselves from
我们不能从这件事中解脱出来。尽管我们遵循的是两相锁定。当我们到达数据库的中止呼叫时，我们就有麻烦了。如果现在撤消这两个，你打算做什么？如果TTwo已经承诺，并且已经支付了那25美元，会怎么样？你不能撤销它。

1638
00:40:49,050 --> 00:40:50,175
0,290 400,735 735,930 930,1035 1035,1125
this. {Even,though -} we are

1639
00:40:50,175 --> 00:40:51,270
0,210 210,450 450,645 645,1005 1005,1095
following two phase {locking.,We -}

1640
00:40:51,270 --> 00:40:52,260
0,75 75,195 195,470 550,840 840,990
are in trouble when we

1641
00:40:52,260 --> 00:40:53,370
0,165 165,360 360,705 705,915 915,1110
reach the abort call comes

1642
00:40:53,370 --> 00:40:54,150
0,150 150,255 255,495 495,720 720,780
to {the,database. -} What are

1643
00:40:54,150 --> 00:40:55,110
0,75 75,180 180,285 285,530 610,960
you going to do if

1644
00:40:55,110 --> 00:40:56,745
0,240 240,660 660,870 870,1190 1360,1635
now undo t two? What

1645
00:40:56,745 --> 00:40:57,825
0,150 150,315 315,465 465,720 720,1080
if t two was already

1646
00:40:57,825 --> 00:40:59,865
0,365 595,995 1345,1680 1680,1890 1890,2040
committed and had already paid

1647
00:40:59,865 --> 00:41:00,930
0,150 150,300 300,660 660,870 870,1065
out that 25 dollars? You

1648
00:41:00,930 --> 00:41:02,140
0,180 180,465 465,740
can't undo that.|
|

1649
00:41:02,390 --> 00:41:04,075
0,400 750,1025 1025,1340 1340,1490 1490,1685
So we can't let t
所以我们不能让这两个人走。

1650
00:41:04,075 --> 00:41:05,180
0,180 180,455
two go.|
|

1651
00:41:05,490 --> 00:41:07,235
0,290 290,455 455,730 1170,1520 1520,1745
If it is has got
如果它已经得到了对t1的依赖，那么我们如何才能使两个面锁定更安全？

1652
00:41:07,235 --> 00:41:09,620
0,180 180,905 1255,1635 1635,1950 2190,2385
a dependency on t 1

1653
00:41:09,620 --> 00:41:11,090
0,150 150,360 360,570 570,920 1120,1470
t one not committed, so

1654
00:41:11,090 --> 00:41:12,020
0,240 240,405 405,525 525,705 705,930
how can we make two

1655
00:41:12,020 --> 00:41:13,980
0,210 210,630 630,1310
face locking safer?|
|

1656
00:41:13,980 --> 00:41:15,210
0,255 255,570 570,810 810,1005 1005,1230
To this type of problem,
对于这种类型的问题，它对于可序列化目的来说已经是安全的，好吗？

1657
00:41:15,210 --> 00:41:16,815
0,270 270,480 480,735 735,945 945,1605
it's already safe for serializable

1658
00:41:16,815 --> 00:41:18,240
0,275 535,935
purposes, okay?|
|

1659
00:41:18,240 --> 00:41:20,175
0,225 225,500 670,1035 1035,1400 1570,1935
But now it it still
但现在，它仍然需要我们处理这种关于问题的级联，因为事务可能会中止。

1660
00:41:20,175 --> 00:41:21,135
0,315 315,555 555,720 720,840 840,960
will require us to deal

1661
00:41:21,135 --> 00:41:22,430
0,150 150,300 300,735 735,990 990,1295
with this cascading about problems

1662
00:41:22,450 --> 00:41:24,200
0,275 275,550 600,860 860,1240
because transactions can abort.|
|

1663
00:41:24,330 --> 00:41:25,690
0,400 480,770 770,935 935,1085 1085,1360
Everyone, does that make sense?|
各位，这说得通吗？|

1664
00:41:27,350 --> 00:41:28,690
0,275 275,550 750,1025 1025,1190 1190,1340
Okay, so the way to
好的，所以让它安全的方法是对两相锁定做一些更多的事情，对吗？所以这个允许的时间表，我们想让它在一个新的协议中被禁止，这个协议被称为强，严格的两阶段锁定。教科书还称其为严格的两相锁定。

1665
00:41:28,690 --> 00:41:31,350
0,150 150,315 315,590 700,1100 2260,2660
make it safe is to

1666
00:41:31,700 --> 00:41:32,950
0,335 335,620 620,845 845,1040 1040,1250
do something a little bit

1667
00:41:32,950 --> 00:41:34,360
0,290 610,900 900,1050 1050,1200 1200,1410
more with the two phase

1668
00:41:34,360 --> 00:41:36,640
0,530 760,1080 1080,1395 1395,1695 1695,2280
locking, right? So this permissible

1669
00:41:36,640 --> 00:41:38,230
0,290 940,1200 1200,1350 1350,1485 1485,1590
schedule, we want to make

1670
00:41:38,230 --> 00:41:39,850
0,240 240,1140 1140,1335 1335,1470 1470,1620
it unadmittable in a new

1671
00:41:39,850 --> 00:41:43,015
0,560 850,1250 1780,2130 2130,2750 2830,3165
protocol and the protocol is

1672
00:41:43,015 --> 00:41:44,935
0,335 715,1115 1195,1500 1500,1695 1695,1920
called strong, strict two phase

1673
00:41:44,935 --> 00:41:46,600
0,540 540,795 795,1140 1140,1380 1380,1665
locking. {The,textbook -} also calls

1674
00:41:46,600 --> 00:41:48,360
0,315 315,855 855,1035 1035,1230 1230,1760
it rigorous two phase locking.|
|

1675
00:41:48,770 --> 00:41:49,780
0,260 260,365 365,575 575,830 830,1010
And if you understand this
如果你了解我们所说的锁点业务。

1676
00:41:49,780 --> 00:41:50,905
0,210 210,465 465,765 765,990 990,1125
lock point business that we

1677
00:41:50,905 --> 00:41:52,020
0,195 195,515
talked about.|
|

1678
00:41:52,020 --> 00:41:53,220
0,195 195,500 670,930 930,1065 1065,1200
Right. {So,if -} you go
正确的。所以如果你回到这里，你能想一想你会对这张图做些什么来改善这个问题吗？所以这是正确的协议，对，我们到目前为止一直在遵循，但投射机器人是会发生的。

1679
00:41:53,220 --> 00:41:54,165
0,150 150,420 420,675 675,795 795,945
back here, can you think

1680
00:41:54,165 --> 00:41:54,975
0,195 195,375 375,525 525,660 660,810
about what you would do

1681
00:41:54,975 --> 00:41:56,805
0,150 150,330 330,635 1015,1415 1495,1830
to this graph to make

1682
00:41:56,805 --> 00:41:58,740
0,270 270,600 600,995 1375,1710 1710,1935
this problem better? So this

1683
00:41:58,740 --> 00:41:59,910
0,150 150,330 330,525 525,960 960,1170
is the correct protocol, right,

1684
00:41:59,910 --> 00:42:00,810
0,150 150,315 315,405 405,645 645,900
that we've been following so

1685
00:42:00,810 --> 00:42:01,980
0,210 210,405 405,780 780,915 915,1170
far, but casting a bots

1686
00:42:01,980 --> 00:42:02,980
0,260
happens.|
|

1687
00:42:04,080 --> 00:42:04,970
0,275 275,395 395,515 515,665 665,890
Can you think of something
你能想出什么办法来处理这张图的形状吗？

1688
00:42:04,970 --> 00:42:05,690
0,210 210,330 330,450 450,555 555,720
to do to the shape

1689
00:42:05,690 --> 00:42:07,080
0,195 195,375 375,680
of this graph?|
|

1690
00:42:07,480 --> 00:42:09,760
0,395 395,725 725,1235 1235,1750
To stop cascading bots.|
以阻止层叠的机器人。|

1691
00:42:09,770 --> 00:42:10,600
0,275 275,410 410,515 515,650 650,830
What was the root cause
瀑布的根本原因是什么？是的，是的。

1692
00:42:10,600 --> 00:42:12,080
0,150 150,510 510,830 1030,1430
of cascading? Yep, yep.|
|

1693
00:42:13,490 --> 00:42:15,030
0,400 510,830 830,1055 1055,1250 1250,1540
Correct release all at once
一次正确发布，什么时候发布？

1694
00:42:15,380 --> 00:42:16,330
0,290 290,455 455,575 575,740 740,950
and when do you release

1695
00:42:16,330 --> 00:42:17,140
0,290
it?|
|

1696
00:42:19,550 --> 00:42:21,145
0,400 870,1160 1160,1325 1325,1460 1460,1595
Exactly. {So,what -} if we
一点儿没错。所以，如果我们说你爬山，它是一个高原，然后它是一个悬崖。

1697
00:42:21,145 --> 00:42:22,420
0,275 325,630 630,855 855,1035 1035,1275
said you climb the mountain,

1698
00:42:22,420 --> 00:42:23,350
0,330 330,420 420,720 720,810 810,930
it's a plateau and then

1699
00:42:23,350 --> 00:42:24,560
0,180 180,285 285,560
it's a cliff.|
|

1700
00:42:24,670 --> 00:42:26,175
0,305 305,560 560,785 785,995 995,1505
Which means you never unlock
这意味着你永远不会提早解锁。没有人能看到一笔交易，一件被抢走的物品基本上是，你知道，如果你在19世纪70年代拿出这个东西，你就会获奖，所以。

1701
00:42:26,175 --> 00:42:27,590
0,335 535,810 810,960 960,1125 1125,1415
early. {No,one -} can see

1702
00:42:27,970 --> 00:42:30,285
0,320 320,640 810,1210 1740,2030 2030,2315
that a transaction, the a

1703
00:42:30,285 --> 00:42:32,840
0,395 865,1170 1170,1410 1410,2015 2155,2555
object that was grabbed was

1704
00:42:33,100 --> 00:42:34,485
0,400 810,1085 1085,1205 1205,1295 1295,1385
basically, you know, if you

1705
00:42:34,485 --> 00:42:35,235
0,135 135,300 300,450 450,585 585,750
had come up with that

1706
00:42:35,235 --> 00:42:36,945
0,305 385,785 925,1500 1500,1620 1620,1710
in 19 seventies you would

1707
00:42:36,945 --> 00:42:38,360
0,120 120,255 255,420 420,725 1015,1415
have won an award, so.|
|

1708
00:42:40,890 --> 00:42:41,780
0,260 260,380 380,515 515,695 695,890
But it was very hard
但在那个时候，你很难理解所有这些东西。它变得很容易，因为现在我已经向你们展示了图表。当有人简单地向你解释某事时，你总是会说，哦，这是微不足道的。但如果你没有这一点，就需要花很长时间来概念化。而以这种正确的方式抽象就是艺术。

1709
00:42:41,780 --> 00:42:42,545
0,165 165,315 315,480 480,630 630,765
at that time to just

1710
00:42:42,545 --> 00:42:43,310
0,135 135,255 255,435 435,630 630,765
get your head around all

1711
00:42:43,310 --> 00:42:44,780
0,135 135,315 315,620 880,1230 1230,1470
of this stuff. {It,becomes -}

1712
00:42:44,780 --> 00:42:46,160
0,285 285,570 570,860 880,1245 1245,1380
easy because now I've shown

1713
00:42:46,160 --> 00:42:47,045
0,135 135,255 255,435 435,615 615,885
you the {graph.,This -} is

1714
00:42:47,045 --> 00:42:48,275
0,300 300,465 465,660 660,975 975,1230
always the case where when

1715
00:42:48,275 --> 00:42:49,400
0,255 255,600 600,780 780,885 885,1125
someone explains to you something

1716
00:42:49,400 --> 00:42:50,255
0,315 315,510 510,630 630,750 750,855
simply, you say, oh, it

1717
00:42:50,255 --> 00:42:51,620
0,150 150,635 685,1035 1035,1245 1245,1365
{is,trivial. -} But if you

1718
00:42:51,620 --> 00:42:52,625
0,225 225,375 375,600 600,810 810,1005
didn't have that, it just

1719
00:42:52,625 --> 00:42:53,585
0,165 165,285 285,480 480,720 720,960
took a long time {to,conceptualize

1720
00:42:53,585 --> 00:42:55,610
0,600 600,905 955,1350 1350,1890 1890,2025
-} that. And abstraction in

1721
00:42:55,610 --> 00:42:56,675
0,135 135,330 330,555 555,825 825,1065
that right way is the

1722
00:42:56,675 --> 00:42:57,480
0,275
art.|
|

1723
00:42:57,480 --> 00:42:59,000
0,225 225,435 435,630 630,810 810,1520
Of coming up with breakthroughs.|
取得突破性进展。|

1724
00:42:59,500 --> 00:43:00,505
0,240 240,465 465,630 630,795 795,1005
So this is what we
这就是我们要做的。

1725
00:43:00,505 --> 00:43:01,580
0,335
do.|
|

1726
00:43:02,040 --> 00:43:03,170
0,275 275,515 515,725 725,920 920,1130
The problem we ran into
我们遇到的问题是解锁允许另一个事务进入，该事务遵循两阶段锁定并开始看到不好的东西。但是现在如果你做这个严格的，强烈的，严格的两个阶段的锁定，你说爬山，它一直是一个高原，然后最后同时放下所有的锁。

1727
00:43:03,170 --> 00:43:05,075
0,240 240,765 765,975 975,1280 1540,1905
is unlock of a allowed

1728
00:43:05,075 --> 00:43:06,230
0,210 210,375 375,695 775,1020 1020,1155
the other transaction to come

1729
00:43:06,230 --> 00:43:07,295
0,195 195,345 345,465 465,740 790,1065
in who was following two

1730
00:43:07,295 --> 00:43:08,690
0,210 210,750 750,1020 1020,1230 1230,1395
phase locking and start to

1731
00:43:08,690 --> 00:43:10,250
0,165 165,420 420,770 1120,1410 1410,1560
see bad stuff. {But,now -}

1732
00:43:10,250 --> 00:43:11,320
0,135 135,285 285,450 450,705 705,1070
if you do this strict,

1733
00:43:11,340 --> 00:43:12,875
0,365 365,635 635,815 815,1010 1010,1535
strong, strict two phase locking

1734
00:43:12,875 --> 00:43:13,940
0,270 270,465 465,690 690,855 855,1065
you say climb the mountain,

1735
00:43:13,940 --> 00:43:15,560
0,315 315,560 640,1185 1185,1440 1440,1620
it's a plateau all the

1736
00:43:15,560 --> 00:43:16,625
0,165 165,470 490,780 780,930 930,1065
way through and then in

1737
00:43:16,625 --> 00:43:17,735
0,120 120,365 475,780 780,975 975,1110
the end drop all the

1738
00:43:17,735 --> 00:43:19,420
0,300 300,1325
locks simultaneously.|
|

1739
00:43:19,760 --> 00:43:20,830
0,275 275,410 410,515 515,680 680,1070
And just a little tidbit,
显然，你不会同时放下所有的锁，而是一次只放下一个锁。正在对哈希表执行多个操作。所以这是一个小语义学。但是，即使这需要一点时间，您也可以在那个悬崖上提交事务。因为我们将讨论耐用性。您将写入提交日志，然后就可以开始删除了。

1740
00:43:20,830 --> 00:43:21,940
0,270 270,510 510,735 735,915 915,1110
obviously, you won't drop all

1741
00:43:21,940 --> 00:43:24,240
0,150 150,435 435,1520 1630,2055 2055,2300
the locks simultaneously, it'll be

1742
00:43:24,260 --> 00:43:25,225
0,320 320,545 545,725 725,860 860,965
get dropped one at a

1743
00:43:25,225 --> 00:43:26,605
0,180 180,515 625,975 975,1170 1170,1380
time. {Multiple,operations -} are happening

1744
00:43:26,605 --> 00:43:27,940
0,210 210,315 315,570 570,845 1105,1335
to the hash {table.,So -}

1745
00:43:27,940 --> 00:43:28,540
0,150 150,210 210,330 330,465 465,600
it's a little bit {of,semantics.

1746
00:43:28,540 --> 00:43:30,400
0,710 880,1260 1260,1575 1575,1755 1755,1860
-} But even though it

1747
00:43:30,400 --> 00:43:31,165
0,165 165,315 315,465 465,630 630,765
takes a little bit of

1748
00:43:31,165 --> 00:43:32,335
0,270 270,540 540,780 780,1020 1020,1170
time, you can commit the

1749
00:43:32,335 --> 00:43:33,730
0,275 355,630 630,840 840,1140 1140,1395
transaction {at,that -} cliff. As

1750
00:43:33,730 --> 00:43:35,065
0,195 195,345 345,540 540,1020 1020,1335
{we'll,talk -} about durability. You'll

1751
00:43:35,065 --> 00:43:36,250
0,120 120,345 345,585 585,875 895,1185
write that commit log and

1752
00:43:36,250 --> 00:43:37,120
0,180 180,330 330,480 480,675 675,870
then you can start to

1753
00:43:37,120 --> 00:43:37,780
0,290
drop.|
|

1754
00:43:37,900 --> 00:43:39,810
0,400 870,1280 1280,1445 1445,1700 1700,1910
So there's this different type
所以有一种不同类型的机制来使那个峰看起来像一个峰，就像那个锋利的边缘看起来像一个边。但暂时忽略这一点。

1755
00:43:39,810 --> 00:43:40,920
0,120 120,380 460,735 735,915 915,1110
of mechanism to make that

1756
00:43:40,920 --> 00:43:41,850
0,225 225,450 450,615 615,750 750,930
peak look like a peak,

1757
00:43:41,850 --> 00:43:43,170
0,255 255,510 510,795 795,1095 1095,1320
like that sharp edge look

1758
00:43:43,170 --> 00:43:44,445
0,150 150,285 285,560 670,1020 1020,1275
like an edge. {But,ignore -}

1759
00:43:44,445 --> 00:43:45,540
0,195 195,360 360,635
that for now.|
|

1760
00:43:46,700 --> 00:43:47,740
0,380 380,575 575,770 770,890 890,1040
Obviously, if you've got a
显然，如果你有十亿个石头，你不可能瞬间对哈希表进行十亿次操作，对吗？这需要一些时间，需要一些CPU时间才能实现。

1761
00:43:47,740 --> 00:43:49,270
0,225 225,590 940,1215 1215,1425 1425,1530
billion rocks, you can't make

1762
00:43:49,270 --> 00:43:50,275
0,120 120,375 375,705 705,900 900,1005
a billion operations to the

1763
00:43:50,275 --> 00:43:51,865
0,180 180,360 360,675 675,1470 1470,1590
hash table and instantaneously, right?

1764
00:43:51,865 --> 00:43:53,110
0,240 240,360 360,510 510,785 955,1245
It'll take some time, take

1765
00:43:53,110 --> 00:43:54,325
0,165 165,555 555,825 825,1080 1080,1215
some cpu time to make

1766
00:43:54,325 --> 00:43:55,240
0,150 150,425
that happen.|
|

1767
00:43:56,670 --> 00:43:58,055
0,275 275,485 485,800 800,1025 1025,1385
But now, hopefully, this intuition
但现在，希望这种直觉在这方面是有意义的。在您绘制的依赖关系图中，无论谁到达锁定点，都在前面，在提交或中止事务之前，没有人能看到事务所做的更改。因此，不会传递任何脏读操作，并且后面的中止不会导致您解开其状态可能已经确定的事务。

1768
00:43:58,055 --> 00:43:59,615
0,225 225,435 435,675 675,995 1195,1560
makes sense this way. {Whoever,reaches

1769
00:43:59,615 --> 00:44:00,830
0,375 375,495 495,660 660,915 915,1215
-} the lock point is

1770
00:44:00,830 --> 00:44:02,975
0,345 345,645 645,950 1300,1935 1935,2145
ahead in the dependency graph

1771
00:44:02,975 --> 00:44:04,805
0,210 210,360 360,635 835,1235 1525,1830
that you draw, and no

1772
00:44:04,805 --> 00:44:06,500
0,180 180,345 345,635 985,1385 1405,1695
one can see changes made

1773
00:44:06,500 --> 00:44:07,550
0,135 135,240 240,500 550,810 810,1050
by a transaction till it's

1774
00:44:07,550 --> 00:44:09,590
0,290 550,840 840,1250 1540,1830 1830,2040
committed or {aborted.,So -} no

1775
00:44:09,590 --> 00:44:11,180
0,300 300,705 705,840 840,1130 1300,1590
dirty reads will get ah

1776
00:44:11,180 --> 00:44:12,545
0,285 285,680 760,1050 1050,1185 1185,1365
passed across, and the later

1777
00:44:12,545 --> 00:44:13,670
0,330 330,645 645,840 840,1005 1005,1125
abort doesn't cause you to

1778
00:44:13,670 --> 00:44:15,485
0,435 435,600 600,860 1300,1605 1605,1815
unwind a transaction whose state

1779
00:44:15,485 --> 00:44:16,870
0,165 165,425 535,825 825,1050 1050,1385
might have already been determined.|
|

1780
00:44:18,950 --> 00:44:20,180
0,400
Questions.|
问题。|

1781
00:44:22,380 --> 00:44:24,040
0,275 275,440 440,905 905,1210
Instead of forcing the.|
而不是强迫。|

1782
00:44:31,420 --> 00:44:33,750
0,350 550,950 1000,1400 1720,2025 2025,2330
Also thought to commit first.|
也想过要先承诺。|

1783
00:44:35,350 --> 00:44:36,600
0,350 350,545 545,650 650,910 930,1250
Yeah, so if I understand
是的，如果我没理解错的话，那是第一个到达锁定点的交易吗？

1784
00:44:36,600 --> 00:44:37,950
0,210 210,500 520,885 885,1140 1140,1350
your question correctly, is that

1785
00:44:37,950 --> 00:44:39,315
0,210 210,500 610,900 900,1215 1215,1365
the transaction that reaches the

1786
00:44:39,315 --> 00:44:41,020
0,210 210,495 495,845
lock point first?|
|

1787
00:44:41,020 --> 00:44:41,905
0,135 135,270 270,405 405,630 630,885
Can you make it commit
你能让它先承诺吗？

1788
00:44:41,905 --> 00:44:43,040
0,305
first?|
|

1789
00:44:43,040 --> 00:44:44,160
0,290
Uh.|
呃。|

1790
00:44:44,160 --> 00:44:46,140
0,320 490,890 1060,1460 1480,1785 1785,1980
Why so? It depends upon
为何如此？这取决于为什么是高原。平台期是因为我已经锁定了我所有的数据，所有我需要的数据。现在我正在处理数据，就像计算聚合和计算、连接或类似的东西。所以这里的时间仍然会被用来做我想要做的查询工作。

1791
00:44:46,140 --> 00:44:46,995
0,150 150,270 270,390 390,705 705,855
why is the plateau. {The,plateau

1792
00:44:46,995 --> 00:44:48,450
0,300 300,480 480,735 735,1140 1140,1455
-} is because I've gotten

1793
00:44:48,450 --> 00:44:50,310
0,300 300,525 525,830 1300,1635 1635,1860
all my data locked, all

1794
00:44:50,310 --> 00:44:51,060
0,135 135,285 285,465 465,615 615,750
the data I {need.,Now,I'm -

1795
00:44:51,060 --> 00:44:52,290
0,180 180,440 520,780 780,960 960,1230
-} processing the data, like

1796
00:44:52,290 --> 00:44:53,910
0,315 315,420 420,960 960,1275 1275,1620
computing an aggregate and a

1797
00:44:53,910 --> 00:44:55,035
0,345 345,450 450,660 660,885 885,1125
computing, a join or something

1798
00:44:55,035 --> 00:44:57,015
0,270 270,575 775,1175 1345,1680 1680,1980
{like,that. -} So that time

1799
00:44:57,015 --> 00:44:57,945
0,270 270,465 465,630 630,795 795,930
here is still going to

1800
00:44:57,945 --> 00:44:58,785
0,90 90,300 300,525 525,690 690,840
be taken for doing the

1801
00:44:58,785 --> 00:44:59,475
0,150 150,315 315,420 420,555 555,690
work that I want to

1802
00:44:59,475 --> 00:45:00,700
0,120 120,255 255,360 360,665
do for the query.|
|

1803
00:45:00,700 --> 00:45:01,585
0,90 90,180 180,420 420,645 645,885
So I can just drop
所以我可以直接把它放在这里。我必须等到所有的工作都做完了。

1804
00:45:01,585 --> 00:45:02,350
0,225 225,435 435,585 585,675 675,765
it right there. {I,have -}

1805
00:45:02,350 --> 00:45:03,040
0,120 120,270 270,420 420,555 555,690
to wait till all of

1806
00:45:03,040 --> 00:45:04,320
0,135 135,285 285,450 450,740
that work is done.|
|

1807
00:45:04,820 --> 00:45:05,695
0,275 275,410 410,545 545,710 710,875
Does that make sense? Or
这说得通吗？或许我没听懂你的问题。

1808
00:45:05,695 --> 00:45:06,655
0,165 165,300 300,585 585,810 810,960
maybe I didn't understand your

1809
00:45:06,655 --> 00:45:07,660
0,275
question.|
|

1810
00:45:11,240 --> 00:45:12,720
0,365 365,650 650,860 860,1115 1115,1480
I thought your question is,
我以为你的问题是，为什么我们有一个平台期？为什么我们不能在锁点降落，对吗？

1811
00:45:12,860 --> 00:45:13,735
0,290 290,455 455,575 575,710 710,875
why do we have a

1812
00:45:13,735 --> 00:45:15,625
0,515 1045,1335 1335,1590 1590,1695 1695,1890
plateau? Why can't we just

1813
00:45:15,625 --> 00:45:16,620
0,225 225,390 390,525 525,690 690,995
drop at the lock point,

1814
00:45:16,700 --> 00:45:17,660
0,400
correct?|
|

1815
00:45:17,700 --> 00:45:19,835
0,400 510,910 1140,1430 1430,1895 1895,2135
Yeah, because the plateau is
是的，因为高原是那个街区的工作，我们读到的所有东西都可能正在完成。

1816
00:45:19,835 --> 00:45:20,765
0,195 195,345 345,525 525,735 735,930
where the work on that

1817
00:45:20,765 --> 00:45:22,925
0,305 595,900 900,1110 1110,1415 1825,2160
block, on all the things

1818
00:45:22,925 --> 00:45:23,735
0,195 195,300 300,405 405,585 585,810
that we have read is

1819
00:45:23,735 --> 00:45:25,240
0,300 300,615 615,935
probably getting done.|
|

1820
00:45:26,280 --> 00:45:27,290
0,350 350,605 605,770 770,890 890,1010
So could you have a
那么你能做一笔交易吗？平台期可能为零吗？在某些情况下，是的。

1821
00:45:27,290 --> 00:45:28,865
0,260 670,945 945,1095 1095,1425 1425,1575
transaction? Could the plateau be

1822
00:45:28,865 --> 00:45:30,130
0,210 210,420 420,585 585,870 870,1265
zero? In some cases, yes.|
|

1823
00:45:30,860 --> 00:45:31,655
0,195 195,360 360,495 495,630 630,795
If all the work it
如果它需要的所有工作，例如，如果这是一个更新查询。

1824
00:45:31,655 --> 00:45:32,735
0,255 255,540 540,765 765,945 945,1080
needed, for example, if this

1825
00:45:32,735 --> 00:45:34,440
0,150 150,390 390,660 660,995
were an update query.|
|

1826
00:45:34,440 --> 00:45:35,655
0,150 150,300 300,510 510,860 880,1215
And the last thing that
当它到达锁定点时，最后一件事是它需要更新的最后一条记录，它会更新并删除它。高原将是非常小的。

1827
00:45:35,655 --> 00:45:36,465
0,210 210,360 360,510 510,645 645,810
when it reached the lock

1828
00:45:36,465 --> 00:45:37,380
0,210 210,390 390,510 510,675 675,915
point was the last record

1829
00:45:37,380 --> 00:45:38,745
0,195 195,390 390,675 675,1020 1020,1365
it needed to update it

1830
00:45:38,745 --> 00:45:39,900
0,330 330,585 585,840 840,975 975,1155
updates and drops it. {The,plateau

1831
00:45:39,900 --> 00:45:41,000
0,330 330,465 465,585 585,765 765,1100
-} will be very small.|
|

1832
00:45:44,510 --> 00:45:45,940
0,260 260,395 395,545 545,820
Does that make sense?|
这说得通吗？|

1833
00:45:46,500 --> 00:45:47,915
0,350 350,515 515,850 930,1235 1235,1415
It's also possible that, you
也有可能，你知道，我在这里拿了一把锁，然后我在拿锁之前发出了很长一段时间的滴答声。

1834
00:45:47,915 --> 00:45:48,950
0,240 240,495 495,675 675,840 840,1035
know, I grab a lock

1835
00:45:48,950 --> 00:45:50,330
0,320 430,720 720,855 855,1050 1050,1380
here and then I'm clattering

1836
00:45:50,330 --> 00:45:51,170
0,120 120,240 240,405 405,645 645,840
for a long time before

1837
00:45:51,170 --> 00:45:52,620
0,135 135,345 345,525 525,920
I grab the locks.|
|

1838
00:45:52,760 --> 00:45:53,875
0,275 275,425 425,605 605,875 875,1115
You know, I read a
你知道，我读了一张桌子，然后我要用它做一些工作。然后，我决定根据我读到的内容做一些其他的事情。所以，你知道，这不是高原和山峰。我们所知道的是，增长阶段只会出现问题。它是单调地增加平台，然后降低两个相位锁定。这是一个单调的递增。

1839
00:45:53,875 --> 00:45:55,060
0,275 505,765 765,945 945,1050 1050,1185
table, then I'm going to

1840
00:45:55,060 --> 00:45:55,870
0,150 150,330 330,510 510,675 675,810
do some work with it.

1841
00:45:55,870 --> 00:45:56,560
0,120 120,300 300,465 465,555 555,690
{Then,I,decide - -} I want

1842
00:45:56,560 --> 00:45:57,940
0,120 120,210 210,420 420,770 1000,1380
to do something else based

1843
00:45:57,940 --> 00:45:58,930
0,255 255,390 390,705 705,855 855,990
upon the contents of what

1844
00:45:58,930 --> 00:46:00,220
0,135 135,315 315,620 700,1080 1080,1290
I {read.,So -} it's not,

1845
00:46:00,220 --> 00:46:01,465
0,225 225,450 450,675 675,1065 1065,1245
you know, the plateaus {and,peaks.

1846
00:46:01,465 --> 00:46:02,440
0,300 300,555 555,720 720,840 840,975
-} All we have is

1847
00:46:02,440 --> 00:46:03,325
0,135 135,270 270,465 465,705 705,885
that the growing phase is

1848
00:46:03,325 --> 00:46:04,420
0,210 210,435 435,615 615,825 825,1095
only {going,up -} wrong. It's

1849
00:46:04,420 --> 00:46:06,775
0,765 765,1070 1480,1980 1980,2160 2160,2355
monotonically increasing plateau and then

1850
00:46:06,775 --> 00:46:08,620
0,305 720,915 915,1125 1125,1590 1590,1845
{drop,2 -} phase locking. It's

1851
00:46:08,620 --> 00:46:10,400
0,75 75,795 795,1100
a monotonically increasing.|
|

1852
00:46:10,400 --> 00:46:12,430
0,120 120,240 240,930 930,1460 1630,2030
And then monotonically decreasing curve.|
然后是单调递减曲线。|

1853
00:46:13,790 --> 00:46:14,725
0,260 260,380 380,500 500,800 800,935
They can be plateaus on
它们可能是两边的高原。

1854
00:46:14,725 --> 00:46:15,860
0,180 180,485
both sides.|
|

1855
00:46:20,430 --> 00:46:22,030
0,365 365,620 620,785 785,1090 1200,1600
Relieving losss and the other
减轻损失和其他联系可以。

1856
00:46:22,050 --> 00:46:22,840
0,395 395,740
connections can.|
|

1857
00:46:24,390 --> 00:46:25,820
0,320 320,515 515,695 695,965 965,1430
Yeah, but that causes cascading
是啊，但那会导致b的级联，对吧？这就是全部意义所在。如果是的话，那就先去吧，先去。

1858
00:46:25,820 --> 00:46:26,645
0,135 135,300 300,510 510,675 675,825
of b, right? That was

1859
00:46:26,645 --> 00:46:28,600
0,120 120,270 270,575 715,1115 1555,1955
the whole point. {If,,yeah, -}

1860
00:46:28,680 --> 00:46:31,540
0,260 260,410 410,700 1500,1900
go ahead first, first.|
|

1861
00:46:31,820 --> 00:46:33,335
0,135 135,285 285,560 640,1040 1090,1515
I think transaction who researched
我想交易是谁研究的？

1862
00:46:33,335 --> 00:46:34,040
0,120 120,395
at this?|
|

1863
00:46:34,390 --> 00:46:35,670
0,400 480,770 770,935 935,1085 1085,1280
Yeah, I see what you're
是的，我明白你的意思了。很好。非常--很好。-}所以你是说，哦，你知道吗？这并不是一个真正的问题。

1864
00:46:35,670 --> 00:46:37,010
0,230 280,600 600,825 825,1035 1035,1340
saying. {Very,good. {-},Very {-},good. -}

1865
00:46:37,030 --> 00:46:38,250
0,275 275,410 410,545 545,820 840,1220
So you are saying, oh,

1866
00:46:38,250 --> 00:46:39,615
0,255 255,390 390,650 790,1065 1065,1365
you know what? There wasn't

1867
00:46:39,615 --> 00:46:41,280
0,180 180,345 345,585 585,965
really a problem here.|
|

1868
00:46:41,350 --> 00:46:43,580
0,365 365,665 665,935 935,1270 1830,2230
What if you said, ah,
如果你说，啊，让这个人走呢？

1869
00:46:43,930 --> 00:46:45,620
0,335 335,545 545,725 725,1030
let this guy go?|
|

1870
00:46:45,630 --> 00:46:46,985
0,410 410,530 530,755 755,1085 1085,1355
Don't let it commit till
在结果出来之前，不要让它承诺。这正是一些协议所做的，比如微软黑客松服务器黑客松系统。我和微软内部的一群非常聪明的人一起做了这件事，他们会跟踪这些依赖的东西，然后不会让这个奖杯。啊，不会让这笔交易被两个，两个提交。

1871
00:46:46,985 --> 00:46:48,350
0,255 255,465 465,615 615,900 900,1365
the outcome is done. {That's,exactly

1872
00:46:48,350 --> 00:46:49,895
0,345 345,630 630,810 810,1335 1335,1545
-} what some protocols do,

1873
00:46:49,895 --> 00:46:52,685
0,210 210,485 535,1065 1065,1355 2185,2790
like Microsoft hackathon server hackathon

1874
00:46:52,685 --> 00:46:53,615
0,285 285,495 495,615 615,765 765,930
{system.,And,I - -} worked on

1875
00:46:53,615 --> 00:46:54,680
0,210 210,420 420,645 645,885 885,1065
that with a whole bunch

1876
00:46:54,680 --> 00:46:55,655
0,150 150,360 360,600 600,795 795,975
of really smart people at

1877
00:46:55,655 --> 00:46:57,710
0,275 925,1440 1440,1575 1575,1785 1785,2055
Microsoft internally will keep track

1878
00:46:57,710 --> 00:46:59,345
0,195 195,420 420,770 790,1190 1330,1635
of this dependent stuff and

1879
00:46:59,345 --> 00:47:00,545
0,255 255,615 615,765 765,960 960,1200
then won't let {this,cup. -}

1880
00:47:00,545 --> 00:47:02,140
0,335 535,915 915,1065 1065,1275 1275,1595
Ah, won't let that transaction

1881
00:47:02,220 --> 00:47:03,600
0,275 275,425 425,635 635,970
t two, two commit.|
|

1882
00:47:03,670 --> 00:47:04,575
0,260 260,380 380,515 515,695 695,905
Because it has taken a
因为它已经依赖了一些交易。所以，即使你在这里说提交，它也会说不，我必须抓住你，因为你读到了其他东西。在放你走之前我需要知道这一点。

1883
00:47:04,575 --> 00:47:05,850
0,455 625,900 900,1035 1035,1155 1155,1275
dependence on some of the

1884
00:47:05,850 --> 00:47:07,185
0,260 640,885 885,1035 1035,1200 1200,1335
transaction. {So,even -} if you

1885
00:47:07,185 --> 00:47:08,580
0,210 210,510 510,875 925,1290 1290,1395
say commit here, it'll say

1886
00:47:08,580 --> 00:47:09,315
0,135 135,285 285,450 450,600 600,735
no, no, no, I got

1887
00:47:09,315 --> 00:47:10,440
0,120 120,285 285,605 685,945 945,1125
to hold you because you've

1888
00:47:10,440 --> 00:47:11,265
0,120 120,345 345,555 555,690 690,825
read something {else.,I -} need

1889
00:47:11,265 --> 00:47:12,045
0,120 120,240 240,465 465,675 675,780
to know that before I

1890
00:47:12,045 --> 00:47:13,020
0,120 120,255 255,515
let you go.|
|

1891
00:47:13,750 --> 00:47:15,285
0,400 690,980 980,1130 1130,1310 1310,1535
Absolutely. {So,the -} more advanced
绝对一点儿没错。所以更高级的协议会做这样的事情。所以这很好。你已经在设计下一代协议了，这很好。

1892
00:47:15,285 --> 00:47:16,500
0,495 495,645 645,825 825,1020 1020,1215
protocols will do stuff like

1893
00:47:16,500 --> 00:47:17,745
0,290 310,555 555,750 750,915 915,1245
{that.,So -} {that's,great. -} You're

1894
00:47:17,745 --> 00:47:19,485
0,240 240,660 660,1025 1105,1425 1425,1740
already designing the next generation

1895
00:47:19,485 --> 00:47:20,780
0,270 270,765 765,885 885,1020 1020,1295
of protocols, which is good.|
|

1896
00:47:23,160 --> 00:47:24,620
0,335 335,670
Other questions?|
还有其他问题吗？|

1897
00:47:31,260 --> 00:47:32,360
0,400
Yeah.|
嗯。|

1898
00:47:33,860 --> 00:47:35,035
0,365 365,590 590,710 710,890 890,1175
Yeah, so the question is,
是的，所以问题是，我按住锁的时间越长，我不是在减少并行性吗？绝对一点儿没错。这就是为什么会有更多的锁定模式。

1899
00:47:35,035 --> 00:47:36,010
0,225 225,450 450,675 675,825 825,975
the longer I hold the

1900
00:47:36,010 --> 00:47:37,330
0,260 280,570 570,735 735,990 990,1320
lock, am I not reducing

1901
00:47:37,330 --> 00:47:39,385
0,255 255,885 885,1160 1570,1935 1935,2055
the parallelism? Absolutely. {That's,why -}

1902
00:47:39,385 --> 00:47:40,760
0,165 165,375 375,845
more lock modes.|
|

1903
00:47:41,170 --> 00:47:42,210
0,275 275,425 425,605 605,770 770,1040
They will hold the locks
他们将持有锁，但较弱的锁，以便其他锁可以进入，所以等待，我们今天可能不会到达它，但这是好的。

1904
00:47:42,210 --> 00:47:43,320
0,165 165,525 525,810 810,930 930,1110
but weaker locks so other

1905
00:47:43,320 --> 00:47:44,595
0,300 300,450 450,615 615,890 1000,1275
locks can get in, so

1906
00:47:44,595 --> 00:47:46,020
0,180 180,345 345,605 925,1245 1245,1425
wait for that and we

1907
00:47:46,020 --> 00:47:46,815
0,135 135,285 285,465 465,615 615,795
may not get to it

1908
00:47:46,815 --> 00:47:48,280
0,225 225,375 375,660 660,965
today, but that's okay.|
|

1909
00:47:48,570 --> 00:47:49,640
0,90 90,240 240,375 375,620
We'll get to it.|
我们会找到它的。|

1910
00:47:50,140 --> 00:47:52,260
0,305 305,610 810,1210 1590,1985 1985,2120
All right, so let's keep
好了，我们继续前进吧。希望这对每个人都有意义。

1911
00:47:52,260 --> 00:47:53,970
0,290 550,950 970,1260 1260,1455 1455,1710
moving. {Hopefully,,this -} makes sense

1912
00:47:53,970 --> 00:47:55,280
0,315 315,680
to everyone.|
|

1913
00:47:55,280 --> 00:47:57,485
0,260 760,1160 1480,1800 1800,1995 1995,2205
And, ah, ah, we now
而且，啊，啊，我们现在有了一个有效的解决方案，让我们摆脱了这场层出不穷的波。

1914
00:47:57,485 --> 00:47:59,500
0,240 240,480 480,815 1375,1695 1695,2015
have a solution that works

1915
00:47:59,760 --> 00:48:01,025
0,335 335,560 560,725 725,980 980,1265
and gets us out of

1916
00:48:01,025 --> 00:48:03,260
0,305 565,1200 1200,1565
this cascading Bo.|
|

1917
00:48:03,420 --> 00:48:04,880
0,260 260,410 410,700 930,1325 1325,1460
All right, so let's take
好的，让我们快速地看一下这个例子，以确保所有的东西都是固定的。我想每个人都是基于这场讨论才明白的。但只要给你一点时间来消化这一点。考虑两个交易。他告诉我他有一个赌注经纪人。

1918
00:48:04,880 --> 00:48:06,740
0,290 550,840 840,1130 1180,1530 1530,1860
a look at this example

1919
00:48:06,740 --> 00:48:08,105
0,345 345,710 820,1110 1110,1245 1245,1365
really quickly, just to make

1920
00:48:08,105 --> 00:48:09,410
0,270 270,510 510,630 630,1140 1140,1305
sure everything is solidified. {I,think

1921
00:48:09,410 --> 00:48:10,340
0,225 225,465 465,615 615,765 765,930
-} everyone got it based

1922
00:48:10,340 --> 00:48:11,870
0,165 165,405 405,765 765,1160 1240,1530
on this {discussion.,But -} just

1923
00:48:11,870 --> 00:48:12,455
0,150 150,240 240,315 315,450 450,585
give you a little bit

1924
00:48:12,455 --> 00:48:13,460
0,120 120,300 300,465 465,780 780,1005
of time to digest {this,too.

1925
00:48:13,460 --> 00:48:15,620
0,320 730,1065 1065,1305 1305,1610 1870,2160
-} Consider two transactions. T

1926
00:48:15,620 --> 00:48:17,180
0,150 150,300 300,480 1060,1380 1380,1560
1 t 2 he tells

1927
00:48:17,180 --> 00:48:17,870
0,180 180,360 360,465 465,570 570,690
me he has a bookie.

1928
00:48:17,870 --> 00:48:18,680
0,380
|
|

1929
00:48:18,680 --> 00:48:20,135
0,195 195,420 420,720 720,1230 1230,1455
So he keeps transferring money
因此，他不断地将资金从他的账户转移到他的博彩公司账户，然后需要计算这两个账户的总和。这就是这两笔交易。

1930
00:48:20,135 --> 00:48:21,500
0,365 535,870 870,1110 1110,1260 1260,1365
from his account to his

1931
00:48:21,500 --> 00:48:23,720
0,345 345,680 940,1245 1245,1550 1930,2220
bookies account and then need

1932
00:48:23,720 --> 00:48:25,100
0,225 225,420 420,555 555,1010 1060,1380
to go and compute the

1933
00:48:25,100 --> 00:48:26,480
0,315 315,645 645,885 885,1125 1125,1380
total across both those accounts.

1934
00:48:26,480 --> 00:48:27,185
0,180 180,315 315,450 450,570 570,705
{So,those -} are the two

1935
00:48:27,185 --> 00:48:28,460
0,275
transactions.|
|

1936
00:48:28,650 --> 00:48:30,070
0,290 290,530 530,755 755,1025 1025,1420
A non two pl example
这是一个不是两个pl的例子，这是为了确保我们都在同一页上，这就是锁，然后你就会进入这样的情况，你现在得到的值是不正确的，我想每个人都知道，这是可能发生的坏事。

1937
00:48:30,540 --> 00:48:31,595
0,275 275,440 440,665 665,905 905,1055
and this is again to

1938
00:48:31,595 --> 00:48:32,645
0,135 135,425 445,795 795,900 900,1050
make sure we're all on

1939
00:48:32,645 --> 00:48:33,995
0,120 120,285 285,605 715,1110 1110,1350
the same page you'll acquire,

1940
00:48:34,235 --> 00:48:35,870
0,285 285,665 895,1215 1215,1410 1410,1635
that's lock and then you'll

1941
00:48:35,870 --> 00:48:38,075
0,260 400,800 850,1250 1330,1730 1930,2205
get into the situation where

1942
00:48:38,075 --> 00:48:39,125
0,135 135,300 300,525 525,795 795,1050
you end up with an

1943
00:48:39,125 --> 00:48:40,685
0,525 525,815 865,1155 1155,1335 1335,1560
incorrect value right by now,

1944
00:48:40,685 --> 00:48:42,010
0,195 195,450 450,750 750,990 990,1325
I think everyone gets that,

1945
00:48:42,180 --> 00:48:43,565
0,380 380,890 890,1100 1100,1235 1235,1385
that that's the type of

1946
00:48:43,565 --> 00:48:44,590
0,210 210,435 435,600 600,750 750,1025
bad stuff that can happen.|
|

1947
00:48:45,180 --> 00:48:46,665
0,240 240,480 480,1070 1090,1365 1365,1485
Two, phase locking. {If,we -}
二，锁相。如果我们最终这样做了，我们将使用锁，然后移动东西，这样我们就得到了正确的状态。对吗？仍然无法避免我们刚刚谈到的级联，但你现在可以了。你可以把这个东西放进独立图，然后自己做，你会发现我们打破了那个循环。我们没有让循环走得太远。

1948
00:48:46,665 --> 00:48:48,350
0,120 120,300 300,525 525,845 1015,1685
end up doing that, we'll

1949
00:48:48,580 --> 00:48:50,085
0,335 335,545 545,1025 1025,1325 1325,1505
use the locks and then

1950
00:48:50,085 --> 00:48:51,555
0,165 165,420 420,785 925,1215 1215,1470
move things around so that

1951
00:48:51,555 --> 00:48:52,770
0,240 240,435 435,735 735,1005 1005,1215
we end up with the

1952
00:48:52,770 --> 00:48:54,375
0,240 240,525 525,890 970,1275 1275,1605
correct {state.,Right?,Still - -} doesn't

1953
00:48:54,375 --> 00:48:55,740
0,195 195,645 645,960 960,1215 1215,1365
avoid cascading about which we

1954
00:48:55,740 --> 00:48:57,090
0,165 165,420 420,770 970,1230 1230,1350
just talked about, but you

1955
00:48:57,090 --> 00:48:58,080
0,135 135,410 430,690 690,825 825,990
{can,now. -} You can take

1956
00:48:58,080 --> 00:48:59,355
0,210 210,450 450,645 645,900 900,1275
this thing, put in independence

1957
00:48:59,355 --> 00:49:01,005
0,395 565,930 930,1170 1170,1380 1380,1650
graph and do that by

1958
00:49:01,005 --> 00:49:02,340
0,240 240,435 435,725 805,1110 1110,1335
yourself and see that we

1959
00:49:02,340 --> 00:49:03,465
0,240 240,450 450,705 705,930 930,1125
{broke,that -} cycle. We didn't

1960
00:49:03,465 --> 00:49:04,520
0,120 120,270 270,510 510,765 765,1055
let the cycle get far.|
|

1961
00:49:06,200 --> 00:49:08,010
0,290 290,575 575,920 920,1270 1410,1810
All right, and strict, strong,
好的，严格的，强的，严格的，两相锁定，在这种情况下，基本上需要a和b都保持到最后。

1962
00:49:08,030 --> 00:49:09,490
0,290 290,470 470,680 680,1205 1205,1460
strict, two phase locking in

1963
00:49:09,490 --> 00:49:11,845
0,210 210,530 610,915 915,1220 1990,2355
this case would basically require

1964
00:49:11,845 --> 00:49:13,120
0,255 255,450 450,645 645,930 930,1275
that a and b both

1965
00:49:13,120 --> 00:49:14,820
0,240 240,530 940,1260 1260,1440 1440,1700
be held till the end.|
|

1966
00:49:15,680 --> 00:49:18,360
0,400 870,1175 1175,1480 1530,1930
And you basically are.|
而你基本上就是。|

1967
00:49:19,050 --> 00:49:20,405
0,400 480,815 815,1025 1025,1160 1160,1355
Effectively running t one after
有效地在t 1和t 2之后运行t，对吗？在这种情况下，没有任何相似之处。

1968
00:49:20,405 --> 00:49:21,440
0,240 240,480 480,705 705,945 945,1035
t two, right? There's no

1969
00:49:21,440 --> 00:49:23,080
0,465 465,740 880,1170 1170,1350 1350,1640
parallelism there in this case.|
|

1970
00:49:26,320 --> 00:49:27,400
0,290 290,580
All right.|
好的。|

1971
00:49:27,400 --> 00:49:28,890
0,350 550,870 870,1080 1080,1230 1230,1490
So going back to this.|
所以回到这个问题上来。|

1972
00:49:29,880 --> 00:49:32,195
0,575 575,1090 1290,1690 1830,2105 2105,2315
Serial schedules, right? A bigger
连续的时间表，对吧？其中一个更大的子集。我们这样做是因为你想要允许更多的东西，使用数据库，使它更有效率。

1973
00:49:32,195 --> 00:49:33,530
0,390 390,525 525,785 1015,1245 1245,1335
subset of that. {We,are -}

1974
00:49:33,530 --> 00:49:34,340
0,150 150,375 375,570 570,675 675,810
doing that because you want

1975
00:49:34,340 --> 00:49:35,540
0,165 165,345 345,570 570,890 910,1200
to allow more stuff, use

1976
00:49:35,540 --> 00:49:36,530
0,150 150,410 430,690 690,810 810,990
the database, make it more

1977
00:49:36,530 --> 00:49:37,580
0,320
efficient.|
|

1978
00:49:38,220 --> 00:49:40,775
0,305 305,1010 1010,1780 1860,2260 2280,2555
New serializable theoretical. {But,,you -}
新的可序列化理论。但你知道，很高兴知道它能做什么。层叠机器人的图片是这样的。它越过了这一点。

1979
00:49:40,775 --> 00:49:41,435
0,135 135,285 285,420 420,540 540,660
know, good to know what

1980
00:49:41,435 --> 00:49:43,295
0,120 120,395 685,1365 1365,1590 1590,1860
it {does.,Cascadinging -} bot picture

1981
00:49:43,295 --> 00:49:45,035
0,315 315,540 540,845 1135,1440 1440,1740
looks {like,this. -} It cuts

1982
00:49:45,035 --> 00:49:46,320
0,330 330,665
across that.|
|

1983
00:49:46,320 --> 00:49:48,090
0,180 180,405 405,660 660,980 1000,1770
There are some complex serializable
有一些复杂的可序列化调度。

1984
00:49:48,090 --> 00:49:49,360
0,290
schedule.|
|

1985
00:49:49,360 --> 00:49:51,115
0,380 460,750 750,1020 1020,1395 1395,1755
That it will remove from
它将被排除在考虑之外，但使其更安全，这样你就不会出现层叠董事会的情况。所以我们对这个空间进行了更多的限制。

1986
00:49:51,115 --> 00:49:53,140
0,365 1015,1320 1320,1500 1500,1665 1665,2025
consideration, but make it safer

1987
00:49:53,140 --> 00:49:53,830
0,150 150,285 285,405 405,585 585,690
so that you don't have

1988
00:49:53,830 --> 00:49:54,940
0,120 120,540 540,780 780,960 960,1110
the cascading board case. {So,we've

1989
00:49:54,940 --> 00:49:56,545
0,345 345,810 810,1100 1120,1440 1440,1605
-} restricted that space a

1990
00:49:56,545 --> 00:49:57,640
0,150 150,345 345,635
little bit more.|
|

1991
00:49:58,740 --> 00:50:00,560
0,400 450,710 710,1040 1040,1330 1530,1820
Obviously, a serial schedule is
显然，连续的时间表不会有这样的结果，因为你在去之前就知道结果了。所以它被覆盖在那些东西下面。但当我们开始进行严格的两阶段锁定时，我们说我们的并行性会减少一点，但我们这样做是因为我们想避免这些级联Bo。

1992
00:50:00,560 --> 00:50:01,280
0,165 165,315 315,435 435,540 540,720
not going to have that

1993
00:50:01,280 --> 00:50:02,165
0,180 180,300 300,435 435,630 630,885
because you know the outcome

1994
00:50:02,165 --> 00:50:03,305
0,195 195,300 300,525 525,780 780,1140
before you go. {So,it's -}

1995
00:50:03,305 --> 00:50:05,020
0,345 345,615 615,870 870,1205 1315,1715
covered under that {stuff.,But -}

1996
00:50:05,040 --> 00:50:06,080
0,290 290,470 470,680 680,860 860,1040
when we start to do

1997
00:50:06,080 --> 00:50:07,265
0,210 210,375 375,570 570,975 975,1185
strict two phase locking, we're

1998
00:50:07,265 --> 00:50:08,420
0,245 595,900 900,975 975,1065 1065,1155
saying we're going to have

1999
00:50:08,420 --> 00:50:10,115
0,105 105,270 270,480 480,1190 1420,1695
a little less parallelism, but

2000
00:50:10,115 --> 00:50:11,045
0,180 180,315 315,570 570,810 810,930
we're doing that because we

2001
00:50:11,045 --> 00:50:12,140
0,135 135,315 315,495 495,660 660,1095
want to avoid these cascading

2002
00:50:12,140 --> 00:50:13,040
0,350
Bo.|
|

2003
00:50:16,340 --> 00:50:17,360
0,400
Right.|
正确的。|

2004
00:50:17,590 --> 00:50:19,100
0,350 350,560 560,820
Questions on this?|
对此有疑问吗？|

2005
00:50:21,480 --> 00:50:23,680
0,335 335,670 990,1390
Alright, so now?|
好的，那现在呢？|

2006
00:50:23,680 --> 00:50:25,465
0,470 910,1200 1200,1380 1380,1605 1605,1785
Let's just make sure we
我们只要确保我们都准备好了就行了。我们谈到了强的、严格的两阶段锁定，就像你们中的许多人已经问过的那样，事务t1和t2以不同的顺序跟踪两个对象a和b的情况会怎样？

2007
00:50:25,465 --> 00:50:27,235
0,245 445,780 780,1115 1285,1560 1560,1770
have everything together. {We,talked -}

2008
00:50:27,235 --> 00:50:28,600
0,300 300,600 600,915 915,1200 1200,1365
about the strong, strict two

2009
00:50:28,600 --> 00:50:30,205
0,195 195,740 940,1245 1245,1440 1440,1605
phase locking, as many of

2010
00:50:30,205 --> 00:50:32,305
0,105 105,270 270,495 495,785 1795,2100
you have already asked, what

2011
00:50:32,305 --> 00:50:34,950
0,305 535,935 1045,1445 1465,1865 2245,2645
about that situations where transactions

2012
00:50:35,060 --> 00:50:36,160
0,275 410,545 545,695 695,905 905,1100
t 1 t two go

2013
00:50:36,160 --> 00:50:37,225
0,210 210,420 420,660 660,915 915,1065
after two objects a and

2014
00:50:37,225 --> 00:50:38,100
0,120 120,225 225,330 330,525 525,875
b in a different order?|
|

2015
00:50:38,760 --> 00:50:40,580
0,270 270,590 790,1110 1110,1425 1425,1820
That's exactly the example here.
这就是这里的例子。A锁定交易。一次锁定一笔交易，两次锁定b。

2016
00:50:40,990 --> 00:50:43,365
0,400 690,1300 1500,1790 1790,2080 2100,2375
{A,locks -} the {transaction.,T -}

2017
00:50:43,365 --> 00:50:45,075
0,150 150,405 405,665 985,1385 1435,1710
one locks a transaction t

2018
00:50:45,075 --> 00:50:46,340
0,135 135,375 375,635
two locks b.|
|

2019
00:50:47,130 --> 00:50:48,795
0,290 310,615 615,920 1000,1395 1395,1665
T 1 then asked for
然后T1要求一个。

2020
00:50:48,795 --> 00:50:49,780
0,275
a.|
|

2021
00:50:49,780 --> 00:50:51,085
0,180 180,450 450,720 720,1035 1035,1305
Lock manager says, whoa, I
锁管理器说，哇，我需要把你放到挂起的队列中，你需要等待。T两个人后来回来说我需要B。

2022
00:50:51,085 --> 00:50:51,685
0,150 150,270 270,390 390,495 495,600
need to put you on

2023
00:50:51,685 --> 00:50:52,675
0,120 120,420 420,690 690,855 855,990
the pending queue, you need

2024
00:50:52,675 --> 00:50:54,145
0,120 120,365 805,1095 1095,1260 1260,1470
to wait. {T,two -} later

2025
00:50:54,145 --> 00:50:55,060
0,225 225,375 375,525 525,720 720,915
comes back and says I

2026
00:50:55,060 --> 00:50:56,340
0,225 225,560
need b.|
|

2027
00:50:56,940 --> 00:50:59,020
0,290 290,470 470,860 860,1210 1680,2080
T two can't get a
T2得不到a，因为t2t1有，反之亦然。所以这是一个僵局。不会有任何进展。我们遵循严格的两相锁定。我们仍然可以让自己陷入这场麻烦。

2028
00:50:59,070 --> 00:51:00,290
0,350 350,605 605,830 830,1040 1040,1220
because t two t one

2029
00:51:00,290 --> 00:51:01,630
0,210 210,405 405,555 555,780 780,1340
has it and vice versa.

2030
00:51:01,710 --> 00:51:03,190
0,290 290,455 455,605 605,875 875,1480
{So,this -} is a {deadlock.,No

2031
00:51:03,510 --> 00:51:04,490
0,305 305,545 545,740 740,875 875,980
-} progress is going to

2032
00:51:04,490 --> 00:51:05,660
0,75 75,320 370,645 645,900 900,1170
{be,made. -} We follow strict

2033
00:51:05,660 --> 00:51:06,950
0,165 165,375 375,900 900,1140 1140,1290
{two,phase -} locking. We can

2034
00:51:06,950 --> 00:51:08,000
0,180 180,405 405,690 690,900 900,1050
still get ourselves into this

2035
00:51:08,000 --> 00:51:08,840
0,290
trouble.|
|

2036
00:51:10,340 --> 00:51:11,065
0,275 275,395 395,515 515,635 635,725
So we need to get
因此，我们需要摆脱这种情况，为此，有一些机制可以找到死锁。因此，这种情况被称为僵局。

2037
00:51:11,065 --> 00:51:12,145
0,120 120,285 285,575 625,915 915,1080
out of this and for

2038
00:51:12,145 --> 00:51:13,680
0,275 355,615 615,735 735,870 870,1535
that there are these mechanisms

2039
00:51:14,450 --> 00:51:16,120
0,400 420,800 800,1340 1340,1460 1460,1670
to find deadlocks. {So,that -}

2040
00:51:16,120 --> 00:51:17,430
0,270 270,495 495,690 690,840 840,1310
situation is called a deadlock.|
|

2041
00:51:18,420 --> 00:51:19,420
0,335 335,500 500,575 575,710 710,1000
And there are two ways.|
有两种方法。|

2042
00:51:20,180 --> 00:51:21,275
0,270 270,420 420,645 645,915 915,1095
That you can deal with
你可以处理好僵局。第一个称为死锁检测。您会定期运行一些后台线程。

2043
00:51:21,275 --> 00:51:22,970
0,495 495,645 645,870 870,1235 1375,1695
deadlocks. {The,first -} one is

2044
00:51:22,970 --> 00:51:25,385
0,225 225,645 645,1220 1450,2190 2190,2415
called deadlock {detection.,Periodically -} you'll

2045
00:51:25,385 --> 00:51:27,380
0,180 180,495 495,875 1015,1415
run some background thread.|
|

2046
00:51:27,380 --> 00:51:28,145
0,150 150,315 315,510 510,660 660,765
To go look through the
查看锁管理器并说，我看到的是死锁循环吗？我们稍后会讨论这个问题。如果是这样的话，我会终止其中一笔交易，打破这个循环。好的，这是一个死锁的循环，不同于依赖图的循环。

2047
00:51:28,145 --> 00:51:29,195
0,165 165,450 450,690 690,885 885,1050
lock manager and say, do

2048
00:51:29,195 --> 00:51:30,280
0,120 120,255 255,375 375,765 765,1085
I see a deadlock cycle?

2049
00:51:30,690 --> 00:51:31,610
0,335 335,485 485,665 665,800 800,920
We'll talk about that in

2050
00:51:31,610 --> 00:51:33,070
0,120 120,380 700,990 990,1170 1170,1460
a second. {And,if -} so,

2051
00:51:33,090 --> 00:51:33,890
0,320 320,425 425,530 530,650 650,800
I'm going to kill one

2052
00:51:33,890 --> 00:51:34,865
0,105 105,210 210,470 520,795 795,975
of the transactions and break

2053
00:51:34,865 --> 00:51:36,215
0,165 165,425 925,1185 1185,1275 1275,1350
the {cycle.,Okay, -} this is

2054
00:51:36,215 --> 00:51:37,820
0,105 105,315 315,555 555,1205 1255,1605
a cycle for deadlocks different

2055
00:51:37,820 --> 00:51:39,110
0,210 210,330 330,525 525,765 765,1290
than the cycle for dependency

2056
00:51:39,110 --> 00:51:40,380
0,290 460,860
graph, okay.|
|

2057
00:51:40,390 --> 00:51:42,375
0,335 335,620 620,1055 1055,1480 1710,1985
And then deadlock prevention, which
然后防止僵局，这在某种意义上说，认为它是悲观的。它会说，我会尽可能早地阻止你。

2058
00:51:42,375 --> 00:51:43,395
0,210 210,435 435,645 645,855 855,1020
is in some sense, think

2059
00:51:43,395 --> 00:51:44,475
0,135 135,255 255,390 390,540 540,1080
of it as being pessimistic.

2060
00:51:44,475 --> 00:51:45,090
0,165 165,255 255,360 360,450 450,615
{It's,going -} to say, I'm

2061
00:51:45,090 --> 00:51:46,290
0,105 105,240 240,405 405,710 910,1200
going to stop you as

2062
00:51:46,290 --> 00:51:47,760
0,240 240,465 465,740
early as possible.|
|

2063
00:51:47,830 --> 00:51:48,645
0,260 260,395 395,545 545,680 680,815
Okay, but now this is
好的，但这是针对死结的，对吧？不适用于依赖图之类的东西。

2064
00:51:48,645 --> 00:51:50,190
0,150 150,690 690,965 1105,1395 1395,1545
for deadlocks, right? Not for

2065
00:51:50,190 --> 00:51:51,920
0,165 165,540 540,810 810,1160
the dependence graph stuff.|
|

2066
00:51:51,930 --> 00:51:53,945
0,380 380,950 950,1100 1100,1390 1620,2015
Similar concepts, but different applications,
相似的概念，但不同的应用，不同的问题，我们正在努力解决。

2067
00:51:53,945 --> 00:51:55,130
0,390 390,765 765,1005 1005,1095 1095,1185
different problem that we are

2068
00:51:55,130 --> 00:51:56,280
0,150 150,300 300,560
trying to solve.|
|

2069
00:51:56,780 --> 00:51:58,255
0,400 450,770 770,1025 1025,1265 1265,1475
So we create these things
所以我们创造了这些东西，叫做图的权重。

2070
00:51:58,255 --> 00:52:00,000
0,225 225,435 435,705 705,1050 1050,1745
called the weight for graphs.|
|

2071
00:52:00,770 --> 00:52:02,395
0,320 320,560 560,815 815,1250 1250,1625
They look like dependence graphs,
它们看起来像依赖图，概念相似，但对于死锁，好吧。

2072
00:52:02,395 --> 00:52:04,560
0,275 295,695 895,1260 1260,1500 1500,2165
similar ideas, but for deadlocks,

2073
00:52:04,820 --> 00:52:05,740
0,400
okay.|
|

2074
00:52:06,780 --> 00:52:08,420
0,275 275,455 455,760 1080,1430 1430,1640
All right, so imagine I
好的，想象一下，我等待从已被锁定的锁管理器状态构建的图。

2075
00:52:08,420 --> 00:52:10,010
0,260 550,810 810,990 990,1200 1200,1590
have a wait for graphs

2076
00:52:10,010 --> 00:52:11,135
0,290 310,615 615,810 810,945 945,1125
that are going to be

2077
00:52:11,135 --> 00:52:12,250
0,360 360,510 510,645 645,810 810,1115
constructed from the lock manager

2078
00:52:12,480 --> 00:52:14,170
0,400 600,920 920,1235 1235,1385 1385,1690
state of what's been locked.|
|

2079
00:52:15,170 --> 00:52:16,015
0,275 275,425 425,575 575,710 710,845
Not in terms of the
不是在读写方面，这是依赖图的方面，所以它们是不同的。别把它们搞混了。

2080
00:52:16,015 --> 00:52:17,260
0,195 195,480 480,845 865,1125 1125,1245
read write stuff, which is

2081
00:52:17,260 --> 00:52:18,430
0,135 135,300 300,690 690,945 945,1170
what the dependence graph stuff,

2082
00:52:18,430 --> 00:52:19,720
0,150 150,345 345,590 820,1185 1185,1290
so they're different. {Don't,get -}

2083
00:52:19,720 --> 00:52:21,020
0,255 255,650
those confused.|
|

2084
00:52:22,860 --> 00:52:24,275
0,260 260,395 395,640 690,1090 1140,1415
But they also related, if
但他们也是相关的，如果你稍微考虑一下，他们可以进行单独的对话，但概念是不同的。这将从锁管理器构建。锁管理器知道哪个事务已被授予、哪个对象的哪种类型的锁以及谁在等待。

2085
00:52:24,275 --> 00:52:24,920
0,135 135,300 300,465 465,570 570,645
you think about it a

2086
00:52:24,920 --> 00:52:25,955
0,135 135,440 490,780 780,915 915,1035
little bit, and they can

2087
00:52:25,955 --> 00:52:27,395
0,135 135,270 270,510 510,875 1135,1440
have a separate conversation, but

2088
00:52:27,395 --> 00:52:28,805
0,165 165,645 645,810 810,1110 1110,1410
the concepts are different. {This,will

2089
00:52:28,805 --> 00:52:30,245
0,195 195,390 390,695 805,1125 1125,1440
-} get built from the

2090
00:52:30,245 --> 00:52:31,970
0,315 315,635 1075,1335 1335,1485 1485,1725
lock {manager.,The -} lock manager

2091
00:52:31,970 --> 00:52:33,650
0,350 610,915 915,1220 1240,1515 1515,1680
knows which transaction has been

2092
00:52:33,650 --> 00:52:35,285
0,290 730,1035 1035,1215 1215,1365 1365,1635
granted, which type of lock

2093
00:52:35,285 --> 00:52:36,545
0,315 315,525 525,795 795,1050 1050,1260
for which object and who's

2094
00:52:36,545 --> 00:52:37,640
0,210 210,435 435,695
waiting for that.|
|

2095
00:52:37,640 --> 00:52:38,660
0,135 135,270 270,525 525,840 840,1020
And from that information, you
从这些信息中，你可以把这个放在一起。这是三笔交易的日程表。

2096
00:52:38,660 --> 00:52:39,710
0,135 135,345 345,570 570,810 810,1050
can put this and put

2097
00:52:39,710 --> 00:52:42,005
0,180 180,405 405,740 1210,1610 1900,2295
this thing together. {So,here's -}

2098
00:52:42,005 --> 00:52:43,030
0,120 120,345 345,585 585,750 750,1025
a schedule of three transactions.|
|

2099
00:52:44,060 --> 00:52:46,210
0,320 490,810 810,1130 1390,1875 1875,2150
And t one locks a
T1锁定a，然后尝试锁定BT，两个锁定b，然后尝试锁定c，t三次尝试锁定c，然后是a，所以这是一个例子，三个事务之前看到了两个事务的死锁，但它们可以跨三个事务发生。

2100
00:52:46,590 --> 00:52:47,570
0,290 290,470 470,650 650,800 800,980
and then tries to lock

2101
00:52:48,150 --> 00:52:49,715
0,305 305,545 545,980 980,1265 1265,1565
BT two locks b then

2102
00:52:49,715 --> 00:52:51,230
0,195 195,345 345,510 510,815 1195,1515
tries to lock c and

2103
00:52:51,230 --> 00:52:52,400
0,240 240,540 540,825 825,990 990,1170
t three tries to lock

2104
00:52:52,400 --> 00:52:53,900
0,270 270,510 510,690 690,980 1240,1500
c and then a so

2105
00:52:53,900 --> 00:52:54,935
0,165 165,300 300,495 495,720 720,1035
it's just showing an example

2106
00:52:54,935 --> 00:52:56,830
0,300 300,570 570,840 840,1145 1495,1895
with like three transactions previously

2107
00:52:56,910 --> 00:52:58,385
0,260 260,380 380,770 770,1090 1170,1475
saw a deadlock with two

2108
00:52:58,385 --> 00:52:59,980
0,305 535,930 930,1185 1185,1320 1320,1595
transactions, but they can happen

2109
00:53:00,060 --> 00:53:01,920
0,380 380,665 665,970
across three transactions.|
|

2110
00:53:01,920 --> 00:53:03,020
0,320
So.|
所以。|

2111
00:53:03,020 --> 00:53:04,160
0,270 270,420 420,555 555,830 850,1140
As you can see, this
正如您所看到的，在锁管理器中做这件事的方式略有不同。我们将以倒退的方式来说，哦，谁在等待什么，这就是这里形成的弧线。

2112
00:53:04,160 --> 00:53:05,290
0,150 150,285 285,480 480,765 765,1130
thing is done slightly differently

2113
00:53:05,400 --> 00:53:06,680
0,290 290,440 440,620 620,940 990,1280
in the lock manager. {We,will

2114
00:53:06,680 --> 00:53:07,865
0,285 285,555 555,705 705,825 825,1185
-} go in the backward

2115
00:53:07,865 --> 00:53:09,185
0,270 270,525 525,815 895,1170 1170,1320
fashion in this to say,

2116
00:53:09,185 --> 00:53:10,730
0,275 655,915 915,1065 1065,1305 1305,1545
oh, who is waiting for

2117
00:53:10,730 --> 00:53:11,915
0,270 270,555 555,825 825,990 990,1185
what, and that's what becomes

2118
00:53:11,915 --> 00:53:13,160
0,150 150,450 450,695
an arc here.|
|

2119
00:53:14,010 --> 00:53:15,245
0,305 305,665 665,860 860,1040 1040,1235
The dependence graph was this
在这里，依赖图是以这种方式及时出现的。这张图在时间上是这样的。

2120
00:53:15,245 --> 00:53:16,910
0,195 195,405 405,720 720,1115 1345,1665
way right in time here.

2121
00:53:16,910 --> 00:53:18,020
0,240 240,465 465,645 645,825 825,1110
{This,graph -} is this way

2122
00:53:18,020 --> 00:53:19,160
0,270 270,560
in time.|
|

2123
00:53:20,240 --> 00:53:22,380
0,400 840,1240
So, uh.|
那么，呃。|

2124
00:53:22,420 --> 00:53:23,655
0,365 365,650 650,845 845,1040 1040,1235
Say Steven is waiting for
比方说史蒂文在等第二节的节目。

2125
00:53:23,655 --> 00:53:25,180
0,225 225,450 450,615 615,905
something from t two.|
|

2126
00:53:25,540 --> 00:53:26,550
0,320 320,500 500,635 635,830 830,1010
T two is waiting for
T2号在等T3号的东西。

2127
00:53:26,550 --> 00:53:28,940
0,225 225,590 1090,1425 1425,1760
something from t three.|
|

2128
00:53:29,920 --> 00:53:32,475
0,400 600,875 875,1355 1355,1960 2280,2555
And the deadlock completes when
当最后一个请求到达时，死锁完成，此时，这三个事务不会取得任何进展。系统将永远等待。

2129
00:53:32,475 --> 00:53:33,630
0,165 165,455 475,765 765,960 960,1155
that last request comes in,

2130
00:53:33,630 --> 00:53:34,665
0,165 165,330 330,540 540,765 765,1035
at this point, no progress

2131
00:53:34,665 --> 00:53:35,625
0,225 225,345 345,540 540,765 765,960
will be made across these

2132
00:53:35,625 --> 00:53:36,900
0,195 195,485 595,855 855,1065 1065,1275
three transactions. {The,system -} will

2133
00:53:36,900 --> 00:53:38,700
0,260 490,870 870,1250
just wait forever.|
|

2134
00:53:39,030 --> 00:53:40,480
0,305 305,485 485,665 665,970
Unless we break it.|
除非我们打破它。|

2135
00:53:40,930 --> 00:53:41,840
0,400
Okay.|
好吧。|

2136
00:53:41,840 --> 00:53:43,060
0,380
Questions.|
问题。|

2137
00:53:43,060 --> 00:53:44,440
0,150 150,270 270,420 420,710
Does that make sense?|
这说得通吗？|

2138
00:53:46,400 --> 00:53:47,455
0,380 380,620 620,725 725,875 875,1055
Cycle in the waste program
在废物计划进度中循环。

2139
00:53:47,455 --> 00:53:47,980
0,275
progress.|
|

2140
00:53:47,980 --> 00:53:48,880
0,225 225,480 480,660 660,765 765,900
Any cycle in the base
图的基础中的任何循环都将是死锁。

2141
00:53:48,880 --> 00:53:49,735
0,180 180,420 420,660 660,780 780,855
for graph will be a

2142
00:53:49,735 --> 00:53:50,680
0,425
deadlock.|
|

2143
00:53:50,780 --> 00:53:51,880
0,400 750,1070
And a.|
还有一个。|

2144
00:53:51,880 --> 00:53:54,160
0,260 1270,1665 1665,1950 1950,2115 2115,2280
Cool observation has been that
冷静的观察是，大多数周期往往也是长度较长的。所以死锁检测本身就是一个复杂的算法，运行的计算非常昂贵，所以人们会运行很多次，你知道吗？所以，有一个问题是，我应该多频繁地运行这个后台线程，来遍历锁管理器中的所有锁，并计算这个图。

2145
00:53:54,160 --> 00:53:55,180
0,210 210,600 600,780 780,915 915,1020
most cycles tend to be

2146
00:53:55,180 --> 00:53:56,665
0,195 195,495 495,860 1120,1380 1380,1485
of length too. {So,a -}

2147
00:53:56,665 --> 00:53:57,940
0,375 375,765 765,990 990,1155 1155,1275
deadlock detection itself is a

2148
00:53:57,940 --> 00:54:00,025
0,260 430,1155 1155,1290 1290,1545 1545,2085
complex algorithm to run computationally

2149
00:54:00,025 --> 00:54:01,450
0,195 195,545 865,1125 1125,1260 1260,1425
very expensive, so many times

2150
00:54:01,450 --> 00:54:02,905
0,240 240,495 495,800 1030,1290 1290,1455
people will run, you know?

2151
00:54:02,905 --> 00:54:03,685
0,180 180,390 390,555 555,630 630,780
So there's, there's a question

2152
00:54:03,685 --> 00:54:04,765
0,165 165,330 330,635 655,930 930,1080
of how frequently should I

2153
00:54:04,765 --> 00:54:05,905
0,150 150,315 315,605 655,960 960,1140
run this background thread to

2154
00:54:05,905 --> 00:54:07,290
0,180 180,360 360,630 630,900 900,1385
go through all the locks

2155
00:54:07,370 --> 00:54:08,485
0,290 290,425 425,575 575,845 845,1115
in the lock manager and

2156
00:54:08,485 --> 00:54:09,920
0,390 390,585 585,875
compute this graph.|
|

2157
00:54:09,930 --> 00:54:11,020
0,260 260,425 425,650 650,830 830,1090
The lock manager could have
锁管理器中可能有数百万个条目，因此计算此图可能非常昂贵。

2158
00:54:11,190 --> 00:54:12,820
0,400 420,755 755,1220 1220,1370 1370,1630
millions of entries in it,

2159
00:54:12,930 --> 00:54:14,135
0,335 335,650 650,800 800,1010 1010,1205
so computing this graph can

2160
00:54:14,135 --> 00:54:15,740
0,150 150,425 445,845
be very expensive.|
|

2161
00:54:15,740 --> 00:54:16,865
0,165 165,270 270,360 360,570 570,1125
But they are cheaper algorithms
但它们是更便宜的算法，比方说，寻找图表，也找到长度的圈，这可以更快地完成。魔兽世界的气球飞到了这里，因为这里有一台全新的相机。阿。

2162
00:54:16,865 --> 00:54:19,010
0,150 150,330 330,635 1105,1775 1825,2145
to, say, find graphs, find

2163
00:54:19,010 --> 00:54:20,225
0,345 345,495 495,705 705,990 990,1215
cycles of length too, which

2164
00:54:20,225 --> 00:54:21,005
0,165 165,300 300,405 405,525 525,780
can be done a lot

2165
00:54:21,005 --> 00:54:23,420
0,395 955,1355 1405,1770 1770,2205 2205,2415
faster. {And,wow, -} balloons went

2166
00:54:23,420 --> 00:54:25,190
0,150 150,330 330,650 1390,1650 1650,1770
up over here because of

2167
00:54:25,190 --> 00:54:26,630
0,150 150,440 580,870 870,1155 1155,1440
this whole new camera thing

2168
00:54:26,630 --> 00:54:28,220
0,290 460,860
here. Ah.|
|

2169
00:54:28,230 --> 00:54:29,480
0,400
So.|
所以。|

2170
00:54:30,050 --> 00:54:31,380
0,275 275,425 425,700 780,1055 1055,1330
You can have the background
您可以让后台线程更频繁地运行，以便也找到长度较长的周期，但对于较大的周期，运行频率较低。

2171
00:54:31,520 --> 00:54:33,835
0,400 840,1220 1220,1550 1550,1900 2040,2315
thread run more frequently to

2172
00:54:33,835 --> 00:54:35,245
0,225 225,555 555,1005 1005,1185 1185,1410
just find cycles of length

2173
00:54:35,245 --> 00:54:36,985
0,335 595,900 900,1125 1125,1445 1465,1740
too, but less frequently for

2174
00:54:36,985 --> 00:54:38,360
0,105 105,285 285,815
the bigger cycles.|
|

2175
00:54:39,930 --> 00:54:41,560
0,400 570,920 920,1040 1040,1190 1190,1630
Okay, that's just a tidbit
好吧，这只是一个小道消息，以防你对僵局超级感兴趣和兴奋。啊侦测的东西。重点是找到这个图表，如果你有一个大的。

2176
00:54:42,300 --> 00:54:43,265
0,290 290,455 455,575 575,695 695,965
in case you get super

2177
00:54:43,265 --> 00:54:45,250
0,395 415,750 750,1050 1050,1415 1585,1985
interested and excited about the

2178
00:54:45,600 --> 00:54:47,780
0,590 590,920 920,1370 1370,1660 1920,2180
deadlock. {Ah,,detection -} {stuff.,The -}

2179
00:54:47,780 --> 00:54:49,355
0,165 165,375 375,680 910,1290 1290,1575
main point is finding this

2180
00:54:49,355 --> 00:54:50,465
0,285 285,540 540,780 780,930 930,1110
graph if you've got a

2181
00:54:50,465 --> 00:54:51,580
0,275
large.|
|

2182
00:54:51,860 --> 00:54:53,800
0,335 335,670 960,1360 1530,1805 1805,1940
Lock manager table where there
有许多条目的锁管理器表是昂贵的，所以您不能一直运行它，您必须定期运行它。

2183
00:54:53,800 --> 00:54:55,105
0,195 195,435 435,615 615,1005 1005,1305
are lots of entries is

2184
00:54:55,105 --> 00:54:56,395
0,365 625,870 870,960 960,1155 1155,1290
expensive, so you can't just

2185
00:54:56,395 --> 00:54:57,330
0,195 195,360 360,525 525,675 675,935
run this all the time,

2186
00:54:57,410 --> 00:54:58,135
0,335 335,410 410,500 500,605 605,725
you're going to have to

2187
00:54:58,135 --> 00:54:59,560
0,105 105,240 240,995
run it periodically.|
|

2188
00:54:59,600 --> 00:55:00,850
0,275 275,545 545,950 950,1085 1085,1250
Okay, so that's the trade
好的，这就是检查频率和交易等待时间之间的权衡。你可以随时查看。您将很快找到死锁，但您花费了很多周期，只是发现了死锁。比方说，如果你每天检查，那么已经形成了一天的僵局。你很长时间内都找不到它。

2189
00:55:00,850 --> 00:55:02,410
0,290 640,915 915,1050 1050,1305 1305,1560
off between the frequency of

2190
00:55:02,410 --> 00:55:03,895
0,260 700,1005 1005,1185 1185,1335 1335,1485
checking and how long the

2191
00:55:03,895 --> 00:55:05,395
0,275 415,815 925,1185 1185,1320 1320,1500
transactions wait. {You,can -} check

2192
00:55:05,395 --> 00:55:06,850
0,210 210,375 375,635 985,1335 1335,1455
all the {time.,You'll -} find

2193
00:55:06,850 --> 00:55:08,035
0,135 135,435 435,735 735,990 990,1185
the deadlock quickly, but you're

2194
00:55:08,035 --> 00:55:08,980
0,150 150,300 300,405 405,555 555,945
spending a lot of cycles

2195
00:55:08,980 --> 00:55:10,645
0,180 180,360 360,585 585,1250 1390,1665
and just {finding,deadlocks. -} If

2196
00:55:10,645 --> 00:55:11,815
0,180 180,480 480,840 840,945 945,1170
you check, let's say, every

2197
00:55:11,815 --> 00:55:13,585
0,365 595,975 975,1230 1230,1560 1560,1770
day, then a deadlock that's

2198
00:55:13,585 --> 00:55:14,245
0,120 120,285 285,435 435,540 540,660
been formed {for,a -} day.

2199
00:55:14,245 --> 00:55:15,190
0,135 135,300 300,450 450,720 720,945
You won't find it for

2200
00:55:15,190 --> 00:55:16,140
0,105 105,255 255,560
a long time.|
|

2201
00:55:22,060 --> 00:55:23,160
0,195 195,495 495,795 795,1050
Pin check on the.|
检查上的PIN。|

2202
00:55:24,590 --> 00:55:25,680
0,400
Yeah.|
嗯。|

2203
00:55:28,460 --> 00:55:29,425
0,305 305,470 470,590 590,770 770,965
Yeah. {So,the -} question is,
嗯。所以问题是，我可以在每次输入时动态维护这个锁图吗？如果向锁管理器发出请求，您可以这样做，但这会增加成本。

2204
00:55:29,425 --> 00:55:30,780
0,135 135,270 270,545 595,975 975,1355
can I maintain this lock

2205
00:55:30,920 --> 00:55:32,965
0,400 660,1505 1505,1715 1715,1910 1910,2045
graph dynamically every time I

2206
00:55:32,965 --> 00:55:35,005
0,275 595,990 990,1385 1555,1860 1860,2040
do an entry? If make

2207
00:55:35,005 --> 00:55:35,770
0,195 195,390 390,525 525,630 630,765
a request to the lock

2208
00:55:35,770 --> 00:55:37,060
0,290 460,750 750,960 960,1140 1140,1290
manager, you could, but then

2209
00:55:37,060 --> 00:55:38,100
0,165 165,315 315,510 510,735 735,1040
that will add more cost.|
|

2210
00:55:38,780 --> 00:55:39,500
0,165 165,345 345,495 495,615 615,720
See you trying to make
我看到你在试着让这个锁管理员跑得很快。我正在获取一把锁，放开它。如果你开始说我也需要更新和绘制图表，那你就是在权衡。它将使每次锁定请求的时间增加一倍、三倍。所以，你宁愿做的是让这些锁没有那么多机会让这种类型的冲突提前阻止它们。这就是分层锁定所要做的，我们将在稍后看到。

2211
00:55:39,500 --> 00:55:40,550
0,150 150,330 330,570 570,810 810,1050
this lock manager go really

2212
00:55:40,550 --> 00:55:41,810
0,330 330,705 705,930 930,1095 1095,1260
fast. {I'm,acquiring -} a lock,

2213
00:55:41,810 --> 00:55:42,995
0,180 180,315 315,590 730,1020 1020,1185
let it {go.,And -} if

2214
00:55:42,995 --> 00:55:43,715
0,165 165,375 375,540 540,630 630,720
you start to say I

2215
00:55:43,715 --> 00:55:44,555
0,165 165,360 360,525 525,675 675,840
also need to update and

2216
00:55:44,555 --> 00:55:45,425
0,225 225,465 465,570 570,720 720,870
graph, that's a trade off

2217
00:55:45,425 --> 00:55:47,840
0,195 195,425 685,1385 1465,1865 2035,2415
{you're,making. -} It'll double, triple

2218
00:55:47,840 --> 00:55:48,950
0,255 255,435 435,615 615,810 810,1110
the time of {each,lock -}

2219
00:55:48,950 --> 00:55:51,410
0,410 760,1080 1080,1400 1900,2235 2235,2460
requests. And so what, what

2220
00:55:51,410 --> 00:55:52,430
0,180 180,375 375,630 630,855 855,1020
you would rather do is

2221
00:55:52,430 --> 00:55:54,380
0,195 195,495 495,840 840,1430 1630,1950
to have these locks not

2222
00:55:54,380 --> 00:55:55,510
0,225 225,435 435,645 645,840 840,1130
have as many chance of

2223
00:55:56,100 --> 00:55:57,680
0,400 660,995 995,1220 1220,1400 1400,1580
being having these types of

2224
00:55:57,680 --> 00:55:59,525
0,615 615,915 915,1095 1095,1370 1510,1845
{conflicts,stop -} them early. That's

2225
00:55:59,525 --> 00:56:00,710
0,120 120,240 240,765 765,1050 1050,1185
what the hierarchical locking will

2226
00:56:00,710 --> 00:56:01,325
0,120 120,255 255,450 450,525 525,615
do, as we'll see in

2227
00:56:01,325 --> 00:56:02,200
0,90 90,255 255,575
a little bit.|
|

2228
00:56:02,480 --> 00:56:03,220
0,275 275,425 425,530 530,605 605,740
And so there are all
所以有各种各样的方法，但一直在内存中动态保存图形是有代价的。

2229
00:56:03,220 --> 00:56:04,540
0,165 165,315 315,590 640,990 990,1320
kinds of methods, but there's

2230
00:56:04,540 --> 00:56:06,220
0,105 105,380 430,795 795,1500 1500,1680
a cost to dynamically keeping

2231
00:56:06,220 --> 00:56:07,690
0,210 210,500 550,885 885,1200 1200,1470
that graph in memory all

2232
00:56:07,690 --> 00:56:08,580
0,135 135,380
the time.|
|

2233
00:56:10,300 --> 00:56:11,250
0,290 290,560 560,785 785,905 905,950
And sometimes when you're in
有时，当您处于分布式系统中时。

2234
00:56:11,250 --> 00:56:12,880
0,165 165,480 480,860
a distributed system.|
|

2235
00:56:12,920 --> 00:56:13,975
0,350 350,605 605,785 785,920 920,1055
That state is not in
这种状态并不在一个地方。锁管理器位于每个节点并进行死锁检测。必须有人将所有这些都集中到一个节点上，然后再做这些事情。因此，在将全局图整合到分布式系统中之前，您甚至都没有全局图。而像雪花数据这样的大多数数据库系统打破了微软、亚马逊和谷歌提供的所有他们分发的东西。

2236
00:56:13,975 --> 00:56:15,085
0,180 180,450 450,675 675,840 840,1110
one place. {The,lock -} manager

2237
00:56:15,085 --> 00:56:16,630
0,240 240,450 450,720 720,1290 1290,1545
is at each node and

2238
00:56:16,630 --> 00:56:18,085
0,135 135,480 480,975 975,1260 1260,1455
the deadlock {detection.,Someone -} has

2239
00:56:18,085 --> 00:56:18,820
0,120 120,240 240,405 405,555 555,735
to bring all of it

2240
00:56:18,820 --> 00:56:20,245
0,240 240,435 435,600 600,1100 1120,1425
together to one node and

2241
00:56:20,245 --> 00:56:21,580
0,240 240,435 435,600 600,905 955,1335
then do {this,stuff. -} So

2242
00:56:21,580 --> 00:56:22,720
0,255 255,450 450,600 600,885 885,1140
you don't even have a

2243
00:56:22,720 --> 00:56:23,650
0,255 255,525 525,690 690,810 810,930
global graph till you bring

2244
00:56:23,650 --> 00:56:25,105
0,180 180,500 670,930 930,1125 1125,1455
it together in {a,distributed -}

2245
00:56:25,105 --> 00:56:27,090
0,395 595,960 960,1245 1245,1565 1585,1985
system. And most database systems

2246
00:56:27,110 --> 00:56:29,470
0,305 305,830 830,1145 1145,1510 2040,2360
like snowflake data breaks all

2247
00:56:29,470 --> 00:56:31,465
0,210 210,435 435,690 690,1010 1690,1995
the things that Microsoft, Amazon

2248
00:56:31,465 --> 00:56:32,610
0,180 180,345 345,555 555,810 810,1145
and Google offer they distributed.|
|

2249
00:56:33,200 --> 00:56:35,000
0,195 195,500 520,920 1390,1665 1665,1800
Right. {And,so -} start in
正确的。所以从一个地方开始。

2250
00:56:35,000 --> 00:56:36,060
0,135 135,410
one place.|
|

2251
00:56:36,190 --> 00:56:37,820
0,245 245,395 395,650 650,1000
So even more expensive.|
所以更贵了。|

2252
00:56:38,570 --> 00:56:40,040
0,335 335,670
Other questions?|
还有其他问题吗？|

2253
00:56:42,310 --> 00:56:45,000
0,400 540,940 1080,1640 1640,2200 2310,2690
Okay, so deadlock detection, how
好的，那么死锁检测，我们要怎么做呢？假设我们找到了一个循环。

2254
00:56:45,000 --> 00:56:45,885
0,285 285,450 450,615 615,765 765,885
are we going to do

2255
00:56:45,885 --> 00:56:47,520
0,270 270,630 630,750 750,1115 1285,1635
that? Let's say we found

2256
00:56:47,520 --> 00:56:48,740
0,210 210,470
a cycle.|
|

2257
00:56:48,740 --> 00:56:49,445
0,180 180,285 285,390 390,510 510,705
Now you have to choose
现在，您必须选择要终止哪一块板的事务的节点。请记住，我们上次讨论过如何启动事务，有时数据库可能会为您中止事务。因此，您作为应用程序程序员编写您的代码，并且您必须准备好应对代码中止后会发生的情况。在好的应用程序中，你经常会在放弃并抛出应用程序错误之前说，如果一个机器人重试了五次或诸如此类的话。

2258
00:56:49,445 --> 00:56:50,855
0,240 240,480 480,585 585,845 1105,1410
which node to kill which

2259
00:56:50,855 --> 00:56:52,655
0,305 415,660 660,750 750,995 1435,1800
transaction to a board. {And,this

2260
00:56:52,655 --> 00:56:53,855
0,240 240,435 435,690 690,945 945,1200
-} is remember last time

2261
00:56:53,855 --> 00:56:55,700
0,195 195,405 405,755 835,1235 1555,1845
we talked about how a

2262
00:56:55,700 --> 00:56:56,855
0,290 340,615 615,765 765,915 915,1155
transaction may start and sometimes

2263
00:56:56,855 --> 00:56:58,115
0,225 225,480 480,735 735,1065 1065,1260
a database may abort the

2264
00:56:58,115 --> 00:56:59,255
0,275 415,720 720,900 900,1035 1035,1140
transaction for {you.,So -} you

2265
00:56:59,255 --> 00:57:01,055
0,90 90,315 315,630 630,1325 1495,1800
as an applications programmer write

2266
00:57:01,055 --> 00:57:03,800
0,180 180,455 1465,1865 2335,2595 2595,2745
your code and you have

2267
00:57:03,800 --> 00:57:04,805
0,135 135,240 240,435 435,750 750,1005
to be ready for what

2268
00:57:04,805 --> 00:57:05,800
0,195 195,375 375,495 495,630 630,995
happens if it {gets,aborted. -}

2269
00:57:06,120 --> 00:57:07,610
0,320 320,605 605,860 860,1145 1145,1490
So often in good applications

2270
00:57:07,610 --> 00:57:08,570
0,270 270,360 360,495 495,630 630,960
you'll say if a bot

2271
00:57:08,570 --> 00:57:09,910
0,435 435,660 660,900 900,1080 1080,1340
retry five times or whatever

2272
00:57:09,960 --> 00:57:10,805
0,275 275,410 410,530 530,665 665,845
before you give up and

2273
00:57:10,805 --> 00:57:12,280
0,165 165,405 405,720 720,1055
throw an application error.|
|

2274
00:57:12,610 --> 00:57:13,965
0,305 305,530 530,850 960,1220 1220,1355
Why would someone, why would
为什么会有人，为什么数据库会支持这种死锁的发生？一个普遍的理由是对的吗？您正在做一些事情，一些应用程序代码正在做一些事情，数据库检测到死锁。其中一个应用程序代码、一个SQL查询必须中止。但这并不是因为程序员有一个显式的中止调用，而是因为数据库必须因为死锁而中止。

2275
00:57:13,965 --> 00:57:15,465
0,120 120,365 445,735 735,1020 1020,1500
the database support that deadlock

2276
00:57:15,465 --> 00:57:17,060
0,275 595,885 885,1035 1035,1245 1245,1595
happen? Is a common reason

2277
00:57:17,140 --> 00:57:18,170
0,305 305,470 470,590 590,740 740,1030
right? You were doing something,

2278
00:57:18,280 --> 00:57:19,440
0,260 260,380 380,605 605,920 920,1160
some of the application code

2279
00:57:19,440 --> 00:57:20,925
0,180 180,360 360,650 1000,1320 1320,1485
was doing something and the

2280
00:57:20,925 --> 00:57:22,350
0,245 325,645 645,735 735,1125 1125,1425
database detects a deadlock. {One,of

2281
00:57:22,350 --> 00:57:23,700
0,180 180,440 550,885 885,1155 1155,1350
-} those application code, one

2282
00:57:23,700 --> 00:57:25,110
0,120 120,255 255,740 790,1260 1260,1410
of those sql queries has

2283
00:57:25,110 --> 00:57:27,375
0,150 150,410 700,1220 1780,2085 2085,2265
to get {aborted.,But, -} and

2284
00:57:27,375 --> 00:57:28,470
0,240 240,540 540,705 705,885 885,1095
that's theort is not because

2285
00:57:28,470 --> 00:57:30,165
0,180 180,720 720,960 960,1305 1305,1695
the programmer had an explicit

2286
00:57:30,165 --> 00:57:31,350
0,255 255,570 570,900 900,1065 1065,1185
abort call is because the

2287
00:57:31,350 --> 00:57:32,490
0,260 310,585 585,705 705,945 945,1140
database has to abort for

2288
00:57:32,490 --> 00:57:33,880
0,210 210,405 405,890
so a deadlock.|
|

2289
00:57:33,880 --> 00:57:35,920
0,320 1210,1500 1500,1665 1665,1815 1815,2040
And how would you choose
你会如何选择受害者是什么？你可以用多种方式来表达。

2290
00:57:35,920 --> 00:57:36,865
0,240 240,375 375,570 570,810 810,945
what the victim is? There

2291
00:57:36,865 --> 00:57:37,885
0,90 90,330 330,675 675,885 885,1020
are multiple ways you could

2292
00:57:37,885 --> 00:57:38,900
0,275
say.|
|

2293
00:57:38,900 --> 00:57:41,465
0,360 360,1070 1960,2265 2265,2430 2430,2565
Lowest timestamp or you could
最低时间戳，或者您可以说我将中止已完成的工作量最少的事务。您可能会对工作有一些定义，比如，您在BEGIN和END语句之间激发了10个查询，已经激发了10个查询。另外一个刚刚炒了两个人，所以我要去，啊，杀了这个交易，它做的工作量较少。

2294
00:57:41,465 --> 00:57:42,935
0,275 295,555 555,735 735,1170 1170,1470
say I will abort the

2295
00:57:42,935 --> 00:57:44,030
0,335 415,675 675,795 795,945 945,1095
transaction that has done the

2296
00:57:44,030 --> 00:57:45,470
0,210 210,435 435,585 585,860 1180,1440
least amount of work. {You,might

2297
00:57:45,470 --> 00:57:46,520
0,135 135,300 300,480 480,770 790,1050
-} have some definition of

2298
00:57:46,520 --> 00:57:47,600
0,195 195,420 420,630 630,825 825,1080
work saying, oh, you fired

2299
00:57:47,600 --> 00:57:49,655
0,300 300,795 795,1095 1095,1400 1780,2055
10 queries in the between

2300
00:57:49,655 --> 00:57:50,680
0,180 180,330 330,450 450,675 675,1025
the begin and end statements,

2301
00:57:50,940 --> 00:57:51,980
0,320 320,515 515,665 665,875 875,1040
10 have been {fired.,The -}

2302
00:57:51,980 --> 00:57:52,730
0,120 120,255 255,375 375,525 525,750
other one is just fired

2303
00:57:52,730 --> 00:57:53,915
0,350 400,645 645,780 780,900 900,1185
two, so I'm going to

2304
00:57:53,915 --> 00:57:55,480
0,395 565,885 885,1110 1110,1290 1290,1565
go, ah, kill the transaction,

2305
00:57:55,650 --> 00:57:56,720
0,275 275,425 425,605 605,845 845,1070
which has done less amount

2306
00:57:56,720 --> 00:57:57,620
0,150 150,410
of work.|
|

2307
00:57:58,440 --> 00:57:59,495
0,290 290,440 440,605 605,785 785,1055
By the number of items
通过锁表中锁定的项的数量，因为这可能是某人完成的工作量的代理。基本上，当你中止一个交易时，你就失去了所有的工作，对吗？那就得重做了。因此，您正在尝试对此进行优化。

2308
00:57:59,495 --> 00:58:00,335
0,255 255,390 390,555 555,720 720,840
that are locked in the

2309
00:58:00,335 --> 00:58:01,310
0,120 120,395 415,690 690,840 840,975
lock table, because that may

2310
00:58:01,310 --> 00:58:02,075
0,105 105,210 210,525 525,630 630,765
be a proxy of the

2311
00:58:02,075 --> 00:58:03,215
0,150 150,300 300,510 510,825 825,1140
amount of work that's someone's

2312
00:58:03,215 --> 00:58:04,475
0,240 240,630 630,885 885,1005 1005,1260
done. {Basically,,when -} you abort

2313
00:58:04,475 --> 00:58:05,750
0,180 180,455 475,810 810,1020 1020,1275
a transaction, you're losing all

2314
00:58:05,750 --> 00:58:07,010
0,180 180,435 435,780 780,1170 1170,1260
that work, right? That'll have

2315
00:58:07,010 --> 00:58:07,895
0,105 105,225 225,570 570,720 720,885
to get {redone.,So -} you're

2316
00:58:07,895 --> 00:58:09,730
0,135 135,425 745,1410 1410,1575 1575,1835
trying to optimize for that.|
|

2317
00:58:10,390 --> 00:58:11,835
0,290 290,440 440,980 980,1220 1220,1445
But the balancing part is
但平衡的部分是，如果你放弃了一笔交易。

2318
00:58:11,835 --> 00:58:13,065
0,150 150,300 300,555 555,1035 1035,1230
that if you abort a

2319
00:58:13,065 --> 00:58:14,400
0,275
transaction.|
|

2320
00:58:14,400 --> 00:58:15,420
0,285 285,510 510,675 675,810 810,1020
That has done the least
它完成的工作量最少，取得的进展也最少。然后，您可能会让一些永远不会取得进展的事务挨饿，因为较旧的事务可能总是在它的前面。

2321
00:58:15,420 --> 00:58:16,305
0,240 240,390 390,555 555,735 735,885
amount of work or made

2322
00:58:16,305 --> 00:58:17,210
0,135 135,315 315,495 495,630 630,905
the least amount of progress.

2323
00:58:17,410 --> 00:58:18,180
0,260 260,365 365,470 470,590 590,770
{Then,you -} could end up

2324
00:58:18,180 --> 00:58:19,575
0,465 465,645 645,950 1000,1260 1260,1395
starving some transactions that can

2325
00:58:19,575 --> 00:58:21,015
0,180 180,375 375,665 745,1145 1195,1440
never make progress because the

2326
00:58:21,015 --> 00:58:22,680
0,195 195,545 685,1085 1135,1455 1455,1665
older transactions could always be

2327
00:58:22,680 --> 00:58:23,760
0,165 165,330 330,620
ahead of it.|
|

2328
00:58:23,760 --> 00:58:24,450
0,120 120,210 210,345 345,495 495,690
So you want to avoid
所以你想避免饥饿，所以有时你发生的事情，你最终要做的是说我是否使用了基于时间戳的协议，这在当时是很常见的。

2329
00:58:24,450 --> 00:58:26,055
0,530 700,990 990,1155 1155,1380 1380,1605
starvation and so sometimes what

2330
00:58:26,055 --> 00:58:27,180
0,135 135,395 655,930 930,1035 1035,1125
you happen, what you end

2331
00:58:27,180 --> 00:58:28,010
0,135 135,285 285,450 450,585 585,830
up doing is to say

2332
00:58:28,060 --> 00:58:29,295
0,275 275,440 440,590 590,785 785,1235
if I'm using a timestamp

2333
00:58:29,295 --> 00:58:30,435
0,210 210,675 675,825 825,960 960,1140
based protocol, which is pretty

2334
00:58:30,435 --> 00:58:32,380
0,305 775,1175
common then.|
|

2335
00:58:32,380 --> 00:58:33,420
0,180 180,285 285,570 570,765 765,1040
When I abort, the transaction
当我中止时，事务变为最近的。我将保留原始时间戳，以便事务获得越来越高的优先级，以便它有机会在某个时间点完成。

2336
00:58:33,590 --> 00:58:34,960
0,305 305,610 720,995 995,1160 1160,1370
gets recent. {I,will -} keep

2337
00:58:34,960 --> 00:58:36,715
0,240 240,525 525,1160 1330,1605 1605,1755
the original timestamp so the

2338
00:58:36,715 --> 00:58:38,200
0,275 445,780 780,1050 1050,1260 1260,1485
transaction gets higher and higher

2339
00:58:38,200 --> 00:58:39,835
0,350 880,1155 1155,1290 1290,1440 1440,1635
priority so that it has

2340
00:58:39,835 --> 00:58:40,945
0,210 210,435 435,630 630,990 990,1110
some chance of finishing at

2341
00:58:40,945 --> 00:58:42,180
0,150 150,330 330,510 510,785
some point in time.|
|

2342
00:58:42,180 --> 00:58:42,810
0,225 225,330 330,435 435,525 525,630
If you give it a
如果您给它一个新的时间戳，它可能永远不会运行。

2343
00:58:42,810 --> 00:58:43,770
0,135 135,525 525,675 675,810 810,960
new timestamp, it may never

2344
00:58:43,770 --> 00:58:44,740
0,180 180,470
get run.|
|

2345
00:58:47,140 --> 00:58:48,240
0,305 305,610
All right.|
好的。|

2346
00:58:48,480 --> 00:58:51,590
0,400 1890,2240 2240,2480 2480,2770 2790,3110
So now, when you have
因此，现在，当您必须取消必须终止的事务时，有两种不同的方法来完成。其一，你本可以买下整笔交易。

2347
00:58:51,590 --> 00:58:53,375
0,240 240,720 720,885 885,1160 1480,1785
to undo a transaction that

2348
00:58:53,375 --> 00:58:54,800
0,195 195,345 345,540 540,875 1135,1425
has to be killed, there

2349
00:58:54,800 --> 00:58:55,760
0,180 180,330 330,540 540,795 795,960
are two different ways to

2350
00:58:55,760 --> 00:58:56,690
0,105 105,345 345,630 630,795 795,930
do it. {One,is -} you

2351
00:58:56,690 --> 00:58:57,485
0,105 105,210 210,360 360,555 555,795
could have bought the entire

2352
00:58:57,485 --> 00:58:58,700
0,335
transaction.|
|

2353
00:58:58,700 --> 00:59:00,430
0,195 195,500 610,1200 1200,1485 1485,1730
And in sql, you're also
在SQL中，也允许这样做。让我们看看您正在编写的应用程序代码，其中有应用程序需要的10条SQL语句，对吗？第一个是您的航班已经确认，酒店已经确认。诸如此类的事情，当你到达第九个步骤时，你意识到最后一个问题就是那个引起麻烦的问题。你可能想说，不要放弃一切。回滚就行了。

2354
00:59:00,480 --> 00:59:01,540
0,350 350,635 635,710 710,830 830,1060
allowed. {Let's,see, -} you're writing

2355
00:59:01,650 --> 00:59:02,645
0,350 350,575 575,725 725,875 875,995
application code in which there

2356
00:59:02,645 --> 00:59:03,965
0,90 90,240 240,615 615,905 1015,1320
are 10 sql statements that

2357
00:59:03,965 --> 00:59:05,405
0,300 300,645 645,900 900,1185 1185,1440
the application needs, right? The

2358
00:59:05,405 --> 00:59:06,290
0,195 195,390 390,540 540,705 705,885
first one is your flight

2359
00:59:06,290 --> 00:59:07,400
0,165 165,390 390,660 660,900 900,1110
has been confirmed, the hotel

2360
00:59:07,400 --> 00:59:08,540
0,165 165,390 390,675 675,930 930,1140
has been {confirmed.,Stuff -} like

2361
00:59:08,540 --> 00:59:10,210
0,290 490,795 795,1050 1050,1335 1335,1670
that, and you reach the

2362
00:59:11,640 --> 00:59:13,475
0,320 320,590 590,1100 1100,1420 1530,1835
reach the ninth step and

2363
00:59:13,475 --> 00:59:15,200
0,285 285,665 745,1145 1225,1560 1560,1725
realize the last query is

2364
00:59:15,200 --> 00:59:16,240
0,120 120,270 270,450 450,690 690,1040
the one that {caused,trouble. -}

2365
00:59:16,530 --> 00:59:17,300
0,260 260,380 380,530 530,665 665,770
You may want to say

2366
00:59:17,300 --> 00:59:18,935
0,165 165,530 610,975 975,1305 1305,1635
{don't,abort -} everything. Just roll

2367
00:59:18,935 --> 00:59:19,820
0,365
back.|
|

2368
00:59:19,820 --> 00:59:21,940
0,225 225,360 360,620 1300,1700 1720,2120
To the previous safe point.
到上一个安全点。所以你可以显式地设置安全点调用，所以你作为一个程序，必须这样做。然后，您可以说如果中止，只需回滚到该位置，我将重试最后一步。

2369
00:59:22,050 --> 00:59:23,315
0,230 230,320 320,545 545,1100 1100,1265
{So,you -} can explicitly put

2370
00:59:23,315 --> 00:59:24,980
0,240 240,510 510,845 1195,1470 1470,1665
safe point calls so you

2371
00:59:24,980 --> 00:59:25,820
0,195 195,330 330,525 525,720 720,840
as a program and have

2372
00:59:25,820 --> 00:59:27,020
0,120 120,255 255,530 790,1065 1065,1200
to do {that.,And -} then

2373
00:59:27,020 --> 00:59:27,560
0,105 105,225 225,345 345,435 435,540
you can say if it

2374
00:59:27,560 --> 00:59:28,565
0,300 300,510 510,690 690,870 870,1005
aborts, just roll back to

2375
00:59:28,565 --> 00:59:29,555
0,120 120,255 255,465 465,780 780,990
that and I'll retry again

2376
00:59:29,555 --> 00:59:30,840
0,180 180,330 330,555 555,905
just that last step.|
|

2377
00:59:30,910 --> 00:59:32,010
0,275 275,410 410,530 530,770 770,1100
So you as an application
所以作为一个应用程序程序员，你必须明确地设置这些安全点，但有一种机制可以让你告诉数据库，如果你需要中止我，只需中止我到这个级别。

2378
00:59:32,010 --> 00:59:33,645
0,615 615,825 825,1035 1035,1500 1500,1635
programmer have to explicitly put

2379
00:59:33,645 --> 00:59:34,860
0,150 150,360 360,695 775,1035 1035,1215
these safe points, but there's

2380
00:59:34,860 --> 00:59:35,940
0,90 90,350 490,780 780,945 945,1080
a mechanism so that you

2381
00:59:35,940 --> 00:59:37,665
0,260 790,1065 1065,1200 1200,1455 1455,1725
can tell the database if

2382
00:59:37,665 --> 00:59:38,535
0,135 135,270 270,390 390,675 675,870
you need to abort me,

2383
00:59:38,535 --> 00:59:39,450
0,165 165,465 465,630 630,765 765,915
just abort me to this

2384
00:59:39,450 --> 00:59:40,320
0,290
level.|
|

2385
00:59:41,740 --> 00:59:42,820
0,305 305,610
All right.|
好的。|

2386
00:59:43,920 --> 00:59:45,900
0,260 260,455 455,790 840,1240
The other side of.|
的另一边。|

2387
00:59:46,040 --> 00:59:47,740
0,350 350,560 560,965 965,1205 1205,1700
Dealing with deadlocks is deadlock
处理死锁就是防止死锁。

2388
00:59:47,740 --> 00:59:48,920
0,440
prevention.|
|

2389
00:59:48,930 --> 00:59:50,000
0,365 365,620 620,830 830,935 935,1070
So what it's going to
所以它要做的是。

2390
00:59:50,000 --> 00:59:50,960
0,120 120,380
do is.|
|

2391
00:59:50,960 --> 00:59:51,650
0,180 180,285 285,420 420,555 555,690
I'm going to stop the
我要在第一次碰触就打破僵局。

2392
00:59:51,650 --> 00:59:52,720
0,285 285,435 435,555 555,735 735,1070
deadlock at the first touch.|
|

2393
00:59:53,570 --> 00:59:54,460
0,400
Okay.|
好吧。|

2394
00:59:54,460 --> 00:59:56,935
0,350 430,830 1210,1610 1750,2295 2295,2475
And so, ah, here's what
所以，啊，这就是它要做的，假设两笔交易t1t2已经进入了系统。

2395
00:59:56,935 --> 00:59:58,975
0,135 135,285 285,575 895,1295 1675,2040
it will do, is imagine

2396
00:59:58,975 --> 01:00:00,460
0,240 240,515 745,1020 1170,1320 1320,1485
two transactions t 1 t

2397
01:00:00,460 --> 01:00:03,580
0,290 610,1010 1510,1910 2590,2880 2880,3120
two are, ah, have come

2398
01:00:03,580 --> 01:00:04,840
0,195 195,300 300,560
into the system.|
|

2399
01:00:04,840 --> 01:00:06,180
0,320
And?|
然后呢？|

2400
01:00:06,220 --> 01:00:09,465
0,320 320,640 810,1210 2220,2620 2940,3245
T one is older than
T1比t2早，所以第一个称为权重DIE的协议表示，如果正在请求的事务具有更高的优先级，那么它比事务更早，那么谁已经拥有锁？

2401
01:00:09,465 --> 01:00:10,860
0,210 210,515 805,1080 1080,1215 1215,1395
t two, so the first

2402
01:00:10,860 --> 01:00:13,010
0,620 640,975 975,1215 1215,1520 1750,2150
protocol called weight die says

2403
01:00:13,060 --> 01:00:15,180
0,400 780,1070 1070,1360 1620,1895 1895,2120
if the transaction that is

2404
01:00:15,180 --> 01:00:16,485
0,420 420,555 555,675 675,915 915,1305
requesting has a higher priority,

2405
01:00:16,485 --> 01:00:18,240
0,240 240,450 450,725 1345,1620 1620,1755
so it's older than the

2406
01:00:18,240 --> 01:00:19,425
0,260 310,615 615,825 825,1020 1020,1185
transaction, who already has the

2407
01:00:19,425 --> 01:00:20,340
0,275
lock?|
|

2408
01:00:20,340 --> 01:00:21,630
0,350 400,690 690,990 990,1125 1125,1290
Then what I'm going to
然后，我要做的就是允许该请求事务。啊，那么那个请求的交易就可以等了。

2409
01:00:21,630 --> 01:00:24,405
0,260 460,860 1000,1400 1690,2090 2380,2775
do is to allow that

2410
01:00:24,405 --> 01:00:27,440
0,435 435,725 1285,1685 2005,2405 2635,3035
requesting transaction. {Ah,,ah, -} ah,

2411
01:00:27,520 --> 01:00:30,195
0,400 750,1150 1800,2090 2090,2330 2330,2675
ah, ah, then the that

2412
01:00:30,195 --> 01:00:31,875
0,420 420,695 745,1035 1035,1325 1375,1680
requesting transaction can wait for

2413
01:00:31,875 --> 01:00:32,540
0,305
it.|
|

2414
01:00:32,540 --> 01:00:33,365
0,210 210,360 360,525 525,600 600,825
So if I'm an older
因此，如果我是较老的交易，我可以等待较年轻的交易。锁在谁手里？

2415
01:00:33,365 --> 01:00:34,535
0,365 385,750 750,900 900,1035 1035,1170
transaction, I'm allowed to wait

2416
01:00:34,535 --> 01:00:35,720
0,135 135,255 255,465 465,815 925,1185
for the younger transaction. {Who,has

2417
01:00:35,720 --> 01:00:36,800
0,165 165,330 330,590
-} the lock?|
|

2418
01:00:36,960 --> 01:00:37,925
0,275 275,425 425,680 680,800 800,965
Okay, so that's the way
好的，这就是领带的方式。

2419
01:00:37,925 --> 01:00:38,940
0,305
tie.|
|

2420
01:00:38,940 --> 01:00:41,100
0,240 240,510 510,855 855,1250
The wound weight is.|
伤口的重量是。|

2421
01:00:41,830 --> 01:00:43,230
0,245 245,410 410,730 930,1220 1220,1400
A little terrible, if you
如果你认为年老和年轻的类比，那就有点可怕了。这就像如果我是旧的交易，而年轻人拥有它，我可以取消它。

2422
01:00:43,230 --> 01:00:43,995
0,180 180,330 330,495 495,660 660,765
think the old and the

2423
01:00:43,995 --> 01:00:45,360
0,210 210,720 720,915 915,1155 1155,1365
young analogy. {It's,like -} if

2424
01:00:45,360 --> 01:00:46,395
0,240 240,345 345,480 480,765 765,1035
I'm the old transaction and

2425
01:00:46,395 --> 01:00:47,480
0,120 120,270 270,540 540,795 795,1085
the young person has it,

2426
01:00:47,680 --> 01:00:49,180
0,275 275,410 410,680 680,1000
I can abort it.|
|

2427
01:00:49,280 --> 01:00:51,250
0,730 1140,1445 1445,1670 1670,1835 1835,1970
Involuntarily and take away its
不由自主地拿走了它的锁。

2428
01:00:51,250 --> 01:00:52,280
0,470
locks.|
|

2429
01:00:52,280 --> 01:00:53,830
0,290 310,675 675,885 885,1200 1200,1550
So it's called wound weight,
所以这被称为伤口重量，这意味着我上了这笔交易，因为我年纪大了，我得到了他们拥有的锁。

2430
01:00:54,060 --> 01:00:55,085
0,275 275,440 440,605 605,815 815,1025
which means I wound the

2431
01:00:55,085 --> 01:00:56,795
0,275 505,765 765,945 945,1175 1435,1710
transaction because I'm older and

2432
01:00:56,795 --> 01:00:57,980
0,150 150,315 315,465 465,900 900,1185
I get the locks that

2433
01:00:57,980 --> 01:00:58,940
0,150 150,410
they have.|
|

2434
01:00:59,480 --> 01:01:00,685
0,305 305,485 485,650 650,875 875,1205
Both of them will prevent
他们两个都会阻止这种循环的发生，对吗？因为当有人开始等待，艺术开始形成我的那一刻，你就会说，哎呀，让我们杀了它。

2435
01:01:00,685 --> 01:01:02,095
0,285 285,570 570,840 840,1095 1095,1410
that cycle from happening, right?

2436
01:01:02,095 --> 01:01:03,265
0,195 195,300 300,540 540,900 900,1170
Because the minute someone starts

2437
01:01:03,265 --> 01:01:04,165
0,150 150,270 270,420 420,645 645,900
to wait and art starts

2438
01:01:04,165 --> 01:01:04,720
0,150 150,255 255,330 330,465 465,555
to form me, you're saying,

2439
01:01:04,720 --> 01:01:06,120
0,330 330,570 570,690 690,950
whoops, let's kill it.|
|

2440
01:01:06,180 --> 01:01:07,180
0,245 245,380 380,440 440,635 635,1000
So it's a little aggressive,
所以它有点侵略性，但它不需要保持图形的权重，也不需要通过这个锁表之类的东西。因此，这样做更简单，但可能更浪费。

2441
01:01:07,590 --> 01:01:09,395
0,400 600,890 890,1205 1205,1475 1475,1805
but it doesn't require maintaining

2442
01:01:09,395 --> 01:01:10,670
0,255 255,435 435,705 705,1170 1170,1275
the weight for graphs and

2443
01:01:10,670 --> 01:01:11,660
0,120 120,390 390,615 615,825 825,990
it doesn't require going through

2444
01:01:11,660 --> 01:01:13,070
0,135 135,330 330,650 850,1170 1170,1410
this lock table and stuff

2445
01:01:13,070 --> 01:01:14,990
0,210 210,500 610,1010 1450,1755 1755,1920
like that. {And,hence -} it

2446
01:01:14,990 --> 01:01:16,190
0,240 240,750 750,870 870,1020 1020,1200
is simpler in that way,

2447
01:01:16,190 --> 01:01:17,760
0,165 165,375 375,600 600,1130
but maybe more wasteful.|
|

2448
01:01:19,280 --> 01:01:20,305
0,290 290,440 440,590 590,800 800,1025
And so if you want
如果你想看上面的例子，让我们来看看。

2449
01:01:20,305 --> 01:01:21,420
0,150 150,255 255,450 450,750 750,1115
to look at an example

2450
01:01:22,310 --> 01:01:23,950
0,290 290,500 500,820 1140,1520 1520,1640
up over here, let's just

2451
01:01:23,950 --> 01:01:26,040
0,290 880,1170 1170,1460
go look at.|
|

2452
01:01:26,040 --> 01:01:27,590
0,260 610,975 975,1125 1125,1290 1290,1550
That you've got the first
在第一种情况下，t1后面紧跟t2，我们将按时间戳计算。所以在这两个例子中，t1都比t2老。所以当t1在等待t2的时候，因为t2已经锁定了等待模具中的a，所以t1被允许等待。它更老了，所以可以等一等。

2453
01:01:27,700 --> 01:01:28,950
0,365 365,635 635,905 905,1055 1055,1250
situation where there's t one

2454
01:01:28,950 --> 01:01:30,405
0,225 225,435 435,615 615,920 1090,1455
followed by t two, we'll

2455
01:01:30,405 --> 01:01:31,905
0,245 295,600 600,1125 1125,1320 1320,1500
go by timestamp. {So,t -}

2456
01:01:31,905 --> 01:01:33,360
0,210 210,435 435,755 955,1245 1245,1455
one is older than t

2457
01:01:33,360 --> 01:01:34,910
0,320 430,735 735,945 945,1200 1200,1550
two in both these {examples.,And

2458
01:01:35,500 --> 01:01:37,230
0,335 335,670 900,1220 1220,1475 1475,1730
-} so when t one

2459
01:01:37,230 --> 01:01:38,850
0,255 255,590 730,1095 1095,1365 1365,1620
is waiting for t two,

2460
01:01:38,850 --> 01:01:39,795
0,240 240,405 405,585 585,780 780,945
because t two already had

2461
01:01:39,795 --> 01:01:41,415
0,135 135,375 375,675 675,995 1255,1620
the lock on a in

2462
01:01:41,415 --> 01:01:42,480
0,225 225,405 405,690 690,930 930,1065
the wait die, t one

2463
01:01:42,480 --> 01:01:43,620
0,165 165,345 345,480 480,740 790,1140
is allowed {to,wait. -} It's

2464
01:01:43,620 --> 01:01:44,990
0,230 580,840 840,960 960,1095 1095,1370
older so it can wait.|
|

2465
01:01:45,620 --> 01:01:47,110
0,400 690,965 965,1115 1115,1280 1280,1490
But if it is wound
但如果是伤口重量，那就不好了。它会扼杀你取得进步。

2466
01:01:47,110 --> 01:01:49,000
0,320 640,960 960,1280 1420,1725 1725,1890
weight, t one will be

2467
01:01:49,000 --> 01:01:50,580
0,465 465,795 795,945 945,1140 1305,1580
nasty. {It'll,kill -} t 2

2468
01:01:50,870 --> 01:01:52,360
0,320 320,640
make progress.|
|

2469
01:01:55,020 --> 01:01:56,680
0,380 380,680 680,875 875,1150 1260,1660
The other way around is
另一种方式是t两个进来，现在想要对旧事务已有的东西提出请求。这种情况在分量上发生了反转。第二架飞机将中止飞行。这就像年轻人不能等老年人，而伤口重量表明，是的，好的，如果你更年轻，你可以等待。

2470
01:01:57,330 --> 01:01:58,505
0,320 320,545 545,770 770,980 980,1175
t two comes in and

2471
01:01:58,505 --> 01:01:59,735
0,305 445,765 765,930 930,1035 1035,1230
now wants to make a

2472
01:01:59,735 --> 01:02:00,830
0,270 270,465 465,690 690,945 945,1095
request for something that the

2473
01:02:00,830 --> 01:02:02,945
0,225 225,590 670,1070 1360,1755 1755,2115
older transaction has. {The,situation -}

2474
01:02:02,945 --> 01:02:04,355
0,345 345,690 690,990 990,1200 1200,1410
flips around in {weight.,I -}

2475
01:02:04,355 --> 01:02:05,345
0,195 195,345 345,465 465,735 735,990
t two {will,abort. -} It's

2476
01:02:05,345 --> 01:02:06,320
0,135 135,315 315,540 540,840 840,975
like young people can't wait

2477
01:02:06,320 --> 01:02:07,835
0,165 165,360 360,680 1000,1305 1305,1515
for old people and wound

2478
01:02:07,835 --> 01:02:09,170
0,225 225,495 495,795 795,1110 1110,1335
weight says yeah, fine, if

2479
01:02:09,170 --> 01:02:10,120
0,180 180,360 360,570 570,690 690,950
you're younger, you can wait.|
|

2480
01:02:11,190 --> 01:02:12,380
0,275 275,515 515,755 755,980 980,1190
Okay, so you follow one
好的，所以你要遵守其中一项协议。你可以像这样错配，对吗？否则它不会起作用的。所以你只需遵循其中一项协议。从本质上讲，它说的是，一旦我以某种方式决定了圆弧的方向在图的权重中所占的位置。

2481
01:02:12,380 --> 01:02:13,250
0,120 120,270 270,660 660,735 735,870
of those protocols. {You,can -}

2482
01:02:13,250 --> 01:02:14,435
0,420 420,615 615,795 795,975 975,1185
mismatch like that, right? Otherwise

2483
01:02:14,435 --> 01:02:15,650
0,210 210,420 420,665 865,1110 1110,1215
it won't {work.,So -} you

2484
01:02:15,650 --> 01:02:16,400
0,135 135,330 330,510 510,630 630,750
just follow one of {the,protocols.

2485
01:02:16,400 --> 01:02:18,440
0,645 645,1005 1005,1230 1230,1490 1750,2040
-} Essentially, it says as

2486
01:02:18,440 --> 01:02:19,550
0,180 180,375 375,630 630,900 900,1110
soon as I decide in

2487
01:02:19,550 --> 01:02:20,750
0,240 240,555 555,810 810,990 990,1200
some way in which the

2488
01:02:20,750 --> 01:02:21,760
0,240 240,420 420,525 525,765 765,1010
direction of the arc holds

2489
01:02:22,230 --> 01:02:23,500
0,290 290,470 470,770 770,950 950,1270
in that weights for graph.|
|

2490
01:02:24,070 --> 01:02:24,975
0,260 260,395 395,545 545,710 710,905
As soon as I see
一旦我看到一道弧线出现，我就会停下来。

2491
01:02:24,975 --> 01:02:26,325
0,180 180,510 510,755 835,1140 1140,1350
an arc happening, I stop

2492
01:02:26,325 --> 01:02:27,100
0,305
it.|
|

2493
01:02:27,100 --> 01:02:27,940
0,150 150,390 390,510 510,630 630,840
That doesn't mean the cycle
这并不意味着循环已经形成。我只是不喜欢牛津大学。如果你不允许弧线形成，就不会形成循环，对吗？

2494
01:02:27,940 --> 01:02:29,035
0,225 225,480 480,720 720,870 870,1095
is formed. {I,just -} don't

2495
01:02:29,035 --> 01:02:30,330
0,150 150,660 660,855 855,960 960,1295
form {Oxford.,If -} you don't

2496
01:02:30,890 --> 01:02:32,065
0,290 290,635 635,770 770,965 965,1175
allow arcs to form, no

2497
01:02:32,065 --> 01:02:33,600
0,300 300,465 465,675 675,995
cycles will form, right?|
|

2498
01:02:35,780 --> 01:02:36,865
0,275 275,410 410,545 545,785 785,1085
So you can only follow
所以你只能跟着一个。

2499
01:02:36,865 --> 01:02:37,120
0,225
one.|
|

2500
01:02:37,830 --> 01:02:39,140
0,245 245,350 350,610 810,1175 1175,1310
So what happens? Don't mix
那么会发生什么呢？不要在同一系统中混搭。你只需要遵循一个，否则它就不会起作用。是的，你会惹上麻烦的。

2501
01:02:39,140 --> 01:02:39,890
0,165 165,330 330,480 480,585 585,750
and match in the same

2502
01:02:39,890 --> 01:02:40,640
0,255 255,435 435,540 540,630 630,750
system. {You,have -} to follow

2503
01:02:40,640 --> 01:02:41,660
0,225 225,435 435,630 630,810 810,1020
only one, otherwise it won't

2504
01:02:41,660 --> 01:02:42,650
0,240 240,585 585,750 750,900 900,990
{work.,You'll -} get into a

2505
01:02:42,650 --> 01:02:43,880
0,260 610,1010
mess, yeah.|
|

2506
01:02:45,010 --> 01:02:45,930
0,335 335,515 515,620 620,800 800,920
Yep. {So,you -} can't mix
是啊。所以你不能混杂在一起，然后说，为了这个部分，我会做那个。这一部分，就像遵循一个协议一样。

2507
01:02:45,930 --> 01:02:46,920
0,165 165,345 345,540 540,780 780,990
and match and say, for

2508
01:02:46,920 --> 01:02:47,760
0,150 150,330 330,570 570,675 675,840
this part, I'll do {that.,This

2509
01:02:47,760 --> 01:02:48,915
0,165 165,440 460,840 840,990 990,1155
-} part, it's just like

2510
01:02:48,915 --> 01:02:50,300
0,180 180,375 375,905
follow one protocol.|
|

2511
01:02:51,660 --> 01:02:52,715
0,275 275,425 425,680 680,875 875,1055
So which one's better for
那么在什么情况下哪一个更好呢？啊，这是一个很好的问题，对这两个问题都没有一个非常好的答案。我认为这取决于应用程序、工作负载和场景。但你知道，人们仍在研究如何打破僵局，以及如何应对。所以这是一个悬而未决的问题。但没有，啊，据我所知，没有一个非常好的证据可以证明a比b更好。

2512
01:02:52,715 --> 01:02:54,230
0,135 135,425 805,1140 1140,1410 1410,1515
what scenario? Ah, that's a

2513
01:02:54,230 --> 01:02:56,165
0,165 165,470 640,1040 1390,1665 1665,1935
great question and there isn't

2514
01:02:56,165 --> 01:02:57,440
0,135 135,345 345,675 675,1020 1020,1275
a very, just very good

2515
01:02:57,440 --> 01:02:58,820
0,290 490,810 810,1020 1020,1185 1185,1380
answer for both of that.

2516
01:02:58,820 --> 01:02:59,840
0,180 180,315 315,540 540,765 765,1020
{I,think -} it's like depends

2517
01:02:59,840 --> 01:03:00,815
0,150 150,375 375,660 660,855 855,975
on the application and the

2518
01:03:00,815 --> 01:03:03,220
0,360 360,510 510,645 645,905 2005,2405
workload and the {scenario.,But, -}

2519
01:03:03,270 --> 01:03:04,655
0,275 275,440 440,680 680,1010 1010,1385
you know, people still research

2520
01:03:04,655 --> 01:03:06,380
0,395 565,960 960,1305 1305,1530 1530,1725
into what ways to break

2521
01:03:06,380 --> 01:03:07,820
0,495 495,740 850,1140 1140,1290 1290,1440
deadlocks and what to do

2522
01:03:07,820 --> 01:03:09,080
0,165 165,440 760,1020 1020,1185 1185,1260
{with,that. -} So it's {an,open

2523
01:03:09,080 --> 01:03:10,385
0,240 240,615 615,900 900,1065 1065,1305
-} question. But there isn't,

2524
01:03:10,385 --> 01:03:11,540
0,275 445,750 750,915 915,1035 1035,1155
ah, not that I know

2525
01:03:11,540 --> 01:03:12,875
0,135 135,300 300,590 820,1110 1110,1335
of a very a proof

2526
01:03:12,875 --> 01:03:13,775
0,225 225,435 435,615 615,735 735,900
that says a is better

2527
01:03:13,775 --> 01:03:14,520
0,195 195,485
than b.|
|

2528
01:03:15,760 --> 01:03:16,545
0,230 230,320 320,440 440,605 605,785
And if you find one,
如果你找到了，告诉我。

2529
01:03:16,545 --> 01:03:17,540
0,135 135,255 255,515
let me know.|
|

2530
01:03:19,010 --> 01:03:19,920
0,400
Okay.|
好吧。|

2531
01:03:20,020 --> 01:03:21,240
0,400
So.|
所以。|

2532
01:03:21,470 --> 01:03:23,200
0,335 335,530 530,880 1260,1550 1550,1730
We've talked about why these
我们已经讨论了为什么这些保证为什么这些系统有效。你知道，希望你能理解，当我们处理交易时，我们喜欢把事情想象成图形和循环是不好的。所有的依赖图和等待图都在发生，我们正在努力，我们基本上是在寻找不形成这些循环的方法。

2533
01:03:23,200 --> 01:03:25,045
0,555 555,765 765,1035 1035,1430 1450,1845
guarantees why these systems work.

2534
01:03:25,045 --> 01:03:26,260
0,270 270,480 480,795 795,1050 1050,1215
{You,know, -} hopefully you're getting

2535
01:03:26,260 --> 01:03:27,445
0,350 370,675 675,855 855,1005 1005,1185
to understand that when we

2536
01:03:27,445 --> 01:03:29,275
0,285 285,555 555,845 1345,1635 1635,1830
deal with transactions, we like

2537
01:03:29,275 --> 01:03:30,790
0,195 195,735 735,915 915,1125 1125,1515
to visualize things as graphs

2538
01:03:30,790 --> 01:03:32,245
0,150 150,510 510,660 660,920 1150,1455
and cycles are {bad.,And -}

2539
01:03:32,245 --> 01:03:33,835
0,305 385,750 750,995 1075,1380 1380,1590
all that's happening across the

2540
01:03:33,835 --> 01:03:34,825
0,315 315,540 540,660 660,810 810,990
dependence graphs and wait for

2541
01:03:34,825 --> 01:03:35,830
0,270 270,390 390,510 510,735 735,1005
graphs is we are trying

2542
01:03:35,830 --> 01:03:37,555
0,290 850,1080 1080,1155 1155,1395 1395,1725
to, we are basically finding

2543
01:03:37,555 --> 01:03:38,380
0,240 240,405 405,540 540,690 690,825
ways to not have these

2544
01:03:38,380 --> 01:03:39,560
0,300 300,480 480,770
cycles get formed.|
|

2545
01:03:41,460 --> 01:03:44,000
0,290 290,580 930,1330 1950,2270 2270,2540
All right, so so far
好的，到目前为止，我们讨论的是所有这些方案，我们有从数据库、对象到锁的一对一映射。

2546
01:03:44,000 --> 01:03:45,280
0,225 225,435 435,630 630,930 930,1280
what we've talked about is

2547
01:03:45,480 --> 01:03:46,985
0,335 335,670 690,1130 1130,1265 1265,1505
all these schemes that we

2548
01:03:46,985 --> 01:03:49,025
0,365 775,1175 1405,1695 1695,1890 1890,2040
have have a one to

2549
01:03:49,025 --> 01:03:50,120
0,135 135,540 540,720 720,855 855,1095
one mapping from the database,

2550
01:03:50,120 --> 01:03:51,780
0,375 375,630 630,735 735,1160
objects to the locks.|
|

2551
01:03:51,780 --> 01:03:52,590
0,135 135,270 270,390 390,555 555,810
And if you want to
如果你想更新十亿条记录，就像我们刚才提到的，啊，啊，在课程开始的时候，我们买了十亿把锁，这是非常昂贵的，对吧？更改哈希表是相当昂贵的，我们可以做得更好吗？

2552
01:03:52,590 --> 01:03:54,615
0,285 285,510 510,780 780,1160 1720,2025
update a billion records, as

2553
01:03:54,615 --> 01:03:55,820
0,165 165,360 360,645 645,900 900,1205
we just mentioned, ah, ah,

2554
01:03:56,290 --> 01:03:57,210
0,320 320,470 470,620 620,800 800,920
towards the beginning of the

2555
01:03:57,210 --> 01:03:58,605
0,260 430,735 735,960 960,1215 1215,1395
class, then we acquired a

2556
01:03:58,605 --> 01:04:00,480
0,210 210,815 1135,1410 1410,1650 1650,1875
billion locks and that's very

2557
01:04:00,480 --> 01:04:02,970
0,380 760,1160 1660,1995 1995,2280 2280,2490
expensive, right? Making changes to

2558
01:04:02,970 --> 01:04:03,810
0,105 105,285 285,420 420,600 600,840
the hash table is pretty

2559
01:04:03,810 --> 01:04:05,960
0,350 760,1160 1420,1725 1725,1890 1890,2150
expensive and can we do

2560
01:04:05,980 --> 01:04:06,960
0,400
better?|
|

2561
01:04:07,100 --> 01:04:08,240
0,400
So.|
所以。|

2562
01:04:09,890 --> 01:04:11,120
0,400
Um.|
恩。|

2563
01:04:11,540 --> 01:04:12,840
0,260 260,395 395,545 545,820 900,1300
There is this notion called.|
有一个概念叫做。|

2564
01:04:13,700 --> 01:04:16,240
0,920 1030,1380 1380,1970
Hierarchies of locking.|
锁定的层次结构。|

2565
01:04:16,240 --> 01:04:16,885
0,75 75,225 225,345 345,495 495,645
And its based on a
它基于一个非常简单的观察，说的是数据库对象。让我们来考虑一张唱片。

2566
01:04:16,885 --> 01:04:19,890
0,255 255,635 715,1115 1765,2165 2605,3005
very simple observation, saying database

2567
01:04:19,970 --> 01:04:21,415
0,400 570,935 935,1100 1100,1295 1295,1445
objects. {Let's,think -} about a

2568
01:04:21,415 --> 01:04:22,360
0,275
record.|
|

2569
01:04:22,520 --> 01:04:24,580
0,470 470,695 695,980 980,1330 1770,2060
Doesn't sit by itself. {We,put
不是一个人坐着的。我们把唱片一页一页地放进书页。我们把页面放进表格，把表格放进数据库，所以我们有一个层次结构。

2570
01:04:24,580 --> 01:04:26,530
0,180 180,470 490,765 765,1040 1660,1950
-} record into {pages.,We -}

2571
01:04:26,530 --> 01:04:28,650
0,180 180,470 610,870 870,1130 1720,2120
put pages into tables, tables

2572
01:04:28,730 --> 01:04:30,400
0,245 245,940 1140,1415 1415,1550 1550,1670
into databases, so we have

2573
01:04:30,400 --> 01:04:32,540
0,105 105,855 855,1190
a hierarchical structure.|
|

2574
01:04:32,540 --> 01:04:34,070
0,290 400,690 690,1095 1095,1380 1380,1530
For how we've organized the
我们是如何组织数据的。

2575
01:04:34,070 --> 01:04:35,020
0,260
data.|
|

2576
01:04:35,210 --> 01:04:36,550
0,260 260,395 395,575 575,755 755,1340
And in fact, that hierarchical
事实上，这种层次结构也是我们访问数据的方式，对吗？

2577
01:04:36,550 --> 01:04:37,590
0,180 180,330 330,540 540,765 765,1040
structure is also how we

2578
01:04:37,700 --> 01:04:39,340
0,305 305,485 485,725 725,1090
access the data, right?|
|

2579
01:04:39,340 --> 01:04:41,275
0,150 150,440 1030,1410 1410,1725 1725,1935
In the execution code that
在您为操作符编写的执行代码中，您将打开一个文件并开始扫描记录。

2580
01:04:41,275 --> 01:04:42,280
0,150 150,345 345,525 525,630 630,1005
you wrote for your operators,

2581
01:04:42,280 --> 01:04:43,315
0,270 270,450 450,660 660,825 825,1035
you'll open a file and

2582
01:04:43,315 --> 01:04:44,880
0,240 240,585 585,690 690,935
start scanning the record.|
|

2583
01:04:44,980 --> 01:04:45,825
0,290 290,485 485,605 605,740 740,845
First you'll start with the
首先，您将从数据库开始，然后是表，然后是页面，然后是记录，所以您遵循的是层次结构。所以问题是，我们能做到吗？

2584
01:04:45,825 --> 01:04:47,480
0,245 265,555 555,780 780,1115 1255,1655
database, then the the table,

2585
01:04:48,340 --> 01:04:50,010
0,320 320,635 635,905 905,1180 1380,1670
and then the pages, and

2586
01:04:50,010 --> 01:04:51,150
0,180 180,315 315,560 760,990 990,1140
then the records, so you're

2587
01:04:51,150 --> 01:04:53,220
0,230 250,525 525,1170 1170,1490 1810,2070
following that hierarchical structure. {So,the

2588
01:04:53,220 --> 01:04:54,710
0,135 135,360 360,710 790,1140 1140,1490
-} question is, can we?|
|

2589
01:04:55,700 --> 01:04:57,865
0,350 350,700 1200,1625 1625,2030 2030,2165
Try to acquire locks at
尝试获取不同粒度的锁。

2590
01:04:57,865 --> 01:05:00,200
0,275 295,1505
different granularities.|
|

2591
01:05:00,330 --> 01:05:01,160
0,245 245,365 365,530 530,695 695,830
So I could have a
所以我可以有一个页面级锁，一个记录级锁，对不起，一个在列级的锁，但也可以是一个表级锁或一个数据库级锁。

2592
01:05:01,160 --> 01:05:02,525
0,210 210,495 495,830 850,1125 1125,1365
page level lock, a record

2593
01:05:02,525 --> 01:05:03,905
0,300 300,635 655,930 930,1140 1140,1380
level lock, a sorry a

2594
01:05:03,905 --> 01:05:05,540
0,300 300,660 660,945 945,1265 1345,1635
at column level lock, but

2595
01:05:05,540 --> 01:05:06,970
0,285 285,555 555,795 795,1095 1095,1430
also a table level lock

2596
01:05:07,050 --> 01:05:08,650
0,380 380,620 620,880 930,1265 1265,1600
or a database level lock.|
|

2597
01:05:09,280 --> 01:05:11,200
0,380 760,1095 1095,1350 1350,1560 1560,1920
And allow mix and matching
并允许混合和匹配所有这些。哦，顺便说一句，让我们也有不同类型的锁，有些更放松。因此，这听起来很奇怪。但这就是为什么这篇论文所取得的突破以及IBM和吉姆·格雷所做的工作如此令人兴奋，完全改变了这一领域。

2598
01:05:11,200 --> 01:05:12,595
0,120 120,285 285,450 450,710 1090,1395
of all of those. {Oh,,and

2599
01:05:12,595 --> 01:05:13,570
0,195 195,345 345,480 480,690 690,975
-} by the way, let's

2600
01:05:13,570 --> 01:05:14,950
0,180 180,465 465,800 880,1185 1185,1380
also have different types of

2601
01:05:14,950 --> 01:05:16,240
0,495 495,780 780,945 945,1080 1080,1290
locks, some that are more

2602
01:05:16,240 --> 01:05:17,335
0,390 390,555 555,720 720,915 915,1095
{relaxed.,So -} that sounds {like,bizarre.

2603
01:05:17,335 --> 01:05:18,700
0,525 525,750 750,960 960,1110 1110,1365
-} But that's why the,

2604
01:05:18,700 --> 01:05:20,905
0,255 255,735 735,1010 1240,1640 1810,2205
the breakthrough that ah, this

2605
01:05:20,905 --> 01:05:22,135
0,300 300,600 600,900 900,1095 1095,1230
this paper had and the

2606
01:05:22,135 --> 01:05:23,140
0,135 135,300 300,690 690,825 825,1005
work that IBM and Jim

2607
01:05:23,140 --> 01:05:25,320
0,195 195,500 550,950 1060,1460 1780,2180
gray did was so exciting

2608
01:05:25,460 --> 01:05:26,760
0,305 305,575 575,860 860,1040 1040,1300
and totally changed the field.|
|

2609
01:05:27,510 --> 01:05:28,690
0,275 275,620 620,740 740,890 890,1180
So here's how it looks.|
这就是它看起来的样子。|

2610
01:05:29,520 --> 01:05:31,210
0,260 260,365 365,470 470,730 1290,1690
I have a database structure
我有一个数据库结构层次结构。数据库有表，表有页，页有记录，记录有列或属性。

2611
01:05:31,230 --> 01:05:33,530
0,770 770,1460 1460,1640 1640,1930 1950,2300
hierarchy. {Databases,have -} tables, tables

2612
01:05:33,530 --> 01:05:34,960
0,225 225,500 520,885 885,1140 1140,1430
have pages, pages have records,

2613
01:05:35,190 --> 01:05:36,545
0,305 305,545 545,740 740,1100 1100,1355
and records have columns or

2614
01:05:36,545 --> 01:05:37,680
0,485
attributes.|
|

2615
01:05:37,810 --> 01:05:38,655
0,275 275,455 455,605 605,755 755,845
So now what I'm going
所以现在我要做的是，我将说我将允许，啊，所以如果我有事务t 1，如果它想要获取表级锁，就像我可以锁定表对象，并且隐式地锁定它下面的所有东西。

2616
01:05:38,655 --> 01:05:39,735
0,120 120,365 535,810 810,945 945,1080
to do is I will

2617
01:05:39,735 --> 01:05:40,730
0,135 135,345 345,480 480,690 690,995
say I'm going to allow,

2618
01:05:41,230 --> 01:05:43,620
0,400 1530,1895 1895,2120 2120,2300 2300,2390
ah, so if I've got

2619
01:05:43,620 --> 01:05:45,225
0,135 135,410 520,810 810,1100 1330,1605
to transaction t one, if

2620
01:05:45,225 --> 01:05:46,755
0,150 150,345 345,665 775,1205 1225,1530
it wants to acquire a

2621
01:05:46,755 --> 01:05:48,360
0,300 300,630 630,965 1105,1470 1470,1605
table level lock, it's kind

2622
01:05:48,360 --> 01:05:49,290
0,180 180,405 405,600 600,750 750,930
of like I can lock

2623
01:05:49,290 --> 01:05:51,030
0,150 150,360 360,705 705,1005 1005,1740
the table object and implicitly

2624
01:05:51,030 --> 01:05:52,220
0,165 165,405 405,735 735,930 930,1190
it's locked everything below it.|
|

2625
01:05:53,640 --> 01:05:54,790
0,350 350,575 575,770 770,920 920,1150
Okay, so now, instead of
好的，现在，我不会锁定十亿条记录，而是只锁定表，因为我正在扫描整个表。

2626
01:05:54,990 --> 01:05:56,930
0,425 425,560 560,845 845,1240 1590,1940
locking a billion records, I'll

2627
01:05:56,930 --> 01:05:57,875
0,135 135,330 330,465 465,705 705,945
just lock the table because

2628
01:05:57,875 --> 01:05:58,780
0,165 165,405 405,510 510,630 630,905
I'm scanning the whole table.|
|

2629
01:05:59,790 --> 01:06:01,415
0,335 335,650 650,1030 1230,1505 1505,1625
Way cheaper, right? And I
便宜多了，对吧？我能把我们所说的一切都说对吗？

2630
01:06:01,415 --> 01:06:02,300
0,105 105,345 345,615 615,765 765,885
can make everything that we

2631
01:06:02,300 --> 01:06:03,680
0,195 195,480 480,830
talked about correct?|
|

2632
01:06:03,960 --> 01:06:05,090
0,320 320,575 575,740 740,950 950,1130
And we'll talk about this
我们将在非常高的层次上讨论这一协议。上面有一整张纸。这需要一堂完整的课才能讲完。这一点我们将在数据库系统课上讲到。但希望你能直觉地知道它是如何工作的。

2633
01:06:05,090 --> 01:06:06,095
0,390 390,510 510,615 615,780 780,1005
protocol at a very high

2634
01:06:06,095 --> 01:06:07,385
0,305 415,765 765,840 840,1005 1005,1290
level. {There's,a -} whole paper

2635
01:06:07,385 --> 01:06:08,180
0,225 225,360 360,510 510,660 660,795
on {it.,It -} takes a

2636
01:06:08,180 --> 01:06:09,215
0,150 150,435 435,690 690,855 855,1035
full lecture to go {through,this.

2637
01:06:09,215 --> 01:06:10,745
0,275 385,705 705,1020 1020,1395 1395,1530
-} And again, that's going

2638
01:06:10,745 --> 01:06:11,435
0,105 105,180 180,360 360,555 555,690
to be talked about in

2639
01:06:11,435 --> 01:06:13,280
0,135 135,395 1015,1410 1410,1695 1695,1845
the {database,systems -} class. But

2640
01:06:13,280 --> 01:06:14,240
0,210 210,405 405,525 525,630 630,960
hopefully you get the intuition

2641
01:06:14,240 --> 01:06:15,640
0,210 210,345 345,495 495,770
for how it works.|
|

2642
01:06:15,640 --> 01:06:17,640
0,380 790,1185 1185,1530 1530,1740 1740,2000
So database systems will actually
所以数据库系统实际上会允许这样的事情。他们会说，你知道吗，你可以在内部锁定机制在数据库级别锁定，这是非常罕见的。我们谈到了在MongoDB的早期，这是他们在数据库级别允许的唯一锁，因为它很容易实现。

2643
01:06:17,660 --> 01:06:18,955
0,320 320,575 575,785 785,995 995,1295
allow things like that. {They'll,say,

2644
01:06:18,955 --> 01:06:19,720
0,120 120,270 270,405 405,585 585,765
-} you know what, you

2645
01:06:19,720 --> 01:06:21,720
0,260 700,1095 1095,1365 1365,1725 1725,2000
can the, the locking mechanism

2646
01:06:21,890 --> 01:06:23,200
0,620 620,860 860,1025 1025,1175 1175,1310
internally can lock at the

2647
01:06:23,200 --> 01:06:24,325
0,255 255,570 570,750 750,900 900,1125
database level, which is pretty

2648
01:06:24,325 --> 01:06:25,735
0,335 535,795 795,975 975,1185 1185,1410
{rare.,We -} talked about how

2649
01:06:25,735 --> 01:06:26,680
0,225 225,360 360,555 555,780 780,945
in the early days of

2650
01:06:26,680 --> 01:06:28,645
0,770 790,1260 1260,1380 1380,1635 1635,1965
mongodb that's the only lock

2651
01:06:28,645 --> 01:06:29,605
0,225 225,405 405,570 570,705 705,960
they allowed at the database

2652
01:06:29,605 --> 01:06:30,910
0,395 445,705 705,840 840,1020 1020,1305
level because it was easy

2653
01:06:30,910 --> 01:06:32,100
0,315 315,650
to implement.|
|

2654
01:06:32,140 --> 01:06:33,060
0,245 245,350 350,515 515,710 710,920
And of course they change
当然，它们改变了它很容易实现，你得到了正确性，但没有并行性，对吗？因此，业绩受到了影响。

2655
01:06:33,060 --> 01:06:34,305
0,315 315,660 660,810 810,1020 1020,1245
the it's easy to implement,

2656
01:06:34,305 --> 01:06:35,385
0,180 180,375 375,765 765,930 930,1080
you get correctness, but no

2657
01:06:35,385 --> 01:06:37,280
0,555 555,735 735,1020 1020,1380 1380,1895
parallelism, right? So performance suffers.|
|

2658
01:06:37,900 --> 01:06:39,685
0,290 310,710 730,1130 1210,1545 1545,1785
But database systems now have
但数据库系统现在有这些阻塞的层次结构。表级锁对于已经实现的系统来说是非常常见的。页面级别也很常见，而且很容易放置。正如您可以想象的那样，第一次访问缓冲池中的页面是在可以访问的时候。缓冲区管理器可以请求锁表的内容。当您打开文件时，可以正确地提出该请求。如果您正在执行记录级别锁定，那么当您扫描页面中的记录时，就可以发出该请求。在极少数情况下，系统还会执行属性级别锁定。

2659
01:06:39,685 --> 01:06:41,635
0,210 210,840 840,1065 1065,1605 1605,1950
these hierarchy of blocking. {Table,level

2660
01:06:41,635 --> 01:06:42,850
0,285 285,510 510,705 705,915 915,1215
-} lock is very common

2661
01:06:42,850 --> 01:06:44,280
0,360 360,720 720,930 930,1095 1095,1430
for systems to have {implemented.,Page

2662
01:06:44,570 --> 01:06:46,030
0,335 335,590 590,860 860,1190 1190,1460
-} level is also very

2663
01:06:46,030 --> 01:06:46,990
0,225 225,390 390,555 555,705 705,960
common and it's very easy

2664
01:06:46,990 --> 01:06:47,695
0,195 195,315 315,450 450,555 555,705
{to,put. -} As you can

2665
01:06:47,695 --> 01:06:49,075
0,305 475,735 735,915 915,1125 1125,1380
imagine, the first time you

2666
01:06:49,075 --> 01:06:49,795
0,225 225,330 330,465 465,615 615,720
access a page in the

2667
01:06:49,795 --> 01:06:50,710
0,270 270,450 450,645 645,795 795,915
buffer pool is when {you,can

2668
01:06:50,710 --> 01:06:52,285
0,135 135,410 820,1080 1080,1350 1350,1575
-} go. The buffer manager

2669
01:06:52,285 --> 01:06:53,425
0,225 225,360 360,570 570,885 885,1140
can make a request for

2670
01:06:53,425 --> 01:06:54,910
0,135 135,575 685,1065 1065,1335 1335,1485
{the,locks -} table stuff. When

2671
01:06:54,910 --> 01:06:56,065
0,105 105,300 300,495 495,740 790,1155
you open the file, that

2672
01:06:56,065 --> 01:06:57,420
0,255 255,420 420,540 540,785 955,1355
{request,can -} be made right.

2673
01:06:57,530 --> 01:06:59,200
0,260 260,470 470,700 810,1210 1320,1670
If you're doing a record

2674
01:06:59,200 --> 01:07:00,715
0,270 270,800 820,1125 1125,1290 1290,1515
level locking, then when you're

2675
01:07:00,715 --> 01:07:02,050
0,345 345,480 480,755 775,1125 1125,1335
scanning the records in the

2676
01:07:02,050 --> 01:07:03,670
0,260 670,975 975,1155 1155,1380 1380,1620
page is {when,that -} request

2677
01:07:03,670 --> 01:07:05,160
0,165 165,300 300,560 700,1095 1095,1490
can be made. And very

2678
01:07:05,180 --> 01:07:07,045
0,400 450,845 845,1205 1205,1520 1520,1865
rarely, systems also do attribute

2679
01:07:07,045 --> 01:07:07,960
0,210 210,725
level locking.|
|

2680
01:07:08,150 --> 01:07:09,055
0,245 245,320 320,410 410,620 620,905
So in a system that
因此，在支持属性级别锁定的系统中，显然您可以执行更多的并行性，因为。

2681
01:07:09,055 --> 01:07:10,680
0,330 330,750 750,975 975,1335 1335,1625
supports attribute level locking, obviously

2682
01:07:10,880 --> 01:07:11,620
0,245 245,365 365,500 500,605 605,740
you can do a lot

2683
01:07:11,620 --> 01:07:13,840
0,165 165,830 1150,1550
more parallelism because.|
|

2684
01:07:13,940 --> 01:07:15,600
0,395 395,575 575,860 860,1130 1130,1660
I'm doing record level locking
我正在进行创纪录级别的锁定2笔交易。其中一个想要更新一个列，另一个想要更新另一个列。他们真的不冲突。

2685
01:07:16,120 --> 01:07:17,365
0,210 210,500 730,990 990,1110 1110,1245
2 transactions. {One,of -} them

2686
01:07:17,365 --> 01:07:19,495
0,195 195,480 480,845 1495,1815 1815,2130
wants to update one column,

2687
01:07:19,495 --> 01:07:20,425
0,240 240,375 375,525 525,705 705,930
the other one wants to

2688
01:07:20,425 --> 01:07:21,580
0,240 240,480 480,705 705,915 915,1155
update another {column.,They -} really

2689
01:07:21,580 --> 01:07:23,040
0,300 300,560
don't conflict.|
|

2690
01:07:23,040 --> 01:07:24,090
0,240 240,360 360,510 510,780 780,1050
But if I only do
但如果我只做记录级别的锁定，我会的。

2691
01:07:24,090 --> 01:07:25,460
0,255 255,540 540,900 900,1065 1065,1370
record level locking, I will.|
|

2692
01:07:26,300 --> 01:07:27,475
0,335 335,575 575,785 785,965 965,1175
Make them go one after
让他们一个接一个地走。

2693
01:07:27,475 --> 01:07:28,500
0,180 180,425
the other.|
|

2694
01:07:28,960 --> 01:07:30,105
0,275 275,425 425,590 590,860 860,1145
So you go further down,
所以你再往下走，你会得到更多的并行度。

2695
01:07:30,105 --> 01:07:31,780
0,225 225,330 330,480 480,1145
you'll get more parallelism.|
|

2696
01:07:31,850 --> 01:07:32,785
0,260 260,455 455,635 635,830 830,935
But you'll also be do
但您还将执行更多锁定操作。所以你想要的是允许，如果你想允许所有这些，你能混合和匹配吗？你能两全其美吗？答案是肯定的。

2697
01:07:32,785 --> 01:07:34,090
0,90 90,225 225,390 390,875 1045,1305
a lot more locking. {So,what

2698
01:07:34,090 --> 01:07:34,810
0,135 135,255 255,390 390,555 555,720
-} you want is to

2699
01:07:34,810 --> 01:07:35,620
0,240 240,450 450,555 555,675 675,810
allow, if you want to

2700
01:07:35,620 --> 01:07:36,660
0,150 150,330 330,540 540,750 750,1040
do allow all of that,

2701
01:07:36,920 --> 01:07:37,915
0,275 275,410 410,575 575,770 770,995
can you mix and match

2702
01:07:37,915 --> 01:07:38,650
0,225 225,375 375,495 495,615 615,735
that? Can you get the

2703
01:07:38,650 --> 01:07:39,865
0,165 165,360 360,555 555,990 990,1215
best of both worlds? And

2704
01:07:39,865 --> 01:07:41,280
0,120 120,285 285,480 480,755
the answer is yes.|
|

2705
01:07:41,280 --> 01:07:42,480
0,290
And?|
然后呢？|

2706
01:07:42,480 --> 01:07:43,305
0,150 150,300 300,465 465,600 600,825
To do all of that
为了正确地做到这一切，你将不得不引入这个概念，是的。

2707
01:07:43,305 --> 01:07:44,685
0,365 715,1020 1020,1140 1140,1275 1275,1380
correctly, you're going to have

2708
01:07:44,685 --> 01:07:46,100
0,240 240,480 480,660 660,965 1015,1415
to introduce this notion, yep.|
|

2709
01:07:46,840 --> 01:07:48,355
0,105 105,240 240,495 495,860 1210,1515
But on previous slide, so
但在前一张幻灯片上，所以现在有属性级别的损失，但。

2710
01:07:48,355 --> 01:07:49,710
0,225 225,465 465,855 855,1035 1035,1355
there now attribute level loss,

2711
01:07:50,030 --> 01:07:50,360
0,290
but.|
|

2712
01:07:50,360 --> 01:07:51,935
0,135 135,315 315,555 555,930 930,1575
They were below tuple hierarchies.
它们位于元组层次结构之下。你有一个分解存储模型，其中所有的列都可以工作，可以直接阻止列。是的，很好。很好，问你个问题。--}如果我有一个列存储或分解存储模型，我可以锁定整个列号吗？是的，您只需要调整它的结构，让表格变成列，这样页面就会变成列，而在列下面之前，你可能会有页面。

2713
01:07:51,935 --> 01:07:53,525
0,225 225,375 375,525 525,785 895,1590
{You,had -} like a decomposition

2714
01:07:53,525 --> 01:07:55,205
0,270 270,605 955,1290 1290,1515 1515,1680
storage model where all of

2715
01:07:55,205 --> 01:07:56,585
0,150 150,480 480,615 615,1260 1260,1380
the columns would workedigously would

2716
01:07:56,585 --> 01:07:57,950
0,135 135,390 390,785 805,1140 1140,1365
be possible to block the

2717
01:07:57,950 --> 01:07:59,735
0,390 390,645 645,930 930,1280 1450,1785
columns like {directly.,Yeah, -} {very,good.

2718
01:07:59,735 --> 01:08:02,000
0,335 535,935 1045,1445 1825,2115 2115,2265
{-},Excellent,question. - -} If I

2719
01:08:02,000 --> 01:08:03,470
0,120 120,380 610,1010 1060,1350 1350,1470
have a column store or

2720
01:08:03,470 --> 01:08:05,210
0,105 105,585 585,855 855,1220 1450,1740
a decomposed storage model, can

2721
01:08:05,210 --> 01:08:06,425
0,150 150,315 315,540 540,795 795,1215
I lock an entire columnumns?

2722
01:08:06,425 --> 01:08:07,715
0,240 240,555 555,765 765,1065 1065,1290
Yes, you'll just adjust the

2723
01:08:07,715 --> 01:08:09,005
0,270 270,525 525,815 865,1140 1140,1290
structure of this to say

2724
01:08:09,005 --> 01:08:10,700
0,275 355,660 660,1175 1225,1515 1515,1695
tables becomes columns and so

2725
01:08:10,700 --> 01:08:12,275
0,270 270,615 615,825 825,1350 1350,1575
pages you'll get columns, and

2726
01:08:12,275 --> 01:08:13,580
0,335 445,720 720,1065 1065,1200 1200,1305
before below columns you might

2727
01:08:13,580 --> 01:08:14,560
0,135 135,410
have pages.|
|

2728
01:08:14,960 --> 01:08:16,150
0,305 305,530 530,800 800,1040 1040,1190
And then in that, you
然后，在那里，你会有柱子。

2729
01:08:16,150 --> 01:08:17,460
0,120 120,255 255,710
would have columns.|
|

2730
01:08:17,610 --> 01:08:19,280
0,305 305,610
So, absolutely.|
所以，绝对可以。|

2731
01:08:19,370 --> 01:08:20,125
0,275 275,425 425,560 560,665 665,755
As long as you have
只要您有一个列存储的结构层次结构，它看起来就会不同。这是一个很好的观察结果。常见还是罕见？就像，是的，嗯，是常见的还是罕见的？这很常见，因为列存储在分析系统中使用。这就是你成为一个分析系统的方式。现在，如果您正在构建啊，您可能会遇到的下一个问题是，在列存储中进行更新有多常见。

2732
01:08:20,125 --> 01:08:21,145
0,120 120,435 435,795 795,915 915,1020
a structural hierarchy for a

2733
01:08:21,145 --> 01:08:21,925
0,195 195,390 390,495 495,630 630,780
column store, it would look

2734
01:08:21,925 --> 01:08:23,310
0,255 255,585 585,705 705,990 990,1385
different. {That's,a -} great {observation.,Common,

2735
01:08:23,870 --> 01:08:25,350
0,400 480,755 755,890 890,1115 1115,1480
-} or is it rare?

2736
01:08:25,880 --> 01:08:28,120
0,365 365,730 1140,1540 1830,2105 2105,2240
Like, yeah, well, is it

2737
01:08:28,120 --> 01:08:29,470
0,240 240,510 510,800 910,1185 1185,1350
common or rare? It is

2738
01:08:29,470 --> 01:08:30,700
0,180 180,450 450,705 705,945 945,1230
pretty common because column stores

2739
01:08:30,700 --> 01:08:32,365
0,270 270,615 615,900 900,1440 1440,1665
get used in {analytic,systems. -}

2740
01:08:32,365 --> 01:08:33,130
0,345 345,435 435,540 540,645 645,765
That's the way in which

2741
01:08:33,130 --> 01:08:34,435
0,225 225,345 345,480 480,1035 1035,1305
you've been {an,analytic -} system.

2742
01:08:34,435 --> 01:08:36,540
0,395 715,990 990,1170 1170,1415 1705,2105
Now if you're building ah,

2743
01:08:36,770 --> 01:08:38,365
0,350 350,700 720,1070 1070,1370 1370,1595
the, the next question that

2744
01:08:38,365 --> 01:08:39,430
0,150 150,360 360,615 615,825 825,1065
you probably have is like

2745
01:08:39,430 --> 01:08:40,360
0,240 240,465 465,660 660,795 795,930
how common is it to

2746
01:08:40,360 --> 01:08:42,115
0,260 340,740 880,1245 1245,1485 1485,1755
do updates in a column

2747
01:08:42,115 --> 01:08:42,920
0,395
store.|
|

2748
01:08:42,920 --> 01:08:44,465
0,195 195,435 435,800 1060,1365 1365,1545
The answer is more and
答案越来越普遍，因为现在人们正试图建造这些被称为EDGE TAP系统的东西。所以人们通常会说，我有一个分析系统和一个交易系统，但现在我维护着两个系统。因此，edgetap系统说我想要允许事务和分析并高效地执行，但分析工作负载想要列存储。

2749
01:08:44,465 --> 01:08:45,635
0,165 165,455 475,765 765,960 960,1170
more common because now people

2750
01:08:45,635 --> 01:08:46,490
0,180 180,345 345,495 495,660 660,855
are trying to build these

2751
01:08:46,490 --> 01:08:47,770
0,210 210,435 435,675 675,945 945,1280
things called edge tap systems.

2752
01:08:48,210 --> 01:08:49,475
0,290 290,575 575,845 845,1055 1055,1265
{So,typically -} what people will

2753
01:08:49,475 --> 01:08:50,585
0,135 135,315 315,420 420,555 555,1110
say, I've got an analytic

2754
01:08:50,585 --> 01:08:51,365
0,195 195,390 390,555 555,645 645,780
system and I've got a

2755
01:08:51,365 --> 01:08:53,180
0,275 385,785 1225,1515 1515,1650 1650,1815
transaction systems, but now I'm

2756
01:08:53,180 --> 01:08:54,845
0,230 250,540 540,830 1330,1560 1560,1665
maintaining two {systems.,So -} an

2757
01:08:54,845 --> 01:08:56,015
0,390 390,660 660,915 915,1050 1050,1170
edgetap system says I want

2758
01:08:56,015 --> 01:08:57,860
0,150 150,315 315,605 865,1230 1230,1845
to allow transactions and analytics

2759
01:08:57,860 --> 01:08:59,285
0,150 150,285 285,450 450,1130 1150,1425
and do that efficiently, but

2760
01:08:59,285 --> 01:09:01,720
0,725 985,1560 1560,1755 1755,2055 2055,2435
analytics workloads want column stores.|
|

2761
01:09:02,260 --> 01:09:04,360
0,320 610,1260 1260,1500 1500,1830 1830,2100
Whereas transactional systems want raw
而交易系统需要原始商店，因此有大量研究正在研究如何实现这一点。只要你有一个存储层次结构，你就可以让这件事的理论发挥作用。这就是这种技术的美妙之处，它就是它。

2762
01:09:04,360 --> 01:09:05,850
0,320 700,960 960,1140 1140,1230 1230,1490
stores, so there's a huge

2763
01:09:05,900 --> 01:09:07,000
0,290 290,530 530,770 770,950 950,1100
bunch of research going on

2764
01:09:07,000 --> 01:09:07,870
0,135 135,300 300,450 450,600 600,870
on how to make that

2765
01:09:07,870 --> 01:09:09,490
0,380 850,1155 1155,1350 1350,1515 1515,1620
work. {As,long -} as you

2766
01:09:09,490 --> 01:09:10,540
0,75 75,195 195,435 435,945 945,1050
have a storage hierarchy, you

2767
01:09:10,540 --> 01:09:12,070
0,135 135,330 330,600 600,950 1180,1530
can make the theory of

2768
01:09:12,070 --> 01:09:13,240
0,255 255,465 465,675 675,870 870,1170
this thing {work.,And -} that's

2769
01:09:13,240 --> 01:09:14,580
0,150 150,440 490,810 810,1035 1035,1340
the beauty of this technique,

2770
01:09:14,840 --> 01:09:16,060
0,365 365,730
it it.|
|

2771
01:09:16,250 --> 01:09:17,910
0,275 275,485 485,1085 1085,1310 1310,1660
With any hierarchical data structure,
任何层次的数据结构，但是如何使EDGE TAP系统工作，在哪里我可能有一个行存储和一个列存储是目前社区中正在密切研究的事情。

2772
01:09:18,290 --> 01:09:19,255
0,275 275,440 440,590 590,740 740,965
but how to make edge

2773
01:09:19,255 --> 01:09:20,665
0,255 255,575 595,945 945,1215 1215,1410
tap systems work, where I

2774
01:09:20,665 --> 01:09:21,505
0,150 150,285 285,420 420,630 630,840
might have a row store

2775
01:09:21,505 --> 01:09:23,250
0,150 150,270 270,515 535,935 1345,1745
and a column store is

2776
01:09:23,570 --> 01:09:25,450
0,380 380,665 665,970 990,1390 1440,1880
something that is being researched

2777
01:09:25,450 --> 01:09:26,830
0,525 525,705 705,825 825,1070 1090,1380
intensely in the community right

2778
01:09:26,830 --> 01:09:27,540
0,290
now.|
|

2779
01:09:27,810 --> 01:09:28,865
0,245 245,350 350,470 470,730 780,1055
Make sure the questions understood
确保问题理解正确。好吧?具体而言，就像锁定整个列一样，这很常见。

2780
01:09:28,865 --> 01:09:31,090
0,275 415,705 705,995 1585,1905 1905,2225
correctly. {Okay?,Specifically,,like - -} having

2781
01:09:31,110 --> 01:09:32,930
0,530 530,800 800,1115 1115,1520 1520,1820
locking on entire columns, that's

2782
01:09:32,930 --> 01:09:33,240
0,270
common.|
|

2783
01:09:34,460 --> 01:09:35,590
0,275 275,425 425,605 605,860 860,1130
In all APP systems, that's
在所有的应用程序系统中，这就是你会做的。是的，如果它不是只读的。如果它不是只读数据库。如果它是只读数据库，那么您所谈论的一切都无关紧要。是啊，对吧？所以，所有的应用程序系统都会说，我将您指定为只读。

2784
01:09:35,590 --> 01:09:36,600
0,105 105,270 270,435 435,660 660,1010
what you would do. {Yeah,,if

2785
01:09:36,650 --> 01:09:37,600
0,260 260,365 365,485 485,710 710,950
-} it is not read

2786
01:09:37,600 --> 01:09:38,620
0,290 310,585 585,780 780,885 885,1020
{only.,If -} it's not a

2787
01:09:38,620 --> 01:09:39,700
0,120 120,315 315,645 645,900 900,1080
read {only,database. -} If it's

2788
01:09:39,700 --> 01:09:41,125
0,105 105,285 285,590 1000,1260 1260,1425
read only database, everything you're

2789
01:09:41,125 --> 01:09:42,960
0,165 165,435 435,795 795,1055 1435,1835
talking {about,won't -} matter. Yeah,

2790
01:09:43,160 --> 01:09:44,515
0,400 540,830 830,1010 1010,1190 1190,1355
right? So there are all

2791
01:09:44,515 --> 01:09:45,505
0,180 180,435 435,660 660,780 780,990
APP systems where they say

2792
01:09:45,505 --> 01:09:46,600
0,240 240,690 690,810 810,930 930,1095
I designate you as just

2793
01:09:46,600 --> 01:09:47,640
0,165 165,440
read only.|
|

2794
01:09:47,680 --> 01:09:49,875
0,400 900,1265 1265,1630 1650,1940 1940,2195
And no updates. {This,means -}
也没有最新消息。这意味着所有这些都不适用。

2795
01:09:49,875 --> 01:09:51,420
0,240 240,390 390,585 585,935
none of this applies.|
|

2796
01:09:54,740 --> 01:09:56,160
0,320 320,640
Other questions?|
还有其他问题吗？|

2797
01:09:57,260 --> 01:09:58,170
0,245 245,350 350,470 470,665 665,910
Okay, and we won't finish
好的，我们今天不会做完所有的事，但没关系。让我们看看我们能通过多少。我一直在问问题，因为这个，这个材料需要一点时间来消化。

2798
01:09:58,250 --> 01:09:59,875
0,350 350,700 780,1070 1070,1370 1370,1625
everything today, but that's okay.

2799
01:09:59,875 --> 01:10:00,685
0,270 270,375 375,495 495,660 660,810
{Let's,see -} how much we

2800
01:10:00,685 --> 01:10:02,635
0,135 135,330 330,495 495,755 1645,1950
can get {through.,I -} keep

2801
01:10:02,635 --> 01:10:04,000
0,270 270,630 630,885 885,1080 1080,1365
asking questions because this, this

2802
01:10:04,000 --> 01:10:05,020
0,285 285,510 510,645 645,810 810,1020
material takes a little time

2803
01:10:05,020 --> 01:10:06,140
0,150 150,590
to digest.|
|

2804
01:10:07,360 --> 01:10:09,150
0,400 990,1265 1265,1430 1430,1610 1610,1790
So to make all these
因此，要使所有这些层次结构工作，如果您只是保持共享和独占锁定。

2805
01:10:09,150 --> 01:10:10,875
0,525 525,830 1120,1395 1395,1545 1545,1725
hierarchies work, if you just

2806
01:10:10,875 --> 01:10:12,030
0,195 195,345 345,525 525,795 795,1155
kept a shared and exclusive

2807
01:10:12,030 --> 01:10:13,060
0,380
lock.|
|

2808
01:10:13,060 --> 01:10:14,370
0,210 210,465 465,615 615,915 915,1310
We won't get much performance
我们不会获得太多性能，因为您知道如果有人锁定整个数据库。

2809
01:10:14,450 --> 01:10:15,265
0,290 290,425 425,500 500,590 590,815
because you know if someone

2810
01:10:15,265 --> 01:10:17,400
0,375 375,555 555,795 795,1115
locks the entire database.|
|

2811
01:10:17,440 --> 01:10:18,870
0,365 365,500 500,1085 1085,1250 1250,1430
There's no parallelism, right? So
没有平行关系，对吧？所以对我们来说会适得其反。

2812
01:10:18,870 --> 01:10:20,700
0,375 375,810 810,1005 1005,1280
it'll backfire on us.|
|

2813
01:10:20,700 --> 01:10:21,675
0,225 225,360 360,540 540,765 765,975
So we need this thing
所以我们需要这种被称为故意锁的东西，它看起来有点奇怪，与前面提出的问题有关。有超过两种类型的原木是什么？是的，有很多很多不同类型的锁。最简单的是，我们有一种叫做分享意图的东西。这上面写的是看。

2814
01:10:21,675 --> 01:10:23,130
0,305 355,900 900,1170 1170,1290 1290,1455
called intentional locks, which sort

2815
01:10:23,130 --> 01:10:24,510
0,150 150,375 375,735 735,1080 1080,1380
of seems weird and connects

2816
01:10:24,510 --> 01:10:25,230
0,105 105,210 210,405 405,600 600,720
to the question that was

2817
01:10:25,230 --> 01:10:26,610
0,165 165,470 580,975 975,1245 1245,1380
asked earlier. {What,are -} there

2818
01:10:26,610 --> 01:10:27,345
0,120 120,270 270,420 420,570 570,735
more than two types of

2819
01:10:27,345 --> 01:10:29,055
0,425 535,935 1015,1290 1290,1485 1485,1710
logs? Yeah, there are lots

2820
01:10:29,055 --> 01:10:29,940
0,180 180,330 330,465 465,660 660,885
and lots of different types

2821
01:10:29,940 --> 01:10:31,670
0,180 180,650 730,1005 1005,1410 1410,1730
of {locks.,The -} simplest one

2822
01:10:31,930 --> 01:10:33,015
0,335 335,605 605,785 785,905 905,1085
is going to be one

2823
01:10:33,015 --> 01:10:34,125
0,180 180,315 315,495 495,765 765,1110
where we have something called

2824
01:10:34,125 --> 01:10:36,300
0,395 535,825 825,1115 1675,1980 1980,2175
intention {to,share. -} And what

2825
01:10:36,300 --> 01:10:38,080
0,210 210,530 550,915 915,1280
this says is look.|
|

2826
01:10:38,365 --> 01:10:40,090
0,675 675,1080 1080,1230 1230,1440 1440,1725
Traversing I'm t one, I'm
我是一号桌，我是一号桌。

2827
01:10:40,090 --> 01:10:42,080
0,480 480,735 735,1020 1020,1340
traversing table t one.|
|

2828
01:10:42,300 --> 01:10:42,995
0,245 245,395 395,470 470,575 575,695
I don't want to grab
我不想在古铜色皮肤上共享锁。

2829
01:10:42,995 --> 01:10:44,140
0,135 135,330 330,540 540,690 690,1145
a shared lock on tan.|
|

2830
01:10:44,690 --> 01:10:45,475
0,260 260,380 380,515 515,650 650,785
Because it may be too
因为可能太多了，我只想看看TIVA的一些记录。

2831
01:10:45,475 --> 01:10:47,020
0,275 565,855 855,1125 1125,1395 1395,1545
much, I only want to

2832
01:10:47,020 --> 01:10:48,115
0,120 120,300 300,555 555,855 855,1095
look at some records in

2833
01:10:48,115 --> 01:10:49,100
0,455
tiva.|
|

2834
01:10:49,660 --> 01:10:51,165
0,395 395,755 755,980 980,1325 1325,1505
Maybe I'm just accessing an
也许我只是在访问一个索引，并且只访问匹配的记录，而我不知道结果会是什么。或许该指数可以。

2835
01:10:51,165 --> 01:10:52,350
0,225 225,405 405,690 690,960 960,1185
index and only the records

2836
01:10:52,350 --> 01:10:53,835
0,225 225,500 730,1065 1065,1260 1260,1485
that match, and I don't

2837
01:10:53,835 --> 01:10:54,765
0,150 150,345 345,510 510,660 660,930
know what will end up.

2838
01:10:54,765 --> 01:10:56,780
0,345 345,660 660,930 930,1235
{Maybe,that -} index can.|
|

2839
01:10:57,140 --> 01:10:58,735
0,320 320,635 635,920 920,1355 1355,1595
Ends up the predicate range
最终，谓词范围是这样的，我需要访问每条记录，或者它太窄，以至于我可能访问表中的零条记录或只访问一条记录。我不知道这个。

2840
01:10:58,735 --> 01:10:59,815
0,225 225,465 465,735 735,930 930,1080
is such that I need

2841
01:10:59,815 --> 01:11:01,420
0,210 210,420 420,675 675,1055 1315,1605
to access every record, or

2842
01:11:01,420 --> 01:11:02,350
0,165 165,300 300,480 480,735 735,930
it is so narrow that

2843
01:11:02,350 --> 01:11:03,565
0,135 135,375 375,630 630,885 885,1215
I might access zero records

2844
01:11:03,565 --> 01:11:04,600
0,225 225,405 405,615 615,840 840,1035
or only one record in

2845
01:11:04,600 --> 01:11:05,515
0,120 120,345 345,570 570,795 795,915
the table. {I,don't -} know

2846
01:11:05,515 --> 01:11:06,300
0,275
that.|
|

2847
01:11:06,300 --> 01:11:07,160
0,195 195,270 270,360 360,525 525,860
But I have to acquire
但是，当我首先从这个层次结构下来时，我必须获得那个锁，这样我才能获得表上的共享锁。但如果实际需要读取的记录非常少，情况可能会非常糟糕。

2848
01:11:07,300 --> 01:11:08,235
0,320 320,530 530,695 695,815 815,935
that lock as I come

2849
01:11:08,235 --> 01:11:10,100
0,150 150,300 300,720 720,995 1465,1865
down this hierarchy first, so

2850
01:11:10,330 --> 01:11:11,370
0,260 260,440 440,695 695,860 860,1040
I could acquire the shared

2851
01:11:11,370 --> 01:11:12,375
0,180 180,315 315,435 435,645 645,1005
lock on the table. {But,that

2852
01:11:12,375 --> 01:11:13,550
0,285 285,450 450,600 600,825 825,1175
-} could be really bad

2853
01:11:13,780 --> 01:11:15,210
0,380 380,695 695,890 890,1100 1100,1430
if very few records actually

2854
01:11:15,210 --> 01:11:16,440
0,255 255,375 375,480 480,740
need to be read.|
|

2855
01:11:16,630 --> 01:11:17,535
0,320 320,590 590,665 665,815 815,905
So here's what I'm going
所以这就是我要做的。我要说我没有。我打算在下面的某个地方抢一把共享的锁。

2856
01:11:17,535 --> 01:11:18,210
0,105 105,195 195,405 405,510 510,675
to do. {I'm,going -} to

2857
01:11:18,210 --> 01:11:19,760
0,210 210,390 390,750 750,1100 1150,1550
say I {haven't.,I -} intend

2858
01:11:20,020 --> 01:11:21,675
0,400 630,950 950,1130 1130,1355 1355,1655
to grab a shared lock

2859
01:11:21,675 --> 01:11:23,120
0,285 285,615 615,995
somewhere down below.|
|

2860
01:11:23,120 --> 01:11:23,870
0,165 165,270 270,405 405,570 570,750
So I will grab an
所以我会获取一个I锁，意图共享锁，而IS锁的好处是它与I锁兼容，I锁的意图是写入，以获得下面某个地方的独占锁。

2861
01:11:23,870 --> 01:11:25,550
0,290 490,825 825,1110 1110,1440 1440,1680
I lock an intention to

2862
01:11:25,550 --> 01:11:27,020
0,210 210,560 910,1185 1185,1320 1320,1470
share lock and the beauty

2863
01:11:27,020 --> 01:11:28,100
0,150 150,285 285,560 580,885 885,1080
of an is lock is

2864
01:11:28,100 --> 01:11:29,440
0,225 225,735 735,885 885,1050 1050,1340
it's compatible with an I

2865
01:11:29,640 --> 01:11:31,180
0,305 305,470 470,665 665,1000 1140,1540
lock, which is intention to

2866
01:11:31,440 --> 01:11:33,005
0,400 450,755 755,950 950,1205 1205,1565
write to get an exclusive

2867
01:11:33,005 --> 01:11:34,600
0,270 270,510 510,810 810,1175
lock somewhere down below.|
|

2868
01:11:34,600 --> 01:11:36,010
0,225 225,500 520,855 855,1110 1110,1410
So the main line is
所以主线是我可以拿到一把IS锁，这样其他读者当然可以通过。

2869
01:11:36,010 --> 01:11:37,080
0,255 255,435 435,630 630,795 795,1070
I could grab an is

2870
01:11:37,130 --> 01:11:38,560
0,350 350,620 620,890 890,1205 1205,1430
lock so other readers can,

2871
01:11:38,560 --> 01:11:40,040
0,135 135,330 330,555 555,860
of course go through.|
|

2872
01:11:40,040 --> 01:11:41,015
0,345 345,435 435,570 570,750 750,975
I'm just saying I intend
我只是说，当我到达下面时，我打算向下分享，我实际上会在我正在阅读的东西上获取共享锁，但在顶层，我不是黑锁，所以我有这样的斗争，如果我只是这样做，比方说，啊，元组级别的锁定生活很好，严格，强大，严格的两阶段锁定。

2873
01:11:41,015 --> 01:11:42,200
0,150 150,395 565,885 885,1065 1065,1185
to share down when I

2874
01:11:42,200 --> 01:11:43,370
0,195 195,390 390,585 585,830 850,1170
get below, I'll actually grab

2875
01:11:43,370 --> 01:11:44,270
0,180 180,390 390,630 630,780 780,900
a shared lock on the

2876
01:11:44,270 --> 01:11:45,635
0,150 150,285 285,465 465,710 1060,1365
thing that I'm reading, but

2877
01:11:45,635 --> 01:11:46,625
0,180 180,315 315,510 510,750 750,990
at the top level I'm

2878
01:11:46,625 --> 01:11:47,950
0,165 165,450 450,870 870,990 990,1325
not black blocking so I'm

2879
01:11:48,060 --> 01:11:50,105
0,305 305,530 530,850 990,1390 1770,2045
have this fight between if

2880
01:11:50,105 --> 01:11:51,400
0,165 165,405 405,705 705,1035 1035,1295
I just do, let's say,

2881
01:11:51,690 --> 01:11:53,405
0,320 320,665 665,860 860,1390 1410,1715
ah, tuple level locking life

2882
01:11:53,405 --> 01:11:54,995
0,180 180,375 375,615 615,935 1255,1590
is good with strict, strong,

2883
01:11:54,995 --> 01:11:56,620
0,255 255,450 450,645 645,1175
strict two phase locking.|
|

2884
01:11:56,660 --> 01:11:58,090
0,400 810,1070 1070,1175 1175,1280 1280,1430
But if I have to
但如果我必须扫描很多记录，我的锁定开销太高。因此，我正在尝试平衡锁定开销和我允许的并行度。因此，IS锁有不同的口味。三种主要的口味是意向分享。

2885
01:11:58,090 --> 01:11:58,945
0,195 195,345 345,450 450,585 585,855
scan a lot of records,

2886
01:11:58,945 --> 01:12:00,130
0,270 270,555 555,900 900,1035 1035,1185
my locking overhead is too

2887
01:12:00,130 --> 01:12:00,805
0,150 150,270 270,405 405,540 540,675
high. {So,I'm,trying - -} to

2888
01:12:00,805 --> 01:12:02,230
0,180 180,375 375,645 645,1155 1155,1425
balance the locking overhead with

2889
01:12:02,230 --> 01:12:03,600
0,180 180,360 360,900 900,1065 1065,1370
how much parallelism I {allow.,So

2890
01:12:03,950 --> 01:12:06,055
0,400 540,830 830,1120 1230,1835 1835,2105
-} the is locks come

2891
01:12:06,055 --> 01:12:07,465
0,135 135,345 345,825 825,1125 1125,1410
in {different,flavors. -} The three

2892
01:12:07,465 --> 01:12:09,160
0,210 210,585 585,875 1045,1440 1440,1695
main flavors are intention to

2893
01:12:09,160 --> 01:12:10,100
0,260
share.|
|

2894
01:12:10,410 --> 01:12:12,845
0,400 420,820 1650,2000 2000,2225 2225,2435
Intention to grab a shared
获取共享锁的意图低于ix获取排他锁的意图，而共享意图获取六个锁的意图是。

2895
01:12:12,845 --> 01:12:14,975
0,240 240,545 565,960 960,1800 1800,2130
lock somewhere below ix's intention

2896
01:12:14,975 --> 01:12:16,280
0,270 270,435 435,660 660,1005 1005,1305
to grab an exclusive lock

2897
01:12:16,280 --> 01:12:18,500
0,315 315,710 1090,1410 1410,1730 1840,2220
somewhere below and shared intention

2898
01:12:18,500 --> 01:12:21,500
0,380 1000,1395 1395,1950 1950,2330
to six locks is.|
|

2899
01:12:21,500 --> 01:12:23,080
0,195 195,405 405,710 850,1215 1215,1580
I will read everything below.
我将阅读下面的所有内容。我已经知道了。

2900
01:12:23,460 --> 01:12:25,200
0,290 290,455 455,695 695,1060
{I,know -} that already.|
|

2901
01:12:25,200 --> 01:12:26,250
0,195 195,480 480,735 735,900 900,1050
But some things I may
但有些东西我可能真的会更新，所以可能我没有。

2902
01:12:26,250 --> 01:12:27,780
0,290 430,830 1000,1245 1245,1365 1365,1530
actually update, so it may

2903
01:12:27,780 --> 01:12:29,300
0,210 210,390 390,645 645,890
be I don't have.|
|

2904
01:12:29,700 --> 01:12:31,145
0,335 335,560 560,725 725,1000 1080,1445
Index built at all, let's
建立索引，比方说在学生记录表上，我想扫描所有东西，把每个得到b-的人，移到A，B，我不知道是哪一个。我要去拿一把专属的锁，但我知道我会读所有的东西。

2905
01:12:31,145 --> 01:12:32,620
0,210 210,570 570,855 855,1110 1110,1475
say on a student record

2906
01:12:32,970 --> 01:12:34,775
0,400 600,965 965,1330 1440,1700 1700,1805
table student table, and I

2907
01:12:34,775 --> 01:12:36,220
0,135 135,285 285,545 715,1080 1080,1445
want to scan everything and

2908
01:12:36,570 --> 01:12:38,135
0,400 420,695 695,905 905,1150 1290,1565
take everyone who's got a

2909
01:12:38,135 --> 01:12:39,095
0,165 165,405 405,630 630,795 795,960
b minus and move them

2910
01:12:39,095 --> 01:12:40,460
0,120 120,225 225,485 805,1080 1080,1365
to A B I don't

2911
01:12:40,460 --> 01:12:41,510
0,195 195,465 465,705 705,930 930,1050
know which ones. {I'm,going -}

2912
01:12:41,510 --> 01:12:42,700
0,135 135,255 255,465 465,810 810,1190
to grab an exclusive lock,

2913
01:12:42,870 --> 01:12:43,595
0,260 260,395 395,500 500,635 635,725
but I know I'm going

2914
01:12:43,595 --> 01:12:44,800
0,120 120,365 385,785
to read everything.|
|

2915
01:12:44,990 --> 01:12:46,045
0,245 245,335 335,470 470,755 755,1055
So I will say please
所以我会说，请不要让我在下面获取共享锁，假设我已经共享了所有东西。所以只需要一个锁，假设在100个学生中只有一个学生需要更新。我以后只会为我需要更改的那个学生获取一个独占锁。所以这是非常有效的，两把锁，对，而不是必须抢100多把锁。

2916
01:12:46,045 --> 01:12:47,035
0,210 210,330 330,480 480,705 705,990
don't make me grab shared

2917
01:12:47,035 --> 01:12:48,925
0,285 285,615 615,995 1255,1590 1590,1890
lock down below, assume I've

2918
01:12:48,925 --> 01:12:50,545
0,455 505,905 955,1230 1230,1410 1410,1620
sharedlock everything. {So,just -} one

2919
01:12:50,545 --> 01:12:51,595
0,300 300,570 570,750 750,840 840,1050
lock and let's say there's

2920
01:12:51,595 --> 01:12:52,660
0,195 195,495 495,765 765,945 945,1065
only one student that I

2921
01:12:52,660 --> 01:12:53,485
0,135 135,330 330,525 525,675 675,825
need to update out of

2922
01:12:53,485 --> 01:12:55,120
0,105 105,375 375,1260 1260,1410 1410,1635
the 100 {students.,I} will only

2923
01:12:55,120 --> 01:12:56,790
0,285 285,620 640,1035 1035,1335 1335,1670
grab one exclusive lock later

2924
01:12:57,050 --> 01:12:58,150
0,290 290,470 470,680 680,920 920,1100
for that one student that

2925
01:12:58,150 --> 01:12:58,840
0,120 120,255 255,390 390,555 555,690
I need to {change.,So -}

2926
01:12:58,840 --> 01:13:00,150
0,135 135,315 315,615 615,855 855,1310
it's very efficient, two locks,

2927
01:13:00,380 --> 01:13:01,855
0,400 510,845 845,1100 1100,1280 1280,1475
right, as opposed to having

2928
01:13:01,855 --> 01:13:03,660
0,195 195,455 565,1050 1050,1335 1335,1805
to grab 100 plus locks.|
|

2929
01:13:04,700 --> 01:13:06,445
0,400 540,940 1050,1340 1340,1535 1535,1745
Okay, so how does that
好的，那这是怎么回事？我们需要一个兼容性矩阵才能继续。

2930
01:13:06,445 --> 01:13:08,215
0,305 655,915 915,1035 1035,1140 1140,1770
work? We need a compatibility

2931
01:13:08,215 --> 01:13:09,750
0,605 715,990 990,1125 1125,1260 1260,1535
matrix before we can proceed.|
|

2932
01:13:10,660 --> 01:13:12,900
0,395 395,665 665,1310 1310,1955 1955,2240
And that compatibility matrix has
这个兼容性矩阵有几个有趣的要点，我想提请您注意。其一，is锁与ix锁兼容。

2933
01:13:12,900 --> 01:13:14,220
0,150 150,410 460,810 810,1110 1110,1320
a couple interesting points that

2934
01:13:14,220 --> 01:13:14,955
0,180 180,300 300,450 450,570 570,735
I'd like to draw your

2935
01:13:14,955 --> 01:13:16,455
0,285 285,665 925,1200 1200,1350 1350,1500
attention to. {One,is -} that

2936
01:13:16,455 --> 01:13:18,375
0,195 195,515 745,1095 1095,1335 1335,1920
an is lock is compatible

2937
01:13:18,375 --> 01:13:20,120
0,135 135,270 270,750 750,1115
with an ix lock.|
|

2938
01:13:20,120 --> 01:13:21,185
0,120 120,300 300,525 525,765 765,1065
And what that is saying
这就是说，是的，你打算分享，啊，啊，在层次结构中低于这个级别的一些阅读，你将在你真正想要阅读的内容上获得一个适当的共享锁。嘿，如果其他人想要获得下面的独占锁，他们可能会说，在这个级别上，我只是一个ix锁，我和ix lock兼容。

2939
01:13:21,185 --> 01:13:23,030
0,285 285,575 685,1085 1195,1545 1545,1845
is that yes, you intend

2940
01:13:23,030 --> 01:13:26,000
0,350 460,860 1510,1910 1990,2390 2650,2970
to share, ah, ah, do

2941
01:13:26,000 --> 01:13:28,115
0,320 370,770 1090,1490 1600,1905 1905,2115
some read below this level

2942
01:13:28,115 --> 01:13:29,570
0,165 165,270 270,875 985,1275 1275,1455
in the hierarchy, you will

2943
01:13:29,570 --> 01:13:30,635
0,180 180,330 330,540 540,825 825,1065
grab a proper shared lock

2944
01:13:30,635 --> 01:13:31,415
0,195 195,345 345,495 495,660 660,780
on the stuff that you

2945
01:13:31,415 --> 01:13:32,900
0,210 210,465 465,615 615,875 1195,1485
actually want to read. {And,hey,

2946
01:13:32,900 --> 01:13:34,055
0,165 165,300 300,555 555,900 900,1155
-} if someone else wants

2947
01:13:34,055 --> 01:13:35,440
0,165 165,315 315,585 585,990 990,1385
to grab an exclusive lock

2948
01:13:35,670 --> 01:13:37,250
0,395 395,790 870,1160 1160,1355 1355,1580
down below, they could say

2949
01:13:37,250 --> 01:13:38,270
0,210 210,405 405,630 630,885 885,1020
at this level I'm just

2950
01:13:38,270 --> 01:13:39,290
0,150 150,465 465,645 645,795 795,1020
an ix lock and I

2951
01:13:39,290 --> 01:13:41,100
0,240 240,555 555,870 870,1520
and ix locker compatible.|
|

2952
01:13:42,860 --> 01:13:43,750
0,275 275,485 485,605 605,755 755,890
And you'll see that with
你会通过一个例子看到这一点。然后6号锁和IS号锁是兼容的，因为6号锁就像我对下面所有东西都有一个共享的锁。当然，读与读是兼容的，包括与读的意图兼容，所以这也是兼容的。

2953
01:13:43,750 --> 01:13:45,160
0,195 195,530 760,1035 1035,1215 1215,1410
an example. {And,then -} the

2954
01:13:45,160 --> 01:13:46,795
0,285 285,645 645,900 900,1500 1500,1635
six lock is compatible with

2955
01:13:46,795 --> 01:13:48,475
0,135 135,390 390,750 750,1115 1315,1680
the is lock because six

2956
01:13:48,475 --> 01:13:49,765
0,270 270,495 495,815 865,1185 1185,1290
lock is like I've got

2957
01:13:49,765 --> 01:13:50,710
0,120 120,270 270,435 435,660 660,945
a shared lock on everything

2958
01:13:50,710 --> 01:13:51,685
0,300 300,525 525,630 630,795 795,975
{below.,So -} of course, read

2959
01:13:51,685 --> 01:13:52,860
0,150 150,645 645,780 780,915 915,1175
is compatible with a read,

2960
01:13:53,120 --> 01:13:54,955
0,400 570,1205 1205,1340 1340,1535 1535,1835
including compatible with an intention

2961
01:13:54,955 --> 01:13:56,545
0,225 225,485 655,960 960,1260 1260,1590
to read, and so that

2962
01:13:56,545 --> 01:13:58,020
0,210 210,435 435,1175
is also compatible.|
|

2963
01:13:58,580 --> 01:14:00,955
0,350 350,700 1380,1790 1790,2030 2030,2375
Okay, so let's see you've
好的，让我们看看你有五分钟时间。这应该足以完成这里的一些核心部分。

2964
01:14:00,955 --> 01:14:02,170
0,135 135,345 345,665 745,1035 1035,1215
got five minutes. {That,should -}

2965
01:14:02,170 --> 01:14:03,085
0,165 165,345 345,495 495,675 675,915
be enough to go through

2966
01:14:03,085 --> 01:14:03,895
0,165 165,300 300,420 420,570 570,810
some of the core parts

2967
01:14:03,895 --> 01:14:04,860
0,335
here.|
|

2968
01:14:04,860 --> 01:14:06,540
0,210 210,345 345,570 570,920 1330,1680
Let's take this example of
让我们以这个从Andy可疑的离岸银行账户获得余额的例子为例。

2969
01:14:06,540 --> 01:14:08,810
0,285 285,465 465,710 790,1190 1450,2270
getting a balance from Andy's

2970
01:14:09,040 --> 01:14:11,380
0,455 455,910 960,1355 1355,1750
shady offshore bank account.|
|

2971
01:14:11,540 --> 01:14:12,415
0,245 245,425 425,530 530,665 665,875
I don't think he really
我不认为他真的有，这只是一个例子，所以。

2972
01:14:12,415 --> 01:14:13,390
0,240 240,435 435,660 660,780 780,975
has one, there's just an

2973
01:14:13,390 --> 01:14:15,320
0,320 340,740
example, so.|
|

2974
01:14:15,720 --> 01:14:16,930
0,365 365,500 500,710 710,965 965,1210
Don't tell people it's real.
别告诉别人这是真的。啊，然后把博彩公司的账户余额增加1%，让我们去看看是什么样子。我们已经有了一个包含所有这些银行帐户信息的表，我们将从读取该记录的第一个交易开始。

2975
01:14:17,100 --> 01:14:18,665
0,400 570,875 875,1115 1115,1370 1370,1565
{Ah,,and -} then increase the

2976
01:14:18,665 --> 01:14:19,940
0,360 360,585 585,840 840,1095 1095,1275
bookies account balance by one

2977
01:14:19,940 --> 01:14:22,565
0,290 790,1190 2020,2400 2400,2505 2505,2625
percent and let's go and

2978
01:14:22,565 --> 01:14:23,570
0,150 150,375 375,615 615,810 810,1005
look at what that looks

2979
01:14:23,570 --> 01:14:24,785
0,180 180,315 315,495 495,740 940,1215
{like.,So -} we've got a

2980
01:14:24,785 --> 01:14:26,735
0,275 415,705 705,915 915,1235 1585,1950
table of all these bank

2981
01:14:26,735 --> 01:14:28,775
0,365 415,815 1225,1590 1590,1890 1890,2040
account information and we'll start

2982
01:14:28,775 --> 01:14:30,065
0,165 165,270 270,450 450,785 925,1290
with the first transaction to

2983
01:14:30,065 --> 01:14:31,620
0,315 315,585 585,905
read that record.|
|

2984
01:14:31,620 --> 01:14:32,610
0,165 165,345 345,585 585,780 780,990
At that point, we might
在这一点上，我们可能只想读取这一条记录。所以我们可以说的是，我宣布我走在桌子上.

2985
01:14:32,610 --> 01:14:33,570
0,300 300,540 540,675 675,795 795,960
only want to read that

2986
01:14:33,570 --> 01:14:34,530
0,195 195,465 465,690 690,825 825,960
one record. {So,what -} we

2987
01:14:34,530 --> 01:14:35,805
0,150 150,440 490,795 795,1020 1020,1275
might say is at that

2988
01:14:35,805 --> 01:14:37,275
0,225 225,525 525,675 675,965 1165,1470
I declare an is walk

2989
01:14:37,275 --> 01:14:38,480
0,165 165,270 270,515
on the table.|
|

2990
01:14:38,520 --> 01:14:40,160
0,320 320,640 960,1220 1220,1385 1385,1640
And then, you know, assuming
然后，假设只有一个安迪，我只会读取一个元组，然后写一个共享锁。所以两个锁我做完了。然后，如果我必须扫描整个表，我将只在我需要的地方获取共享锁。

2991
01:14:40,160 --> 01:14:41,315
0,255 255,405 405,615 615,855 855,1155
there's only one Andy, I'm

2992
01:14:41,315 --> 01:14:42,020
0,120 120,300 300,420 420,540 540,705
only going to read that

2993
01:14:42,020 --> 01:14:44,765
0,195 195,680 880,1280 1390,1790 2440,2745
one tuple and basically write

2994
01:14:44,765 --> 01:14:45,770
0,195 195,420 420,735 735,870 870,1005
a shared locks. {So,two -}

2995
01:14:45,770 --> 01:14:47,195
0,255 255,465 465,710 1000,1260 1260,1425
locks I'm {done.,And -} then

2996
01:14:47,195 --> 01:14:47,840
0,150 150,240 240,345 345,480 480,645
if I had to scan

2997
01:14:47,840 --> 01:14:48,980
0,210 210,450 450,720 720,975 975,1140
the entire table, I'll only

2998
01:14:48,980 --> 01:14:50,030
0,285 285,540 540,795 795,915 915,1050
grab shared locks on what

2999
01:14:50,030 --> 01:14:51,000
0,120 120,285 285,590
I need to.|
|

3000
01:14:51,070 --> 01:14:52,550
0,400 450,740 740,905 905,1130 1130,1480
Now, at the same time,
现在，同时，这里允许的并行性是，事务t 2可以在持有这些锁的同时运行，并且可以抢占一个ix锁。

3001
01:14:52,720 --> 01:14:54,330
0,260 260,725 725,860 860,1025 1025,1610
the parallelism that is allowable

3002
01:14:54,330 --> 01:14:55,680
0,315 315,555 555,705 705,980 1060,1350
here is that transaction t

3003
01:14:55,680 --> 01:14:57,645
0,180 180,345 345,720 720,1580 1690,1965
two could beok concurrently while

3004
01:14:57,645 --> 01:14:58,640
0,195 195,480 480,585 585,720 720,995
those locks are being held

3005
01:14:58,840 --> 01:15:00,075
0,305 305,500 500,680 680,845 845,1235
and can grab an ix

3006
01:15:00,075 --> 01:15:01,040
0,335
lock.|
|

3007
01:15:01,040 --> 01:15:01,955
0,180 180,360 360,570 570,765 765,915
And as long as it
只要它不想更新与安迪的记录相同的记录，该交易就可以继续进行。

3008
01:15:01,955 --> 01:15:02,900
0,165 165,345 345,540 540,750 750,945
does not want to update

3009
01:15:02,900 --> 01:15:05,180
0,165 165,440 760,1160 1630,1980 1980,2280
the same record that is

3010
01:15:05,180 --> 01:15:07,265
0,555 555,800 1180,1485 1485,1785 1785,2085
Andy's record, that transaction is

3011
01:15:07,265 --> 01:15:08,580
0,195 195,345 345,605
allowed to proceed.|
|

3012
01:15:09,760 --> 01:15:10,570
0,240 240,345 345,465 465,630 630,810
We're at the level of
我们是在桌子的那一层吧。

3013
01:15:10,570 --> 01:15:11,640
0,120 120,380 670,1020
the table it.|
|

3014
01:15:11,680 --> 01:15:12,780
0,380 380,680 680,890 890,1010 1010,1100
Million going down to the
百万美元跌至底部如果他们是两个人，我们想要抢占IS的位置。为了确保您必须出于某种原因修改您想要获取的实际表本身。

3015
01:15:12,780 --> 01:15:13,440
0,195 195,285 285,390 390,540 540,660
bottom of if they're two,

3016
01:15:13,440 --> 01:15:14,220
0,165 165,300 300,450 450,630 630,780
we want to grab an

3017
01:15:14,220 --> 01:15:15,120
0,240 240,540 540,675 675,780 780,900
is slot. {To,be -} sure

3018
01:15:15,120 --> 01:15:15,780
0,105 105,225 225,375 375,510 510,660
you have to, for some

3019
01:15:15,780 --> 01:15:16,830
0,165 165,495 495,570 570,750 750,1050
reason, modify the actual table

3020
01:15:16,830 --> 01:15:17,720
0,240 240,390 390,510 510,630 630,890
itself you want to grab.|
|

3021
01:15:18,630 --> 01:15:19,780
0,400
Excellent.|
太棒了。|

3022
01:15:21,070 --> 01:15:22,490
0,400 510,785 785,920 920,1100 1100,1420
Yeah. {So,the -} question is,
嗯。因此，问题是，如果您知道您正在修改该表，您可以获取独占锁吗？所以在某些情况下，你会这么做。例如，也许。这又是一个可能，如果我试图对表进行模式更改，这意味着我将更改所有内容。为此，你会说，哦，我需要在桌子上拿到一把独占的锁。

3023
01:15:23,200 --> 01:15:24,375
0,275 275,440 440,605 605,830 830,1175
if you know you're modifying

3024
01:15:24,375 --> 01:15:25,155
0,120 120,300 300,495 495,630 630,780
the table, can you grab

3025
01:15:25,155 --> 01:15:26,745
0,210 210,575 595,995 1165,1440 1440,1590
an exclusive lock? So there

3026
01:15:26,745 --> 01:15:27,855
0,150 150,425 445,795 795,1005 1005,1110
are some situations where you

3027
01:15:27,855 --> 01:15:28,760
0,120 120,255 255,390 390,585 585,905
would do {that.,For -} {example,,maybe.

3028
01:15:29,020 --> 01:15:30,420
0,400 570,860 860,1130 1130,1280 1280,1400
-} And that's again a

3029
01:15:30,420 --> 01:15:31,545
0,260 400,660 660,855 855,990 990,1125
maybe if I'm trying to

3030
01:15:31,545 --> 01:15:32,550
0,90 90,240 240,615 615,825 825,1005
make a schema change to

3031
01:15:32,550 --> 01:15:33,660
0,105 105,350 550,825 825,960 960,1110
the table, that means I'm

3032
01:15:33,660 --> 01:15:35,040
0,90 90,195 195,440 580,980 1090,1380
going {to,change -} everything. And

3033
01:15:35,040 --> 01:15:35,820
0,165 165,345 345,510 510,645 645,780
for that you would say,

3034
01:15:35,820 --> 01:15:36,435
0,135 135,255 255,375 375,510 510,615
oh, I would need to

3035
01:15:36,435 --> 01:15:37,485
0,120 120,330 330,660 660,900 900,1050
grab an exclusive lock on

3036
01:15:37,485 --> 01:15:38,380
0,120 120,365
the table.|
|

3037
01:15:38,380 --> 01:15:39,775
0,380 400,675 675,855 855,1140 1140,1395
So if you know that
因此，如果您知道要对下面的所有内容进行更改，那么您将停止层次结构并获取锁。分层锁中没有说明我不可能获取表r上的X锁，所以这取决于我要做什么。

3038
01:15:39,775 --> 01:15:40,680
0,195 195,330 330,495 495,630 630,905
you're going to make changes

3039
01:15:40,700 --> 01:15:42,535
0,400 570,950 950,1330 1440,1715 1715,1835
to everything below, then you

3040
01:15:42,535 --> 01:15:43,810
0,150 150,360 360,510 510,1050 1050,1275
would stop the hierarchy and

3041
01:15:43,810 --> 01:15:44,980
0,285 285,390 390,650 670,990 990,1170
grabbed the lock. {Nothing,in -}

3042
01:15:44,980 --> 01:15:46,440
0,105 105,555 555,960 960,1155 1155,1460
the hierarchical locking say is

3043
01:15:46,460 --> 01:15:47,755
0,290 290,440 440,725 725,905 905,1295
that I couldn't have grabbed

3044
01:15:47,755 --> 01:15:48,685
0,135 135,345 345,555 555,720 720,930
an X lock on table

3045
01:15:48,685 --> 01:15:49,975
0,335 475,720 720,855 855,1080 1080,1290
r, so it depends upon

3046
01:15:49,975 --> 01:15:50,790
0,120 120,300 300,435 435,570 570,815
what I'm trying to do.|
|

3047
01:15:52,740 --> 01:15:54,100
0,400 750,1150
Yep, so.|
是的，所以。|

3048
01:15:54,400 --> 01:15:56,400
0,290 610,1010 1270,1560 1560,1725 1725,2000
This situation, is it possible
在这种情况下，我们有没有可能只是？

3049
01:15:56,540 --> 01:15:58,020
0,260 260,425 425,605 605,880
for us to just?|
|

3050
01:16:00,190 --> 01:16:01,280
0,580 690,1040
Logs all.|
记录所有。|

3051
01:16:02,270 --> 01:16:03,475
0,320 320,500 500,680 680,905 905,1205
Until we need to write
直到我们需要写作，因为例如，在我们的。

3052
01:16:03,475 --> 01:16:04,765
0,300 300,510 510,690 690,930 930,1290
because like for example, in

3053
01:16:04,765 --> 01:16:05,120
0,315
our.|
|

3054
01:16:05,240 --> 01:16:06,775
0,400 540,800 800,980 980,1190 1190,1535
Yeah, so you're saying, should
是的，所以你是说，事务t 2是否应该在元组n上获取一个读锁，然后升级到一个X锁？

3055
01:16:06,775 --> 01:16:08,935
0,365 565,885 885,1205 1495,1830 1830,2160
transaction t two have grabbed

3056
01:16:08,935 --> 01:16:10,825
0,120 120,360 360,725 1015,1415 1615,1890
a read lock on the

3057
01:16:10,825 --> 01:16:12,355
0,330 330,525 525,735 735,1025 1135,1530
tuple n and then upgraded

3058
01:16:12,355 --> 01:16:13,380
0,210 210,315 315,495 495,720 720,1025
to an X lock later?|
|

3059
01:16:14,190 --> 01:16:15,340
0,400
Or.|
或。|

3060
01:16:15,340 --> 01:16:16,705
0,270 270,480 480,740 790,1230 1230,1365
Sure, but also, couldn't I
当然，但同时，我不能同时喜欢这两笔交易吗？

3061
01:16:16,705 --> 01:16:18,030
0,180 180,485 505,840 840,1050 1050,1325
just like both of these

3062
01:16:18,110 --> 01:16:19,540
0,400
transactions?|
|

3063
01:16:20,310 --> 01:16:21,665
0,365 365,605 605,845 845,1115 1115,1355
Grab a shared block on
获取整个密钥上的共享块。

3064
01:16:21,665 --> 01:16:22,360
0,225 225,450 450,645
the entire key.|
|

3065
01:16:22,660 --> 01:16:23,805
0,380 380,635 635,755 755,890 890,1145
Yeah, because we did that
是啊，因为我们这么做是为了。

3066
01:16:23,805 --> 01:16:24,980
0,240 240,495 495,875
sort of for.|
|

3067
01:16:25,380 --> 01:16:26,430
0,165 165,440 460,750 750,900 900,1050
The people screen for the
人们筛选的是，是的，是的，你想得到什么？所以，但这会阻止某人进行更新。如果他们两个都看到了，这种情况就不会发生。现在，我们允许一个记录的更新与另一个记录的读取同时发生。

3068
01:16:26,430 --> 01:16:28,005
0,290 430,860 1090,1380 1380,1515 1515,1575
yep, yepup and what are

3069
01:16:28,005 --> 01:16:29,270
0,135 135,255 255,390 390,635 865,1265
you're trying to get? So,

3070
01:16:29,320 --> 01:16:30,540
0,290 290,470 470,665 665,920 920,1220
but that would prevent someone

3071
01:16:30,540 --> 01:16:31,860
0,240 240,420 420,710 760,1095 1095,1320
from doing an update. {This,would

3072
01:16:31,860 --> 01:16:33,105
0,165 165,330 330,620 760,1050 1050,1245
-} not happen if both

3073
01:16:33,105 --> 01:16:35,235
0,180 180,455 1045,1445 1645,1950 1950,2130
of them {see.,Right -} now

3074
01:16:35,235 --> 01:16:36,750
0,180 180,375 375,665 745,1145 1255,1515
we allowed an update to

3075
01:16:36,750 --> 01:16:37,890
0,135 135,410 460,810 810,1020 1020,1140
a record happen at the

3076
01:16:37,890 --> 01:16:39,050
0,165 165,330 330,465 465,740 760,1160
same time as a read

3077
01:16:39,070 --> 01:16:40,460
0,305 305,530 530,850
to another record.|
|

3078
01:16:40,550 --> 01:16:41,980
0,305 305,610 690,1040 1040,1265 1265,1430
We allowed update if I
如果我在桌子上拿到S的锁，我们就允许更新。不能对记录进行更新，对吗？看看这里发生了什么，对吧？我们允许，只要他们触摸同一张桌子的不同部分，我们都说没问题。这种层次化的锁定可以实现这一点。

3079
01:16:41,980 --> 01:16:43,255
0,315 315,495 495,750 750,1050 1050,1275
grabbed an s lock on

3080
01:16:43,255 --> 01:16:44,580
0,120 120,345 345,690 690,990 990,1325
the table. {No,updates -} can

3081
01:16:44,840 --> 01:16:47,200
0,400 870,1160 1160,1310 1310,1570 2070,2360
happen on the records, right?

3082
01:16:47,200 --> 01:16:48,370
0,270 270,555 555,720 720,915 915,1170
So look what happened here,

3083
01:16:48,370 --> 01:16:49,900
0,225 225,530 640,1040 1090,1365 1365,1530
right? We allowed as long

3084
01:16:49,900 --> 01:16:51,040
0,195 195,465 465,720 720,915 915,1140
as they're touching different parts

3085
01:16:51,040 --> 01:16:51,835
0,150 150,255 255,390 390,615 615,795
of the same table, we

3086
01:16:51,835 --> 01:16:52,900
0,105 105,345 345,570 570,825 825,1065
said it's {okay.,And -} this

3087
01:16:52,900 --> 01:16:54,720
0,570 570,855 855,1080 1080,1400
hierarchical locking allows that.|
|

3088
01:16:55,440 --> 01:16:56,720
0,290 290,785 785,935 935,1100 1100,1280
So logically, we still need
因此，从逻辑上讲，我们仍然需要有这样的意图。

3089
01:16:56,720 --> 01:16:58,090
0,285 285,585 585,780 780,1020 1020,1370
to have, like, the intention.|
|

3090
01:16:58,610 --> 01:17:00,265
0,400 510,785 785,935 935,1370 1370,1655
Yes. {So,the -} protocol is
是。所以协议是你要顺着。

3091
01:17:00,265 --> 01:17:01,960
0,375 375,495 495,705 705,1025
you'll go down the.|
|

3092
01:17:02,030 --> 01:17:04,290
0,820 1020,1355 1355,1550 1550,1810 1860,2260
Hierarchy of the database structure.|
数据库结构的层次结构。|

3093
01:17:05,270 --> 01:17:06,960
0,275 275,550 660,1060 1080,1385 1385,1690
You can issue an I
你可以发出一个I lock，I lock，或者6，lock，锁定我们讨论过的任何锁定模式。

3094
01:17:07,010 --> 01:17:08,665
0,400 540,940 990,1295 1295,1475 1475,1655
lock I lock or six,

3095
01:17:08,665 --> 01:17:09,430
0,195 195,360 360,495 495,615 615,765
lock any of the lock

3096
01:17:09,430 --> 01:17:10,940
0,270 270,390 390,585 585,920
modes we talked about.|
|

3097
01:17:11,040 --> 01:17:12,140
0,320 320,515 515,650 650,815 815,1100
But if you do an
但如果你做了意向锁，那么下面你必须拿到一把合适的锁。所以如果你做IS或X锁，你必须抓住下面的S或X锁，对吗？

3098
01:17:12,140 --> 01:17:13,880
0,375 375,765 765,1110 1110,1455 1455,1740
intention lock, then down below

3099
01:17:13,880 --> 01:17:14,795
0,165 165,345 345,540 540,705 705,915
you must grab a proper

3100
01:17:14,795 --> 01:17:15,545
0,270 270,450 450,540 540,645 645,750
lock. {So,if -} you do

3101
01:17:15,545 --> 01:17:16,340
0,105 105,315 315,525 525,630 630,795
an is or an X

3102
01:17:16,340 --> 01:17:17,675
0,320 400,690 690,900 900,1140 1140,1335
lock, you must grab a

3103
01:17:17,675 --> 01:17:18,755
0,240 240,480 480,615 615,795 795,1080
s or an X lock

3104
01:17:18,755 --> 01:17:20,020
0,365 595,995
below, right?|
|

3105
01:17:25,660 --> 01:17:27,080
0,335 335,515 515,755 755,1085 1085,1420
Yeah, the benefit is imagine
是的，好处是想象一下这个查询。所以，让我们来看看这个例子，这将会清楚地说明。好的，想象一下我得到了这笔交易，我们在这张幻灯片之后停下来，在下一节课上继续。

3106
01:17:27,100 --> 01:17:29,055
0,320 320,670 690,1090 1140,1475 1475,1955
this query. {So,here -} let's

3107
01:17:29,055 --> 01:17:30,165
0,285 285,435 435,630 630,900 900,1110
go to this example and

3108
01:17:30,165 --> 01:17:31,010
0,135 135,270 270,405 405,555 555,845
that will make it {clear.,Okay,

3109
01:17:31,270 --> 01:17:32,835
0,400 450,850 900,1235 1235,1460 1460,1565
-} so imagine I've got

3110
01:17:32,835 --> 01:17:34,020
0,165 165,455 565,840 840,1005 1005,1185
this transaction t one t

3111
01:17:34,155 --> 01:17:35,670
0,135 135,330 805,1110 1110,1365 1365,1515
2 t 3 we'll stop

3112
01:17:35,670 --> 01:17:36,630
0,240 240,480 480,660 660,825 825,960
after this slide and pick

3113
01:17:36,630 --> 01:17:37,260
0,105 105,210 210,345 345,465 465,630
it up in the next

3114
01:17:37,260 --> 01:17:38,140
0,320
class.|
|

3115
01:17:38,140 --> 01:17:39,340
0,315 315,540 540,720 720,930 930,1200
T wants to scan all
T希望扫描所有记录并只更新一条记录。

3116
01:17:39,340 --> 01:17:40,405
0,210 210,405 405,660 660,855 855,1065
the records and update only

3117
01:17:40,405 --> 01:17:41,300
0,335
one.|
|

3118
01:17:42,410 --> 01:17:44,890
0,400 720,1025 1025,1330 1950,2285 2285,2480
Okay, so now imagine this
好的，现在想象一下这里面有十亿行。所以我们现在能做的是，我们不能进来，拿一把6号锁。

3119
01:17:44,890 --> 01:17:45,760
0,120 120,240 240,450 450,765 765,870
is a billion rows in

3120
01:17:45,760 --> 01:17:47,800
0,260 430,830 1360,1695 1695,1905 1905,2040
it. {So,here -} what we

3121
01:17:47,800 --> 01:17:49,450
0,150 150,440 700,1100 1180,1470 1470,1650
can do is t one

3122
01:17:49,450 --> 01:17:50,755
0,165 165,315 315,590 760,1080 1080,1305
can come in and grab

3123
01:17:50,755 --> 01:17:52,140
0,195 195,450 450,815
a six lock.|
|

3124
01:17:52,360 --> 01:17:54,675
0,400 540,1070 1070,1390 1440,2150 2150,2315
S locke says implicitly. {Now,,down
S·洛克含蓄地说。现在，在下面，继续阅读任何东西。你有自由的许可，自由的权利去做那件事。

3125
01:17:54,675 --> 01:17:55,740
0,270 270,555 555,765 765,915 915,1065
-} below, go ahead and

3126
01:17:55,740 --> 01:17:57,000
0,270 270,540 540,825 825,1005 1005,1260
read {anything.,You've -} got the

3127
01:17:57,000 --> 01:17:58,440
0,350 430,795 795,1050 1050,1260 1260,1440
free permission, free rights to

3128
01:17:58,440 --> 01:17:59,540
0,150 150,300 300,560
go do that.|
|

3129
01:17:59,540 --> 01:18:00,425
0,210 210,330 330,540 540,735 735,885
But the record, you want
但是记录，你想去更新一下吗？如果你拿到了，就要一把X锁。

3130
01:18:00,425 --> 01:18:02,105
0,150 150,345 345,695 925,1325 1405,1680
to go update? Ask for

3131
01:18:02,105 --> 01:18:03,305
0,150 150,390 390,755 805,1065 1065,1200
an X lock if you

3132
01:18:03,305 --> 01:18:04,220
0,150 150,425
get it.|
|

3133
01:18:04,230 --> 01:18:05,075
0,305 305,470 470,605 605,725 725,845
Go ahead and do your
去做你的工作吧。只有两个锁，而不是获得了10亿个锁，对吗？

3134
01:18:05,075 --> 01:18:06,635
0,275 415,780 780,1035 1035,1365 1365,1560
work. {Only,two -} locks as

3135
01:18:06,635 --> 01:18:07,655
0,210 210,330 330,435 435,645 645,1020
opposed to a billion locks

3136
01:18:07,655 --> 01:18:09,660
0,275 655,1055 1315,1715
being acquired, right?|
|

3137
01:18:09,780 --> 01:18:11,435
0,400 480,815 815,1150 1200,1490 1490,1655
And another transaction could come
另一个事务可能想要同时读取它被允许通过的单个记录，因为它将获得一个与六锁兼容的IS锁。

3138
01:18:11,435 --> 01:18:12,350
0,240 240,480 480,645 645,795 795,915
in that wants to read

3139
01:18:12,350 --> 01:18:13,895
0,120 120,315 315,650 1090,1365 1365,1545
a single record it is

3140
01:18:13,895 --> 01:18:14,660
0,210 210,360 360,495 495,645 645,765
allowed to go through at

3141
01:18:14,660 --> 01:18:16,040
0,120 120,285 285,590 790,1065 1065,1380
the same time because it'll

3142
01:18:16,040 --> 01:18:17,210
0,210 210,375 375,650 700,1005 1005,1170
acquire an is lock which

3143
01:18:17,210 --> 01:18:18,200
0,120 120,570 570,690 690,810 810,990
is compatible with a six

3144
01:18:18,200 --> 01:18:19,120
0,320
lock.|
|

3145
01:18:19,610 --> 01:18:20,815
0,290 290,455 455,905 905,1025 1025,1205
So more parallelism is being
因此，更多的并行正在被允许。收集的锁更少，发布的锁更少，效率更高。

3146
01:18:20,815 --> 01:18:22,450
0,305 685,1035 1035,1350 1350,1455 1455,1635
allowed. {Fewer,locks -} are being

3147
01:18:22,450 --> 01:18:26,700
0,320 970,1370 1900,2300 3070,3470
gathered, being issued, efficient.|
|

3148
01:18:26,700 --> 01:18:28,515
0,150 150,650 790,1185 1185,1560 1560,1815
More parallelels is allowed because
允许更多的并行是因为在同一个表上，该读请求被允许通过第三个事务，该事务将扫描所有记录。它也被允许做它的所有工作，直到它到达最后一个记录。所以，如果它要处理最后一笔交易，如果它想要获取S锁。

3149
01:18:28,515 --> 01:18:29,930
0,135 135,270 270,450 450,755 1015,1415
on that same table, that

3150
01:18:29,980 --> 01:18:31,155
0,380 380,635 635,830 830,1040 1040,1175
read request is allowed to

3151
01:18:31,155 --> 01:18:32,570
0,150 150,455 625,900 900,1095 1095,1415
go through a third transaction

3152
01:18:32,710 --> 01:18:34,605
0,305 305,610 810,1145 1145,1510 1560,1895
comes in that scans all

3153
01:18:34,605 --> 01:18:36,120
0,195 195,455 895,1170 1170,1305 1305,1515
the records. {It,is -} also

3154
01:18:36,120 --> 01:18:37,050
0,240 240,390 390,540 540,750 750,930
allowed to do all of

3155
01:18:37,050 --> 01:18:39,080
0,165 165,470 610,1010 1390,1710 1710,2030
its work till it gets

3156
01:18:39,160 --> 01:18:41,670
0,275 275,550 690,1090 1860,2255 2255,2510
to that last {record.,So -}

3157
01:18:41,670 --> 01:18:42,800
0,120 120,360 360,525 525,780 780,1130
if it's going to transaction

3158
01:18:42,940 --> 01:18:44,550
0,335 335,605 605,940 1230,1490 1490,1610
that last transaction, if it

3159
01:18:44,550 --> 01:18:45,330
0,150 150,300 300,420 420,555 555,780
wants to grab an s

3160
01:18:45,330 --> 01:18:46,180
0,350
lock.|
|

3161
01:18:46,240 --> 01:18:48,075
0,275 275,455 455,760 1230,1595 1595,1835
It will wait till the
它会一直等到表r，因为它有一个与S日志不兼容的6锁，所以它会一直等下去。

3162
01:18:48,075 --> 01:18:49,845
0,255 255,635 1255,1515 1515,1635 1635,1770
table r because it has

3163
01:18:49,845 --> 01:18:50,655
0,135 135,315 315,540 540,705 705,810
a six lock which is

3164
01:18:50,655 --> 01:18:51,975
0,585 585,705 705,825 825,1020 1020,1320
incompatible with an s log,

3165
01:18:51,975 --> 01:18:53,210
0,210 210,465 465,705 705,960 960,1235
so it'll wait for that.|
|

3166
01:18:53,800 --> 01:18:55,560
0,210 210,435 435,675 675,1010 1360,1760
Until it goes further down.|
直到它进一步下跌。|

3167
01:18:56,780 --> 01:18:57,880
0,290 290,485 485,740 740,965 965,1100
Okay. {And,then -} when it
好吧。然后，当它完成时，它就会得到那个请求。

3168
01:18:57,880 --> 01:18:58,960
0,150 150,420 420,675 675,870 870,1080
is done, it goes get

3169
01:18:58,960 --> 01:19:00,160
0,270 270,650
that request.|
|

3170
01:19:00,270 --> 01:19:01,265
0,395 395,665 665,785 785,890 890,995
So, you know, you could
所以，你知道，你可以说，哦，交易2可能抓住了一把IS锁，然后抓住了10亿次阅读，直到它达到最后的记录。即使是这样，如果这笔交易也是允许的。所以如果它想说我想去的话，我想这么做，我不介意支付锁的费用，因为我想得到这个平衡。您可以这样做，但您可能不会这样做，因为这会使协议变得非常困难。但基本上你在这里看到的，即使有交易t1和t2，也是这样。

3171
01:19:01,265 --> 01:19:03,065
0,120 120,315 315,570 570,905 1435,1800
have said, oh, transaction two

3172
01:19:03,065 --> 01:19:04,150
0,225 225,375 375,660 660,825 825,1085
could have grabbed an is

3173
01:19:04,260 --> 01:19:05,690
0,400 450,740 740,965 965,1325 1325,1430
lock and then grabbed a

3174
01:19:05,690 --> 01:19:07,310
0,260 280,980 1030,1305 1305,1455 1455,1620
billion reads till it got

3175
01:19:07,310 --> 01:19:08,240
0,150 150,255 255,420 420,675 675,930
to the last record. {Even,that

3176
01:19:08,240 --> 01:19:09,110
0,210 210,375 375,540 540,720 720,870
-} would be allowed if

3177
01:19:09,110 --> 01:19:10,280
0,120 120,380 460,735 735,960 960,1170
the {transaction.,So -} wanted to

3178
01:19:10,280 --> 01:19:11,375
0,135 135,410 520,765 765,885 885,1095
do that if it wanted

3179
01:19:11,375 --> 01:19:12,730
0,180 180,425 475,765 765,1005 1005,1355
to say I want to

3180
01:19:12,840 --> 01:19:14,300
0,400 600,935 935,1130 1130,1325 1325,1460
go and I don't mind

3181
01:19:14,300 --> 01:19:15,245
0,165 165,300 300,555 555,825 825,945
paying the cost for the

3182
01:19:15,245 --> 01:19:16,385
0,425 505,765 765,870 870,1005 1005,1140
locks because I wanted to

3183
01:19:16,385 --> 01:19:17,240
0,120 120,270 270,525 525,750 750,855
get {this,balance. -} You could

3184
01:19:17,240 --> 01:19:17,975
0,120 120,240 240,360 360,480 480,735
do that, but you probably

3185
01:19:17,975 --> 01:19:19,055
0,390 390,525 525,705 705,885 885,1080
wouldn't do that because it'd

3186
01:19:19,055 --> 01:19:20,140
0,105 105,225 225,600 600,780 780,1085
make the {protocol,very -} hard.

3187
01:19:20,400 --> 01:19:21,725
0,350 350,700 750,1025 1025,1160 1160,1325
But essentially what you saw

3188
01:19:21,725 --> 01:19:23,405
0,305 505,840 840,1065 1065,1355 1405,1680
here, even with transaction t

3189
01:19:23,540 --> 01:19:25,060
0,150 150,330 330,620 880,1200 1200,1520
1 t two is that.|
|

3190
01:19:25,690 --> 01:19:27,680
0,350 350,590 590,935 935,1210
Very few locks were.|
很少有锁是。|

3191
01:19:28,620 --> 01:19:30,440
0,380 380,605 605,880 1320,1625 1625,1820
Requests were made and you
请求已发出，并且您允许此级别的并行性。

3192
01:19:30,440 --> 01:19:31,900
0,195 195,405 405,615 615,780 780,1460
allowed this level of parallelism.|
|

3193
01:19:33,250 --> 01:19:34,305
0,275 275,440 440,680 680,905 905,1055
So you really get a
因此，与其他方式相比，您可以获得更高性能的数据库系统。如果没有有意设置的锁和层次结构，就不会有这种级别的并行性。

3194
01:19:34,305 --> 01:19:35,930
0,195 195,510 510,870 870,1230 1230,1625
much higher performance database system

3195
01:19:36,190 --> 01:19:37,245
0,275 275,410 410,545 545,800 800,1055
than you would get through

3196
01:19:37,245 --> 01:19:38,025
0,105 105,255 255,480 480,645 645,780
the other ways. {If,you -}

3197
01:19:38,025 --> 01:19:39,195
0,255 255,420 420,630 630,975 975,1170
didn't have the intentional locks

3198
01:19:39,195 --> 01:19:40,875
0,120 120,725 1045,1320 1320,1485 1485,1680
and hierarchies, you will not

3199
01:19:40,875 --> 01:19:42,320
0,195 195,360 360,555 555,750 750,1445
get this level of parallelism.|
|

3200
01:19:42,860 --> 01:19:43,900
0,260 260,470 470,770 770,890 890,1040
All alright I'm going to
好了，我就到此为止，我可以在线下回答问题，然后我会在下一节课上从这张幻灯片中拿起这张幻灯片，沙伊，男孩们都是帮派，耶耶，现在听着，我是罂粟花，他妈的勾住了28,000美元，看它是不是煮熟了，你没有听到暴徒的声音，但还是受到了震动，我用剪辑的底部打你，告诉你抬头看你，让我看看你的脸在哪里，我把你的脸打回去，我有一块积木板，敲打不了痕迹，风格就像是t作为证据，你可以。不要在多米尼加或你叫我多米尼加黑色天鹅绒黑色皮革黑色绒面Timmerins，我整个黑色肮脏的8送你到梨门你得到你的沙拉试图说明，这是你的第一个错误，我不会撒谎，拿着你的脸看体重，我的孙子重，我的体重通过每一个州，当他问我如何生活告诉我。

3201
01:19:43,900 --> 01:19:44,605
0,150 150,300 300,405 405,525 525,705
stop here I can take

3202
01:19:44,605 --> 01:19:46,150
0,270 270,845 955,1230 1230,1365 1365,1545
questions offline and then I'll

3203
01:19:46,150 --> 01:19:47,380
0,105 105,270 270,560 580,915 915,1230
pick up from this slide

3204
01:19:47,380 --> 01:19:48,865
0,255 255,375 375,555 555,890 940,1485
in the next class Sha

3205
01:19:48,865 --> 01:20:00,115
0,255 255,545 5905,6305 10555,10935 10935,11250
hit it Gang boys are

3206
01:20:00,115 --> 01:20:06,780
0,335 4915,5315 5605,6005 6085,6375 6375,6665
Gang yeah yeah now listen

3207
01:20:07,040 --> 01:20:08,200
0,365 365,470 470,845 845,1010 1010,1160
I'm the poppy with the

3208
01:20:08,200 --> 01:20:10,210
0,555 555,825 825,1130 1240,1830 1830,2010
motherfuck hook up 28 a

3209
01:20:10,210 --> 01:20:11,545
0,290 340,720 720,975 975,1125 1125,1335
grand depending on if it's

3210
01:20:11,545 --> 01:20:12,730
0,195 195,425 535,825 825,1050 1050,1185
cooked up you ain't hear

3211
01:20:12,730 --> 01:20:14,035
0,135 135,315 315,650 760,1080 1080,1305
the mob yet still got

3212
01:20:14,035 --> 01:20:15,160
0,165 165,345 345,600 600,870 870,1125
your shook up I smack

3213
01:20:15,160 --> 01:20:16,045
0,150 150,285 285,420 420,645 645,885
you with the bottom of

3214
01:20:16,045 --> 01:20:16,930
0,165 165,360 360,510 510,675 675,885
the clip to tell you

3215
01:20:16,930 --> 01:20:18,070
0,195 195,470 520,840 840,1020 1020,1140
look up show me where

3216
01:20:18,070 --> 01:20:19,045
0,120 120,330 330,600 600,810 810,975
the face at for I

3217
01:20:19,045 --> 01:20:20,245
0,180 180,375 375,630 630,960 960,1200
blow your face back I

3218
01:20:20,245 --> 01:20:21,550
0,150 150,315 315,750 750,1050 1050,1305
gotta a blockboard taps the

3219
01:20:21,550 --> 01:20:23,080
0,330 330,645 645,870 870,1185 1185,1530
ves can't trace that styl

3220
01:20:23,080 --> 01:20:24,295
0,195 195,405 405,705 705,960 960,1215
is like t for proof

3221
01:20:24,295 --> 01:20:25,405
0,255 255,570 570,765 765,960 960,1110
you can't lace that at

3222
01:20:25,405 --> 01:20:26,965
0,150 150,915 915,1140 1140,1230 1230,1560
the Dominican or y youa

3223
01:20:26,965 --> 01:20:28,930
0,270 270,450 450,1170 1170,1500 1500,1965
call me Dominican black skelly

3224
01:20:28,930 --> 01:20:30,730
0,225 225,675 675,945 945,1290 1290,1800
black leather black suede timmerins

3225
01:20:30,730 --> 01:20:32,230
0,195 195,435 435,750 750,1065 1320,1500
my whole black dirty 8

3226
01:20:32,230 --> 01:20:33,130
0,195 195,375 375,510 510,645 645,900
send you to the pear

3227
01:20:33,130 --> 01:20:34,585
0,380 520,795 795,945 945,1095 1095,1455
gates you get your salat

3228
01:20:34,585 --> 01:20:35,455
0,165 165,330 330,495 495,660 660,870
trying to state and that's

3229
01:20:35,455 --> 01:20:36,955
0,105 105,365 385,785 985,1275 1275,1500
your first mistake I ain't

3230
01:20:36,955 --> 01:20:37,915
0,210 210,450 450,600 600,780 780,960
lying for that take your

3231
01:20:37,915 --> 01:20:39,250
0,180 180,345 345,585 585,965 1045,1335
fam of see weight my

3232
01:20:39,250 --> 01:20:40,255
0,375 375,525 525,705 705,825 825,1005
grandson heavy mewe weight to

3233
01:20:40,255 --> 01:20:41,500
0,195 195,375 375,645 645,905 985,1245
ran through everyby state when

3234
01:20:41,500 --> 01:20:42,280
0,105 105,255 255,420 420,570 570,780
he ask me how I'm

3235
01:20:42,280 --> 01:20:43,300
0,360 360,675 675,990
livin tell my.|
|

3236
01:20:43,300 --> 01:20:48,999
0,120 120,270 270,560
Have been great.|
一直都很棒。|
