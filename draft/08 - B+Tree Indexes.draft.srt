1
00:00:26,170 --> 00:00:40,470
0,490 13590,13835 13835,13940 13940,14105 14105,14300

2
00:00:40,470 --> 00:00:42,300
0,225 225,560 580,870 870,1160 1570,1830

3
00:00:42,300 --> 00:00:46,005
0,150 150,345 345,650 2050,2450 3400,3705
{ - -} Okay, alright,
好的，今天有很多东西要讨论，

4
00:00:46,005 --> 00:00:47,145
0,375 375,585 585,750 750,915 915,1140
let's lots of discuss today,|
|

5
00:00:47,145 --> 00:00:47,820
0,150 150,240 240,330 330,510 510,675
so I'm gonna [plow right]
所以我要把所有东西[]。

6
00:00:47,820 --> 00:00:49,540
0,270 270,650
through everything.|
|

7
00:00:49,770 --> 00:00:51,455
0,400 840,1100 1100,1220 1220,1400 1400,1685
So again, a quick reminder,|
再次提醒一下，|

8
00:00:51,455 --> 00:00:53,140
0,315 315,975 975,1140 1140,1365 1365,1685
upcoming events now correct dates,|
即将到来的活动现在改正了日期，|

9
00:00:53,520 --> 00:00:55,145
0,290 290,580 810,1190 1190,1445 1445,1625
so today, {} at {4:30
所以今天，在 4:30 通过 Zoom ，

10
00:00:55,145 --> 00:00:56,210
0,270 270,570 570,840 840,1020 1020,1065
-} over Zoom,| we're going
|我们将有 Postgres ML 的联合创始人，

11
00:00:56,210 --> 00:00:57,830
0,60 60,290 670,1070 1090,1365 1365,1620
to have the Co founder

12
00:00:57,830 --> 00:01:00,250
0,260 400,825 825,1190 1540,1940 2020,2420
of Postgres ML,| basically a
|基本上是 Postgres 的修改版本，

13
00:01:01,800 --> 00:01:03,230
0,485 485,650 650,800 800,1190 1190,1430
modified version of Postgres| or
|或它不是 Postgres 修改的，

14
00:01:03,230 --> 00:01:04,700
0,195 195,410 580,975 975,1155 1155,1470
it's not Postgres isn't modified,|
|

15
00:01:04,700 --> 00:01:06,245
0,410 580,885 885,1080 1080,1290 1290,1545
they're building off the extension
他们建立 Postgres 的扩展系统和 API ，

16
00:01:06,245 --> 00:01:08,210
0,300 300,665 745,1350 1350,1590 1590,1965
system and API in Postgres,|
|

17
00:01:08,210 --> 00:01:09,420
0,255 255,590
to support
来直接在 Postgres 内部支持机器学习框架和大型语言模型，

18
00:01:09,420 --> 00:01:12,015
0,290 1390,1665 1665,1875 1875,2370 2370,2595
{} machine learning frameworks and

19
00:01:12,015 --> 00:01:13,350
0,195 195,450 450,750 750,1095 1095,1335
large language models directly inside

20
00:01:13,350 --> 00:01:14,280
0,105 105,525 525,825 825,870 870,930
of Postgres,| he's going to
|他将在谈论他们在构建的东西，

21
00:01:14,280 --> 00:01:15,135
0,105 105,300 300,495 495,675 675,855
talk about the stuff that

22
00:01:15,135 --> 00:01:16,605
0,180 180,255 255,515 955,1275 1275,1470
they've been building,| next week,
|下周，我们可能有一家更大的矢量数据库公司来做演讲， Weaviate ，

23
00:01:16,605 --> 00:01:17,490
0,120 120,255 255,545 565,810 810,885
we have probably one of

24
00:01:17,490 --> 00:01:19,665
0,90 90,350 970,1305 1305,1610 1810,2175
the bigger vector database companies

25
00:01:19,665 --> 00:01:20,385
0,225 225,315 315,375 375,465 465,720
come to give a talk

26
00:01:20,385 --> 00:01:21,975
0,635 775,1020 1020,1110 1110,1275 1275,1590
Weaviate,| and then after that,
|然后在它之后将是 FeatureForm ，

27
00:01:21,975 --> 00:01:23,295
0,515 625,855 855,915 915,1065 1065,1320
it's going to be {FeatureForm

28
00:01:23,295 --> 00:01:24,735
0,335 565,810 810,975 975,1230 1230,1440
-}| and after {FeatureForm -}
|在 FeatureForm 之后是 FeatureBase ，

29
00:01:24,735 --> 00:01:26,625
0,195 195,375 375,725 1195,1590 1590,1890
its {FeatureBase -}, right,| same
|相同的名字，不同的系统。

30
00:01:26,625 --> 00:01:28,725
0,240 240,510 510,845 1705,1980 1980,2100
name, different systems.| Again, this
|再说一次，这是可选的，如果你想参加的话。

31
00:01:28,725 --> 00:01:30,290
0,105 105,605 925,1185 1185,1305 1305,1565
is optional by all means

32
00:01:30,970 --> 00:01:32,460
0,260 260,365 365,470 470,730 1230,1490
attend if you want.| And
|然后，我在 Piazza 贴上，

33
00:01:32,460 --> 00:01:33,195
0,165 165,345 345,480 480,600 600,735
then as I post on

34
00:01:33,195 --> 00:01:34,335
0,390 390,540 540,705 705,915 915,1140
Piazza,| while sending out an
|给数据库的朋友们发了一封电子邮件，

35
00:01:34,335 --> 00:01:35,480
0,240 240,480 480,630 630,810 810,1145
email to the database friends,|
|

36
00:01:35,800 --> 00:01:37,335
0,335 335,560 560,950 950,1220 1220,1535
companies like theses,| with everyone's
像这样的公司，|附着大家的简历，

37
00:01:37,335 --> 00:01:38,520
0,435 435,555 555,750 750,945 945,1185
CVs,| if you, if you
|如果你昨天上传了。

38
00:01:38,520 --> 00:01:41,160
0,480 480,615 615,920
uploaded it yesterday.|
|

39
00:01:41,840 --> 00:01:42,840
0,245 245,490
All right.|
好的。|

40
00:01:42,840 --> 00:01:43,905
0,240 240,435 435,705 705,900 900,1065
So last class we talked
上一节课，我们讨论了哈希表，

41
00:01:43,905 --> 00:01:46,185
0,180 180,360 360,605 1525,1925 2005,2280
about hash tables| and we
|我们讨论了这个重要的数据结构，

42
00:01:46,185 --> 00:01:47,685
0,195 195,515 655,1020 1020,1275 1275,1500
talked how this important data

43
00:01:47,685 --> 00:01:49,215
0,335 745,1245 1245,1320 1320,1410 1410,1530
structure,| that's going to give
|它会给我们带来很好的 O(1) 平均时间复杂度，

44
00:01:49,215 --> 00:01:50,715
0,165 165,375 375,695 955,1275 1275,1500
us this nice {O(1) -}

45
00:01:50,715 --> 00:01:52,155
0,225 225,495 495,1065 1065,1275 1275,1440
average time complexity| to do
|来查找键和值的匹配。

46
00:01:52,155 --> 00:01:54,650
0,455 1435,1905 1905,2100 2100,2250 2250,2495
lookup matching keys to values.|
|

47
00:01:56,200 --> 00:01:57,390
0,320 320,515 515,680 680,905 905,1190
And we spent time talking
我们花时间讨论了静态和动态哈希方法之间的区别，

48
00:01:57,390 --> 00:01:58,605
0,270 270,585 585,840 840,1005 1005,1215
about how there was this

49
00:01:58,605 --> 00:02:01,035
0,665 745,1145 1585,1965 1965,2220 2220,2430
differentiation between static and dynamic

50
00:02:01,035 --> 00:02:03,660
0,390 390,905 1795,2130 2130,2415 2415,2625
hashing schemes,| like static was
|比如静态使用的是固定大小 slot 数量，

51
00:02:03,660 --> 00:02:04,845
0,225 225,450 450,660 660,945 945,1185
used of fixed size number

52
00:02:04,845 --> 00:02:06,690
0,135 135,425 835,1215 1215,1530 1530,1845
of slots,| whereas the extendible
|而可扩展哈希、链式哈希和线性哈希，

53
00:02:06,690 --> 00:02:09,240
0,450 450,750 750,1215 1215,1550 2140,2550
hashing, chain hashing and linear

54
00:02:09,240 --> 00:02:10,815
0,470 730,1050 1050,1245 1245,1380 1380,1575
hashing| all had the ability
|都具有随时间递增增长的能力，

55
00:02:10,815 --> 00:02:12,330
0,210 210,485 655,1140 1140,1290 1290,1515
to grow incrementally over time|
|

56
00:02:12,330 --> 00:02:13,650
0,195 195,600 600,885 885,1125 1125,1320
to accommodate more more keys
以容纳比你最初设想的更多的键。

57
00:02:13,650 --> 00:02:15,000
0,150 150,270 270,450 450,1010
than you originally envisioned.|
|

58
00:02:15,410 --> 00:02:16,750
0,245 245,335 335,500 500,1055 1055,1340
So the main takeaway from
所以，上一节课的主要收获应该是，

59
00:02:16,750 --> 00:02:18,145
0,255 255,585 585,840 840,1100 1120,1395
last class should be,| we
|我们花了大部分时间讨论如何处理这个复杂的问题，

60
00:02:18,145 --> 00:02:18,820
0,165 165,330 330,435 435,525 525,675
spent most of our time

61
00:02:18,820 --> 00:02:19,615
0,180 180,345 345,480 480,645 645,795
talking about how to deal

62
00:02:19,615 --> 00:02:21,820
0,90 90,335 355,755 1615,1935 1935,2205
with the complex,| two keys,
|两个键，两个不同的键哈希到相同的位置，你会做什么，

63
00:02:21,820 --> 00:02:23,245
0,440 700,945 945,1065 1065,1215 1215,1425
hash two different keys hash

64
00:02:23,245 --> 00:02:24,400
0,75 75,135 135,300 300,635 895,1155
to the same location, what

65
00:02:24,400 --> 00:02:26,395
0,90 90,195 195,470 1600,1875 1875,1995
do you do,| and then
|然后我们主要讨论了，

66
00:02:26,395 --> 00:02:27,265
0,90 90,270 270,480 480,630 630,870
we mostly talk about,| how
|这些哈希表将如何在大多数系统中主要用于内部数据结构，

67
00:02:27,265 --> 00:02:28,555
0,255 255,525 525,705 705,960 960,1290
these hash tables are primarily

68
00:02:28,555 --> 00:02:29,380
0,210 210,240 240,330 330,555 555,825
going to be used in

69
00:02:29,380 --> 00:02:31,795
0,270 270,620 1390,1790 1840,2160 2160,2415
most systems for internal data

70
00:02:31,795 --> 00:02:33,510
0,335 685,960 960,1125 1125,1365 1365,1715
structures,| like your page table
|比如如页表和项目 1 ，或页面目录，

71
00:02:33,710 --> 00:02:35,120
0,290 290,545 545,910
and project 1,

72
00:02:35,310 --> 00:02:36,455
0,260 260,380 380,590 590,965 965,1145
or the page directory| or
|或跟踪数据库系统本身的状态的其他东西，

73
00:02:36,455 --> 00:02:37,175
0,165 165,285 285,420 420,525 525,720
the other thing is keeping

74
00:02:37,175 --> 00:02:38,435
0,210 210,435 435,780 780,975 975,1260
track of what's the state

75
00:02:38,435 --> 00:02:39,635
0,300 300,510 510,645 645,870 870,1200
of of the database system

76
00:02:39,635 --> 00:02:41,585
0,315 315,540 540,720 720,965 1615,1950
itself,| while we're running,| we'll
|当我们运行时，|我们将再次看到哈希表，

77
00:02:41,585 --> 00:02:42,650
0,120 120,375 375,600 600,885 885,1065
see hash tables again,| when
|当我们谈论如何 Join 时，

78
00:02:42,650 --> 00:02:43,355
0,135 135,300 300,465 465,600 600,705
we talk about how to

79
00:02:43,355 --> 00:02:45,515
0,120 120,465 465,995 1255,1655 1885,2160
you Joins sufficiently,| {} but
|但是，在大多数情况下，

80
00:02:45,515 --> 00:02:46,220
0,165 165,285 285,360 360,510 510,705
again for the most part|
|

81
00:02:46,220 --> 00:02:47,440
0,150 150,270 270,525 525,870 870,1220
these are primarily used for
它们主要用于内部数据结构。

82
00:02:47,490 --> 00:02:50,270
0,305 305,515 515,820 2040,2345 2345,2780
internal data structures.| So today's
|所以今天的课程，我们现在讨论的是 B+ 树，

83
00:02:50,270 --> 00:02:51,005
0,180 180,375 375,480 480,615 615,735
class we're now talking about

84
00:02:51,005 --> 00:02:53,540
0,165 165,360 360,665 1765,2165 2215,2535
{B+ -} trees| and these
|它们将主要是默认的选择，

85
00:02:53,540 --> 00:02:54,730
0,165 165,240 240,315 315,560 790,1190
are going to be primarily

86
00:02:54,930 --> 00:02:56,480
0,365 365,665 665,1000 1170,1445 1445,1550
the default choice,| when you
|当你想要在关系数据库系统中建立索引时。

87
00:02:56,480 --> 00:02:57,250
0,75 75,165 165,270 270,450 450,770
want to have an index

88
00:02:57,720 --> 00:02:59,405
0,365 365,730 750,1025 1025,1355 1355,1685
in, in a relational database

89
00:02:59,405 --> 00:03:00,350
0,345 345,555 555,630 630,735 735,945
system.| So if you call
|所以如果你调用 CREATE INDEX ，

90
00:03:00,350 --> 00:03:01,560
0,300 300,650
CREATE INDEX,|
|

91
00:03:01,690 --> 00:03:02,985
0,305 305,830 830,965 965,1055 1055,1295
{yeah,99% -} of the time,
是的， 99% 的情况下，在大多数系统中，

92
00:03:02,985 --> 00:03:04,170
0,285 285,480 480,785 805,1095 1095,1185
in most systems,| you'll be
|你会得到一个看起来像 B+ 树的东西。

93
00:03:04,170 --> 00:03:06,135
0,260 1210,1530 1530,1710 1710,1845 1845,1965
getting something that looks like

94
00:03:06,135 --> 00:03:07,815
0,90 90,210 210,390 390,695 1435,1680
A B plus tree,| Then
|然后我们再讨论一下，

95
00:03:07,815 --> 00:03:08,670
0,150 150,300 300,540 540,675 675,855
we'll talk about,| so we'll
|我们将首先进行一个高层次的概述，

96
00:03:08,670 --> 00:03:09,450
0,180 180,345 345,465 465,600 600,780
first go a high level

97
00:03:09,450 --> 00:03:10,560
0,450 450,660 660,840 840,975 975,1110
overview| of what a B
|B+ 树是什么样子的，

98
00:03:10,560 --> 00:03:12,375
0,180 180,345 345,525 525,830 1540,1815
plus tree looks like,| what
|它是什么组成的，

99
00:03:12,375 --> 00:03:13,695
0,165 165,455 655,1020 1020,1140 1140,1320
makes it,| what's the plus,
|B+ 树与常规的 B 树相比。

100
00:03:13,695 --> 00:03:14,955
0,165 165,315 315,510 510,815 925,1260
and {B+ -} tree versus

101
00:03:14,955 --> 00:03:17,160
0,270 270,495 495,785 1735,1995 1995,2205
regular B tree.| And I'll
|我将讨论一些基本的设计选择，

102
00:03:17,160 --> 00:03:18,075
0,90 90,225 225,360 360,600 600,915
talk about some basic design

103
00:03:18,075 --> 00:03:19,395
0,330 330,720 720,975 975,1125 1125,1320
choices,| how when we actually
|当我们想要构建一个系统时，

104
00:03:19,395 --> 00:03:20,730
0,150 150,255 255,435 435,755 1045,1335
want to build one| and
|我们将结束，

105
00:03:20,730 --> 00:03:21,860
0,165 165,345 345,510 510,780 780,1130
then we'll finish up| to
|直到我们有时间，

106
00:03:22,360 --> 00:03:23,150
0,230 230,305 305,425 425,545 545,790
to the time we have,|
|

107
00:03:23,890 --> 00:03:24,750
0,335 335,500 500,575 575,695 695,860
to that we have time
直到我们有的最后的时间，

108
00:03:24,750 --> 00:03:25,785
0,135 135,225 225,470 700,945 945,1035
at the end,| talk about
|讨论所有不同的方法，

109
00:03:25,785 --> 00:03:26,775
0,195 195,375 375,525 525,795 795,990
all the different ways| you
|你可以实际优化和提高这些不同系统的性能，

110
00:03:26,775 --> 00:03:29,265
0,135 135,375 375,815 1345,1745 2185,2490
can actually optimize and improve

111
00:03:29,265 --> 00:03:30,240
0,225 225,405 405,540 540,720 720,975
performance of these different systems|
|

112
00:03:30,240 --> 00:03:31,740
0,210 210,405 405,740 910,1230 1230,1500
and the examples real systems
以及真实系统今天在做的例子。

113
00:03:31,740 --> 00:03:33,440
0,350 520,780 780,960 960,1280
are actually doing today.|
|

114
00:03:33,610 --> 00:03:35,060
0,400
Okay?|
好的？|

115
00:03:35,810 --> 00:03:36,625
0,335 335,515 515,605 605,710 710,815
{All,right}, so the first we
好的，所以我们首先要讨论的是什么是 B+ 树。

116
00:03:36,625 --> 00:03:37,630
0,60 60,165 165,330 330,605 685,1005
got to discuss is what

117
00:03:37,630 --> 00:03:39,060
0,210 210,500 610,915 915,1125 1125,1430
is a {B+ -} tree.|
|

118
00:03:39,710 --> 00:03:40,540
0,275 275,395 395,485 485,620 620,830
And so the {B+ -}
B+ 树属于一种称为 B 树的数据结构，

119
00:03:40,540 --> 00:03:42,745
0,270 270,525 525,810 810,1190 1810,2205
tree is in a category

120
00:03:42,745 --> 00:03:44,530
0,240 240,405 405,725 745,1145 1465,1785
of data structures called B

121
00:03:44,530 --> 00:03:45,715
0,320 580,840 840,1020 1020,1095 1095,1185
trees,| and what's sort of
|在数据库文献中，令人困惑的是，

122
00:03:45,715 --> 00:03:47,785
0,395 415,735 735,1005 1005,1355 1675,2070
confusing about this in database

123
00:03:47,785 --> 00:03:49,915
0,395 1105,1395 1395,1635 1635,1920 1920,2130
literature,| different database systems, is
|不同的数据库系统中，

124
00:03:49,915 --> 00:03:51,445
0,275 595,945 945,1110 1110,1350 1350,1530
that,| there's the class of
|有一类数据结构被称为 B 树，

125
00:03:51,445 --> 00:03:52,555
0,105 105,300 300,615 615,900 900,1110
the data structure called B

126
00:03:52,555 --> 00:03:53,995
0,305 745,1020 1020,1155 1155,1335 1335,1440
trees,| and then there's a
|然后是一种特殊的数据结构，称为 B 树，

127
00:03:53,995 --> 00:03:55,570
0,275 355,705 705,1020 1020,1320 1320,1575
specific data structure called B

128
00:03:55,570 --> 00:03:57,330
0,320 790,1065 1065,1245 1245,1455 1455,1760
tree,| and then some database
|然后一些数据库系统实际上使用的是 B+ 树，

129
00:03:57,380 --> 00:03:58,690
0,335 335,590 590,770 770,1010 1010,1310
systems are actually using {B+

130
00:03:58,690 --> 00:04:00,475
0,270 270,620 1270,1545 1545,1725 1725,1785
-} trees,| but they're going
|但他们将自己称为 B 树。

131
00:04:00,475 --> 00:04:01,690
0,90 90,330 330,725 775,1035 1035,1215
to call themselves a B

132
00:04:01,690 --> 00:04:02,640
0,320
tree,

133
00:04:02,740 --> 00:04:03,555
0,380 380,590 590,650 650,725 725,815
right.| So if you go
|所以如果你去看 Postgres 代码，

134
00:04:03,555 --> 00:04:04,460
0,90 90,165 165,255 255,615 615,905
look at the Postgres code,|
|

135
00:04:04,600 --> 00:04:05,460
0,320 320,380 380,440 440,635 635,860
they're going to refer to
他们会把他们的数据结构称为 B 树，

136
00:04:05,460 --> 00:04:06,450
0,180 180,420 420,675 675,870 870,990
their data structure as a

137
00:04:06,450 --> 00:04:07,725
0,180 180,500 820,1050 1050,1140 1140,1275
B tree,| but as far
|但据我所知，这是一棵 B+ 树，

138
00:04:07,725 --> 00:04:08,670
0,120 120,225 225,375 375,645 645,945
as I can tell, it's

139
00:04:08,670 --> 00:04:10,125
0,105 105,285 285,525 525,860 1150,1455
a {B+ -} tree,| with
|使用了一些现代技术，比如 B-Link 树。

140
00:04:10,125 --> 00:04:12,345
0,305 505,905 1075,1475 1495,1895 1945,2220
some modern techniques, like from

141
00:04:12,345 --> 00:04:13,560
0,120 120,255 255,450 450,755
the {B-Link -} tree,

142
00:04:13,570 --> 00:04:14,900
0,400 600,830 830,980 980,1070 1070,1330
right.| So it's sort of,
|所以当你说 B+ 树的时候，

143
00:04:14,950 --> 00:04:15,945
0,275 275,545 545,785 785,875 875,995
when B, when you say

144
00:04:15,945 --> 00:04:17,970
0,165 165,360 360,665 1285,1725 1725,2025
{B+ -} tree,| it's typically
|它通常指的是其他一些不同的东西。

145
00:04:17,970 --> 00:04:18,885
0,180 180,255 255,500 550,795 795,915
going to mean a bunch

146
00:04:18,885 --> 00:04:19,730
0,90 90,165 165,315 315,525 525,845
of these other different things.|
|

147
00:04:20,590 --> 00:04:22,280
0,400
So,
所以， B+ 树没有原始论文，

148
00:04:22,280 --> 00:04:23,770
0,225 225,450 450,735 735,1070 1090,1490
there is no original paper

149
00:04:24,300 --> 00:04:25,450
0,290 290,425 425,590 590,830 830,1150
on the {B+ -} tree,|
|

150
00:04:25,500 --> 00:04:27,500
0,400 1170,1430 1430,1565 1565,1775 1775,2000
actually, the one that everyone
大家提到的这个是 1979 年的这个，

151
00:04:27,500 --> 00:04:28,415
0,225 225,390 390,525 525,705 705,915
cites is this one from

152
00:04:28,415 --> 00:04:31,235
0,905 1345,1745 2305,2565 2565,2670 2670,2820
1979,| {} by the guys
|由 IBM 的人谈论，

153
00:04:31,235 --> 00:04:32,770
0,150 150,600 600,900 900,1185 1185,1535
at IBM talking about the,|
|

154
00:04:33,270 --> 00:04:33,845
0,245 245,335 335,425 425,500 500,575
what they call it, the
他们称为无处不在的 B 树，

155
00:04:33,845 --> 00:04:35,870
0,495 495,750 750,1065 1065,1385 1765,2025
ubiquitous {B -} tree,| and
|然后他们描述说，

156
00:04:35,870 --> 00:04:36,970
0,135 135,285 285,435 435,705 705,1100
in then this they describe,|
|

157
00:04:37,050 --> 00:04:38,240
0,305 305,545 545,725 725,980 980,1190
hey, there's this {}, the
嘿，有这个不同的变种，

158
00:04:38,240 --> 00:04:40,040
0,225 225,770 1180,1470 1470,1620 1620,1800
different variants,| but the most
|但对数据库系统最有用的是 B+ 树，

159
00:04:40,040 --> 00:04:40,925
0,255 255,495 495,720 720,780 780,885
common one that's gonna be

160
00:04:40,925 --> 00:04:42,100
0,165 165,375 375,570 570,810 810,1175
most useful for database systems

161
00:04:42,180 --> 00:04:42,920
0,275 275,395 395,485 485,590 590,740
is gonna be a {B+

162
00:04:42,920 --> 00:04:43,760
0,210 210,405 405,525 525,645 645,840
-} tree,| And then they
|然后他们引用了某种 IBM 技术报告，

163
00:04:43,760 --> 00:04:45,850
0,380 490,795 795,945 945,1190 1860,2090
cite some kind of IBM

164
00:04:45,990 --> 00:04:46,925
0,320 320,545 545,695 695,800 800,935
tech report,| that I have
|我没有找到，

165
00:04:46,925 --> 00:04:47,680
0,150 150,255 255,360 360,495 495,755
not been able to find,|
|

166
00:04:49,020 --> 00:04:49,805
0,245 245,380 380,470 470,620 620,785
I didn't look that hard,|
我没有那么认真地找，|

167
00:04:49,805 --> 00:04:51,125
0,275 745,990 990,1170 1170,1245 1245,1320
but it doesn't show up
但它在 Google 上没有显示出来，

168
00:04:51,125 --> 00:04:53,825
0,135 135,285 285,545 1675,2075 2305,2700
right on Google,| that that's
|这是他们谈论的那个原始 B+ 树，

169
00:04:53,825 --> 00:04:54,560
0,90 90,210 210,345 345,495 495,735
the one where they talk

170
00:04:54,560 --> 00:04:56,080
0,330 330,710
about the,

171
00:04:56,080 --> 00:04:59,220
0,360 360,660 660,870 870,1430
the original {B+,tree -}.|
|

172
00:04:59,500 --> 00:05:02,175
0,400 810,1175 1175,1775 1775,2140 2340,2675
The original authors of what
关于 B+ 的原始作者，

173
00:05:02,175 --> 00:05:04,335
0,335 775,1175 1555,1860 1860,2010 2010,2160
the of of the {B+

174
00:05:04,335 --> 00:05:06,600
0,305 535,935 1375,1635 1635,1890 1890,2265
-} work,| this guy bear
|这个人承担的责任和功劳，

175
00:05:06,600 --> 00:05:08,145
0,240 240,375 375,650 1000,1305 1305,1545
and the credit,| they never
|他们从未真正定义过 B+ 树中 B 的意思，

176
00:05:08,145 --> 00:05:09,315
0,285 285,585 585,810 810,960 960,1170
actually define what the B

177
00:05:09,315 --> 00:05:11,810
0,335 1525,1800 1800,1965 1965,2175 2175,2495
means in {B+ -} tree,|
|

178
00:05:12,070 --> 00:05:13,995
0,400 480,815 815,1055 1055,1445 1445,1925
typically people say it's, it's
通常人们说它是，代表平衡，宽广，浓密，

179
00:05:13,995 --> 00:05:17,415
0,240 240,755 1975,2375 2515,3095 3175,3420
for balanced, broad, bushy,| the
|这个人的名字是 Bayer ， b a y er ，

180
00:05:17,415 --> 00:05:18,525
0,255 255,360 360,525 525,915 915,1110
guy's name is Bayer, b

181
00:05:18,525 --> 00:05:19,485
0,180 180,360 360,540 540,705 705,960
a {} y e r,|
|

182
00:05:19,485 --> 00:05:20,540
0,255 255,465 465,660 660,810 810,1055
so could have nameded after
所以可能是以他自己的名字命名的，

183
00:05:20,560 --> 00:05:24,210
0,400 2160,2560 2730,3065 3065,3365 3365,3650
himself,| this data structure actually
|这个数据结构实际上是 Boeing 开发的，那个飞机公司，

184
00:05:24,210 --> 00:05:26,040
0,210 210,405 405,890 1420,1680 1680,1830
developed at Boeing, like the

185
00:05:26,040 --> 00:05:27,765
0,195 195,470 490,890 1360,1590 1590,1725
airplane companies,| could have been
|可能是 Boeing 树，

186
00:05:27,765 --> 00:05:29,120
0,455 505,905
Boeing tree,|
|

187
00:05:29,280 --> 00:05:30,430
0,290 290,455 455,635 635,845 845,1150
nobody really knows,| but typically
没有人真正知道，|但通常情况下，

188
00:05:30,540 --> 00:05:32,135
0,400 900,1145 1145,1250 1250,1400 1400,1595
people,| when you say B
|当你说 B 树时，人们通常指的是平衡。

189
00:05:32,135 --> 00:05:33,970
0,285 285,665 835,1155 1155,1365 1365,1835
tree, people typically mean balanced.|
|

190
00:05:35,320 --> 00:05:36,675
0,335 335,545 545,965 965,1175 1175,1355
There's another variant called {B-Link
还有另一个变体叫做 B-Link 树，

191
00:05:36,675 --> 00:05:38,490
0,210 210,545 745,1145 1465,1710 1710,1815
-} tree,| {} and as
|正如我所说的，有一种经典的 B+ 树，

192
00:05:38,490 --> 00:05:39,555
0,135 135,410 430,765 765,900 900,1065
I said, there'll be the

193
00:05:39,555 --> 00:05:40,665
0,120 120,270 270,555 555,855 855,1110
sort of classic {B+ -}

194
00:05:40,665 --> 00:05:42,570
0,335 715,975 975,1185 1185,1665 1665,1905
tree,| but nobody implements exactly
|但没有人实现它的定义，

195
00:05:42,570 --> 00:05:44,235
0,195 195,420 420,645 645,980 1300,1665
as it's defined there,| people
|人们会零星地借用它，

196
00:05:44,235 --> 00:05:45,180
0,270 270,480 480,645 645,765 765,945
gonna borrow bits and pieces

197
00:05:45,180 --> 00:05:46,035
0,150 150,240 240,345 345,540 540,855
of it| and in particular
|特别是他们会从这篇 B-Link 树论文中借用一些想法，

198
00:05:46,035 --> 00:05:47,130
0,225 225,360 360,465 465,750 750,1095
what they're gonna borrow some

199
00:05:47,130 --> 00:05:48,075
0,255 255,420 420,570 570,750 750,945
ideas from this {B-Link -}

200
00:05:48,075 --> 00:05:49,590
0,180 180,455 805,1140 1140,1350 1350,1515
tree paper,| that actually came
|这篇论文实际上来自 CMU ，在 1981 年，

201
00:05:49,590 --> 00:05:50,480
0,135 135,240 240,390 390,585 585,890
from here at {CMU -}

202
00:05:50,830 --> 00:05:53,205
0,335 335,530 530,1240 1860,2180 2180,2375
in in 1981,| certain guy
|这个人是 Philip Lehman ，

203
00:05:53,205 --> 00:05:54,520
0,165 165,345 345,785
by Philip Lehman,|
|

204
00:05:54,650 --> 00:05:55,615
0,290 290,515 515,710 710,845 845,965
that dude still works in
那个家伙仍在 CMU 五楼的院长办公室工作，

205
00:05:55,615 --> 00:05:56,760
0,90 90,405 405,540 540,660 660,1145
the dean's office at CMU

206
00:05:57,350 --> 00:05:59,020
0,275 275,410 410,590 590,910 1410,1670
on the 5th floor,| and
|如果你去看 Postgres 源代码，

207
00:05:59,020 --> 00:05:59,530
0,90 90,150 150,270 270,420 420,510
if you go look at

208
00:05:59,530 --> 00:06:01,390
0,75 75,315 315,630 630,950 1570,1860
the Postgres source code,| in
|在他们谈论 B 树的目录中，

209
00:06:01,390 --> 00:06:02,980
0,290 490,885 885,1365 1365,1485 1485,1590
the the directory where they

210
00:06:02,980 --> 00:06:03,835
0,120 120,240 240,360 360,570 570,855
talk about of B tree,|
|

211
00:06:03,835 --> 00:06:04,915
0,285 285,420 420,570 570,795 795,1080
notice they say B tree
注意他们说的是 B 树而不是 B+ 树，

212
00:06:04,915 --> 00:06:05,820
0,195 195,270 270,405 405,600 600,905
instead of {B+ -} tree|
|

213
00:06:05,990 --> 00:06:06,685
0,230 230,320 320,455 455,575 575,695
and {} there is an
这里有一个 nbtree ，

214
00:06:06,685 --> 00:06:08,020
0,225 225,540 540,905 925,1185 1185,1335
{nbtree - -},| because it's
|因为这是一个非平衡 B+ 树，

215
00:06:08,020 --> 00:06:09,160
0,105 105,330 330,660 660,930 930,1140
a non balance {B+ -}

216
00:06:09,160 --> 00:06:10,675
0,320 610,1010 1030,1320 1320,1410 1410,1515
tree,| but we'll get to
|但我们稍后会谈到这个。

217
00:06:10,675 --> 00:06:12,700
0,105 105,365 1495,1755 1755,1890 1890,2025
that later.| But yeah, right
|但是，是的，就在这个代码中，

218
00:06:12,700 --> 00:06:13,510
0,105 105,180 180,270 270,615 615,810
here in the source,| oh
|是的，这是一个正确的暗示，

219
00:06:13,510 --> 00:06:14,620
0,255 255,525 525,645 645,855 855,1110
yeah, this is a correct

220
00:06:14,620 --> 00:06:16,110
0,555 555,810 810,990 990,1185 1185,1490
implication,| correct is always important,|
|正确总是重要的，|

221
00:06:16,400 --> 00:06:18,210
0,400 780,1085 1085,1250 1250,1550 1550,1810
of Lehman and Yao's paper
关于 Lehman 和 Yao 的 B-Link 论文，在 1973 年，

222
00:06:18,260 --> 00:06:19,255
0,305 305,440 440,545 545,710 710,995
from the {B-Link -} tree,

223
00:06:19,255 --> 00:06:20,740
0,390 390,1025
from 1973,

224
00:06:21,020 --> 00:06:21,810
0,245 245,335 335,425 425,530 530,790
right,| that's kind of cool.|
|这太酷了。|

225
00:06:23,370 --> 00:06:24,650
0,400 510,860 860,1085 1085,1235 1235,1280
{} But again we're going
但我们将主要关注这个，

226
00:06:24,650 --> 00:06:25,610
0,75 75,255 255,570 570,825 825,960
to focus primarily on this

227
00:06:25,610 --> 00:06:27,140
0,260 430,825 825,1130 1210,1455 1455,1530
one,| we'll see if we
|我们将看看是否有时间，

228
00:06:27,140 --> 00:06:28,025
0,135 135,390 390,675 675,780 780,885
have time,| I'll talk about
|我将在最后讨论 Bε 树，

229
00:06:28,025 --> 00:06:28,865
0,75 75,165 165,570 570,735 735,840
the {Bε -} tree at

230
00:06:28,865 --> 00:06:30,020
0,90 90,335 655,915 915,1035 1035,1155
the end,| and then the
|然后， Bw 树是微软的东西，

231
00:06:30,020 --> 00:06:31,030
0,120 120,315 315,555 555,735 735,1010
{Bw -} tree is a

232
00:06:31,170 --> 00:06:32,510
0,290 290,440 440,995 995,1100 1100,1340
thing of Microsoft,| a {lock-free
|一种 B+ 树的无锁版本。

233
00:06:32,510 --> 00:06:33,605
0,300 300,600 600,825 825,945 945,1095
-} version of {} {B+

234
00:06:33,605 --> 00:06:35,390
0,180 180,485 1015,1335 1335,1545 1545,1785
-} tree.| We actually implemented
|我们实际上在 CMU 实现了这个，

235
00:06:35,390 --> 00:06:36,970
0,240 240,530 670,1125 1125,1320 1320,1580
that here CMU| and was
|这并不容易，

236
00:06:36,990 --> 00:06:38,915
0,290 290,580 1530,1775 1775,1850 1850,1925
not easy| and we have
|我们有一个开放源码的实现。

237
00:06:38,915 --> 00:06:39,755
0,120 120,240 240,480 480,750 750,840
an open source implementation of

238
00:06:39,755 --> 00:06:40,440
0,215
that.|
|

239
00:06:41,150 --> 00:06:42,280
0,400
Okay.|
好的。|

240
00:06:42,570 --> 00:06:43,565
0,260 260,365 365,500 500,710 710,995
So the {B+ -} tree
所以 B+ 树是一个自平衡的排序树，

241
00:06:43,565 --> 00:06:44,525
0,255 255,375 375,450 450,690 690,960
is going to be a

242
00:06:44,525 --> 00:06:46,850
0,195 195,690 690,1020 1020,1385 1825,2325
self balanced order tree,| that's
|它允许我们进行搜索和顺序访问，以及插入和删除，

243
00:06:46,850 --> 00:06:47,405
0,60 60,150 150,300 300,450 450,555
going to allow us to

244
00:06:47,405 --> 00:06:49,535
0,245 265,855 855,1235 1285,1815 1815,2130
do searches and sequential access

245
00:06:49,535 --> 00:06:51,400
0,225 225,645 645,750 750,1205 1465,1865
and insertions and deletions,| all
|所有这些都在 log n 时间内，

246
00:06:51,420 --> 00:06:53,340
0,400 480,800 800,1040 1040,1360
in log n time,

247
00:06:54,070 --> 00:06:55,410
0,400 660,965 965,1145 1145,1265 1265,1340
right,| log n is going
|log n 是树的高度。

248
00:06:55,410 --> 00:06:56,280
0,60 60,240 240,450 450,645 645,870
to be the height of

249
00:06:56,280 --> 00:06:57,280
0,180 180,470
the tree.|
|

250
00:06:57,570 --> 00:06:59,950
0,290 290,580 810,1210 1440,1840 1980,2380
And so the, the difference
所以，这里的区别，

251
00:06:59,970 --> 00:07:01,250
0,400 510,770 770,1010 1010,1175 1175,1280
between,| what we'll describe here
|我们在这里描述的 B+ 树和一般的二叉搜索树之间的区别是，

252
00:07:01,250 --> 00:07:01,895
0,45 45,105 105,240 240,435 435,645
and {} {B+ -} tree

253
00:07:01,895 --> 00:07:04,655
0,255 255,605 1435,2040 2040,2475 2475,2760
versus a generic binary search

254
00:07:04,655 --> 00:07:06,800
0,335 565,825 825,1085 1345,1650 1650,2145
tree is that,| the nodes
|我们数据结构中的节点显然可以有两个以上的键，

255
00:07:06,800 --> 00:07:08,090
0,150 150,300 300,570 570,950 1000,1290
in our data structure can

256
00:07:08,090 --> 00:07:09,820
0,290 580,915 915,1155 1155,1395 1395,1730
have obviously more than two,

257
00:07:10,950 --> 00:07:12,320
0,290 290,580
two keys,|
|

258
00:07:12,320 --> 00:07:13,235
0,225 225,315 315,510 510,750 750,915
and the reason why we're
我们想要这个的原因是，

259
00:07:13,235 --> 00:07:14,030
0,45 45,120 120,270 270,510 510,795
going to want this is

260
00:07:14,030 --> 00:07:15,770
0,350 550,950 1090,1365 1365,1515 1515,1740
because,| again, we want to
|我们想要转换，

261
00:07:15,770 --> 00:07:16,805
0,315 315,525 525,615 615,705 705,1035
convert,| we want to minimize
|我们想要最小化我们做的随机 I/O 量，

262
00:07:16,805 --> 00:07:17,555
0,150 150,255 255,420 420,600 600,750
amount of random {I/O -}

263
00:07:17,555 --> 00:07:18,575
0,195 195,425 625,855 855,930 930,1020
we're doing,| so we want
|我们想要最大化顺序 I/O 量，

264
00:07:18,575 --> 00:07:19,880
0,120 120,645 645,810 810,1185 1185,1305
to maximize amount {of,sequential} {I/O

265
00:07:19,880 --> 00:07:21,275
0,290 730,975 975,1080 1080,1215 1215,1395
-},| and the {B+ -}
|B+ 树是非常适合我们这样做的，

266
00:07:21,275 --> 00:07:21,680
0,150 150,240 240,300 300,330 330,405
tree is going to be

267
00:07:21,680 --> 00:07:22,700
0,195 195,375 375,620 670,915 915,1020
perfect for us to do

268
00:07:22,700 --> 00:07:23,930
0,260 550,795 795,885 885,1005 1005,1230
this,| because when we land
|因为当我们到达一个在获取页面的节点时，

269
00:07:23,930 --> 00:07:25,025
0,195 195,300 300,540 540,810 810,1095
in a node, that's essentially

270
00:07:25,025 --> 00:07:26,435
0,360 360,450 450,570 570,845 1165,1410
fetching in a page| and
|我们没有尽可能多的键在里面，

271
00:07:26,435 --> 00:07:27,230
0,75 75,225 225,420 420,630 630,795
we don't have, we don't

272
00:07:27,230 --> 00:07:28,055
0,120 120,255 255,465 465,675 675,825
have as many keys as

273
00:07:28,055 --> 00:07:29,540
0,150 150,425 475,765 765,1055
we can inside that,|
|

274
00:07:29,610 --> 00:07:30,440
0,305 305,440 440,515 515,665 665,830
before we have to move
在我们继续，从磁盘中获取下一个页面之前。

275
00:07:30,440 --> 00:07:31,220
0,195 195,390 390,525 525,645 645,780
on, to grab the next

276
00:07:31,220 --> 00:07:33,005
0,150 150,410 1150,1440 1440,1620 1620,1785
piece of next page from

277
00:07:33,005 --> 00:07:33,880
0,425
disk,

278
00:07:33,880 --> 00:07:35,020
0,380
right.|
|

279
00:07:35,060 --> 00:07:37,405
0,400 1080,1430 1430,1780 1890,2180 2180,2345
So thinking back, way back
所以回想一下，早在 20 世纪 70 年代，

280
00:07:37,405 --> 00:07:39,030
0,225 225,420 420,665 745,1305 1305,1625
in the {1970s -},| when
|当硬件很糟糕的时候，

281
00:07:39,290 --> 00:07:41,220
0,320 320,515 515,790 1110,1510 1530,1930
hardware was terrible,| {} like
|比如你有最少的 RAM ，

282
00:07:41,960 --> 00:07:42,790
0,245 245,350 350,485 485,665 665,830
you had a minimum amount

283
00:07:42,790 --> 00:07:44,290
0,120 120,380 910,1155 1155,1290 1290,1500
of RAM,| but your disk
|你的磁盘也超级慢，

284
00:07:44,290 --> 00:07:45,900
0,150 150,330 330,540 540,890 1210,1610
was also super slow,| so
|所以 B+ 树，

285
00:07:45,980 --> 00:07:47,245
0,290 290,485 485,725 725,1010 1010,1265
a {B+ -} tree,| it's
|它将允许转换，

286
00:07:47,245 --> 00:07:47,845
0,60 60,150 150,285 285,420 420,600
going to allow you to

287
00:07:47,845 --> 00:07:49,255
0,335 835,1080 1080,1170 1170,1275 1275,1410
convert,| when you do these
|当你做这些查找时，

288
00:07:49,255 --> 00:07:51,180
0,395 775,1050 1050,1230 1230,1590 1590,1925
lookup,| from random I/O into
|从随机 I/O 转换为顺序访问。

289
00:07:51,920 --> 00:07:53,340
0,575 575,910
sequential access.|
|

290
00:07:53,500 --> 00:07:54,450
0,275 275,410 410,575 575,785 785,950
Because once you follow the
因为一旦你跟随叶节点，

291
00:07:54,450 --> 00:07:56,130
0,165 165,680 760,1140 1140,1440 1440,1680
leaf nodes| or follow the
|或沿着树向下到叶节点，

292
00:07:56,130 --> 00:07:58,230
0,320 1270,1545 1545,1710 1710,1935 1935,2100
the the tree down to

293
00:07:58,230 --> 00:07:59,070
0,75 75,225 225,570 570,690 690,840
the leaf nodes,| and once
|一旦你到了那里，

294
00:07:59,070 --> 00:08:00,180
0,180 180,330 330,650 700,945 945,1110
you're down there,| you never
|你再也不会回到上面，

295
00:08:00,180 --> 00:08:01,935
0,195 195,360 360,650 1240,1530 1530,1755
go back up,| not entirely
|不完全正确，

296
00:08:01,935 --> 00:08:02,745
0,225 225,375 375,465 465,555 555,810
true,| but for our purposes,|
|但出于我们的目的，|

297
00:08:02,745 --> 00:08:03,765
0,375 375,660 660,765 765,930 930,1020
now we'll assume that's the
我们现在假设情况就是这样，

298
00:08:03,765 --> 00:08:04,800
0,245 415,660 660,735 735,825 825,1035
case,| and then I can
|然后我可以沿着叶节点扫描，

299
00:08:04,800 --> 00:08:06,800
0,315 315,680 1000,1260 1260,1440 1440,2000
scan along the leaf nodes|
|

300
00:08:06,850 --> 00:08:07,770
0,275 275,455 455,605 605,740 740,920
to find the data I'm
以找到我正在寻找的数据。

301
00:08:07,770 --> 00:08:08,900
0,180 180,530
looking for,

302
00:08:09,740 --> 00:08:10,880
0,400
right.|
|

303
00:08:11,990 --> 00:08:13,225
0,380 380,695 695,1070 1070,1130 1130,1235
So more formative, we can
所以，更具形式性的，我们可以说，

304
00:08:13,225 --> 00:08:13,990
0,180 180,345 345,450 450,585 585,765
say,| that a {B+ -}
|B+ 树是具有以下性质的 M 路搜索树，

305
00:08:13,990 --> 00:08:14,470
0,135 135,255 255,345 345,390 390,480
tree is going to be

306
00:08:14,470 --> 00:08:16,180
0,150 150,345 345,585 585,920 1450,1710
{M-way -} search tree with

307
00:08:16,180 --> 00:08:17,780
0,105 105,315 315,680
the following properties,|
|

308
00:08:18,100 --> 00:08:18,900
0,230 230,335 335,470 470,635 635,800
for us, is that it
对我们来说，它是完全平衡的，

309
00:08:18,900 --> 00:08:20,640
0,135 135,405 405,1010 1090,1455 1455,1740
be perfectly balanced,| meaning that
|这意味着我们树结构中的每个叶节点都将具有相同的深度，

310
00:08:20,640 --> 00:08:23,220
0,320 910,1305 1305,1700 1810,2355 2355,2580
the every leaf node in

311
00:08:23,220 --> 00:08:24,765
0,195 195,390 390,680 1120,1410 1410,1545
our tree structure is going

312
00:08:24,765 --> 00:08:25,730
0,90 90,225 225,405 405,630 630,965
to have the same depth,|
|

313
00:08:26,080 --> 00:08:27,840
0,400 510,830 830,1150 1170,1520 1520,1760
means, the same number of
也就是从根到该叶节点的相同层数，

314
00:08:27,840 --> 00:08:29,240
0,270 270,650 730,990 990,1125 1125,1400
levels down from the root

315
00:08:29,470 --> 00:08:30,860
0,335 335,590 590,800 800,995 995,1390
to that that leaf node,|
|

316
00:08:31,060 --> 00:08:32,985
0,275 275,550 1170,1640 1640,1805 1805,1925
and again, Postgres is going
再次， Postgres 会违反这一点，

317
00:08:32,985 --> 00:08:33,990
0,210 210,630 630,750 750,870 870,1005
to violate this little bit,|
|

318
00:08:33,990 --> 00:08:35,355
0,225 225,450 450,615 615,920 1030,1365
some, some people do,| but
有些人是这样做的，|但是从一开始就认为情况是这样。

319
00:08:35,355 --> 00:08:36,600
0,330 330,570 570,750 750,1035 1035,1245
{} the very beginning assume

320
00:08:36,600 --> 00:08:37,680
0,195 195,285 285,530
that's the case.|
|

321
00:08:38,720 --> 00:08:39,970
0,335 335,530 530,770 770,1040 1040,1250
We also have a rule,|
我们还有一条规则，|

322
00:08:39,970 --> 00:08:41,410
0,240 240,540 540,1035 1035,1260 1260,1440
that every node other than
除根节点之外的每个节点都必须至少半满，

323
00:08:41,410 --> 00:08:42,910
0,120 120,380 790,1110 1110,1320 1320,1500
the root has to be

324
00:08:42,910 --> 00:08:44,335
0,150 150,315 315,555 555,890 1180,1425
at least {half-full -},| so
|所以如果我有 M 个键在一个节点中，

325
00:08:44,335 --> 00:08:44,950
0,75 75,225 225,390 390,495 495,615
if I, if I can

326
00:08:44,950 --> 00:08:46,315
0,150 150,405 405,770 790,1080 1080,1365
have M keys in my,

327
00:08:46,315 --> 00:08:47,395
0,255 255,515 535,795 795,945 945,1080
in my, in my, in

328
00:08:47,395 --> 00:08:48,535
0,105 105,575 655,915 915,1035 1035,1140
my node,| I need to
|我需要至少有一半的节点，

329
00:08:48,535 --> 00:08:50,635
0,180 180,390 390,665 715,1115 1855,2100
have at least half a

330
00:08:50,635 --> 00:08:51,430
0,105 105,210 210,525 525,690 690,795
number of nodes,| half a
|尽可能有最大数量一半的键，

331
00:08:51,430 --> 00:08:52,500
0,90 90,210 210,470 520,795 795,1070
number of keys as possible,

332
00:08:52,910 --> 00:08:54,660
0,320 320,640 840,1100 1100,1355 1355,1750
up to the maximum number,

333
00:08:55,920 --> 00:08:57,365
0,400 600,830 830,950 950,1145 1145,1445
right,| if I go below
|如果我低于这个阈值，

334
00:08:57,365 --> 00:08:58,580
0,300 300,780 780,960 960,1080 1080,1215
that threshold,| if I {}
|如果我低于半满，

335
00:08:58,580 --> 00:08:59,765
0,135 135,410 490,795 795,1005 1005,1185
go below mean less than

336
00:08:59,765 --> 00:09:01,385
0,180 180,485 925,1275 1275,1485 1485,1620
{half-full -},| then I have
|那么我必须进行一些合并，

337
00:09:01,385 --> 00:09:03,050
0,135 135,360 360,585 585,995 1405,1665
to do some merging,| but
|但是再次，我们可以稍后对这个要求进行调整。

338
00:09:03,050 --> 00:09:04,270
0,180 180,450 450,735 735,945 945,1220
again, we can, we can,

339
00:09:05,140 --> 00:09:06,400
0,120 120,270 270,480 480,740 850,1260
we can tweak that requirement

340
00:09:06,400 --> 00:09:07,540
0,150 150,440
later on.|
|

341
00:09:08,310 --> 00:09:09,530
0,260 260,380 380,640 810,1070 1070,1220
And so then the root
根节点是特殊的，

342
00:09:09,530 --> 00:09:10,570
0,120 120,225 225,500 550,795 795,1040
would be {special,case},| so we
|所以我们现在可以忽略它，

343
00:09:10,620 --> 00:09:11,530
0,290 290,440 440,560 560,665 665,910
can ignore it for now,|
|

344
00:09:12,510 --> 00:09:13,925
0,275 275,425 425,695 695,1025 1025,1415
and then every inner node
然后每个有 k 个键的内部节点将至少有 k+1 个非空子节点，

345
00:09:13,925 --> 00:09:15,500
0,165 165,455 985,1320 1320,1500 1500,1575
with k keys are going

346
00:09:15,500 --> 00:09:16,115
0,60 60,135 135,225 225,390 390,615
to have at least {k+1

347
00:09:16,115 --> 00:09:17,350
0,210 210,465 465,720 720,930 930,1235
- -} {non-null -} children,|
|

348
00:09:18,030 --> 00:09:19,750
0,350 350,620 620,845 845,1150 1320,1720
meaning I could have some
这意味着我可以有一些位置，

349
00:09:20,370 --> 00:09:21,670
0,350 350,530 530,725 725,995 995,1300
locations, { - -}| or
|或者指向我下面的叶节点或节点的可能指针，

350
00:09:21,840 --> 00:09:23,345
0,440 440,680 680,1010 1010,1235 1235,1505
pointer, possible pointers to leaf

351
00:09:23,345 --> 00:09:25,655
0,455 1345,1620 1620,1860 1860,2055 2055,2310
nodes or nodes below me,|
|

352
00:09:25,655 --> 00:09:26,900
0,165 165,315 315,480 480,935 1015,1245
when I'm inner node,| but
当我是内部节点时，|但我不一定要有最大数量。

353
00:09:26,900 --> 00:09:27,580
0,75 75,240 240,330 330,435 435,680
I don't have to have

354
00:09:27,630 --> 00:09:29,360
0,305 305,560 560,910
the max number.|
|

355
00:09:32,120 --> 00:09:32,875
0,260 260,365 365,440 440,545 545,755
So this is all math,|
所以这都是数学问题，|

356
00:09:33,040 --> 00:09:34,600
0,75 75,165 165,315 315,620
let's look at example.|
让我们来看一个例子。|

357
00:09:34,600 --> 00:09:35,460
0,105 105,255 255,315 315,510 510,860
So here's a really simple,|
所以这里有一个非常简单的，|

358
00:09:38,260 --> 00:09:39,315
0,305 305,335 335,440 440,730 780,1055
here's a really simple {2-way
这里有一个非常简单的 2 阶 B+ 树，

359
00:09:39,315 --> 00:09:42,045
0,270 270,540 540,735 735,1055 2395,2730
-} {B+ -} tree,| and
|我们可以定义顶部的根节点，

360
00:09:42,045 --> 00:09:42,990
0,180 180,330 330,570 570,780 780,945
we can define the root

361
00:09:42,990 --> 00:09:44,220
0,210 210,285 285,390 390,650 970,1230
node at the top| and
|然后是内部节点，

362
00:09:44,220 --> 00:09:45,570
0,120 120,240 240,405 405,860 1090,1350
then the inner nodes,| because
|因为我们只有三层，

363
00:09:45,570 --> 00:09:46,530
0,90 90,180 180,440 460,735 735,960
we only have three levels,|
|

364
00:09:46,530 --> 00:09:47,115
0,165 165,255 255,435 435,510 510,585
the inner nodes are just
内部节点就是中间的那些，

365
00:09:47,115 --> 00:09:47,720
0,90 90,225 225,330 330,375 375,605
the ones in the middle,|
|

366
00:09:48,130 --> 00:09:49,185
0,260 260,380 380,500 500,680 680,1055
and then the leaf nodes
然后叶节点就是底部的东西。

367
00:09:49,185 --> 00:09:50,115
0,275 325,585 585,720 720,840 840,930
are the things at the

368
00:09:50,115 --> 00:09:51,120
0,245
bottom.|
|

369
00:09:51,720 --> 00:09:53,080
0,290 290,545 545,755 755,1025 1025,1360
So {with,inner -} node itself,|
所以，在内部节点本身中，|

370
00:09:53,370 --> 00:09:54,250
0,275 275,320 320,395 395,560 560,880
we're going to have this
我们将有这种交替模式，

371
00:09:55,230 --> 00:09:57,980
0,520 1050,1430 1430,1810 2070,2375 2375,2750
alternating pattern| between a pointer
|一个指向另一个节点的指针和一个键，

372
00:09:57,980 --> 00:09:59,000
0,180 180,405 405,765 765,900 900,1020
to another node and then

373
00:09:59,000 --> 00:10:00,140
0,150 150,440
a key,|
|

374
00:10:00,840 --> 00:10:01,940
0,275 275,485 485,710 710,875 875,1100
and then in the leaf
然后在叶节点中，

375
00:10:01,940 --> 00:10:04,120
0,620 820,1140 1140,1370 1600,1890 1890,2180
nodes,| there'll be the value
|将有我们试图为给定键存储的值，

376
00:10:04,440 --> 00:10:05,780
0,335 335,755 755,950 950,1100 1100,1340
that we're trying to store

377
00:10:05,780 --> 00:10:07,145
0,210 210,470 610,960 960,1170 1170,1365
for this for a given

378
00:10:07,145 --> 00:10:08,140
0,335
key,|
|

379
00:10:08,540 --> 00:10:09,505
0,350 350,560 560,725 725,905 905,965
and for now, we're not
目前，我们不会找到值是什么，

380
00:10:09,505 --> 00:10:09,925
0,60 60,135 135,240 240,330 330,420
going to find what the

381
00:10:09,925 --> 00:10:10,735
0,180 180,450 450,630 630,720 720,810
value is,| but you can
|但你可以将其视为潜在的记录 ID ，

382
00:10:10,735 --> 00:10:11,875
0,105 105,195 195,315 315,605 805,1140
think of it like potentially

383
00:10:11,875 --> 00:10:13,240
0,195 195,375 375,695 775,1110 1110,1365
the record ID| to point
|以指向实际的 tuple ，某个页码和偏移量，

384
00:10:13,240 --> 00:10:14,410
0,180 180,330 330,555 555,945 945,1170
to the actual tuple, some

385
00:10:14,410 --> 00:10:16,000
0,165 165,440 970,1245 1245,1380 1380,1590
page number, page number and

386
00:10:16,000 --> 00:10:18,025
0,350 1360,1665 1665,1815 1815,1950 1950,2025
offset,| or if it's a
|或者，如果这是 MySQL 或 SQLite 的情况，

387
00:10:18,025 --> 00:10:19,270
0,135 135,330 330,825 825,975 975,1245
case of MySQL or {SQLite

388
00:10:19,270 --> 00:10:20,650
0,260 550,840 840,1065 1065,1260 1260,1380
-},| it could actually be
|它可能是 tuple 本身，

389
00:10:20,650 --> 00:10:22,270
0,135 135,465 465,770 1270,1530 1530,1620
the tuple itself,| but for
|但就目前而言，我们可以忽略这个。

390
00:10:22,270 --> 00:10:23,100
0,105 105,240 240,390 390,555 555,830
now, we can ignore that.|
|

391
00:10:24,230 --> 00:10:25,030
0,275 275,395 395,500 500,650 650,800
And so the way to
所以思考这些内部节点和根节点中的数字的方法是，

392
00:10:25,030 --> 00:10:26,500
0,165 165,390 390,710 820,1185 1185,1470
think about these numbers here

393
00:10:26,500 --> 00:10:27,415
0,195 195,330 330,495 495,810 810,915
in the inner nodes and

394
00:10:27,415 --> 00:10:28,435
0,105 105,240 240,645 645,885 885,1020
the root nodes,| that these
|这些基本上是路标，

395
00:10:28,435 --> 00:10:29,740
0,135 135,375 375,750 750,1155 1155,1305
are essentially {guideposts -},| that
|告诉你要走哪条路径。

396
00:10:29,740 --> 00:10:30,970
0,195 195,500 520,840 840,1065 1065,1230
tell you which path you

397
00:10:30,970 --> 00:10:32,320
0,120 120,225 225,360 360,650
want to go down,

398
00:10:32,390 --> 00:10:33,160
0,305 305,440 440,500 500,590 590,770
right.| So at the root
|所以在这里的根节点，

399
00:10:33,160 --> 00:10:33,985
0,240 240,405 405,555 555,675 675,825
node here,| we only have
|我们只有一个键，它是 20 ，

400
00:10:33,985 --> 00:10:35,350
0,180 180,330 330,555 555,845 1105,1365
one key, it's 20,| so
|所以如果你去左边，

401
00:10:35,350 --> 00:10:35,860
0,105 105,270 270,315 315,375 375,510
if you're going to go

402
00:10:35,860 --> 00:10:37,030
0,195 195,345 345,590 670,1005 1005,1170
left to it,| it's any
|它是任何小于 20 的值，

403
00:10:37,030 --> 00:10:38,440
0,320 580,900 900,1095 1095,1245 1245,1410
value, any key value that's

404
00:10:38,440 --> 00:10:39,205
0,60 60,105 105,300 300,570 570,765
going to be less than

405
00:10:39,205 --> 00:10:40,710
0,305 625,930 930,1110 1110,1215 1215,1505
20,| and we'll go right,
|我们去右边，就会得到大于或等于的。

406
00:10:41,090 --> 00:10:42,600
0,320 320,640 660,935 935,1160 1160,1510
greater than or equal to,

407
00:10:43,300 --> 00:10:44,865
0,400 840,1130 1130,1295 1295,1415 1415,1565
right.| Same thing, the next
|一样的东西，下一个，我这里有 10 ，

408
00:10:44,865 --> 00:10:46,520
0,305 775,1035 1035,1170 1170,1350 1350,1655
one, I have 10 here,|
|

409
00:10:47,140 --> 00:10:48,200
0,290 290,440 440,590 590,770 770,1060
less than 10 goes here,|
小于 10 的到这边，|

410
00:10:48,340 --> 00:10:49,335
0,305 305,485 485,665 665,830 830,995
greater than equal to 10
大于等于 10 的在另一边。

411
00:10:49,335 --> 00:10:50,120
0,180 180,300 300,375 375,495 495,785
goes on the other side.|
|

412
00:10:53,370 --> 00:10:55,595
0,260 260,410 410,700 1830,2090 2090,2225
So what makes?| So this
那么什么造成？|这就是我到目前为止所描述的，

413
00:10:55,595 --> 00:10:56,270
0,135 135,270 270,405 405,510 510,675
is sort of what I'm

414
00:10:56,270 --> 00:10:56,945
0,210 210,315 315,435 435,570 570,675
describing so far,| this is
|这是一个基本的 B+ 树，

415
00:10:56,945 --> 00:10:58,240
0,135 135,420 420,720 720,960 960,1295
a basic {B+ -} tree,|
|

416
00:10:58,500 --> 00:10:59,705
0,290 290,580 630,875 875,995 995,1205
but what I was saying
但我之前说过，他们有这个，

417
00:10:59,705 --> 00:11:01,090
0,315 315,585 585,765 765,1020 1020,1385
before that they have this,|
|

418
00:11:01,230 --> 00:11:03,665
0,400 1080,1385 1385,1775 1775,2105 2105,2435
{} we're borrowing ideas from
我们借鉴了其他论文的想法，比如 B-Link 树，

419
00:11:03,665 --> 00:11:04,730
0,285 285,585 585,810 810,930 930,1065
other papers like the {B-Link

420
00:11:04,730 --> 00:11:06,560
0,195 195,500 730,1005 1005,1280 1540,1830
-} tree,| is that the
|也就是节点也将在每个级别上有兄弟指针，

421
00:11:06,560 --> 00:11:07,310
0,330 330,510 510,660 660,705 705,750
nodes are also going to

422
00:11:07,310 --> 00:11:09,725
0,150 150,510 510,980 1960,2220 2220,2415
have sibling pointers at every

423
00:11:09,725 --> 00:11:10,740
0,335
level,|
|

424
00:11:10,740 --> 00:11:11,955
0,240 240,450 450,690 690,855 855,1215
so I think the textbook
我认为课本可能只在叶节点上显示，

425
00:11:11,955 --> 00:11:12,915
0,150 150,360 360,630 630,840 840,960
might only show at the

426
00:11:12,915 --> 00:11:14,565
0,150 150,695 865,1380 1380,1545 1545,1650
leaf nodes,| Postgres puts them
|Postgres 将它们放在中间节点，也是内部节点，

427
00:11:14,565 --> 00:11:15,840
0,105 105,210 210,375 375,905 955,1275
in the middle node, {the,inner}

428
00:11:15,840 --> 00:11:17,130
0,225 225,345 345,620 940,1185 1185,1290
nodes as well,| and I
|我认为原始的 B-Link 论文也有这些节点。

429
00:11:17,130 --> 00:11:17,835
0,120 120,225 225,375 375,555 555,705
think the original {B-Link -}

430
00:11:17,835 --> 00:11:19,410
0,210 210,545 565,900 900,1305 1305,1575
paper had the nodes as

431
00:11:19,410 --> 00:11:20,300
0,290
well.|
|

432
00:11:20,370 --> 00:11:21,680
0,275 275,550 660,905 905,1070 1070,1310
And so the reason why
所以这很重要的原因是，

433
00:11:21,680 --> 00:11:23,615
0,240 240,555 555,900 900,1250 1630,1935
this matters is,| again, if
|如果我要进行搜索，

434
00:11:23,615 --> 00:11:24,890
0,240 240,435 435,785 895,1155 1155,1275
I'm doing search,| give me
|给我所有大于等于 6 的键，

435
00:11:24,890 --> 00:11:26,180
0,150 150,315 315,590 820,1140 1140,1290
all the keys greater than

436
00:11:26,180 --> 00:11:27,575
0,135 135,330 330,620 970,1245 1245,1395
equal to 6,| I could
|我可以沿着树的这一边遍历，到达底部，

437
00:11:27,575 --> 00:11:29,840
0,390 390,755 865,1265 1885,2130 2130,2265
traverse down the, you know,

438
00:11:29,840 --> 00:11:30,620
0,195 195,375 375,480 480,585 585,780
this side of the tree,

439
00:11:30,620 --> 00:11:31,865
0,180 180,285 285,390 390,650 970,1245
get to the bottom,| and
|现在我可以沿着叶子节点，不用回到上面了，

440
00:11:31,865 --> 00:11:32,920
0,150 150,285 285,435 435,705 705,1055
now I can [] through

441
00:11:32,970 --> 00:11:34,430
0,290 290,440 440,695 695,1175 1175,1460
along the leaf nodes and

442
00:11:34,430 --> 00:11:35,585
0,225 225,435 435,570 570,830 850,1155
never have to go back

443
00:11:35,585 --> 00:11:36,440
0,305
up,|
|

444
00:11:36,860 --> 00:11:37,840
0,260 260,470 470,605 605,755 755,980
we won't talk about multi
我们现在还不会讨论多线程，

445
00:11:37,840 --> 00:11:39,030
0,330 330,480 480,720 720,930 930,1190
threading just yet,| but like
|但是为了扫描而不得不获取父节点的锁，

446
00:11:39,410 --> 00:11:41,200
0,350 350,700 1170,1475 1475,1625 1625,1790
like the having to get

447
00:11:41,200 --> 00:11:42,460
0,315 315,645 645,840 840,1155 1155,1260
parent lock or latches on

448
00:11:42,460 --> 00:11:43,435
0,135 135,410 490,750 750,855 855,975
your parents in order to

449
00:11:43,435 --> 00:11:44,650
0,180 180,485 625,1005 1005,1065 1065,1215
scan along,| that's gonna be
|这将是昂贵的，

450
00:11:44,650 --> 00:11:45,490
0,315 315,540 540,615 615,705 705,840
expensive,| if I can just
|如果我能保持在我需要去的最低层级，

451
00:11:45,490 --> 00:11:46,360
0,195 195,405 405,555 555,660 660,870
keep down at the lowest

452
00:11:46,360 --> 00:11:47,220
0,240 240,375 375,480 480,600 600,860
level I need to go,|
|

453
00:11:47,570 --> 00:11:48,430
0,320 320,500 500,635 635,755 755,860
then I can, I can
那么我可以移动得更快。

454
00:11:48,430 --> 00:11:49,640
0,120 120,255 255,530
move more quickly.|
|

455
00:11:50,480 --> 00:11:52,030
0,305 305,610 900,1160 1160,1370 1370,1550
And again, if it's random
再次，如果它是随机 I/O ，这很糟糕，

456
00:11:52,030 --> 00:11:53,035
0,195 195,405 405,630 630,915 915,1005
{I/O -}, this sucks,| but
|但如果我到了这里，

457
00:11:53,035 --> 00:11:53,790
0,75 75,150 150,270 270,450 450,755
if I get down here,|
|

458
00:11:54,020 --> 00:11:55,290
0,290 290,455 455,620 620,890 890,1270
assuming all these pages are
假设所有这些页面都是在磁盘上彼此顺序或连续，

459
00:11:56,040 --> 00:11:57,465
0,600 600,810 810,1230 1230,1335 1335,1425
sequentially or contiguous on each

460
00:11:57,465 --> 00:11:58,845
0,150 150,345 345,875 895,1155 1155,1380
other on disk,| then that's
|那么所有这些要扫过的都是顺序 I/O 。

461
00:11:58,845 --> 00:11:59,820
0,120 120,420 420,510 510,735 735,975
all sequential {I/O -}, to

462
00:11:59,820 --> 00:12:01,040
0,210 210,530
scan across.|
|

463
00:12:01,170 --> 00:12:03,160
0,400 900,1175 1175,1325 1325,1600
Yes. { - -}|
是的。|

464
00:12:04,130 --> 00:12:04,990
0,245 245,350 350,485 485,650 650,860
Yeah, it point goes,| what's
是的，它指向，|在内部节点中这些指向什么，

465
00:12:04,990 --> 00:12:05,575
0,75 75,165 165,240 240,360 360,585
the point of having these

466
00:12:05,575 --> 00:12:06,685
0,195 195,270 270,345 345,605 835,1110
in the inner nodes,| it
|它在拆分和合并时对你有帮助，

467
00:12:06,685 --> 00:12:07,585
0,180 180,345 345,480 480,660 660,900
helps you when do splits,

468
00:12:07,585 --> 00:12:09,280
0,545 925,1215 1215,1350 1350,1500 1500,1695
merges, right,| if I know
|如果我知道我必须，

469
00:12:09,280 --> 00:12:10,435
0,180 180,345 345,620 700,1005 1005,1155
I have to,| like if
|比如我想偷走某个东西，

470
00:12:10,435 --> 00:12:11,400
0,105 105,210 210,360 360,615 615,965
I want to steal something,|
|

471
00:12:12,240 --> 00:12:14,355
0,180 180,440 1390,1650 1650,1845 1845,2115
so say if I delete
比如，如果我删除 10 ，10 被删除，

472
00:12:14,355 --> 00:12:16,070
0,335 685,975 975,1125 1125,1290 1290,1715
10, say 10 gets deleted,|
|

473
00:12:16,390 --> 00:12:19,395
0,260 260,380 380,620 620,1000 2430,3005
instead of having to reorganize
不是必须重新组织整棵树，

474
00:12:19,395 --> 00:12:20,520
0,150 150,345 345,665 745,1005 1005,1125
the entire tree,| I could
|我可以跟随兄弟指针，

475
00:12:20,520 --> 00:12:21,630
0,150 150,315 315,510 510,900 900,1110
follow {sibling -} pointer,| maybe
|也许从这个节点拿出一个键，把它带过来。

476
00:12:21,630 --> 00:12:22,350
0,180 180,315 315,450 450,570 570,720
take a key from this

477
00:12:22,350 --> 00:12:23,000
0,120 120,210 210,330 330,420 420,650
guy and bring it over.|
|

478
00:12:24,560 --> 00:12:25,615
0,400 600,830 830,875 875,935 935,1055
Yes. { - - -}|
是的。|

479
00:12:25,615 --> 00:12:27,100
0,150 150,285 285,545 625,1025

480
00:12:28,710 --> 00:12:30,020
0,230 230,460 570,920 920,1115 1115,1310
What is question,| what is
问题是什么，|什么是节点指针，

481
00:12:30,020 --> 00:12:32,795
0,255 255,525 525,950 2350,2625 2625,2775
a node pointer,| these red
|这些红色的行，

482
00:12:32,795 --> 00:12:36,100
0,1530 1530,1905 1905,2235 2235,2645 2905,3305
lines,| { - -} oh,
|哦，节点指针，

483
00:12:36,480 --> 00:12:38,360
0,245 245,490
the {node,pointer},|
|

484
00:12:39,530 --> 00:12:40,435
0,335 335,440 440,530 530,635 635,905
I'll show the next slide,|
我将播放下一张幻灯片，|

485
00:12:40,435 --> 00:12:41,020
0,285 285,375 375,450 450,495 495,585
you're not going to lay
你不会完全把这个这样放置，

486
00:12:41,020 --> 00:12:42,055
0,105 105,270 270,585 585,825 825,1035
this out exactly,| you wouldn't
|你不会把这些都完全按我描述的放在磁盘上，

487
00:12:42,055 --> 00:12:42,700
0,120 120,255 255,420 420,555 555,645
lay this out in a

488
00:12:42,700 --> 00:12:43,915
0,285 285,495 495,765 765,1095 1095,1215
disk exactly I'm describing,| but
|但是考虑它是，

489
00:12:43,915 --> 00:12:44,490
0,105 105,210 210,285 285,345 345,575
to think of it is,|
|

490
00:12:44,870 --> 00:12:47,080
0,305 305,500 500,790 900,1300 1860,2210
like I have the key
比如我这里有键 20 ，

491
00:12:47,080 --> 00:12:48,535
0,300 300,650 940,1185 1185,1245 1245,1455
here 20,| and so that's
|这就是这部分，

492
00:12:48,535 --> 00:12:49,750
0,165 165,455 655,915 915,1050 1050,1215
this part,| and then the
|然后节点指针说，

493
00:12:49,750 --> 00:12:51,850
0,330 330,660 660,950 1090,1490 1870,2100
node pointer is saying,| if
|如果你要寻找一个小于 20 的键，

494
00:12:51,850 --> 00:12:52,495
0,135 135,255 255,390 390,480 480,645
you're looking for a key

495
00:12:52,495 --> 00:12:54,355
0,285 285,465 465,675 675,995 1525,1860
that's less than 20,| follow
|沿着这个指针往下走，你就会找到它，

496
00:12:54,355 --> 00:12:55,300
0,240 240,570 570,705 705,825 825,945
this pointer and you go

497
00:12:55,300 --> 00:12:56,340
0,150 150,405 405,630 630,765 765,1040
down here, you find it,|
|

498
00:12:56,830 --> 00:12:58,230
0,380 380,725 725,950 950,1145 1145,1400
and in an our world,
在我们的世界里，在磁盘上的数据库系统中，

499
00:12:58,230 --> 00:12:59,130
0,165 165,270 270,465 465,705 705,900
in a database system that's

500
00:12:59,130 --> 00:13:00,180
0,120 120,570 570,825 825,930 930,1050
on disk,| it's just a
|它只是一个页面 ID 。

501
00:13:00,180 --> 00:13:01,440
0,135 135,410
page ID.|
|

502
00:13:01,600 --> 00:13:02,230
0,120 120,270 270,390 390,480 480,630

503
00:13:02,230 --> 00:13:02,965
0,165 165,300 300,555 555,660 660,735

504
00:13:02,965 --> 00:13:06,720
0,245 295,695

505
00:13:07,360 --> 00:13:08,670
0,395 395,650 650,740 740,815 815,1310
Yeah, this is the visualization
是的，这是人们通常的视觉化显示。

506
00:13:08,670 --> 00:13:11,140
0,240 240,560 880,1215 1215,1550
people usually show, show.|
|

507
00:13:12,280 --> 00:13:13,995
0,335 335,670 870,1235 1235,1445 1445,1715
{All,right}, so the, the nodes
好的，所以节点本身基本上是键值对的数组，

508
00:13:13,995 --> 00:13:14,720
0,225 225,390 390,465 465,510 510,725
themselves are going to be

509
00:13:15,040 --> 00:13:17,520
0,400 1680,2045 2045,2165 2165,2300 2300,2480
basically arrays of key value

510
00:13:17,520 --> 00:13:20,085
0,350 1240,1640 1930,2205 2205,2370 2370,2565
pairs,| and again, the keys
|键将从表中索引所基于的任何属性派生，

511
00:13:20,085 --> 00:13:21,320
0,150 150,210 210,300 300,695 835,1235
are to be derived from

512
00:13:21,670 --> 00:13:23,145
0,275 275,545 545,950 950,1235 1235,1475
whatever the attribute that the

513
00:13:23,145 --> 00:13:24,150
0,180 180,345 345,555 555,810 810,1005
index is based on from

514
00:13:24,150 --> 00:13:25,410
0,120 120,380 730,960 960,1080 1080,1260
the table,| so I say
|所以假设我在表 foo 列 abc 上构建了一个索引，

515
00:13:25,410 --> 00:13:26,630
0,165 165,315 315,525 525,840 840,1220
I built an index on

516
00:13:26,710 --> 00:13:28,755
0,350 350,665 665,1010 1280,1570 1740,2045
table foo column abc,| the
|键本身将是 abc 中每个 tuple 的副本，

517
00:13:28,755 --> 00:13:30,135
0,270 270,570 570,750 750,930 930,1380
key itself will be copies

518
00:13:30,135 --> 00:13:31,740
0,120 120,240 240,515 1195,1440 1440,1605
of the values for every

519
00:13:31,740 --> 00:13:33,540
0,225 225,540 540,705 705,1310
single tuple in abc,|
|

520
00:13:33,780 --> 00:13:34,370
0,230 230,305 305,395 395,500 500,590
so you can sort of
所以，你可以在某种程度上认为，

521
00:13:34,370 --> 00:13:35,180
0,90 90,345 345,600 600,705 705,810
think,| the index is like
|索引就是为你要索引的表的副本，

522
00:13:35,180 --> 00:13:36,340
0,135 135,570 570,705 705,870 870,1160
a replica of the table

523
00:13:36,930 --> 00:13:38,060
0,395 395,665 665,860 860,950 950,1130
that, that you're trying to

524
00:13:38,060 --> 00:13:41,990
0,320 880,1280 1960,2570 2650,3170 3610,3930
index,| and it's, it's organized
|它是以这样一种有序的方式组织的，

525
00:13:41,990 --> 00:13:43,070
0,210 210,360 360,465 465,710 820,1080
in such a way in

526
00:13:43,070 --> 00:13:44,330
0,105 105,315 315,680 850,1110 1110,1260
an ordered manner,| that allow
|你可以进行高效的 log n 查找，

527
00:13:44,330 --> 00:13:45,130
0,150 150,225 225,330 330,510 510,800
you to do these efficient

528
00:13:45,450 --> 00:13:47,195
0,290 290,470 470,1000 1200,1550 1550,1745
log n lookups, right,| in
|在关系型模型中，表可能是未排序的，

529
00:13:47,195 --> 00:13:48,395
0,75 75,330 330,675 675,930 930,1200
the relational model, the tables

530
00:13:48,395 --> 00:13:50,380
0,395 715,1005 1005,1200 1200,1365 1365,1985
are could potentially be unsorteded,|
|

531
00:13:50,460 --> 00:13:51,740
0,335 335,620 620,905 905,1160 1160,1280
we'll violate that in a
我们将在几张幻灯片中违反这一点，

532
00:13:51,740 --> 00:13:53,315
0,105 105,225 225,500 700,1100 1270,1575
few more slides,| but the
|但表可能是未排序的，

533
00:13:53,315 --> 00:13:54,395
0,255 255,435 435,510 510,990 990,1080
table could be unsorteded| and
|所以索引是一种快速排序访问的方法。

534
00:13:54,395 --> 00:13:55,130
0,105 105,315 315,540 540,660 660,735
so this index is a

535
00:13:55,130 --> 00:13:56,870
0,105 105,225 225,470 1210,1545 1545,1740
way to have fast sort

536
00:13:56,870 --> 00:13:57,920
0,210 210,560
of access.|
|

537
00:13:58,730 --> 00:13:59,440
0,215 215,275 275,395 395,560 560,710
And of course, now only
当然，只有在它涵盖数据库系统的情况下，

538
00:13:59,440 --> 00:14:00,235
0,90 90,195 195,405 405,600 600,795
if it covers the database

539
00:14:00,235 --> 00:14:01,120
0,330 330,570 570,705 705,780 780,885
system,| and we'll see this
|我们将在本学期晚些时候看到这一点，

540
00:14:01,120 --> 00:14:02,260
0,135 135,225 225,285 285,560 850,1140
later in the semester,| has
|必须确保你的索引与表同步，

541
00:14:02,260 --> 00:14:03,235
0,120 120,270 270,540 540,765 765,975
to make sure that your

542
00:14:03,235 --> 00:14:04,090
0,210 210,345 345,510 510,735 735,855
index is in sync with

543
00:14:04,090 --> 00:14:05,220
0,120 120,380
the table,

544
00:14:05,500 --> 00:14:07,220
0,350 350,700 840,1085 1085,1325 1325,1720
right,| meaning if I update,
|意思是如果我更新，在我的表中插入 tuple ，

545
00:14:07,450 --> 00:14:08,295
0,395 395,515 515,650 650,755 755,845
insert a {tuple -} into

546
00:14:08,295 --> 00:14:09,290
0,135 135,405 405,645 645,750 750,995
my table,| I want to
|我想要自动更新我的索引，

547
00:14:09,370 --> 00:14:11,295
0,400 480,800 800,1040 1040,1540 1680,1925
automatically update my indexes| and
|数据库系统会为你做这件事，

548
00:14:11,295 --> 00:14:12,210
0,120 120,345 345,615 615,795 795,915
the database system will do

549
00:14:12,210 --> 00:14:13,350
0,135 135,285 285,560 760,1005 1005,1140
this for you| and make
|并确保一切都是同步的。

550
00:14:13,350 --> 00:14:14,550
0,240 240,450 450,660 660,945 945,1200
sure everything is consistent in

551
00:14:14,550 --> 00:14:15,440
0,380
sync.|
|

552
00:14:16,580 --> 00:14:17,530
0,245 245,410 410,590 590,785 785,950
But again, we won't focus
同样，我们在这节课上不会关注这个。

553
00:14:17,530 --> 00:14:18,270
0,165 165,255 255,345 345,465 465,740
on that in this class.|
|

554
00:14:20,640 --> 00:14:22,660
0,400
The.|
这个。|

555
00:14:22,940 --> 00:14:25,380
0,290 290,580 660,965 965,1270 2040,2440
The values can differ depending,|
这些值可能会有所不同，|

556
00:14:26,630 --> 00:14:27,850
0,245 245,440 440,695 695,965 965,1220
the values will differ, depending
值会不同，取决于是内部节点或叶子节点，

557
00:14:27,850 --> 00:14:28,585
0,135 135,255 255,375 375,510 510,735
on where the inner node

558
00:14:28,585 --> 00:14:29,605
0,75 75,150 150,300 300,755 775,1020
or a leaf node,| if
|如果它是内部节点，

559
00:14:29,605 --> 00:14:30,850
0,165 165,345 345,810 810,1035 1035,1245
it's inner node,| the value
|值是指向我们下面某个页面的指针，

560
00:14:30,850 --> 00:14:31,900
0,210 210,345 345,705 705,885 885,1050
is a pointer to some

561
00:14:31,900 --> 00:14:33,565
0,195 195,435 435,770 1120,1395 1395,1665
page below us,| if it's
|如果它是叶子节点，

562
00:14:33,565 --> 00:14:34,540
0,135 135,315 315,660 660,795 795,975
the leaf node,| then it's
|那么它将是指向 tuple 的指针，

563
00:14:34,540 --> 00:14:35,940
0,120 120,315 315,585 585,950 1000,1400
gonna be either again the

564
00:14:36,770 --> 00:14:38,005
0,275 275,605 605,725 725,845 845,1235
the pointer to the tuple,|
|

565
00:14:38,005 --> 00:14:38,920
0,255 255,360 360,510 510,780 780,915
I'm using the pointer, not
我使用的指针而不是内存地址术语，

566
00:14:38,920 --> 00:14:40,645
0,120 120,210 210,435 435,800 1450,1725
{} the memory address term,|
|

567
00:14:40,645 --> 00:14:41,755
0,135 135,330 330,645 645,930 930,1110
I meaning like in page,
我的意思是页面 ID ，

568
00:14:41,875 --> 00:14:42,960
0,195 195,495 495,615 615,780 780,1085
ID,| {oh\,,sorry} the record ID
|抱歉，记录 ID 可以是 tuple 本身。

569
00:14:43,370 --> 00:14:44,830
0,335 335,545 545,820 1020,1310 1310,1460
or could be the actual

570
00:14:44,830 --> 00:14:46,060
0,285 285,590
tuple itself.|
|

571
00:14:46,520 --> 00:14:47,935
0,290 290,665 665,875 875,1070 1070,1415
The arrays within the nodes
节点本身中的数组通常按排序顺序保存，

572
00:14:47,935 --> 00:14:49,555
0,335 595,915 915,1230 1230,1485 1485,1620
themselves are typically kept in

573
00:14:49,555 --> 00:14:50,455
0,285 285,480 480,660 660,735 735,900
sorted order,| but they don't
|但不必如此，

574
00:14:50,455 --> 00:14:51,560
0,120 120,240 240,485
have to be,|
|

575
00:14:51,560 --> 00:14:53,165
0,290 790,1065 1065,1260 1260,1500 1500,1605
{} and then there's this
然后就有了这个问题，

576
00:14:53,165 --> 00:14:53,855
0,240 240,465 465,540 540,600 600,690
issue,| how do you deal
|你如何处理 NULL 键？

577
00:14:53,855 --> 00:14:55,960
0,135 135,420 420,755 1525,1815 1815,2105
with NULL keys?| Because again,
|因为假设，如果索引尝试构建，

578
00:14:56,130 --> 00:14:58,265
0,320 320,640 1140,1445 1445,1750 1860,2135
assume that if the index

579
00:14:58,265 --> 00:14:59,960
0,135 135,240 240,345 345,605 1375,1695
are trying to build,| the
|索引尝试使用 B+ 树构建，

580
00:14:59,960 --> 00:15:00,760
0,195 195,330 330,435 435,540 540,800
index are trying to build

581
00:15:01,230 --> 00:15:02,375
0,320 320,500 500,665 665,875 875,1145
using {B+ -} tree,| if
|如果它不是唯一的，则可能有空值，

582
00:15:02,375 --> 00:15:03,740
0,210 210,375 375,540 540,845 1105,1365
if it's non unique there

583
00:15:03,740 --> 00:15:04,730
0,105 105,210 210,405 405,680 760,990
could be NULL values,| we
|我们必须将空值放在某个地方，

584
00:15:04,730 --> 00:15:05,360
0,75 75,150 150,240 240,375 375,630
have to put the null

585
00:15:05,360 --> 00:15:07,070
0,350 850,1125 1125,1380 1380,1590 1590,1710
somewhere,| so typically you either
|所以通常你要么把它们全部放在末尾，要么全部放在开头，

586
00:15:07,070 --> 00:15:07,730
0,135 135,225 225,375 375,540 540,660
put them all at the

587
00:15:07,730 --> 00:15:08,615
0,210 210,420 420,600 600,780 780,885
end or all all at

588
00:15:08,615 --> 00:15:10,115
0,135 135,425 865,1185 1185,1380 1380,1500
the beginning,| and actually when
|实际上，当你在某些系统中创建索引时，

589
00:15:10,115 --> 00:15:11,300
0,135 135,425 475,885 885,1020 1020,1185
you create indexes in some

590
00:15:11,300 --> 00:15:12,590
0,270 270,570 570,810 810,1080 1080,1290
systems,| you actually define where
|你实际上定义了想要它们的位置，

591
00:15:12,590 --> 00:15:13,220
0,120 120,270 270,435 435,540 540,630
you want them,| you want
|你想要第一个还是之后，

592
00:15:13,220 --> 00:15:14,050
0,90 90,210 210,420 420,585 585,830
to be first or after,|
|

593
00:15:14,370 --> 00:15:15,245
0,320 320,530 530,650 650,740 740,875
because depending on what your
因为根据查询内容的不同，

594
00:15:15,245 --> 00:15:16,295
0,195 195,345 345,465 465,725 775,1050
query is,| you may want
|你可能不希望首先看到空值，

595
00:15:16,295 --> 00:15:17,180
0,135 135,330 330,510 510,615 615,885
to not see the nulls

596
00:15:17,180 --> 00:15:17,975
0,255 255,450 450,570 570,690 690,795
first,| you may want to
|而可能希望在最后看到它们，

597
00:15:17,975 --> 00:15:18,550
0,90 90,150 150,225 225,330 330,575
see them at the end,|
|

598
00:15:19,570 --> 00:15:20,750
0,245 245,410 410,590 590,815 815,1180
and it depends on applications.|
这取决于应用程序。|

599
00:15:22,130 --> 00:15:23,275
0,335 335,560 560,785 785,1010 1010,1145
Another important thing also, too,
另一件重要的事情是，

600
00:15:23,275 --> 00:15:25,200
0,105 105,365 1165,1455 1455,1635 1635,1925
is that,| going back here,|
|回到这里，|

601
00:15:25,580 --> 00:15:27,250
0,320 320,530 530,950 950,1385 1385,1670
there's only sibling pointers and
只有兄弟指针和指针向下移动，

602
00:15:27,250 --> 00:15:29,125
0,360 360,615 615,980 1330,1650 1650,1875
pointers going down,| there's no
|没有回传的指针，

603
00:15:29,125 --> 00:15:31,000
0,435 435,630 630,840 840,1145
pointers going back up,|
|

604
00:15:31,250 --> 00:15:32,305
0,245 245,365 365,605 605,845 845,1055
and the reason is why,|
原因是，|

605
00:15:32,305 --> 00:15:33,055
0,225 225,315 315,435 435,570 570,750
we'll see this more next
我们将在下一节课中看到更多，

606
00:15:33,055 --> 00:15:34,170
0,240 240,465 465,645 645,825 825,1115
class is,| when we start
|当我们开始在这些节点上使用 latch 的时候，

607
00:15:34,220 --> 00:15:35,880
0,365 365,860 860,995 995,1130 1130,1660
taking latches on these nodes,|
|

608
00:15:36,950 --> 00:15:37,810
0,275 275,500 500,575 575,665 665,860
we don't want to have
我们不想让一个线程以这种方式运行，自上而下，

609
00:15:37,810 --> 00:15:39,120
0,285 285,525 525,750 750,990 990,1310
one thread going this way,

610
00:15:39,320 --> 00:15:40,480
0,245 245,470 470,785 785,980 980,1160
you know, from the top

611
00:15:40,480 --> 00:15:41,890
0,320 550,855 855,1050 1050,1245 1245,1410
down,| another thread going from
|另一个线程从自下而上，

612
00:15:41,890 --> 00:15:43,165
0,105 105,300 300,650 850,1095 1095,1275
the bottom top,| because that's
|因为这将导致死锁，

613
00:15:43,165 --> 00:15:44,590
0,60 60,105 105,225 225,845 1165,1425
going to have deadlocks,| now
|现在兄弟指针也会有这个问题，

614
00:15:44,590 --> 00:15:45,625
0,135 135,435 435,765 765,930 930,1035
the sibling pointers are going

615
00:15:45,625 --> 00:15:46,405
0,90 90,195 195,405 405,645 645,780
have this issue too,| and
|我们将看看如何处理这个问题，

616
00:15:46,405 --> 00:15:46,975
0,135 135,225 225,330 330,420 420,570
we'll see how to handle

617
00:15:46,975 --> 00:15:48,925
0,305 565,965 1105,1425 1425,1755 1755,1950
that,| but by avoiding having
|但通过避免指针在不同级别之间的两个方向上移动，

618
00:15:48,925 --> 00:15:49,915
0,195 195,495 495,675 675,840 840,990
the pointers going in two

619
00:15:49,915 --> 00:15:51,850
0,275 475,795 795,1035 1035,1355 1585,1935
directions between different levels,| it's
|我们需要担心的事情就少了一件。

620
00:15:51,850 --> 00:15:52,570
0,150 150,330 330,495 495,615 615,720
one less thing we have

621
00:15:52,570 --> 00:15:53,540
0,105 105,240 240,530
to worry about.|
|

622
00:15:53,930 --> 00:15:54,985
0,260 260,350 350,500 500,730 810,1055
Because we don't need,| the
因为我们不需要，|我们将要进行拆分和合并的方式，

623
00:15:54,985 --> 00:15:55,435
0,120 120,300 300,330 330,360 360,450
way we're going to do

624
00:15:55,435 --> 00:15:56,275
0,150 150,255 255,540 540,735 735,840
splits and merges,| it's not
|它不像一棵 AVL 树，

625
00:15:56,275 --> 00:15:57,295
0,120 120,225 225,615 615,855 855,1020
like an AVL tree,| where
|你必须做旋转和所有的事情，

626
00:15:57,295 --> 00:15:58,410
0,75 75,165 165,255 255,485 565,1115
you have to do rotations

627
00:15:58,460 --> 00:16:00,385
0,400 540,815 815,1090 1560,1850 1850,1925
and all that,| we're not
|我们不会这么做。

628
00:16:00,385 --> 00:16:00,960
0,75 75,150 150,255 255,345 345,575
going do any of that.|
|

629
00:16:02,520 --> 00:16:03,470
0,275 275,440 440,560 560,770 770,950
Some may say it's, it's
可能有人会说，这更容易，

630
00:16:03,470 --> 00:16:07,340
0,230 880,1280 1390,1665 1665,1940 3610,3870
easier,| no, not really,| they
|不，不是真的，|它们都很困难。

631
00:16:07,340 --> 00:16:09,020
0,255 255,510 510,770 880,1280 1420,1680
both, both hard.| {All\,,right}, so
|好的，这又是我们的节点的样子，

632
00:16:09,020 --> 00:16:10,010
0,180 180,360 360,585 585,750 750,990
here's what again our node

633
00:16:10,010 --> 00:16:11,770
0,135 135,410 880,1215 1215,1455 1455,1760
looks like| and somewhere in
|假设这是一个页面，

634
00:16:11,880 --> 00:16:12,850
0,290 290,455 455,575 575,695 695,970
assuming this is a page,

635
00:16:13,200 --> 00:16:14,030
0,380 380,590 590,725 725,755 755,830
right,| so we're going to
|所以我们将有这个键值指针数组，抱歉，键和值，

636
00:16:14,030 --> 00:16:15,575
0,260 670,1005 1005,1230 1230,1395 1395,1545
have this array of key

637
00:16:15,575 --> 00:16:17,585
0,240 240,755 1255,1560 1560,1800 1800,2010
value pointers, sorry, keys and

638
00:16:17,585 --> 00:16:19,130
0,275 775,1050 1050,1200 1200,1365 1365,1545
values,| and then we'll have
|然后我们在这里有这些指针，

639
00:16:19,130 --> 00:16:21,200
0,350 730,1155 1155,1430
these pointers here,|
|

640
00:16:21,200 --> 00:16:22,805
0,260 310,630 630,950 1210,1545 1545,1605
{} that go, that'll be
这将是前一个和下一个的页面 ID ，

641
00:16:22,805 --> 00:16:23,705
0,90 90,210 210,375 375,660 660,900
just a page ID to

642
00:16:23,705 --> 00:16:24,980
0,120 120,375 375,755 895,1170 1170,1275
the previous one and to

643
00:16:24,980 --> 00:16:26,380
0,90 90,255 255,560 610,1005 1005,1400
the next one| along along
|沿着我们的层级，

644
00:16:26,400 --> 00:16:28,660
0,400 930,1205 1205,1480
along our level,|
|

645
00:16:29,080 --> 00:16:30,495
0,400 420,695 695,905 905,1220 1220,1415
the key value pairs could
键值对可以一个接一个地排序，

646
00:16:30,495 --> 00:16:32,265
0,150 150,345 345,785 1255,1530 1530,1770
either be sorted one after

647
00:16:32,265 --> 00:16:35,175
0,365 835,1110 1110,1335 1335,1565 2605,2910
another,| if it's a, it's
|如果它是一个内部节点，

648
00:16:35,175 --> 00:16:36,650
0,215 445,765 765,1080 1080,1215 1215,1475
an inner node,| then the
|那么值就只是指针，记录 ID ，

649
00:16:37,390 --> 00:16:38,750
0,350 350,560 560,710 710,890 890,1360
values would just be pointers,

650
00:16:38,800 --> 00:16:41,625
0,400 450,770 770,1360 2400,2645 2645,2825
again, record IDs,| we could
|我们也可以分别对它们进行排序，

651
00:16:41,625 --> 00:16:43,320
0,210 210,360 360,555 555,1115
also sort them separately,|
|

652
00:16:43,410 --> 00:16:44,735
0,335 335,530 530,790 810,1100 1100,1325
{} and this, this common
这个常见的方法，

653
00:16:44,735 --> 00:16:45,665
0,240 240,375 375,465 465,660 660,930
approach,| you would have the
|你会把键排序放在一个数组中，

654
00:16:45,665 --> 00:16:46,595
0,240 240,495 495,720 720,825 825,930
the key sort of in

655
00:16:46,595 --> 00:16:47,825
0,195 195,515 715,975 975,1095 1095,1230
one array| and then the
|然后把值分别放在另一个数组中，

656
00:16:47,825 --> 00:16:49,205
0,275 295,570 570,840 840,1230 1230,1380
values sort of separately in

657
00:16:49,205 --> 00:16:50,740
0,240 240,575 715,975 975,1185 1185,1535
another array,| and then whatever
|然后无论你在键数组中，

658
00:16:50,790 --> 00:16:52,060
0,275 275,410 410,650 650,950 950,1270
offset you are in the

659
00:16:52,620 --> 00:16:53,840
0,305 305,610 750,995 995,1100 1100,1220
in the, you know, in

660
00:16:53,840 --> 00:16:55,295
0,135 135,330 330,650 790,1065 1065,1455
the key array| that corresponds
|对应于在值数组中的一些偏移量，

661
00:16:55,295 --> 00:16:56,375
0,135 135,390 390,645 645,825 825,1080
to some offset in the

662
00:16:56,375 --> 00:16:57,605
0,210 210,315 315,540 540,885 885,1230
in the value array,| it's
|它几乎就像我们之前说过的列存储的东西，

663
00:16:57,605 --> 00:16:58,400
0,120 120,225 225,345 345,555 555,795
almost like the column store

664
00:16:58,400 --> 00:16:59,255
0,195 195,375 375,495 495,675 675,855
stuff, we said before,| you
|你可以用简单的算术来决定如何跳过，

665
00:16:59,255 --> 00:17:00,350
0,90 90,225 225,390 390,900 900,1095
can do simple arithmetic to

666
00:17:00,350 --> 00:17:01,630
0,320 490,735 735,840 840,990 990,1280
decide how to jump around|
|

667
00:17:01,890 --> 00:17:03,760
0,320 320,640 1170,1460 1460,1610 1610,1870
{[] -}, mess that up,|
[]，把它搞砸，|

668
00:17:03,840 --> 00:17:04,930
0,260 260,485 485,710 710,830 830,1090
but you you just maintain
但是你只需要维护偏移表，跟踪这些东西。

669
00:17:05,040 --> 00:17:05,975
0,260 260,395 395,530 530,725 725,935
offset table to keep keep

670
00:17:05,975 --> 00:17:07,040
0,150 150,270 270,390 390,665
track of these things.|
|

671
00:17:09,190 --> 00:17:11,205
0,400 690,950 950,1175 1175,1660 1680,2015
So, and then there's additional
所以，还有一个额外的[]来跟踪，

672
00:17:11,205 --> 00:17:12,380
0,480 480,660 660,810 810,930 930,1175
[] keep track of,| like,
|比如，这是我的页面上留下的一些 slot ，

673
00:17:12,640 --> 00:17:13,665
0,335 335,380 380,515 515,755 755,1025
here's a number of slots

674
00:17:13,665 --> 00:17:14,745
0,165 165,330 330,540 540,810 810,1080
I have left my my

675
00:17:14,745 --> 00:17:16,740
0,305 715,1020 1020,1325 1675,1905 1905,1995
page,| what level, you know,
|我看的是什么层级，

676
00:17:16,740 --> 00:17:17,520
0,180 180,375 375,480 480,585 585,780
what level am I looking

677
00:17:17,520 --> 00:17:18,735
0,320 460,720 720,870 870,1050 1050,1215
at,| and that way as
|当你向下遍历时，

678
00:17:18,735 --> 00:17:20,040
0,180 180,570 570,845 925,1185 1185,1305
you're traversing down,| you can
|你可以只看着页面，然后说，

679
00:17:20,040 --> 00:17:20,655
0,135 135,285 285,390 390,480 480,615
just look in the page

680
00:17:20,655 --> 00:17:22,425
0,105 105,210 210,485 1375,1650 1650,1770
and say,| okay, where am
|好的，我在树的什么位置，

681
00:17:22,425 --> 00:17:23,620
0,105 105,225 225,375 375,665
I in the tree,|
|

682
00:17:24,450 --> 00:17:26,150
0,365 365,530 530,820 1140,1460 1460,1700
it's also useful for recovery
它对恢复也很有用。

683
00:17:26,150 --> 00:17:27,160
0,195 195,470
as well.|
|

684
00:17:29,010 --> 00:17:29,565
0,45 45,105 105,255 255,420 420,555
So I've already said this,|
所以我已经说过了，|

685
00:17:29,655 --> 00:17:30,620
0,45 45,165 165,465 465,675 675,965
I'm just repeating myself,| but
我只是重复我自己，|但是，叶节点值本身可以是记录 ID ，

686
00:17:30,670 --> 00:17:31,920
0,400
the,

687
00:17:31,920 --> 00:17:33,020
0,225 225,465 465,645 645,855 855,1100
the, the leaf node values

688
00:17:33,040 --> 00:17:34,110
0,350 350,545 545,695 695,875 875,1070
themselves could either be record

689
00:17:34,110 --> 00:17:35,220
0,435 435,570 570,735 735,945 945,1110
IDs,| which is page number
|也就是页面编号和到某个位置的偏移量，

690
00:17:35,220 --> 00:17:36,350
0,210 210,465 465,615 615,795 795,1130
and offset to some location|
|

691
00:17:36,850 --> 00:17:38,250
0,305 305,610 690,995 995,1220 1220,1400
and then the or could
然后可以是 tuple 数据，

692
00:17:38,250 --> 00:17:39,930
0,260 340,705 705,1050 1050,1310 1420,1680
be a tuple data| as
|就像索引组织存储，

693
00:17:39,930 --> 00:17:40,700
0,105 105,210 210,360 360,510 510,770
in the case of an

694
00:17:40,780 --> 00:17:42,090
0,395 395,725 725,1025 1025,1220 1220,1310
index organized storage,| when we
|我们之前讨论过的，

695
00:17:42,090 --> 00:17:43,215
0,120 120,240 240,500 520,840 840,1125
talked about before,| like {SQLite
|比如 SQLite 和 MySQL 在默认情况下是这样做的，

696
00:17:43,215 --> 00:17:44,760
0,245 535,855 855,1065 1065,1380 1380,1545
-} and {MySQL -} do

697
00:17:44,760 --> 00:17:46,140
0,135 135,375 375,740 1000,1260 1260,1380
this by default,| but in
|但在 SQL Server 和 Oracle 中，

698
00:17:46,140 --> 00:17:47,820
0,260 730,1110 1110,1245 1245,1365 1365,1680
like SQL Server and Oracle,|
|

699
00:17:47,820 --> 00:17:48,615
0,90 90,180 180,375 375,600 600,795
you can say CREATE TABLE
你可以说 CREATE TABLE ，我想要索引组织的。

700
00:17:48,615 --> 00:17:49,275
0,150 150,255 255,375 375,480 480,660
and I want to be

701
00:17:49,275 --> 00:17:50,560
0,300 300,665
index organized,

702
00:17:50,830 --> 00:17:52,155
0,290 290,530 530,845 845,1115 1115,1325
right,| and it'll, it'll make
|它会生成一个 B+ 树，

703
00:17:52,155 --> 00:17:53,700
0,335 835,1170 1170,1275 1275,1395 1395,1545
the, it'll make a {B+

704
00:17:53,700 --> 00:17:54,615
0,210 210,480 480,690 690,810 810,915
-} tree| and then the
|然后叶子节点就是 tuple 本身。

705
00:17:54,615 --> 00:17:55,410
0,165 165,390 390,495 495,630 630,795
leaf nodes will be the

706
00:17:55,410 --> 00:17:57,080
0,165 165,315 315,585 585,980
actual just tuple themselves.|
|

707
00:17:58,680 --> 00:17:59,915
0,400 450,695 695,770 770,935 935,1235
You, for the number two,
对于第二个，你只对主键索引执行这个操作，

708
00:17:59,915 --> 00:18:00,860
0,240 240,435 435,615 615,765 765,945
you only do this for

709
00:18:00,860 --> 00:18:02,465
0,290 730,990 990,1170 1170,1395 1395,1605
the the primary key index,|
|

710
00:18:02,465 --> 00:18:04,145
0,305 415,705 705,1065 1065,1385 1435,1680
otherwise you're duplicating data,| you
否则你将复制数据，|你不会想这么做的。

711
00:18:04,145 --> 00:18:04,655
0,120 120,165 165,225 225,300 300,510
don't want to do that.|
|

712
00:18:04,655 --> 00:18:05,675
0,365 475,720 720,825 825,930 930,1020
Yes. { - - -}|
是的。|

713
00:18:05,675 --> 00:18:07,200
0,285 285,405 405,750 750,1485

714
00:18:07,300 --> 00:18:08,940
0,335 335,605 605,940

715
00:18:10,250 --> 00:18:11,515
0,245 245,490 630,875 875,1055 1055,1265
The question, if it's storing
问题是，否存储记录 ID 是叶子节点还是内部节点，

716
00:18:11,515 --> 00:18:12,940
0,240 240,675 675,915 915,1185 1185,1425
record IDs is a leaf

717
00:18:12,940 --> 00:18:14,035
0,330 330,480 480,675 675,915 915,1095
node or inner node,| it's
|它是叶子节点，

718
00:18:14,035 --> 00:18:15,990
0,215 235,540 540,965 1315,1635 1635,1955
a leaf node,| because again.|
|因为。|

719
00:18:18,820 --> 00:18:19,560
0,305 305,395 395,470 470,590 590,740
We bring up an example
我们马上就会举一个例子。

720
00:18:19,560 --> 00:18:20,840
0,90 90,165 165,410
in a second.|
|

721
00:18:22,730 --> 00:18:24,620
0,400 570,970
Here the,|
在这里，|

722
00:18:25,210 --> 00:18:26,805
0,275 275,545 545,935 935,1265 1265,1595
the only really keys that
唯一存在的键，

723
00:18:26,805 --> 00:18:28,785
0,395 715,1115 1345,1620 1620,1830 1830,1980
exist,| that actually correspond to
|对应于表中，

724
00:18:28,785 --> 00:18:29,600
0,195 195,315 315,390 390,525 525,815
what's actually in your table|
|

725
00:18:29,770 --> 00:18:30,870
0,305 305,575 575,785 785,905 905,1100
are found in the leaf
是在叶子节点中找到的。

726
00:18:30,870 --> 00:18:32,720
0,470 970,1260 1260,1470 1470,1590 1590,1850
nodes.| So we'll see this
|所以，我们将在 demo 中看到这个，

727
00:18:32,740 --> 00:18:34,005
0,365 365,605 605,830 830,1025 1025,1265
in our demo,| when we
|当我们删除和插入键时，

728
00:18:34,005 --> 00:18:36,225
0,345 345,555 555,900 900,1235 1825,2220
delete and insert keys,| they
|被删除的键，可能仍然存在于内部节点中，

729
00:18:36,225 --> 00:18:37,590
0,395 535,855 855,1050 1050,1185 1185,1365
the a key that was

730
00:18:37,590 --> 00:18:38,970
0,315 315,555 555,795 795,1035 1035,1380
deleted may actually still exist

731
00:18:38,970 --> 00:18:40,280
0,315 315,510 510,630 630,825 825,1310
in in an inner node,

732
00:18:40,680 --> 00:18:42,030
0,320 550,795 795,930 930,1215 1215,1350
right,| so you can't have
|所以你不能让它，

733
00:18:42,030 --> 00:18:43,035
0,165 165,435 435,705 705,915 915,1005
it,| like you couldn't have
|你不能让它指向某个东西的记录 ID ，

734
00:18:43,035 --> 00:18:43,755
0,90 90,180 180,285 285,450 450,720
it be a record ID

735
00:18:43,755 --> 00:18:44,930
0,240 240,405 405,570 570,810 810,1175
to point to something,| because
|因为在那个记录可能不存在，

736
00:18:45,220 --> 00:18:46,425
0,395 395,665 665,845 845,1010 1010,1205
that that record may not

737
00:18:46,425 --> 00:18:47,730
0,335 565,810 810,930 930,1110 1110,1305
exist,| in this case, here
|在这种情况中，我在这个内部节点里是 35 ，

738
00:18:47,730 --> 00:18:48,585
0,180 180,390 390,555 555,675 675,855
I have in this inner

739
00:18:48,585 --> 00:18:49,760
0,210 210,330 330,465 465,615 615,1175
node here, I have 35,|
|

740
00:18:50,230 --> 00:18:51,690
0,260 260,470 470,730 750,1310 1310,1460
but there's no 35 in
但叶子节点中没有 35 ，

741
00:18:51,690 --> 00:18:52,815
0,90 90,255 255,510 510,770 820,1125
the leaf node,| meaning at
|这意味着在某个时刻，

742
00:18:52,815 --> 00:18:54,770
0,225 225,545 1015,1335 1335,1605 1605,1955
some point,| this key got
|这个键插入了 35 ，然后被删除了，

743
00:18:54,970 --> 00:18:56,295
0,470 470,845 845,1010 1010,1205 1205,1325
35 inserted into it and

744
00:18:56,295 --> 00:18:57,885
0,165 165,420 420,905 955,1320 1320,1590
then got deleted,| but because
|但因为它的组织方式，

745
00:18:57,885 --> 00:18:58,830
0,165 165,345 345,570 570,720 720,945
the way it it got

746
00:18:58,830 --> 00:18:59,850
0,285 285,480 480,615 615,780 780,1020
organized| and in the algorithm
|以及在维护树的平衡的算法中，

747
00:18:59,850 --> 00:19:00,885
0,105 105,345 345,600 600,810 810,1035
to maintain the balance of

748
00:19:00,885 --> 00:19:01,995
0,135 135,255 255,405 405,695 835,1110
the of the tree,| I
|我最终没有删除 35 ，

749
00:19:01,995 --> 00:19:03,315
0,255 255,375 375,555 555,840 840,1320
didn't end up removing 35,|
|

750
00:19:03,315 --> 00:19:04,215
0,210 210,360 360,480 480,720 720,900
so it's still there,| so
所以它仍然在那里，|所以它就像互联网人发布的帖子一样，

751
00:19:04,215 --> 00:19:04,980
0,150 150,270 270,435 435,585 585,765
it's the thing like all

752
00:19:04,980 --> 00:19:07,010
0,240 240,560 580,915 915,1430 1630,2030
the Internet guy posts| or
|或者或者交通标志或街道标志，

753
00:19:07,030 --> 00:19:09,150
0,245 245,425 425,760 1470,1820 1820,2120
you know, or traffic signs

754
00:19:09,150 --> 00:19:10,605
0,345 345,630 630,920 1060,1335 1335,1455
or street signs| to tell
|告诉你如何在叶子中到达你需要去的地方。

755
00:19:10,605 --> 00:19:11,370
0,105 105,240 240,375 375,540 540,765
you how to get down

756
00:19:11,370 --> 00:19:11,970
0,150 150,255 255,375 375,480 480,600
to where you need to

757
00:19:11,970 --> 00:19:13,430
0,260 610,930 930,1110 1110,1215 1215,1460
go in in the leaves.|
|

758
00:19:14,910 --> 00:19:16,630
0,400 810,1100 1100,1280 1280,1445 1445,1720
Yes. { - - -}|
是的。|

759
00:19:16,740 --> 00:19:18,000
0,400 480,890 890,1150

760
00:19:18,310 --> 00:19:20,595
0,400 510,875 875,1175 1175,1510 2010,2285

761
00:19:20,595 --> 00:19:21,780
0,240 240,525 525,1085

762
00:19:23,120 --> 00:19:24,220
0,290 290,470 470,695 695,905 905,1100
His statement is,| is it
他的说法是，|是否每个内部节点都有一个键，

763
00:19:24,220 --> 00:19:25,660
0,270 270,495 495,660 660,840 840,1440
true to say that {every,inner,node}

764
00:19:25,660 --> 00:19:27,320
0,210 210,510 510,890
has one key,|
|

765
00:19:27,320 --> 00:19:28,115
0,225 225,405 405,570 570,735 735,795
but every leaf node can
但是每个叶子节点可以有多个键？

766
00:19:28,115 --> 00:19:30,120
0,60 60,270 270,635
have multiple keys?|
|

767
00:19:30,610 --> 00:19:32,205
0,350 350,650 650,1000 1020,1370 1370,1595
This example here,| I'm showing
在这里的这个例子中，|我展示了每个节点的两个键，

768
00:19:32,205 --> 00:19:33,405
0,270 270,510 510,735 735,1080 1080,1200
two keys per node,| because
|因为我必须使它适合幻灯片，

769
00:19:33,405 --> 00:19:33,840
0,90 90,165 165,225 225,315 315,435
I got to make it

770
00:19:33,840 --> 00:19:36,660
0,105 105,240 240,740 910,1310 2350,2820
fit on Powerpoint, right,| there's
|这里跟 B+ 树没有任何关系，

771
00:19:36,660 --> 00:19:37,890
0,320 340,690 690,915 915,1065 1065,1230
nothing about the {B+ -}

772
00:19:37,890 --> 00:19:38,640
0,150 150,270 270,390 390,570 570,750
tree,| that says you can
|说你只能有两个键，

773
00:19:38,640 --> 00:19:39,975
0,165 165,360 360,650 820,1140 1140,1335
only have two keys,| you
|你可以有多个键。

774
00:19:39,975 --> 00:19:41,280
0,150 150,375 375,725
have multiple keys.|
|

775
00:19:41,700 --> 00:19:43,185
0,300 300,615 615,1010 1030,1380 1380,1485

776
00:19:43,185 --> 00:19:44,145
0,165 165,300 300,480 480,705 705,960

777
00:19:44,145 --> 00:19:45,440
0,270 270,435 435,600 600,905

778
00:19:46,220 --> 00:19:47,225
0,150 150,330 330,525 525,750 750,1005

779
00:19:47,225 --> 00:19:47,480
0,225

780
00:19:48,970 --> 00:19:50,660
0,290 290,530 530,880
In this example?|
在这个例子中？|

781
00:19:50,870 --> 00:19:52,075
0,260 260,440 440,710 710,1010 1010,1205
In this example, yeah, you
在这个例子中，是的，你只需要一个，

782
00:19:52,075 --> 00:19:53,500
0,135 135,315 315,605
only need one,|
|

783
00:19:53,770 --> 00:19:55,365
0,400 570,965 965,1220 1220,1400 1400,1595
but in a real B+
但是在真正的 B+ 树中，

784
00:19:55,365 --> 00:19:56,310
0,240 240,435 435,615 615,735 735,945
tree,| you wouldn't have one
|你不必每个节点有一个键，

785
00:19:56,310 --> 00:19:58,040
0,225 225,450 450,770 1000,1290 1290,1730
key for index per node,

786
00:19:58,600 --> 00:20:01,940
0,320
right,|
|

787
00:20:01,940 --> 00:20:03,340
0,90 90,165 165,360 360,1035 1035,1400
you can have unlimited, right,|
你可以有无限的，|

788
00:20:03,840 --> 00:20:05,720
0,400 1320,1640 1640,1715 1715,1805 1805,1880
and we'll get this in
我们很快就会到这里，

789
00:20:05,720 --> 00:20:06,515
0,75 75,225 225,405 405,615 615,795
a second,| the slower the
|磁盘越慢，你想要的节点就越大，

790
00:20:06,515 --> 00:20:07,820
0,330 330,465 465,570 570,845 955,1305
disk, actually, the bigger the

791
00:20:07,820 --> 00:20:09,485
0,285 285,405 405,680 1150,1440 1440,1665
node you want,| because that's
|因为这是更多的顺序 I/O ，

792
00:20:09,485 --> 00:20:11,080
0,240 240,510 510,785
more sequential I/O,|
|

793
00:20:11,150 --> 00:20:12,025
0,260 260,350 350,455 455,665 665,875
you could have hundreds of
你可以有几百个键，

794
00:20:12,025 --> 00:20:13,080
0,275
keys,|
|

795
00:20:15,980 --> 00:20:16,885
0,290 290,365 365,665 665,800 800,905
there's a limitation on what
我在幻灯片上展示的内容是有限的，

796
00:20:16,885 --> 00:20:17,700
0,90 90,180 180,270 270,375 375,815
I can show on PowerPoint,|
|

797
00:20:17,900 --> 00:20:18,910
0,400 450,740 740,815 815,920 920,1010
but we'll bring up the
但我们马上会展示 demo 。

798
00:20:18,910 --> 00:20:21,280
0,230 1030,1275 1275,1365 1365,1610
demo in a second.|
|

799
00:20:22,250 --> 00:20:23,720
0,290 290,580
Other questions?|
还有其他问题吗？|

800
00:20:25,000 --> 00:20:26,480
0,350 350,700
Okay, so,|
好的，那么，|

801
00:20:27,010 --> 00:20:27,915
0,305 305,485 485,605 605,725 725,905
I made a big deal,|
我做了一个大的[决定]，|

802
00:20:27,915 --> 00:20:29,115
0,270 270,635 915,990 990,1080 1080,1200
like, okay, we're talking about
我们说的是 B+ 树，不是 B 树，

803
00:20:29,115 --> 00:20:29,985
0,165 165,345 345,510 510,660 660,870
{B+ -} trees, not B

804
00:20:29,985 --> 00:20:30,960
0,275
trees,|
|

805
00:20:31,030 --> 00:20:31,665
0,245 245,350 350,470 470,560 560,635
you may not know what
你可能不知道什么是 B 树。

806
00:20:31,665 --> 00:20:33,320
0,75 75,345 345,605
a {B,tree} is.|
|

807
00:20:33,360 --> 00:20:35,015
0,400 450,755 755,1040 1040,1370 1370,1655
So, the original B tree
所以，源自 1972 年的原始 B 树

808
00:20:35,015 --> 00:20:37,715
0,285 285,1205 1735,2055 2055,2375 2395,2700
from 1972| had all the
|将所有键和值存储在整个树中，

809
00:20:37,715 --> 00:20:39,275
0,210 210,405 405,695 895,1275 1275,1560
keys and values stored all

810
00:20:39,275 --> 00:20:41,180
0,300 300,525 525,815 1075,1395 1395,1905
throughout the tree,| like AVL
|比如 AVL 树，

811
00:20:41,180 --> 00:20:42,600
0,240 240,435 435,710
tree, for example,|
|

812
00:20:43,090 --> 00:20:44,420
0,260 260,440 440,650 650,965 965,1330
and it's more space efficient,|
它更节省空间，|

813
00:20:44,500 --> 00:20:45,960
0,290 290,470 470,710 710,1060 1080,1460
because you never have keys
因为你从来没有键，

814
00:20:45,960 --> 00:20:47,620
0,345 345,710
that are,|
|

815
00:20:47,620 --> 00:20:49,290
0,260 490,870 870,1095 1095,1365 1365,1670
that don't correspond to actually
与你的数据库中的实际数据不一致，

816
00:20:49,430 --> 00:20:50,335
0,275 275,395 395,500 500,680 680,905
something in your data set,|
|

817
00:20:50,335 --> 00:20:51,130
0,150 150,255 255,375 375,585 585,795
like I said before,| I
就像我之前说的，|我可以删除记录 35 ，键 35 ，

818
00:20:51,130 --> 00:20:53,185
0,180 180,500 1000,1335 1335,1830 1830,2055
could delete record 35, key

819
00:20:53,185 --> 00:20:56,560
0,485 1015,1415 2095,2495 2665,3045 3045,3375
35| and I get it'll
|它会从叶子节点中删除，

820
00:20:56,560 --> 00:20:57,325
0,150 150,360 360,495 495,600 600,765
get removed from the leaf

821
00:20:57,325 --> 00:20:58,060
0,285 285,375 375,450 450,585 585,735
nodes,| but it may end
|但它最终可能仍然是一个路标，

822
00:20:58,060 --> 00:20:58,870
0,120 120,270 270,540 540,750 750,810
up is still one of

823
00:20:58,870 --> 00:21:00,120
0,75 75,240 240,710
the {guideposts -},|
|

824
00:21:00,120 --> 00:21:01,220
0,255 255,465 465,585 585,765 765,1100
or I could have multiple
或者我可能有多个键的副本，

825
00:21:01,630 --> 00:21:02,835
0,440 440,530 530,650 650,905 905,1205
copies of the key| going
|从内部节点到叶子节点，

826
00:21:02,835 --> 00:21:04,635
0,285 285,635 1105,1410 1410,1695 1695,1800
down my inner nodes to

827
00:21:04,635 --> 00:21:06,945
0,90 90,255 255,755 835,1235 1855,2310
the leaf node,| and that's
|这可能会浪费数据或空间。

828
00:21:06,945 --> 00:21:08,550
0,240 240,630 630,905 1105,1350 1350,1605
potentially wasting data or wasting

829
00:21:08,550 --> 00:21:09,500
0,290
space.|
|

830
00:21:09,850 --> 00:21:11,240
0,400 540,785 785,890 890,1070 1070,1390
So in a B tree,|
所以在一个 B 树中，|

831
00:21:11,380 --> 00:21:12,920
0,320 320,560 560,860 860,1190 1190,1540
a key only appears once
一个键在整个树的任何地方只出现一次，

832
00:21:13,300 --> 00:21:14,540
0,320 320,500 500,650 650,890 890,1240
anywhere in the entire tree,|
|

833
00:21:15,120 --> 00:21:16,425
0,350 550,795 795,930 930,1140 1140,1305
{} but the problem with
但它的问题是，

834
00:21:16,425 --> 00:21:18,570
0,135 135,270 270,515 1105,1505 1765,2145
that one is the,| the
|这些值表示，指向实际 tuple 的记录，

835
00:21:18,570 --> 00:21:20,700
0,380 670,1070 1270,1515 1515,1760 1840,2130
values mean, the record pointing

836
00:21:20,700 --> 00:21:21,840
0,105 105,195 195,345 345,740 850,1140
to the actual tuples,| they
|它们可以在树中的任何地方，

837
00:21:21,840 --> 00:21:22,815
0,135 135,380 430,705 705,825 825,975
can be anywhere in the

838
00:21:22,815 --> 00:21:24,225
0,305 655,930 930,1080 1080,1260 1260,1410
tree,| and so now if
|现在如果我想按顺序扫描，

839
00:21:24,225 --> 00:21:25,125
0,120 120,225 225,375 375,615 615,900
I want to scan along

840
00:21:25,125 --> 00:21:27,000
0,815 1105,1365 1365,1515 1515,1710 1710,1875
sequentially| to get all the
|得到我需要的所有键，

841
00:21:27,000 --> 00:21:28,125
0,225 225,480 480,660 660,885 885,1125
keys I need in, in,

842
00:21:28,125 --> 00:21:29,430
0,180 180,315 315,420 420,665 1015,1305
in sort of order,| I
|我可能需要向上，向下遍历，

843
00:21:29,430 --> 00:21:30,450
0,165 165,300 300,465 465,795 795,1020
may have to traverse up,

844
00:21:30,450 --> 00:21:31,260
0,195 195,345 345,555 555,720 720,810
up and down,| because I
|因为我基本上在做广度优先搜索。

845
00:21:31,260 --> 00:21:32,040
0,195 195,375 375,465 465,600 600,780
basically have to do {breadth-first

846
00:21:32,040 --> 00:21:33,140
0,195 195,500
-} search,

847
00:21:33,240 --> 00:21:34,380
0,400
right.|
|

848
00:21:34,450 --> 00:21:35,280
0,290 290,455 455,620 620,725 725,830
And again, we're not going
再次，我们现在还不打算讨论 latch ，

849
00:21:35,280 --> 00:21:36,030
0,60 60,150 150,285 285,630 630,750
to talk about latching just

850
00:21:36,030 --> 00:21:36,705
0,165 165,345 345,465 465,555 555,675
yet,| but think of like,
|但是想想看，我基本上必须锁整个树，

851
00:21:36,705 --> 00:21:37,515
0,150 150,345 345,510 510,615 615,810
I basically have to latch

852
00:21:37,515 --> 00:21:39,030
0,180 180,390 390,725 1045,1320 1320,1515
the entire tree,| as I'm
|因为我向上和向下移动，

853
00:21:39,030 --> 00:21:40,820
0,165 165,390 390,540 540,800 1390,1790
going up and down,| whereas
|而在一个 B+ 树中，

854
00:21:40,930 --> 00:21:41,955
0,245 245,350 350,500 500,710 710,1025
in a {B+ -} tree,|
|

855
00:21:41,955 --> 00:21:43,335
0,330 330,540 540,750 750,1200 1200,1380
because the leaf nodes are
因为只有叶子节点是值实际存在的地方，

856
00:21:43,335 --> 00:21:44,550
0,210 210,465 465,645 645,905 955,1215
only places where values actually

857
00:21:44,550 --> 00:21:46,155
0,260 670,1005 1005,1215 1215,1365 1365,1605
are, right,| consider like, that's
|考虑就像是表中（值）的准确副本，

858
00:21:46,155 --> 00:21:47,430
0,210 210,465 465,675 675,990 990,1275
the, the exact copy of

859
00:21:47,430 --> 00:21:48,860
0,240 240,315 315,435 435,710
what's in the table,|
|

860
00:21:48,860 --> 00:21:49,790
0,225 225,435 435,645 645,810 810,930
once I get to the
一旦我到达叶子节点，

861
00:21:49,790 --> 00:21:51,350
0,195 195,770 910,1200 1200,1455 1455,1560
leaf nodes,| I don't have
|我不需要维护树中上部的任何 latch ，

862
00:21:51,350 --> 00:21:52,145
0,105 105,330 330,585 585,705 705,795
to maintain any of the

863
00:21:52,145 --> 00:21:53,285
0,405 405,600 600,795 795,1005 1005,1140
latches from upper parts in

864
00:21:53,285 --> 00:21:54,260
0,135 135,425 565,810 810,900 900,975
the tree,| and I can
|我可以沿着叶子扫描，

865
00:21:54,260 --> 00:21:55,780
0,120 120,315 315,510 510,800 1120,1520
just scan along the leaves|
|

866
00:21:56,190 --> 00:21:57,560
0,400 420,695 695,920 920,1235 1235,1370
and let other threads do
让其他线程在[]的顶部做任何它们想做的事情，

867
00:21:57,560 --> 00:21:58,460
0,150 150,270 270,525 525,780 780,900
whatever they want at the

868
00:21:58,460 --> 00:21:59,360
0,150 150,285 285,390 390,645 645,900
top of a []| as
|而不需要我做的事情。

869
00:21:59,360 --> 00:22:00,290
0,120 120,360 360,705 705,810 810,930
long as doesn't need for

870
00:22:00,290 --> 00:22:01,500
0,120 120,300 300,530
what I'm doing,

871
00:22:01,780 --> 00:22:02,900
0,400
right.|
|

872
00:22:02,900 --> 00:22:04,985
0,350 910,1310 1330,1730 1780,2010 2010,2085
So the advantage for a
所以 B+ 树相对于 B 树的优势在于，

873
00:22:04,985 --> 00:22:07,640
0,135 135,330 330,585 585,935 2335,2655
{B+ -} tree over B

874
00:22:07,640 --> 00:22:08,480
0,165 165,255 255,500 520,795 795,840
trees is that,| we're going
|我们有更好的并发访问，

875
00:22:08,480 --> 00:22:09,790
0,60 60,165 165,375 375,945 945,1310
to have better concurrent access,|
|

876
00:22:09,990 --> 00:22:10,835
0,365 365,575 575,710 710,755 755,845
and again, we're going to
同样，我们将最大限度地，

877
00:22:10,835 --> 00:22:14,390
0,605 2125,2525 3085,3330 3330,3435 3435,3555
maximize,| improve the amount of
|提高我们在顺序 I/O 的数量，而不是随机 I/O 。

878
00:22:14,390 --> 00:22:15,155
0,195 195,360 360,495 495,660 660,765
sequential {I/O -} we're doing,

879
00:22:15,155 --> 00:22:16,360
0,165 165,360 360,540 540,815
over random {I/O -}.|
|

880
00:22:17,700 --> 00:22:18,880
0,400
Yes.|
是的。|

881
00:22:22,150 --> 00:22:23,600
0,305 305,455 455,635 635,1120

882
00:22:24,030 --> 00:22:25,420
0,260 260,425 425,725 725,1055 1055,1390
His question is,| if the,
他的问题是，|如果，

883
00:22:26,450 --> 00:22:28,050
0,305 305,610 690,995 995,1325 1325,1600
if the inner nodes only,
如果内部节点只是路标，

884
00:22:28,340 --> 00:22:29,800
0,335 335,980 980,1175 1175,1310 1310,1460
only guideposts,| why do we
|为什么我们会有兄弟指针？

885
00:22:29,800 --> 00:22:31,500
0,290
have,

886
00:22:31,570 --> 00:22:32,400
0,245 245,320 320,410 410,560 560,830
why do we have sibling

887
00:22:32,400 --> 00:22:33,520
0,380
pointers?|
|

888
00:22:35,130 --> 00:22:36,665
0,350 350,575 680,785 785,1060 1230,1535
Because when you're doing split
因为在你进行拆分合并时，

889
00:22:36,665 --> 00:22:38,410
0,455 655,960 960,1215 1215,1455 1455,1745
merges,| you may need to
|你可能需要借东西或与你的相邻节点合并，

890
00:22:39,120 --> 00:22:40,850
0,350 350,680 680,995 995,1310 1310,1730
do borrow things or emerge

891
00:22:40,850 --> 00:22:42,060
0,165 165,270 270,530
with your neighbor,|
|

892
00:22:42,430 --> 00:22:43,850
0,260 260,395 395,590 590,910 1020,1420
and they may, they may,|
他们可能，|

893
00:22:43,870 --> 00:22:44,925
0,260 260,520 540,800 800,935 935,1055
you know, you have the
你们有相同的父节点，

894
00:22:44,925 --> 00:22:45,885
0,150 150,455 565,795 795,870 870,960
same parent,| instead of going
|不是从父节点得到，

895
00:22:45,885 --> 00:22:46,425
0,90 90,210 210,375 375,480 480,540
make it parent,| you can
|你可以绕过并得到它们，

896
00:22:46,425 --> 00:22:47,120
0,105 105,240 240,360 360,450 450,695
go across and get them,|
|

897
00:22:50,385 --> 00:22:51,615
0,90 90,210 210,360 925,1155 1155,1230
you don't need it, it's
你不需要它，它只是一个优化。

898
00:22:51,615 --> 00:22:53,080
0,90 90,225 225,695
just an optimization.|
|

899
00:22:54,820 --> 00:22:55,815
0,440 440,575 575,695 695,845 845,995
Postgres does it,| I actually
Postgres 实现了它，|我不知道 MySQL 是不是这样的。

900
00:22:55,815 --> 00:22:56,355
0,105 105,225 330,405 405,465 465,540
don't know, I don't know

901
00:22:56,355 --> 00:22:57,760
0,135 135,390 390,755
whether MySQL does.|
|

902
00:23:03,070 --> 00:23:03,520
0,60 60,135 135,240 240,345 345,450
So let's see,| how we
所以让我们看看，|我们想要如何做我们的基本操作。

903
00:23:03,520 --> 00:23:04,360
0,105 105,240 240,420 420,585 585,840
want to do our basic

904
00:23:04,360 --> 00:23:05,560
0,380
operations.|
|

905
00:23:05,930 --> 00:23:07,465
0,245 245,335 335,410 410,850 1290,1535
So do an insert,| we
所以，做一个 insert ，|我们想要，

906
00:23:07,465 --> 00:23:08,290
0,90 90,210 210,465 465,690 690,825
want to,| basically, the goal
|基本上目标是找到正确的叶子节点，

907
00:23:08,290 --> 00:23:08,980
0,135 135,240 240,390 390,540 540,690
is to find the correct

908
00:23:08,980 --> 00:23:11,980
0,180 180,590
leaf node,|
|

909
00:23:11,990 --> 00:23:13,540
0,305 305,520 540,890 890,1265 1265,1550
we're gonna basically traverse down,
我们基本上要往下走，沿着路标，

910
00:23:13,540 --> 00:23:14,735
0,300 300,465 465,930 930,1185 1185,1395
following the guidepost,| get to
|到达某个叶子节点，

911
00:23:14,835 --> 00:23:16,070
0,180 180,360 360,630 630,855 855,1235
some leaf node,| where, where
|我们的键应该在那里，

912
00:23:16,220 --> 00:23:18,820
0,305 305,515 515,680 680,940 2310,2600
our key should be| and
|如果它有足够的空间，

913
00:23:18,820 --> 00:23:19,690
0,135 135,225 225,375 375,585 585,870
if it has enough space,|
|

914
00:23:19,690 --> 00:23:20,785
0,270 270,405 405,705 705,855 855,1095
great, we insert it in,|
很好，我们把它插入，|

915
00:23:20,785 --> 00:23:21,835
0,345 345,540 540,765 765,915 915,1050
sorted, order in in that
在那个叶子节点上排序，

916
00:23:21,835 --> 00:23:22,680
0,150 150,330 330,480 480,615 615,845
leaf node| and we're done,|
|我们就完成了，|

917
00:23:23,340 --> 00:23:24,620
0,225 225,435 435,660 660,945 945,1280
if there's not enough space,|
如果没有足够的空间，|

918
00:23:25,480 --> 00:23:27,420
0,400 750,1025 1025,1300 1590,1835 1835,1940
meaning the keys, the number
这意味着节点上我们拥有的键的数量是满的，

919
00:23:27,420 --> 00:23:28,065
0,120 120,240 240,345 345,480 480,645
of keys we have is

920
00:23:28,065 --> 00:23:29,430
0,165 165,300 300,405 405,845 1045,1365
full at the node,| then
|那么我们必须将我们试图插入的叶子节点拆分为两个节点，

921
00:23:29,430 --> 00:23:30,615
0,180 180,285 285,510 510,855 855,1185
we have to split whatever

922
00:23:30,615 --> 00:23:31,710
0,240 240,435 435,825 825,1005 1005,1095
the leaf node we're trying

923
00:23:31,710 --> 00:23:34,065
0,75 75,315 315,590 1150,1550 2080,2355
to insert into into two

924
00:23:34,065 --> 00:23:35,200
0,515
nodes,|
|

925
00:23:35,240 --> 00:23:36,430
0,305 305,455 455,590 590,880 930,1190
divide it in half,| but
把它一分为二，|一半的键放在一边，一半的键放在另一边，

926
00:23:36,430 --> 00:23:37,075
0,150 150,300 300,450 450,570 570,645
half the keys go on

927
00:23:37,075 --> 00:23:37,975
0,150 150,375 375,585 585,735 735,900
one side, half the keys

928
00:23:37,975 --> 00:23:38,730
0,150 150,240 240,315 315,450 450,755
go on the other side,|
|

929
00:23:39,170 --> 00:23:40,180
0,275 275,425 425,575 575,725 725,1010
and then you're gonna copy
然后你要复制列表中间的键到你的父节点，

930
00:23:40,180 --> 00:23:41,215
0,255 255,420 420,555 555,795 795,1035
up whatever the middle key

931
00:23:41,215 --> 00:23:42,925
0,275 895,1260 1260,1500 1500,1620 1620,1710
is between in that, in

932
00:23:42,925 --> 00:23:44,080
0,105 105,240 240,390 390,665 835,1155
that list of keys up

933
00:23:44,080 --> 00:23:45,420
0,165 165,315 315,620
to your parent,|
|

934
00:23:45,710 --> 00:23:46,705
0,245 245,380 380,605 605,815 815,995
and then now we have
现在我们有了一个新的路标

935
00:23:46,705 --> 00:23:47,980
0,165 165,425 445,825 825,1080 1080,1275
a new new new {guidepost

936
00:23:47,980 --> 00:23:48,970
0,255 255,420 420,510 510,660 660,990
-}| and a new pointer
|和一个指向你刚刚创建的新节点的新指针，

937
00:23:48,970 --> 00:23:50,800
0,255 255,650 1090,1350 1350,1590 1590,1830
down to the new the

938
00:23:50,800 --> 00:23:51,750
0,135 135,390 390,510 510,660 660,950
new node, you just created,|
|

939
00:23:51,860 --> 00:23:53,320
0,320 320,545 545,970
new leaf node.|
新的叶子节点。|

940
00:23:53,390 --> 00:23:54,160
0,230 230,305 305,440 440,590 590,770
And of course, this happens
当然，这是递归发生的，

941
00:23:54,160 --> 00:23:56,155
0,615 615,795 795,990 990,1280 1750,1995
recursively, right,| if I, if
|如果我把中间的键向上提升到父节点，

942
00:23:56,155 --> 00:23:57,210
0,135 135,270 270,480 480,750 750,1055
I, if I promote up

943
00:23:57,440 --> 00:23:58,420
0,245 245,425 425,680 680,830 830,980
the middle key that I

944
00:23:58,420 --> 00:23:59,640
0,180 180,440 610,855 855,960 960,1220
split on to the parent|
|

945
00:23:59,900 --> 00:24:00,940
0,260 260,425 425,650 650,845 845,1040
and that parent is full,|
而父节点是满的，|

946
00:24:00,940 --> 00:24:01,645
0,180 180,270 270,360 360,525 525,705
well, now I gotta split
那么现在我必须拆分父节点，

947
00:24:01,645 --> 00:24:02,620
0,135 135,395
the parent,|
|

948
00:24:03,070 --> 00:24:05,025
0,400 1140,1415 1415,1550 1550,1850 1850,1955
and that can cascade all
而这可能会一直延续到顶端。

949
00:24:05,025 --> 00:24:05,600
0,60 60,120 120,210 210,315 315,575
the way to the top.|
|

950
00:24:08,000 --> 00:24:09,120
0,400
So,
所以，在 PowerPoint 中制作这些幻灯片来展示这个，

951
00:24:09,570 --> 00:24:11,810
0,400 1230,1550 1550,1775 1775,2030 2030,2240
making, making these slides show

952
00:24:11,810 --> 00:24:13,800
0,180 180,500
this in,

953
00:24:14,450 --> 00:24:16,765
0,400 1290,1850 1850,2120 2120,2195 2195,2315
in PowerPoint,| it's kind of
|是一种痛苦，

954
00:24:16,765 --> 00:24:18,520
0,275 625,1025
pain,| so,
|所以，我要做的，

955
00:24:18,520 --> 00:24:19,630
0,225 225,255 255,390 390,710 820,1110
I'm going to do,| I'm
|我要把这个可视化，

956
00:24:19,630 --> 00:24:19,975
0,45 45,90 90,150 150,225 225,345
going to bring up this

957
00:24:19,975 --> 00:24:21,330
0,615 615,840 840,960 960,1095 1095,1355
visualization,| so this is a,|
|所以这是一个，

958
00:24:23,430 --> 00:24:24,840
0,245 245,305 305,395 395,670
bring it up here,|
把它拿到这里，|

959
00:24:25,680 --> 00:24:26,950
0,260 260,520 720,950 950,1025 1025,1270
the size, here we go,|
这是我们要的大小，|

960
00:24:27,240 --> 00:24:28,000
0,245 245,335 335,425 425,515 515,760
so this is a website,|
这是一个网站，|

961
00:24:28,560 --> 00:24:30,740
0,400 600,1000 1620,1865 1865,1985 1985,2180
the link on the slides
幻灯片上的链接将你带到错误的地址，

962
00:24:30,740 --> 00:24:31,520
0,210 210,375 375,480 480,585 585,780
takes you to the wrong

963
00:24:31,520 --> 00:24:33,280
0,320
one,|
|

964
00:24:33,740 --> 00:24:36,295
0,550 630,890 890,995 995,1240 2160,2555
I'll update it,| but if
我会更新它，|但如果你搜索 B+ 树可视化，

965
00:24:36,295 --> 00:24:37,195
0,255 255,405 405,570 570,720 720,900
you search {B+ -} tree

966
00:24:37,195 --> 00:24:39,000
0,525 525,735 735,840 840,1115 1405,1805
visualization,| you'll get this. {}|
|你会得到这个。|

967
00:24:39,590 --> 00:24:40,810
0,400 600,875 875,920 920,1010 1010,1220
So, I'm going to do
所以我要做一个 B+ 树的 demo ，阶数是 2 ，

968
00:24:40,810 --> 00:24:42,550
0,350 1000,1290 1290,1425 1425,1560 1560,1740
a demo of a {B+

969
00:24:42,550 --> 00:24:43,750
0,210 210,450 450,690 690,945 945,1200
-} tree, with degree 2,|
|

970
00:24:43,750 --> 00:24:44,500
0,165 165,255 255,435 435,630 630,750
so the maximum number of
所以每个节点的最大键数是 2 ，

971
00:24:44,500 --> 00:24:45,720
0,210 210,450 450,750 750,915 915,1220
keys per node is 2,|
|

972
00:24:45,830 --> 00:24:47,200
0,260 260,470 470,725 725,1145 1145,1370
and maximum of pointers is
最大指针数是 3 。

973
00:24:47,200 --> 00:24:49,500
0,150 150,255 255,435 435,770
going to be 3.|
|

974
00:24:51,080 --> 00:24:52,045
0,380 380,605 605,725 725,845 845,965
So the first thing we'll
所以我们要做的第一件事，

975
00:24:52,045 --> 00:24:53,040
0,150 150,360 360,405 405,480 480,995
do,| we're going to insert
|我们插入 2 ，

976
00:24:53,120 --> 00:24:54,955
0,400 1050,1355 1355,1565 1565,1715 1715,1835
2,| that lands in our
|它落在我们的根节点上，

977
00:24:54,955 --> 00:24:56,290
0,165 165,605 925,1155 1155,1230 1230,1335
root node,| can I make
|我能把它放大一点吗，

978
00:24:56,290 --> 00:24:57,480
0,165 165,470
that bigger,|
|

979
00:24:58,220 --> 00:25:00,820
0,90 90,255 255,560 1300,1700
let's try this, height
让我们试试这个，高度 200 ，

980
00:25:03,660 --> 00:25:05,045
0,515 515,770 770,1030 1050,1295 1295,1385
200| and then now I
|然后现在我也许可以做这个，

981
00:25:05,045 --> 00:25:06,360
0,75 75,195 195,345 345,605
can maybe do this,|
|

982
00:25:07,120 --> 00:25:08,500
0,260 260,380 380,640
is that better?|
这样好点了吗？|

983
00:25:10,360 --> 00:25:11,025
0,305 305,455 455,530 530,635 635,665
{All,right}, so then we're going
好的，然后我们要插入 6 ，

984
00:25:11,025 --> 00:25:13,710
0,60 60,495 495,875 1645,2045 2305,2685
to insert 6, right,| so
|再次，我们只有一个根节点，

985
00:25:13,710 --> 00:25:15,750
0,380 1540,1785 1785,1890 1890,1965 1965,2040
again, we only have a

986
00:25:15,750 --> 00:25:16,905
0,150 150,615 615,885 885,1005 1005,1155
root node,| it can hold
|它可以容纳两个键，

987
00:25:16,905 --> 00:25:18,420
0,195 195,485 625,960 960,1245 1245,1515
two keys,| so nothing changes
|所以这里没有什么变化，

988
00:25:18,420 --> 00:25:19,590
0,320 550,810 810,945 945,1110 1110,1170
here,| so now we're going
|所以现在我们要插入 4 。

989
00:25:19,590 --> 00:25:21,000
0,60 60,375 375,710
to insert 4.|
|

990
00:25:22,680 --> 00:25:23,620
0,215 215,275 275,410 410,620 620,940
So in this case here,|
所以，在这个例中，|

991
00:25:23,820 --> 00:25:24,755
0,275 275,410 410,545 545,725 725,935
we try to put three
我们尝试在根节点中放入三个键，

992
00:25:24,755 --> 00:25:25,535
0,180 180,300 300,405 405,585 585,780
keys in our root,| we
|我们不能这么做，

993
00:25:25,535 --> 00:25:26,615
0,225 225,360 360,635 805,1020 1020,1080
can't do that,| so it
|所以它决定在 4 上分裂，

994
00:25:26,615 --> 00:25:27,700
0,270 270,465 465,615 615,780 780,1085
decides to split on 4,|
|

995
00:25:28,080 --> 00:25:29,480
0,335 335,560 560,850 990,1250 1250,1400
makes two new, two new
生成两个新的叶子节点，

996
00:25:29,480 --> 00:25:32,495
0,180 180,710 1900,2300 2590,2880 2880,3015
leaf nodes| and then the
|然后中间的键是 4 ，

997
00:25:32,495 --> 00:25:35,090
0,195 195,405 405,665 1825,2225 2245,2595
middle key {is,4},| {anything,less,than} 4
|任何小于 4 的在这边，

998
00:25:35,090 --> 00:25:36,365
0,210 210,330 330,495 495,800 1000,1275
goes on this side,| greater
|大于 4 的在另一边，

999
00:25:36,365 --> 00:25:37,175
0,180 180,345 345,525 525,705 705,810
than {} 4 goes on

1000
00:25:37,175 --> 00:25:37,865
0,75 75,195 195,390 390,570 570,690
the other side,| so 2
|所以 2 在这个叶子节点，

1001
00:25:37,865 --> 00:25:38,495
0,90 90,195 195,330 330,480 480,630
is on this node, over

1002
00:25:38,495 --> 00:25:39,755
0,180 180,345 345,495 495,905 985,1260
here, this leaf node,| and
|然后 4 和 8 在另一边。

1003
00:25:39,755 --> 00:25:41,855
0,275 1495,1770 1770,1875 1875,1980 1980,2100
then 4 and 8 on

1004
00:25:41,855 --> 00:25:43,100
0,75 75,225 225,545 745,1065 1065,1245
the other side.| And in
|在这个实现中，

1005
00:25:43,100 --> 00:25:44,300
0,195 195,530 640,900 900,1050 1050,1200
this implementation,| they only have
|它们只有一个方向的兄弟指针，

1006
00:25:44,300 --> 00:25:45,230
0,120 120,405 405,675 675,780 780,930
the sibling pointer going in

1007
00:25:45,230 --> 00:25:46,420
0,210 210,530
one direction,|
|

1008
00:25:46,420 --> 00:25:48,040
0,210 210,450 450,675 675,950 1150,1620
some systems do that,| Postgres
有些系统这样做，|Postgres 做了两个方向，

1009
00:25:48,040 --> 00:25:49,580
0,165 165,345 345,650
does both directions,|
|

1010
00:25:50,340 --> 00:25:51,825
0,75 75,135 135,285 285,590 1210,1485
and it's not wrong, it
这不是错的，只是做得不同，

1011
00:25:51,825 --> 00:25:53,000
0,180 180,485
done differently.|
|

1012
00:25:54,410 --> 00:25:55,470
0,230 230,335 335,455 455,740 740,1060
So now I insert 5,
所以现在我插入 5 ，

1013
00:25:56,090 --> 00:25:57,630
0,400 540,770 770,890 890,1160 1160,1540
right,| so I follow 4,|
|我跟着插入 4 ，|

1014
00:25:58,220 --> 00:25:59,515
0,290 290,455 455,650 650,970 1020,1295
4 is less than 5,
4 小于 5 ，大于等于 4 ，

1015
00:25:59,515 --> 00:26:00,430
0,135 135,395 415,705 705,825 825,915
is greater, greater than equal

1016
00:26:00,430 --> 00:26:01,450
0,135 135,410 670,885 885,930 930,1020
to 4,| so it would
|所以它将向下移动到前一个节点，

1017
00:26:01,450 --> 00:26:02,215
0,135 135,315 315,465 465,570 570,765
go down to the previous

1018
00:26:02,215 --> 00:26:03,420
0,510 510,750 750,840 840,945 945,1205
node,| but then I have,
|但是我已经有两个键了，

1019
00:26:03,680 --> 00:26:04,720
0,260 260,440 440,665 665,860 860,1040
I had two keys already

1020
00:26:04,720 --> 00:26:05,440
0,150 150,345 345,510 510,600 600,720
in there,| so I had
|所以我必须拆分那个叶子节点，

1021
00:26:05,440 --> 00:26:07,380
0,180 180,435 435,750 750,1130 1540,1940
to split that key and

1022
00:26:08,000 --> 00:26:08,995
0,275 275,440 440,620 620,890 890,995
split that leaf node,| I
|我做了两个节点，

1023
00:26:08,995 --> 00:26:10,195
0,150 150,315 315,785 835,1095 1095,1200
made two nodes| and then
|然后我把 5 放在上面。

1024
00:26:10,195 --> 00:26:11,110
0,165 165,390 390,585 585,750 750,915
I I put 5 up

1025
00:26:11,110 --> 00:26:11,900
0,290
there.|
|

1026
00:26:12,650 --> 00:26:13,620
0,400
Okay?|
好的？|

1027
00:26:16,800 --> 00:26:18,160
0,260 260,380 380,485 485,730
So first, so good?|
所以第一个，（大家）都还好吗？|

1028
00:26:22,730 --> 00:26:23,980
0,350 350,590 590,800 800,1055 1055,1250
So, delete is essentially the
所以， delete 本质上是与此相反的，

1029
00:26:23,980 --> 00:26:26,220
0,150 150,285 285,530 820,1220 1840,2240
reverse of this,| {} where
|我们从根节点开始，向下移动，

1030
00:26:26,390 --> 00:26:27,505
0,260 260,395 395,515 515,760 840,1115
we start the root, go

1031
00:26:27,505 --> 00:26:28,510
0,165 165,300 300,420 420,695 745,1005
down| until we find the
|直到我们找到我们想要删除的条目，

1032
00:26:28,510 --> 00:26:31,225
0,165 165,405 405,645 645,1040 2410,2715
leaf node where entry, the

1033
00:26:31,225 --> 00:26:32,335
0,165 165,375 375,635 715,960 960,1110
entry {we,want,remove -},| if it's
|如果它不在那里，我们不会做任何事情，

1034
00:26:32,335 --> 00:26:33,220
0,150 150,390 390,615 615,750 750,885
not there, then we don't

1035
00:26:33,220 --> 00:26:35,005
0,150 150,470 790,1190 1270,1545 1545,1785
do anything,| because we can't
|因为我们不能删除不存在的键，

1036
00:26:35,005 --> 00:26:35,650
0,120 120,195 195,300 300,420 420,645
delete a key that doesn't

1037
00:26:35,650 --> 00:26:37,480
0,290
exist,|
|

1038
00:26:37,690 --> 00:26:38,640
0,275 275,380 380,515 515,770 770,950
if it is there, then
如果它在那里，那么我们继续并删除它，

1039
00:26:38,640 --> 00:26:39,210
0,75 75,195 195,300 300,420 420,570
we go ahead and delete

1040
00:26:39,210 --> 00:26:41,130
0,260 340,630 630,900 900,1280 1600,1920
it,| so if the leaf
|如果我们刚刚修改的叶子节点至少有一半是满的，

1041
00:26:41,130 --> 00:26:42,285
0,270 270,375 375,495 495,990 990,1155
node we just modified is

1042
00:26:42,285 --> 00:26:43,845
0,120 120,300 300,540 540,875 1285,1560
at least half full,| then
|那么我们就完成了，

1043
00:26:43,845 --> 00:26:45,980
0,165 165,395 1375,1680 1680,1860 1860,2135
we're done,| we {pop,it} out
|我们抛出它，什么都不做，

1044
00:26:46,000 --> 00:26:47,000
0,245 245,320 320,485 485,680 680,1000
and we don't do anything,|
|

1045
00:26:47,320 --> 00:26:48,720
0,275 275,550 930,1175 1175,1280 1280,1400
but now, but if the
但如果删除键后的叶子节点低于我们的阈值，

1046
00:26:48,720 --> 00:26:49,770
0,165 165,465 465,645 645,915 915,1050
leaf node after deleting that

1047
00:26:49,770 --> 00:26:51,560
0,290 430,780 780,1065 1065,1275 1275,1790
key, goes below our threshold,

1048
00:26:52,160 --> 00:26:53,960
0,380 400,800 1150,1485 1485,1680 1680,1800
right,| M, {M/2-1 - -
|M/2-1 ，

1049
00:26:53,960 --> 00:26:55,775
0,105 105,255 255,560 1420,1695 1695,1815
- - -},| M is
|M 是每个节点的键的数量，

1050
00:26:55,775 --> 00:26:56,710
0,60 60,180 180,375 375,525 525,935
the {number,of} keys per node,|
|

1051
00:26:57,060 --> 00:26:58,540
0,350 350,560 560,710 710,845 845,1480
then we have to redistribute,|
那我们就得重新分配，|

1052
00:26:58,950 --> 00:27:00,005
0,260 260,425 425,605 605,845 845,1055
the first thing we try
我们尝试做的第一件事是重新分配，

1053
00:27:00,005 --> 00:27:00,970
0,60 60,105 105,210 210,690 690,965
to do is redistribute| meaning
|意味着跟随兄弟指针，

1054
00:27:01,290 --> 00:27:03,280
0,350 350,575 575,845 845,1300 1590,1990
follow the sibling pointers,| find
|找到与我们相同级别的另一个节点，

1055
00:27:03,330 --> 00:27:05,240
0,400 960,1310 1310,1670 1670,1790 1790,1910
a, another node at the

1056
00:27:05,240 --> 00:27:06,980
0,165 165,360 360,510 510,770 1360,1740
same level as us| and
|并获取它们的一个键，

1057
00:27:06,980 --> 00:27:08,080
0,300 300,480 480,585 585,765 765,1100
steal one of their keys,|
|

1058
00:27:08,280 --> 00:27:09,020
0,260 260,365 365,485 485,620 620,740
like, as long as they
比如，只要他们不会变得不平衡，那就没问题，

1059
00:27:09,020 --> 00:27:10,540
0,195 195,315 315,855 855,1215 1215,1520
don't become unbalanced, that's okay,|
|

1060
00:27:10,860 --> 00:27:11,765
0,245 245,395 395,560 560,710 710,905
we may have to tweak
我们可能不得不在父节点上方进行调整，

1061
00:27:11,765 --> 00:27:14,230
0,165 165,485 1495,1755 1755,1950 1950,2465
up above the parent node,|
|

1062
00:27:14,660 --> 00:27:16,325
0,350 790,1035 1035,1140 1140,1305 1305,1665
{} in the parent node,
在父节点中，路标，分割点，

1063
00:27:16,325 --> 00:27:17,930
0,335 475,870 870,1185 1185,1470 1470,1605
the the {guideposts -}, the

1064
00:27:17,930 --> 00:27:21,035
0,165 165,440 1540,1815 1815,1935 1935,3105
split point,| but again, that's's
|但同样，这并不昂贵，

1065
00:27:21,035 --> 00:27:22,205
0,120 120,315 315,635 835,1080 1080,1170
not that expensive,| because we
|因为我们已经有了它的 latch ，

1066
00:27:22,205 --> 00:27:22,835
0,105 105,225 225,345 345,450 450,630
would already have the latch

1067
00:27:22,835 --> 00:27:23,820
0,150 150,395
for it,|
|

1068
00:27:24,510 --> 00:27:26,330
0,245 245,365 365,530 530,820 1560,1820
we cover next time.| If
我们下一次会讲到。|如果我们不能重新分配，

1069
00:27:26,330 --> 00:27:27,905
0,150 150,405 405,1040 1180,1455 1455,1575
we can't redistribute,| then we
|那么我们必须将 L 与其兄弟项之一合并，

1070
00:27:27,905 --> 00:27:29,045
0,120 120,270 270,600 600,855 855,1140
had to merge L with

1071
00:27:29,045 --> 00:27:30,890
0,165 165,240 240,360 360,845 1405,1845
one of its siblings,| combine
|将这两个的键组合在一起，

1072
00:27:30,890 --> 00:27:31,820
0,225 225,405 405,615 615,795 795,930
those two keys, put it

1073
00:27:31,820 --> 00:27:33,470
0,290 520,780 780,990 990,1340 1390,1650
together| and then update the
|然后相应地更新父节点。

1074
00:27:33,470 --> 00:27:35,750
0,240 240,830 1000,1400 1870,2145 2145,2280
parent accordingly, right.| And again,
|再次，这是递归的，

1075
00:27:35,750 --> 00:27:37,180
0,255 255,525 525,1020 1020,1170 1170,1430
this is recursive,| so if
|所以如果我将两个节点合并在一起，

1076
00:27:38,010 --> 00:27:39,340
0,400
I

1077
00:27:39,410 --> 00:27:41,010
0,500 500,785 785,1040 1040,1295 1295,1600
merge two, two nodes together|
|

1078
00:27:41,300 --> 00:27:42,415
0,275 275,395 395,560 560,860 860,1115
and then I delete a
然后我删除一个父节点上的路标键，

1079
00:27:42,415 --> 00:27:43,570
0,465 465,645 645,750 750,900 900,1155
guidepost key at my parent|
|

1080
00:27:43,570 --> 00:27:44,395
0,210 210,345 345,495 495,675 675,825
and now the parent is
现在父节点不到一半满了，

1081
00:27:44,395 --> 00:27:45,990
0,120 120,255 255,435 435,755 1195,1595
less than half full,| then
|然后合并将层叠向上。

1082
00:27:46,580 --> 00:27:47,760
0,290 290,515 515,620 620,920 920,1180
the merge will cascade up.|
|

1083
00:27:50,050 --> 00:27:51,045
0,245 245,320 320,455 455,740 740,995
What does it feel,| like
如果它，|如果我有两个键，

1084
00:27:51,045 --> 00:27:53,700
0,135 135,395 865,1265
if I, if

1085
00:27:54,870 --> 00:27:55,835
0,290 290,470 470,635 635,815 815,965
I have two keys,| you
|你有一个键，

1086
00:27:55,835 --> 00:27:56,630
0,105 105,270 270,480 480,645 645,795
have one key| and you're
|你是我的兄弟节点，

1087
00:27:56,630 --> 00:27:57,935
0,135 135,315 315,405 405,830 970,1305
my, you're my sibling,| I
|我删除了一个键，

1088
00:27:57,935 --> 00:27:58,865
0,195 195,345 345,615 615,840 840,930
delete a key| and I
|我不到一半满了，

1089
00:27:58,865 --> 00:28:00,305
0,135 135,285 285,450 450,755 1165,1440
less than half full,| that's
|这是个坏例子，

1090
00:28:00,305 --> 00:28:01,330
0,45 45,180 180,450 450,675 675,1025
a bad example,| because there's
|因为有三个键，

1091
00:28:01,350 --> 00:28:03,650
0,320 320,515 515,790 1050,1450 2040,2300
say three keys, right,| if
|如果你有两个键，

1092
00:28:03,650 --> 00:28:04,715
0,105 105,240 240,420 420,710 820,1065
you have two keys| and
|我有两个键，

1093
00:28:04,715 --> 00:28:06,050
0,90 90,195 195,345 345,635 985,1335
I have two keys,| I
|我删除一个键，

1094
00:28:06,050 --> 00:28:07,055
0,195 195,315 315,570 570,900 900,1005
delete a key,| I'm like
|我就像，哦，我没有一半满，

1095
00:28:07,055 --> 00:28:07,865
0,180 180,420 420,525 525,645 645,810
oh, I'm less than half

1096
00:28:07,865 --> 00:28:08,750
0,255 255,450 450,555 555,720 720,885
full| and I go try
|我想拿走你的一个键，

1097
00:28:08,750 --> 00:28:09,500
0,135 135,330 330,495 495,585 585,750
to steal one of your

1098
00:28:09,500 --> 00:28:10,625
0,300 300,675 675,900 900,1005 1005,1125
keys,| but if I do
|但如果我这么做了，

1099
00:28:10,625 --> 00:28:11,390
0,120 120,255 255,420 420,585 585,765
that to you,| then you're
|你就没一半满了，

1100
00:28:11,390 --> 00:28:12,350
0,105 105,240 240,390 390,680 730,960
less than half full,| so
|所以我不能。

1101
00:28:12,350 --> 00:28:13,320
0,90 90,500
I can't.|
|

1102
00:28:15,380 --> 00:28:16,100
0,240 240,375 375,480 480,630 630,720
All right, so let's go
好的，让我们回到我们的 demo 。

1103
00:28:16,100 --> 00:28:17,520
0,150 150,255 255,345 345,620
back to our demo.|
|

1104
00:28:18,940 --> 00:28:20,880
0,400 420,820
{All,right}, so,|
好的，所以，|

1105
00:28:21,930 --> 00:28:22,520
0,230 230,305 305,395 395,470 470,590
we can go ahead and
我们可以继续并删除，

1106
00:28:22,520 --> 00:28:23,360
0,225 225,405 405,600 600,720 720,840
delete,| so let's go ahead
|所以让我们继续并删除 8 ，

1107
00:28:23,360 --> 00:28:25,180
0,150 150,440 580,980
and delete 8,|
|

1108
00:28:25,620 --> 00:28:26,630
0,335 335,545 545,680 680,830 830,1010
8 at the far end
8 在这里最远的一端，

1109
00:28:26,630 --> 00:28:29,470
0,290 1300,1545 1545,1665 1665,1940 2440,2840
here,| it was 8, sorry,|
|它是 6 ，抱歉，

1110
00:28:31,570 --> 00:28:33,060
0,400
6,
6 ，在这里，删除 6 ，

1111
00:28:33,060 --> 00:28:34,485
0,290 550,825 825,960 960,1155 1155,1425
right, goes over here, delete

1112
00:28:34,485 --> 00:28:36,060
0,335 505,915 915,1140 1140,1425 1425,1575
6,| that's fine, we're still
|这是好的，我们仍然是平衡的，

1113
00:28:36,060 --> 00:28:38,835
0,290 640,1050 1050,1245 1245,1550 2470,2775
balanced,| it's two keys, two
|每个节点两个键，仍然是半满的，

1114
00:28:38,835 --> 00:28:41,865
0,255 255,495 495,995 1165,1565 2785,3030
keys per node, {still,half,full},| in
|在这种情况下，是 1 ，

1115
00:28:41,865 --> 00:28:43,815
0,120 120,345 345,695 1585,1845 1845,1950
this case, 1,| we can
|我们可以去 4 阶，它看起来更好，

1116
00:28:43,815 --> 00:28:44,490
0,180 180,345 345,420 420,525 525,675
go, we can go to

1117
00:28:44,490 --> 00:28:46,730
0,290 1090,1490 1570,1845 1845,1980 1980,2240
degree 4, that look better,|
|

1118
00:28:46,840 --> 00:28:47,775
0,260 260,380 380,500 500,695 695,935
but now I say I
但现在说我要删除中间的键 4 ，

1119
00:28:47,775 --> 00:28:48,720
0,225 225,480 480,705 705,840 840,945
delete key 4 in the

1120
00:28:48,720 --> 00:28:49,640
0,260
middle,

1121
00:28:52,020 --> 00:28:54,785
0,400 810,1115 1115,1420 2100,2600 2600,2765
right,| it basically propagates up
|它基本上向上传播，并将其从上方移除。

1122
00:28:54,785 --> 00:28:55,930
0,165 165,360 360,480 480,750 750,1145
and removes it from above.|
|

1123
00:28:56,760 --> 00:28:57,650
0,230 230,395 395,485 485,635 635,890
So let's go to degree
所以让我们来看看 4 阶，

1124
00:28:57,650 --> 00:28:58,490
0,315 315,525 525,630 630,735 735,840
4,| because then you can
|因为这样你就可以更好地看到偷取行为。

1125
00:28:58,490 --> 00:28:59,890
0,180 180,495 495,825 825,1140 1140,1400
start seeing the stealing better.|
|

1126
00:29:00,600 --> 00:29:01,325
0,230 230,395 395,485 485,590 590,725
So let's do the same
所以让我们做同样的事情来插入 1 ，

1127
00:29:01,325 --> 00:29:03,540
0,255 255,570 570,960 960,1265
thing to insert 1,|
|

1128
00:29:04,080 --> 00:29:05,580
0,320 320,640
insert 2,
插入 2 4 5 ，

1129
00:29:07,060 --> 00:29:08,460
0,400
{4}

1130
00:29:10,270 --> 00:29:11,760
0,400
{5},|
|

1131
00:29:11,860 --> 00:29:12,860
0,335 335,530 530,620 620,725 725,1000
split, now we got there,|
分裂，现在我们到了这里，|

1132
00:29:14,410 --> 00:29:15,700
0,400
{6}
6 8 ，

1133
00:29:17,490 --> 00:29:19,000
0,400
{8},|
|

1134
00:29:24,110 --> 00:29:25,200
0,245 245,455 455,695 695,830 830,1090
and then we do 9.|
然后我们插入 9 。|

1135
00:29:29,030 --> 00:29:29,515
0,230 230,290 290,335 335,395 395,485
So we're going to go
所以，我们将继续，删除这里中间的 5 ，

1136
00:29:29,515 --> 00:29:30,720
0,90 90,210 210,485
ahead and delete

1137
00:29:31,210 --> 00:29:32,270
0,320 320,470 470,545 545,725 725,1060
5 in the middle here,|
|

1138
00:29:33,040 --> 00:29:34,525
0,195 195,500 880,1155 1155,1320 1320,1485
and again, at this point
再次，在这里，

1139
00:29:34,525 --> 00:29:35,815
0,275 325,645 645,975 975,1140 1140,1290
here,| this node, this leaf
|这个叶子节点将变得不到一半满，

1140
00:29:35,815 --> 00:29:36,610
0,120 120,270 270,480 480,660 660,795
node will become less than

1141
00:29:36,610 --> 00:29:38,185
0,165 165,470 790,1170 1170,1425 1425,1575
half full,| so the first
|所以我们要做的第一件事就是，

1142
00:29:38,185 --> 00:29:38,770
0,120 120,285 285,420 420,495 495,585
thing we try to do

1143
00:29:38,770 --> 00:29:39,685
0,120 120,225 225,360 360,585 585,915
is| try to steal from,
|试着从它的兄弟节点那里偷取，

1144
00:29:39,685 --> 00:29:43,270
0,395 1945,2205 2205,2355 2355,2795 3355,3585
from when its siblings,| so
|所以，让我们继续并删除 5 ，

1145
00:29:43,270 --> 00:29:43,915
0,165 165,270 270,375 375,480 480,645
let's go ahead and delete

1146
00:29:43,915 --> 00:29:45,000
0,305
5,|
|

1147
00:29:49,040 --> 00:29:52,240
0,335 335,455 455,730
didn't do that,|
没有那么做，|

1148
00:29:54,640 --> 00:29:55,980
0,290 290,580
why not?|
为什么不是？|

1149
00:29:58,210 --> 00:30:00,240
0,400
Yeah.|
是的。|

1150
00:30:01,010 --> 00:30:02,005
0,275 275,455 455,680 680,845 845,995
{What,is} that. { - -}|
是什么？|

1151
00:30:02,005 --> 00:30:03,280
0,120 120,365

1152
00:30:03,560 --> 00:30:04,270
0,305 305,455 455,530 530,635 635,710
Yeah, I think it's a
是的，我想是 4 ，

1153
00:30:04,270 --> 00:30:06,130
0,260 700,930 930,1035 1035,1230 1230,1860
4,| so I delete 4,
|所以我删除 4 ，看看它是怎么做的，

1154
00:30:06,130 --> 00:30:07,440
0,75 75,150 150,225 225,470 910,1310
see what it does,| yeah,
|是的，那里有偷取。

1155
00:30:07,610 --> 00:30:09,140
0,605 605,970
there steals.|
|

1156
00:30:09,180 --> 00:30:10,400
0,320 320,470 470,560 560,920 920,1220
Yeah, so this animation doesn't
是的，所以这个动画并不是完全按照教科书，

1157
00:30:10,400 --> 00:30:13,865
0,150 150,300 300,660 660,1010 3220,3465
follow the textbook exactly,| but
|但它是没有错的，

1158
00:30:13,865 --> 00:30:14,810
0,135 135,345 345,465 465,645 645,945
like, it's, it's not wrong,|
|

1159
00:30:14,810 --> 00:30:15,635
0,240 240,330 330,465 465,645 645,825
it's just like different ways
这就像是做事情的不同方式，

1160
00:30:15,635 --> 00:30:17,030
0,105 105,210 210,485 505,905 1135,1395
to do things,| like, you
|就像，你想在某些优化上有多积极，

1161
00:30:17,030 --> 00:30:18,140
0,255 255,600 600,870 870,1035 1035,1110
know, how aggressive you want

1162
00:30:18,140 --> 00:30:19,420
0,75 75,210 210,465 465,780 780,1280
to be on certain optimizations,|
|

1163
00:30:19,950 --> 00:30:20,915
0,400 480,725 725,815 815,890 890,965
but as long as you
但是你得到了高层次想法，你可以偷取。

1164
00:30:20,915 --> 00:30:21,500
0,75 75,135 135,240 240,420 420,585
get the high level idea,

1165
00:30:21,500 --> 00:30:22,880
0,120 120,270 270,480 480,800
that you could steal.|
|

1166
00:30:22,950 --> 00:30:24,180
0,400

1167
00:30:24,180 --> 00:30:24,690
0,120 120,210 210,300 300,375 375,510
But you still have to
但当你偷取时，你仍然必须更新父节点，

1168
00:30:24,690 --> 00:30:25,455
0,150 150,270 270,465 465,645 645,765
update the parent, when you

1169
00:30:25,455 --> 00:30:26,355
0,165 165,435 435,750 750,825 825,900
steal,| because that's going to
|因为这将更改边界点。

1170
00:30:26,355 --> 00:30:27,900
0,135 135,270 270,555 555,815
change the boundary points.|
|

1171
00:30:28,240 --> 00:30:29,925
0,400 780,1115 1115,1265 1265,1430 1430,1685
Yes. { - - -}|
是的。|

1172
00:30:29,925 --> 00:30:31,515
0,255 255,515 535,1170 1170,1425 1425,1590

1173
00:30:31,515 --> 00:30:32,760
0,225 225,510 510,755

1174
00:30:36,550 --> 00:30:37,650
0,260 260,440 440,680 680,935 935,1100
In this example here,| they
在这个例中，|它们有单向的同级指针，

1175
00:30:37,650 --> 00:30:38,990
0,105 105,570 570,765 765,1020 1020,1340
have siblinginters going one direction,|
|

1176
00:30:39,670 --> 00:30:41,130
0,590 590,815 815,965 965,1235 1235,1460
Postgres and other systems go
Postgres 和其他系统有双向的链表。

1177
00:30:41,130 --> 00:30:42,650
0,120 120,285 285,590 970,1245 1245,1520
in both directions, {double,linked} list.|
|

1178
00:30:46,230 --> 00:30:47,645
0,400 720,950 950,1040 1040,1160 1160,1415
Yes. { - - -}|
是的。|

1179
00:30:47,645 --> 00:30:49,280
0,545 625,885 885,1305 1305,1470 1470,1635

1180
00:30:49,280 --> 00:30:50,105
0,135 135,330 330,585 585,750 750,825

1181
00:30:50,105 --> 00:30:51,575
0,180 180,420 420,795 795,1185 1185,1470

1182
00:30:51,575 --> 00:30:53,500
0,240 240,545 1165,1440 1440,1620 1620,1925

1183
00:30:53,640 --> 00:30:55,480
0,245 245,350 350,500 500,790
Yeah, his question is,|
是的，他的问题是，|

1184
00:30:56,150 --> 00:30:57,415
0,215 215,380 380,730 750,1070 1070,1265
actually, I had an example
事实上，我有一个这样的例子，

1185
00:30:57,415 --> 00:30:58,420
0,120 120,365
of that,|
|

1186
00:31:02,485 --> 00:31:03,980
0,75 75,135 135,240 240,515
actually, that's a question,|
有个问题，|

1187
00:31:05,830 --> 00:31:06,630
0,335 335,515 515,635 635,680 680,800
actually, I don't have an
实际上，我没有这样的例子，

1188
00:31:06,630 --> 00:31:07,365
0,165 165,270 270,465 465,645 645,735
example of that,| well, I
|好的，我知道我在这中间做的，

1189
00:31:07,365 --> 00:31:08,070
0,120 120,210 210,420 420,630 630,705
know I do in the

1190
00:31:08,070 --> 00:31:10,520
0,135 135,440
middle here,|
|

1191
00:31:10,520 --> 00:31:12,065
0,165 165,470 730,1095 1095,1380 1380,1545
these guys,| I, yeah, so
这些家伙，|是的，所以我认为叶子节点，

1192
00:31:12,065 --> 00:31:13,370
0,240 240,630 630,885 885,1050 1050,1305
I think the leaf nodes,|
|

1193
00:31:13,370 --> 00:31:14,740
0,120 120,330 330,615 615,1035 1035,1370
you definitely want pointers to
你肯定想要指针指向你的兄弟节点，

1194
00:31:15,090 --> 00:31:16,175
0,275 275,560 560,755 755,950 950,1085
your siblings along this,| because
|因为你需要沿着叶子节点前进，

1195
00:31:16,175 --> 00:31:18,185
0,245 835,1110 1110,1385 1495,1800 1800,2010
you need to go along

1196
00:31:18,185 --> 00:31:20,345
0,180 180,345 345,785 1705,1980 1980,2160
the leaf nodes,| if this
|如果这家伙变得更大了，

1197
00:31:20,345 --> 00:31:22,160
0,225 225,480 480,815 1375,1620 1620,1815
guy had like, you know,

1198
00:31:22,160 --> 00:31:23,140
0,240 240,390 390,510 510,675 675,980
this thing got even bigger,|
|

1199
00:31:23,580 --> 00:31:25,210
0,245 245,365 365,640 1050,1340 1340,1630
could you have two parents,|
你能有两个父节点吗，|

1200
00:31:25,290 --> 00:31:26,870
0,275 275,425 425,605 605,910 1320,1580
could two, {} two, two
两个同一级别上的节点必须指着对方，

1201
00:31:26,870 --> 00:31:27,575
0,150 150,270 270,345 345,465 465,705
nodes at the same level

1202
00:31:27,575 --> 00:31:28,340
0,270 270,465 465,570 570,630 630,765
had pointed to each other|
|

1203
00:31:28,340 --> 00:31:29,075
0,150 150,255 255,390 390,585 585,735
even though they was, you
即使它们有相同的父节点，

1204
00:31:29,075 --> 00:31:29,800
0,105 105,210 210,300 300,435 435,725
know, have the same parent,|
|

1205
00:31:30,510 --> 00:31:31,685
0,305 305,605 605,845 845,995 995,1175
you could, I don't know,|
你可以，我不知道，|

1206
00:31:31,685 --> 00:31:32,375
0,330 330,420 420,555 555,615 615,690
actually, I don't know what
事实上，我不知道 Postgres 做了什么或其他系统做了什么。

1207
00:31:32,375 --> 00:31:33,380
0,255 255,420 420,555 555,690 690,1005
Postgres does or other systems

1208
00:31:33,380 --> 00:31:34,160
0,260
do.|
|

1209
00:31:37,440 --> 00:31:38,420
0,350 350,470 470,635 635,800 800,980

1210
00:31:38,420 --> 00:31:39,160
0,120 120,315 315,690

1211
00:31:40,460 --> 00:31:41,760
0,165 165,315 315,555 555,890

1212
00:31:42,120 --> 00:31:43,100
0,230 230,320 320,545 545,800 800,980
To this point, you may
在这一点上，你可能不会，

1213
00:31:43,100 --> 00:31:44,560
0,290
not,|
|

1214
00:31:44,560 --> 00:31:45,595
0,290 430,690 690,795 795,915 915,1035
so if you had the
所以，如果你有相同的父节点，还是。

1215
00:31:45,595 --> 00:31:47,280
0,135 135,360 360,695 1075,1380 1380,1685
same parent, or. { -}|
|

1216
00:31:48,080 --> 00:31:49,060
0,260 260,455 455,790

1217
00:31:49,060 --> 00:31:49,600
0,60 60,225 225,345 345,450 450,540

1218
00:31:49,600 --> 00:31:50,320
0,105 105,270 270,690

1219
00:31:50,320 --> 00:31:51,145
0,165 165,270 270,360 360,480 480,825

1220
00:31:51,145 --> 00:31:51,960
0,240 240,605

1221
00:31:52,620 --> 00:31:53,900
0,400 630,875 875,1010 1010,1145 1145,1280
Everyone comes up to the
每个节点都来自根节点，就像，

1222
00:31:53,900 --> 00:31:56,640
0,290 1390,1635 1635,1880
root, {} like,|
|

1223
00:31:58,440 --> 00:31:59,105
0,260 260,380 380,470 470,545 545,665
it may be a case
这可能是一个，你必须重新组织一切，

1224
00:31:59,105 --> 00:32:00,545
0,105 105,195 195,285 285,515 775,1440
you have to, like, reorganize

1225
00:32:00,545 --> 00:32:02,675
0,395 505,905 1195,1575 1575,1890 1890,2130
everything, right,| so that may
|所以这可能会有帮助，

1226
00:32:02,675 --> 00:32:03,410
0,210 210,345 345,435 435,585 585,735
help,| but at that point,
|但在这一点上，你在锁住整棵树，谁在乎呢？

1227
00:32:03,410 --> 00:32:04,640
0,405 405,720 720,825 825,990 990,1230
you're latching the whole tree,

1228
00:32:04,640 --> 00:32:06,000
0,165 165,285 285,770
so who cares?|
|

1229
00:32:06,790 --> 00:32:08,340
0,400

1230
00:32:08,430 --> 00:32:10,130
0,400 900,1160 1160,1295 1295,1415 1415,1700
Yes. { - - -}|
是的。|

1231
00:32:10,130 --> 00:32:11,495
0,240 240,450 450,740 760,1215 1215,1365

1232
00:32:11,495 --> 00:32:12,485
0,105 105,240 240,465 465,705 705,990

1233
00:32:12,485 --> 00:32:13,040
0,300 300,525

1234
00:32:14,050 --> 00:32:15,105
0,260 260,425 425,695 695,920 920,1055
This question is,| if you
这个问题是，|如果你不存储指向父节点的指针，

1235
00:32:15,105 --> 00:32:17,010
0,425 1015,1260 1260,1350 1350,1665 1665,1905
don't, if you don't store

1236
00:32:17,010 --> 00:32:17,895
0,195 195,465 465,555 555,660 660,885
a pointer to the parent,|
|

1237
00:32:17,895 --> 00:32:18,525
0,210 210,285 285,375 375,510 510,630
how do you send data
如何将数据发送到父节点？

1238
00:32:18,525 --> 00:32:19,720
0,90 90,180 180,425
to the parent.|
|

1239
00:32:19,820 --> 00:32:20,740
0,260 260,425 425,605 605,755 755,920
We will discuss this next
我们将在下一节课中讨论，

1240
00:32:20,740 --> 00:32:22,810
0,290 400,800 1210,1590 1590,1875 1875,2070
class,| because basically, as you're
|因为基本上，当你向下时，

1241
00:32:22,810 --> 00:32:23,845
0,165 165,435 435,630 630,810 810,1035
going down,| you keep track
|你将跟踪你在向下时访问的节点堆栈，

1242
00:32:23,845 --> 00:32:25,210
0,165 165,375 375,630 630,935 1075,1365
of the stack of the

1243
00:32:25,210 --> 00:32:26,065
0,255 255,360 360,570 570,765 765,855
nodes you visit as you

1244
00:32:26,065 --> 00:32:27,220
0,120 120,395 595,855 855,990 990,1155
go down,| and you keep
|并跟踪你为哪些节点设置了 latch ，

1245
00:32:27,220 --> 00:32:28,045
0,165 165,330 330,525 525,705 705,825
track of which ones you

1246
00:32:28,045 --> 00:32:29,440
0,105 105,240 240,480 480,815
had the latch for,|
|

1247
00:32:29,480 --> 00:32:30,660
0,350 350,575 575,710 710,875 875,1180
so I can go down,|
如果我向下，|

1248
00:32:31,190 --> 00:32:33,210
0,260 260,500 500,1000 1050,1450 1620,2020
if I'm traversing down here,|
如果我从这里向下，|

1249
00:32:34,170 --> 00:32:35,410
0,275 275,515 515,770 770,950 950,1240
and say this guy here,
然后比如这个家伙，我必须分裂，

1250
00:32:35,460 --> 00:32:36,875
0,290 290,470 470,760 900,1160 1160,1415
I have to, I gotta

1251
00:32:36,875 --> 00:32:38,420
0,395
split,|
|

1252
00:32:38,460 --> 00:32:39,575
0,290 290,515 515,740 740,920 920,1115
when I, when I come
当我下来的时候，到了这里，

1253
00:32:39,575 --> 00:32:41,525
0,305 805,1205 1345,1620 1620,1770 1770,1950
down, {} and get here,|
|

1254
00:32:41,525 --> 00:32:42,620
0,165 165,285 285,545 565,870 870,1095
I would recognize,| hey, I'm
我就会意识到，|嘿，我要分裂了，

1255
00:32:42,620 --> 00:32:44,030
0,90 90,210 210,405 405,740 1000,1410
gonna have to split,| don't
|不要释放我的父节点的 latch ，

1256
00:32:44,030 --> 00:32:44,825
0,180 180,330 330,525 525,660 660,795
release the latch of my

1257
00:32:44,825 --> 00:32:45,665
0,300 300,525 525,630 630,750 750,840
parent,| so I still have
|所以我还有一个指针，

1258
00:32:45,665 --> 00:32:46,820
0,135 135,600 600,870 870,1020 1020,1155
a pointer,| I still have
|我还把它放在我的堆栈上，

1259
00:32:46,820 --> 00:32:47,450
0,90 90,165 165,315 315,510 510,630
it on my stack,| I
|我可以回去看看。

1260
00:32:47,450 --> 00:32:48,720
0,75 75,180 180,330 330,620
can get back to.|
|

1261
00:32:48,720 --> 00:32:49,845
0,180 180,345 345,480 480,690 690,1125
So it's the internal bookkeeping
所以，这是 worker 的内部[簿记]，

1262
00:32:49,845 --> 00:32:50,505
0,90 90,180 180,360 360,555 555,660
of the worker| as it
|当它沿着树向下。

1263
00:32:50,505 --> 00:32:52,040
0,135 135,300 300,450 450,845 1135,1535
goes down the threads or

1264
00:32:52,150 --> 00:32:53,560
0,275 275,425 425,575 575,850
goes down the tree.|
|

1265
00:32:56,320 --> 00:32:57,940
0,320 320,640
Yes, again.|
是的，再次。|

1266
00:32:58,090 --> 00:32:59,910
0,350 350,700 1350,1640 1640,1730 1730,1820
And so we'll talk about
所以我们将谈论它意味着更安全，更不安全，

1267
00:32:59,910 --> 00:33:01,170
0,60 60,180 180,420 420,840 840,1260
it means be safer, unsafe,

1268
00:33:01,170 --> 00:33:03,200
0,500 580,930 930,1230 1230,1580 1630,2030
traversals,| like, you know, like,
|比如，当你往下的时候，你会知道，

1269
00:33:03,940 --> 00:33:05,060
0,275 275,410 410,545 545,770 770,1120
as you go down, if

1270
00:33:05,320 --> 00:33:06,690
0,245 245,365 365,635 635,1085 1085,1370
you would know,| I'm, I'm
|我在试着删除一些东西，

1271
00:33:06,690 --> 00:33:08,055
0,105 105,255 255,465 465,770 1120,1365
trying to delete something,| so
|所以当我往下时，

1272
00:33:08,055 --> 00:33:08,895
0,150 150,315 315,465 465,675 675,840
as I go down,| if
|如果我知道，不管如何，

1273
00:33:08,895 --> 00:33:09,975
0,165 165,420 420,660 660,825 825,1080
I know that no matter

1274
00:33:09,975 --> 00:33:10,875
0,270 270,390 390,555 555,765 765,900
whether or not,| the key
|我下面的键 m ，不管它在哪里，

1275
00:33:10,875 --> 00:33:12,200
0,120 120,360 360,645 645,945 945,1325
m need need below me,

1276
00:33:12,730 --> 00:33:13,845
0,380 380,725 725,860 860,965 965,1115
whether it's there or not,|
|

1277
00:33:13,845 --> 00:33:15,555
0,210 210,420 420,725 955,1355 1405,1710
I know that, there I
我知道我不需要对这个节点进行合并或拆分，

1278
00:33:15,555 --> 00:33:16,410
0,300 300,435 435,585 585,705 705,855
won't have to do a

1279
00:33:16,410 --> 00:33:18,270
0,590 850,1215 1215,1500 1500,1695 1695,1860
merge or split on this

1280
00:33:18,270 --> 00:33:18,750
0,120 120,180 180,285 285,360 360,480
node,| what I'm at right
|我所在的节点，

1281
00:33:18,750 --> 00:33:19,890
0,260 400,675 675,825 825,975 975,1140
now,| so once I go
|所以一旦我过了它，我可以释放它的 latch ，

1282
00:33:19,890 --> 00:33:20,760
0,195 195,360 360,495 495,735 735,870
past it, I don't. I

1283
00:33:20,760 --> 00:33:21,450
0,135 135,270 270,375 375,540 540,690
can release the latch on

1284
00:33:21,450 --> 00:33:22,890
0,260 310,570 570,840 840,1110 1110,1440
it,| could it's considered safe,
|它被认为是安全的，它不会，

1285
00:33:22,890 --> 00:33:24,105
0,225 225,590 640,885 885,1035 1035,1215
it won't,| No matter what
|不管你下面发生什么，

1286
00:33:24,105 --> 00:33:25,605
0,195 195,510 510,905 985,1380 1380,1500
happens below you,| it'll never
|它永远不会重新组织，

1287
00:33:25,605 --> 00:33:26,820
0,135 135,665 745,990 990,1080 1080,1215
get reorganized,| so you don't
|所以你不需要保留最后一个[字]。

1288
00:33:26,820 --> 00:33:27,480
0,90 90,180 180,345 345,510 510,660
need to maintain the last

1289
00:33:27,480 --> 00:33:28,080
0,320
[word].|
|

1290
00:33:28,210 --> 00:33:29,150
0,260 260,380 380,515 515,665 665,940
That will cover next class.|
这将在下一节课中讲到。|

1291
00:33:33,310 --> 00:33:34,420
0,400

1292
00:33:38,010 --> 00:33:38,915
0,275 275,395 395,575 575,665 665,905
{All,right}, so that's the basic
好的，这就是分裂、合并的基本操作，

1293
00:33:38,915 --> 00:33:42,485
0,345 345,695 1285,1620 1620,2075 3325,3570
operations for splits emerges,| so
|所以 B+ 树，

1294
00:33:42,485 --> 00:33:44,045
0,90 90,225 225,420 420,725 1285,1560
the {B+ -} tree,| just
|只是一般的树，

1295
00:33:44,045 --> 00:33:45,305
0,150 150,315 315,605 865,1125 1125,1260
trees in general,| {B+ -}
|在数据库中， B+ 树，

1296
00:33:45,305 --> 00:33:46,175
0,150 150,285 285,405 405,585 585,870
tree from {B+ -} in,

1297
00:33:46,175 --> 00:33:48,050
0,330 330,995 1285,1560 1560,1710 1710,1875
in databases| is gonna have
|将会有一堆其他的东西，

1298
00:33:48,050 --> 00:33:48,800
0,180 180,345 345,540 540,690 690,750
a bunch of, do a

1299
00:33:48,800 --> 00:33:49,520
0,90 90,180 180,345 345,570 570,720
bunch of other stuff,| we
|我们不能用哈希表。

1300
00:33:49,520 --> 00:33:50,660
0,225 225,540 540,780 780,1050 1050,1140
can we, we couldn't be

1301
00:33:50,660 --> 00:33:52,025
0,180 180,405 405,630 630,890 1120,1365
able, we couldn't do with

1302
00:33:52,025 --> 00:33:53,340
0,105 105,360 360,635
a hash table.|
|

1303
00:33:53,520 --> 00:33:54,950
0,400 480,770 770,1070 1070,1250 1250,1430
So a hash table, the
所以哈希表，我们唯一能做的操作就是，

1304
00:33:54,950 --> 00:33:56,405
0,260 640,975 975,1170 1170,1290 1290,1455
only operation we could do

1305
00:33:56,405 --> 00:33:57,580
0,305
is,|
|

1306
00:33:58,150 --> 00:33:59,910
0,380 380,635 635,800 800,1090 1440,1760
something equals this key, right,|
某个东西等于这个键，|

1307
00:33:59,910 --> 00:34:00,825
0,195 195,345 345,495 495,630 630,915
is the, is the hash
哈希键是否等于我要找的键，

1308
00:34:00,825 --> 00:34:02,160
0,305 475,825 825,1020 1020,1185 1185,1335
key equal to my to

1309
00:34:02,160 --> 00:34:02,985
0,165 165,360 360,525 525,645 645,825
my key I'm looking up

1310
00:34:02,985 --> 00:34:04,440
0,275 685,960 960,1170 1170,1275 1275,1455
on,| we can't do less
|我们不能做小于，我们不能做大于，

1311
00:34:04,440 --> 00:34:05,400
0,255 255,450 450,645 645,750 750,960
than, we can't do greater

1312
00:34:05,400 --> 00:34:06,750
0,350 760,1005 1005,1110 1110,1290 1290,1350
than| and we can't do
|我们不能做任何部分键查找，

1313
00:34:06,750 --> 00:34:07,875
0,150 150,525 525,660 660,960 960,1125
any partial key lookup,| you
|你必须拥有完整的键。

1314
00:34:07,875 --> 00:34:08,595
0,90 90,165 165,255 255,435 435,720
have to have the entire

1315
00:34:08,595 --> 00:34:09,520
0,365
key,

1316
00:34:09,750 --> 00:34:10,580
0,275 275,365 365,410 410,575 575,830
right.| So if I say,|
|所以，如果我说，|

1317
00:34:10,580 --> 00:34:11,540
0,195 195,330 330,480 480,675 675,960
I build an index on
我在列 a b c 上构建索引，

1318
00:34:11,540 --> 00:34:13,220
0,375 375,495 495,645 645,920 1330,1680
columns a b c,| I
|如果对于我的键，我只有列 a 和 b ，

1319
00:34:13,220 --> 00:34:14,540
0,195 195,300 300,450 450,740 940,1320
if I only have columns

1320
00:34:14,540 --> 00:34:15,470
0,120 120,255 255,405 405,680 700,930
{} a and b, for

1321
00:34:15,470 --> 00:34:17,015
0,150 150,470 730,1020 1020,1290 1290,1545
my key,| I can't hash
|我不能哈希它并跳到任何有意义的地方，

1322
00:34:17,015 --> 00:34:18,065
0,165 165,330 330,525 525,810 810,1050
that and jump to anything

1323
00:34:18,065 --> 00:34:19,730
0,275 925,1200 1200,1320 1320,1425 1425,1665
meaningful, right,| because the hash
|因为哈希是完全随机的。

1324
00:34:19,730 --> 00:34:21,780
0,165 165,470 730,1130
is completely random.|
|

1325
00:34:21,820 --> 00:34:23,030
0,260 260,410 410,605 605,860 860,1210
But in {B+ -} tree,|
但是在 B+ 树中，|

1326
00:34:23,290 --> 00:34:23,955
0,260 260,365 365,455 455,545 545,665
we can do a bunch
我们可以做一系列的技巧，

1327
00:34:23,955 --> 00:34:25,580
0,150 150,435 435,725 1075,1350 1350,1625
of tricks,| where we can
|我们可能只拥有，或者不可能，

1328
00:34:26,020 --> 00:34:27,975
0,395 395,770 770,1100 1100,1450 1650,1955
potentially only have, or not

1329
00:34:27,975 --> 00:34:29,145
0,225 225,405 405,665 835,1080 1080,1170
potentially you can,| you can
|你只能拥有部分键，

1330
00:34:29,145 --> 00:34:30,105
0,180 180,435 435,675 675,840 840,960
only have parts of the

1331
00:34:30,105 --> 00:34:32,610
0,275 1165,1455 1455,1745 1975,2295 2295,2505
key| or a certain number
|或者基于你的键的特定数量的属性，

1332
00:34:32,610 --> 00:34:33,570
0,120 120,270 270,615 615,825 825,960
of the attributes, that your

1333
00:34:33,570 --> 00:34:34,785
0,135 135,255 255,435 435,740 880,1215
key is based on| and
|并且仍然将其用于查询。

1334
00:34:34,785 --> 00:34:36,890
0,335 595,870 870,1035 1035,1325 1525,2105
still use it for queries.|
|

1335
00:34:37,980 --> 00:34:39,080
0,245 245,410 410,725 725,980 980,1100
So again, say index on
再次，比如说 a b c 的索引，

1336
00:34:39,365 --> 00:34:41,135
0,275 835,1155 1155,1410 1410,1620 1620,1770
{a,b,c},| so obviously, I can
|所以很明显，我可以做 a=1 b=2 c=3 ，

1337
00:34:41,135 --> 00:34:43,625
0,275 895,1245 1245,1485 1485,1775 2215,2490
do {a=1 - -}, {b=2

1338
00:34:43,625 --> 00:34:44,390
0,150 150,300 300,450 450,600 600,765
- -} and {c=3 -

1339
00:34:44,390 --> 00:34:45,185
0,210 210,450 450,540 540,675 675,795
-},| that's the same thing
|这和哈希是一样的，

1340
00:34:45,185 --> 00:34:46,145
0,105 105,210 210,645 645,855 855,960
as the hashing,| I have
|我有[质量]匹配的所有键，

1341
00:34:46,145 --> 00:34:47,255
0,135 135,375 375,810 810,945 945,1110
the [quality] matching for all

1342
00:34:47,255 --> 00:34:48,485
0,165 165,300 300,575 865,1125 1125,1230
of the keys,| that are
|都在我的，索引所基于的。

1343
00:34:48,485 --> 00:34:49,560
0,135 135,425
in my,

1344
00:34:49,600 --> 00:34:50,505
0,290 290,455 455,620 620,785 785,905
that that the index is
|

1345
00:34:50,505 --> 00:34:51,990
0,150 150,455 865,1200 1200,1380 1380,1485
based on.| I also can
|我也可以做所谓的前缀搜索，

1346
00:34:51,990 --> 00:34:52,830
0,120 120,300 300,375 375,495 495,840
do what's called a prefix

1347
00:34:52,830 --> 00:34:54,510
0,320 640,1005 1005,1260 1260,1455 1455,1680
search,| where I only have
|我只有 a 和 b ，没有 c ，

1348
00:34:54,510 --> 00:34:55,725
0,210 210,390 390,675 675,945 945,1215
a and b and not

1349
00:34:55,725 --> 00:34:56,900
0,395
c,

1350
00:34:57,190 --> 00:34:58,890
0,380 380,760 1110,1385 1385,1535 1535,1700
right,| and we can do
|我们可以进行查找，

1351
00:34:58,890 --> 00:35:00,705
0,290 400,810 810,1020 1020,1340 1540,1815
the lookup| to define all
|定义所有匹配，基于 a 和 b ，而不包括 c 。

1352
00:35:00,705 --> 00:35:01,920
0,120 120,365 745,1020 1020,1140 1140,1215
the matches based on the

1353
00:35:01,920 --> 00:35:02,750
0,75 75,165 165,270 270,480 480,830
a and b without c.|
|

1354
00:35:03,720 --> 00:35:05,135
0,245 245,470 470,790 870,1160 1160,1415
But we'd also, not all
但我们也，不是所有的系统都这样做，

1355
00:35:05,135 --> 00:35:06,575
0,330 330,570 570,840 840,1170 1170,1440
systems do this,| because it's
|因为这样做更棘手，

1356
00:35:06,575 --> 00:35:07,610
0,240 240,330 330,575 685,900 900,1035
trickier to do,| but we
|但我们也可以做后缀搜索，

1357
00:35:07,610 --> 00:35:10,460
0,180 180,315 315,590
also can do

1358
00:35:10,560 --> 00:35:11,945
0,400 510,950 950,1115 1115,1265 1265,1385
a suffix look up,| where
|我们没有前缀，

1359
00:35:11,945 --> 00:35:12,905
0,105 105,285 285,375 375,510 510,960
we don't have the prefix,|
|

1360
00:35:12,905 --> 00:35:15,395
0,395 505,905 1015,1415 1915,2340 2340,2490
we have the suffix of
我们有键的后缀，

1361
00:35:15,395 --> 00:35:16,415
0,135 135,395 535,765 765,840 840,1020
the keys,| so I don't
|所以我没有 a ，但我有 b 和 c ，

1362
00:35:16,415 --> 00:35:17,630
0,180 180,515 745,990 990,1065 1065,1215
have a, but I have

1363
00:35:17,630 --> 00:35:18,860
0,180 180,375 375,710 880,1125 1125,1230
b and c| and I
|我仍然可以使用我的索引，进行查找，

1364
00:35:18,860 --> 00:35:20,000
0,240 240,585 585,825 825,960 960,1140
can potentially still use my

1365
00:35:20,000 --> 00:35:21,040
0,210 210,360 360,480 480,615 615,1040
index and do that lookup,|
|

1366
00:35:21,910 --> 00:35:23,055
0,335 335,545 545,770 770,995 995,1145
very few systems do this,
很少有系统做这个，这太难了，

1367
00:35:23,055 --> 00:35:24,165
0,135 135,270 270,480 480,855 855,1110
this is hard,| Postgres doesn't
|Postgres 没有这么做，

1368
00:35:24,165 --> 00:35:26,235
0,120 120,395 745,1145 1345,1920 1920,2070
do this,| the Oracle and
|Oracle ，我认为也许 SQL Server 可以做这个。

1369
00:35:26,235 --> 00:35:27,210
0,105 105,240 240,450 450,780 780,975
I think maybe SQL Server

1370
00:35:27,210 --> 00:35:28,400
0,165 165,270 270,530
can do this.|
|

1371
00:35:28,510 --> 00:35:30,135
0,400 1080,1340 1340,1475 1475,1565 1565,1625
{All,right}?| And again, if it
好的？|再次，如果它是哈希索引，

1372
00:35:30,135 --> 00:35:30,900
0,75 75,165 165,420 420,630 630,765
was a hash index,| we
|我们必须拥有整个键，

1373
00:35:30,900 --> 00:35:31,635
0,90 90,195 195,330 330,510 510,735
have to have the entire

1374
00:35:31,635 --> 00:35:33,270
0,335 715,1065 1065,1335 1335,1515 1515,1635
key| and it always has
|并且它必须始终在[质量谓词]中。

1375
00:35:33,270 --> 00:35:34,280
0,90 90,150 150,270 270,570 570,1010
to be in [quality predicate].|
|

1376
00:35:37,570 --> 00:35:39,435
0,400 750,1150 1350,1595 1595,1685 1685,1865
{} Yeah, because you basically
因为你基本上需要可能多个线程同时向下，

1377
00:35:39,435 --> 00:35:41,130
0,180 180,270 270,435 435,755 1375,1695
need to have like potentially

1378
00:35:41,130 --> 00:35:42,015
0,270 270,570 570,645 645,735 735,885
multiple threads at the same

1379
00:35:42,015 --> 00:35:44,145
0,225 225,450 450,755 775,1175 1765,2130
time going down| and everyone,
|每个线程协调，

1380
00:35:44,145 --> 00:35:45,380
0,255 255,665
everyone coordinating,|
|

1381
00:35:45,820 --> 00:35:46,905
0,290 290,485 485,620 620,740 740,1085
there might be a patent
Oracle 可能有一个专利，

1382
00:35:46,905 --> 00:35:47,865
0,135 135,525 525,630 630,750 750,960
from Oracle,| and that present
|禁止人们这样做，

1383
00:35:47,865 --> 00:35:49,320
0,225 225,375 375,555 555,875 1075,1455
people from doing this,| wouldn't
|不会让我感到惊讶，我不知道，

1384
00:35:49,320 --> 00:35:50,120
0,195 195,360 360,465 465,585 585,800
surprise me, I don't know,|
|

1385
00:35:50,560 --> 00:35:51,660
0,290 290,470 470,725 725,935 935,1100
they're called skip scans at
它们在 Oracle 被称为跳跃扫描，

1386
00:35:51,660 --> 00:35:54,030
0,470 1690,1920 1920,2040 2040,2220 2220,2370
Oracle| and that that might
|这可能是为什么没有人这样做的原因。

1387
00:35:54,030 --> 00:35:55,860
0,260 910,1200 1200,1395 1395,1635 1635,1830
be why nobody does. Nobody

1388
00:35:55,860 --> 00:35:56,900
0,120 120,255 255,530
else does this.|
|

1389
00:35:57,170 --> 00:35:58,555
0,320 320,500 500,760 960,1235 1235,1385
Alright, so again,| say I
好的，再次，|我在 a 和 b 上有我的索引，

1390
00:35:58,555 --> 00:35:59,815
0,150 150,425 535,900 900,1140 1140,1260
have my my index on

1391
00:35:59,815 --> 00:36:01,000
0,105 105,225 225,485 835,1080 1080,1185
a and b,| if I
|如果我想找到键 1 和 2 ，

1392
00:36:01,000 --> 00:36:01,840
0,90 90,180 180,420 420,690 690,840
want to find key 1

1393
00:36:01,840 --> 00:36:03,745
0,135 135,410 1360,1635 1635,1770 1770,1905
and 2,| again I use
|再次，我使用我的路标，

1394
00:36:03,745 --> 00:36:05,740
0,180 180,435 435,995 1165,1565 1675,1995
my guide posts| and essentially
|基本上只是查看键，

1395
00:36:05,740 --> 00:36:06,870
0,210 210,450 450,675 675,840 840,1130
just looking at the keys,|
|

1396
00:36:07,250 --> 00:36:08,095
0,290 290,455 455,620 620,740 740,845
the the parts of the
以顺序模式键的各个部分，

1397
00:36:08,095 --> 00:36:09,670
0,240 240,605 1075,1350 1350,1470 1470,1575
key in in sort of

1398
00:36:09,670 --> 00:36:11,050
0,315 315,560 730,1020 1020,1200 1200,1380
sequential order,| so first I
|所以，首先我检查的是 1 小于等于 1 ，

1399
00:36:11,050 --> 00:36:12,505
0,195 195,405 405,630 630,950 1180,1455
check is 1 less, less

1400
00:36:12,505 --> 00:36:13,915
0,120 120,240 240,390 390,665 1135,1410
than equal to 1| and
|然后我检查第二部分是 2 小于等于 3 ，

1401
00:36:13,915 --> 00:36:14,560
0,120 120,225 225,345 345,465 465,645
then I check the second

1402
00:36:14,560 --> 00:36:15,430
0,225 225,435 435,615 615,750 750,870
part is 2 less than

1403
00:36:15,430 --> 00:36:16,660
0,150 150,330 330,620 820,1080 1080,1230
equal to 3| and that
|这告诉我我想沿着这个节点往下，

1404
00:36:16,660 --> 00:36:17,350
0,195 195,360 360,480 480,600 600,690
tells me that I want

1405
00:36:17,350 --> 00:36:18,610
0,90 90,285 285,585 585,950 1000,1260
to follow down this to

1406
00:36:18,610 --> 00:36:20,065
0,260 340,630 630,855 855,1100 1210,1455
this, this node here| and
|然后我就可以找到我寻找的条目。

1407
00:36:20,065 --> 00:36:20,695
0,90 90,180 180,285 285,435 435,630
then I can find the

1408
00:36:20,695 --> 00:36:21,700
0,135 135,270 270,420 420,755
entry I'm looking for.|
|

1409
00:36:23,320 --> 00:36:24,525
0,275 275,485 485,680 680,905 905,1205
If I'm doing a prefix
如果我进行前缀搜索，

1410
00:36:24,525 --> 00:36:26,115
0,285 285,555 555,705 705,965 1315,1590
search,| meaning I have the
|意味着我有键的第一部分，但没有剩下的部分，

1411
00:36:26,115 --> 00:36:26,790
0,180 180,330 330,405 405,510 510,675
first part of the key

1412
00:36:26,790 --> 00:36:27,710
0,135 135,240 240,375 375,585 585,920
but not the remaining part,|
|

1413
00:36:28,090 --> 00:36:30,160
0,230 230,440 440,820
so I have
所以我有 a 的键，但是没有 b ，

1414
00:36:30,350 --> 00:36:31,410
0,245 245,365 365,590 590,800 800,1060
key on a, but not

1415
00:36:31,460 --> 00:36:32,580
0,400
b,|
|

1416
00:36:32,770 --> 00:36:33,870
0,400 450,695 695,830 830,980 980,1100
{} the way that would
这样做的方法是，

1417
00:36:33,870 --> 00:36:35,100
0,165 165,435 435,675 675,950 970,1230
work is,| you basically look
|你基本上查看你有的部分，

1418
00:36:35,100 --> 00:36:35,760
0,105 105,210 210,360 360,525 525,660
at the part that you

1419
00:36:35,760 --> 00:36:36,960
0,165 165,470 670,945 945,1065 1065,1200
do have| and see is
|然后看 1 是否小于等于 1 ，

1420
00:36:36,960 --> 00:36:37,940
0,180 180,375 375,570 570,720 720,980
1 less equal to 1,|
|

1421
00:36:38,260 --> 00:36:39,930
0,365 365,650 650,875 875,1180 1410,1670
yes, follow down here| and
是的，继续往下走，|然后我继续扫描，

1422
00:36:39,930 --> 00:36:41,180
0,150 150,360 360,630 630,915 915,1250
then now I scan along|
|

1423
00:36:41,500 --> 00:36:43,980
0,305 305,610 930,1295 1295,1960 2160,2480
and keep, keep evaluating my
继续计算我的[谓词]，

1424
00:36:43,980 --> 00:36:45,210
0,450 450,705 705,945 945,1080 1080,1230
predicate| against all the keys
|对于叶子节点中的所有键，

1425
00:36:45,210 --> 00:36:45,975
0,255 255,465 465,540 540,615 615,765
that are in the leaf

1426
00:36:45,975 --> 00:36:47,295
0,455 655,900 900,1005 1005,1140 1140,1320
nodes| until I have something
|直到我有违反的东西，

1427
00:36:47,295 --> 00:36:49,500
0,195 195,755 1285,1685 1735,2025 2025,2205
that violates,| or I know
|或者我知道现在 1 小于 2 ，

1428
00:36:49,500 --> 00:36:51,140
0,180 180,360 360,525 525,800 1240,1640
that 1 is now is

1429
00:36:51,550 --> 00:36:52,970
0,305 305,530 530,850 960,1190 1190,1420
less than 2| and I
|我不能遍历这里，

1430
00:36:53,020 --> 00:36:54,290
0,395 395,560 560,755 755,980 980,1270
can't, I can't traverse here,|
|

1431
00:36:54,550 --> 00:36:55,245
0,260 260,410 410,485 485,590 590,695
because it's a sort of
因为这是一种顺序，

1432
00:36:55,245 --> 00:36:55,965
0,135 135,315 315,510 510,645 645,720
order,| I know there will
|我知道那里永远不会有任何东西，

1433
00:36:55,965 --> 00:36:57,500
0,135 135,425 445,845 925,1230 1230,1535
be never, never anything,| where
|有一个键，第一部分 a 等于 1 ，

1434
00:36:57,980 --> 00:36:59,080
0,150 150,315 315,510 510,735 735,1100
you know, with a key,

1435
00:36:59,370 --> 00:37:00,695
0,275 275,440 440,710 710,1055 1055,1325
the first part, a equals

1436
00:37:00,695 --> 00:37:02,165
0,305 565,930 930,1185 1185,1335 1335,1470
1| and something else for
|b 后面有其他的东西，

1437
00:37:02,165 --> 00:37:03,335
0,275 415,675 675,780 780,930 930,1170
b,| after at this point,|
|在这个点之后，|

1438
00:37:03,335 --> 00:37:04,280
0,210 210,420 420,570 570,720 720,945
because they're sort of first
因为它们是键的第一部分。

1439
00:37:04,280 --> 00:37:05,360
0,350
on,

1440
00:37:05,360 --> 00:37:07,025
0,290 910,1200 1200,1410 1410,1575 1575,1665
on the first part of

1441
00:37:07,025 --> 00:37:08,280
0,105 105,365
the key.|
|

1442
00:37:09,940 --> 00:37:10,815
0,260 260,380 380,545 545,740 740,875
Again, the last one for
同样，最后一个用于跳跃扫描，

1443
00:37:10,815 --> 00:37:12,255
0,120 120,300 300,605 835,1215 1215,1440
the skip scans,| basically what
|基本上发生的是，

1444
00:37:12,255 --> 00:37:13,860
0,210 210,575 625,1025 1195,1455 1455,1605
happens is| you, at every
|在每个节点上，你评估，

1445
00:37:13,860 --> 00:37:15,825
0,195 195,465 465,710 1120,1520 1690,1965
single node you evaluate,| okay,
|好的，我有键的哪一部分，

1446
00:37:15,825 --> 00:37:16,635
0,180 180,360 360,450 450,540 540,810
what part of the key

1447
00:37:16,635 --> 00:37:18,435
0,270 270,435 435,725 1315,1590 1590,1800
do I have,| and then
|然后确定你必须看下面树的哪一部分，

1448
00:37:18,435 --> 00:37:20,090
0,335 355,690 690,990 990,1305 1305,1655
determine what portion of the

1449
00:37:20,200 --> 00:37:21,060
0,305 305,515 515,665 665,755 755,860
trees below you have to

1450
00:37:21,060 --> 00:37:22,005
0,135 135,410 520,765 765,855 855,945
look at,| and this is
|这是一个例子，

1451
00:37:22,005 --> 00:37:23,265
0,120 120,345 345,695 865,1125 1125,1260
an example here,| since I
|因为我没有键的第一部分，

1452
00:37:23,265 --> 00:37:24,675
0,270 270,515 685,1035 1035,1275 1275,1410
don't have the first part

1453
00:37:24,675 --> 00:37:25,650
0,75 75,165 165,425 475,765 765,975
of the key,| I essentially
|我基本上必须查看所有东西。

1454
00:37:25,650 --> 00:37:26,630
0,180 180,285 285,375 375,600 600,980
have to look at everything.|
|

1455
00:37:27,410 --> 00:37:28,780
0,290 290,580 930,1175 1175,1265 1265,1370
And again, I think in
同样，我认为在 Oracle 中，

1456
00:37:28,780 --> 00:37:30,115
0,420 420,570 570,705 705,975 975,1335
Oracle,| they can have multiple
|他们可以让多个线程并行，

1457
00:37:30,115 --> 00:37:31,360
0,300 300,420 420,695 775,1065 1065,1245
threads in parallel| go down
|沿着树的不同部分，

1458
00:37:31,360 --> 00:37:32,190
0,180 180,345 345,450 450,555 555,830
different parts of the tree,|
|

1459
00:37:32,420 --> 00:37:33,370
0,260 260,380 380,500 500,770 770,950
and then they combine the
然后在最后将结果组合在一起，

1460
00:37:33,370 --> 00:37:34,560
0,240 240,570 570,825 825,945 945,1190
results together at the end,|
|

1461
00:37:36,515 --> 00:37:37,220
0,105 105,240 240,375 375,555 555,705
it's almost like doing a
这就像是在进行通配符搜索，

1462
00:37:37,220 --> 00:37:38,650
0,195 195,450 450,770 880,1155 1155,1430
wild card search,| and so,
|我们最终将在 demo 中看到这个，

1463
00:37:39,460 --> 00:37:40,260
0,500 500,575 575,665 665,725 725,800
we'll see this a little

1464
00:37:40,260 --> 00:37:41,010
0,180 180,345 345,450 450,600 600,750
bit at the demo at

1465
00:37:41,010 --> 00:37:41,880
0,105 105,285 285,555 555,705 705,870
the end.| There's this trade
|在数据集中有这样的权衡，

1466
00:37:41,880 --> 00:37:42,720
0,195 195,420 420,570 570,690 690,840
off between in the data

1467
00:37:42,720 --> 00:37:43,365
0,135 135,300 300,360 360,435 435,645
set,| it's going to make
|它会让它变得，

1468
00:37:43,365 --> 00:37:44,600
0,270 270,575
that like,|
|

1469
00:37:44,600 --> 00:37:45,440
0,210 210,345 345,510 510,675 675,840
it could say, all right,
它可能会说，好的，

1470
00:37:45,440 --> 00:37:46,740
0,290
well,|
|

1471
00:37:47,110 --> 00:37:48,390
0,305 305,590 590,905 905,1130 1130,1280
I know something about the
我知道一些关于我的索引所基于的键的统计数据，

1472
00:37:48,390 --> 00:37:50,060
0,260 700,1020 1020,1215 1215,1380 1380,1670
statistics of of the keys

1473
00:37:50,080 --> 00:37:51,030
0,275 275,440 440,605 605,755 755,950
that my index is based

1474
00:37:51,030 --> 00:37:53,175
0,320 640,1040 1390,1695 1695,1950 1950,2145
on,| so it probably still
|所以可能仍然值得我去看看键，看看索引，

1475
00:37:53,175 --> 00:37:53,895
0,120 120,300 300,465 465,570 570,720
is worth me to go

1476
00:37:53,895 --> 00:37:54,705
0,240 240,435 435,540 540,645 645,810
look, look in the key,

1477
00:37:54,705 --> 00:37:56,115
0,180 180,330 330,525 525,845 1165,1410
look in the index,| but
|但它可能决定，

1478
00:37:56,115 --> 00:37:57,015
0,90 90,270 270,570 570,795 795,900
it may decide,| okay, well
|好的，我不知道你想让我做什么，

1479
00:37:57,015 --> 00:37:57,765
0,120 120,270 270,435 435,645 645,750
I don't know anything about

1480
00:37:57,765 --> 00:37:58,275
0,90 90,255 255,330 330,405 405,510
what you're trying to ask

1481
00:37:58,275 --> 00:37:59,475
0,120 120,210 210,455 685,930 930,1200
me to do,| so I'm,
|所以索引不会帮助我，

1482
00:37:59,475 --> 00:38:00,300
0,270 270,480 480,615 615,735 735,825
the index is not going

1483
00:38:00,300 --> 00:38:00,885
0,60 60,180 180,345 345,525 525,585
to help me,| I'm just
|我要对整张表做一个顺序扫描。

1484
00:38:00,885 --> 00:38:01,515
0,75 75,135 135,195 195,465 465,630
gonna do a sequential scan

1485
00:38:01,515 --> 00:38:02,780
0,180 180,315 315,480 480,785
across the entire table.|
|

1486
00:38:02,970 --> 00:38:03,830
0,245 245,425 425,605 605,725 725,860
And that actually may be
这可能快于，

1487
00:38:03,830 --> 00:38:05,225
0,255 255,570 570,750 750,1010 1120,1395
faster than| trying to do
|尝试对索引进行多个探测，并将结果组合在一起。

1488
00:38:05,225 --> 00:38:06,230
0,255 255,615 615,750 750,855 855,1005
multiple probes down to the

1489
00:38:06,230 --> 00:38:07,930
0,320 520,780 780,1080 1080,1365 1365,1700
index| and combine results together.|
|

1490
00:38:09,020 --> 00:38:09,940
0,275 275,395 395,545 545,695 695,920
And again, it's not something
再次，这不是程序员必须处理的事情，

1491
00:38:09,940 --> 00:38:11,395
0,180 180,770 910,1185 1185,1320 1320,1455
the programmer has to deal

1492
00:38:11,395 --> 00:38:12,325
0,180 180,345 345,465 465,645 645,930
with,| this is something we
|这是我们使用 SQL 查询，

1493
00:38:12,325 --> 00:38:13,300
0,225 225,360 360,585 585,765 765,975
take the SQL query| and
|并尝试自己解决这个。

1494
00:38:13,300 --> 00:38:13,975
0,180 180,285 285,405 405,525 525,675
try to figure this out

1495
00:38:13,975 --> 00:38:15,560
0,305 415,675 675,935
on our own.|
|

1496
00:38:16,430 --> 00:38:19,350
0,400 420,725 725,890 890,1210 2370,2920
Again, we cover this [].|
再次，我们在[]讨论这个。|

1497
00:38:22,470 --> 00:38:23,760
0,400
Yes.|
是的。|

1498
00:38:23,890 --> 00:38:25,060
0,335 335,670

1499
00:38:25,990 --> 00:38:28,215
0,260 260,520 1500,1790 1790,1970 1970,2225
This question, this question is,|
这个问题是，|

1500
00:38:28,215 --> 00:38:28,785
0,225 225,315 315,405 405,495 495,570
is it up to the
是不是由程序来决定建立什么样的索引，

1501
00:38:28,785 --> 00:38:29,775
0,180 180,390 390,570 570,870 870,990
program decide what indexes to

1502
00:38:29,775 --> 00:38:30,740
0,275
make,|
|

1503
00:38:31,180 --> 00:38:33,080
0,305 305,590 590,970
most systems, yes.|
大多数系统，是的。|

1504
00:38:33,150 --> 00:38:34,805
0,400 420,695 695,970 1320,1565 1565,1655
So this is, this is
所以，这是数据库中的一个老问题，

1505
00:38:34,805 --> 00:38:36,070
0,90 90,210 210,420 420,660 660,1265
an old problem in databases,|
|

1506
00:38:37,350 --> 00:38:38,350
0,305 305,485 485,605 605,725 725,1000
I talk about how great
我谈到关系模型的抽象有多棒，

1507
00:38:38,610 --> 00:38:39,770
0,320 320,665 665,815 815,950 950,1160
the abstraction is for relational

1508
00:38:39,770 --> 00:38:40,760
0,330 330,645 645,810 810,945 945,990
model,| that you don't have
|你不必担心东西实际上是如何物理存储的等等，

1509
00:38:40,760 --> 00:38:41,390
0,75 75,210 210,360 360,495 495,630
to worry about how things

1510
00:38:41,390 --> 00:38:42,260
0,135 135,270 270,495 495,765 765,870
are actually physically stored and

1511
00:38:42,260 --> 00:38:43,640
0,90 90,350 700,1095 1095,1320 1320,1380
all that,| but the end
|但是最终，

1512
00:38:43,640 --> 00:38:44,555
0,75 75,180 180,435 435,840 840,915
of the day,| someone's got
|总得有人来决定你到底需要什么样的索引，

1513
00:38:44,555 --> 00:38:45,830
0,135 135,405 405,735 735,1110 1110,1275
to decide what indexes you

1514
00:38:45,830 --> 00:38:46,940
0,210 210,500
actually need,|
|

1515
00:38:46,940 --> 00:38:47,810
0,195 195,360 360,555 555,645 645,870
and so there's a long
所以我自己在 CMU 有一长串的研究，

1516
00:38:47,810 --> 00:38:49,985
0,210 210,330 330,590 1750,2040 2040,2175
line of research myself here

1517
00:38:49,985 --> 00:38:51,470
0,120 120,540 540,735 735,995 1195,1485
at CMU,| but like, going
|但是，回到 1970 年代，

1518
00:38:51,470 --> 00:38:52,400
0,165 165,270 270,330 330,510 510,930
back to the {1970s -},|
|

1519
00:38:52,400 --> 00:38:53,405
0,120 120,300 300,465 465,710 730,1005
of people trying to figure
人们试图自动找出你想要什么索引，

1520
00:38:53,405 --> 00:38:54,650
0,275 355,690 690,930 930,1110 1110,1245
out automatically what index is

1521
00:38:54,650 --> 00:38:55,600
0,260
{you,need},|
|

1522
00:38:56,420 --> 00:38:58,320
0,305 305,545 545,880 1020,1420 1500,1900
and so the commercial systems
所以，商业系统内置了工具，

1523
00:38:58,490 --> 00:38:59,740
0,350 350,605 605,815 815,1070 1070,1250
have built in tools| that
|可以帮助你解决这一问题，

1524
00:38:59,740 --> 00:39:00,340
0,60 60,165 165,300 300,450 450,600
can help you figure this

1525
00:39:00,340 --> 00:39:01,960
0,260 820,1110 1110,1335 1335,1410 1410,1620
out,| {MySQL -} and Postgres
|MySQL 和 Postgres 没有这个，

1526
00:39:01,960 --> 00:39:03,240
0,210 210,345 345,480 480,740
do not have that,|
|

1527
00:39:03,390 --> 00:39:05,195
0,350 350,575 575,850 990,1340 1340,1805
Postgres will build whatever indexes
Postgres 将构建你告诉它需要的任何索引，

1528
00:39:05,195 --> 00:39:05,975
0,225 225,345 345,450 450,555 555,780
you tell it you want

1529
00:39:05,975 --> 00:39:07,000
0,360 360,510 510,630 630,765 765,1025
it,| do it for you,
|为你做这些，

1530
00:39:08,010 --> 00:39:09,305
0,320 320,470 470,545 545,790 1050,1295
right,| so you want,| if
|所以你想，|如果你告诉，我想要一千个索引，

1531
00:39:09,305 --> 00:39:09,785
0,105 105,210 210,300 300,390 390,480
you tell I want a

1532
00:39:09,785 --> 00:39:11,260
0,240 240,750 750,1095 1095,1215 1215,1475
thousand indexes,| it do it,
|它就会这样做，

1533
00:39:12,150 --> 00:39:14,620
0,400 690,1090
right,| in,
|在 Azure 的 SQL Server 中，

1534
00:39:14,990 --> 00:39:16,660
0,400 450,875 875,1115 1115,1430 1430,1670
in SQL Server on, on

1535
00:39:16,660 --> 00:39:18,475
0,590 850,1125 1125,1410 1410,1620 1620,1815
Azure,| what they actually do
|它们实际上所做的是，

1536
00:39:18,475 --> 00:39:20,160
0,195 195,575 865,1140 1140,1350 1350,1685
is,| they'll spin up a
|它们为你的数据库系统启动一个单独的实例，

1537
00:39:20,360 --> 00:39:22,165
0,400 1050,1355 1355,1490 1490,1595 1595,1805
separate instance for your database

1538
00:39:22,165 --> 00:39:24,385
0,335 895,1170 1170,1445 1585,1980 1980,2220
system,| try out basically some
|尝试某种基本的机器算法，

1539
00:39:24,385 --> 00:39:26,005
0,75 75,195 195,345 345,605 1315,1620
kind of machine algorithm| to
|来找出你实际需要的索引，

1540
00:39:26,005 --> 00:39:26,890
0,180 180,300 300,450 450,750 750,885
figure out what indexes you

1541
00:39:26,890 --> 00:39:28,165
0,150 150,410 550,810 810,1020 1020,1275
actually need| and then suggest
|然后向你推荐它们，

1542
00:39:28,165 --> 00:39:29,400
0,195 195,345 345,605
them to you,

1543
00:39:29,400 --> 00:39:30,420
0,260
right,|
|

1544
00:39:30,430 --> 00:39:31,605
0,350 350,485 485,650 650,860 860,1175
SQL Server does other other
SQL Server 还做了其他有趣的事情，

1545
00:39:31,605 --> 00:39:33,255
0,270 270,450 450,690 690,1025 1375,1650
interesting things too,| although in
|尽管在查询优化器中，

1546
00:39:33,255 --> 00:39:35,630
0,150 150,455 475,1175 1765,2040 2040,2375
the query optimizer,| which we'll
|我们将在期中之后讨论，

1547
00:39:35,680 --> 00:39:37,395
0,245 245,425 425,680 680,1150 1440,1715
talk about after midterm,| your
|你的查询会出现，

1548
00:39:37,395 --> 00:39:38,700
0,240 240,465 465,755 835,1095 1095,1305
query shows up,| it starts
|它会开始根据你拥有的任何索引来计划它，

1549
00:39:38,700 --> 00:39:39,705
0,285 285,480 480,615 615,795 795,1005
planning it based on whatever

1550
00:39:39,705 --> 00:39:41,010
0,315 315,435 435,695 955,1185 1185,1305
indexes you have,| but at
|但在某种程度上，你也可以说，

1551
00:39:41,010 --> 00:39:41,745
0,180 180,315 315,390 390,540 540,735
some point you can also

1552
00:39:41,745 --> 00:39:43,200
0,275 415,750 750,1005 1005,1155 1155,1455
say,| man, I'd be really
|伙计，这很好，

1553
00:39:43,200 --> 00:39:44,025
0,255 255,360 360,435 435,630 630,825
great,| if I had, if
|如果我现在有一个索引在这个树上，在这个表上，

1554
00:39:44,025 --> 00:39:44,640
0,90 90,180 180,315 315,480 480,615
I had an index on

1555
00:39:44,640 --> 00:39:45,810
0,165 165,470 580,855 855,990 990,1170
this tree on this table

1556
00:39:45,810 --> 00:39:47,760
0,210 210,500 790,1035 1035,1400 1660,1950
right now,| it doesn't can
|它可能不能为你构建它，

1557
00:39:47,760 --> 00:39:48,590
0,165 165,300 300,435 435,570 570,830
build it for you if

1558
00:39:48,730 --> 00:39:50,450
0,400 630,1030 1080,1325 1325,1445 1445,1720
potentially,| but instead of saying
|它可能可以只为那个查询构建，

1559
00:39:51,070 --> 00:39:52,290
0,275 275,545 545,860 860,1085 1085,1220
it can potentially build for

1560
00:39:52,290 --> 00:39:52,920
0,75 75,180 180,285 285,405 405,630
you just for that query,|
|

1561
00:39:52,920 --> 00:39:53,670
0,150 150,330 330,495 495,630 630,750
but it also come back
但它也会回来告诉你，

1562
00:39:53,670 --> 00:39:54,300
0,120 120,240 240,345 345,480 480,630
and tell you,| hey, by
|嘿，顺便说一句，

1563
00:39:54,300 --> 00:39:55,365
0,105 105,350 550,795 795,915 915,1065
the way,| if you gave
|如果你给我这个索引，我会跑得更快。

1564
00:39:55,365 --> 00:39:56,220
0,120 120,300 300,540 540,765 765,855
me this index, I'd run

1565
00:39:56,220 --> 00:39:57,340
0,90 90,225 225,530
a lot faster.|
|

1566
00:39:57,610 --> 00:39:58,815
0,245 245,425 425,740 740,965 965,1205
The reason why you may
你可能必须的原因，

1567
00:39:58,815 --> 00:40:00,135
0,395 475,720 720,945 945,1185 1185,1320
necessarily,| you know, you could
|你可以只为查询构建它，然后丢弃它，

1568
00:40:00,135 --> 00:40:00,750
0,150 150,285 285,420 420,525 525,615
build it just for the

1569
00:40:00,750 --> 00:40:01,365
0,165 165,285 285,390 390,495 495,615
query and then throw it

1570
00:40:01,365 --> 00:40:02,805
0,275 535,810 810,1050 1050,1230 1230,1440
away,| because that only affect
|因为这只会影响该查询，

1571
00:40:02,805 --> 00:40:04,245
0,165 165,485 745,1035 1035,1245 1245,1440
that query,| you may not
|你可能不想构建它，然后保留它，

1572
00:40:04,245 --> 00:40:05,370
0,135 135,315 315,555 555,870 870,1125
want to build it and

1573
00:40:05,370 --> 00:40:06,615
0,150 150,315 315,465 465,740 850,1245
then keep it around,| because
|因为正如我所说的，你必须维护它，

1574
00:40:06,615 --> 00:40:07,380
0,240 240,375 375,540 540,660 660,765
as I said, you got

1575
00:40:07,380 --> 00:40:08,595
0,105 105,350 460,860 880,1125 1125,1215
to maintain it,| you got
|你必须使其与表保持同步，

1576
00:40:08,595 --> 00:40:09,285
0,90 90,195 195,300 300,465 465,690
to keep it in sync

1577
00:40:09,285 --> 00:40:10,545
0,105 105,240 240,515 925,1170 1170,1260
with the table,| so you
|所以你不希望你的数据库添加大量索引，

1578
00:40:10,545 --> 00:40:11,790
0,165 165,270 270,405 405,665 985,1245
don't want your database {sort,of}

1579
00:40:11,790 --> 00:40:12,615
0,195 195,375 375,510 510,660 660,825
adding like a ton of

1580
00:40:12,615 --> 00:40:13,515
0,330 330,465 465,630 630,825 825,900
indexes| and now that's gonna
|这将使我的所有插入、更新和删除变得更慢。

1581
00:40:13,515 --> 00:40:14,475
0,90 90,225 225,375 375,750 750,960
make all my insert updates

1582
00:40:14,475 --> 00:40:15,760
0,135 135,285 285,465 465,785
and deletes go slower.|
|

1583
00:40:16,160 --> 00:40:17,350
0,275 275,440 440,730 810,1055 1055,1190
Also, too, like, you know,
此外，它们占用存储空间、内存空间，

1584
00:40:17,350 --> 00:40:18,475
0,180 180,390 390,630 630,900 900,1125
they take storage space, take

1585
00:40:18,475 --> 00:40:20,020
0,195 195,515 805,1125 1125,1290 1290,1545
memory space,| there's a cost
|还有物理硬件的成本，

1586
00:40:20,020 --> 00:40:21,090
0,180 180,375 375,630 630,810 810,1070
of physical hardware as well,|
|

1587
00:40:22,270 --> 00:40:23,620
0,75 75,180 180,330 330,620
that's a whole other
这完全是另一个马蜂窝，

1588
00:40:24,670 --> 00:40:25,485
0,380 380,515 515,635 635,725 725,815
hornets nest,| we can get
|我们可以进入。

1589
00:40:25,485 --> 00:40:26,440
0,245
into.|
|

1590
00:40:29,640 --> 00:40:31,160
0,400
Okay.|
好的。|

1591
00:40:31,950 --> 00:40:32,525
0,245 245,320 320,410 410,485 485,575
So the next thing we've
所以，我们接下来要处理的事情是，

1592
00:40:32,525 --> 00:40:33,310
0,60 60,135 135,240 240,450 450,785
got to deal with is,|
|

1593
00:40:33,660 --> 00:40:34,250
0,245 245,335 335,440 440,530 530,590
at this point, we know
在这一点上，我们知道如何做插入、更新和删除，

1594
00:40:34,250 --> 00:40:35,710
0,75 75,165 165,570 570,855 855,1460
how do inserts, updates, deletes,|
|

1595
00:40:36,090 --> 00:40:36,890
0,245 245,320 320,365 365,425 425,800
we know to do inserts
我们知道做插入和删除，

1596
00:40:36,890 --> 00:40:38,225
0,180 180,680 940,1185 1185,1260 1260,1335
and deletes,| we know how
|我们知道如何进行基本的查找

1597
00:40:38,225 --> 00:40:40,025
0,90 90,335 775,1170 1170,1620 1620,1800
to do basic lookup| to
|来找到我们寻找的键，

1598
00:40:40,025 --> 00:40:40,835
0,195 195,375 375,510 510,675 675,810
find the keys we're looking

1599
00:40:40,835 --> 00:40:42,335
0,180 180,405 405,780 780,1215 1215,1500
for,| whether prefix searches, full
|无论是前缀搜索、全键搜索还是跳跃扫描。

1600
00:40:42,335 --> 00:40:43,580
0,165 165,435 435,695 775,1065 1065,1245
key searches or the skip

1601
00:40:43,580 --> 00:40:44,520
0,290
scans.|
|

1602
00:40:44,830 --> 00:40:45,720
0,275 275,470 470,680 680,815 815,890
The next challenge we got
我们要处理的下一个挑战是如何处理重复的键？

1603
00:40:45,720 --> 00:40:46,350
0,75 75,180 180,300 300,450 450,630
to deal with is how

1604
00:40:46,350 --> 00:40:47,720
0,120 120,210 210,470 520,1080 1080,1370
do we handle duplicate keys?|
|

1605
00:40:51,170 --> 00:40:52,570
0,230 230,350 350,545 545,850 1140,1400
So there's two approaches to
所以，有两种方法可以做到这个。

1606
00:40:52,570 --> 00:40:53,720
0,135 135,410
do this.|
|

1607
00:40:54,250 --> 00:40:55,185
0,365 365,575 575,710 710,845 845,935
Again, the issue is going
再说一次，问题会是这样的，

1608
00:40:55,185 --> 00:40:56,310
0,75 75,225 225,525 525,870 870,1125
to be like,| since I
|因为我希望能够，

1609
00:40:56,310 --> 00:40:57,110
0,150 150,240 240,300 300,465 465,800
want to be able to,|
|

1610
00:40:58,910 --> 00:41:00,250
0,400 420,740 740,965 965,1145 1145,1340
have everything always in {log(n)
让每件事都是 log(n) ，

1611
00:41:00,250 --> 00:41:02,005
0,320 760,1160 1300,1560 1560,1650 1650,1755
-}, right,| how do I
|我该如何处理，

1612
00:41:02,005 --> 00:41:03,490
0,120 120,210 210,300 300,545 1225,1485
actually want to handle,| have
|有能力一遍又一遍地插入键和复制键，

1613
00:41:03,490 --> 00:41:05,010
0,105 105,350 430,705 705,1215 1215,1520
the capability of inserting keys

1614
00:41:05,870 --> 00:41:06,850
0,380 380,560 560,740 740,830 830,980
duplic keys over and over

1615
00:41:06,850 --> 00:41:09,085
0,270 270,525 525,830 940,1610 1900,2235
again| and not violate that
|而不违反这一要求。

1616
00:41:09,085 --> 00:41:10,100
0,515
requirement.|
|

1617
00:41:10,450 --> 00:41:11,535
0,260 260,365 365,530 530,785 785,1085
So the most common approach
所以，最常见的方法是，

1618
00:41:11,535 --> 00:41:13,980
0,330 330,695 1045,1445 1735,2135 2215,2445
is| to to maintain sort
|在键中维护某种隐藏列或隐藏属性，

1619
00:41:13,980 --> 00:41:15,405
0,60 60,180 180,465 465,860 1150,1425
of a hidden column or

1620
00:41:15,405 --> 00:41:16,850
0,275 535,870 870,1005 1005,1155 1155,1445
hidden attribute in the key|
|

1621
00:41:17,410 --> 00:41:18,645
0,290 290,470 470,695 695,995 995,1235
with the record ID of
其中包含它所指向的 tuple 的记录 ID ，

1622
00:41:18,645 --> 00:41:19,545
0,150 150,420 420,540 540,705 705,900
the tuple that it's pointing

1623
00:41:19,545 --> 00:41:20,420
0,335
to,|
|

1624
00:41:20,970 --> 00:41:22,535
0,275 275,470 470,740 740,1355 1355,1565
and then that guarantees that
然后，这保证了每个键最终都是唯一的，

1625
00:41:22,535 --> 00:41:23,735
0,240 240,540 540,765 765,930 930,1200
every key ends up being

1626
00:41:23,735 --> 00:41:24,960
0,395
unique,

1627
00:41:24,970 --> 00:41:25,860
0,335 335,545 545,680 680,785 785,890
right,| if you have a
|如果你有一个键在 4 上，

1628
00:41:25,860 --> 00:41:26,775
0,135 135,360 360,660 660,855 855,915
key on 4,| and I
|我有一个键在 4 上，

1629
00:41:26,775 --> 00:41:27,500
0,60 60,165 165,270 270,420 420,725
have a key on 4,|
|

1630
00:41:27,910 --> 00:41:28,620
0,275 275,395 395,485 485,575 575,710
but you have a separate
但是你有一个 tuple ，我有一个 tuple ，

1631
00:41:28,620 --> 00:41:29,055
0,150 150,255 255,330 330,375 375,435
{tuple -}, I have a

1632
00:41:29,055 --> 00:41:29,805
0,135 135,330 330,465 465,585 585,750
separate tuple,| if we put
|如果我们把我们的记录 ID 作为键的一部分，

1633
00:41:29,805 --> 00:41:31,020
0,275 325,615 615,840 840,1035 1035,1215
our, our basic, our record

1634
00:41:31,200 --> 00:41:32,370
0,260 400,720 720,930 930,1050 1050,1170
ID as part of the

1635
00:41:32,370 --> 00:41:33,960
0,290 880,1140 1140,1335 1335,1500 1500,1590
key| in addition to the
|除了基于他们的索引的列，

1636
00:41:33,960 --> 00:41:35,300
0,260 340,630 630,795 795,1005 1005,1340
column based on their index,|
|

1637
00:41:35,680 --> 00:41:37,140
0,400 480,800 800,1040 1040,1265 1265,1460
then your 4, my 4
那么你的 4 ，我的 4 ，最终是唯一的。

1638
00:41:37,140 --> 00:41:38,500
0,135 135,240 240,390 390,680
end up being unique.|
|

1639
00:41:38,760 --> 00:41:39,830
0,350 350,635 635,830 830,950 950,1070
And because I can do
因为我可以做前缀搜索，

1640
00:41:39,830 --> 00:41:41,540
0,165 165,555 555,860 1390,1620 1620,1710
that prefix search,| where I
|我不需要拥有键的所有元素来进行查找，

1641
00:41:41,540 --> 00:41:42,440
0,195 195,285 285,390 390,585 585,900
don't have to have all

1642
00:41:42,440 --> 00:41:43,475
0,240 240,450 450,645 645,780 780,1035
the elements of the key

1643
00:41:43,475 --> 00:41:45,250
0,210 210,330 330,875 1225,1500 1500,1775
to do lookups,| then this
|所以这个方案仍然有效。

1644
00:41:45,360 --> 00:41:46,940
0,335 335,545 545,820
scheme still works.|
|

1645
00:41:48,890 --> 00:41:49,855
0,245 245,410 410,635 635,815 815,965
The other approach is to
另一种方法是溢出叶子节点，

1646
00:41:49,855 --> 00:41:52,630
0,545 685,1320 1320,1560 1560,2075 2515,2775
overload, overflow leaf nodes| and
|基本思想是，

1647
00:41:52,630 --> 00:41:54,370
0,260 340,600 600,735 735,1010 1360,1740
basic idea is that,| the
|叶子节点本身，

1648
00:41:54,370 --> 00:41:55,810
0,240 240,390 390,735 735,1100 1180,1440
the leaf nodes themselves,| if
|如果我太满，

1649
00:41:55,810 --> 00:41:56,665
0,180 180,345 345,480 480,660 660,855
I, if I get too

1650
00:41:56,665 --> 00:41:57,400
0,210 210,360 360,480 480,600 600,735
full,| but I know I'm
|但我知道我插入的是相同的键，

1651
00:41:57,400 --> 00:41:58,930
0,285 285,390 390,585 585,920 1240,1530
inserting the same key,| then
|那么我可能会继续构建一个链表，

1652
00:41:58,930 --> 00:42:00,010
0,165 165,345 345,645 645,915 915,1080
I just potentially keep building

1653
00:42:00,010 --> 00:42:01,510
0,150 150,315 315,620 1030,1290 1290,1500
a linked list| and I
|我会再次深入树的深处，

1654
00:42:01,510 --> 00:42:03,430
0,180 180,285 285,465 465,770 1630,1920
sort of go down in

1655
00:42:03,430 --> 00:42:04,120
0,150 150,270 270,420 420,555 555,690
in the depth of the

1656
00:42:04,120 --> 00:42:05,575
0,290 610,870 870,975 975,1110 1110,1455
tree,| again, but that violates
|但这违反了我们的 log(n) 保证。

1657
00:42:05,575 --> 00:42:06,570
0,135 135,285 285,465 465,675 675,995
our, our {log(n) -} approach,

1658
00:42:08,310 --> 00:42:10,420
0,275 275,485 485,845 845,1120 1710,2110
our, {log(n) -} guarantee.| {All,right},
|好的，所以这就是我们如何做记录，

1659
00:42:11,670 --> 00:42:12,545
0,260 260,440 440,530 530,650 650,875
so here's how we do

1660
00:42:12,545 --> 00:42:14,945
0,365 925,1325 1795,2025 2025,2160 2160,2400
the record,| so the key
|现在的键不只是数字 1 ，

1661
00:42:14,945 --> 00:42:16,450
0,300 300,645 645,870 870,1170 1170,1505
now isn't just number 1,|
|

1662
00:42:16,740 --> 00:42:18,095
0,410 410,695 695,935 935,1085 1085,1355
it's one, and then followed
它是 1 ，然后跟着是记录 ID ，

1663
00:42:18,095 --> 00:42:20,405
0,365 835,1095 1095,1275 1275,1595 2065,2310
by the record ID,| which
|也就是页码和偏移量。

1664
00:42:20,405 --> 00:42:21,185
0,75 75,180 180,345 345,540 540,780
is the page number and

1665
00:42:21,185 --> 00:42:22,040
0,335
offset.|
|

1666
00:42:22,440 --> 00:42:23,180
0,245 245,380 380,515 515,620 620,740
So now if I want
所以现在，如果我想插入 6 ，

1667
00:42:23,180 --> 00:42:24,365
0,90 90,435 435,750 750,1020 1020,1185
to insert 6| and 6
|而 6 已经存在，

1668
00:42:24,365 --> 00:42:26,530
0,210 210,545 1015,1415 1495,1830 1830,2165
already exists,| well, any time,
|那么，任何时候，即使你可能调用 SQL ， INSERT 6 ，

1669
00:42:27,240 --> 00:42:28,235
0,290 290,455 455,575 575,740 740,995
even though you might call

1670
00:42:28,235 --> 00:42:29,960
0,225 225,555 555,900 900,1235 1495,1725
in SQL, INSERT 6,| where
|数据库做的就是将其转换为，

1671
00:42:29,960 --> 00:42:30,815
0,105 105,380 430,690 690,780 780,855
the database is going to

1672
00:42:30,815 --> 00:42:31,865
0,90 90,270 270,495 495,720 720,1050
do is convert that to|
|

1673
00:42:31,865 --> 00:42:33,560
0,525 525,875
insert 6,
插入 6 ，后面跟着页码和 slot 编号。

1674
00:42:33,600 --> 00:42:34,930
0,320 320,620 620,875 875,1040 1040,1330
followed by the page number

1675
00:42:35,490 --> 00:42:37,000
0,305 305,530 530,820
and slot number.|
|

1676
00:42:37,000 --> 00:42:37,660
0,165 165,315 315,465 465,555 555,660
So now when I get
所以现在当我向下的时候，

1677
00:42:37,660 --> 00:42:39,625
0,195 195,530 1390,1680 1680,1830 1830,1965
down here,| since this guy
|因为这个节点已经满了，

1678
00:42:39,625 --> 00:42:41,965
0,180 180,485 1825,2115 2115,2220 2220,2340
is full,| I'll just do
|我做一个分裂，滑动。

1679
00:42:41,965 --> 00:42:44,490
0,165 165,485 775,1065 1065,1355 2125,2525
a split, slide over and.|
|

1680
00:42:48,340 --> 00:42:49,440
0,400

1681
00:42:50,370 --> 00:42:51,815
0,400 570,875 875,1070 1070,1280 1280,1445
So things slide over| and
所以节点滑动过去，|现在我可以在这里插入 6 。

1682
00:42:51,815 --> 00:42:52,810
0,105 105,300 300,510 510,615 615,995
then now I can insert

1683
00:42:53,130 --> 00:42:54,400
0,290 290,440 440,700
6 right here,

1684
00:42:54,750 --> 00:42:57,275
0,400 900,1300 1380,2000 2000,2230 2250,2525
right.| Again, superficially, it looks
|从表面上看，它像是一个重复键，

1685
00:42:57,275 --> 00:42:58,055
0,135 135,345 345,480 480,585 585,780
like it's like a {duplicate,keys},|
|

1686
00:42:58,055 --> 00:42:59,470
0,210 210,485 595,900 900,1110 1110,1415
but again, the actual bits
但是，实际的位本身是唯一的。

1687
00:42:59,490 --> 00:43:01,520
0,400 450,785 785,1010 1010,1300
themselves are are unique.|
|

1688
00:43:03,050 --> 00:43:03,835
0,245 245,380 380,545 545,650 650,785
Of course, now if I
当然，现在如果我想要再次删除 6 ，

1689
00:43:03,835 --> 00:43:04,510
0,180 180,315 315,450 450,570 570,675
want, if I want to

1690
00:43:04,510 --> 00:43:05,610
0,90 90,225 225,480 480,765 765,1100
do a delete on 6|
|

1691
00:43:06,350 --> 00:43:07,380
0,320 320,500 500,620 620,755 755,1030
again, I would have to,|
我将不得不，|

1692
00:43:07,460 --> 00:43:08,830
0,245 245,490 780,1175 1175,1250 1250,1370
you know, internally the database
在内部，数据库系统将知道，

1693
00:43:08,830 --> 00:43:09,790
0,165 165,285 285,420 420,690 690,960
system is gonna know,| okay,
|好的，删除 6 跟着这个记录 ID 和页面偏移量，

1694
00:43:09,790 --> 00:43:11,185
0,290 370,630 630,825 825,1110 1110,1395
well, delete on 6, followed

1695
00:43:11,185 --> 00:43:12,370
0,225 225,405 405,615 615,885 885,1185
by this record ID and

1696
00:43:12,370 --> 00:43:13,220
0,350
offset,

1697
00:43:13,320 --> 00:43:15,220
0,400 690,965 965,1190 1190,1520 1520,1900
the page number offset.| Yes.|
|是的。|

1698
00:43:17,160 --> 00:43:18,380
0,400

1699
00:43:19,410 --> 00:43:20,285
0,350 350,545 545,680 680,785 785,875
Question, what happens if the
问题是，如果键不是数字会发生什么，

1700
00:43:20,285 --> 00:43:21,100
0,120 120,240 240,390 390,540 540,815
key is not a number,|
|

1701
00:43:21,450 --> 00:43:23,540
0,215 215,260 260,305 305,520
what do you mean?|
你是什么意思？|

1702
00:43:23,930 --> 00:43:25,350
0,305 305,545 545,880 900,1160 1160,1420

1703
00:43:26,850 --> 00:43:27,980
0,275 275,455 455,725 725,980 980,1130
So yeah, so 6 is
所以，是的， 6 是键。

1704
00:43:27,980 --> 00:43:29,240
0,150 150,440
the key.|
|

1705
00:43:32,390 --> 00:43:33,265
0,245 245,335 335,425 425,635 635,875

1706
00:43:33,265 --> 00:43:35,000
0,120 120,495 495,780 780,1115

1707
00:43:36,230 --> 00:43:37,360
0,395 395,620 620,725 725,980 980,1130
{} Because I insert into
因为我插入到一个表中，

1708
00:43:37,360 --> 00:43:38,860
0,150 150,410 1000,1245 1245,1350 1350,1500
a table| and the table
|那个表在列 foo ，列 a 上有一个索引，

1709
00:43:38,860 --> 00:43:40,525
0,195 195,500 670,1070 1240,1515 1515,1665
has has an index on

1710
00:43:40,525 --> 00:43:42,900
0,275 475,935 1045,1350 1350,1655
column foo, column a,|
|

1711
00:43:43,060 --> 00:43:45,000
0,400 720,1010 1010,1295 1295,1745 1745,1940
and the tuple {I'm,inserting} for
我插入那个属性的 tuple 将值设置为 6 ，

1712
00:43:45,000 --> 00:43:46,620
0,260 340,800 1090,1380 1380,1500 1500,1620
that attribute sets the value

1713
00:43:46,620 --> 00:43:47,860
0,150 150,410
to 6,

1714
00:43:47,900 --> 00:43:49,320
0,400 450,815 815,1055 1055,1175 1175,1420
right,| but instead of just
|但是不是只放入 6 ，

1715
00:43:49,400 --> 00:43:51,040
0,335 335,575 575,880 1260,1580 1580,1640
putting 6 in,| it's going
|它会说，我已经插入了表中，

1716
00:43:51,040 --> 00:43:52,405
0,75 75,320 460,840 840,975 975,1365
to say I've already inserted

1717
00:43:52,405 --> 00:43:53,560
0,120 120,240 240,515 745,1020 1020,1155
into the table,| now I
|现在我有了一个记录 ID ，

1718
00:43:53,560 --> 00:43:54,715
0,105 105,210 210,390 390,710 910,1155
have a record ID,| so
|所以当我插入索引时，

1719
00:43:54,715 --> 00:43:55,690
0,90 90,390 390,540 540,705 705,975
when {I,insert} into the index,|
|

1720
00:43:55,690 --> 00:43:57,745
0,360 360,650 700,1100 1330,1845 1845,2055
it's the 6, appended by
它是 6 ，跟着记录 ID 的位，

1721
00:43:57,745 --> 00:43:58,690
0,180 180,390 390,645 645,810 810,945
the bits for the record

1722
00:43:58,690 --> 00:43:59,600
0,290
ID,|
|

1723
00:43:59,980 --> 00:44:01,125
0,245 245,380 380,860 860,1025 1025,1145
and that guarantees that no,
这保证了很多次我插入 6 ，

1724
00:44:01,125 --> 00:44:02,400
0,150 150,375 375,630 630,1005 1005,1275
many times I insert 6,|
|

1725
00:44:02,400 --> 00:44:04,970
0,270 270,500 970,1370 1600,2000 2170,2570
it's unique, right| now, if
它是唯一的，|如果它是唯一索引，

1726
00:44:05,740 --> 00:44:06,885
0,245 245,395 395,455 455,700 750,1145
if it's a unique index,|
|

1727
00:44:06,885 --> 00:44:08,250
0,395 595,855 855,975 975,1155 1155,1365
I, like a primary key
比如主键索引，

1728
00:44:08,250 --> 00:44:08,925
0,180 180,300 300,360 360,435 435,675
index,| or I can declare
|或者我可以声明它是唯一索引，

1729
00:44:08,925 --> 00:44:09,890
0,165 165,345 345,405 405,600 600,965
that it's a unique index,|
|

1730
00:44:10,180 --> 00:44:11,850
0,400 930,1220 1220,1475 1475,1565 1565,1670
then I don't want to
那么我不想这样做，

1731
00:44:11,850 --> 00:44:13,670
0,120 120,380 640,1040 1330,1575 1575,1820
do this,| but the mechanism
|但这一机制仍然有效。

1732
00:44:13,780 --> 00:44:15,040
0,275 275,550
still works.|
|

1733
00:44:16,610 --> 00:44:18,130
0,305 305,530 530,800 800,1150 1200,1520

1734
00:44:18,130 --> 00:44:19,920
0,300 300,615 615,950 1240,1740

1735
00:44:21,200 --> 00:44:22,240
0,305 305,610

1736
00:44:25,180 --> 00:44:26,550
0,260 260,440 440,760 960,1205 1205,1370
His statement is,| and he's
他的说法是，|他是正确的，

1737
00:44:26,550 --> 00:44:28,020
0,260 310,710 790,1050 1050,1245 1245,1470
correct,| this is just essentially
|这本质上是一个隐藏的属性，

1738
00:44:28,020 --> 00:44:29,480
0,135 135,360 360,830
a hidden attribute,|
|

1739
00:44:29,640 --> 00:44:31,810
0,275 275,680 680,890 890,1210 1680,2170
that guarantees that that duplicate
保证了重复键在物理上是唯一的，

1740
00:44:31,860 --> 00:44:34,940
0,320 320,640 1260,1640 1640,2020 2790,3080
keys are physically unique,| because
|因为它是记录 ID ，

1741
00:44:34,940 --> 00:44:36,130
0,225 225,315 315,480 480,795 795,1190
it's the record ID,| yes,
|是的，这是个技巧。

1742
00:44:36,970 --> 00:44:38,100
0,75 75,180 180,440
that's the trick.|
|

1743
00:44:42,820 --> 00:44:45,480
0,395 395,695 695,1270 1740,2375 2375,2660
So the overflow, overflow leaf
所以，溢出叶子节点如下所示，

1744
00:44:45,480 --> 00:44:46,665
0,195 195,300 300,435 435,710 940,1185
nodes look like this,| I
|我插入 6 ，

1745
00:44:46,665 --> 00:44:48,645
0,285 285,605 775,1035 1035,1295 1555,1980
insert 6,| I recognize it's
|我发现它在我的叶子节点上已经满了，

1746
00:44:48,645 --> 00:44:50,985
0,305 1255,1590 1590,1785 1785,1935 1935,2340
full in my leaf node,|
|

1747
00:44:50,985 --> 00:44:52,005
0,210 210,360 360,510 510,735 735,1020
but I also recognize that,|
但我也认识到，|

1748
00:44:52,005 --> 00:44:52,605
0,150 150,255 255,405 405,495 495,600
the thing you're trying to
你试图插入的东西已经存在于这里，

1749
00:44:52,605 --> 00:44:53,955
0,375 375,720 720,1005 1005,1170 1170,1350
insert already exists in here|
|

1750
00:44:53,955 --> 00:44:55,040
0,255 255,420 420,540 540,615 615,1085
and therefore it's a duplicate,|
因此它是一个重复的，|

1751
00:44:55,210 --> 00:44:55,875
0,230 230,305 305,410 410,530 530,665
so I just make this
所以我做了这个溢出页面，并将其插入到这里。

1752
00:44:55,875 --> 00:44:57,975
0,465 465,755 1225,1575 1575,1995 1995,2100
overflow page and insert it

1753
00:44:57,975 --> 00:44:58,900
0,150 150,455
down here,

1754
00:44:59,600 --> 00:45:00,660
0,400
right,|
|

1755
00:45:00,790 --> 00:45:02,460
0,260 260,520 690,1055 1055,1550 1550,1670
and I keep inserting new
我不断地插入新的东西，

1756
00:45:02,460 --> 00:45:03,345
0,180 180,330 330,420 420,555 555,885
things| and I keep appending
|我一直像这样追加它。

1757
00:45:03,345 --> 00:45:04,920
0,105 105,345 345,600 600,875
it along like this.|
|

1758
00:45:06,510 --> 00:45:07,895
0,245 245,380 380,670 900,1220 1220,1385
So this looks similar to
所以，这看起来类似于前面的链哈希表，

1759
00:45:07,895 --> 00:45:10,000
0,245 1165,1440 1440,1650 1650,1800 1800,2105
the chain hash table before,|
|

1760
00:45:11,120 --> 00:45:12,200
0,165 165,440
that like,|
就像是，|

1761
00:45:12,670 --> 00:45:13,755
0,260 260,380 380,575 575,785 785,1085
instead of having a hash
不是让哈希函数告诉我我在链表的开始位置，

1762
00:45:13,755 --> 00:45:15,375
0,255 255,495 495,755 1135,1425 1425,1620
function tell me where I

1763
00:45:15,375 --> 00:45:16,050
0,210 210,360 360,465 465,585 585,675
land at the start of

1764
00:45:16,050 --> 00:45:17,505
0,105 105,270 270,560 1090,1350 1350,1455
my linked list,| I have
|而是在它前面有一个树结构，

1765
00:45:17,505 --> 00:45:18,195
0,120 120,285 285,465 465,600 600,690
a tree structure in front

1766
00:45:18,195 --> 00:45:19,490
0,90 90,335 445,735 735,960 960,1295
of it,| but essentially doing
|但本质上做的是相同的事情，

1767
00:45:19,660 --> 00:45:20,940
0,275 275,455 455,760
the same thing,|
|

1768
00:45:21,680 --> 00:45:23,410
0,245 245,365 365,575 575,910 1440,1730
of course, now, again, this
当然，现在，再一次，这违反了 log(n) ，

1769
00:45:23,410 --> 00:45:25,060
0,390 390,615 615,920 1300,1545 1545,1650
violates {log(n) -},| we have
|我们必须处理，

1770
00:45:25,060 --> 00:45:26,275
0,120 120,285 285,450 450,710 970,1215
to deal with like,| what
|如果我们真的想要拆分和合并，

1771
00:45:26,275 --> 00:45:26,905
0,105 105,270 270,420 420,510 510,630
if we actually want to

1772
00:45:26,905 --> 00:45:27,580
0,135 135,240 240,525 525,615 615,675
split and merge,| what do
|我们要移动什么东西，

1773
00:45:27,580 --> 00:45:29,350
0,90 90,225 225,500 1270,1575 1575,1770
we move things,| this makes
|这使得事情比记录 ID 方法复杂得多，

1774
00:45:29,350 --> 00:45:30,445
0,180 180,330 330,465 465,740 850,1095
things way more complicated than

1775
00:45:30,445 --> 00:45:31,890
0,105 105,255 255,465 465,785 1045,1445
the record ID approach, very,|
|

1776
00:45:33,235 --> 00:45:33,850
0,75 75,120 120,180 180,345 345,615
I don't think any real
我不认为任何真正的系统会做到这个。

1777
00:45:33,850 --> 00:45:36,740
0,330 330,555 555,675 675,950
system actually does this.|
|

1778
00:45:37,260 --> 00:45:38,270
0,245 245,380 380,650 650,950 950,1010
The question is, what's the
问题是，这种方法的好处是什么，

1779
00:45:38,270 --> 00:45:39,275
0,90 90,180 180,315 315,620 760,1005
benefit of this approach,| now
|现在，我不需要保存记录 ID ，

1780
00:45:39,275 --> 00:45:39,755
0,75 75,195 195,270 270,375 375,480
I don't need to store

1781
00:45:39,755 --> 00:45:44,620
0,90 90,255 255,575 1345,3155 4465,4865
the record {ID\,,right},| duplicate, {store,a,part}
|在每个键中保存一部分，

1782
00:45:44,700 --> 00:45:47,380
0,275 275,455 455,680 680,1000
in every single key,|
|

1783
00:45:48,530 --> 00:45:50,980
0,195 195,560 730,1130 1240,1640
it's potentially easier engineering,|
这可能是更容易的工程设计，|

1784
00:45:51,270 --> 00:45:51,920
0,245 245,350 350,470 470,560 560,650
actually, not really, it makes
事实上，不是很清楚，这让它变得更难了。

1785
00:45:51,920 --> 00:45:52,960
0,120 120,380
it harder.|
|

1786
00:45:53,330 --> 00:45:53,935
0,275 275,365 365,410 410,470 470,605
Yeah, this is a bad
是的，这是个坏想法，别这么做，

1787
00:45:53,935 --> 00:45:55,855
0,165 165,315 315,405 405,665 1675,1920
idea, don't do this,| but
|但是你可以，

1788
00:45:55,855 --> 00:45:56,995
0,120 120,395 625,885 885,1005 1005,1140
you could,| and so you
|所以你可以，它是坏的。

1789
00:45:56,995 --> 00:45:58,700
0,245 355,720 720,965
have, {I'm,saying} bad.|
|

1790
00:46:05,380 --> 00:46:06,180
0,350 350,530 530,590 590,665 665,800
I want to talk about
我想谈谈聚集索引，

1791
00:46:06,180 --> 00:46:08,180
0,270 270,720 945,1095 1095,1370
cluster indexes,| these aren't,|
|这些不是，|

1792
00:46:08,820 --> 00:46:09,395
0,245 245,305 305,410 410,500 500,575
I mean, it's good for
我是说，至少你们知道这个对你们是有好处的，

1793
00:46:09,395 --> 00:46:10,100
0,60 60,165 165,315 315,510 510,705
you guys at least know

1794
00:46:10,100 --> 00:46:11,225
0,225 225,495 495,765 765,1005 1005,1125
this,| this exists,| but I
|这是存在的，|但我不想在上面花费太多时间，

1795
00:46:11,225 --> 00:46:11,600
0,120 120,150 150,210 210,300 300,375
don't want to spend too

1796
00:46:11,600 --> 00:46:12,515
0,90 90,210 210,330 330,590 670,915
much time on it.| The
|其基本思想是，

1797
00:46:12,515 --> 00:46:13,370
0,210 210,405 405,495 495,615 615,855
basic idea is that,| there's
|有一些数据库系统允许你在表上定义所谓的聚集索引，

1798
00:46:13,370 --> 00:46:15,785
0,290 730,1080 1080,1430 1840,2130 2130,2415
some database systems let you

1799
00:46:15,785 --> 00:46:17,525
0,395 835,1065 1065,1155 1155,1335 1335,1740
define what are called clustered

1800
00:46:17,525 --> 00:46:20,210
0,300 300,435 435,725 2215,2490 2490,2685
indexes on tables,| where you
|你可以允许实际的表本身，实际的 tuple 本身，

1801
00:46:20,210 --> 00:46:21,940
0,240 240,560 910,1215 1215,1425 1425,1730
can allow the the actual

1802
00:46:21,960 --> 00:46:23,570
0,400 420,770 770,1010 1010,1205 1205,1610
table itself, the actual tuples

1803
00:46:23,570 --> 00:46:24,995
0,350 610,885 885,1035 1035,1155 1155,1425
themselves,| even though the relational
|即使关系型模型没有排序，

1804
00:46:24,995 --> 00:46:26,465
0,210 210,465 465,935 1075,1335 1335,1470
models {unsorted -},| you can
|你可以说我希望磁盘上的物理 tuple 排序，

1805
00:46:26,465 --> 00:46:27,460
0,165 165,345 345,540 540,720 720,995
say I want the physical

1806
00:46:27,540 --> 00:46:28,940
0,515 515,815 815,1175 1175,1250 1250,1400
tuples on disk to be

1807
00:46:28,940 --> 00:46:30,545
0,405 405,660 660,1010 1150,1440 1440,1605
sorted,| based on the sort
|基于某个索引定义的排序。

1808
00:46:30,545 --> 00:46:32,110
0,240 240,555 555,825 825,1145 1165,1565
order defined by some index.|
|

1809
00:46:33,630 --> 00:46:34,580
0,275 275,410 410,560 560,755 755,950
And in this case here,|
在这个例子中，|

1810
00:46:34,580 --> 00:46:35,705
0,290 370,645 645,765 765,915 915,1125
if I have a true
如果我有一个真正的聚集索引，

1811
00:46:35,705 --> 00:46:38,080
0,390 390,725
clustered index,|
|

1812
00:46:38,620 --> 00:46:39,915
0,275 275,395 395,640 840,1145 1145,1295
that no matter where I
无论我在哪里插入新记录，

1813
00:46:39,915 --> 00:46:41,570
0,255 255,360 360,480 480,755 1255,1655
insert a new record,| the
|实际的堆文件本身都将保证按这种顺序排序，

1814
00:46:42,190 --> 00:46:44,340
0,290 290,665 665,1060 1200,1600 1890,2150
actual heap files themselves will

1815
00:46:44,340 --> 00:46:46,040
0,135 135,645 645,795 795,1040 1300,1700
be guaranteed to be in

1816
00:46:46,060 --> 00:46:47,540
0,305 305,470 470,590 590,850
that sort of order,|
|

1817
00:46:47,660 --> 00:46:48,550
0,320 320,500 500,620 620,755 755,890
you sort of think of
你可以再次考虑这个，

1818
00:46:48,550 --> 00:46:50,740
0,210 210,450 450,740 790,2025 2025,2190
this again,| the MySQL SQLite
|MySQL SQLite 方法，

1819
00:46:50,740 --> 00:46:51,640
0,225 225,390 390,495 495,660 660,900
approach,| where the leaf nodes
|叶子节点实际存储了 tuple ，

1820
00:46:51,640 --> 00:46:52,300
0,120 120,255 255,435 435,555 555,660
are actually stored the {tuples

1821
00:46:52,300 --> 00:46:54,420
0,260 520,975 975,1320 1320,1785 1785,2120
-},| that's automatically clustered index,|
|这是自动聚集索引，|

1822
00:46:54,890 --> 00:46:56,160
0,245 245,380 380,590 590,890 890,1270
but in some database systems,|
但在一些数据库系统中，|

1823
00:46:56,330 --> 00:46:58,770
0,305 305,515 515,1030 1890,2165 2165,2440
where it isn't an in
它不是一个有组织的表，

1824
00:46:58,850 --> 00:47:00,330
0,290 290,580 750,1025 1025,1190 1190,1480
organized table,| you can have
|你可以通过这种索引来强制执行。

1825
00:47:00,410 --> 00:47:01,750
0,260 260,410 410,635 635,830 830,1340
the sort of be enforced

1826
00:47:01,750 --> 00:47:03,235
0,290 910,1155 1155,1260 1260,1365 1365,1485
by, by this kind of

1827
00:47:03,235 --> 00:47:04,080
0,275
index,

1828
00:47:04,730 --> 00:47:05,900
0,400
right.|
|

1829
00:47:06,720 --> 00:47:07,955
0,275 275,550 570,830 830,1040 1040,1235
And so the advantage of
这样做的好处是，

1830
00:47:07,955 --> 00:47:08,825
0,120 120,270 270,495 495,720 720,870
this is that,| when I
|当我开始这样做，

1831
00:47:08,825 --> 00:47:11,080
0,165 165,455
start doing,|
|

1832
00:47:11,080 --> 00:47:11,650
0,225 225,315 315,390 390,465 465,570
when I want to start
当我想要开始扫描时，

1833
00:47:11,650 --> 00:47:13,945
0,210 210,590 1780,2055 2055,2205 2205,2295
doing scans,| assuming I'm not
|假设我不是在进行索引、有组织的存储，

1834
00:47:13,945 --> 00:47:15,640
0,195 195,480 480,735 735,1025 1435,1695
doing index, organized storage,| when
|当我沿着叶子节点扫描，

1835
00:47:15,640 --> 00:47:16,630
0,195 195,465 465,690 690,825 825,990
I scan along the leaf

1836
00:47:16,630 --> 00:47:17,395
0,315 315,420 420,555 555,675 675,765
nodes| to find all the
|以找到我正在寻找的所有 tuple ，

1837
00:47:17,395 --> 00:47:18,700
0,120 120,285 285,450 450,785 1045,1305
tuples I'm looking for,| then
|那么我肯定会得到页面，

1838
00:47:18,700 --> 00:47:20,340
0,180 180,675 675,840 840,1130 1240,1640
I'm guaranteed to get the

1839
00:47:20,930 --> 00:47:22,280
0,400
pages,|
|

1840
00:47:22,280 --> 00:47:23,855
0,180 180,495 495,720 720,1100 1300,1575
in sorted order {based,as} defined
在键定义的排序基础上。

1841
00:47:23,855 --> 00:47:25,200
0,120 120,240 240,390 390,665
on the key order,

1842
00:47:26,030 --> 00:47:28,660
0,400 810,1210 1290,1610 1610,1930 2310,2630
right.| So again as I
|所以，当我再一次扫描的时候，

1843
00:47:28,660 --> 00:47:30,880
0,225 225,530 700,1050 1050,1400
scan this going across,|
|

1844
00:47:30,880 --> 00:47:32,110
0,350 460,705 705,810 810,930 930,1230
I get all my entries|
我得到了我所有的条目，|

1845
00:47:32,110 --> 00:47:32,725
0,135 135,270 270,405 405,495 495,615
and I get all my
我得到了我所有的页面，

1846
00:47:32,725 --> 00:47:33,565
0,195 195,345 345,495 495,720 720,840
pages| and I [rip] through
|我按顺序[撕开]它，事情变得很快。

1847
00:47:33,565 --> 00:47:34,570
0,135 135,555 555,705 705,855 855,1005
that sequentially and things go

1848
00:47:34,570 --> 00:47:35,540
0,260
fast.|
|

1849
00:47:37,250 --> 00:47:38,020
0,245 245,350 350,575 575,665 665,770
If you don't have a
如果你没有聚集索引，

1850
00:47:38,020 --> 00:47:39,955
0,255 255,620 670,1070 1390,1740 1740,1935
cluster index,| then you end
|那么你有时会得到一堆随机 I/O ，

1851
00:47:39,955 --> 00:47:41,125
0,245 265,660 660,945 945,1065 1065,1170
up sometimes with a bunch

1852
00:47:41,125 --> 00:47:42,670
0,120 120,270 270,450 450,725 1165,1545
of random {I/O -},| the,
|再次，叶子节点可以按顺序存储在磁盘上，

1853
00:47:42,670 --> 00:47:44,755
0,380 430,830 1300,1620 1620,1920 1920,2085
again the leaf nodes that

1854
00:47:44,755 --> 00:47:46,075
0,135 135,365 475,825 825,1200 1200,1320
could be stored sequentially on

1855
00:47:46,075 --> 00:47:47,500
0,515 625,915 915,1095 1095,1260 1260,1425
disk,| but when I start
|但当我开始查找以获得叶子节点所指向的实际数据时，

1856
00:47:47,500 --> 00:47:49,075
0,210 210,710 940,1200 1200,1365 1365,1575
doing lookups to get the

1857
00:47:49,075 --> 00:47:50,455
0,210 210,515 535,930 930,1215 1215,1380
actual data, that the leaf

1858
00:47:50,455 --> 00:47:51,940
0,180 180,315 315,585 585,965
nodes are pointing to,|
|

1859
00:47:51,940 --> 00:47:52,950
0,300 300,480 480,600 600,735 735,1010
that could end up being
最终可能是随机的。

1860
00:47:53,060 --> 00:47:54,280
0,400
random,

1861
00:47:54,750 --> 00:47:55,595
0,335 335,545 545,650 650,725 725,845
right.| And so if I
|所以，如果我做了一些非常愚蠢的事情，

1862
00:47:55,595 --> 00:47:56,825
0,150 150,345 345,630 630,960 960,1230
do something really stupid,| like
|比如我的缓冲池中有一个空闲的 frame ，

1863
00:47:56,825 --> 00:47:57,995
0,165 165,285 285,480 480,795 795,1170
say I have one free

1864
00:47:57,995 --> 00:47:59,110
0,315 315,465 465,570 570,855 855,1115
frame in my buffer pool|
|

1865
00:47:59,580 --> 00:48:01,700
0,400 1080,1340 1340,1550 1550,1835 1835,2120
and if I scan along
如果我按顺序扫描，

1866
00:48:01,700 --> 00:48:03,500
0,225 225,360 360,620 1420,1650 1650,1800
in the order,| if I
|如果我按照页面从索引中出来的顺序获取页面，

1867
00:48:03,500 --> 00:48:04,370
0,255 255,405 405,585 585,765 765,870
fetch the page in the

1868
00:48:04,370 --> 00:48:05,435
0,210 210,555 555,825 825,945 945,1065
order that they come out

1869
00:48:05,435 --> 00:48:06,905
0,105 105,270 270,605 985,1260 1260,1470
of the index,| I may
|我可能会得到一大堆冗余的 I/O ，

1870
00:48:06,905 --> 00:48:07,655
0,180 180,300 300,480 480,630 630,750
end up doing a bunch

1871
00:48:07,655 --> 00:48:09,500
0,165 165,455 985,1515 1515,1650 1650,1845
of the redundant {I/O -},|
|

1872
00:48:09,500 --> 00:48:10,460
0,180 180,420 420,645 645,825 825,960
where like I fetch the
比如获取页面，在它上面运行，

1873
00:48:10,460 --> 00:48:11,960
0,165 165,470 730,1110 1110,1365 1365,1500
page in, process on it,|
|

1874
00:48:11,960 --> 00:48:12,620
0,105 105,270 270,375 375,510 510,660
because that's the key I'm
因为这是我现在正在查看的键，

1875
00:48:12,620 --> 00:48:13,660
0,120 120,285 285,435 435,675 675,1040
looking at right now| or
|或者我指向的，

1876
00:48:13,740 --> 00:48:14,780
0,350 350,545 545,665 665,830 830,1040
that that I got pointed

1877
00:48:14,780 --> 00:48:16,310
0,320 550,840 840,1080 1080,1350 1350,1530
to| and then I throw
|然后我扔掉它，获得下一页，

1878
00:48:16,310 --> 00:48:17,075
0,120 120,285 285,450 450,570 570,765
it away, get the next

1879
00:48:17,075 --> 00:48:18,515
0,335 535,780 780,1005 1005,1260 1260,1440
page,| but then a few
|但是再几个键之后，

1880
00:48:18,515 --> 00:48:19,400
0,165 165,300 300,465 465,690 690,885
few more keys later,| I
|我会获取之前相同的页面。

1881
00:48:19,400 --> 00:48:20,180
0,105 105,270 270,420 420,585 585,780
go fetch the same page

1882
00:48:20,180 --> 00:48:21,280
0,135 135,225 225,470
I did before.|
|

1883
00:48:22,810 --> 00:48:24,110
0,230 230,320 320,500 500,770 770,1300
So a really simple optimization
所以，有一个非常简单的优化方法是，

1884
00:48:24,220 --> 00:48:25,130
0,260 260,380 380,515 515,650 650,910
to do this is that,|
|

1885
00:48:25,480 --> 00:48:28,065
0,305 305,820 1110,1510 2160,2405 2405,2585
you don't actually, you don't
当你沿着叶子节点扫描时，你不会检索到 tuple ，

1886
00:48:28,065 --> 00:48:29,910
0,465 465,600 600,1005 1005,1355 1495,1845
retrieve the tuples as you

1887
00:48:29,910 --> 00:48:31,250
0,255 255,450 450,600 600,795 795,1340
scan along the leaf nodes,|
|

1888
00:48:31,720 --> 00:48:33,120
0,260 260,410 410,605 605,910 1110,1400
as you find them,| you
当你查找它们时，|你首先扫描叶子节点，

1889
00:48:33,120 --> 00:48:34,395
0,210 210,525 525,855 855,1095 1095,1275
first do the scan the

1890
00:48:34,395 --> 00:48:36,240
0,180 180,510 510,815 1435,1710 1710,1845
leaf nodes first,| get your
|获取所有页面的列表，

1891
00:48:36,240 --> 00:48:37,130
0,135 135,270 270,420 420,600 600,890
list of all your pages,|
|

1892
00:48:38,070 --> 00:48:40,420
0,400 510,815 815,1085 1085,1450 1950,2350
then sort them in by
然后根据页面 ID 对它们进行排序，

1893
00:48:40,800 --> 00:48:42,260
0,275 275,425 425,590 590,880 1200,1460
based on page ID| and
|然后根据这个进行检索，

1894
00:48:42,260 --> 00:48:43,295
0,150 150,285 285,600 600,795 795,1035
then go retrieve them based

1895
00:48:43,295 --> 00:48:44,120
0,135 135,395 415,660 660,750 750,825
on this,| now you still
|现在你仍然需要[记账]，

1896
00:48:44,120 --> 00:48:45,215
0,75 75,150 150,375 375,645 645,1095
have to do the bookkeeping|
|

1897
00:48:45,215 --> 00:48:46,120
0,75 75,210 210,390 390,585 585,905
to make sure that you
以确保你跟随 tuple ，

1898
00:48:46,230 --> 00:48:47,860
0,350 350,575 575,860 860,1130 1130,1630
you're following along the tuples|
|

1899
00:48:48,240 --> 00:48:49,460
0,260 260,380 380,620 620,935 935,1220
in the order defined by
按照索引定义的顺序，

1900
00:48:49,460 --> 00:48:50,615
0,270 270,480 480,770 790,1080 1080,1155
the index,| that that's what
|这就是你所关心的。

1901
00:48:50,615 --> 00:48:51,740
0,105 105,270 270,575
you care about.|
|

1902
00:48:51,740 --> 00:48:52,445
0,210 210,345 345,495 495,615 615,705
But again, this is a
同样，这是一种获得更多顺序 I/O ，

1903
00:48:52,445 --> 00:48:53,345
0,120 120,240 240,375 375,645 645,900
way to get {more,sequencial} {I/O

1904
00:48:53,345 --> 00:48:54,410
0,165 165,345 345,495 495,755 805,1065
-}| and reduce the amount
|并减少随机访问量的方法。

1905
00:48:54,410 --> 00:48:55,700
0,105 105,330 330,710
of random access.|
|

1906
00:48:56,390 --> 00:48:57,420
0,275 275,425 425,650 650,770 770,1030

1907
00:48:57,710 --> 00:48:59,380
0,275 275,500 500,755 755,1030 1380,1670

1908
00:48:59,380 --> 00:49:00,145
0,150 150,255 255,435 435,630 630,765

1909
00:49:00,145 --> 00:49:01,800
0,195 195,405 405,660 660,1025 1255,1655

1910
00:49:04,670 --> 00:49:06,190
0,260 260,515 515,860 860,1210 1230,1520
And so, so his statement
所以，所以他的说法是，

1911
00:49:06,190 --> 00:49:07,255
0,290 460,750 750,915 915,960 960,1065
is,| why couldn't I just
|为什么我不能跟踪我已经获取的页面，

1912
00:49:07,255 --> 00:49:08,140
0,240 240,480 480,615 615,735 735,885
keep track of what I've

1913
00:49:08,140 --> 00:49:08,860
0,105 105,330 330,435 435,600 600,720
already fetched in page,| I
|然后我不再获取它。

1914
00:49:08,860 --> 00:49:09,835
0,120 120,240 240,375 375,650 730,975
don't fetch it again.| I
|我举了一个玩具例子，

1915
00:49:09,835 --> 00:49:10,765
0,105 105,300 300,495 495,675 675,930
was giving a toy example,|
|

1916
00:49:10,765 --> 00:49:11,905
0,195 195,455 595,855 855,990 990,1140
where, like I only have
比如，我只有一个 frame ，

1917
00:49:11,905 --> 00:49:13,220
0,225 225,575
one frame,|
|

1918
00:49:13,420 --> 00:49:14,355
0,320 320,500 500,605 605,725 725,935
so I can only fetch
所以我只能获取一页，

1919
00:49:14,355 --> 00:49:15,285
0,210 210,450 450,675 675,825 825,930
one page,| I throw it
|我把它扔掉，然后获取下一页，

1920
00:49:15,285 --> 00:49:15,870
0,120 120,255 255,360 360,450 450,585
out and get the next

1921
00:49:15,870 --> 00:49:17,360
0,290 670,960 960,1125 1125,1245 1245,1490
page,| in this, in this
|在这个玩具例子中。

1922
00:49:17,410 --> 00:49:19,560
0,290 290,580
toy example.|
|

1923
00:49:20,400 --> 00:49:21,290
0,320 320,545 545,710 710,800 800,890
But, but think in a
但是，考虑在一个真实的系统中，

1924
00:49:21,290 --> 00:49:23,075
0,180 180,500 1270,1530 1530,1710 1710,1785
real system,| again, don't think
|不要考虑一页，

1925
00:49:23,075 --> 00:49:23,930
0,105 105,240 240,405 405,615 615,855
of like one page,| think
|考虑，比如我可能有 10G 的空间，

1926
00:49:23,930 --> 00:49:24,940
0,210 210,390 390,525 525,690 690,1010
like I can have maybe,

1927
00:49:25,530 --> 00:49:26,930
0,230 230,460 540,845 845,1265 1265,1400
you know, 10 gigabytes of

1928
00:49:26,930 --> 00:49:28,750
0,290 700,960 960,1095 1095,1370 1420,1820
space,| but my database is
|但我的数据库是 1TB ，表是 1TB ，

1929
00:49:29,070 --> 00:49:30,800
0,290 290,850 1230,1505 1505,1625 1625,1730
1 terabyte, table is one

1930
00:49:30,800 --> 00:49:32,570
0,330 330,405 405,650 1330,1665 1665,1770
terabyte,| and then you're run
|然后你就会耗尽空间。

1931
00:49:32,570 --> 00:49:33,540
0,75 75,150 150,410
out of space.|
|

1932
00:49:34,580 --> 00:49:35,740
0,165 165,270 270,530

1933
00:49:35,840 --> 00:49:36,685
0,290 290,440 440,560 560,695 695,845
You, you want to sort
你想要对它们进行排序，

1934
00:49:36,685 --> 00:49:37,105
0,120 120,210 210,285 285,345 345,420
them| and you want to
|你想让它们出现在页面上，

1935
00:49:37,105 --> 00:49:37,920
0,60 60,105 105,225 225,465 465,815
get them in page,| you,
|你想要以它们在磁盘上的物理存在的顺序来访问它们，

1936
00:49:38,210 --> 00:49:39,070
0,245 245,335 335,500 500,695 695,860
you want to access them

1937
00:49:39,070 --> 00:49:40,030
0,210 210,390 390,600 600,810 810,960
in the order that they

1938
00:49:40,030 --> 00:49:41,830
0,195 195,435 435,660 660,1190 1540,1800
exist physically on disk| and
|然后仍然这样做，只是记账，

1939
00:49:41,830 --> 00:49:42,715
0,165 165,360 360,525 525,690 690,885
then still do, but just

1940
00:49:42,715 --> 00:49:43,660
0,450 450,555 555,675 675,825 825,945
bookkeeping| to make sure that
|以确保你生成的结果的顺序

1941
00:49:43,660 --> 00:49:44,590
0,135 135,360 360,570 570,735 735,930
the order of the results

1942
00:49:44,590 --> 00:49:46,390
0,195 195,650 970,1350 1350,1620 1620,1800
you're generating| match the sort
|与的索引中排序顺序相匹配，

1943
00:49:46,390 --> 00:49:47,780
0,255 255,510 510,800
order of the

1944
00:49:47,780 --> 00:49:49,020
0,105 105,255 255,560
of the index,|
|

1945
00:49:50,880 --> 00:49:51,995
0,395 395,695 695,890 890,1025 1025,1115
again to reduce amount of
再次，为了减少浪费 I/O 的数量。

1946
00:49:51,995 --> 00:49:53,200
0,240 240,360 360,635
wasted {I/O -}.|
|

1947
00:49:57,810 --> 00:49:58,880
0,400
Okay.|
好的。|

1948
00:49:58,890 --> 00:49:59,525
0,230 230,290 290,350 350,440 440,635
So I want to quickly
所以我想在这里快速介绍一些设计选择，

1949
00:49:59,525 --> 00:50:00,920
0,225 225,515 565,885 885,1125 1125,1395
go through some design choices

1950
00:50:00,920 --> 00:50:02,735
0,350 1090,1350 1350,1440 1440,1590 1590,1815
here,| how to handle certain
|如何处理某些事情。

1951
00:50:02,735 --> 00:50:03,860
0,305 415,660 660,810 810,975 975,1125
things.| And so a lot
|所以这些想法很多都来自这本书，

1952
00:50:03,860 --> 00:50:04,970
0,210 210,480 480,750 750,960 960,1110
of these ideas come from

1953
00:50:04,970 --> 00:50:05,945
0,180 180,405 405,570 570,750 750,975
this book,| which is considered
|这本书被认为是 B+ 树的圣经，

1954
00:50:05,945 --> 00:50:07,220
0,165 165,425 505,840 840,1065 1065,1275
the Bible of {B+ -}

1955
00:50:07,220 --> 00:50:09,515
0,320 1540,1800 1800,1920 1920,2085 2085,2295
trees| from this guy Goetz
|来自 Goetz Graefe 这个人，

1956
00:50:09,515 --> 00:50:11,885
0,515 1615,1950 1950,2100 2100,2250 2250,2370
Graefe,| he's invented a bunch
|他发明了一系列不同的技术，

1957
00:50:11,885 --> 00:50:13,220
0,275 325,630 630,915 915,1140 1140,1335
of various techniques,| that we'll
|我们将在本学期讨论。

1958
00:50:13,220 --> 00:50:15,380
0,240 240,450 450,770
discuss this semester.|
|

1959
00:50:15,380 --> 00:50:16,730
0,285 285,590 700,1005 1005,1140 1140,1350
And again, it's called modern
再次，这被称为现代 B 树技术，

1960
00:50:16,730 --> 00:50:17,825
0,240 240,465 465,615 615,840 840,1095
B B tree techniques,| and
|再说一次，他说的是 B+ 树，

1961
00:50:17,825 --> 00:50:18,650
0,165 165,375 375,495 495,645 645,825
again, he's about {B+ -}

1962
00:50:18,650 --> 00:50:19,340
0,210 210,360 360,450 450,585 585,690
trees,| but he calls it
|但他称之为 B 树，

1963
00:50:19,340 --> 00:50:21,320
0,60 60,195 195,500 1510,1815 1815,1980
a B tree,| and actually,
|事实上，如果你在 Google 上搜索这本书的名字，

1964
00:50:21,320 --> 00:50:22,100
0,90 90,165 165,330 330,585 585,780
if you just Google this

1965
00:50:22,100 --> 00:50:23,135
0,150 150,285 285,420 420,690 690,1035
name of this book,| it's
|它是 2010 年出版的，

1966
00:50:23,135 --> 00:50:24,200
0,120 120,255 255,1005 1005,1035 1035,1065
came out 2010,| it's a
|这是一本很棒的书，

1967
00:50:24,200 --> 00:50:24,830
0,105 105,255 255,420 420,540 540,630
great book,| covers a lot
|涵盖了很多这些技巧，甚至更多，

1968
00:50:24,830 --> 00:50:25,610
0,90 90,195 195,420 420,645 645,780
of these techniques and, and

1969
00:50:25,610 --> 00:50:27,580
0,165 165,470 730,1130
even more, {}|
|

1970
00:50:27,710 --> 00:50:28,855
0,260 260,380 380,515 515,790 810,1145
if you just Google, you'll
如果你用 Google 搜索，你会找到 PDF ，

1971
00:50:28,855 --> 00:50:30,835
0,120 120,255 255,695 1645,1890 1890,1980
find the PDF,| if you
|如果你喜欢这种东西，

1972
00:50:30,835 --> 00:50:31,465
0,105 105,240 240,345 345,435 435,630
like this kind of stuff,|
|

1973
00:50:31,465 --> 00:50:32,755
0,225 225,285 285,375 375,635 985,1290
it's a good read.| Again,
这是一本很好的读物。|因为它是理论，

1974
00:50:32,755 --> 00:50:34,450
0,165 165,485 775,1175 1225,1560 1560,1695
because it's theory,| here's how
|这是如何在实际系统中实现它的方法。

1975
00:50:34,450 --> 00:50:35,005
0,105 105,165 165,255 255,375 375,555
actually you how to implement

1976
00:50:35,005 --> 00:50:36,180
0,305 445,690 690,780 780,900 900,1175
it in a real system.|
|

1977
00:50:38,090 --> 00:50:38,830
0,245 245,365 365,470 470,575 575,740
All right, the first question
好的，第一个问题是，

1978
00:50:38,830 --> 00:50:39,415
0,180 180,405 405,465 465,510 510,585
is,| what's going to be
|节点的大小是多少。

1979
00:50:39,415 --> 00:50:41,920
0,105 105,345 345,635 1375,1775 2245,2505
the node size.| So you
|所以，你可以假设，

1980
00:50:41,920 --> 00:50:43,075
0,195 195,530 580,840 840,990 990,1155
can assume,| in all our
|在这里的所有图表中，

1981
00:50:43,075 --> 00:50:44,725
0,465 465,660 660,900 900,1200 1200,1650
diagrams here,| one node corresponds
|一个节点对应于一个页面，

1982
00:50:44,725 --> 00:50:47,290
0,135 135,390 390,755 1975,2310 2310,2565
to one page| in, in,
|在我们的数据库文件中，在我们的缓冲池中，

1983
00:50:47,290 --> 00:50:48,385
0,255 255,555 555,780 780,945 945,1095
in, in in our in

1984
00:50:48,385 --> 00:50:49,630
0,105 105,330 330,695 865,1125 1125,1245
our database files, in our

1985
00:50:49,630 --> 00:50:52,495
0,270 270,530 1690,2090 2260,2595 2595,2865
buffer pool,| but in some
|但在某些系统中，例如在 IBM DB2 中，

1986
00:50:52,495 --> 00:50:53,875
0,335 385,645 645,765 765,1110 1110,1380
systems, like in IBM {DB2

1987
00:50:53,875 --> 00:50:56,095
0,275 535,795 795,1005 1005,1355 1555,2220
-},| you can actually modify,|
|你实际上可以修改，|

1988
00:50:56,095 --> 00:50:57,925
0,335 475,915 915,1125 1125,1445 1585,1830
you configure the size of
你为不同的表和不同的索引配置数据库页的大小。

1989
00:50:57,925 --> 00:50:59,095
0,105 105,360 360,720 720,960 960,1170
a database page for different

1990
00:50:59,095 --> 00:51:00,680
0,270 270,435 435,615 615,1145
tables and different indexes.|
|

1991
00:51:00,830 --> 00:51:02,305
0,320 320,640 720,1070 1070,1310 1310,1475
And so, depending on what
所以，根据硬件的不同，

1992
00:51:02,305 --> 00:51:03,670
0,165 165,420 420,785 955,1215 1215,1365
your hardware is,| you may
|你可能希望设置大小，

1993
00:51:03,670 --> 00:51:04,560
0,135 135,240 240,375 375,570 570,890
want to set the size,|
|

1994
00:51:04,640 --> 00:51:05,820
0,260 260,440 440,695 695,905 905,1180
the page size of your
B+ 树节点的页面大小不同，

1995
00:51:06,170 --> 00:51:07,890
0,290 290,455 455,590 590,1030 1320,1720
{B+ -} tree nodes differently,|
|

1996
00:51:08,700 --> 00:51:09,960
0,240 240,375 375,570 570,890 970,1260
and so again, the, the
所以，磁盘速度越慢，

1997
00:51:09,960 --> 00:51:11,310
0,225 225,405 405,810 810,1125 1125,1350
slower your disk,| typically the
|通常你想要的页面越大，

1998
00:51:11,310 --> 00:51:12,300
0,210 210,420 420,570 570,735 735,990
larger the page you want,|
|

1999
00:51:12,300 --> 00:51:14,025
0,380 1210,1530 1530,1590 1590,1635 1635,1725
because it's going to be
因为这将更有利于最大化顺序 I/O 。

2000
00:51:14,025 --> 00:51:16,780
0,275 355,755 865,1505 1615,2165
better for maximizing {sequential,I/O}.|
|

2001
00:51:16,960 --> 00:51:17,790
0,230 230,290 290,425 425,605 605,830
So if you're an an
所以，如果你是一个旧的旋转磁盘硬盘，

2002
00:51:17,790 --> 00:51:18,890
0,210 210,480 480,615 615,795 795,1100
old spinning disk hard drive,|
|

2003
00:51:19,180 --> 00:51:20,040
0,260 260,365 365,485 485,665 665,860
you want to page size
你想要页面大小大约为 1 兆字节，

2004
00:51:20,040 --> 00:51:21,720
0,135 135,285 285,465 465,1040 1390,1680
of like 1 megabyte,| now,
|现在，键的数量适应 1 兆字节，

2005
00:51:21,720 --> 00:51:22,455
0,135 135,255 255,390 390,570 570,735
the number of keys will

2006
00:51:22,455 --> 00:51:23,175
0,165 165,360 360,465 465,570 570,720
be that you can fit

2007
00:51:23,175 --> 00:51:24,105
0,150 150,300 300,615 615,780 780,930
on 1 megabyte page,| will
|将被定义你的键的大小，

2008
00:51:24,105 --> 00:51:25,440
0,165 165,485 715,975 975,1140 1140,1335
be defined the size your

2009
00:51:25,440 --> 00:51:26,760
0,180 180,470 820,1065 1065,1170 1170,1320
keys are, right,| if they're
|如果它们都是 8 位整数，

2010
00:51:26,760 --> 00:51:28,010
0,150 150,360 360,495 495,915 915,1250
all 8 bit integers,| then
|那么你可以存储很多它们，

2011
00:51:28,240 --> 00:51:28,875
0,245 245,350 350,455 455,530 530,635
you can store a lot

2012
00:51:28,875 --> 00:51:31,350
0,105 105,335 1285,1575 1575,1865 2185,2475
of them,| probably more, more
|可能比你实际拥有的更多。

2013
00:51:31,350 --> 00:51:32,180
0,150 150,315 315,465 465,570 570,830
than you actually can have.|
|

2014
00:51:33,570 --> 00:51:34,745
0,350 350,635 635,875 875,1040 1040,1175
But for fast {SSD -
但是对于快速的 SSD ，

2015
00:51:34,745 --> 00:51:36,260
0,275 565,915 915,1140 1140,1380 1380,1515
-},| it's roughly 8 to
|它大约是 8 到 10 千字节被认为是合适的大小，

2016
00:51:36,260 --> 00:51:37,940
0,165 165,840 840,1220 1270,1560 1560,1680
10 kilobytes is considered to

2017
00:51:37,940 --> 00:51:39,170
0,120 120,360 360,615 615,920 970,1230
be the right size,| and
|如果你是在内存中，

2018
00:51:39,170 --> 00:51:40,475
0,260 550,795 795,945 945,1050 1050,1305
then if you're in-memory,| 512
|512 个字节被认为是合适的大小，

2019
00:51:40,475 --> 00:51:43,190
0,585 585,1025 1045,1445 1765,2165 2455,2715
-} bytes is, is considered

2020
00:51:43,190 --> 00:51:44,570
0,90 90,500 730,1035 1035,1185 1185,1380
the {right,sizes}| within a cache
|在一个缓存行中，

2021
00:51:44,570 --> 00:51:45,800
0,320 400,690 690,855 855,1020 1020,1230
line,| you keep things very
|你让事情变得非常高效。

2022
00:51:45,800 --> 00:51:46,660
0,320
efficient,

2023
00:51:46,840 --> 00:51:47,980
0,400
right.|
|

2024
00:51:50,720 --> 00:51:52,195
0,275 275,485 485,725 725,1030 1140,1475
We talked about that,| that
我们讨论了，|一些系统实际上可能会违反这一要求，

2025
00:51:52,195 --> 00:51:53,590
0,240 240,495 495,750 750,945 945,1395
some systems can actually violate

2026
00:51:53,590 --> 00:51:55,030
0,320 340,825 825,915 915,1110 1110,1440
that requirement,| that every node
|每个节点都必须是半满的，

2027
00:51:55,030 --> 00:51:56,070
0,165 165,315 315,480 480,720 720,1040
has to be half full,|
|

2028
00:51:56,510 --> 00:51:57,640
0,400 480,740 740,935 935,1025 1025,1130
obviously, you can't go to
显然，你不能更多，

2029
00:51:57,640 --> 00:51:59,155
0,260 820,1095 1095,1170 1170,1335 1335,1515
more,| can't have more keys
|不能拥有比你实际存储的更多的键，

2030
00:51:59,155 --> 00:52:00,160
0,135 135,300 300,495 495,720 720,1005
than you actually store,| because
|因为你的空间用完了，

2031
00:52:00,160 --> 00:52:00,930
0,210 210,315 315,405 405,510 510,770
you run out of space,|
|

2032
00:52:02,320 --> 00:52:04,470
0,260 1000,1260 1260,1380 1380,1640 1750,2150
but you can recognize that,|
但你能认出这个，|

2033
00:52:04,910 --> 00:52:07,100
0,275 275,455 455,760 930,1330
okay, well, most the,|
好的，大部分，|

2034
00:52:07,140 --> 00:52:07,910
0,275 275,380 380,515 515,575 575,770
maybe I don't want to
也许我不想拆分，

2035
00:52:07,910 --> 00:52:09,845
0,350 550,950 1480,1725 1725,1830 1830,1935
split,| or maybe I want
|或者我想一直合并我的节点，

2036
00:52:09,845 --> 00:52:10,655
0,120 120,405 405,525 525,660 660,810
to merge my nodes all

2037
00:52:10,655 --> 00:52:13,730
0,135 135,395 1705,2105 2605,2880 2880,3075
the time| and I can
|这样我就可以暂时低于这个阈值，

2038
00:52:13,730 --> 00:52:16,060
0,240 240,560 700,1035 1035,1670
go below that threshold

2039
00:52:16,340 --> 00:52:17,920
0,580
temporarily,|
|

2040
00:52:17,920 --> 00:52:19,000
0,195 195,405 405,645 645,1005 1005,1080
to see whether something's going
看看是否会插入一些东西，

2041
00:52:19,000 --> 00:52:21,390
0,225 225,480 480,1220 1870,2130 2130,2390
to get inserted| to then
|然后让我超过这个阈值，

2042
00:52:21,440 --> 00:52:22,180
0,260 260,380 380,530 530,650 650,740
put me above of that

2043
00:52:22,180 --> 00:52:23,560
0,390 390,570 570,780 780,1050 1050,1380
threshold| to avoid having to
|以避免过早地这样做。

2044
00:52:23,560 --> 00:52:26,080
0,255 255,390 390,1100
do this prematurely.|
|

2045
00:52:26,570 --> 00:52:27,550
0,275 275,410 410,515 515,665 665,980
Again, this is why Postgres
这就是为什么 Postgres 称他们的平衡，

2046
00:52:27,550 --> 00:52:28,210
0,105 105,195 195,300 300,465 465,660
are going to call their

2047
00:52:28,210 --> 00:52:29,665
0,290 760,1035 1035,1185 1185,1320 1320,1455
balance,| they call their {B+
|他们把他们的 B+ 树称为非平衡 B+ 树，

2048
00:52:29,665 --> 00:52:31,045
0,150 150,360 360,555 555,815 1045,1380
-} tree as a non

2049
00:52:31,045 --> 00:52:34,015
0,315 315,570 570,750 750,1055 2635,2970
balanceed {B+ -} tree,| because
|因为他们可能会违反这个要求。

2050
00:52:34,015 --> 00:52:35,350
0,300 300,525 525,840 840,1050 1050,1335
they can violate this, this

2051
00:52:35,350 --> 00:52:36,380
0,530
requirement.|
|

2052
00:52:38,930 --> 00:52:39,610
0,260 260,395 395,515 515,605 605,680
Next question is,| how do
下一个问题是，|你希望如何处理可变长度键，

2053
00:52:39,610 --> 00:52:40,285
0,60 60,120 120,195 195,390 390,675
you want to handle variable

2054
00:52:40,285 --> 00:52:42,330
0,270 270,605 1315,1560 1560,1725 1725,2045
length keys,| I think somebody
|我想是有人提起了这件事。

2055
00:52:42,380 --> 00:52:44,250
0,260 260,380 380,640 1080,1475 1475,1870
brought this up.| So the,|
|所以，|

2056
00:52:45,430 --> 00:52:46,500
0,290 290,500 500,665 665,860 860,1070
we could sort of try
我们可以试着像一个列存储一样处理它，

2057
00:52:46,500 --> 00:52:47,565
0,260 280,570 570,705 705,825 825,1065
to approach it like a,

2058
00:52:47,565 --> 00:52:48,570
0,210 210,360 360,630 630,870 870,1005
like a column store,| we
|我们希望每个东西都是固定长度的。

2059
00:52:48,570 --> 00:52:49,425
0,210 210,450 450,570 570,675 675,855
want everything to be fixed

2060
00:52:49,425 --> 00:52:51,645
0,305 1585,1830 1830,1965 1965,2115 2115,2220
length.| So one way to
|要做到这个的一种方法是，

2061
00:52:51,645 --> 00:52:52,455
0,120 120,300 300,555 555,735 735,810
do that is| actually you
|实际上你不在每个节点中存储键本身，

2062
00:52:52,455 --> 00:52:53,660
0,195 195,360 360,510 510,785 805,1205
don't store the keys themselves

2063
00:52:53,860 --> 00:52:55,755
0,365 365,590 590,755 755,1300 1560,1895
in in every node,| you
|而是存储一个指向键的指针，比如记录 ID ，

2064
00:52:55,755 --> 00:52:56,775
0,180 180,330 330,750 750,900 900,1020
store a pointer to the

2065
00:52:56,775 --> 00:52:57,860
0,240 240,465 465,585 585,765 765,1085
key, like the record ID,|
|

2066
00:52:58,810 --> 00:52:59,580
0,245 245,485 485,620 620,710 710,770
because that's always going to
因为这将始终是 32 位或 64 位，

2067
00:52:59,580 --> 00:53:00,645
0,135 135,345 345,735 735,885 885,1065
be either 32 bits or

2068
00:53:00,645 --> 00:53:02,020
0,390 390,665
64 bits,

2069
00:53:02,620 --> 00:53:04,380
0,400 810,1145 1145,1340 1340,1550 1550,1760
right.| And actually this, this
|实际上，这也将节省空间，

2070
00:53:04,380 --> 00:53:05,720
0,150 150,390 390,675 675,975 975,1340
will save space, too,| because
|因为，如果我的键都很大，

2071
00:53:05,950 --> 00:53:06,840
0,245 245,380 380,530 530,695 695,890
you know if my keys

2072
00:53:06,840 --> 00:53:08,550
0,150 150,270 270,465 465,800 1390,1710
are all really big,| I'm
|我就不会存储它们，

2073
00:53:08,550 --> 00:53:09,345
0,105 105,270 270,435 435,630 630,795
not gonna store them,| you
|再次， B+ 树是表格中的副本，

2074
00:53:09,345 --> 00:53:10,755
0,245 565,965 985,1230 1230,1305 1305,1410
know can, again, the B

2075
00:53:10,755 --> 00:53:11,760
0,255 255,330 330,450 450,720 720,1005
{B+,tree} is a copy of

2076
00:53:11,760 --> 00:53:13,245
0,240 240,330 330,450 450,710 1210,1485
what's in the table,| I
|我只需存储到指向记录 ID 的指针，

2077
00:53:13,245 --> 00:53:14,010
0,150 150,270 270,405 405,570 570,765
only have to store to

2078
00:53:14,010 --> 00:53:14,775
0,195 195,345 345,600 600,690 690,765
just the pointer to the

2079
00:53:14,775 --> 00:53:16,875
0,150 330,605 985,1305 1305,1625 1825,2100
record ID,| in the, in
|在节点中。

2080
00:53:16,875 --> 00:53:17,900
0,210 210,405 405,570 570,750 750,1025
the, in the, the nodes.|
|

2081
00:53:19,430 --> 00:53:20,185
0,245 245,350 350,440 440,590 590,755
Is that a good idea
这是个好主意还是坏主意？

2082
00:53:20,185 --> 00:53:21,700
0,75 75,165 165,405 405,785
or a bad idea?|
|

2083
00:53:25,280 --> 00:53:26,500
0,180 180,315 315,435 435,710

2084
00:53:26,780 --> 00:53:29,845
0,670 1380,1900 2610,2930 2930,2990 2990,3065
{} {He's,right}, doesn't sound like
他是对的，听起来不是个好主意，

2085
00:53:29,845 --> 00:53:30,700
0,90 90,255 255,480 480,645 645,855
a good idea,| because it
|因为它会导致很多非顺序的 I/O 。

2086
00:53:30,700 --> 00:53:31,495
0,240 240,375 375,480 480,600 600,795
causes a lot of non

2087
00:53:31,495 --> 00:53:33,595
0,330 330,420 420,665 1345,1740 1740,2100
sequential {I/O -}.| Think I'm
|考虑我正在向下遍历我的节点，

2088
00:53:33,595 --> 00:53:35,635
0,390 390,615 615,965 1435,1755 1755,2040
traversing down my my nodes|
|

2089
00:53:35,635 --> 00:53:36,265
0,195 195,270 270,390 390,525 525,630
and I gotta figure out
我必须弄清楚我是向左还是向右，

2090
00:53:36,265 --> 00:53:36,880
0,90 90,210 210,345 345,480 480,615
whether I go left and

2091
00:53:36,880 --> 00:53:37,860
0,260
right,|
|

2092
00:53:37,860 --> 00:53:39,030
0,120 120,285 285,435 435,630 630,1170
I don't have those guideposts
我的节点上没有那些路标，

2093
00:53:39,030 --> 00:53:40,125
0,120 120,255 255,705 705,975 975,1095
in my node,| I got
|我必须沿着指针去获取页面中的那个 tuple ，

2094
00:53:40,125 --> 00:53:41,130
0,75 75,180 180,405 405,630 630,1005
to go follow the pointer

2095
00:53:41,130 --> 00:53:42,200
0,165 165,300 300,450 450,615 615,1070
to go get that tuple

2096
00:53:42,820 --> 00:53:43,875
0,260 260,410 410,650 650,905 905,1055
in that page,| then do
|然后进行查找以找到我需要的东西。

2097
00:53:43,875 --> 00:53:45,375
0,105 105,330 330,420 420,665 1255,1500
the lookup to find what

2098
00:53:45,375 --> 00:53:46,845
0,105 105,365 895,1170 1170,1320 1320,1470
I need.| And again, while
|再次，当我这样做的时候，

2099
00:53:46,845 --> 00:53:47,790
0,180 180,315 315,465 465,690 690,945
I'm doing this,| I'm holding
|我在我的数据结构中持有 latch ，

2100
00:53:47,790 --> 00:53:49,490
0,560 820,1080 1080,1200 1200,1380 1380,1700
latches in my data structure|
|

2101
00:53:49,750 --> 00:53:50,385
0,260 260,470 470,515 515,560 560,635
and that's going to be
这将是非常缓慢的。

2102
00:53:50,385 --> 00:53:51,945
0,195 195,545 715,1035 1035,1260 1260,1560
really slow.| Yeah, so nobody
|是的，所以没人会在数据库系统中这样做。

2103
00:53:51,945 --> 00:53:53,565
0,345 345,695 895,1215 1215,1425 1425,1620
does this in a {database

2104
00:53:53,565 --> 00:53:54,820
0,210 210,515
-} system.|
|

2105
00:53:54,860 --> 00:53:56,005
0,395 395,800 800,890 890,1025 1025,1145
The variant of this of
这种 B+ 树的变体称为 T 树，

2106
00:53:56,005 --> 00:53:56,590
0,90 90,210 210,375 375,495 495,585
{} {B+ -} tree is

2107
00:53:56,590 --> 00:53:59,200
0,165 165,390 390,710 2260,2505 2505,2610
called {T-Trees -},| I figure
|我弄清楚 T 代表什么，

2108
00:53:59,200 --> 00:53:59,890
0,90 90,195 195,375 375,570 570,690
what the T stands for,|
|

2109
00:53:59,890 --> 00:54:00,385
0,75 75,165 165,255 255,375 375,495
I think it stands for
我想这表示这家伙的名字，

2110
00:54:00,385 --> 00:54:02,320
0,105 105,405 405,665
the dude's name,|
|

2111
00:54:03,640 --> 00:54:05,385
0,395 395,650 650,1270 1290,1565 1565,1745
in the diagrams, the nodes
在图表中，节点看起来像 [T] ，

2112
00:54:05,385 --> 00:54:07,425
0,165 165,425 775,1175 1435,1815 1815,2040
look like [Ts],| but I
|但我想电子邮件说的是，

2113
00:54:07,425 --> 00:54:08,250
0,105 105,300 300,540 540,705 705,825
think the email said,| oh
|哦，是的，那个人的名字，但是无论什么。

2114
00:54:08,250 --> 00:54:09,240
0,150 150,285 285,495 495,720 720,990
yes, the guy's name, but

2115
00:54:09,240 --> 00:54:11,820
0,290 1480,1770 1770,1980 1980,2445 2445,2580
whatever.| {In-memory -} databases did
|内存数据库在 80 年代做了这个，

2116
00:54:11,820 --> 00:54:12,870
0,135 135,270 270,390 390,825 825,1050
this in the 80s,| because
|因为他们想要节省空间，

2117
00:54:12,870 --> 00:54:13,695
0,120 120,255 255,390 390,585 585,825
they wanted to save space,|
|

2118
00:54:13,695 --> 00:54:14,445
0,135 135,210 210,285 285,390 390,750
you want to have duplicate
你想在你的 B+ 树上有重复的键，

2119
00:54:14,445 --> 00:54:15,120
0,195 195,360 360,450 450,555 555,675
keys in your, in your

2120
00:54:15,120 --> 00:54:15,780
0,120 120,270 270,420 420,540 540,660
{B+ -} tree,| because they
|因为他们没有太多的内存。

2121
00:54:15,780 --> 00:54:16,185
0,135 135,195 195,255 255,315 315,405
didn't have a lot of

2122
00:54:16,185 --> 00:54:17,460
0,245 445,720 720,885 885,1080 1080,1275
memory.| But again, nobody does
|但再说一次，现在没有人在真正的系统中这样做，

2123
00:54:17,460 --> 00:54:18,900
0,210 210,530 940,1185 1185,1290 1290,1440
this now in a real

2124
00:54:18,900 --> 00:54:20,520
0,290 310,675 675,1050 1050,1365 1365,1620
system,| because it's it's so
|因为执行其他查找的成本太高了，

2125
00:54:20,520 --> 00:54:21,255
0,225 225,360 360,435 435,540 540,735
expensive to do that other

2126
00:54:21,255 --> 00:54:22,305
0,300 300,420 420,615 615,915 915,1050
lookup,| it's just it's easier
|只是复制键更容易。

2127
00:54:22,305 --> 00:54:23,270
0,165 165,330 330,540 540,705 705,965
to just copy the key.|
|

2128
00:54:24,340 --> 00:54:25,545
0,275 275,470 470,680 680,920 920,1205
You could support variable length
你可以支持可变长度节点，

2129
00:54:25,545 --> 00:54:27,560
0,605
nodes,|
|

2130
00:54:27,660 --> 00:54:28,685
0,260 260,410 410,680 680,905 905,1025
or the size of the
或者，节点的大小在索引中可能会有所不同，

2131
00:54:28,685 --> 00:54:30,860
0,435 435,750 750,990 990,1295 1855,2175
node can can vary within

2132
00:54:30,860 --> 00:54:32,390
0,255 255,590 1090,1335 1335,1425 1425,1530
the index| and you have
|你必须这样做，

2133
00:54:32,390 --> 00:54:33,080
0,120 120,255 255,420 420,570 570,690
to do this,| because you
|因为你不知道大小，

2134
00:54:33,080 --> 00:54:34,100
0,240 240,375 375,525 525,780 780,1020
don't know the size of

2135
00:54:34,100 --> 00:54:35,735
0,260 1150,1395 1395,1485 1485,1560 1560,1635
the,| you want to have
|你希望在每个节点中都有相同的潜在数量的键，

2136
00:54:35,735 --> 00:54:36,785
0,105 105,365 415,720 720,900 900,1050
the same potential number of

2137
00:54:36,785 --> 00:54:37,990
0,195 195,360 360,495 495,705 705,1205
keys in every single node,|
|

2138
00:54:38,100 --> 00:54:40,320
0,260 260,455 455,790
but nobody has,|
但是没有人，|

2139
00:54:40,320 --> 00:54:41,580
0,225 225,470 730,975 975,1095 1095,1260
you know, you may not
你可能没有足够的空间在节点中存储所有这些键。

2140
00:54:41,580 --> 00:54:42,945
0,290 520,840 840,1050 1050,1215 1215,1365
have enough space to store

2141
00:54:42,945 --> 00:54:44,070
0,210 210,465 465,690 690,915 915,1125
all those keys within that

2142
00:54:44,070 --> 00:54:46,000
0,470
node.|
|

2143
00:54:46,160 --> 00:54:47,040
0,290 290,440 440,545 545,635 635,880
As far as I know,
据我所知，只有学术系统才会这样做，

2144
00:54:47,420 --> 00:54:48,985
0,400 480,845 845,1160 1160,1370 1370,1565
only academic systems do this,|
|

2145
00:54:48,985 --> 00:54:49,945
0,270 270,495 495,690 690,840 840,960
nobody does this in the
在现实世界中，没有人会这样做。

2146
00:54:49,945 --> 00:54:51,200
0,165 165,455
real world.|
|

2147
00:54:51,240 --> 00:54:52,415
0,455 455,590 590,800 800,1025 1025,1175
Padding is another approach to
填充是处理这个问题的另一种方法，

2148
00:54:52,415 --> 00:54:53,495
0,165 165,485 535,795 795,900 900,1080
handle this,| as we talked
|正如我们之前在列存储中讨论的那样，

2149
00:54:53,495 --> 00:54:54,905
0,270 270,495 495,785 835,1155 1155,1410
before in, in, in column

2150
00:54:54,905 --> 00:54:56,885
0,335 1255,1530 1530,1680 1680,1830 1830,1980
stores,| again, I think this
|再次，我认为这是罕见的，

2151
00:54:56,885 --> 00:54:58,220
0,165 165,455 595,855 855,1050 1050,1335
is rare,| what most people
|大多数人会做的是，

2152
00:54:58,220 --> 00:54:58,970
0,225 225,375 375,510 510,630 630,750
do is that,| they would
|他们基本上会有一个 slot array ，

2153
00:54:58,970 --> 00:55:02,465
0,255 255,650 1270,1670 1750,2150 3040,3495
have a essentially a slot

2154
00:55:02,465 --> 00:55:03,460
0,275
array,|
|

2155
00:55:03,920 --> 00:55:05,770
0,400 450,905 905,1130 1130,1480 1590,1850
a slotted page approach, like
像我们在表页中看到的那样的 slot 页方法，

2156
00:55:05,770 --> 00:55:07,630
0,135 135,315 315,620 1150,1550 1570,1860
we saw in table {},

2157
00:55:07,630 --> 00:55:09,235
0,180 180,470 880,1185 1185,1410 1410,1605
table pages,| where you have
|你有这个指针数组，

2158
00:55:09,235 --> 00:55:10,710
0,270 270,540 540,705 705,1125 1125,1475
this array of pointers within|
|

2159
00:55:11,150 --> 00:55:12,760
0,635 635,830 830,1025 1025,1295 1295,1610
{it's,also} within the page you're
它在你查看的页面中或者另一个溢出页面。

2160
00:55:12,760 --> 00:55:13,975
0,135 135,440 550,840 840,1020 1020,1215
looking at or to another

2161
00:55:13,975 --> 00:55:15,400
0,495 495,785
overflow page.|
|

2162
00:55:15,550 --> 00:55:16,760
0,400

2163
00:55:18,530 --> 00:55:19,975
0,275 275,440 440,730 750,1160 1160,1445
{} And again it's, it's,
再次，怎么说这个，

2164
00:55:19,975 --> 00:55:20,425
0,135 135,180 180,240 240,330 330,450
how do you say this,|
|

2165
00:55:20,425 --> 00:55:21,580
0,315 315,705 705,930 930,1065 1065,1155
it's, it's just like the
它就像我们之前看到的溢出值一样，

2166
00:55:21,580 --> 00:55:22,975
0,465 465,795 795,1020 1020,1155 1155,1395
overflow values we saw before,|
|

2167
00:55:22,975 --> 00:55:24,120
0,210 210,300 300,545
where you just,|
你只是，|

2168
00:55:24,120 --> 00:55:24,945
0,135 135,255 255,390 390,555 555,825
you know, you know that
你知道我要找的东西不是我的页面，

2169
00:55:24,945 --> 00:55:25,620
0,210 210,300 300,435 435,555 555,675
the thing I'm looking for

2170
00:55:25,620 --> 00:55:26,400
0,105 105,255 255,420 420,615 615,780
is not my page,| I
|我得去别的地方去获取它。

2171
00:55:26,400 --> 00:55:26,955
0,90 90,150 150,240 240,390 390,555
got to go somewhere else

2172
00:55:26,955 --> 00:55:28,140
0,120 120,240 240,375 375,635
and go get it.|
|

2173
00:55:30,610 --> 00:55:31,125
0,230 230,305 305,365 365,425 425,515
Now we got to talk
现在我们要谈谈到底如何查找键，

2174
00:55:31,125 --> 00:55:31,770
0,135 135,300 300,465 465,585 585,645
about how we actually want

2175
00:55:31,770 --> 00:55:32,720
0,60 60,180 180,420 420,660 660,950
to go find the keys,|
|

2176
00:55:33,580 --> 00:55:34,825
0,350 550,795 795,930 930,1095 1095,1245
once you know, once we
一旦我们到了节点上，

2177
00:55:34,825 --> 00:55:35,875
0,150 150,255 255,345 345,795 795,1050
land on the node,| we
|我们把它带到内存中，

2178
00:55:35,875 --> 00:55:36,450
0,120 120,195 195,255 255,330 330,575
bring it in a memory|
|

2179
00:55:36,530 --> 00:55:37,420
0,245 245,395 395,590 590,785 785,890
and we're looking for a
我们寻找一个键，决定向左还是向右，

2180
00:55:37,420 --> 00:55:38,095
0,165 165,315 315,405 405,525 525,675
key, decide to go left

2181
00:55:38,095 --> 00:55:39,265
0,135 135,300 300,600 600,960 960,1170
or right,| or whether we
|或者我们是否在叶子节点中找到我们想要的匹配，

2182
00:55:39,265 --> 00:55:39,970
0,120 120,240 240,375 375,570 570,705
have the match we're looking

2183
00:55:39,970 --> 00:55:41,665
0,320 670,945 945,1095 1095,1260 1260,1695
for in our leaf node,|
|

2184
00:55:41,665 --> 00:55:42,690
0,300 300,495 495,645 645,810 810,1025
{we,got} decide how we're going
我们必须决定如何进行匹配。

2185
00:55:42,800 --> 00:55:44,780
0,400 660,950 950,1240
do that match.|
|

2186
00:55:45,030 --> 00:55:46,145
0,260 260,380 380,800 800,1010 1010,1115
So the easiest approach is
所以最简单的方法就是做一个线性扫描。

2187
00:55:46,145 --> 00:55:46,940
0,105 105,270 270,390 390,495 495,795
to just do a linear

2188
00:55:46,940 --> 00:55:48,680
0,320 940,1200 1200,1320 1320,1515 1515,1740
scan.| Just think of an
|考虑一个数组，

2189
00:55:48,680 --> 00:55:50,555
0,290 760,1125 1125,1370 1450,1695 1695,1875
array,| doesn't matter if it's
|无论它是否排序，

2190
00:55:50,555 --> 00:55:51,725
0,120 120,270 270,545 775,1035 1035,1170
sort of not,| I just
|我只是从头开始，

2191
00:55:51,725 --> 00:55:52,775
0,120 120,195 195,300 300,575 805,1050
start at the beginning| and
|一直往看，直到找到我要找的东西，

2192
00:55:52,775 --> 00:55:53,645
0,135 135,330 330,585 585,765 765,870
I scan along until I

2193
00:55:53,645 --> 00:55:54,350
0,165 165,315 315,420 420,555 555,705
find the thing I'm looking

2194
00:55:54,350 --> 00:55:55,100
0,180 180,285 285,405 405,555 555,750
for,| in this case here,
|在这个情况下，我在找键 8 ，

2195
00:55:55,100 --> 00:55:55,990
0,210 210,345 345,525 525,645 645,890
I'm looking for key 8,|
|

2196
00:55:57,365 --> 00:55:58,700
0,135 135,420 645,750 750,1025 1045,1335
it's simple, it's dumb, it
这很简单，这太傻了，这很管用，是吧？

2197
00:55:58,700 --> 00:56:00,740
0,290 970,1370
works, right?|
|

2198
00:56:01,260 --> 00:56:01,820
0,230 230,305 305,380 380,440 440,560
We can do a little
不过，我们可以做得更好一些，

2199
00:56:01,820 --> 00:56:03,965
0,210 210,420 420,615 615,1130 1870,2145
better though,| with SIMD,| actually
|使用 SIMD ，|实际上它是，

2200
00:56:03,965 --> 00:56:05,300
0,390 390,645 645,750 750,995 1015,1335
it,| who here has taken
|在座的谁学过 418/618 ？

2201
00:56:05,300 --> 00:56:06,880
0,180 180,390 390,600 600,860
{418/618 - - -}?|
|

2202
00:56:07,540 --> 00:56:09,600
0,400 540,940 1500,1760 1760,1880 1880,2060
Nobody, okay,| who here doesn't
没有人，好的，|在座的谁不知道 SIMD 是什么？

2203
00:56:09,600 --> 00:56:11,140
0,60 60,180 180,510 510,770
know what SIMD is?|
|

2204
00:56:12,070 --> 00:56:13,425
0,290 290,580 660,935 935,1115 1115,1355
Okay, Okay, {SIMD -} stands
好的，好的， SIMD 代表单指令流多数据流，

2205
00:56:13,425 --> 00:56:14,715
0,315 315,690 690,975 975,1125 1125,1290
for {} single {instruction -}

2206
00:56:14,715 --> 00:56:15,990
0,150 150,315 315,635 835,1140 1140,1275
{} multiple data,| it's a
|这是现代 CPU 上有的一类指令，

2207
00:56:15,990 --> 00:56:17,130
0,240 240,405 405,825 825,1035 1035,1140
class of instructions you can

2208
00:56:17,130 --> 00:56:18,015
0,165 165,330 330,540 540,780 780,885
have on modern {CPU -

2209
00:56:18,015 --> 00:56:19,070
0,150 150,375 375,570 570,765 765,1055
-},| that allow you to
|它允许你有一个向量寄存器，

2210
00:56:19,420 --> 00:56:21,560
0,400 540,875 875,1100 1100,1420 1740,2140
basically have a vector register,|
|

2211
00:56:22,030 --> 00:56:22,710
0,260 260,365 365,455 455,560 560,680
you put a bunch of
你把一堆值放进去，

2212
00:56:22,710 --> 00:56:23,850
0,240 240,465 465,710 760,1020 1020,1140
values in it| and then
|然后有一条指令，在上面做一些事情，

2213
00:56:23,850 --> 00:56:24,900
0,150 150,285 285,495 495,870 870,1050
there's a single instruction to

2214
00:56:24,900 --> 00:56:26,250
0,180 180,500 670,960 960,1170 1170,1350
do, like do something on

2215
00:56:26,250 --> 00:56:27,300
0,120 120,380 490,735 735,855 855,1050
it,| like you can put
|比如你可以把一堆数字放进一个向量，

2216
00:56:27,300 --> 00:56:28,170
0,165 165,270 270,375 375,600 600,870
a bunch of numbers in

2217
00:56:28,170 --> 00:56:29,265
0,180 180,500 610,870 870,990 990,1095
one vector,| a bunch of
|一堆数字和另一个向量，

2218
00:56:29,265 --> 00:56:30,150
0,150 150,315 315,465 465,705 705,885
numbers and another vector| and
|然后把它们加在一起，输出到另一个向量，

2219
00:56:30,150 --> 00:56:31,410
0,260 370,645 645,825 825,1065 1065,1260
do add them together and

2220
00:56:31,410 --> 00:56:32,280
0,165 165,330 330,450 450,645 645,870
the output goes into another

2221
00:56:32,280 --> 00:56:34,035
0,350 760,1080 1080,1260 1260,1545 1545,1755
vector,| we'll cover this when
|我们将在讨论查询执行时讨论这个，

2222
00:56:34,035 --> 00:56:34,850
0,90 90,165 165,255 255,480 480,815
we talk about query execution,|
|

2223
00:56:35,020 --> 00:56:36,075
0,320 320,485 485,560 560,755 755,1055
but this is a very
但这是现代系统中使用的一种非常常见的技术，

2224
00:56:36,075 --> 00:56:37,410
0,240 240,495 495,825 825,1095 1095,1335
common technique used in modern

2225
00:56:37,410 --> 00:56:38,850
0,350 730,990 990,1095 1095,1215 1215,1440
systems,| this is what made
|这就是 10 年前让 Snowflake 变得特别的地方。

2226
00:56:38,850 --> 00:56:40,120
0,405 405,710
snowflake special,

2227
00:56:40,120 --> 00:56:41,220
0,120 120,285 285,590
10 years ago.|
|

2228
00:56:41,720 --> 00:56:43,585
0,400 450,850 1380,1640 1640,1745 1745,1865
{All,right}, so what I can
好的，所以我能做的是，

2229
00:56:43,585 --> 00:56:44,520
0,165 165,390 390,570 570,675 675,935
do is,| instead of doing,
|不是一个接一个地查看每个键，试着找到 8 ，

2230
00:56:44,780 --> 00:56:47,455
0,305 305,485 485,725 725,1090 2340,2675
looking at every single key

2231
00:56:47,455 --> 00:56:48,775
0,240 240,480 480,815 985,1230 1230,1320
one after another, try to

2232
00:56:48,775 --> 00:56:50,545
0,150 150,455 955,1230 1230,1440 1440,1770
find 8,| I can instead
|我可以使用 SIMD 内部函数，

2233
00:56:50,545 --> 00:56:53,275
0,395 1495,1770 1770,2070 2070,2580 2580,2730
use a SIMD intrinsic,| in
|在这个例中，

2234
00:56:53,275 --> 00:56:54,070
0,120 120,270 270,435 435,585 585,795
this case here,| this is
|这是对于 x86 ，

2235
00:56:54,070 --> 00:56:55,560
0,330 330,585 585,1020 1020,1230 1230,1490
for {x86 -}| to do
|在 128 位寄存器上对 32 位整数进行求值。

2236
00:56:56,510 --> 00:56:58,200
0,470 470,815 815,890 890,1325 1325,1690
evaluation {32-bit -} integers on,

2237
00:57:00,030 --> 00:57:01,235
0,275 275,515 515,785 785,950 950,1205
{128-bit - - - -

2238
00:57:01,235 --> 00:57:03,590
0,395 805,1415 1495,1725 1725,1955 2095,2355
-} registers.| So I store,
|所以我查找 8 ，

2239
00:57:03,590 --> 00:57:04,730
0,165 165,270 270,405 405,650 850,1140
I'm looking for 8,| I
|我存储八个（应该是四个） 8 的副本，

2240
00:57:04,730 --> 00:57:05,780
0,195 195,435 435,780 780,885 885,1050
store eight copies of 8|
|

2241
00:57:05,780 --> 00:57:06,905
0,180 180,330 330,540 540,840 840,1125
and my SIMD register has
我的 SIMD 寄存器有 4 个通道，

2242
00:57:06,905 --> 00:57:08,270
0,195 195,515 835,1095 1095,1215 1215,1365
four lanes,| and then now
|现在，在一条指令中，

2243
00:57:08,270 --> 00:57:09,320
0,135 135,240 240,390 390,810 810,1050
in a single instruction,| I
|我可以用数组中的键对这八个 8 或四个 8 求值，

2244
00:57:09,320 --> 00:57:11,380
0,120 120,285 285,480 480,1040 1660,2060
can do an evaluation of

2245
00:57:11,670 --> 00:57:13,265
0,400 600,905 905,1175 1175,1415 1415,1595
those eight 8 or four

2246
00:57:13,265 --> 00:57:14,900
0,480 480,795 795,1080 1080,1395 1395,1635
8 with the keys in

2247
00:57:14,900 --> 00:57:16,220
0,195 195,530 820,1080 1080,1185 1185,1320
my array,| and then I'll
|然后我会得到位 mask ，

2248
00:57:16,220 --> 00:57:17,320
0,75 75,195 195,600 600,810 810,1100
get a {bit,mask},| that says
|如果没有匹配，则为 0 ，

2249
00:57:18,270 --> 00:57:19,330
0,395 395,485 485,680 680,800 800,1060
0 if there's no match,|
|

2250
00:57:19,530 --> 00:57:20,410
0,275 275,395 395,575 575,635 635,880
1, if there's a match.|
如果匹配，则为 1 。|

2251
00:57:20,730 --> 00:57:21,610
0,215 215,260 260,380 380,575 575,880
So in this case here,|
所以在这种情况下，|

2252
00:57:21,630 --> 00:57:22,595
0,260 260,395 395,470 470,605 605,965
now it's a single instruction
现在只有一条指令来进行求值，

2253
00:57:22,595 --> 00:57:24,280
0,225 225,375 375,525 525,1025
to do that evaluation,|
|

2254
00:57:24,280 --> 00:57:24,880
0,210 210,330 330,420 420,495 495,600
and I can do that
我可以用这种方式比一个接一个地做更有效率。

2255
00:57:24,880 --> 00:57:25,795
0,150 150,315 315,675 675,765 765,915
way more efficiently than going

2256
00:57:25,795 --> 00:57:27,100
0,165 165,345 345,665 925,1170 1170,1305
one after another.| In this
|在这种情况下，

2257
00:57:27,100 --> 00:57:28,105
0,210 210,390 390,645 645,885 885,1005
case,| and then for this
|对于这个，我没有匹配，

2258
00:57:28,105 --> 00:57:28,585
0,120 120,195 195,315 315,390 390,480
one, I don't have a

2259
00:57:28,585 --> 00:57:29,185
0,195 195,360 360,420 420,495 495,600
match,| so I got to
|所以我把它滑过去，

2260
00:57:29,185 --> 00:57:30,640
0,150 150,270 270,515 805,1185 1185,1455
slide it over,| do the
|看看下一个，

2261
00:57:30,640 --> 00:57:31,410
0,150 150,240 240,315 315,465 465,770
look at the next one,|
|

2262
00:57:31,580 --> 00:57:32,620
0,230 230,305 305,410 410,670 780,1040
I have to recognize that,
我必须认识到我只有三个键，而不是四个，

2263
00:57:32,620 --> 00:57:33,790
0,135 135,345 345,615 615,870 870,1170
I only have three keys

2264
00:57:33,790 --> 00:57:34,705
0,225 225,390 390,675 675,855 855,915
and not four,| so I
|所以我必须玩一些小把戏来确保，

2265
00:57:34,705 --> 00:57:35,440
0,120 120,255 255,420 420,660 660,735
gotta play little tricks to

2266
00:57:35,440 --> 00:57:36,250
0,105 105,255 255,480 480,675 675,810
make sure,| like I don't
|就像我不会得到假的确定。

2267
00:57:36,250 --> 00:57:36,925
0,90 90,255 255,405 405,510 510,675
end up with a false

2268
00:57:36,925 --> 00:57:38,335
0,305 775,1020 1020,1110 1110,1230 1230,1410
positive.| But in this case
|但在这种情况下，

2269
00:57:38,335 --> 00:57:39,430
0,225 225,480 480,675 675,840 840,1095
here,| now I have 8
|现在我在第一个通道上有 8 等于 8 ，

2270
00:57:39,430 --> 00:57:40,720
0,225 225,500 700,945 945,1080 1080,1290
equals 8 in that first

2271
00:57:40,720 --> 00:57:41,530
0,320 340,570 570,645 645,735 735,810
lane| and I have a
|我有一个匹配。

2272
00:57:41,530 --> 00:57:42,320
0,230
match.|
|

2273
00:57:42,890 --> 00:57:43,495
0,230 230,305 305,395 395,485 485,605
So I can do this
所以我可以更有效地这样做，

2274
00:57:43,495 --> 00:57:44,380
0,165 165,525 525,585 585,690 690,885
more efficiently| and then doing
|然后做这个，

2275
00:57:44,380 --> 00:57:46,170
0,320 670,915 915,1080 1080,1290 1290,1790
this,| it is still linear,|
|它仍然是线性的，|

2276
00:57:46,460 --> 00:57:47,395
0,320 320,590 590,695 695,800 800,935
but I'm doing it in
但我是分批进行的，

2277
00:57:47,395 --> 00:57:48,910
0,515 775,1035 1035,1140 1140,1305 1305,1515
batches| and the hardware can
|硬件可以支持它。

2278
00:57:48,910 --> 00:57:49,880
0,180 180,470
support that.|
|

2279
00:57:52,220 --> 00:57:53,245
0,320 320,530 530,710 710,875 875,1025
Next approach to obviously do
下一个方法，显然是进行二分搜索，

2280
00:57:53,245 --> 00:57:55,090
0,330 330,635 1105,1380 1380,1560 1560,1845
binary search,| assuming it's sorted,
|假设它是排序的，这很容易，

2281
00:57:55,090 --> 00:57:56,035
0,150 150,285 285,560 580,840 840,945
this is easy,| you jump
|你跳到中间，

2282
00:57:56,035 --> 00:57:57,400
0,90 90,180 180,425 925,1200 1200,1365
in the middle,| my value
|我的值大于，

2283
00:57:57,400 --> 00:57:59,820
0,150 150,300 300,590 820,1220 2020,2420
is greater than,| the key
|键大于，小于我要找的那个，

2284
00:57:59,870 --> 00:58:01,000
0,275 275,550 630,920 920,1055 1055,1130
is greater, less than the

2285
00:58:01,000 --> 00:58:01,930
0,60 60,165 165,285 285,590 670,930
one I'm looking for,| I
|我跳到下一边，以此类推，

2286
00:58:01,930 --> 00:58:02,605
0,120 120,225 225,300 300,420 420,675
jump to the next side

2287
00:58:02,605 --> 00:58:03,415
0,225 225,360 360,555 555,705 705,810
and so forth| until I
|直到我找到我匹配的，

2288
00:58:03,415 --> 00:58:05,020
0,120 120,225 225,485 1195,1440 1440,1605
find my match,| then I'm
|然后我就完成了。

2289
00:58:05,020 --> 00:58:05,760
0,230
done.|
|

2290
00:58:05,760 --> 00:58:06,675
0,120 120,240 240,465 465,705 705,915
This is what most systems
这是大多数系统都会做的事情。

2291
00:58:06,675 --> 00:58:09,380
0,195 195,455
will do.|
|

2292
00:58:09,660 --> 00:58:10,535
0,305 305,515 515,680 680,770 770,875
It depends on the hardware
这取决于硬件，

2293
00:58:10,535 --> 00:58:12,320
0,275 925,1155 1155,1260 1260,1635 1635,1785
of,| so in Postgres be
|所以在 Postgres 中是 8 千字节，

2294
00:58:12,320 --> 00:58:13,860
0,135 135,650
8 kilobytes,

2295
00:58:13,860 --> 00:58:15,150
0,270 270,495 495,800 940,1185 1185,1290
right,| but again, the number
|但是同样，你可以在节点中存储的键的数量

2296
00:58:15,150 --> 00:58:15,915
0,120 120,270 270,390 390,525 525,765
of keys you can store

2297
00:58:15,915 --> 00:58:17,055
0,210 210,485 595,975 975,1065 1065,1140
in that node| is going
|取决于键的类型。

2298
00:58:17,055 --> 00:58:17,810
0,75 75,195 195,330 330,480 480,755
to depend on the key,

2299
00:58:17,830 --> 00:58:18,735
0,260 260,485 485,710 710,815 815,905
what the type of the

2300
00:58:18,735 --> 00:58:19,780
0,120 120,395
key is.|
|

2301
00:58:20,640 --> 00:58:21,740
0,215 215,430
All right.|
好的。|

2302
00:58:22,870 --> 00:58:23,955
0,245 245,545 545,755 755,965 965,1085
So, binary search is the
所以，二分搜索是最常见的一种。

2303
00:58:23,955 --> 00:58:25,200
0,120 120,300 300,605
most common one.|
|

2304
00:58:25,570 --> 00:58:26,940
0,400
The,|
这个，|

2305
00:58:27,550 --> 00:58:28,740
0,305 305,500 500,650 650,910 960,1190
you could do this,| I
你可以做这个，|我不认为任何，

2306
00:58:28,740 --> 00:58:30,900
0,105 105,165 165,410 1450,1785 1785,2160
don't think any,| outside academia,
|学术界之外，没有人这样做。

2307
00:58:30,900 --> 00:58:32,535
0,240 240,495 495,800 1330,1560 1560,1635
nobody does this.| You can
|你可以做插值搜索，

2308
00:58:32,535 --> 00:58:34,395
0,165 165,615 615,965 1315,1620 1620,1860
do interpolation search| and this
|这个方法可行，

2309
00:58:34,395 --> 00:58:35,475
0,255 255,450 450,615 615,840 840,1080
works,| if you know there's
|如果你的键中没有间隔，

2310
00:58:35,475 --> 00:58:36,620
0,150 150,450 450,675 675,840 840,1145
no gaps in your keys|
|

2311
00:58:36,910 --> 00:58:38,535
0,260 260,515 515,710 710,860 860,1625
and they're always in monotonically
并且它们总是按单调递增的顺序排列，

2312
00:58:38,535 --> 00:58:39,810
0,240 240,575 775,1035 1035,1155 1155,1275
increasing order,| like if you
|如果你有一个主键，

2313
00:58:39,810 --> 00:58:41,025
0,135 135,285 285,555 555,885 885,1215
have a primary key,| that's
|那就像自动增量值，

2314
00:58:41,025 --> 00:58:43,065
0,245 1135,1395 1395,1560 1560,1770 1770,2040
a like, {} like auto

2315
00:58:43,065 --> 00:58:44,445
0,300 300,575 745,1035 1035,1215 1215,1380
increment value,| like plus one,
|比如加一，加一，加一，

2316
00:58:44,445 --> 00:58:45,285
0,150 150,330 330,510 510,675 675,840
plus one, plus one, plus

2317
00:58:45,285 --> 00:58:47,025
0,275 865,1170 1170,1335 1335,1530 1530,1740
one,| and again I assume
|再次，我假设我没有任何间隔，

2318
00:58:47,025 --> 00:58:47,750
0,105 105,240 240,300 300,420 420,725
I don't have any gaps,|
|

2319
00:58:48,130 --> 00:58:49,170
0,260 260,440 440,545 545,755 755,1040
then it's just simple math|
那么这只是一个简单的数学运算，|

2320
00:58:49,170 --> 00:58:50,865
0,225 225,390 390,680 1030,1410 1410,1695
to figure out exactly within
在我的数组中准确地计算出，

2321
00:58:50,865 --> 00:58:52,335
0,225 225,545 745,1005 1005,1215 1215,1470
my array,| I know the
|我知道最低点，

2322
00:58:52,335 --> 00:58:53,445
0,225 225,450 450,750 750,990 990,1110
low point,| {I,know} the min
|我知道最小值，最大值，

2323
00:58:53,445 --> 00:58:54,290
0,165 165,285 285,345 345,510 510,845
value, {} the max value,|
|

2324
00:58:54,960 --> 00:58:55,935
0,135 135,380 460,735 735,870 870,975
I have know number of
我知道键的数量，

2325
00:58:55,935 --> 00:58:56,895
0,105 105,195 195,270 270,515 715,960
keys that I have| and
|我只需要做一个简单的公式，

2326
00:58:56,895 --> 00:58:57,570
0,105 105,240 240,375 375,495 495,675
I just do a simple

2327
00:58:57,570 --> 00:58:58,545
0,240 240,435 435,615 615,780 780,975
formula like this| to jump
|跳到我需要的偏移量，

2328
00:58:58,545 --> 00:59:00,015
0,285 285,480 480,675 675,1025 1225,1470
exactly to the offset that

2329
00:59:00,015 --> 00:59:01,220
0,105 105,365 595,840 840,975 975,1205
I need| and I'm done.|
|我就完成了。|

2330
00:59:02,160 --> 00:59:03,320
0,275 275,410 410,530 530,890 890,1160
This is the fastest approach,|
这是最快的方法，|

2331
00:59:03,320 --> 00:59:04,610
0,330 330,555 555,855 855,1035 1035,1290
faster than binary search,| faster
比二分搜索快，|比 SIMD 快，

2332
00:59:04,610 --> 00:59:06,545
0,255 255,710 1330,1605 1605,1770 1770,1935
than SIMD,| but again, you
|但是再次，你不能有间隔来做这个。|

2333
00:59:06,545 --> 00:59:07,520
0,210 210,405 405,615 615,720 720,975
have, you can't have gaps

2334
00:59:07,520 --> 00:59:08,720
0,195 195,300 300,560
to do this.|
|

2335
00:59:09,370 --> 00:59:10,540
0,150 150,270 270,560
So, it's rare.|
所以，这是很罕见的。|

2336
00:59:13,160 --> 00:59:14,545
0,245 245,490 690,935 935,1130 1130,1385
We have, we have 20
我们还有 20 分钟来完成所有这些优化，

2337
00:59:14,545 --> 00:59:15,460
0,225 225,465 465,645 645,780 780,915
minutes left to get through

2338
00:59:15,460 --> 00:59:16,660
0,165 165,420 420,855 855,1110 1110,1200
all these optimizations,| let's see
|让我们看看我们能走多远，好吧。

2339
00:59:16,660 --> 00:59:17,260
0,120 120,255 255,360 360,435 435,600
how far we can go,

2340
00:59:17,260 --> 00:59:19,135
0,320 1210,1455 1455,1530 1530,1695 1695,1875
okay.| Some of these should
|其中一些应该是非常明显的，

2341
00:59:19,135 --> 00:59:21,280
0,105 105,315 315,665
be pretty obvious,|
|

2342
00:59:21,350 --> 00:59:22,795
0,400 540,830 830,1145 1145,1310 1310,1445
the, the Pointer {Swizzling -}
Pointer Swizzling 和 Buffered Updates ，

2343
00:59:22,795 --> 00:59:24,610
0,245 325,600 600,945 945,1265 1555,1815
and the Buffered Updates,| those
|这些可能是最重要的。

2344
00:59:24,610 --> 00:59:25,380
0,120 120,240 240,330 330,465 465,770
are probably the most important,|
|

2345
00:59:26,240 --> 00:59:27,280
0,400
{Deduplication,too}.|
Deduplication 也是。|

2346
00:59:27,810 --> 00:59:30,470
0,400 900,1300 1740,2075 2075,2345 2345,2660
{All,right}, so just like in
好的，所以，就像在列存储中一样，

2347
00:59:30,470 --> 00:59:32,210
0,380 400,780 780,1160 1330,1605 1605,1740
a column store,| we should
|我们应该认识到，

2348
00:59:32,210 --> 00:59:33,575
0,260 340,690 690,945 945,1185 1185,1365
recognize that,| the keys that
|将在我们 B+ 树中的键，

2349
00:59:33,575 --> 00:59:34,100
0,105 105,195 195,270 270,390 390,525
are going to be in

2350
00:59:34,100 --> 00:59:35,345
0,195 195,530 580,855 855,1020 1020,1245
our, in our {B+ -}

2351
00:59:35,345 --> 00:59:36,905
0,335 865,1200 1200,1275 1275,1365 1365,1560
tree,| they're going to be
|它们将位于相同的值域中，

2352
00:59:36,905 --> 00:59:37,990
0,195 195,315 315,480 480,735 735,1085
in the same value domain,|
|

2353
00:59:39,270 --> 00:59:40,190
0,260 260,395 395,500 500,710 710,920
because they're all coming from
因为它们都来自相同的属性，

2354
00:59:40,190 --> 00:59:42,395
0,150 150,345 345,630 630,1040 1480,2205
the same, same attributes,| furthermore,
|此外，它们是经过排序的，

2355
00:59:42,395 --> 00:59:43,685
0,405 405,825 825,1005 1005,1110 1110,1290
they're sorted,| which is even
|这对于压缩来说更好。

2356
00:59:43,685 --> 00:59:46,220
0,300 300,525 525,905 1405,1805 2305,2535
better for compression, right.| So
|所以，我们可以利用很多东西，

2357
00:59:46,220 --> 00:59:46,760
0,135 135,180 180,270 270,390 390,540
there's a bunch of things

2358
00:59:46,760 --> 00:59:47,555
0,135 135,225 225,375 375,600 600,795
we can take advantage of|
|

2359
00:59:47,555 --> 00:59:48,815
0,465 465,675 675,810 810,1050 1050,1260
recognizing that the values are
来认识到这些值将非常相似，

2360
00:59:48,815 --> 00:59:50,860
0,75 75,150 150,395 1405,1725 1725,2045
going to be very similar,|
|

2361
00:59:51,360 --> 00:59:52,850
0,400 510,815 815,1025 1025,1220 1220,1490
to, to reduce the size
以减小我们存储的键的大小。

2362
00:59:52,850 --> 00:59:54,755
0,380 1210,1470 1470,1620 1620,1785 1785,1905
of the keys we actually

2363
00:59:54,755 --> 00:59:55,860
0,90 90,210 210,485
have the store.|
|

2364
00:59:55,930 --> 00:59:56,835
0,245 245,335 335,470 470,680 680,905
So in this case here,|
在这种情况下，|

2365
00:59:56,835 --> 00:59:57,450
0,135 135,195 195,300 300,495 495,615
we can do what's called
我们可以进行前缀压缩，

2366
00:59:57,450 --> 00:59:59,240
0,300 300,710 1150,1410 1410,1530 1530,1790
prefix compression,| and we can
|我们可以确定，

2367
00:59:59,410 --> 01:00:00,165
0,335 335,515 515,650 650,695 695,755
identify that,| we're going to
|我们将拥有一组在物理顺序上彼此非常接近的键，

2368
01:00:00,165 --> 01:00:01,050
0,105 105,255 255,435 435,615 615,885
have a bunch of keys

2369
01:00:01,050 --> 01:00:01,605
0,270 270,390 390,435 435,465 465,555
that are going to be

2370
01:00:01,605 --> 01:00:02,480
0,210 210,435 435,540 540,615 615,875
very close to each other

2371
01:00:02,800 --> 01:00:04,485
0,275 275,845 845,1270 1290,1550 1550,1685
in leographical ordering| and they're
|它们将具有重叠的数据部分。

2372
01:00:04,485 --> 01:00:06,150
0,30 30,90 90,240 240,995 1225,1665
going to have overlapping portions

2373
01:00:06,150 --> 01:00:07,560
0,150 150,315 315,590 1000,1275 1275,1410
of of data.| So instead
|所以我们不是存储密钥的完整副本，

2374
01:00:07,560 --> 01:00:08,760
0,105 105,375 375,690 690,1065 1065,1200
of storing complete copies of

2375
01:00:08,760 --> 01:00:10,395
0,135 135,410 910,1245 1245,1470 1470,1635
the keys,| we store the
|我们存储公共前缀，在这里是 rob ，

2376
01:00:10,395 --> 01:00:11,520
0,240 240,675 675,840 840,960 960,1125
common prefix, in this case

2377
01:00:11,520 --> 01:00:13,290
0,210 210,530 1060,1350 1350,1545 1545,1770
here, rob,| and then we
|然后我们存储剩余的后缀，那是唯一的。

2378
01:00:13,290 --> 01:00:14,580
0,240 240,510 510,735 735,930 930,1290
store the the remaining suffix

2379
01:00:14,580 --> 01:00:15,920
0,300 300,510 510,740
that's, that's unique,

2380
01:00:16,400 --> 01:00:17,580
0,380
right.|
|

2381
01:00:18,160 --> 01:00:19,140
0,90 90,225 225,435 615,720 720,980
That's pretty easy, that's nice.|
这很容易，这很好。|

2382
01:00:21,220 --> 01:00:22,230
0,290 290,545 545,755 755,845 845,1010
Next technique is to do
下一项技术是重复数据删除，

2383
01:00:22,230 --> 01:00:24,495
0,650 1390,1635 1635,1800 1800,2055 2055,2265
deduplication| and the idea here
|这里的想法是，

2384
01:00:24,495 --> 01:00:26,010
0,165 165,455 985,1305 1305,1395 1395,1515
is that,| we're going to
|我们将拥有一堆键，

2385
01:00:26,010 --> 01:00:27,820
0,260
have

2386
01:00:27,930 --> 01:00:29,240
0,260 260,410 410,620 620,940 1050,1310
a bunch of keys,| that
|以相同的值结束，

2387
01:00:29,240 --> 01:00:30,280
0,135 135,300 300,480 480,705 705,1040
are end up with the

2388
01:00:31,860 --> 01:00:33,170
0,335 335,665 665,965 965,1130 1130,1310
same value over and over

2389
01:00:33,170 --> 01:00:35,920
0,320 640,975 975,1310
again| in the,
|在相同的节点中，

2390
01:00:35,920 --> 01:00:37,260
0,180 180,470
in the,

2391
01:00:37,260 --> 01:00:38,270
0,120 120,330 330,540 540,705 705,1010
in, in the same nodes|
|

2392
01:00:38,860 --> 01:00:42,045
0,275 275,515 515,1115 1115,1510 2760,3185
and again ignoring the prefix,
再次，忽略前缀，将记录 ID 放在末尾，

2393
01:00:42,045 --> 01:00:44,025
0,255 255,555 555,875 1555,1845 1845,1980
or putting the, putting the

2394
01:00:44,025 --> 01:00:44,870
0,150 150,345 345,495 495,600 600,845
record ID at the end,|
|

2395
01:00:45,130 --> 01:00:46,350
0,260 260,395 395,670 720,995 995,1220
because that one, the system
因为系统知道它做的，

2396
01:00:46,350 --> 01:00:47,280
0,270 270,435 435,585 585,705 705,930
knows that it's doing that,|
|

2397
01:00:47,280 --> 01:00:48,030
0,210 210,330 330,450 450,570 570,750
it can pull that piece,
它可以取出那一块，

2398
01:00:48,030 --> 01:00:49,065
0,210 210,500 670,900 900,960 960,1035
piece out,| but if I
|但如果我有一堆非唯一的键，

2399
01:00:49,065 --> 01:00:49,560
0,75 75,135 135,225 225,345 345,495
have a bunch of non

2400
01:00:49,560 --> 01:00:50,655
0,290 370,675 675,825 825,960 960,1095
unique keys,| that are that
|它们最终将在同一个节点中，

2401
01:00:50,655 --> 01:00:51,540
0,245 325,570 570,645 645,750 750,885
are going to end up

2402
01:00:51,540 --> 01:00:52,900
0,105 105,210 210,375 375,860
in the same node,|
|

2403
01:00:53,240 --> 01:00:54,595
0,350 350,455 455,620 620,935 935,1355
it's just like prefix sorting
这就像前缀排序或前缀压缩，

2404
01:00:54,595 --> 01:00:56,365
0,240 240,540 540,845 1285,1575 1575,1770
or prefix compression,| I just
|我只需存储一次重复的键，

2405
01:00:56,365 --> 01:00:58,135
0,305 415,815 835,1155 1155,1590 1590,1770
store the the duplicate key

2406
01:00:58,135 --> 01:01:00,355
0,305 655,945 945,1170 1170,1505 1765,2220
once,| then have a posting
|然后拥有一个[发布]列表，

2407
01:01:00,355 --> 01:01:01,300
0,165 165,285 285,390 390,660 660,945
list| or a list of
|或与该键对应的所有值的列表，

2408
01:01:01,300 --> 01:01:03,210
0,240 240,590 880,1280 1300,1605 1605,1910
all the values that correspond

2409
01:01:03,260 --> 01:01:04,640
0,230 230,380 380,700
to that key,|
|

2410
01:01:04,640 --> 01:01:05,765
0,225 225,390 495,630 630,870 870,1125
and now I'm only storing
现在我只需存储那个键的一个副本。

2411
01:01:05,765 --> 01:01:06,610
0,180 180,345 345,465 465,570 570,845
one copy of that key,

2412
01:01:08,320 --> 01:01:09,360
0,400
right.|
|

2413
01:01:09,610 --> 01:01:12,320
0,455 455,650 650,950 950,1330
Postgres added this in,
Postgres 添加这个，我想是 Postgres 15 ，

2414
01:01:12,330 --> 01:01:14,000
0,245 245,380 380,670
I think in,

2415
01:01:14,000 --> 01:01:15,140
0,270 270,600 600,840 840,1065 1065,1140
{} Postgres 15,| I think
|我想它是去年发布的，

2416
01:01:15,140 --> 01:01:15,850
0,75 75,165 165,285 285,435 435,710
it came out last year,|
|

2417
01:01:16,200 --> 01:01:17,090
0,275 275,470 470,530 530,650 650,890
and it's a pretty significant
它对你的节点大小有了很大的下降。

2418
01:01:17,090 --> 01:01:19,690
0,240 240,480 480,735 735,1040 2200,2600
drop in size your nodes.|
|

2419
01:01:21,980 --> 01:01:22,760
0,120 120,330 330,540 540,675 675,780

2420
01:01:22,760 --> 01:01:23,585
0,90 90,255 255,435 435,615 615,825

2421
01:01:23,585 --> 01:01:25,000
0,165 165,270 270,510 510,905 1015,1415

2422
01:01:25,080 --> 01:01:26,140
0,305 305,470 470,605 605,770 770,1060

2423
01:01:26,190 --> 01:01:26,780
0,275 275,550

2424
01:01:26,780 --> 01:01:27,575
0,270 270,405 405,480 480,630 630,795
Yeah, so his question is,|
好的，所以他的问题是，|

2425
01:01:27,575 --> 01:01:28,400
0,210 210,390 390,465 465,570 570,825
how, how do we know,
我们怎么知道，

2426
01:01:28,400 --> 01:01:29,585
0,225 225,300 300,435 435,740 820,1185
How do we know that,|
|

2427
01:01:29,585 --> 01:01:31,115
0,225 225,390 390,695 1045,1335 1335,1530
we should interpret what this
我们应该解释这是什么，

2428
01:01:31,115 --> 01:01:32,690
0,305 835,1095 1095,1215 1215,1380 1380,1575
is,| these are values, not
|这些是值，而不是键，

2429
01:01:32,690 --> 01:01:34,055
0,290 760,1020 1020,1140 1140,1260 1260,1365
keys,| this is just a
|这只是一个模型，

2430
01:01:34,055 --> 01:01:36,035
0,165 165,395 475,735 735,1055 1735,1980
{mockup -},| you wouldn't, you
|你不会完全像这样对页面进行排序，

2431
01:01:36,035 --> 01:01:36,920
0,165 165,345 345,585 585,735 735,885
wouldn't sort exactly the page

2432
01:01:36,920 --> 01:01:38,080
0,150 150,410 580,810 810,900 900,1160
like this,| you would have
|显然，你将拥有存储的元素数量的长度，

2433
01:01:38,370 --> 01:01:39,920
0,395 395,920 920,1250 1250,1460 1460,1550
obviously, lengths of the number

2434
01:01:39,920 --> 01:01:41,280
0,75 75,255 255,510 510,770
of elements you're storing,|
|

2435
01:01:41,320 --> 01:01:42,435
0,245 245,365 365,530 530,820 870,1115
just not showing that,| you
不只是显示的这样，|你有其他元数据，

2436
01:01:42,435 --> 01:01:43,485
0,120 120,315 315,810 810,945 945,1050
have additional metadata,| they know
|它们知道偏移量在哪里。

2437
01:01:43,485 --> 01:01:44,760
0,90 90,165 165,420 420,695
where the offsets are.|
|

2438
01:01:47,960 --> 01:01:48,910
0,245 245,365 365,485 485,620 620,950
We can also do suffix
我们还可以进行后缀截断，

2439
01:01:48,910 --> 01:01:51,130
0,470 1090,1380 1380,1665 1665,2010 2010,2220
truncation| and again, because the
|因为内部节点不必是键的完全副本，

2440
01:01:51,130 --> 01:01:52,555
0,180 180,710 850,1215 1215,1320 1320,1425
inner nodes don't have to

2441
01:01:52,555 --> 01:01:53,650
0,105 105,270 270,555 555,975 975,1095
be the exact copies of

2442
01:01:53,650 --> 01:01:54,580
0,120 120,345 345,555 555,720 720,930
the keys,| because those keys
|因为那些键可能不存在于叶子节点中，

2443
01:01:54,580 --> 01:01:55,315
0,150 150,330 330,525 525,645 645,735
might not exist in the

2444
01:01:55,315 --> 01:01:57,175
0,135 135,605 1045,1350 1350,1605 1605,1860
leaf nodes,| we maybe don't
|所以我们可能不必存储整个键，

2445
01:01:57,175 --> 01:01:58,015
0,75 75,225 225,405 405,600 600,840
have to store the entire

2446
01:01:58,015 --> 01:01:58,940
0,335
key,|
|

2447
01:01:59,040 --> 01:02:00,755
0,245 245,410 410,730 960,1355 1355,1715
we just need enough of
我们只需要足够的键前缀，

2448
01:02:00,755 --> 01:02:03,350
0,365 865,1200 1200,1530 1530,1925 2275,2595
the of the key key

2449
01:02:03,350 --> 01:02:05,075
0,480 480,735 735,1350 1350,1560 1560,1725
prefix| to discriminate whether we
|来区分我们需要向左还是向右。

2450
01:02:05,075 --> 01:02:05,780
0,105 105,210 210,360 360,555 555,705
need to go left or

2451
01:02:05,780 --> 01:02:06,600
0,260
right.|
|

2452
01:02:07,250 --> 01:02:08,260
0,245 245,335 335,485 485,725 725,1010
So in this case here,|
所以在这种情况下，|

2453
01:02:08,260 --> 01:02:10,225
0,225 225,465 465,830 850,1520 1690,1965
I have keys abc up
我有键 abc 到 k ，

2454
01:02:10,225 --> 01:02:11,845
0,195 195,480 480,690 690,930 930,1620
to k,| and then lmno
|然后 lmno 到 v ，

2455
01:02:11,845 --> 01:02:13,600
0,365 445,735 735,1025
up to v,|
|

2456
01:02:13,690 --> 01:02:14,880
0,260 260,470 470,710 710,935 935,1190
the only thing that that
在本例中，真正重要的东西是，

2457
01:02:14,880 --> 01:02:16,530
0,240 240,560 1120,1365 1365,1485 1485,1650
really matters in this case

2458
01:02:16,530 --> 01:02:18,030
0,195 195,500 880,1155 1155,1305 1305,1500
here is| say just the
|比如这两个字符串的前三个字符，

2459
01:02:18,030 --> 01:02:19,470
0,320 340,660 660,980 1030,1290 1290,1440
first three characters of both

2460
01:02:19,470 --> 01:02:21,040
0,105 105,225 225,435 435,770
of these two strings,|
|

2461
01:02:21,170 --> 01:02:22,240
0,245 245,380 380,575 575,800 800,1070
so my inner nodes only
所以我的内部节点只需要存储最小前缀，

2462
01:02:22,240 --> 01:02:24,055
0,195 195,330 330,620 1360,1605 1605,1815
need to store the minimum

2463
01:02:24,055 --> 01:02:25,870
0,515 1045,1305 1305,1425 1425,1590 1590,1815
prefix,| that we need to
|我们需要决定是向左还是向右。

2464
01:02:25,870 --> 01:02:26,845
0,320 370,645 645,750 750,840 840,975
decide whether to go left

2465
01:02:26,845 --> 01:02:27,820
0,135 135,395
or right.|
|

2466
01:02:29,780 --> 01:02:30,535
0,215 215,275 275,410 410,590 590,755
And of course, now the
当然，现在的挑战是，

2467
01:02:30,535 --> 01:02:31,830
0,240 240,570 570,840 840,1020 1020,1295
challenge is like,| if I
|如果我插入一个键，

2468
01:02:32,330 --> 01:02:34,225
0,410 410,545 545,820 1560,1805 1805,1895
insert a key,| if I
|如果我插入一个键，

2469
01:02:34,225 --> 01:02:35,860
0,180 180,315 315,510 510,815
insert a key that,|
|

2470
01:02:35,930 --> 01:02:37,045
0,395 395,635 635,785 785,965 965,1115
could you know, could be
可能在它们之间，

2471
01:02:37,045 --> 01:02:38,275
0,195 195,405 405,695 865,1125 1125,1230
in between them,| maybe I
|也许我得回去，获取原始键，

2472
01:02:38,275 --> 01:02:38,845
0,90 90,165 165,255 255,405 405,570
got to go back and

2473
01:02:38,845 --> 01:02:40,200
0,135 135,225 225,405 405,755 955,1355
get the original keys| to
|来决定前缀应该是什么，

2474
01:02:40,250 --> 01:02:41,110
0,275 275,410 410,515 515,725 725,860
decide what the prefix should

2475
01:02:41,110 --> 01:02:43,000
0,260
be,|
|

2476
01:02:43,000 --> 01:02:44,485
0,240 240,450 450,645 645,1130 1210,1485
but in some environments, this
但在某些环境中，这可能是正确的。

2477
01:02:44,485 --> 01:02:45,210
0,135 135,225 225,300 300,435 435,725
might be the right thing.|
|

2478
01:02:48,970 --> 01:02:50,745
0,400 810,1265 1265,1550 1550,1655 1655,1775
So, Pointer Swizzling is a
所以， Pointer Swizzling 是一种常见的技术，

2479
01:02:50,745 --> 01:02:51,840
0,210 210,545 625,945 945,1005 1005,1095
common technique,| that's going to
|它将允许我们最大限度地减少查找量，

2480
01:02:51,840 --> 01:02:53,420
0,165 165,405 405,740
allow us to

2481
01:02:54,290 --> 01:02:56,545
0,670 810,1115 1115,1415 1415,1805 1805,2255
minimize the amount of lookup,|
|

2482
01:02:56,545 --> 01:02:57,370
0,150 150,285 285,450 450,645 645,825
we have to do in
我们必须在缓冲池页表中所做的。

2483
01:02:57,370 --> 01:02:58,530
0,135 135,390 390,570 570,825 825,1160
our buffer pool page table.|
|

2484
01:02:59,510 --> 01:03:01,165
0,335 335,670 870,1220 1220,1475 1475,1655
Because again, when we are
因为同样，当我们遍历节点，遍历树结构时，

2485
01:03:01,165 --> 01:03:02,500
0,420 420,555 555,930 930,1035 1035,1335
traversing the nodes, or traversing

2486
01:03:02,500 --> 01:03:03,920
0,120 120,285 285,590
the tree structure,|
|

2487
01:03:04,910 --> 01:03:05,770
0,245 245,350 350,500 500,680 680,860
what I keep calling a,
我一直叫做指针，

2488
01:03:05,770 --> 01:03:07,840
0,290 580,1160 1270,1605 1605,1815 1815,2070
{} pointers,| they're really page
|它们实际上是页面 ID 。

2489
01:03:07,840 --> 01:03:09,000
0,530
IDs.|
|

2490
01:03:09,000 --> 01:03:09,405
0,105 105,165 165,255 255,330 330,405
So I got to go
所以我要去页面表说，

2491
01:03:09,405 --> 01:03:10,080
0,75 75,165 165,360 360,555 555,675
to the page table and

2492
01:03:10,080 --> 01:03:11,100
0,195 195,405 405,630 630,855 855,1020
say,| okay, well, if this
|好的，如果这个页面存在，

2493
01:03:11,100 --> 01:03:12,105
0,255 255,540 540,720 720,870 870,1005
page exists,| give me, give
|给我指向它的指针。

2494
01:03:12,105 --> 01:03:13,290
0,120 120,395 535,810 810,1080 1080,1185
me the, the pointer to

2495
01:03:13,290 --> 01:03:14,000
0,230
it,

2496
01:03:14,070 --> 01:03:15,240
0,400
right.|
|

2497
01:03:15,450 --> 01:03:16,025
0,230 230,290 290,395 395,500 500,575
So if I want to
所以，如果我想说查找大于 3 的键，

2498
01:03:16,025 --> 01:03:17,495
0,165 165,480 480,875 895,1215 1215,1470
say find keys greater than

2499
01:03:17,495 --> 01:03:19,010
0,335 745,1035 1035,1200 1200,1350 1350,1515
3,| I started my root
|我从这里的根节点开始，

2500
01:03:19,010 --> 01:03:21,440
0,225 225,500 1390,1790 1840,2205 2205,2430
node here| and I look
|我查看键，

2501
01:03:21,440 --> 01:03:22,220
0,90 90,195 195,360 360,555 555,780
at the keys| and decide
|并决定是否要向左和向右移动，

2502
01:03:22,220 --> 01:03:22,730
0,180 180,285 285,360 360,420 420,510
whether I want to go

2503
01:03:22,730 --> 01:03:23,345
0,135 135,270 270,405 405,510 510,615
left and right,| in this
|在这种情况下，我想向左，

2504
01:03:23,345 --> 01:03:24,190
0,150 150,330 330,495 495,600 600,845
case here, I want to

2505
01:03:25,080 --> 01:03:26,400
0,290 290,580
go left,|
|

2506
01:03:26,400 --> 01:03:28,130
0,195 195,390 390,710 1180,1455 1455,1730
but then the, the value
但是，这个节点中的值将是页码，

2507
01:03:28,210 --> 01:03:29,595
0,395 395,710 710,995 995,1190 1190,1385
in this node here is

2508
01:03:29,595 --> 01:03:31,020
0,120 120,225 225,485 985,1260 1260,1425
going to be the page

2509
01:03:31,020 --> 01:03:32,550
0,180 180,345 345,570 570,920 1270,1530
number,| so page #2,| so
|所以页 #2 ，|现在我要去我的缓冲池，

2510
01:03:32,550 --> 01:03:32,955
0,90 90,180 180,270 270,330 330,405
now I got to go

2511
01:03:32,955 --> 01:03:33,660
0,120 120,255 255,510 510,600 600,705
down my buffer pool| and
|然后说，好的，给我指向页 #2 的指针，

2512
01:03:33,660 --> 01:03:34,905
0,225 225,495 495,660 660,920 1000,1245
say, okay, give me, give

2513
01:03:34,905 --> 01:03:36,090
0,225 225,480 480,795 795,960 960,1185
me the pointer to page

2514
01:03:36,090 --> 01:03:36,980
0,350
#2,|
|

2515
01:03:37,360 --> 01:03:38,940
0,580 750,1010 1010,1115 1115,1295 1295,1580
likewise on the bottom here,|
同样在底部，|

2516
01:03:38,940 --> 01:03:39,920
0,225 225,330 330,420 420,630 630,980
I want to scan along
我想沿着兄弟节点扫描，

2517
01:03:39,940 --> 01:03:41,790
0,275 275,455 455,1000 1440,1715 1715,1850
the sibling nodes,| go from
|从页 #2 转到页 #3 ，

2518
01:03:41,790 --> 01:03:42,680
0,165 165,315 315,405 405,570 570,890
page #2 to page #3,|
|

2519
01:03:42,730 --> 01:03:43,305
0,260 260,350 350,395 395,455 455,575
I got to go back
我必须回到缓冲池。

2520
01:03:43,305 --> 01:03:44,600
0,105 105,180 180,390 390,635
to the buffer pool.|
|

2521
01:03:45,330 --> 01:03:46,700
0,245 245,350 350,610 960,1250 1250,1370
So the technique, the idea
所以这个技术， Pointer Swizzling 的想法是，

2522
01:03:46,700 --> 01:03:47,830
0,135 135,480 480,780 780,885 885,1130
of Pointer Swizzling is that,|
|

2523
01:03:48,500 --> 01:03:49,570
0,135 135,330 330,570 570,780 780,1070
if you pin the page
如果你将页固定在缓冲池中，

2524
01:03:49,620 --> 01:03:51,125
0,245 245,350 350,590 590,850 1200,1505
in the buffer pool,| say
|比如这个页不能被驱逐，

2525
01:03:51,125 --> 01:03:53,435
0,225 225,545 1075,1425 1425,1775 2005,2310
this page cannot be cannot

2526
01:03:53,435 --> 01:03:54,760
0,150 150,485
be evicted,|
|

2527
01:03:54,770 --> 01:03:57,340
0,400 750,1150 1680,2045 2045,2315 2315,2570
then any, any page that
然后，任何指向你固定的页面的页面，

2528
01:03:57,340 --> 01:03:58,840
0,315 315,540 540,800 970,1290 1290,1500
points to that page you

2529
01:03:58,840 --> 01:03:59,830
0,440 520,750 750,825 825,900 900,990
pinned| you have to be
|你也必须固定，

2530
01:03:59,830 --> 01:04:02,455
0,225 225,500 1510,1875 1875,2240 2260,2625
pinned too,| you replace its
|你将其内容替换为内存中的实际指针，

2531
01:04:02,455 --> 01:04:04,270
0,540 540,825 825,1050 1050,1335 1335,1815
contents with the actual pointer

2532
01:04:04,270 --> 01:04:05,460
0,240 240,560
in memory,|
|

2533
01:04:06,870 --> 01:04:07,865
0,260 260,395 395,635 635,845 845,995
and so now when I'm,
所以现在当我扫描，当我遍历我的树时，

2534
01:04:07,865 --> 01:04:08,645
0,90 90,285 285,525 525,630 630,780
when I'm scanning, when I'm,

2535
01:04:08,645 --> 01:04:09,850
0,75 75,420 420,750 750,900 900,1205
you know, traversing my tree,|
|

2536
01:04:10,020 --> 01:04:10,865
0,350 350,485 485,650 650,755 755,845
I'm not going to the
我不会去缓冲池说，

2537
01:04:10,865 --> 01:04:11,690
0,225 225,330 330,420 420,600 600,825
buffer pool to say,| go
|去做这个，帮我查找这个页，

2538
01:04:11,690 --> 01:04:12,260
0,120 120,210 210,345 345,480 480,570
do this, look up for

2539
01:04:12,260 --> 01:04:13,550
0,90 90,195 195,315 315,590 1000,1290
me, for this page,| I
|我有我寻找的东西。

2540
01:04:13,550 --> 01:04:14,540
0,195 195,360 360,585 585,855 855,990
had the thing exactly what

2541
01:04:14,540 --> 01:04:15,660
0,105 105,255 255,590
I'm looking for.|
|

2542
01:04:15,700 --> 01:04:16,650
0,260 260,425 425,605 605,755 755,950
So, thing like the root
所以，像根节点一样，

2543
01:04:16,650 --> 01:04:18,000
0,495 495,855 855,1035 1035,1200 1200,1350
node,| everyone's always going to
|每个都会去你的 B+ 树，然后说，

2544
01:04:18,000 --> 01:04:19,200
0,260 460,735 735,870 870,1005 1005,1200
that in your {B+ -}

2545
01:04:19,200 --> 01:04:20,625
0,320 700,990 990,1170 1170,1305 1305,1425
tree and say,| and then
|然后它们总是会下到下一层，

2546
01:04:20,625 --> 01:04:21,285
0,255 255,405 405,495 495,555 555,660
they're always going to go

2547
01:04:21,285 --> 01:04:22,170
0,195 195,390 390,555 555,705 705,885
down to the the next

2548
01:04:22,170 --> 01:04:23,640
0,320 820,1110 1110,1245 1245,1350 1350,1470
level,| so instead of having
|所以，不必在缓冲池中进行页面查找，

2549
01:04:23,640 --> 01:04:25,155
0,90 90,240 240,560 670,1020 1020,1515
to do page page lookups

2550
01:04:25,155 --> 01:04:26,560
0,150 150,240 240,465 465,725
in the buffer pool,|
|

2551
01:04:26,560 --> 01:04:27,235
0,225 225,360 360,465 465,555 555,675
would get down the next
会进入下一级，

2552
01:04:27,235 --> 01:04:28,530
0,275 385,645 645,765 765,900 900,1295
level,| I have the pointer
|我有知道直接去哪里的指针。

2553
01:04:28,670 --> 01:04:29,650
0,245 245,365 365,620 620,845 845,980
to know where to go

2554
01:04:29,650 --> 01:04:30,620
0,290
directly.|
|

2555
01:04:31,770 --> 01:04:32,795
0,320 320,560 560,740 740,950 950,1025
And obviously, you don't want
显然，你不希望将这个指针存储在磁盘上，

2556
01:04:32,795 --> 01:04:34,295
0,135 135,315 315,510 510,995 1165,1500
to store this pointer on

2557
01:04:34,295 --> 01:04:35,690
0,545 745,990 990,1110 1110,1260 1260,1395
disk,| you know, if the
|如果页面被刷新，

2558
01:04:35,690 --> 01:04:36,815
0,165 165,375 375,735 735,915 915,1125
page gets flushed,| because now
|因为现在你重新加载它，

2559
01:04:36,815 --> 01:04:37,670
0,270 270,450 450,540 540,675 675,855
you load it back in,|
|

2560
01:04:37,670 --> 01:04:38,375
0,135 135,210 210,330 330,600 600,705
you have this pointer that
你就会得到这个指针，它不会指向任何地方，

2561
01:04:38,375 --> 01:04:39,620
0,120 120,315 315,635
goes to nowhere,|
|

2562
01:04:39,620 --> 01:04:40,280
0,120 120,225 225,315 315,420 420,660
and that would be bad,|
这将是糟糕的，|

2563
01:04:40,280 --> 01:04:41,255
0,255 255,465 465,810 810,885 885,975
so there's bookkeeping you have
所以你必须做记账，

2564
01:04:41,255 --> 01:04:41,915
0,75 75,180 180,285 285,405 405,660
to do| to make sure,|
|以确保，|

2565
01:04:41,915 --> 01:04:44,020
0,365 1135,1440 1440,1530 1530,1650 1650,2105
okay, you're going to disk
好的，你要去磁盘，取消这个交换，

2566
01:04:44,220 --> 01:04:47,000
0,575 575,940 1320,1870 2370,2630 2630,2780
undo this swizzle, what got

2567
01:04:47,000 --> 01:04:49,265
0,410 1690,1935 1935,2055 2055,2175 2175,2265
swizzled| to make sure that
|以确保没有人指向它，

2568
01:04:49,265 --> 01:04:50,435
0,195 195,450 450,585 585,815 925,1170
nobody points to it,| and
|然后也是，

2569
01:04:50,435 --> 01:04:51,900
0,195 195,435 435,725
then also, too,|
|

2570
01:04:51,900 --> 01:04:53,140
0,380

2571
01:04:54,200 --> 01:04:55,960
0,275 275,620 620,910 1410,1640 1640,1760
you don't want, you know,
你不想这个页面被驱逐，

2572
01:04:55,960 --> 01:04:56,965
0,135 135,300 300,480 480,765 765,1005
you don't want this page

2573
01:04:56,965 --> 01:04:58,240
0,135 135,210 210,575 865,1140 1140,1275
to get evicted,| this thing
|这个东西有一个交换指针，

2574
01:04:58,240 --> 01:04:59,215
0,120 120,240 240,525 525,855 855,975
have a swizzle pointer| and
|现在它指向一些其他页面，

2575
01:04:59,215 --> 01:04:59,950
0,120 120,300 300,450 450,615 615,735
now it's pointing to some

2576
01:04:59,950 --> 01:05:01,375
0,195 195,530 730,1005 1005,1185 1185,1425
other page,| that got swapped
|交换到 frame 中，

2577
01:05:01,375 --> 01:05:02,845
0,180 180,360 360,665 1075,1335 1335,1470
in that frame| and does
|它不是 B+ 树的一部分，

2578
01:05:02,845 --> 01:05:03,610
0,120 120,300 300,495 495,645 645,765
it, and, and it's not

2579
01:05:03,610 --> 01:05:04,300
0,135 135,195 195,240 240,345 345,690
part of the {B+,tree -}|
|

2580
01:05:04,300 --> 01:05:04,720
0,135 135,210 210,270 270,330 330,420
and then you would have
然后你会有一个段错误，

2581
01:05:04,720 --> 01:05:05,680
0,120 120,270 270,560 610,855 855,960
a seg fault,| because it
|因为它开始解释字节，

2582
01:05:05,680 --> 01:05:07,150
0,195 195,510 510,795 795,1070 1210,1470
starts interpreting bytes that that

2583
01:05:07,150 --> 01:05:08,410
0,120 120,380 490,795 795,1080 1080,1260
it should,| starts interpreting bytes
|开始以它应该解释的方式来解释字节。

2584
01:05:08,410 --> 01:05:08,800
0,60 60,120 120,210 210,300 300,390
in a way that it

2585
01:05:08,800 --> 01:05:09,520
0,260
should.|
|

2586
01:05:10,340 --> 01:05:11,560
0,395 395,635 635,785 785,1010 1010,1220
So the reason why I
所以我之所以为 B+ 树讨论这个，

2587
01:05:11,560 --> 01:05:12,130
0,150 150,255 255,375 375,495 495,570
talk about this for the

2588
01:05:12,130 --> 01:05:13,030
0,120 120,330 330,525 525,690 690,900
{B+ -} tree| and not
|而不是哈希表的东西，

2589
01:05:13,030 --> 01:05:13,975
0,180 180,300 300,555 555,750 750,945
for the hash table stuff|
|

2590
01:05:13,975 --> 01:05:15,235
0,135 135,315 315,635 835,1080 1080,1260
or not for the regular
或者不是常规的堆的东西，

2591
01:05:15,235 --> 01:05:16,705
0,270 270,435 435,725 1015,1305 1305,1470
heap stuff,| is because we
|是因为我们在这里的树结构中已经有了这个层次结构，

2592
01:05:16,705 --> 01:05:18,400
0,165 165,330 330,480 480,1145 1405,1695
already have this hierarchy in

2593
01:05:18,400 --> 01:05:19,915
0,180 180,360 360,600 600,950 1240,1515
our tree structure here,| we
|我们会知道，如果我们交换我们下面的任何东西，

2594
01:05:19,915 --> 01:05:20,800
0,165 165,375 375,540 540,645 645,885
would know that if we

2595
01:05:20,800 --> 01:05:23,635
0,590 1570,1845 1845,2070 2070,2420 2590,2835
swizzle anything below us,| we
|我们想要确保这个东西不会被取消固定，

2596
01:05:23,635 --> 01:05:24,430
0,105 105,210 210,375 375,585 585,795
want to make sure that

2597
01:05:24,430 --> 01:05:26,460
0,225 225,405 405,690 690,950 1180,2030
this thing doesn't get unpinned,|
|

2598
01:05:26,960 --> 01:05:27,940
0,305 305,515 515,680 680,890 890,980
that this thing doesn't get
这个东西不会被取消固定，

2599
01:05:27,940 --> 01:05:30,235
0,645 645,1040 1570,1905 1905,2145 2145,2295
unpinned,| before its children get
|在它的子节点被取消固定之前，

2600
01:05:30,235 --> 01:05:31,140
0,515
unpinned,|
|

2601
01:05:31,140 --> 01:05:31,980
0,225 225,330 330,450 450,585 585,840
and that way, the pointers
这样，指针总是有效的。

2602
01:05:31,980 --> 01:05:33,280
0,135 135,285 285,560
are always valid.|
|

2603
01:05:37,790 --> 01:05:39,055
0,305 305,485 485,680 680,1000 1020,1265
Right, this thing again,| when
好的，又是这个东西，|当你在做项目 #1 时，

2604
01:05:39,055 --> 01:05:40,200
0,165 165,390 390,555 555,810 810,1145
you you're building project #1,|
|

2605
01:05:40,460 --> 01:05:41,245
0,275 275,410 410,545 545,665 665,785
this thing, all the work
这个东西，你要做的所有工作都要，去查看页面，

2606
01:05:41,245 --> 01:05:42,100
0,105 105,195 195,285 285,515 565,855
you have to go, do

2607
01:05:42,100 --> 01:05:42,955
0,135 135,315 315,555 555,720 720,855
to go, go look on

2608
01:05:42,955 --> 01:05:43,675
0,135 135,315 315,480 480,585 585,720
the page,| you will go
|你会找到你要找的东西，

2609
01:05:43,675 --> 01:05:44,365
0,150 150,270 270,375 375,525 525,690
find the thing you're looking

2610
01:05:44,365 --> 01:05:45,385
0,225 225,390 390,660 660,810 810,1020
for,| the frame, not there,|
|frame ，不在那里，|

2611
01:05:45,385 --> 01:05:46,375
0,150 150,300 300,480 480,765 765,990
and then go evict something,
然后去驱逐一些东西，

2612
01:05:46,375 --> 01:05:47,785
0,335 535,870 870,1095 1095,1260 1260,1410
right,| you skip all of
|你可以跳过所有这些，

2613
01:05:47,785 --> 01:05:48,620
0,245
that,|
|

2614
01:05:48,660 --> 01:05:50,270
0,400 540,940 1110,1370 1370,1475 1475,1610
{} you update the {LRU-K
你更新 LRU-K 的东西，

2615
01:05:50,270 --> 01:05:51,410
0,180 180,420 420,735 735,975 975,1140
- -} stuff, right,| you
|你跳过所有这些，

2616
01:05:51,410 --> 01:05:52,115
0,165 165,285 285,405 405,540 540,705
skip all of that,| by
|只需直接转到指针。

2617
01:05:52,115 --> 01:05:53,120
0,150 150,360 360,645 645,870 870,1005
just going directly through the

2618
01:05:53,120 --> 01:05:54,100
0,380
pointers.|
|

2619
01:05:54,140 --> 01:05:54,835
0,230 230,290 290,380 380,515 515,695
But of course, you lose
当然，你会丢失访问模式的元数据，

2620
01:05:54,835 --> 01:05:56,080
0,165 165,600 600,795 795,1050 1050,1245
the metadata of the access

2621
01:05:56,080 --> 01:05:58,225
0,285 285,680 1240,1515 1515,1790 1840,2145
patterns| for how these pages
|有关如何使用这些页面，

2622
01:05:58,225 --> 01:05:59,515
0,150 150,300 300,605 835,1125 1125,1290
are being used,| but again,
|但同样，如果它足够重要，可以将其固定和交换，

2623
01:05:59,515 --> 01:06:00,850
0,105 105,315 315,495 495,785 1045,1335
if it's important enough to

2624
01:06:00,850 --> 01:06:01,800
0,165 165,285 285,450 450,735 735,950
pin it and swizzle it,|
|

2625
01:06:02,060 --> 01:06:03,430
0,400 540,845 845,1055 1055,1250 1250,1370
then you probably should stay
那么你可能应该留在内存中。

2626
01:06:03,430 --> 01:06:04,400
0,90 90,350
in memory.|
|

2627
01:06:07,890 --> 01:06:09,970
0,400 450,695 695,940 1260,1820 1820,2080
Right to do inserts quickly.
快速插入的权利。最常见的技巧是对所有内容进行预分类，我们将在下周讨论这一点。您可以对关键字进行排序，并将它们作为叶节点进行布局。

2628
01:06:10,380 --> 01:06:11,570
0,380 380,605 605,740 740,980 980,1190
The the most common trick

2629
01:06:11,570 --> 01:06:13,145
0,120 120,380 520,825 825,1130 1180,1575
is to pre sort everything,

2630
01:06:13,145 --> 01:06:15,820
0,255 255,420 420,665 2065,2370 2370,2675
which we'll cover next week.

2631
01:06:16,740 --> 01:06:17,710
0,275 275,425 425,560 560,695 695,970
You sort out your keys

2632
01:06:18,150 --> 01:06:19,100
0,260 260,440 440,635 635,755 755,950
and just lay them out

2633
01:06:19,100 --> 01:06:20,800
0,270 270,510 510,1040
as leaf nodes.|
|

2634
01:06:20,800 --> 01:06:21,880
0,225 225,360 360,465 465,705 705,1080
Right with your sibling pointers,
使用兄弟指针，然后自下而上构建数据结构。

2635
01:06:21,880 --> 01:06:23,590
0,210 210,435 435,780 780,1160 1360,1710
and then build the data

2636
01:06:23,590 --> 01:06:24,865
0,330 330,645 645,855 855,1080 1080,1275
structure from the bottom to

2637
01:06:24,865 --> 01:06:25,920
0,120 120,395
the top.|
|

2638
01:06:26,160 --> 01:06:27,320
0,400
Right.|
正确的。|

2639
01:06:27,320 --> 01:06:28,250
0,75 75,180 180,300 300,560 670,930
And this is different. If
这一次不同。如果我一个接一个地插入钥匙，我就会从上面开始，然后从下到下，开始所有的钥匙，以此类推。跳过所有的东西，在上面搭建脚手架。

2640
01:06:28,250 --> 01:06:30,095
0,260 940,1185 1185,1470 1470,1650 1650,1845
I just insert the keys

2641
01:06:30,095 --> 01:06:30,935
0,135 135,270 270,510 510,705 705,840
one after another, I would

2642
01:06:30,935 --> 01:06:32,165
0,165 165,300 300,420 420,695 955,1230
start from the top and

2643
01:06:32,165 --> 01:06:33,635
0,165 165,405 405,675 675,995 1195,1470
go down and start all

2644
01:06:33,635 --> 01:06:35,270
0,345 345,480 480,630 630,905 1345,1635
theits and so forth. Skip

2645
01:06:35,270 --> 01:06:38,120
0,1080 1080,1370 2080,2355 2355,2490 2490,2850
allort things, build the scaffolding

2646
01:06:38,120 --> 01:06:39,360
0,90 90,210 210,315 315,560
on top of it.|
|

2647
01:06:41,430 --> 01:06:43,040
0,400 450,755 755,1060 1170,1445 1445,1610
And this technique is very
而且这种技术也很常见。

2648
01:06:43,040 --> 01:06:44,320
0,180 180,330 330,590
common as well.|
|

2649
01:06:47,210 --> 01:06:48,120
0,245 245,425 425,590 590,665 665,910
All right, so the last
好了，我想谈的最后一个优化是。

2650
01:06:48,260 --> 01:06:48,940
0,380 380,470 470,530 530,590 590,680
optimization I want to talk

2651
01:06:48,940 --> 01:06:50,600
0,240 240,620
about is.|
|

2652
01:06:52,440 --> 01:06:53,405
0,230 230,425 425,665 665,815 815,965
You know, we make a
你知道，我们很看重怎么做。

2653
01:06:53,405 --> 01:06:56,280
0,195 195,515 1105,1485 1485,1865
big deal about how.|
|

2654
01:06:56,480 --> 01:06:57,310
0,245 245,395 395,590 590,740 740,830
The nice thing about the
B+树的好处在于它是平衡的。所有东西都是logn，我们的查找可以非常快，因为同样，所有东西都是logn，以获得叶节点，然后我们可以尝试获得尽可能多的顺序访问顺序io。

2655
01:06:57,310 --> 01:06:58,210
0,135 135,360 360,615 615,795 795,900
b plus tree is that

2656
01:06:58,210 --> 01:06:59,605
0,225 225,710 730,1080 1080,1215 1215,1395
it's balanced. Everything's always log

2657
01:06:59,605 --> 01:07:02,410
0,305 1525,1925 1945,2295 2295,2685 2685,2805
n and our lookup can

2658
01:07:02,410 --> 01:07:04,590
0,90 90,270 270,590 700,1100 1780,2180
be really fast because again,

2659
01:07:05,240 --> 01:07:06,010
0,320 320,440 440,590 590,680 680,770
everything's log n to get

2660
01:07:06,010 --> 01:07:06,790
0,105 105,240 240,495 495,600 600,780
the leaf node and then

2661
01:07:06,790 --> 01:07:07,375
0,180 180,315 315,435 435,510 510,585
we can try to get

2662
01:07:07,375 --> 01:07:08,550
0,90 90,210 210,600 600,855 855,1175
as much sequential access as

2663
01:07:08,600 --> 01:07:09,660
0,380 380,575 575,680 680,800 800,1060
sequential io as we can.|
|

2664
01:07:10,810 --> 01:07:12,080
0,400
But.|
但。|

2665
01:07:12,080 --> 01:07:12,890
0,105 105,225 225,375 375,600 600,810
Of course, the challenge is
当然，挑战是，更新对我们来说将是昂贵的，因为我们必须保持这种平衡，这种平衡属性。当线程出现并插入或删除时，它们可能会吃亏，并负责重新组织整个数据结构。

2666
01:07:12,890 --> 01:07:14,210
0,260 730,1035 1035,1200 1200,1275 1275,1320
that updates are going to

2667
01:07:14,210 --> 01:07:15,395
0,150 150,420 420,615 615,855 855,1185
be expensive for us because

2668
01:07:15,395 --> 01:07:16,175
0,180 180,270 270,345 345,540 540,780
we have to maintain this

2669
01:07:16,175 --> 01:07:19,985
0,275 1075,1470 1470,1865 2215,2615 3235,3810
balance, this balance property. Anytime

2670
01:07:19,985 --> 01:07:21,100
0,195 195,390 390,585 585,795 795,1115
a thread comes along and

2671
01:07:21,120 --> 01:07:23,090
0,530 530,635 635,1180 1380,1715 1715,1970
inserts or deletes, they may

2672
01:07:23,090 --> 01:07:24,065
0,225 225,405 405,615 615,840 840,975
draw the short straw and

2673
01:07:24,065 --> 01:07:25,715
0,180 180,515 535,825 825,1425 1425,1650
be responsible for reorganizing the

2674
01:07:25,715 --> 01:07:27,020
0,165 165,375 375,695
entire data structure.|
|

2675
01:07:28,040 --> 01:07:29,755
0,290 290,580 720,1415 1415,1535 1535,1715
And so, ideally, what we
因此，理想情况下，我们需要的是一种延迟数据结构更新的方法。

2676
01:07:29,755 --> 01:07:30,990
0,225 225,405 405,555 555,840 840,1235
want is a way to

2677
01:07:31,400 --> 01:07:33,760
0,395 395,790 810,1210 1770,2135 2135,2360
delay the updates to the

2678
01:07:33,760 --> 01:07:35,120
0,210 210,560
data structure.|
|

2679
01:07:35,120 --> 01:07:35,990
0,120 120,255 255,390 390,570 570,870
In such a way that
以这样一种方式，我们可以累积它们，然后在以后的某个点上我们有足够的，我们说，好的，让我继续并应用我的所有更改一批。

2680
01:07:35,990 --> 01:07:37,130
0,240 240,345 345,810 810,990 990,1140
we can accumulate them and

2681
01:07:37,130 --> 01:07:38,045
0,120 120,255 255,435 435,675 675,915
then at some later point

2682
01:07:38,045 --> 01:07:38,900
0,150 150,300 300,510 510,660 660,855
we have enough, we say,

2683
01:07:38,900 --> 01:07:39,905
0,350 400,645 645,735 735,870 870,1005
okay, let me go ahead

2684
01:07:39,905 --> 01:07:40,775
0,135 135,300 300,450 450,630 630,870
and apply all my changes

2685
01:07:40,775 --> 01:07:42,240
0,180 180,300 300,605
in a batch.|
|

2686
01:07:42,310 --> 01:07:43,170
0,245 245,365 365,545 545,725 725,860
And then, yes, I may
然后，是的，我可能不得不重新安排事情，但我只做了一次。我可以摊销这笔费用。

2687
01:07:43,170 --> 01:07:45,530
0,105 105,195 195,675 675,980 1960,2360
have to reorganize things, but

2688
01:07:45,550 --> 01:07:46,515
0,350 350,500 500,635 635,785 785,965
I'm doing it all once.

2689
01:07:46,515 --> 01:07:47,630
0,150 150,270 270,660 660,840 840,1115
I can amortize the cost.|
|

2690
01:07:48,370 --> 01:07:50,060
0,400 540,905 905,1175 1175,1385 1385,1690
Of, of making those changes
做出这些改变，现在你的权利可能会更快，因为你没有，你没有。你不必担心。每次我插入新的东西我都得分开。

2691
01:07:50,650 --> 01:07:51,825
0,305 305,545 545,770 770,980 980,1175
and now your rights could

2692
01:07:51,825 --> 01:07:52,935
0,180 180,375 375,665 685,960 960,1110
potentially be faster because you

2693
01:07:52,935 --> 01:07:54,120
0,390 390,570 570,840 840,1020 1020,1185
don't, you don't. You don't

2694
01:07:54,120 --> 01:07:55,335
0,90 90,195 195,330 330,620 910,1215
have to worry about. I'm

2695
01:07:55,335 --> 01:07:56,055
0,45 45,135 135,330 330,540 540,720
gonna have to split every

2696
01:07:56,055 --> 01:07:57,080
0,150 150,240 240,480 480,690 690,1025
time I insert something new.|
|

2697
01:07:59,850 --> 01:08:00,785
0,260 260,440 440,545 545,725 725,935
So there's a line of
因此，关于什么是正确的，有一系列的工作。优化b树或b+树。这些树有时也被称为bepsilon树。你会看到它的一点。

2698
01:08:00,785 --> 01:08:01,985
0,305 385,675 675,825 825,975 975,1200
work on what is called

2699
01:08:01,985 --> 01:08:03,725
0,335 415,905 1135,1440 1440,1620 1620,1740
right. Optimize b trees or

2700
01:08:03,725 --> 01:08:06,190
0,135 135,345 345,665 1855,2160 2160,2465
b plus trees. These have

2701
01:08:06,270 --> 01:08:07,265
0,335 335,515 515,650 650,830 830,995
sometimes are also called b

2702
01:08:07,265 --> 01:08:09,500
0,450 450,785 1765,2085 2085,2175 2175,2235
epsilon trees. You'll see it

2703
01:08:09,500 --> 01:08:10,560
0,90 90,195 195,440
with a little.|
|

2704
01:08:10,720 --> 01:08:13,365
0,275 275,650 650,970 2160,2480 2480,2645
Little epsilon symbol. There's a
小小的埃西隆符号。Tou Tech的人有一种商业变体叫分形树，但它基本上是在打品牌，这是，它的想法是一样的。

2705
01:08:13,365 --> 01:08:14,670
0,300 300,735 735,885 885,1020 1020,1305
commercial variant from the tou

2706
01:08:14,670 --> 01:08:16,335
0,150 150,440 640,990 990,1410 1410,1665
Tech guys called fractal trees,

2707
01:08:16,335 --> 01:08:18,375
0,195 195,765 765,1140 1140,1650 1650,2040
but it's basically branding it's,

2708
01:08:18,375 --> 01:08:20,740
0,300 300,405 405,600 600,935
it's the same idea.|
|

2709
01:08:20,750 --> 01:08:21,900
0,260 260,455 455,695 695,875 875,1150
And the idea is basically
现在的想法基本上是在每个根节点和内部节点，我将有一个mod日志。

2710
01:08:21,950 --> 01:08:23,890
0,305 305,455 455,605 605,910 1650,1940
now at every single root

2711
01:08:23,890 --> 01:08:25,630
0,240 240,345 345,540 540,1010 1390,1740
node and inner node, I'm

2712
01:08:25,630 --> 01:08:26,170
0,60 60,135 135,240 240,345 345,540
going to have a mod

2713
01:08:26,170 --> 01:08:27,240
0,350
log.|
|

2714
01:08:27,310 --> 01:08:28,440
0,275 275,455 455,650 650,920 920,1130
Just like my SEL had
就像我的SEL在他们做压缩时对他们的页面做的那样。

2715
01:08:28,440 --> 01:08:29,445
0,255 255,450 450,705 705,915 915,1005
for their pages when they

2716
01:08:29,445 --> 01:08:30,880
0,90 90,210 210,635
were doing compression.|
|

2717
01:08:30,980 --> 01:08:32,290
0,260 260,755 755,905 905,1085 1085,1310
And anytime a new update
无论何时出现新的更新，我都会违反我们在b+树中讨论过的属性，在该属性中，叶节点必须在哪里，实际值在哪里，我可以将我的条目插入到mod日志中，而不是将这些更改一直传播到叶节点。

2718
01:08:32,290 --> 01:08:34,420
0,225 225,560 1090,1350 1350,1530 1530,2130
comes along, instead of propagating

2719
01:08:34,420 --> 01:08:35,635
0,270 270,590 610,945 945,1110 1110,1215
those changes all the way

2720
01:08:35,635 --> 01:08:36,810
0,195 195,345 345,435 435,630 630,1175
down to the leaf nodes,

2721
01:08:37,190 --> 01:08:38,185
0,305 305,350 350,455 455,860 860,995
I'm going to violate the

2722
01:08:38,185 --> 01:08:39,010
0,210 210,405 405,540 540,705 705,825
property we talked about in

2723
01:08:39,010 --> 01:08:40,675
0,75 75,195 195,390 390,710 1390,1665
the b plus tree, where

2724
01:08:40,675 --> 01:08:41,335
0,120 120,255 255,465 465,570 570,660
the leaf nodes have to

2725
01:08:41,335 --> 01:08:42,085
0,120 120,255 255,405 405,555 555,750
be, where the actual values

2726
01:08:42,085 --> 01:08:43,405
0,335 745,990 990,1095 1095,1200 1200,1320
are, and I can, I

2727
01:08:43,405 --> 01:08:44,700
0,135 135,495 495,645 645,990 990,1295
can insert my entries into

2728
01:08:44,780 --> 01:08:46,000
0,245 245,395 395,700
the mod log.|
|

2729
01:08:46,930 --> 01:08:47,745
0,230 230,290 290,395 395,515 515,815
So if I want toert
因此，如果我想要再次设置7，而不是遍历并计算出7应该放在哪里，我只需将其放在根中。

2730
01:08:47,745 --> 01:08:49,350
0,335 805,1125 1125,1305 1305,1410 1410,1605
seven again, instead of having

2731
01:08:49,350 --> 01:08:50,505
0,375 375,615 615,870 870,1035 1035,1155
traverse down and figure out

2732
01:08:50,505 --> 01:08:52,050
0,165 165,390 390,585 585,845 1255,1545
where seven should go, I

2733
01:08:52,050 --> 01:08:53,040
0,195 195,345 345,450 450,710 730,990
just put it in the

2734
01:08:53,040 --> 01:08:53,840
0,260
root.|
|

2735
01:08:54,760 --> 01:08:55,815
0,290 290,545 545,785 785,905 905,1055
Same thing, I want to
同样的事情，我想删掉十个。我不会把它放到下一步，然后删除它，然后可能进行合并，我只会把它放到mod日志中。

2736
01:08:55,815 --> 01:08:58,440
0,305 655,1055 2065,2325 2325,2460 2460,2625
delete ten. Instead of putting

2737
01:08:58,440 --> 01:09:00,645
0,210 210,530 850,1250 1720,2010 2010,2205
it into the going down

2738
01:09:00,645 --> 01:09:01,635
0,210 210,495 495,630 630,750 750,990
and deleting it and then

2739
01:09:01,635 --> 01:09:03,720
0,315 315,635 835,1095 1095,1565 1765,2085
potentially doing a merge, I'll

2740
01:09:03,720 --> 01:09:04,395
0,90 90,195 195,390 390,585 585,675
just put it in the

2741
01:09:04,395 --> 01:09:05,400
0,150 150,455
mod log.|
|

2742
01:09:06,420 --> 01:09:07,580
0,255 255,530
All right.|
好的。|

2743
01:09:07,960 --> 01:09:09,030
0,245 245,455 455,725 725,890 890,1070
So now if a query
现在，如果出现一个查询，并希望找到10个。

2744
01:09:09,030 --> 01:09:09,750
0,165 165,330 330,465 465,585 585,720
comes up and wants to

2745
01:09:09,750 --> 01:09:11,240
0,225 225,590
find ten.|
|

2746
01:09:11,540 --> 01:09:12,850
0,335 335,560 560,740 740,1025 1025,1310
Well, as I traverse down,
好吧，当我向下遍历时，我查看mod日志并说，OK就是我在这里要找的东西。

2747
01:09:12,850 --> 01:09:13,930
0,285 285,585 585,840 840,930 930,1080
I look in the mod

2748
01:09:13,930 --> 01:09:15,475
0,320 820,1080 1080,1260 1260,1425 1425,1545
log and say, OK is

2749
01:09:15,475 --> 01:09:16,225
0,135 135,255 255,435 435,570 570,750
the thing I'm looking for

2750
01:09:16,225 --> 01:09:17,180
0,275
here.|
|

2751
01:09:17,180 --> 01:09:17,945
0,195 195,240 240,345 345,525 525,765
So in this case here,
所以在这个例子中，我删除了10个。在我的黑帮日志里。所以当我查找的时候，我会在这里找到条目，然后就完成了。我不需要去底部。

2752
01:09:17,945 --> 01:09:19,810
0,330 330,725 865,1200 1200,1560 1560,1865
I I I deleted ten.

2753
01:09:20,550 --> 01:09:21,545
0,290 290,380 380,515 515,710 710,995
It's in my mob log.

2754
01:09:21,545 --> 01:09:22,145
0,210 210,300 300,390 390,480 480,600
So when I do my

2755
01:09:22,145 --> 01:09:23,090
0,285 285,420 420,540 540,720 720,945
lookup, I would find the

2756
01:09:23,090 --> 01:09:24,365
0,195 195,470 640,900 900,1110 1110,1275
entry here and I'm done.

2757
01:09:24,365 --> 01:09:25,040
0,165 165,375 375,480 480,600 600,675
I don't need to go

2758
01:09:25,040 --> 01:09:26,340
0,75 75,180 180,440
to the bottom.|
|

2759
01:09:26,350 --> 01:09:29,580
0,400 1110,1510 2460,2860 2880,3125 3125,3230
And to actually see the
并真正看到变化。

2760
01:09:29,580 --> 01:09:30,560
0,260
change.|
|

2761
01:09:32,490 --> 01:09:33,350
0,245 245,380 500,575 575,710 710,860
Of course, what's the obvious
当然，这有什么明显的问题吗？

2762
01:09:33,350 --> 01:09:34,740
0,135 135,270 270,530
problem with this?|
|

2763
01:09:37,090 --> 01:09:38,660
0,245 245,530 530,695 695,970 1170,1570
The buffers get full right.|
缓冲区完全正确。|

2764
01:09:39,520 --> 01:09:40,720
0,270 270,450 450,630 630,930 930,1200
So when that happens, then
所以当这种情况发生时，你必须级联，改变。但这里的想法是，你增量地批量地做这些，基本上，你不必应用任何修改，直到你到达数据结构的结构，直到你到达叶节点。

2765
01:09:40,720 --> 01:09:42,535
0,135 135,240 240,500 1000,1545 1545,1815
you got to cascade down

2766
01:09:42,535 --> 01:09:44,005
0,315 315,555 555,845 1015,1290 1290,1470
the, the changes. But the

2767
01:09:44,005 --> 01:09:44,635
0,150 150,240 240,360 360,525 525,630
idea is here you're doing

2768
01:09:44,635 --> 01:09:46,050
0,180 180,630 630,765 765,900 900,1415
this incrementally and in batches,

2769
01:09:46,400 --> 01:09:48,280
0,260 260,520 720,1120 1350,1640 1640,1880
and you basically, you don't

2770
01:09:48,280 --> 01:09:49,740
0,90 90,270 270,570 570,855 855,1460
have to apply any modifications

2771
01:09:50,270 --> 01:09:51,595
0,290 290,470 470,760 900,1160 1160,1325
until you get to the

2772
01:09:51,595 --> 01:09:52,530
0,225 225,375 375,450 450,615 615,935
structure of the data structure

2773
01:09:53,090 --> 01:09:54,210
0,275 275,425 425,620 620,830 830,1120
until you get to the,

2774
01:09:54,590 --> 01:09:55,830
0,350 350,545 545,635 635,785 785,1240
to, to the leaf nodes.|
|

2775
01:09:56,280 --> 01:09:57,260
0,105 105,150 150,255 255,645 645,980
So if I insert forty,
所以如果我插入40，我只需要移动之前的更改，惰性7，这里没有10，然后我离开。

2776
01:09:57,490 --> 01:09:58,860
0,290 290,500 500,755 755,1040 1040,1370
I just move my previous

2777
01:09:58,860 --> 01:10:01,410
0,380 1120,1650 1650,1935 1935,2295 2295,2550
changes, inert seven, andert ten

2778
01:10:01,410 --> 01:10:05,180
0,350 1420,1820 1900,2175 2175,2450
here and I leave.|
|

2779
01:10:05,220 --> 01:10:06,140
0,230 230,320 320,440 440,710 710,920
And you put insert forty
你把40号插在这里。

2780
01:10:06,140 --> 01:10:07,160
0,320
there.|
|

2781
01:10:07,160 --> 01:10:07,790
0,225 225,315 315,420 420,540 540,630
And at some point, if
在某个时候，如果我继续这样做，这个东西级联下来，这个东西是满的，然后我继续应用我的更改。

2782
01:10:07,790 --> 01:10:09,190
0,105 105,270 270,560 790,1095 1095,1400
I keep going this thing,

2783
01:10:09,510 --> 01:10:12,170
0,275 275,440 440,860 860,1180 2400,2660
this thing cascades down and

2784
01:10:12,170 --> 01:10:13,180
0,150 150,300 300,465 465,690 690,1010
this thing is full, then

2785
01:10:13,230 --> 01:10:14,255
0,260 260,395 395,575 575,815 815,1025
I go ahead and apply

2786
01:10:14,255 --> 01:10:15,780
0,150 150,425
my changes.|
|

2787
01:10:16,410 --> 01:10:18,095
0,400 630,890 890,1085 1085,1400 1400,1685
Yes, could this potentially make
是的，这可能会使读取非常慢吗？因为你可以建立一个很大的操作缓冲区，然后尝试形成一个读？这需要很长时间，是的。所以问题是，这可能会使读取速度变慢，因为？

2788
01:10:18,095 --> 01:10:19,310
0,285 285,525 525,870 870,1095 1095,1215
reads really slow? Because you

2789
01:10:19,310 --> 01:10:20,030
0,135 135,255 255,375 375,525 525,720
can build up this big

2790
01:10:20,030 --> 01:10:21,880
0,435 435,705 705,1100 1330,1590 1590,1850
buffer of operations and then

2791
01:10:21,930 --> 01:10:22,730
0,260 260,395 395,545 545,665 665,800
try and form a read?

2792
01:10:22,730 --> 01:10:23,750
0,150 150,300 300,590 670,930 930,1020
It takes ages, yeah. So

2793
01:10:23,750 --> 01:10:24,725
0,75 75,225 225,530 580,825 825,975
the question is, could this

2794
01:10:24,725 --> 01:10:25,775
0,210 210,420 420,735 735,855 855,1050
potentially make reads go really

2795
01:10:25,775 --> 01:10:27,320
0,315 315,695
slow because?|
|

2796
01:10:27,770 --> 01:10:29,170
0,320 320,575 575,845 845,1085 1085,1400
As I'm scanning along here,
当我在这里扫描时，我必须在mod日志中进行顺序扫描，以找到为什么我要找的东西在那里。

2797
01:10:29,170 --> 01:10:31,270
0,350 370,630 630,765 765,1040 1660,2100
I have to do sequential

2798
01:10:31,270 --> 01:10:32,230
0,210 210,450 450,600 600,750 750,960
scans within the mod log

2799
01:10:32,230 --> 01:10:33,415
0,150 150,285 285,420 420,680 910,1185
to find to see why

2800
01:10:33,415 --> 01:10:34,060
0,135 135,240 240,375 375,510 510,645
the thing I'm looking for

2801
01:10:34,060 --> 01:10:35,120
0,75 75,195 195,470
is in there.|
|

2802
01:10:35,130 --> 01:10:37,780
0,400 960,1235 1235,1475 1475,1840 2250,2650
Yes, but then like these,
是的，但是就像这些，这些不同的bpspp树的含义。他们在这些东西前面有布隆过滤器要说的是我在寻找的关键，实际上，甚至在我的英里日志。如果是，那就去找吧。

2803
01:10:38,580 --> 01:10:40,190
0,260 260,395 395,875 875,1145 1145,1610
these different implications of bpspsilon

2804
01:10:40,190 --> 01:10:42,440
0,290 520,795 795,1040 1480,1800 1800,2250
trees. They have bloom filters

2805
01:10:42,440 --> 01:10:43,400
0,270 270,420 420,525 525,675 675,960
in front of these things

2806
01:10:43,400 --> 01:10:44,540
0,270 270,560 580,840 840,990 990,1140
to say is the key

2807
01:10:44,540 --> 01:10:45,665
0,150 150,315 315,585 585,855 855,1125
I'm looking for, actually, even

2808
01:10:45,665 --> 01:10:46,940
0,225 225,390 390,555 555,845 955,1275
in my mile log. If

2809
01:10:46,940 --> 01:10:48,290
0,300 300,680 790,1050 1050,1200 1200,1350
yes, then go look for

2810
01:10:48,290 --> 01:10:48,920
0,260
it.|
|

2811
01:10:50,370 --> 01:10:51,650
0,290 290,455 455,695 695,995 995,1280
And bloom voters are cheap
布鲁姆的选民很容易维持，而且他们的人数也不是很多。

2812
01:10:51,650 --> 01:10:53,000
0,210 210,440 520,920 970,1260 1260,1350
to maintain, and they're not

2813
01:10:53,000 --> 01:10:53,920
0,150 150,440
very big.|
|

2814
01:10:55,990 --> 01:10:56,715
0,230 230,305 305,395 395,485 485,725
So this is an old
所以这是一个古老的想法，我会所有。

2815
01:10:56,715 --> 01:10:57,770
0,300 300,495 495,645 645,780 780,1055
idea that I would all.|
|

2816
01:10:58,710 --> 01:11:01,970
0,605 605,850 2010,2360 2360,2600 2600,3260
2003 old people, trees 1972
2003年的老人，1972年的树，所以可能没有那么老。EM是一个古老的想法。这个看起来像什么？我们之前谈过的？日志结构，存储，对吧？同样的想法，我们可以附加这些日志日志条目，然后批量处理它们，并在稍后的某个时候应用它们。

2817
01:11:01,970 --> 01:11:02,825
0,135 135,300 300,600 600,750 750,855
so maybe that's not that

2818
01:11:02,825 --> 01:11:04,610
0,245 295,695 1225,1470 1470,1560 1560,1785
old. EM is an old

2819
01:11:04,610 --> 01:11:07,325
0,380 2050,2295 2295,2385 2385,2505 2505,2715
idea. What does this look

2820
01:11:07,325 --> 01:11:08,510
0,180 180,315 315,605 835,1080 1080,1185
also look like? What we

2821
01:11:08,510 --> 01:11:09,995
0,120 120,255 255,530 790,1155 1155,1485
talked about before? Log structure,

2822
01:11:09,995 --> 01:11:12,470
0,365 925,1325 1705,2070 2070,2325 2325,2475
storage, right? Same idea that

2823
01:11:12,470 --> 01:11:13,450
0,105 105,195 195,480 480,675 675,980
we can append these log

2824
01:11:13,650 --> 01:11:15,680
0,320 320,790 1440,1700 1700,1835 1835,2030
log entries and then batch

2825
01:11:15,680 --> 01:11:16,630
0,135 135,225 225,405 405,645 645,950
them up and apply them

2826
01:11:16,830 --> 01:11:18,220
0,275 275,425 425,605 605,910
at some later point.|
|

2827
01:11:18,930 --> 01:11:20,240
0,400 690,950 950,1070 1070,1175 1175,1310
So I said, you guys,
所以我说，伙计们，我们已经一遍又一遍地看到了这个想法。所以Tou Tech，他们将他们的bpspsilon树的实现重新命名为分形树，然后他们有了一个用于我的SQL的存储引擎。

2828
01:11:20,240 --> 01:11:21,185
0,195 195,300 300,540 540,795 795,945
we've seen this idea over

2829
01:11:21,185 --> 01:11:22,355
0,90 90,195 195,485 535,840 840,1170
and over again. So tou

2830
01:11:22,355 --> 01:11:24,455
0,275 535,840 840,1380 1380,1655 1705,2100
Tech, they rebranded their implementation

2831
01:11:24,455 --> 01:11:25,520
0,225 225,315 315,720 720,885 885,1065
of a bpspsilon tree as

2832
01:11:25,520 --> 01:11:27,020
0,405 405,710 1030,1275 1275,1380 1380,1500
fractal trees, and then they

2833
01:11:27,020 --> 01:11:28,205
0,150 150,360 360,600 600,920 940,1185
had a storage engine for

2834
01:11:28,205 --> 01:11:31,180
0,165 165,665 1855,2255
my sql that.|
|

2835
01:11:31,250 --> 01:11:32,460
0,245 245,365 365,640
I think up.|
我想起来了。|

2836
01:11:32,740 --> 01:11:34,275
0,400 450,725 725,875 875,1325 1325,1535
Got bought by brona and
被Brona收购了，我想我去年被抛弃了，所以。

2837
01:11:34,275 --> 01:11:35,270
0,90 90,195 195,300 300,435 435,995
I think I got deprecated

2838
01:11:35,830 --> 01:11:37,500
0,350 350,650 650,1000
last year, so.|
|

2839
01:11:37,500 --> 01:11:38,415
0,270 270,465 465,645 645,750 750,915
They had probably the most
它们可能是几年前最有说服力的暗示。那是死路一条。拆分器DB是一个从VMware编写的键值存储嵌入式键值存储。事实上，这里有个人是。

2840
01:11:38,415 --> 01:11:40,365
0,210 210,725 1465,1710 1710,1830 1830,1950
robust implication from a few

2841
01:11:40,365 --> 01:11:42,470
0,150 150,455 595,1035 1035,1325 1705,2105
years ago. That's dead EM.

2842
01:11:42,850 --> 01:11:44,985
0,410 410,755 755,1070 1070,1450 1860,2135
Splinter DB is a key

2843
01:11:44,985 --> 01:11:46,095
0,240 240,525 525,750 750,915 915,1110
value store embedded key value

2844
01:11:46,095 --> 01:11:49,110
0,335 385,690 690,1265 2455,2805 2805,3015
store from VMware written. Actually,

2845
01:11:49,110 --> 01:11:50,640
0,180 180,405 405,690 690,1070
somebody here that was.|
|

2846
01:11:50,640 --> 01:11:51,675
0,225 225,420 420,525 525,945 945,1035
He was a researcher at
他是VMware的一名研究人员，但他是在CMU的Tepper和另一个致力于此的人那里获得MBA学位的。他现在是康奈尔大学的教授，但这基本上是一种超级优化的版本，关系I是一个。

2847
01:11:51,675 --> 01:11:52,920
0,545 685,915 915,975 975,1065 1065,1245
VMware, but he was getting

2848
01:11:52,920 --> 01:11:55,550
0,320 1180,1680 1680,1935 1935,2190 2190,2630
his MBA here at Tepper

2849
01:11:55,630 --> 01:11:57,945
0,305 305,790 1710,1985 1985,2150 2150,2315
at cmu and another guy

2850
01:11:57,945 --> 01:11:58,650
0,165 165,285 285,390 390,585 585,705
working on this. He's now

2851
01:11:58,650 --> 01:12:00,060
0,165 165,300 300,680 820,1170 1170,1410
professor at Cornell, but this

2852
01:12:00,060 --> 01:12:02,390
0,180 180,470 1150,1550 1840,2085 2085,2330
is basically a sort of

2853
01:12:02,650 --> 01:12:04,370
0,305 305,605 605,1010 1010,1340 1340,1720
a super optimized version of

2854
01:12:04,600 --> 01:12:06,440
0,400 690,950 950,1055 1055,1360 1440,1840
this and the relational I

2855
01:12:06,490 --> 01:12:08,080
0,305 305,610
is a.|
|

2856
01:12:08,150 --> 01:12:11,725
0,395 395,910 1380,1745 1745,2110 3240,3575
Uh, relational knowledge based graph
嗯，基于关系知识的图形贴面在顶层知识图形贴面上，在实现bpspson树的关系数据库系统之上进行快速更新。

2857
01:12:11,725 --> 01:12:14,305
0,345 345,525 525,785 1915,2280 2280,2580
veneer on top knowledge graph

2858
01:12:14,305 --> 01:12:15,310
0,330 330,495 495,630 630,765 765,1005
veneer on top of relational

2859
01:12:15,310 --> 01:12:18,280
0,270 270,620 1000,1400 1660,2270 2410,2970
database system that implements bpspson

2860
01:12:18,280 --> 01:12:19,920
0,210 210,405 405,660 660,1040
trees do fast updates.|
|

2861
01:12:20,070 --> 01:12:21,230
0,365 365,605 605,755 755,935 935,1160
So this is not that
所以这并不常见。

2862
01:12:21,230 --> 01:12:22,440
0,320
common.|
|

2863
01:12:23,260 --> 01:12:25,980
0,400 1590,1835 1835,2080 2340,2600 2600,2720
But you know, this is
但你知道，这是我怀疑我们在未来会看到越来越多的东西。我的意思是，ro DB不需要这个，因为ro DB已经是一个日志结构合并树，而您基本上得到了相同的概念、相同的属性。

2864
01:12:25,980 --> 01:12:27,045
0,150 150,405 405,705 705,900 900,1065
something I I suspect we'll

2865
01:12:27,045 --> 01:12:27,920
0,120 120,270 270,390 390,555 555,875
see more and more of

2866
01:12:28,090 --> 01:12:29,415
0,260 260,365 365,610 990,1220 1220,1325
in the future. I mean,

2867
01:12:29,415 --> 01:12:30,570
0,210 405,540 540,795 795,945 945,1155
ro DB doesn't need this

2868
01:12:30,570 --> 01:12:31,500
0,195 195,375 510,615 615,780 780,930
because ro DB already is

2869
01:12:31,500 --> 01:12:32,540
0,105 105,270 270,495 495,765 765,1040
a log structure merge tree,

2870
01:12:32,920 --> 01:12:34,905
0,400 900,1205 1205,1370 1370,1690 1710,1985
and you're essentially getting the

2871
01:12:34,905 --> 01:12:37,580
0,195 195,515 1045,1445 2125,2400 2400,2675
same idea, the same properties.|
|

2872
01:12:39,440 --> 01:12:40,600
0,275 275,550
All right.|
好的。|

2873
01:12:40,600 --> 01:12:42,835
0,210 210,330 330,590 1750,2040 2040,2235
So we have six minutes
所以我们还剩六分钟。

2874
01:12:42,835 --> 01:12:43,920
0,305
left.|
|

2875
01:12:44,085 --> 01:12:44,810
0,60 60,150 150,300 300,450 450,725
So let's pop up in
所以，让我们在波斯格雷斯突然出现。

2876
01:12:45,250 --> 01:12:46,620
0,610
postgres.|
|

2877
01:12:49,230 --> 01:12:50,110
0,260 260,380 380,515 515,635 635,880
And you correct them up.|
然后你把它们纠正过来。|

2878
01:12:52,040 --> 01:12:53,230
0,275 275,410 410,670 750,980 980,1190
So here I going to
因此，在这里我将演示两者的区别。

2879
01:12:53,230 --> 01:12:55,580
0,270 270,420 420,680 700,1100
demonstrate the difference between.|
|

2880
01:12:55,580 --> 01:12:56,290
0,150 150,285 285,360 360,450 450,710
I turn the lights off,
我关掉灯，演示我的SQL之间的区别，或者，对不起，不是我的SQL。

2881
01:12:57,060 --> 01:12:58,160
0,275 275,410 410,650 650,905 905,1100
demonstrate the difference between my

2882
01:12:58,160 --> 01:12:59,120
0,420 420,630 630,750 750,855 855,960
sql or, sorry, not my

2883
01:12:59,120 --> 01:13:00,900
0,350
sql.|
|

2884
01:13:04,870 --> 01:13:06,480
0,520 600,1000
Nope, sorry.|
不，对不起。|

2885
01:13:07,290 --> 01:13:08,300
0,400
Works.|
行得通。|

2886
01:13:09,350 --> 01:13:10,675
0,245 245,335 335,580 1020,1250 1250,1325
There we go to write
在那里我们第一次开始写作。因此，我想演示散列索引和A、B加树在数据上的区别，我们可以看到数据系统将选择使用什么来运行查询。

2887
01:13:10,675 --> 01:13:11,395
0,75 75,165 165,420 420,645 645,720
the first time. So I

2888
01:13:11,395 --> 01:13:12,085
0,75 75,240 240,450 450,555 555,690
want to demonstrate the difference

2889
01:13:12,085 --> 01:13:14,740
0,210 210,515 1075,1515 1515,1835 2305,2655
between a hash index and

2890
01:13:14,740 --> 01:13:17,100
0,350 640,930 930,1140 1140,1460 1960,2360
A B plus tree on

2891
01:13:17,930 --> 01:13:19,120
0,305 305,545 545,860 860,1070 1070,1190
on data and we can

2892
01:13:19,120 --> 01:13:20,005
0,195 195,390 390,540 540,705 705,885
see what the data system

2893
01:13:20,005 --> 01:13:22,480
0,120 120,210 210,330 330,605 2215,2475
is going to choose to

2894
01:13:22,480 --> 01:13:24,300
0,260 400,645 645,795 795,1250
use to run queries.|
|

2895
01:13:29,370 --> 01:13:30,305
0,290 290,425 425,605 605,785 860,935
So the data set I'm
所以我要使用的数据集将是。

2896
01:13:30,305 --> 01:13:31,985
0,75 75,180 180,455 1225,1530 1530,1680
going to use is going

2897
01:13:31,985 --> 01:13:34,260
0,75 75,305
to be.|
|

2898
01:13:35,700 --> 01:13:37,570
0,230 230,290 290,500 500,1090 1470,1870
I think it 21 million.|
我想是2100万。|

2899
01:13:39,540 --> 01:13:42,815
0,320 320,820 2760,3020 3020,3140 3140,3275
Email addresses from a few
几年前的电子邮件地址，对吧？因为一切都在进行中。

2900
01:13:42,815 --> 01:13:43,985
0,210 210,545 595,900 900,1050 1050,1170
years ago, right? Because it's

2901
01:13:43,985 --> 01:13:45,580
0,120 120,425
all on.|
|

2902
01:13:46,290 --> 01:13:48,125
0,485 485,785 785,1090 1320,1610 1610,1835
It's, yeah, so twenty seven,
是啊，所以27700万个电子邮件地址，对吧？所以。

2903
01:13:48,125 --> 01:13:49,265
0,240 240,420 420,630 630,840 840,1140
twenty seven million email addresses,

2904
01:13:49,265 --> 01:13:51,380
0,275 685,990 990,1295
right? And so.|
|

2905
01:13:51,380 --> 01:13:51,980
0,195 195,285 285,390 390,465 465,600
I'm not going to run
我不打算实时运行它，但基本上我已经创建了两个索引。

2906
01:13:51,980 --> 01:13:53,800
0,290 340,740 940,1245 1245,1485 1485,1820
this in real time, but

2907
01:13:53,850 --> 01:13:55,540
0,395 395,710 710,920 920,1190 1190,1690
basically I've created two indexes.|
|

2908
01:13:57,210 --> 01:13:58,625
0,290 290,500 500,725 725,1030 1050,1415
I created one here on
我在电子邮件的A，B，bl上创建了一个。抱歉的。

2909
01:13:58,625 --> 01:13:59,480
0,210 210,330 330,540 540,720 720,855
A B bl on the

2910
01:13:59,480 --> 01:14:01,420
0,290 790,1190
emails. Sorry.|
|

2911
01:14:02,600 --> 01:14:03,415
0,290 290,425 425,530 530,650 650,815
And the way it works
它的工作方式类似于在postgres中，您说CREATE INDEX WITH该表上的索引名，然后使用，您可以指定所需的数据结构。所以默认情况下，如果你没有USING子句并且后置，你会得到A，B加3，但这里我明确地告诉你，我想加3，索引已经存在了。我不需要这么做。

2912
01:14:03,415 --> 01:14:04,840
0,180 180,455 535,825 825,1275 1275,1425
is like in postgres you

2913
01:14:04,840 --> 01:14:06,835
0,165 165,435 435,800 1630,1890 1890,1995
say create index with the

2914
01:14:06,835 --> 01:14:08,095
0,105 105,210 210,360 360,665 955,1260
name of the index on

2915
01:14:08,095 --> 01:14:09,270
0,195 195,465 465,690 690,855 855,1175
this table and then using

2916
01:14:09,770 --> 01:14:10,795
0,275 275,380 380,500 500,875 875,1025
and you can specify what

2917
01:14:10,795 --> 01:14:12,145
0,210 210,450 450,615 615,875 1105,1350
data structure you want. So

2918
01:14:12,145 --> 01:14:13,000
0,240 240,525 525,645 645,720 720,855
by default, if you don't

2919
01:14:13,000 --> 01:14:13,840
0,75 75,180 180,375 375,660 660,840
have the using clause and

2920
01:14:13,840 --> 01:14:16,045
0,470 970,1370 1480,1845 1845,2085 2085,2205
postgres you, you, you get

2921
01:14:16,045 --> 01:14:17,170
0,75 75,180 180,375 375,665 865,1125
A B plususter three, but

2922
01:14:17,170 --> 01:14:18,550
0,255 255,630 630,990 990,1200 1200,1380
here I'm explicitly telling I

2923
01:14:18,550 --> 01:14:19,320
0,105 105,195 195,300 300,480 480,770
want to b plususter three

2924
01:14:19,430 --> 01:14:21,055
0,400 630,935 935,1115 1115,1310 1310,1625
and the index already exists.

2925
01:14:21,055 --> 01:14:21,730
0,240 240,390 390,480 480,570 570,675
I don't need to do

2926
01:14:21,730 --> 01:14:23,500
0,260
that.|
|

2927
01:14:23,500 --> 01:14:24,750
0,225 225,420 420,615 615,870 870,1250
And then I have the
然后，我使用哈希表在相同的列上构建相同的内容，Alta on。我只是说使用散列，再一次，我已经有了。

2928
01:14:24,920 --> 01:14:26,220
0,275 275,410 410,575 575,880 900,1300
build the same thing on

2929
01:14:26,690 --> 01:14:28,330
0,245 245,350 350,530 530,850 1080,1640
on the same column, alta

2930
01:14:28,330 --> 01:14:29,470
0,195 195,525 525,825 825,960 960,1140
on on, using a hash

2931
01:14:29,470 --> 01:14:30,520
0,260 430,675 675,780 780,900 900,1050
table. And I just say

2932
01:14:30,520 --> 01:14:31,765
0,210 210,650 670,960 960,1110 1110,1245
using hash, and again, I

2933
01:14:31,765 --> 01:14:32,940
0,135 135,285 285,575
already have that.|
|

2934
01:14:33,600 --> 01:14:34,265
0,245 245,320 320,410 410,530 530,665
So let me turn off
因此，让我关闭一系列其他优化。

2935
01:14:34,265 --> 01:14:35,350
0,120 120,240 240,345 345,555 555,1085
a bunch of other optimizations.|
|

2936
01:14:36,200 --> 01:14:37,640
0,105 105,560 1000,1245 1245,1320 1320,1440
In postgres that we don't
在postgres中，我们还不需要担心，所以我可以像这样进行查询。

2937
01:14:37,640 --> 01:14:38,135
0,75 75,135 135,195 195,330 330,495
need to worry about just

2938
01:14:38,135 --> 01:14:39,815
0,275 1105,1350 1350,1455 1455,1545 1545,1680
yet so I can do

2939
01:14:39,815 --> 01:14:41,400
0,300 300,420 420,695
queries like this.|
|

2940
01:14:41,400 --> 01:14:43,350
0,360 360,830 1300,1560 1560,1740 1740,1950
Right, selects email from emails
好的，从电子邮件中选择电子邮件，我会得到一些随机的东西，比如。

2941
01:14:43,350 --> 01:14:44,535
0,135 135,240 240,390 390,680 850,1185
and I get some random

2942
01:14:44,535 --> 01:14:45,860
0,180 180,300 300,575
thing like this.|
|

2943
01:14:45,900 --> 01:14:46,865
0,290 290,485 485,635 635,785 785,965
But again, if I put
但同样，如果我把解释的关键字放在它前面。

2944
01:14:46,865 --> 01:14:48,020
0,240 240,555 555,885 885,1020 1020,1155
the explained keyword in front

2945
01:14:48,020 --> 01:14:49,160
0,90 90,320
of it.|
|

2946
01:14:49,710 --> 01:14:50,345
0,260 260,365 365,455 455,545 545,635
Will tell me what the
会告诉我查询计划是什么。

2947
01:14:50,345 --> 01:14:51,760
0,180 180,360 360,635
query plan is.|
|

2948
01:14:51,760 --> 01:14:53,155
0,290 730,1005 1005,1140 1140,1320 1320,1395
Right, so here it's going
好的，这里它将告诉我，我将使用b加号树进行仅索引扫描，它会告诉我条件是什么。因此，我们不是只讨论索引扫描，有时是覆盖扫描或覆盖索引。基本上，Postgres认识到我回答这个查询所需的所有数据或列都可以在索引中找到。因此，即使它们将记录ID存储在叶节点中。

2949
01:14:53,155 --> 01:14:54,250
0,120 120,300 300,605 715,990 990,1095
to tell me I going

2950
01:14:54,250 --> 01:14:54,910
0,45 45,105 105,255 255,435 435,660
to do an index only

2951
01:14:54,910 --> 01:14:56,620
0,350 670,1050 1050,1290 1290,1455 1455,1710
scan using the b plus

2952
01:14:56,620 --> 01:14:58,345
0,350 1120,1365 1365,1470 1470,1605 1605,1725
tree and it tells me

2953
01:14:58,345 --> 01:14:59,730
0,90 90,240 240,705 705,1125 1125,1385
what the conditional conditional is.

2954
01:15:01,070 --> 01:15:02,305
0,260 260,380 380,730 780,1040 1040,1235
So we didn't talk about

2955
01:15:02,305 --> 01:15:03,835
0,195 195,375 375,695 715,1115 1195,1530
index only scan, sometimes cover

2956
01:15:03,835 --> 01:15:05,580
0,255 255,405 405,645 645,1175 1345,1745
scans or covering indexes. Basically,

2957
01:15:05,600 --> 01:15:07,645
0,560 560,1100 1100,1460 1460,1805 1805,2045
postgres recognizes that all the

2958
01:15:07,645 --> 01:15:08,695
0,240 240,435 435,555 555,735 735,1050
data or all the columns

2959
01:15:08,695 --> 01:15:09,535
0,120 120,285 285,420 420,615 615,840
I need to answer this

2960
01:15:09,535 --> 01:15:10,990
0,305 625,870 870,1020 1020,1260 1260,1455
query can be found in

2961
01:15:10,990 --> 01:15:12,670
0,195 195,530 910,1170 1170,1365 1365,1680
the index. So even though

2962
01:15:12,670 --> 01:15:14,515
0,300 300,555 555,890 1060,1380 1380,1845
they're storing the record IDs

2963
01:15:14,515 --> 01:15:15,940
0,150 150,285 285,465 465,995
in the leaf nodes.|
|

2964
01:15:15,940 --> 01:15:16,840
0,180 180,405 405,525 525,720 720,900
I don't need to actually
我实际上不需要跟踪这些记录I来获得实际两个池的数据。这个查询所需的所有内容都可以从索引中得到回答。

2965
01:15:16,840 --> 01:15:17,710
0,180 180,375 375,540 540,735 735,870
follow those record I to

2966
01:15:17,710 --> 01:15:18,655
0,105 105,225 225,470 580,825 825,945
get the data for the

2967
01:15:18,655 --> 01:15:20,305
0,150 150,300 300,575 835,1235 1405,1650
actual two pool. All everything

2968
01:15:20,305 --> 01:15:21,310
0,150 150,420 420,645 645,780 780,1005
I need for this query

2969
01:15:21,310 --> 01:15:22,390
0,150 150,300 300,495 495,765 765,1080
can be answered from the

2970
01:15:22,390 --> 01:15:23,380
0,320
index.|
|

2971
01:15:23,380 --> 01:15:25,105
0,320 760,1050 1050,1290 1290,1545 1545,1725
Right, because again going back
是的，因为再次回到我的查询，它只是选择了最小的电子邮件来自。

2972
01:15:25,105 --> 01:15:26,200
0,105 105,335 415,795 795,990 990,1095
to my query, it was

2973
01:15:26,200 --> 01:15:27,895
0,260 700,990 990,1140 1140,1365 1365,1695
just select the min email

2974
01:15:27,895 --> 01:15:30,300
0,365
from.|
|

2975
01:15:30,300 --> 01:15:31,290
0,300 300,525 525,690 690,855 855,990
From the email address and
从电子邮件地址，索引在电子邮件上。所以，一旦我一直走到树的右侧或树的左侧，就有了我要寻找的所有数据。

2976
01:15:31,290 --> 01:15:32,100
0,165 165,330 330,420 420,585 585,810
the index is on email.

2977
01:15:32,100 --> 01:15:33,540
0,150 150,300 300,590 1000,1290 1290,1440
So once I go all

2978
01:15:33,540 --> 01:15:34,575
0,90 90,315 315,555 555,765 765,1035
the way to the right

2979
01:15:34,575 --> 01:15:35,330
0,165 165,270 270,375 375,495 495,755
side of the tree or

2980
01:15:36,070 --> 01:15:36,920
0,290 290,425 425,500 500,590 590,850
left side of the tree,

2981
01:15:37,000 --> 01:15:37,710
0,245 245,350 350,485 485,605 605,710
that has all the data

2982
01:15:37,710 --> 01:15:38,880
0,135 135,270 270,590
I'm looking for.|
|

2983
01:15:39,070 --> 01:15:39,990
0,230 230,425 425,560 560,755 755,920
So that's why it told
这就是为什么它告诉我它只能进行索引扫描，所以这很好。

2984
01:15:39,990 --> 01:15:40,500
0,105 105,195 195,285 285,375 375,510
me it can do an

2985
01:15:40,500 --> 01:15:42,195
0,150 150,345 345,680 1240,1485 1485,1695
index only scan, so that's

2986
01:15:42,195 --> 01:15:43,160
0,245
fine.|
|

2987
01:15:43,200 --> 01:15:44,105
0,230 230,425 425,575 575,770 770,905
So let's see. Now, if
让我们来看看。现在，如果我们想做这样的事情，我们想说。

2988
01:15:44,105 --> 01:15:44,690
0,90 90,180 180,285 285,420 420,585
we want to do something

2989
01:15:44,690 --> 01:15:45,395
0,165 165,360 360,510 510,585 585,705
like this, we want to

2990
01:15:45,395 --> 01:15:46,680
0,275
say.|
|

2991
01:15:46,870 --> 01:15:48,195
0,275 275,550 840,1100 1100,1205 1205,1325
Give me, give me all
给我，给我所有第一个字母是a的电子邮件，但我做了一个限制，你得到像这样的人。

2992
01:15:48,195 --> 01:15:50,835
0,180 180,435 435,785 2185,2445 2445,2640
the emails where the first

2993
01:15:50,835 --> 01:15:52,380
0,255 255,465 465,755 1015,1245 1245,1545
letter is a but I'm

2994
01:15:52,380 --> 01:15:53,250
0,225 225,315 315,480 480,705 705,870
do a limit one and

2995
01:15:53,250 --> 01:15:54,440
0,105 105,350 460,765 765,930 930,1190
you get somebody like this.|
|

2996
01:15:55,180 --> 01:15:56,360
0,290
EM.|
嗯。|

2997
01:15:57,520 --> 01:15:58,275
0,230 230,305 305,380 380,545 545,755
And I can do explain
我可以解释，看看它到底告诉了我什么。所以在这种情况下，Postgres说，即使我有，我有b+树索引，它对电子邮件进行排序，Postgres大小，它想要进行顺序扫描，因为它意识到我正在寻找的东西，你知道，我正在寻找所有，所有以a开头的电子邮件，位于树的某个中间点。

2998
01:15:58,275 --> 01:15:58,890
0,120 120,210 210,285 285,435 435,615
and see what it actually

2999
01:15:58,890 --> 01:16:00,020
0,135 135,410 490,765 765,885 885,1130
tells me what to do.

3000
01:16:00,160 --> 01:16:00,975
0,215 215,275 275,410 410,590 590,815
So in this case here,

3001
01:16:00,975 --> 01:16:03,000
0,465 465,785 1495,1785 1785,1920 1920,2025
postgres says, even though I

3002
01:16:03,000 --> 01:16:03,855
0,195 195,420 420,570 570,705 705,855
have, I have that b

3003
01:16:03,855 --> 01:16:04,740
0,165 165,360 360,555 555,705 705,885
plus tree index that is

3004
01:16:04,740 --> 01:16:06,855
0,375 375,585 585,920 1360,1875 1875,2115
sorted on emails, postgres size,

3005
01:16:06,855 --> 01:16:07,305
0,135 135,225 225,315 315,375 375,450
it wants to do a

3006
01:16:07,305 --> 01:16:09,020
0,345 345,635 1075,1320 1320,1440 1440,1715
sequential scan cause it recognized

3007
01:16:09,160 --> 01:16:10,230
0,290 290,455 455,605 605,845 845,1070
that the thing I'm looking

3008
01:16:10,230 --> 01:16:12,345
0,380 1480,1725 1725,1800 1800,1950 1950,2115
for, you know, I'm looking

3009
01:16:12,345 --> 01:16:13,800
0,195 195,455 565,945 945,1245 1245,1455
for all, all emails that

3010
01:16:13,800 --> 01:16:15,465
0,135 135,270 270,560 1060,1500 1500,1665
start with a that's at

3011
01:16:15,465 --> 01:16:16,650
0,225 225,495 495,765 765,960 960,1185
some middle point in the

3012
01:16:16,650 --> 01:16:18,540
0,350
tree.|
|

3013
01:16:18,540 --> 01:16:20,640
0,260 640,960 960,1185 1185,1700 1810,2100
And since it's unbounded, I'm
由于它是无界的，所以我不会具体说明。

3014
01:16:20,640 --> 01:16:23,400
0,120 120,615 615,950
not specifying like.|
|

3015
01:16:23,500 --> 01:16:24,255
0,245 245,350 350,455 455,560 560,755
At least in the scan
至少在扫描大小上，我没有指定结束标记。它会说，好的，你必须扫描到整个末端。现在，它还不够聪明，不能意识到我有一个极限，对吗？因此，它真正应该做的是深入了解指数，找到第一件事，然后弹出并完成。但在这件事上，Postgco还不够聪明，没有意识到这一点。

3016
01:16:24,255 --> 01:16:25,830
0,335 445,945 945,1080 1080,1425 1425,1575
size, I'm not specifying the

3017
01:16:25,830 --> 01:16:27,195
0,150 150,645 645,945 945,1125 1125,1365
end marker. It would say,

3018
01:16:27,195 --> 01:16:27,945
0,195 195,285 285,375 375,510 510,750
okay, you got to scan

3019
01:16:27,945 --> 01:16:29,055
0,180 180,300 300,465 465,755 835,1110
to the entire end. Now,

3020
01:16:29,055 --> 01:16:29,835
0,210 210,390 390,570 570,675 675,780
it's not smart enough to

3021
01:16:29,835 --> 01:16:30,660
0,210 210,420 420,495 495,600 600,825
recognize I have a limit

3022
01:16:30,660 --> 01:16:32,715
0,285 285,620 910,1310 1690,1950 1950,2055
one there, right? So what

3023
01:16:32,715 --> 01:16:33,375
0,105 105,285 285,450 450,540 540,660
it really should have done

3024
01:16:33,375 --> 01:16:34,425
0,120 120,360 360,705 705,840 840,1050
is just probe down the

3025
01:16:34,425 --> 01:16:35,730
0,335 565,855 855,1005 1005,1155 1155,1305
index, find the first thing,

3026
01:16:35,730 --> 01:16:36,645
0,105 105,330 330,645 645,765 765,915
and then popped out and

3027
01:16:36,645 --> 01:16:37,665
0,275 445,675 675,735 735,855 855,1020
done. But in this case

3028
01:16:37,665 --> 01:16:39,045
0,165 165,720 720,1050 1050,1230 1230,1380
here, postgco wasn't smart enough

3029
01:16:39,045 --> 01:16:40,120
0,120 120,255 255,390 390,635
to figure that out.|
|

3030
01:16:40,690 --> 01:16:42,870
0,400 990,1235 1235,1340 1340,1750 1890,2180
Right. And it can't pick
正确的。它不能选择散列索引，因为我再一次执行通配符搜索。我没有实际的完整密钥。

3031
01:16:42,870 --> 01:16:45,075
0,150 150,465 465,800 850,1250 1930,2205
the hash index because again,

3032
01:16:45,075 --> 01:16:46,080
0,180 180,345 345,525 525,735 735,1005
I'm doing a wild card

3033
01:16:46,080 --> 01:16:47,210
0,240 240,420 420,660 660,825 825,1130
search. I don't have the

3034
01:16:47,440 --> 01:16:48,840
0,275 275,470 470,790
actual full key.|
|

3035
01:16:49,900 --> 01:16:51,040
0,400
Right.|
正确的。|

3036
01:16:51,840 --> 01:16:52,700
0,215 215,410 410,650 650,770 770,860
So you can see this
所以你可以从其他方面来看这一点。所以在这个例子中，我想找出所有比安迪更大的电子邮件。再说一次，我确实会扫描，但现在如果我做这样的事情。

3037
01:16:52,700 --> 01:16:53,825
0,60 60,180 180,435 435,800 880,1125
in other ways. So in

3038
01:16:53,825 --> 01:16:54,965
0,120 120,285 285,575 805,1050 1050,1140
this case here, I want

3039
01:16:54,965 --> 01:16:56,560
0,105 105,365 505,905 955,1275 1275,1595
to find all emails where

3040
01:16:56,820 --> 01:16:59,320
0,490 1020,1310 1310,1460 1460,1720 2100,2500
it's greater than Andy. Again,

3041
01:17:00,090 --> 01:17:01,925
0,305 305,905 905,1180 1440,1700 1700,1835
I doential scan, but now

3042
01:17:01,925 --> 01:17:02,585
0,120 120,210 210,315 315,480 480,660
if I do something like

3043
01:17:02,585 --> 01:17:03,700
0,275
this.|
|

3044
01:17:03,700 --> 01:17:06,490
0,380 550,885 885,1220 2050,2450 2470,2790
Final emails where final emails
最终电子邮件最终电子邮件字符串以Z Z Z开头的第一个字母，现在我在树的右侧。

3045
01:17:06,490 --> 01:17:08,550
0,270 270,620 1300,1575 1575,1755 1755,2060
where the the first letter

3046
01:17:08,960 --> 01:17:10,825
0,400 870,1270 1290,1565 1565,1715 1715,1865
the string starts with Z

3047
01:17:10,825 --> 01:17:12,115
0,165 165,455 745,1035 1035,1215 1215,1290
Z Z, now I'm on

3048
01:17:12,115 --> 01:17:12,820
0,105 105,285 285,480 480,585 585,705
the right side of the

3049
01:17:12,820 --> 01:17:13,780
0,290
tree.|
|

3050
01:17:13,780 --> 01:17:15,370
0,285 285,735 735,1230 1230,1485 1485,1590
And postgres recognizes based on
而Postgres根据分布情况进行识别。好的，好吧，你已经走得够远了，我要扫一扫。所以我可以进行索引扫描，因为这仍然会比完全中央扫描的数据量要少。

3051
01:17:15,370 --> 01:17:17,275
0,135 135,440 580,885 885,1190 1510,1905
the distribution. Okay, well, you're

3052
01:17:17,275 --> 01:17:18,130
0,165 165,330 330,510 510,690 690,855
far enough along the tree

3053
01:17:18,130 --> 01:17:18,760
0,135 135,270 270,330 330,435 435,630
where I'm going to scan

3054
01:17:18,760 --> 01:17:20,200
0,300 300,680 730,1125 1125,1305 1305,1440
along. So it's okay for

3055
01:17:20,200 --> 01:17:20,785
0,75 75,135 135,240 240,390 390,585
me to do the index

3056
01:17:20,785 --> 01:17:22,420
0,305 625,885 885,1095 1095,1350 1350,1635
scan, because that's still, that's

3057
01:17:22,420 --> 01:17:23,170
0,45 45,75 75,180 180,420 420,750
going to be less data

3058
01:17:23,170 --> 01:17:24,630
0,255 255,530 550,855 855,1185 1185,1460
than doing complete centralral scan.|
|

3059
01:17:26,870 --> 01:17:28,100
0,400
Right.|
正确的。|

3060
01:17:28,140 --> 01:17:29,165
0,245 245,350 350,530 530,740 740,1025
And at no point did
Postgres在任何时候都没有决定使用散列索引，因为再一次，我做的是小于等于通配符的匹配。

3061
01:17:29,165 --> 01:17:30,155
0,480 480,660 660,765 765,870 870,990
postgres decide to use the

3062
01:17:30,155 --> 01:17:31,295
0,240 240,510 510,780 780,960 960,1140
hash index because again, I'm

3063
01:17:31,295 --> 01:17:32,300
0,165 165,375 375,570 570,780 780,1005
doing like less than greater

3064
01:17:32,300 --> 01:17:34,040
0,195 195,330 330,690 690,950
than a wildcard matches.|
|

3065
01:17:34,550 --> 01:17:35,215
0,275 275,380 380,440 440,515 515,665
So we can do something
所以我们可以做这样的事情。

3066
01:17:35,215 --> 01:17:36,560
0,180 180,455
like this.|
|

3067
01:17:37,240 --> 01:17:38,150
0,260 260,410 410,530 530,635 635,910
Where? Now we can say.|
哪里?现在我们可以说。|

3068
01:17:39,670 --> 01:17:41,070
0,245 245,490 660,995 995,1235 1235,1400
You know, find emails where
您知道，使用In子句查找质量完全匹配的电子邮件。

3069
01:17:41,070 --> 01:17:42,645
0,270 270,590 670,990 990,1275 1275,1575
there's exact quality matches using

3070
01:17:42,645 --> 01:17:44,080
0,165 165,300 300,635
the in clause.|
|

3071
01:17:44,430 --> 01:17:45,920
0,275 275,440 440,605 605,770 770,1490
And now you see postgresides
现在，您可以在这里看到使用散列索引的postgreside。

3072
01:17:45,920 --> 01:17:47,705
0,210 210,470 1030,1290 1290,1560 1560,1785
that use the hash index

3073
01:17:47,705 --> 01:17:48,720
0,305
here.|
|

3074
01:17:48,720 --> 01:17:49,720
0,290
Right.|
正确的。|

3075
01:17:51,220 --> 01:17:52,515
0,260 260,605 605,845 845,1040 1040,1295
The bitmap index scan. I'll
位图索引扫描。我会解释这不是你想要的，不是真正的位图索引。

3076
01:17:52,515 --> 01:17:53,730
0,180 180,390 390,780 780,1035 1035,1215
explain that it's not what

3077
01:17:53,730 --> 01:17:54,855
0,240 240,480 480,585 585,720 720,1125
you, not a real bitmap

3078
01:17:54,855 --> 01:17:56,880
0,365
index.|
|

3079
01:17:57,100 --> 01:17:57,950
0,260 260,395 395,500 500,590 590,850
You can see it better
您可以更好地查看它，而不是在中使用。

3080
01:17:59,200 --> 01:18:00,900
0,230 230,305 305,485 485,820
instead of using in.|
|

3081
01:18:00,900 --> 01:18:01,950
0,165 165,270 270,530 670,930 930,1050
You can use a bunch
你可以使用很多操作系统，对吗？现在您看到的是，Postgres有多个索引条目，其中对于我在WHERE子句中的每个电子邮件地址，比如，你知道，某物等于某物或某物等于某物，每个条目都将是对散列索引的单独探测。

3082
01:18:01,950 --> 01:18:04,305
0,105 105,590 1090,1490 1840,2130 2130,2355
of OS, right? And now

3083
01:18:04,305 --> 01:18:05,090
0,195 195,330 330,435 435,525 525,785
what you see is that

3084
01:18:05,320 --> 01:18:08,130
0,515 515,820 1230,1610 1610,2170 2550,2810
postgres has multiple entries for

3085
01:18:08,130 --> 01:18:09,765
0,135 135,525 525,830 1210,1470 1470,1635
the indexam where for each

3086
01:18:09,765 --> 01:18:11,175
0,270 270,525 525,675 675,935 1135,1410
of each of the email

3087
01:18:11,175 --> 01:18:12,405
0,270 270,390 390,540 540,815 835,1230
addresses I had in that

3088
01:18:12,405 --> 01:18:13,970
0,255 255,515 565,885 885,1200 1200,1565
in my where clause like,

3089
01:18:14,050 --> 01:18:15,345
0,230 230,460 480,845 845,1085 1085,1295
you know, something equals something

3090
01:18:15,345 --> 01:18:17,145
0,285 285,570 570,765 765,1025 1525,1800
or something equals something, each

3091
01:18:17,145 --> 01:18:17,745
0,150 150,345 345,510 510,570 570,600
of those are going to

3092
01:18:17,745 --> 01:18:18,750
0,90 90,345 345,705 705,840 840,1005
be separate probe into the

3093
01:18:18,750 --> 01:18:20,000
0,270 270,590
hash index.|
|

3094
01:18:20,070 --> 01:18:21,440
0,290 290,530 530,785 785,1085 1085,1370
And then they maintain a
然后他们维护一个位图，我认为这是实际的两个ID d，两个偏移量，不是，不是页面。它们为每个索引探测器维护匹配值的位图。然后他们把它们放在一起。然后这就产生了你实际需要的两个确切的二元组。

3095
01:18:21,440 --> 01:18:23,630
0,195 195,465 465,830 850,1250 1930,2190
bit map of the, I

3096
01:18:23,630 --> 01:18:24,395
0,105 105,240 240,390 390,585 585,765
think it's the actual two

3097
01:18:24,395 --> 01:18:25,570
0,180 180,375 375,555 555,705 705,1175
ID d, the two offsets,

3098
01:18:25,890 --> 01:18:27,040
0,290 290,500 500,680 680,845 845,1150
not the, not the pages.

3099
01:18:27,210 --> 01:18:28,310
0,290 290,530 530,770 770,935 935,1100
They maintain a bit map

3100
01:18:28,310 --> 01:18:29,525
0,120 120,240 240,660 660,950 970,1215
of the matching values for

3101
01:18:29,525 --> 01:18:30,790
0,120 120,240 240,450 450,735 735,1265
each of those index probes.

3102
01:18:30,900 --> 01:18:31,835
0,260 260,380 380,545 545,770 770,935
And then they o them

3103
01:18:31,835 --> 01:18:33,350
0,210 210,575 865,1125 1125,1290 1290,1515
up together. And then that

3104
01:18:33,350 --> 01:18:34,610
0,360 360,585 585,780 780,1080 1080,1260
produces the exact twoples they

3105
01:18:34,610 --> 01:18:35,525
0,165 165,315 315,510 510,735 735,915
actually you actually you actually

3106
01:18:35,525 --> 01:18:36,900
0,120 120,395
would need.|
|

3107
01:18:36,940 --> 01:18:37,680
0,245 245,350 350,470 470,590 590,740
And this is sort of
这和我之前说的有点类似。你，你先从，从，从索引中找出你需要的页面，然后去真正去拿它们。所以他们在这里这样做。他们在索引中执行许多探测，实际上并没有从表中获得真正的数据。

3108
01:18:37,680 --> 01:18:38,460
0,270 270,495 495,585 585,660 660,780
similar to what I was

3109
01:18:38,460 --> 01:18:39,645
0,180 180,470 490,795 795,1005 1005,1185
saying before. You, you figure

3110
01:18:39,645 --> 01:18:41,460
0,165 165,420 420,785 1165,1545 1545,1815
out what the pages you

3111
01:18:41,460 --> 01:18:42,650
0,270 270,540 540,735 735,915 915,1190
need from the, from the,

3112
01:18:43,120 --> 01:18:45,015
0,245 245,380 380,605 605,940 1590,1895
from the index first, then

3113
01:18:45,015 --> 01:18:45,990
0,180 180,390 390,600 600,765 765,975
go actually go get them.

3114
01:18:45,990 --> 01:18:46,830
0,165 165,315 315,450 450,645 645,840
So they're doing that here.

3115
01:18:46,830 --> 01:18:47,775
0,195 195,315 315,495 495,645 645,945
They're doing much of probes

3116
01:18:47,775 --> 01:18:49,095
0,90 90,240 240,545 745,1140 1140,1320
in the index, don't actually

3117
01:18:49,095 --> 01:18:49,950
0,135 135,255 255,420 420,660 660,855
get the real data from

3118
01:18:49,950 --> 01:18:51,560
0,260 400,800
the tables.|
|

3119
01:18:52,190 --> 01:18:53,020
0,290 290,425 425,575 575,725 725,830
Doing the or on the
在位图上做还是在做？然后，您就有了实际需要获取的记录的索引列表。

3120
01:18:53,020 --> 01:18:54,040
0,135 135,410 490,765 765,900 900,1020
bit maps? Then you have

3121
01:18:54,040 --> 01:18:55,230
0,120 120,270 270,525 525,765 765,1190
the list of the indexes

3122
01:18:55,700 --> 01:18:56,515
0,215 215,290 290,470 470,680 680,815
of the records you actually

3123
01:18:56,515 --> 01:18:57,840
0,90 90,180 180,300 300,575
need to go get.|
|

3124
01:18:58,090 --> 01:18:59,180
0,400
Right.|
正确的。|

3125
01:19:00,930 --> 01:19:03,080
0,400 570,970 1710,1955 1955,2060 2060,2150
Okay, so the next thing
好的，接下来我想谈一谈聚类表。这样波斯格雷斯就不会行动了。Postgres支持集群命令，但它实际上并不支持。它将对您的表进行排序，但实际上并不维护排序，因为它不会被组织起来。它不在索引组织中。因此，您可以使用CLUSTER命令pres对数据进行排序，但是当您开始修改该表时，它的排序可能会打乱。

3126
01:19:03,080 --> 01:19:03,530
0,75 75,150 150,225 225,330 330,450
I want to do is

3127
01:19:03,530 --> 01:19:04,925
0,105 105,255 255,660 660,950 1060,1395
talk about clustering tables. So

3128
01:19:04,925 --> 01:19:07,085
0,510 510,855 855,1115 1375,1920 1920,2160
postgres doesn't act. Postgres supports

3129
01:19:07,085 --> 01:19:08,855
0,180 180,480 480,875 1435,1680 1680,1770
the cluster command but it

3130
01:19:08,855 --> 01:19:10,565
0,300 300,635 1075,1365 1365,1530 1530,1710
doesn't actually. And it will

3131
01:19:10,565 --> 01:19:12,005
0,195 195,390 390,695 1105,1350 1350,1440
sort your table, but it

3132
01:19:12,005 --> 01:19:13,490
0,225 225,420 420,725 835,1125 1125,1485
doesn't actually maintain the sorting

3133
01:19:13,490 --> 01:19:14,555
0,195 195,435 435,660 660,885 885,1065
because it because it's not

3134
01:19:14,555 --> 01:19:16,235
0,150 150,395 565,965 1315,1590 1590,1680
gonna be organized. It's not

3135
01:19:16,235 --> 01:19:17,740
0,135 135,375 375,755 1015,1260 1260,1505
in index organized. So you

3136
01:19:17,760 --> 01:19:19,460
0,305 305,515 515,815 815,1180 1320,1700
with the cluster command pres

3137
01:19:19,460 --> 01:19:20,765
0,255 255,405 405,555 555,830 1030,1305
will sort your data, but

3138
01:19:20,765 --> 01:19:21,740
0,135 135,270 270,435 435,840 840,975
as you start modifying the

3139
01:19:21,740 --> 01:19:22,520
0,210 210,420 420,540 540,660 660,780
table it can get out

3140
01:19:22,520 --> 01:19:23,660
0,135 135,270 270,375 375,620
of sort of order.|
|

3141
01:19:23,910 --> 01:19:24,485
0,230 230,335 335,410 410,500 500,575
So I'm not going to
所以我不会现场直播，因为这会花太长时间。我意识到我们有点超时了，但指挥权是。

3142
01:19:24,485 --> 01:19:25,175
0,90 90,225 225,450 450,630 630,690
do this live because it

3143
01:19:25,175 --> 01:19:26,360
0,90 90,255 255,405 405,665 895,1185
would take too long. And

3144
01:19:26,360 --> 01:19:26,945
0,165 165,300 300,450 450,495 495,585
I realized we're a little

3145
01:19:26,945 --> 01:19:27,815
0,150 150,300 300,480 480,690 690,870
over time, but the command

3146
01:19:27,815 --> 01:19:29,020
0,135 135,395
would be.|
|

3147
01:19:29,130 --> 01:19:31,020
0,380 380,650 650,940
Basically like this.|
基本上是这样的。|

3148
01:19:31,210 --> 01:19:32,870
0,335 335,500 500,590 590,850 1230,1660
Right. You would say cluster
正确的。你会说把桌子聚在一起。我们希望聚集，然后让您的索引聚集在一起。这大约需要一分钟才能运行。所以在我们上课之前我已经运行过了。所以我不会这么做的。但是我们可以去看看第一个里面有什么。

3149
01:19:33,100 --> 01:19:33,840
0,275 275,425 425,545 545,635 635,740
the table. We want to

3150
01:19:33,840 --> 01:19:35,940
0,290 1450,1695 1695,1815 1815,1950 1950,2100
cluster and then let the

3151
01:19:35,940 --> 01:19:37,380
0,150 150,410 700,990 990,1155 1155,1440
index you have be clustered

3152
01:19:37,380 --> 01:19:39,735
0,260 880,1170 1170,1460 1990,2250 2250,2355
on. This takes about a

3153
01:19:39,735 --> 01:19:40,380
0,135 135,270 270,405 405,525 525,645
minute to run. So I've

3154
01:19:40,380 --> 01:19:41,205
0,135 135,300 300,405 405,570 570,825
already run it before we

3155
01:19:41,205 --> 01:19:42,240
0,335 565,780 780,900 900,960 960,1035
class. So I'm not going

3156
01:19:42,240 --> 01:19:43,395
0,60 60,165 165,440 790,1050 1050,1155
to do that. But we

3157
01:19:43,395 --> 01:19:44,355
0,105 105,315 315,540 540,720 720,960
can go look at like

3158
01:19:44,355 --> 01:19:46,120
0,285 285,375 375,540 540,845
what's in the first.|
|

3159
01:19:46,850 --> 01:19:48,685
0,305 305,605 605,1000 1380,1655 1655,1835
The first, eh, the first
第一个，呃第一页，也就是CT ID是所有在Postgres设置的记录ID。所以你这样做，实际上这是未排序的，所以它看起来都是随机的，但如果我将表名改为CLUSTED。

3160
01:19:48,685 --> 01:19:49,810
0,300 300,570 570,705 705,945 945,1125
page, again the CT ID

3161
01:19:49,810 --> 01:19:50,635
0,210 210,315 315,480 480,690 690,825
is the record ID in

3162
01:19:50,635 --> 01:19:52,315
0,165 165,360 360,510 510,995 1435,1680
all set in postgres. So

3163
01:19:52,315 --> 01:19:55,045
0,105 105,240 240,515 1435,1835 2485,2730
you do that that actually

3164
01:19:55,045 --> 01:19:56,365
0,165 165,240 240,675 675,935 1075,1320
that's the unsorteded one, so

3165
01:19:56,365 --> 01:19:58,030
0,150 150,330 330,495 495,785 1435,1665
that looks all random, but

3166
01:19:58,030 --> 01:19:58,930
0,75 75,225 225,495 495,735 735,900
if I change the name

3167
01:19:58,930 --> 01:20:00,330
0,120 120,225 225,450 450,795 795,1400
of the table to clustered.|
|

3168
01:20:07,680 --> 01:20:09,120
0,245 245,350 350,545 545,880
Because of that. Sorry.|
正因为如此。抱歉的。|

3169
01:20:14,050 --> 01:20:15,195
0,350 350,590 590,770 770,965 965,1145
Right now you see that
现在您可以看到，在第一个偏移量的第一页中，两个极点实际上是按该顺序排序的。

3170
01:20:15,195 --> 01:20:16,230
0,135 135,315 315,570 570,855 855,1035
in the first page of

3171
01:20:16,230 --> 01:20:18,630
0,105 105,270 270,770 1210,1610 2140,2400
the first offsets, the two

3172
01:20:18,630 --> 01:20:19,710
0,120 120,255 255,555 555,960 960,1080
poles are actually sorted in

3173
01:20:19,710 --> 01:20:20,840
0,150 150,440
that order.|
|

3174
01:20:20,840 --> 01:20:21,880
0,260
Right.|
正确的。|

3175
01:20:23,540 --> 01:20:24,310
0,275 275,410 410,530 530,650 650,770
Based on based on the
基于基于索引的。因此，如果我继续删除其中一个条目，删除他们虚假电子邮件地址中的第一个人，我就会返回并。

3176
01:20:24,310 --> 01:20:25,195
0,255 255,495 495,585 585,720 720,885
index. So if I go

3177
01:20:25,195 --> 01:20:25,870
0,120 120,255 255,435 435,585 585,675
ahead and delete one of

3178
01:20:25,870 --> 01:20:27,040
0,105 105,560 640,915 915,1035 1035,1170
these entries, delete the very

3179
01:20:27,040 --> 01:20:28,870
0,180 180,470 1240,1500 1500,1620 1620,1830
first person in their fake

3180
01:20:28,870 --> 01:20:30,655
0,225 225,500 1060,1320 1320,1545 1545,1785
email address and I go

3181
01:20:30,655 --> 01:20:32,400
0,275 385,785
back and.|
|

3182
01:20:32,540 --> 01:20:33,400
0,245 245,350 350,545 545,755 755,860
Do the same. Scan on
做同样的事情。在桌子上扫描一下，对吗？普雷没有填补第一个空缺，对吗？它是空的。但现在如果我把这个假人放回去。

3183
01:20:33,400 --> 01:20:35,815
0,90 90,350 820,1220 1480,1880 2020,2415
the table right? Pre didn't

3184
01:20:35,815 --> 01:20:37,260
0,135 135,315 315,635 775,1080 1080,1445
fill in that first slot

3185
01:20:37,370 --> 01:20:39,145
0,335 335,785 785,1000 1410,1670 1670,1775
right? It's empty. But now

3186
01:20:39,145 --> 01:20:40,015
0,90 90,180 180,495 495,675 675,870
if I insert this fake

3187
01:20:40,015 --> 01:20:41,860
0,240 240,465 465,755
person back in.|
|

3188
01:20:42,130 --> 01:20:43,160
0,275 275,395 395,500 500,695 695,1030
And do the same scan.|
做同样的扫描。|

3189
01:20:44,920 --> 01:20:45,660
0,230 230,335 335,500 500,650 650,740
Right. They're still not in
正确的。它们仍然不在第一页上。

3190
01:20:45,660 --> 01:20:47,200
0,135 135,360 360,680
that first page.|
|

3191
01:20:48,810 --> 01:20:50,140
0,400
Right.|
正确的。|

3192
01:20:50,310 --> 01:20:51,200
0,245 245,335 335,470 470,680 680,890
So to go find them,
因此，为了找到它们，我们选择了STAR SELECT CTID。

3193
01:20:51,200 --> 01:20:53,780
0,180 180,470 640,990 990,1340 2260,2580
we do select star select

3194
01:20:53,780 --> 01:20:55,480
0,560
ctid.|
|

3195
01:20:56,550 --> 01:20:58,620
0,400 420,740 740,1240
From emails clustered.|
从聚集的电子邮件中。|

3196
01:21:01,950 --> 01:21:03,780
0,400 540,940
Where? Email.|
哪里?电子邮件。|

3197
01:21:03,940 --> 01:21:05,240
0,400
Equals.|
相等。|

3198
01:21:06,090 --> 01:21:07,440
0,400
S.|
S.|

3199
01:21:07,510 --> 01:21:09,075
0,400 630,935 1070,1130 1130,1295 1295,1565
Right now they're on page
现在在二百九十九页。

3200
01:21:09,075 --> 01:21:10,460
0,195 195,360 360,665
two ninety nine.|
|

3201
01:21:10,870 --> 01:21:11,490
0,245 245,365 365,410 410,500 500,620
I don't know where that
我不知道它在哪里，一些随机的东西，但同样，它不是按排序顺序的，因为Postgres不能维护顺序，因为它没有真正的聚集索引。

3202
01:21:11,490 --> 01:21:12,480
0,210 210,435 435,615 615,795 795,990
is, some random thing, but

3203
01:21:12,480 --> 01:21:13,290
0,195 195,360 360,450 450,570 570,810
again, it's not in sorted

3204
01:21:13,290 --> 01:21:15,495
0,260 370,675 675,980 1300,1875 1875,2205
order because, again, postgres can't

3205
01:21:15,495 --> 01:21:17,265
0,240 240,555 555,875 1465,1695 1695,1770
maintain the order because it

3206
01:21:17,265 --> 01:21:18,590
0,165 165,300 300,495 495,840 840,1325
doesn't have true clustered indexes.|
|

3207
01:21:19,440 --> 01:21:20,840
0,400
Okay.|
好吧。|

3208
01:21:22,430 --> 01:21:24,620
0,400
So.|
所以。|

3209
01:21:25,090 --> 01:21:26,210
0,290 290,470 470,635 635,815 815,1120
B plus trees are important.
B+树很重要。它可能是您的数据库系统的最佳选择。尝试是相当不错的。就像我之前说的，你可以有b+树的尝试，但是人加街有很多更快的方法。下一节课，我们讨论如何让你的v街线安全，通过向下遍历，甚至当你做分裂和合并的时候，好的，罂粟花和他妈的钩子每克28，取决于如果它向上，你还没有打暴徒，但仍然让你闭嘴，我用CL的底部打你，告诉你抬起头，展示给我它是什么，把你的脸吹回去，我必须挡住水龙头，f不能追踪，就像大便，你不能在多米尼加，或者你得叫我多米尼克。

3210
01:21:26,440 --> 01:21:27,650
0,335 335,590 590,755 755,905 905,1210
It probably the best choice

3211
01:21:27,700 --> 01:21:29,340
0,380 380,635 635,845 845,1180 1320,1640
for your database system. Tries

3212
01:21:29,340 --> 01:21:31,155
0,165 165,315 315,620 1510,1740 1740,1815
are pretty good. You can

3213
01:21:31,155 --> 01:21:31,905
0,150 150,330 330,480 480,615 615,750
have b plus trees of

3214
01:21:31,905 --> 01:21:32,810
0,210 210,405 405,525 525,645 645,905
tries as I said before

3215
01:21:33,550 --> 01:21:35,810
0,400 1380,1640 1640,1775 1775,1955 1955,2260
but people plus street is

3216
01:21:36,010 --> 01:21:36,660
0,320 320,395 395,485 485,560 560,650
there's a bunch of ways

3217
01:21:36,660 --> 01:21:38,760
0,90 90,320 340,740 1150,1550 1750,2100
of about faster. So next

3218
01:21:38,760 --> 01:21:39,735
0,315 315,555 555,690 690,825 825,975
class we talk about how

3219
01:21:39,735 --> 01:21:40,470
0,90 90,195 195,360 360,525 525,735
do you actually make your

3220
01:21:40,470 --> 01:21:42,375
0,255 255,495 495,720 720,1040 1570,1905
v street thread safe by

3221
01:21:42,375 --> 01:21:43,830
0,510 510,765 765,1080 1080,1305 1305,1455
traversing down and even when

3222
01:21:43,830 --> 01:21:44,870
0,135 135,285 285,495 495,600 600,1040
you're doing splits and merges

3223
01:21:45,160 --> 01:22:05,775
0,400 19680,19955 19955,20315 20315,20465 20465,20615
okay the poppy with the

3224
01:22:05,775 --> 01:22:07,770
0,600 600,870 870,1175 1255,1800 1800,1995
motherfuck hook up 28 a

3225
01:22:07,770 --> 01:22:09,240
0,350 430,765 765,990 990,1155 1155,1470
gram depending on if it's

3226
01:22:09,240 --> 01:22:10,440
0,350 460,720 720,945 945,1065 1065,1200
up you ain't hit the

3227
01:22:10,440 --> 01:22:11,805
0,195 195,530 670,975 975,1170 1170,1365
mob yet still got your

3228
01:22:11,805 --> 01:22:12,885
0,180 180,405 405,690 690,945 945,1080
shut up I smack you

3229
01:22:12,885 --> 01:22:13,980
0,120 120,270 270,510 510,840 840,1095
with the bottom of cl

3230
01:22:13,980 --> 01:22:14,960
0,180 180,330 330,495 495,690 690,980
to tell you look up

3231
01:22:15,100 --> 01:22:15,990
0,290 290,440 440,545 545,680 680,890
show me what it sa

3232
01:22:15,990 --> 01:22:17,295
0,285 285,600 600,840 840,1050 1050,1305
at for blow your face

3233
01:22:17,295 --> 01:22:18,615
0,300 300,540 540,780 780,1065 1065,1320
back I gotta block on

3234
01:22:18,615 --> 01:22:20,025
0,300 300,540 540,810 810,1185 1185,1410
taps the f can't trace

3235
01:22:20,025 --> 01:22:21,645
0,675 675,840 840,1080 1080,1380 1380,1620
thatyl is like t for

3236
01:22:21,645 --> 01:22:22,845
0,285 285,510 510,825 825,1020 1020,1200
poop you can't lace that

3237
01:22:22,845 --> 01:22:24,330
0,150 150,300 300,1065 1065,1320 1320,1485
at the Dominican or you

3238
01:22:24,330 --> 01:22:25,500
0,255 255,510 510,675 675,1140
got call me Dominic.|
|

3239
01:22:25,500 --> 01:22:27,180
0,240 240,570 570,1005 1005,1260 1260,1680
And black sclly black leather,
黑色的黑色皮革，黑色的松木装饰着我整个黑色肮脏的大门，把你送到普尔门。你让你的Savat试着滑冰，这是你的第一个错误，我在那块蛋糕上，你的体重，。

3240
01:22:27,180 --> 01:22:28,755
0,270 270,615 615,1125 1125,1320 1320,1575
black sued timberlands my whole

3241
01:22:28,755 --> 01:22:30,015
0,330 330,630 630,855 855,1065 1065,1260
black dirty gate to send

3242
01:22:30,015 --> 01:22:31,100
0,165 165,300 300,450 450,720 720,1085
you to the pur gates.

3243
01:22:31,240 --> 01:22:32,295
0,275 275,410 410,560 560,905 905,1055
You get your savat trying

3244
01:22:32,295 --> 01:22:33,135
0,165 165,375 375,525 525,720 720,840
to skate and that's your

3245
01:22:33,135 --> 01:22:34,755
0,270 270,665 895,1185 1185,1365 1365,1620
first mistake I in line

3246
01:22:34,755 --> 01:22:37,650
0,210 210,360 360,555 555,845 2575,2895
for that cake, your weight,

3247
01:22:37,650 --> 01:22:46,539
0,320
the.|
|
