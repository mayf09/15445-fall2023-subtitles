1
00:00:34,900 --> 00:00:37,620
0,400
Back.|
背。|

2
00:00:37,690 --> 00:00:39,885
0,230 230,410 410,680 680,1000 1920,2195
All right so eh some
好的，那么，呃，上节课的一些快速的东西，行政的东西，嗯？才过了一天。我们已经收到电子邮件了。第一件事是，上节课我犯了一个错误，我说泰德·科德在宾夕法尼亚大学获得了博士学位。他在密歇根获得博士学位，在那里，所有优秀的数据都获得了博士学位，所以迈克·斯威克在那里获得了他的P-G学位。泰德·科在那里得到了他的P-G，大卫·德维特，另一个著名的戴维斯。所以不是宾夕法尼亚，而是密歇根。另一件事是人们对音频有这样的抱怨。亲爱的安迪，你课上的音频很烂，所以我看你请不起音响工程师，安迪，我喜欢这门课，但我听不下去，因为音频搞砸了。你这么做的时候发生了什么？我丢失了一张Will Live，所以上次是我的错，所以我们正在重复录制，所以希望这次我们在发布它时不会有任何问题。然后我们真的收到了关于你的电子邮件，这很令人惊讶，对吗？我上个月在匹兹堡的21世纪桥表演中看了DJ Two P的表演。这是真的吗？正确的。你很幸运。

3
00:00:39,885 --> 00:00:41,550
0,180 180,485 625,1065 1065,1320 1320,1665
quick things, administrative things from

4
00:00:41,550 --> 00:00:43,815
0,240 240,405 405,690 690,1070 1930,2265
from last class eh? It's

5
00:00:43,815 --> 00:00:44,505
0,105 105,225 225,360 360,540 540,690
only been one day. We

6
00:00:44,505 --> 00:00:46,460
0,120 120,375 375,755 1015,1415 1555,1955
already got emails EM. So

7
00:00:46,930 --> 00:00:47,810
0,260 260,395 395,530 530,635 635,880
the first thing is that

8
00:00:47,860 --> 00:00:48,945
0,260 260,365 365,515 515,785 785,1085
I made a mistake last

9
00:00:48,945 --> 00:00:50,100
0,270 270,480 480,645 645,855 855,1155
class I said ted CoD

10
00:00:50,100 --> 00:00:51,950
0,120 120,270 270,780 780,1130 1450,1850
got his PhD at Penn.

11
00:00:52,360 --> 00:00:53,085
0,245 245,320 320,410 410,650 650,725
He got his PhD at

12
00:00:53,085 --> 00:00:54,465
0,245 655,930 930,1110 1110,1260 1260,1380
Michigan where all the great

13
00:00:54,465 --> 00:00:55,760
0,195 195,375 375,540 540,705 705,1295
data who got their PHDs

14
00:00:56,560 --> 00:00:58,905
0,400 1500,1790 1790,1955 1955,2240 2240,2345
so Mike snow breakaker got

15
00:00:58,905 --> 00:00:59,700
0,105 105,255 255,405 405,585 585,795
his P G there. Ted

16
00:00:59,700 --> 00:01:00,345
0,165 165,285 285,375 375,495 495,645
Co got his P G

17
00:01:00,345 --> 00:01:01,410
0,180 180,390 390,705 705,900 900,1065
there David DeWitt another famous

18
00:01:01,410 --> 00:01:02,490
0,210 210,530 700,930 930,990 990,1080
Davis guy. So it was

19
00:01:02,490 --> 00:01:04,455
0,165 165,465 465,765 765,1070 1720,1965
not Penn it was it

20
00:01:04,455 --> 00:01:05,790
0,105 105,365 835,1065 1065,1185 1185,1335
was Michigan. The other thing

21
00:01:05,790 --> 00:01:07,785
0,135 135,390 390,765 765,1160 1720,1995
is people complain that about

22
00:01:07,785 --> 00:01:09,315
0,120 120,365 745,1005 1005,1265 1285,1530
the audio. Dear Andy the

23
00:01:09,315 --> 00:01:10,245
0,150 150,300 300,405 405,585 585,930
audio of your class sucks

24
00:01:10,245 --> 00:01:11,040
0,75 75,165 165,465 465,645 645,795
so I can't see you

25
00:01:11,040 --> 00:01:11,940
0,150 150,270 270,510 510,780 780,900
afford a sound engineer do

26
00:01:11,940 --> 00:01:13,110
0,90 90,350 550,870 870,1050 1050,1170
it right Andy I love

27
00:01:13,110 --> 00:01:13,860
0,150 150,345 345,495 495,600 600,750
the course but I can't

28
00:01:13,860 --> 00:01:14,445
0,135 135,300 300,390 390,465 465,585
listen to because the audio

29
00:01:14,445 --> 00:01:15,465
0,135 135,345 345,540 540,750 750,1020
is messed up. What happened

30
00:01:15,465 --> 00:01:16,410
0,270 270,435 435,570 570,780 780,945
while you're doing this? I

31
00:01:16,410 --> 00:01:18,470
0,150 150,285 285,420 420,710 1660,2060
lost a would live so

32
00:01:18,760 --> 00:01:20,025
0,400 510,770 770,905 905,1070 1070,1265
that that was my fault

33
00:01:20,025 --> 00:01:21,015
0,195 195,435 435,630 630,780 780,990
last time so we're double

34
00:01:21,015 --> 00:01:22,320
0,330 330,525 525,755 925,1170 1170,1305
recording so hopefully we won't

35
00:01:22,320 --> 00:01:24,600
0,75 75,320 400,800 1690,1980 1980,2280
have any issues with posting

36
00:01:24,600 --> 00:01:25,665
0,225 225,450 450,710 730,975 975,1065
it this time. And then

37
00:01:25,665 --> 00:01:26,850
0,165 165,330 330,575 745,1035 1035,1185
we actually got emails about

38
00:01:26,850 --> 00:01:29,270
0,260 940,1200 1200,1460 1690,2055 2055,2420
you which is surprising right?

39
00:01:29,950 --> 00:01:31,140
0,275 275,470 665,815 815,980 980,1190
I saw DJ two p

40
00:01:31,140 --> 00:01:33,030
0,240 240,510 510,860 1480,1740 1740,1890
last month performing at the

41
00:01:33,030 --> 00:01:34,605
0,290 610,1065 1065,1275 1275,1455 1455,1575
bridge 21 over show in

42
00:01:34,605 --> 00:01:36,860
0,540 540,735 735,840 840,1115 1855,2255
Pittsburgh. Is that true? Right.

43
00:01:37,270 --> 00:01:38,100
0,320 320,455 455,760
You're very lucky.|
|

44
00:01:38,100 --> 00:01:39,150
0,345 345,465 465,675 675,840 840,1050
DJ like that he is
像那样的DJ，他很贵。SEM有很多钱，没有很多钱还好JDJ两个P是可笑的。他是单身吗？我在要求我的，然后她就像没有拇指的泰勒·斯威夫特。我不知道是什么意思，那么你是单身吗？

45
00:01:39,150 --> 00:01:41,610
0,380 1690,2070 2070,2220 2220,2340 2340,2460
expensive. Sem have a lot

46
00:01:41,610 --> 00:01:43,725
0,105 105,350 1660,1920 1920,2025 2025,2115
of money, does not have

47
00:01:43,725 --> 00:01:44,510
0,75 75,165 165,255 255,435 435,785
a lot of money okay

48
00:01:45,670 --> 00:01:47,715
0,400 1140,1580 1580,1745 1745,1910 1910,2045
j DJ two p is

49
00:01:47,715 --> 00:01:49,380
0,245 475,750 750,960 960,1295 1375,1665
ridiculous. Is he single? I'm

50
00:01:49,380 --> 00:01:54,530
0,180 180,360 360,590 4660,4905 4905,5150
asking for my and then

51
00:01:54,610 --> 00:01:55,995
0,350 350,500 500,815 815,1130 1130,1385
she's like Taylor Swift without

52
00:01:55,995 --> 00:01:57,255
0,270 270,810 810,975 975,1110 1110,1260
any thumbs. I dont know

53
00:01:57,255 --> 00:02:01,340
0,335 2305,2705 3385,3645 3645,3795 3795,4085
means so are you single?|
|

54
00:02:01,900 --> 00:02:09,250
0,465 465,740 1120,1520 3850,4250 7030,7350
I'm not all right anyway.
不管怎么说，我都不太好。那是他们的问题。所以今天的课我们来讲讲SQL.嗯，上一节课我们花时间讨论了国家模型。我们讨论了在我看来，对于每个可能的数据库，您可以认为关系数据模型的高级数据模型如何可以用来表示几乎所有不同的模式。然后，我们展示了如何将代数作为我们如何执行查询或定义查询以拥有关系数据库的构建块。因此，今天的课程真正要讨论的是SQL，它是一种用于与数据库系统交互的声明性或非过程性语言。

55
00:02:09,250 --> 00:02:12,850
0,285 285,420 420,710 2650,3050 3160,3600
That's their problem. So today's

56
00:02:12,850 --> 00:02:13,615
0,135 135,285 285,390 390,525 525,765
class we to talk about

57
00:02:13,615 --> 00:02:16,420
0,485 625,1025 1555,1955 2245,2580 2580,2805
sql. EM, the last class

58
00:02:16,420 --> 00:02:17,155
0,165 165,315 315,480 480,630 630,735
we spent time talk on

59
00:02:17,155 --> 00:02:18,835
0,375 375,635 1015,1320 1320,1515 1515,1680
theationalial model. We talked about

60
00:02:18,835 --> 00:02:20,200
0,275 355,630 630,870 870,1170 1170,1365
how in my opinion that

61
00:02:20,200 --> 00:02:22,140
0,255 255,650 970,1275 1275,1560 1560,1940
a superior data model for

62
00:02:22,280 --> 00:02:23,470
0,350 350,635 635,905 905,1085 1085,1190
every possible database you can

63
00:02:23,470 --> 00:02:24,600
0,105 105,195 195,315 315,590 730,1130
sort of think of the

64
00:02:24,860 --> 00:02:26,310
0,410 410,665 665,935 935,1175 1175,1450
relational data model can be

65
00:02:27,080 --> 00:02:28,945
0,380 380,650 650,940 1470,1730 1730,1865
used to represent pretty much

66
00:02:28,945 --> 00:02:30,250
0,210 210,360 360,540 540,1020 1020,1305
all the different schemes that

67
00:02:30,250 --> 00:02:31,735
0,180 180,285 285,435 435,740 1240,1485
that are out there. And

68
00:02:31,735 --> 00:02:32,620
0,75 75,180 180,375 375,675 675,885
then we showed how to

69
00:02:32,620 --> 00:02:33,870
0,315 315,390 390,540 540,830 850,1250
algebra was the building block

70
00:02:34,130 --> 00:02:35,440
0,400 420,725 725,875 875,1070 1070,1310
for how we would execute

71
00:02:35,440 --> 00:02:37,530
0,480 480,860 1000,1380 1380,1815 1815,2090
queries or define queries to

72
00:02:39,380 --> 00:02:41,185
0,275 275,380 380,620 620,970 1530,1805
own a relational database. So

73
00:02:41,185 --> 00:02:42,340
0,375 375,540 540,720 720,915 915,1155
today's class is really now

74
00:02:42,340 --> 00:02:43,540
0,180 180,360 360,630 630,1065 1065,1200
to talk about sql, which

75
00:02:43,540 --> 00:02:45,775
0,260 580,870 870,1580 1750,2040 2040,2235
is a declarative or non

76
00:02:45,775 --> 00:02:48,930
0,555 555,875 1105,1505 2335,2850 2850,3155
procedural language for interacting with

77
00:02:49,190 --> 00:02:50,560
0,275 275,530 530,910
a database system.|
|

78
00:02:50,560 --> 00:02:52,510
0,320 1150,1470 1470,1575 1575,1740 1740,1950
And we'll see over time
我们将看到，随着时间的推移，SQL已经发展到了最初的位置，在20世纪70年代，当它第一次被定义时，它对关系数据库应该是什么样子有非常严格的要求。但在过去的40年里，它得到了扩展，以支持看起来不像是关系的东西，例如json。

79
00:02:52,510 --> 00:02:53,550
0,135 135,285 285,540 540,705 705,1040
is that sql has evolved

80
00:02:53,630 --> 00:02:55,375
0,400 660,935 935,1115 1115,1420 1500,1745
where in the beginning, in

81
00:02:55,375 --> 00:02:56,290
0,90 90,285 285,720 720,840 840,915
the nineteen seventies, when it

82
00:02:56,290 --> 00:02:57,190
0,120 120,360 360,615 615,765 765,900
was first defined, it was

83
00:02:57,190 --> 00:02:59,125
0,255 255,540 540,860 1030,1430 1690,1935
very strict about what a

84
00:02:59,125 --> 00:03:00,420
0,240 240,525 525,780 780,990 990,1295
relational database should look like.

85
00:03:00,830 --> 00:03:02,710
0,400 870,1145 1145,1265 1265,1510 1560,1880
But in the last forty

86
00:03:02,710 --> 00:03:04,450
0,320 370,795 795,1130 1150,1455 1455,1740
years it's expanded to support

87
00:03:04,450 --> 00:03:06,060
0,315 315,650 790,1155 1155,1275 1275,1610
things that don't look relational,

88
00:03:06,080 --> 00:03:07,820
0,290 290,665 665,860 860,1150
like json, for example.|
|

89
00:03:07,820 --> 00:03:09,260
0,350 700,945 945,1140 1140,1335 1335,1440
EM, so let's, let's start
嗯，让我们，让我们从头开始，谈谈它是如何开始的，然后我们将讨论在它的现代版本中可以做的更有趣的事情。

90
00:03:09,260 --> 00:03:10,055
0,165 165,375 375,525 525,630 630,795
the beginning, talk about how

91
00:03:10,055 --> 00:03:11,030
0,240 240,390 390,645 645,855 855,975
so got started, and then

92
00:03:11,030 --> 00:03:13,595
0,195 195,360 360,680 1840,2205 2205,2565
we'll talk about the more

93
00:03:13,595 --> 00:03:15,365
0,395 955,1245 1245,1380 1380,1515 1515,1770
interesting things you can do

94
00:03:15,365 --> 00:03:16,810
0,365 385,735 735,1005 1005,1185 1185,1445
in modern versions of it.|
|

95
00:03:17,700 --> 00:03:20,780
0,395 395,790 1350,1750 2430,2870 2870,3080
So the the sequel goes
所以续集要追溯到20世纪70年代，泰德·科布又一次上映了。当他写第一篇论文时，他还没有定义用于操作关系数据库的编程语言。这一切都是数学上的。人们说，哦，那个。

96
00:03:20,780 --> 00:03:22,210
0,255 255,435 435,525 525,770 820,1430
back to the nineteen seventies

97
00:03:22,590 --> 00:03:24,350
0,275 275,550 960,1235 1235,1445 1445,1760
and again for ted cobb.

98
00:03:24,350 --> 00:03:25,115
0,90 90,195 195,360 360,540 540,765
When he wrote that first

99
00:03:25,115 --> 00:03:26,810
0,335 685,960 960,1275 1275,1515 1515,1695
paper, he didn't define a

100
00:03:26,810 --> 00:03:28,865
0,240 240,620 880,1280 1510,1800 1800,2055
programming language for operating relational

101
00:03:28,865 --> 00:03:30,370
0,435 435,525 525,600 600,750 750,1505
databases. It was all mathematical.

102
00:03:30,840 --> 00:03:32,260
0,350 350,620 620,845 845,1085 1085,1420
People said like, oh, the.|
|

103
00:03:33,400 --> 00:03:34,960
0,260 700,945 945,1050 1050,1275 1275,1560
The, you know, the paper
你知道，这篇论文是如此深不可测，没有人能理解它。如果你真的读了，它实际上是很容易理解的。我想，那时候人们只是不喜欢数学而已。然后他。

104
00:03:34,960 --> 00:03:36,265
0,195 195,345 345,930 930,1080 1080,1305
was so inscrutable, nobody can

105
00:03:36,265 --> 00:03:38,095
0,270 270,575 1285,1545 1545,1695 1695,1830
understand it. If you actually

106
00:03:38,095 --> 00:03:38,890
0,105 105,210 210,420 420,585 585,795
read it, it's actually pretty

107
00:03:38,890 --> 00:03:40,600
0,350 490,1095 1095,1365 1365,1470 1470,1710
easily understandable. It's just people

108
00:03:40,600 --> 00:03:41,605
0,300 300,420 420,660 660,885 885,1005
didn't like math back in

109
00:03:41,605 --> 00:03:43,285
0,90 90,195 195,300 300,545 1405,1680
the day, I guess. So

110
00:03:43,285 --> 00:03:45,540
0,270 270,665
then he.|
|

111
00:03:45,610 --> 00:03:47,220
0,275 275,500 500,1055 1055,1445 1445,1610
Some p IBM saws paper
一些IBM的人看着论文，试图开始建立，你知道，实验性的关系数据库，看看他们是否真的能把他的数学思想付诸实践。据我所知，最早的关系数据库语言是IBM在1971年发明的名为Square的东西，这是为了一个更早的项目，ib为最早的关系数据库系统之一开发的。可能是第一支，听起来像是一支奇怪的实验性摇滚乐队。它被称为彼得·李关系测试车。但这是他们建造的第一件作为早期原型的东西，表明你可以将Ted Codd的想法实际应用到铁路系统中。

112
00:03:47,220 --> 00:03:48,170
0,210 210,390 390,510 510,660 660,950
and try to start building,

113
00:03:48,730 --> 00:03:50,430
0,245 245,455 455,950 950,1145 1145,1700
you know, experimental relational databases

114
00:03:50,430 --> 00:03:51,285
0,135 135,315 315,525 525,690 690,855
to see whether they can

115
00:03:51,285 --> 00:03:53,280
0,195 195,465 465,845 1105,1770 1770,1995
actually take his mathematical ideas

116
00:03:53,280 --> 00:03:54,240
0,180 180,285 285,530 670,900 900,960
and put it, put it

117
00:03:54,240 --> 00:03:55,890
0,135 135,440 1000,1275 1275,1455 1455,1650
into practice. And so the

118
00:03:55,890 --> 00:03:58,110
0,255 255,620 1090,1575 1575,1905 1905,2220
very first relational database language,

119
00:03:58,110 --> 00:03:59,180
0,210 210,315 315,510 510,765 765,1070
as far as I know

120
00:04:00,550 --> 00:04:01,650
0,260 260,395 395,560 560,815 815,1100
was this thing called square

121
00:04:01,650 --> 00:04:04,070
0,165 165,615 615,960 960,1340 1360,2420
that IBM invented in 1971

122
00:04:05,080 --> 00:04:06,200
0,260 260,380 380,545 545,785 785,1120
and this was for a

123
00:04:06,280 --> 00:04:07,755
0,400 480,845 845,1055 1055,1295 1295,1475
earlier project that ib was

124
00:04:07,755 --> 00:04:09,465
0,305 535,935 1315,1560 1560,1620 1620,1710
developing for one of the

125
00:04:09,465 --> 00:04:10,890
0,180 180,465 465,735 735,1085 1105,1425
first relational database systems. Probably

126
00:04:10,890 --> 00:04:13,125
0,225 225,450 450,770 1660,1965 1965,2235
the first one, which sounds

127
00:04:13,125 --> 00:04:13,950
0,225 225,360 360,480 480,585 585,825
it sounds like a weird

128
00:04:13,950 --> 00:04:15,735
0,495 495,720 720,1040 1330,1650 1650,1785
experimental rock band. It's called

129
00:04:15,735 --> 00:04:17,100
0,165 165,405 405,690 690,1080 1080,1365
the Peter Lee relational test

130
00:04:17,100 --> 00:04:18,450
0,320 790,1020 1020,1110 1110,1215 1215,1350
vehicle. But that was the

131
00:04:18,450 --> 00:04:19,575
0,180 180,345 345,510 510,765 765,1125
first thing they built as

132
00:04:19,575 --> 00:04:21,525
0,255 255,465 465,1200 1200,1595 1675,1950
an early prototype to show

133
00:04:21,525 --> 00:04:22,320
0,105 105,195 195,360 360,585 585,795
that you could take ted

134
00:04:22,320 --> 00:04:23,370
0,345 345,555 555,750 750,915 915,1050
codd's ideas and actually put

135
00:04:23,370 --> 00:04:24,770
0,260 370,705 705,900 900,1080 1080,1400
it into a rail system.|
|

136
00:04:25,400 --> 00:04:26,830
0,270 270,495 495,780 780,1080 1080,1430
The problem with square, though,
然而，Square的问题是，您永远不能真正重用它，因为您必须垂直编写奇怪的符号，而您实际上不能这样做。这是你要写的一篇论文中的一篇。

137
00:04:26,850 --> 00:04:28,085
0,275 275,550 660,920 920,1025 1025,1235
is that you can never

138
00:04:28,085 --> 00:04:29,705
0,365 445,870 870,1140 1140,1425 1425,1620
actually reuse it because you

139
00:04:29,705 --> 00:04:31,145
0,150 150,285 285,545 805,1155 1155,1440
had to write in weird

140
00:04:31,145 --> 00:04:34,595
0,545 955,1625 1855,2255 2995,3270 3270,3450
notation vertically, which you can't

141
00:04:34,595 --> 00:04:36,830
0,120 120,425 745,990 990,1235 1945,2235
really do. So this is

142
00:04:36,830 --> 00:04:38,375
0,290 490,890 1060,1290 1290,1350 1350,1545
from the one of the

143
00:04:38,375 --> 00:04:39,970
0,365 655,990 990,1170 1170,1305 1305,1595
papers right you would write.|
|

144
00:04:40,620 --> 00:04:41,400
0,225 225,345 345,465 465,570 570,780
This is how to do
这就是如何按部门在Sales表上进行扫描，就像你会用这种奇怪的垂直方式写下即使在今天你也不会在键盘上使用的字符，所以实际上从来没有人这样做过。

145
00:04:41,400 --> 00:04:43,080
0,350 610,960 960,1290 1290,1530 1530,1680
a scan on on the

146
00:04:43,080 --> 00:04:44,505
0,225 225,465 465,705 705,1040 1150,1425
sales table by department, like

147
00:04:44,505 --> 00:04:45,300
0,150 150,330 330,525 525,645 645,795
you would write in this

148
00:04:45,300 --> 00:04:46,875
0,315 315,705 705,1050 1050,1290 1290,1575
weird vertical way with characters

149
00:04:46,875 --> 00:04:47,640
0,255 255,360 360,510 510,630 630,765
that you wouldn't have on

150
00:04:47,640 --> 00:04:49,695
0,120 120,530 580,900 900,1220 1750,2055
a keyboard even today, so

151
00:04:49,695 --> 00:04:50,535
0,180 180,375 375,540 540,675 675,840
no one actually ever did

152
00:04:50,535 --> 00:04:51,460
0,275
this.|
|

153
00:04:51,500 --> 00:04:54,055
0,245 245,490 840,1540 2130,2405 2405,2555
So then IBM threw that
然后ibm抛弃了这一点，他们开始为system r项目构建一种新的查询语言，名为Sql，拼写为S E Q E L EM，这是我们将在整个学期中讨论的系统。但这是IBM开始构建的第二个关系数据库系统，试图证明Ted Codd的工作实际上是可以完成的。彼得·李获奖的地点是在英国。那是一个很小的团队。系统r项目在圣何塞的IBM研究中心进行，这是一项非常非常重要的任务。

154
00:04:54,055 --> 00:04:55,105
0,210 210,405 405,555 555,750 750,1050
away and they started building

155
00:04:55,105 --> 00:04:57,070
0,395 835,1140 1140,1395 1395,1680 1680,1965
a new query language called

156
00:04:57,070 --> 00:04:58,705
0,500 610,975 975,1170 1170,1410 1410,1635
sql spelled S E Q

157
00:04:58,705 --> 00:05:00,580
0,210 210,515 865,1265 1435,1725 1725,1875
E L EM for the

158
00:05:00,580 --> 00:05:01,825
0,180 180,420 420,705 705,1035 1035,1245
system r project, which is

159
00:05:01,825 --> 00:05:02,890
0,150 150,390 390,615 615,765 765,1065
a system we'll talk about

160
00:05:02,890 --> 00:05:04,165
0,270 270,405 405,710 880,1140 1140,1275
throughout the semester. But this

161
00:05:04,165 --> 00:05:05,575
0,150 150,420 420,720 720,1005 1005,1410
was the the second relational

162
00:05:05,575 --> 00:05:06,805
0,255 255,510 510,720 720,1065 1065,1230
database system that IBM started

163
00:05:06,805 --> 00:05:07,690
0,255 255,480 480,615 615,735 735,885
building to try to show

164
00:05:07,690 --> 00:05:09,880
0,180 180,375 375,920 1690,1980 1980,2190
that ted codd's work could

165
00:05:09,880 --> 00:05:11,170
0,135 135,195 195,440 820,1095 1095,1290
actually be done. The Peter

166
00:05:11,170 --> 00:05:11,950
0,210 210,390 390,555 555,675 675,780
Lee won that was in

167
00:05:11,950 --> 00:05:12,865
0,225 225,525 525,705 705,795 795,915
the UK. That was a

168
00:05:12,865 --> 00:05:14,200
0,180 180,485 595,885 885,1095 1095,1335
small team. The system r

169
00:05:14,200 --> 00:05:15,810
0,320 610,900 900,1125 1125,1335 1335,1610
project was in san Jose

170
00:05:16,700 --> 00:05:17,830
0,275 275,575 575,755 755,935 935,1130
at IBM research and that

171
00:05:17,830 --> 00:05:18,685
0,195 195,270 270,390 390,615 615,855
that was a major, major

172
00:05:18,685 --> 00:05:19,720
0,515
undertaking.|
|

173
00:05:19,760 --> 00:05:21,760
0,400 660,920 920,1115 1115,1450 1530,2000
EM, so they defined sql
EM，所以他们早在1972年就定义了SQL。这是唐·张伯伦和他的声音。他们使用这种查询语言和IDEA，即结构化英语查询语言。

174
00:05:21,760 --> 00:05:24,505
0,225 225,420 420,1245 1245,1520 2440,2745
back in 1972. {This,was} Don

175
00:05:24,505 --> 00:05:26,125
0,450 450,645 645,935 1255,1515 1515,1620
chamberlain and voice. They work

176
00:05:26,125 --> 00:05:28,380
0,90 90,195 195,360 360,635 1855,2255
in this query language and

177
00:05:28,400 --> 00:05:30,325
0,335 335,670 900,1205 1205,1640 1640,1925
the idea, the structured English

178
00:05:30,325 --> 00:05:31,680
0,255 255,575
query language.|
|

179
00:05:31,690 --> 00:05:33,195
0,400 510,770 770,860 860,1265 1265,1505
But in the 1980 s
但在1980年S，当IBM推出商业关系数据库系统时，他们被起诉使用术语Sql，就像名字Sql一样，因为有其他系统或其他软件在使用它。所以他们就这样。

180
00:05:33,195 --> 00:05:34,380
0,335 355,645 645,975 975,1065 1065,1185
when when IBM put out

181
00:05:34,380 --> 00:05:36,045
0,290 430,810 810,1155 1155,1395 1395,1665
a commercial relational database system,

182
00:05:36,045 --> 00:05:37,905
0,195 195,420 420,915 915,1265 1585,1860
they got sued for the

183
00:05:37,905 --> 00:05:39,255
0,210 210,645 645,960 960,1185 1185,1350
term sql, like the name

184
00:05:39,255 --> 00:05:40,515
0,485 505,885 885,1095 1095,1170 1170,1260
sql because there was some

185
00:05:40,515 --> 00:05:41,955
0,165 165,485 625,900 900,1140 1140,1440
other system or some other

186
00:05:41,955 --> 00:05:43,200
0,180 180,285 285,545 895,1140 1140,1245
piece of software that was

187
00:05:43,200 --> 00:05:44,250
0,165 165,470 550,795 795,915 915,1050
using it. So then they

188
00:05:44,250 --> 00:05:45,100
0,260
just.|
|

189
00:05:45,230 --> 00:05:48,370
0,485 485,590 590,755 755,1060 2430,3140
Reverted it back to sql,
将其恢复为SQL，只有字母，结构化查询语言。

190
00:05:48,370 --> 00:05:50,170
0,225 225,375 375,650 1240,1515 1515,1800
just the letters, the structured

191
00:05:50,170 --> 00:05:52,280
0,195 195,500
query language.|
|

192
00:05:52,530 --> 00:05:54,605
0,245 245,410 410,730 1530,1820 1820,2075
There was another very famous
在20世纪70年代，伯克利还有另一个非常著名的项目，当时系统r刚刚起步，叫做入口，她听说过入口。

193
00:05:54,605 --> 00:05:55,895
0,365 415,675 675,810 810,1005 1005,1290
project at the same time

194
00:05:55,895 --> 00:05:57,335
0,285 285,845 925,1170 1170,1245 1245,1440
at Berkeley in the nineteen

195
00:05:57,335 --> 00:05:58,295
0,405 405,525 525,690 690,855 855,960
seventies when system r was

196
00:05:58,295 --> 00:06:01,085
0,180 180,515 1285,1560 1560,2015 2515,2790
getting started called ingress, who

197
00:06:01,085 --> 00:06:02,880
0,225 225,330 330,450 450,875
herears heard of ingress.|
|

198
00:06:03,720 --> 00:06:05,210
0,400 840,1115 1115,1325 1325,1430 1430,1490
Nobody who hears her in
没人会在邮报上听到她的声音。

199
00:06:05,210 --> 00:06:06,940
0,90 90,590
a postgres.|
|

200
00:06:07,080 --> 00:06:07,715
0,260 260,335 335,380 380,470 470,635
You want to know why
你想知道为什么Postgres被称为postgres，因为它是POST入口。当他建造入口时建造石破口的人，他在20世纪70年代末将其商业化，S，然后回到伯克利。20世纪80年代。他们建立了一个新的系统，这个系统应该是进入后的。这就是为什么它被称为Postgres。对不起，入口有另一种名为Quell的查询语言。

201
00:06:07,715 --> 00:06:09,020
0,345 345,465 465,615 615,1095 1095,1305
postgres is called postgres because

202
00:06:09,020 --> 00:06:11,045
0,255 255,560 700,1310 1600,1845 1845,2025
it's post ingress. The guy

203
00:06:11,045 --> 00:06:12,050
0,210 210,465 465,735 735,915 915,1005
that built stone breakak when

204
00:06:12,050 --> 00:06:14,285
0,105 105,285 285,800 1510,1800 1800,2235
he built ingress, he commercialized

205
00:06:14,285 --> 00:06:15,605
0,285 285,570 570,825 825,1110 1110,1320
it in the the late

206
00:06:15,605 --> 00:06:16,625
0,435 435,615 615,735 735,840 840,1020
1970 s and then went

207
00:06:16,625 --> 00:06:17,930
0,255 255,465 465,795 795,975 975,1305
back to Berkeley. Nineteen eighties.

208
00:06:17,930 --> 00:06:18,820
0,105 105,225 225,375 375,570 570,890
They built a new system

209
00:06:19,200 --> 00:06:19,865
0,260 260,365 365,455 455,530 530,665
that was supposed to be

210
00:06:19,865 --> 00:06:21,560
0,240 240,755 1165,1515 1515,1575 1575,1695
post ingress. That's why it's

211
00:06:21,560 --> 00:06:24,995
0,135 135,620 2020,2420 2440,3080 3160,3435
called postgres. They postgres sorry,

212
00:06:24,995 --> 00:06:26,495
0,485 595,870 870,1020 1020,1230 1230,1500
ingress had this other query

213
00:06:26,495 --> 00:06:28,600
0,305 685,1020 1020,1385
language called quell.|
|

214
00:06:28,600 --> 00:06:30,025
0,180 180,450 450,1050 1050,1305 1305,1425
And so sl the plan
所以sl单词的计划是ss sSQL来平息。

215
00:06:30,025 --> 00:06:30,625
0,75 75,150 150,300 300,465 465,600
of the words is that

216
00:06:30,625 --> 00:06:32,250
0,375 375,645 645,1065 1065,1290 1290,1625
ss the sql to quell.|
|

217
00:06:32,920 --> 00:06:34,015
0,225 225,405 405,585 585,900 900,1095
Because they the IBM guys
因为他们，IBM的人知道伯克利的人在做什么，他们会试图构建一种更好的查询语言。石破天惊会辩称，Quell更好，但当然没有人使用它。今天，IBM在20世纪70年代发布了几款。IBM从我S身上赚了很多钱，这是一个非关系型系统，不支持Sequel。然后他们意识到SQL会有用武之地，关系数据也会有用武之地。因此，他们发布了更早的原型，如System 38 SQL DS。但真正成功的是DB Two，它至今仍在使用。再说一次，IBM是计算机界的巨头，所以无论IBM说他们要做什么，这都成了事实上的标准。因此，当IBM推出支持SQL的关系数据库时，尽管存在像Well这样的竞争语言，但每个人都团结在SQL周围。

218
00:06:34,015 --> 00:06:34,825
0,180 180,315 315,450 450,540 540,810
knew what what the Berkeley

219
00:06:34,825 --> 00:06:35,605
0,120 120,255 255,465 465,675 675,780
people were doing and they

220
00:06:35,605 --> 00:06:36,250
0,90 90,195 195,300 300,450 450,645
would try to build a

221
00:06:36,250 --> 00:06:37,885
0,180 180,390 390,680 1180,1470 1470,1635
better query language. Stone break

222
00:06:37,885 --> 00:06:38,710
0,210 210,390 390,510 510,675 675,825
would argue that quell is

223
00:06:38,710 --> 00:06:40,930
0,290 1300,1545 1545,1620 1620,1850 1960,2220
better but of course no

224
00:06:40,930 --> 00:06:42,865
0,105 105,255 255,450 450,740 1390,1935
one uses that. Today IBM

225
00:06:42,865 --> 00:06:46,375
0,270 270,570 570,905 1075,1475 3265,3510
released a couple of in

226
00:06:46,375 --> 00:06:47,575
0,75 75,270 270,675 675,1095 1095,1200
the nineteen seventies. IBM was

227
00:06:47,575 --> 00:06:48,355
0,135 135,270 270,405 405,540 540,780
making a lot of money

228
00:06:48,355 --> 00:06:49,555
0,300 300,525 525,765 765,1020 1020,1200
off of I S, which

229
00:06:49,555 --> 00:06:51,000
0,105 105,365 475,765 765,1080 1080,1445
is a non relational system,

230
00:06:51,110 --> 00:06:52,615
0,350 350,515 515,970 1170,1415 1415,1505
didn't support sequel. And then

231
00:06:52,615 --> 00:06:54,310
0,210 210,525 525,875 1225,1590 1590,1695
they realized that sql was

232
00:06:54,310 --> 00:06:55,090
0,90 90,165 165,285 285,495 495,780
going to go somewhere, relational

233
00:06:55,090 --> 00:06:55,660
0,180 180,330 330,405 405,465 465,570
data were going to go

234
00:06:55,660 --> 00:06:56,815
0,260 490,720 720,870 870,1050 1050,1155
somewhere. So they released a

235
00:06:56,815 --> 00:06:58,290
0,120 120,330 330,975 975,1170 1170,1475
much early prototypes like system

236
00:06:58,370 --> 00:07:00,940
0,610 840,1250 1250,1660 2190,2435 2435,2570
38 sql DS. But the

237
00:07:00,940 --> 00:07:02,605
0,225 225,465 465,770 970,1365 1365,1665
big one that that really

238
00:07:02,605 --> 00:07:04,135
0,165 165,375 375,725 805,1245 1245,1530
took off was DB two,

239
00:07:04,135 --> 00:07:05,310
0,255 255,390 390,615 615,870 870,1175
which is still around today.

240
00:07:06,530 --> 00:07:08,155
0,380 380,1060 1080,1340 1340,1460 1460,1625
Again, IBM was a big

241
00:07:08,155 --> 00:07:09,235
0,405 405,495 495,615 615,885 885,1080
juggernaut in the computing world,

242
00:07:09,235 --> 00:07:11,065
0,210 210,360 360,810 810,1145 1585,1830
so whatever IBM said they

243
00:07:11,065 --> 00:07:11,740
0,90 90,165 165,255 255,420 420,675
were going to do, that

244
00:07:11,740 --> 00:07:12,565
0,180 180,330 330,555 555,705 705,825
sort of became the de

245
00:07:12,565 --> 00:07:14,275
0,360 360,665 1015,1245 1245,1320 1320,1710
facto standard. So when IBM

246
00:07:14,275 --> 00:07:15,070
0,180 180,360 360,495 495,570 570,795
came out with a relational

247
00:07:15,070 --> 00:07:16,960
0,300 300,570 570,810 810,1340 1570,1890
database that supported sql, even

248
00:07:16,960 --> 00:07:17,995
0,210 210,345 345,495 495,765 765,1035
though there were competing languages

249
00:07:17,995 --> 00:07:20,820
0,300 300,605 1165,1565 1975,2490 2490,2825
like well everyone coalesced around

250
00:07:21,800 --> 00:07:23,160
0,400 510,1030
around sql.|
|

251
00:07:24,400 --> 00:07:25,815
0,400 420,815 815,965 965,1130 1130,1415
So sl became a standard
因此，sl成为了南希标准中的标准。它是19、19、86年的美国标准组织，并于1987年成为国际标准。因此，尽管它现在是一种有5060年历史的语言，但它已经随着时间的推移而演变和扩展。因此，最新版本的SQL标准实际上是在今年3月于2023年发布的，他看到了她的列表，所有更新的历史，以及他们随着时间的推移添加的各种功能。

252
00:07:25,815 --> 00:07:27,045
0,375 375,600 600,900 900,1080 1080,1230
in a Nancy standard. It

253
00:07:27,045 --> 00:07:28,260
0,210 210,525 525,810 810,1065 1065,1215
was American standard body in

254
00:07:28,260 --> 00:07:29,925
0,230 340,645 645,855 855,1160 1420,1665
nineteen, nineteen, eighty six, and

255
00:07:29,925 --> 00:07:31,485
0,195 195,525 525,870 870,1215 1215,1560
it became an international standard

256
00:07:31,485 --> 00:07:35,100
0,365 415,2535 2535,2825 2935,3300 3300,3615
in 1987. {And,so} even though

257
00:07:35,100 --> 00:07:37,670
0,375 375,650 1390,2175 2175,2325 2325,2570
it's a 5060 year old

258
00:07:37,750 --> 00:07:39,720
0,395 395,790 1200,1460 1460,1670 1670,1970
language now, it has evolved

259
00:07:39,720 --> 00:07:41,895
0,330 330,705 705,1035 1035,1370 1810,2175
and expanded over time. So

260
00:07:41,895 --> 00:07:43,140
0,225 225,465 465,840 840,1110 1110,1245
the latest version of the

261
00:07:43,140 --> 00:07:44,130
0,240 240,480 480,720 720,855 855,990
sql standard actually came out

262
00:07:44,130 --> 00:07:45,165
0,120 120,330 330,555 555,765 765,1035
in march this year in

263
00:07:45,165 --> 00:07:47,745
0,815 1855,2115 2115,2265 2265,2430 2430,2580
2023 and he sees her

264
00:07:47,745 --> 00:07:48,645
0,180 180,360 360,495 495,705 705,900
list here, the history of

265
00:07:48,645 --> 00:07:49,995
0,150 150,375 375,695 895,1155 1155,1350
all the updates, the various

266
00:07:49,995 --> 00:07:51,320
0,285 285,600 600,765 765,1005 1005,1325
features they've added over time.|
|

267
00:07:51,840 --> 00:07:53,370
0,380 490,750 750,945 945,1365 1365,1530
And the main takeaway from
从这份清单中得到的主要结论是，随着程序的发展，应用程序也在发展，或者软件开发中的趋势也在发展。SQL已经、已经、一直在跟随它，采用了这些想法并采用了新的新功能。因此，在2023年，已经推出的两大功能是现在您可以直接在SQL中进行属性图查询。

268
00:07:53,370 --> 00:07:54,480
0,255 255,495 495,645 645,990 990,1110
this, from this listing here

269
00:07:54,480 --> 00:07:57,620
0,135 135,410 1300,1700 2350,2745 2745,3140
is that as as programs

270
00:07:57,700 --> 00:07:59,355
0,400 510,905 905,1220 1220,1445 1445,1655
evolved, applications evolved, or the

271
00:07:59,355 --> 00:08:01,245
0,300 300,695 745,1095 1095,1445 1555,1890
trends in in development software

272
00:08:01,245 --> 00:08:03,015
0,240 240,435 435,725 1135,1545 1545,1770
development has evolved. Sql has,

273
00:08:03,015 --> 00:08:04,935
0,365 985,1290 1290,1515 1515,1740 1740,1920
has, has moved along with

274
00:08:04,935 --> 00:08:06,360
0,270 270,570 570,825 825,1125 1125,1425
it and adopted the ideas

275
00:08:06,360 --> 00:08:07,910
0,270 270,590 640,1020 1020,1275 1275,1550
and adopted new new capabilities.

276
00:08:08,770 --> 00:08:10,905
0,365 365,730 810,1115 1115,1880 1880,2135
So in in 2023 the

277
00:08:10,905 --> 00:08:11,790
0,225 225,420 420,630 630,795 795,885
big two features that have

278
00:08:11,790 --> 00:08:13,200
0,105 105,315 315,680 970,1260 1260,1410
come out is now you

279
00:08:13,200 --> 00:08:14,840
0,135 135,410 520,870 870,1140 1140,1640
can do property graph queries

280
00:08:15,160 --> 00:08:16,580
0,350 350,590 590,1060
directly in sql.|
|

281
00:08:16,590 --> 00:08:17,960
0,260 260,520 630,890 890,1070 1070,1370
So somebody brought up neo
所以上节课有人提到了尼奥4j。那就是，那是一个特殊用途的图形，数据模型数据库系统。

282
00:08:17,960 --> 00:08:19,595
0,135 135,315 315,525 525,830 1180,1635
four j last class. That's,

283
00:08:19,595 --> 00:08:22,000
0,425 565,960 960,1290 1290,1625 2005,2405
that's a special purpose graph,

284
00:08:22,200 --> 00:08:24,160
0,320 320,605 605,935 935,1300
data model database system.|
|

285
00:08:24,160 --> 00:08:24,805
0,105 105,240 240,375 375,525 525,645
But now you don't need
但是现在您不再需要它了，因为您现在可以直接在SQL中运行图形查询，因为SQL标准支持它。

286
00:08:24,805 --> 00:08:25,705
0,225 225,465 465,645 645,795 795,900
that anymore because now you

287
00:08:25,705 --> 00:08:27,310
0,120 120,395 685,990 990,1350 1350,1605
can run graph queries directly

288
00:08:27,310 --> 00:08:28,675
0,270 270,735 735,990 990,1125 1125,1365
in sql because the sql

289
00:08:28,675 --> 00:08:30,000
0,255 255,525 525,815
standard supports it.|
|

290
00:08:30,010 --> 00:08:31,365
0,305 305,515 515,785 785,1070 1070,1355
They also add support for
它们还添加了对多维数组的支持。我之前说过，很多机器学习的东西都是基于数组或矩阵的。现在您可以直接在SQL上操作这些东西。现在，仅仅因为标准有定义，并不意味着每个系统都会支持它，对吗？我认为没有任何系统真正支持多维数组的东西。Oracle支持属性图之类的东西。波斯格雷斯最终将到达那里的管道，最终，到b的管道已经有了它的原型。

291
00:08:31,365 --> 00:08:33,390
0,270 270,720 720,1205 1705,1935 1935,2025
multi dimensional arrays. So I

292
00:08:33,390 --> 00:08:34,305
0,135 135,405 405,705 705,840 840,915
said before that a lot

293
00:08:34,305 --> 00:08:35,510
0,165 165,345 345,525 525,825 825,1205
of machine learning stuff is

294
00:08:35,620 --> 00:08:36,980
0,305 305,500 500,785 785,875 875,1360
based on arrays or matrices.

295
00:08:37,270 --> 00:08:38,445
0,245 245,350 350,515 515,820 840,1175
Now you can operate directly

296
00:08:38,445 --> 00:08:40,260
0,225 225,635 655,930 930,1205 1555,1815
on sql these things. Now

297
00:08:40,260 --> 00:08:41,595
0,260 340,630 630,810 810,1050 1050,1335
just because the standard has

298
00:08:41,595 --> 00:08:42,555
0,360 360,510 510,705 705,795 795,960
defines it doesn't mean every

299
00:08:42,555 --> 00:08:43,350
0,195 195,345 345,450 450,600 600,795
system is going to support

300
00:08:43,350 --> 00:08:45,975
0,180 180,470 2080,2340 2340,2520 2520,2625
it, right? I don't think

301
00:08:45,975 --> 00:08:47,420
0,195 195,480 480,810 810,1110 1110,1445
any system really supports the

302
00:08:47,920 --> 00:08:50,085
0,400 630,1115 1115,1280 1280,1570 1650,2165
multi dimensional array stuff. Oracle

303
00:08:50,085 --> 00:08:51,015
0,180 180,300 300,465 465,690 690,930
supports the property graph stuff.

304
00:08:51,015 --> 00:08:51,975
0,375 375,495 495,660 660,825 825,960
Postgres will eventually get there

305
00:08:51,975 --> 00:08:53,130
0,180 180,285 285,405 405,1050 1050,1155
duct to b eventuallyuct to

306
00:08:53,130 --> 00:08:53,895
0,90 90,195 195,300 300,660 660,765
b has a prototype for

307
00:08:53,895 --> 00:08:54,400
0,245
it.|
|

308
00:08:54,400 --> 00:08:55,705
0,320 610,885 885,1080 1080,1170 1170,1305
But because it's in the
但因为它在标准中，并不是每个人都能真正支持它。

309
00:08:55,705 --> 00:08:57,055
0,275 565,900 900,1170 1170,1245 1245,1350
standard, not everyone's going to

310
00:08:57,055 --> 00:08:57,790
0,210 210,375 375,450 450,585 585,735
actually be able to support

311
00:08:57,790 --> 00:08:58,540
0,260
it.|
|

312
00:08:59,000 --> 00:08:59,695
0,245 245,365 365,500 500,605 605,695
So I would say, in
因此，在我看来，要说您的数据库支持SQL是在SQL 92标准中定义的，您至少需要对SQL的支持。这就像INSERT、UPDATE、DELETE、创建表。这是，这是基本的功能。

313
00:08:59,695 --> 00:09:02,365
0,180 180,515 955,1355 1375,1775 2365,2670
my opinion, the minimum support

314
00:09:02,365 --> 00:09:03,295
0,165 165,315 315,495 495,795 795,930
you need for sql to

315
00:09:03,295 --> 00:09:04,315
0,165 165,300 300,405 405,665 715,1020
say that your database support

316
00:09:04,315 --> 00:09:06,025
0,485 625,990 990,1305 1305,1545 1545,1710
sql is defined in the

317
00:09:06,025 --> 00:09:08,310
0,285 285,690 690,995 1675,2040 2040,2285
sql 92 standard. That's like

318
00:09:08,540 --> 00:09:10,140
0,485 485,695 695,1100 1100,1295 1295,1600
insert, update deletes, create tables.

319
00:09:10,490 --> 00:09:12,360
0,335 335,545 545,710 710,1010 1010,1870
That's, that's the basic functionality.|
|

320
00:09:13,070 --> 00:09:14,110
0,260 260,395 395,545 545,725 725,1040
So again, even though sql
再说一次，尽管SQL已经有50多年的历史了，但它并不是一种过时的语言，而且一直在更新。

321
00:09:14,110 --> 00:09:15,145
0,180 180,405 405,600 600,765 765,1035
is over fifty years old,

322
00:09:15,145 --> 00:09:16,110
0,345 345,480 480,585 585,690 690,965
it's not a dead language

323
00:09:16,190 --> 00:09:17,320
0,260 260,500 500,755 755,980 980,1130
and there's updates all the

324
00:09:17,320 --> 00:09:18,220
0,260
time.|
|

325
00:09:18,220 --> 00:09:19,330
0,150 150,225 225,470 520,870 870,1110
And of course, every ten
当然，每隔十年，每五年，就会有一些新技术问世，人们说SQL已经死了，它即将被取代。10年前，它还是nos SQL。现在最热门的是聊天GBT或矢量数据库。所以你在Twitter或社交媒体上看到很多这样的事情，他们声称SQL将会消亡，因为聊天tbt将取代它，或者自然语言将取代它，对吗？

326
00:09:19,330 --> 00:09:20,965
0,270 270,570 570,810 810,1130 1270,1635
years, every five years, some

327
00:09:20,965 --> 00:09:22,330
0,240 240,515 595,870 870,1110 1110,1365
new technology comes out and

328
00:09:22,330 --> 00:09:23,760
0,290 460,765 765,960 960,1200 1200,1430
people say that sql is

329
00:09:23,840 --> 00:09:25,480
0,400 1050,1280 1280,1430 1430,1550 1550,1640
dead and it's about to

330
00:09:25,480 --> 00:09:27,685
0,120 120,410 1540,1800 1800,1980 1980,2205
be replaced. Ten years ago

331
00:09:27,685 --> 00:09:28,990
0,135 135,225 225,405 405,815 1045,1305
it was nos sql. And

332
00:09:28,990 --> 00:09:30,060
0,105 105,240 240,420 420,690 690,1070
the hot thing now is

333
00:09:30,560 --> 00:09:32,640
0,305 305,910 930,1250 1250,1490 1490,2080
chat gbt or vector databases.

334
00:09:32,930 --> 00:09:33,595
0,260 260,395 395,500 500,575 575,665
So you see a lot

335
00:09:33,595 --> 00:09:34,300
0,90 90,240 240,405 405,525 525,705
of these kind of things

336
00:09:34,300 --> 00:09:36,595
0,320 340,705 705,1070 1870,2130 2130,2295
on Twitter or on social

337
00:09:36,595 --> 00:09:37,780
0,255 255,450 450,585 585,855 855,1185
media where they claim sql

338
00:09:37,780 --> 00:09:38,850
0,75 75,165 165,270 270,530 670,1070
is going to die because

339
00:09:39,320 --> 00:09:40,240
0,290 290,635 635,725 725,800 800,920
chat tbt is going to

340
00:09:40,240 --> 00:09:41,110
0,210 210,375 375,555 555,735 735,870
replace it or natural language

341
00:09:41,110 --> 00:09:41,695
0,120 120,180 180,270 270,420 420,585
is going to replace it,

342
00:09:41,695 --> 00:09:42,580
0,275
right?|
|

343
00:09:42,710 --> 00:09:44,575
0,290 290,580 1290,1610 1610,1760 1760,1865
This is all a bunch
这都是一堆炒作。这很有趣，但它不会出现在任何地方。SQL，在你出生之前，SQL就在这里了。当你死的时候，SQL在这里。我已经就此发表了基本的公开声明。他们去年在杂志上引用了我的一篇文章。我基本上是说，如果你想在计算机科学中做任何事情，你需要A N SQL。

344
00:09:44,575 --> 00:09:46,885
0,120 120,485 1105,1595 1615,2015 2065,2310
of hype. It's interesting, but

345
00:09:46,885 --> 00:09:47,530
0,150 150,285 285,405 405,495 495,645
it's not going to place.

346
00:09:47,530 --> 00:09:49,120
0,440 760,1155 1155,1260 1260,1395 1395,1590
Sql, sql was here before

347
00:09:49,120 --> 00:09:50,545
0,150 150,255 255,530 880,1290 1290,1425
you were born. Sql be

348
00:09:50,545 --> 00:09:54,390
0,180 180,330 330,420 420,665 3445,3845
here when you die. And

349
00:09:54,740 --> 00:09:56,755
0,470 470,695 695,980 980,1330 1620,2015
I've made public statements basically

350
00:09:56,755 --> 00:09:57,810
0,285 285,495 495,720 720,795 795,1055
about this. There's an article

351
00:09:59,060 --> 00:10:00,685
0,260 260,470 470,635 635,880 1290,1625
they quoted me in last

352
00:10:00,685 --> 00:10:03,120
0,335 1405,1665 1665,2055 2055,2190 2190,2435
year, some magazines or something.

353
00:10:03,170 --> 00:10:04,150
0,260 260,455 455,695 695,860 860,980
I basically said you need

354
00:10:04,150 --> 00:10:04,960
0,105 105,240 240,570 570,705 705,810
A N sql if you

355
00:10:04,960 --> 00:10:05,785
0,90 90,150 150,300 300,540 540,825
want to do anything in

356
00:10:05,785 --> 00:10:07,080
0,300 300,540 540,845
in computer science.|
|

357
00:10:07,520 --> 00:10:08,780
0,245 245,490
All right.|
好的。|

358
00:10:09,440 --> 00:10:11,120
0,380 380,760
So the.|
所以。|

359
00:10:11,120 --> 00:10:12,140
0,105 105,225 225,495 495,780 780,1020
In a relational language like
在像SQL这样的关系语言中，它将由三个部分组成。将会有DML，数据操作语言。这就是我们的SELECT、INSERT、UPDATE、DELETE操作。在我们的数据库中与之交互的查询将是DDL、数据定义、高效语言，即CREATE TABLE语句、用于创建对象实体的CREATE VIEWS。

360
00:10:12,140 --> 00:10:13,090
0,345 345,540 540,615 615,705 705,950
sql, it's going to have

361
00:10:13,740 --> 00:10:15,260
0,290 290,580 1050,1400 1400,1460 1460,1520
three parts. There's going to

362
00:10:15,260 --> 00:10:16,520
0,150 150,330 330,800 850,1110 1110,1260
be the dml, the data

363
00:10:16,520 --> 00:10:18,425
0,675 675,1010 1270,1605 1605,1725 1725,1905
manipulation language. That's how we're

364
00:10:18,425 --> 00:10:20,495
0,150 150,485 1435,1710 1710,1845 1845,2070
going to, that's our select,

365
00:10:20,495 --> 00:10:21,710
0,360 360,570 570,750 750,1005 1005,1215
insert, update, delete. Queries that

366
00:10:21,710 --> 00:10:22,900
0,240 240,525 525,780 780,915 915,1190
interact with in our database

367
00:10:23,430 --> 00:10:24,590
0,245 245,380 380,530 530,980 980,1160
would be the ddl, the

368
00:10:24,590 --> 00:10:25,670
0,165 165,330 330,495 495,765 765,1080
data definition, efficient language, that's

369
00:10:25,670 --> 00:10:26,780
0,135 135,315 315,570 570,885 885,1110
the create table statements, the

370
00:10:26,780 --> 00:10:28,205
0,180 180,500 820,1110 1110,1290 1290,1425
create views to create the

371
00:10:28,205 --> 00:10:30,020
0,405 405,540 540,785 805,1205
entities of the objects.|
|

372
00:10:30,360 --> 00:10:32,225
0,260 260,395 395,670 1440,1700 1700,1865
In our database and then
在我们的数据库中，然后他们将是，我们不会真的讨论这一点，但将有DCL，数据控制语言，用于类似安全和访问控制。有些系统允许您这样，您知道，您可以指定允许哪些用户查看哪些行、哪些列或哪些表等。因此，SQL标准为这些内容指定了。

373
00:10:32,225 --> 00:10:33,110
0,195 195,420 420,705 705,780 780,885
they'll be, we're not really

374
00:10:33,110 --> 00:10:33,815
0,75 75,135 135,300 300,540 540,705
going to cover this, but

375
00:10:33,815 --> 00:10:34,745
0,120 120,195 195,330 330,750 750,930
there'll be the dcl, the

376
00:10:34,745 --> 00:10:36,320
0,210 210,450 450,725 1045,1455 1455,1575
data control language, that's for

377
00:10:36,320 --> 00:10:37,930
0,260 280,630 630,945 945,1260 1260,1610
like security and access control.

378
00:10:38,340 --> 00:10:39,530
0,305 305,575 575,845 845,1010 1010,1190
Some systems allow you have

379
00:10:39,530 --> 00:10:40,745
0,320 550,765 765,870 870,1005 1005,1215
like, you know, you can

380
00:10:40,745 --> 00:10:41,990
0,420 420,600 600,870 870,1110 1110,1245
specify what users are allowed

381
00:10:41,990 --> 00:10:43,010
0,120 120,240 240,420 420,930 930,1020
to see what rows or

382
00:10:43,010 --> 00:10:43,925
0,120 120,465 465,585 585,705 705,915
what columns or what tables

383
00:10:43,925 --> 00:10:45,110
0,210 210,360 360,635 835,1080 1080,1185
and so forth. So the

384
00:10:45,110 --> 00:10:46,610
0,270 270,560 580,1050 1050,1290 1290,1500
sql standard specifies for, for

385
00:10:46,610 --> 00:10:47,700
0,150 150,440
these things.|
|

386
00:10:48,250 --> 00:10:49,260
0,320 320,530 530,695 695,875 875,1010
Another big thing we'll see
我们将在本学期晚些时候看到的另一个重要内容是交易的定义。如何定义一组您希望以隔离方式原子发生的SQL语句。同样，SQL标准支持这一点。再说一次，我们会在没有这学期的时候看到这些零星的东西。但在今天的课程中，我们真正要关注的是第一个，DML。

387
00:10:49,260 --> 00:10:50,690
0,150 150,255 255,345 345,650 1030,1430
later in the semester is

388
00:10:50,950 --> 00:10:53,460
0,230 230,455 455,740 740,1030 2250,2510
the definition of transactions. How

389
00:10:53,460 --> 00:10:54,255
0,90 90,270 270,525 525,675 675,795
do you define a bunch

390
00:10:54,255 --> 00:10:55,335
0,135 135,390 390,665 745,990 990,1080
of sql statements you want

391
00:10:55,335 --> 00:10:57,375
0,75 75,225 225,965 1705,1950 1950,2040
to happen atomically in an

392
00:10:57,375 --> 00:10:59,280
0,345 345,665 835,1235 1255,1650 1650,1905
isolated way. And again, the

393
00:10:59,280 --> 00:11:00,960
0,240 240,435 435,690 690,1010 1420,1680
sql standard supports this. So

394
00:11:00,960 --> 00:11:01,950
0,195 195,510 510,705 705,870 870,990
again, we'll see bits and

395
00:11:01,950 --> 00:11:02,775
0,165 165,315 315,480 480,690 690,825
pieces of this as we

396
00:11:02,775 --> 00:11:03,930
0,90 90,255 255,420 420,725 805,1155
go without this semester. But

397
00:11:03,930 --> 00:11:05,580
0,240 240,645 645,920 1240,1530 1530,1650
for today's lecture we're really

398
00:11:05,580 --> 00:11:06,465
0,120 120,210 210,390 390,660 660,885
going to focus on the

399
00:11:06,465 --> 00:11:08,080
0,165 165,420 420,660 660,1085
first one, the dml.|
|

400
00:11:08,350 --> 00:11:09,770
0,245 245,425 425,755 755,1085 1085,1420
And in reminder from from
从我们上节课讲到的地方提醒一下，SQL将基于袋子，这意味着可能会有重复的EM，而关系代数是基于集合的，我们看到了一些情况，我们必须在SQL语句中添加额外的东西来处理这个问题。

401
00:11:09,970 --> 00:11:11,925
0,290 290,440 440,700 1050,1450 1710,1955
picking up where we we

402
00:11:11,925 --> 00:11:13,830
0,120 120,255 255,420 420,725 1525,1905
talked about last class, sql

403
00:11:13,830 --> 00:11:14,160
0,75 75,135 135,165 165,210 210,330
is going to be based

404
00:11:14,160 --> 00:11:16,065
0,180 180,470 580,980 1450,1740 1740,1905
on bags, meaning there could

405
00:11:16,065 --> 00:11:18,315
0,135 135,695 1045,1445 1705,2025 2025,2250
be duplicates, EM, whereas relation

406
00:11:18,315 --> 00:11:19,610
0,405 405,570 570,765 765,975 975,1295
algebra was based on sets

407
00:11:20,080 --> 00:11:21,150
0,320 320,545 545,710 710,845 845,1070
and we see some cases

408
00:11:21,150 --> 00:11:22,440
0,350 580,870 870,975 975,1110 1110,1290
where we'll have to add

409
00:11:22,440 --> 00:11:23,415
0,270 270,495 495,615 615,720 720,975
extra stuff in our sql

410
00:11:23,415 --> 00:11:26,370
0,270 270,665 2485,2730 2730,2835 2835,2955
statements to, to deal with

411
00:11:26,370 --> 00:11:27,100
0,260
that.|
|

412
00:11:28,480 --> 00:11:29,745
0,260 260,520 540,815 815,1055 1055,1265
So today again, is supposed
因此，今天又应该是一个关于现代SQL的速成课程。我假设每个人，无论您是否知道，您已经从SQL92标准的SELECT Insertlet中了解了足够的知识，我想谈谈。

413
00:11:29,745 --> 00:11:30,450
0,75 75,120 120,210 210,420 420,705
to be a crash course

414
00:11:30,450 --> 00:11:31,905
0,345 345,705 705,1035 1035,1200 1200,1455
on modern sql. I'm assuming

415
00:11:31,905 --> 00:11:33,660
0,395 1075,1335 1335,1440 1440,1590 1590,1755
everyone, whether or not you

416
00:11:33,660 --> 00:11:34,680
0,120 120,195 195,270 270,530 730,1020
know it or not, you

417
00:11:34,680 --> 00:11:35,730
0,210 210,465 465,675 675,810 810,1050
know enough from the sql

418
00:11:35,730 --> 00:11:38,820
0,435 435,740 1360,1650 1650,2480 2830,3090
92 standard select insertlet and

419
00:11:38,820 --> 00:11:39,590
0,105 105,180 180,270 270,450 450,770
I want to talk about

420
00:11:39,640 --> 00:11:40,900
0,400
the.|
|

421
00:11:40,900 --> 00:11:41,680
0,165 165,240 240,330 330,510 510,780
I want to talk about
我想谈谈你可以用它们做的更复杂的事情，但是。

422
00:11:41,680 --> 00:11:43,840
0,350 430,830 1240,1830 1830,2010 2010,2160
the more sophisticated things you

423
00:11:43,840 --> 00:11:45,360
0,120 120,225 225,330 330,590 1120,1520
can do with them, but.|
|

424
00:11:45,850 --> 00:11:47,595
0,260 260,395 395,1250 1250,1535 1535,1745
But the overarching theme also
但最重要的主题也将是我们将开放航站楼。我们将在不同的数据库系统中尝试一系列这样的查询。我们将看到，即使有一个SQL标准，也有一个国际公认的文档说明了SQL应该是什么样子的。

425
00:11:47,595 --> 00:11:48,510
0,120 120,300 300,480 480,705 705,915
will be is that we

426
00:11:48,510 --> 00:11:49,520
0,165 165,300 300,375 375,495 495,1010
will open up the terminal.

427
00:11:49,630 --> 00:11:50,445
0,350 350,470 470,575 575,695 695,815
We'll try a bunch of

428
00:11:50,445 --> 00:11:51,465
0,135 135,480 480,600 600,750 750,1020
these queries in different database

429
00:11:51,465 --> 00:11:53,055
0,365 805,1095 1095,1230 1230,1380 1380,1590
systems. And we will see

430
00:11:53,055 --> 00:11:54,165
0,210 210,465 465,735 735,930 930,1110
that even though there is

431
00:11:54,165 --> 00:11:55,725
0,210 210,540 540,845 1075,1335 1335,1560
a sql standard, there is

432
00:11:55,725 --> 00:11:58,080
0,365 775,1200 1200,1475 1915,2205 2205,2355
an internationally recognized document that

433
00:11:58,080 --> 00:11:59,085
0,165 165,405 405,555 555,870 870,1005
says here's what sql should

434
00:11:59,085 --> 00:12:00,100
0,135 135,425
look like.|
|

435
00:12:00,440 --> 00:12:02,005
0,350 350,755 755,1010 1010,1340 1340,1565
Nobody implements it exactly that
没有人会完全以这种方式实现它。

436
00:12:02,005 --> 00:12:03,000
0,275
way.|
|

437
00:12:03,000 --> 00:12:04,050
0,350 520,870 870,930 930,975 975,1050
Right. Everyone's going to have
正确的。每个人都会有这些奇怪的细微差别和怪癖，他们有不同的功能或不同的命名或语法来做某些事情，在某些情况下，不同操作的不同语义。

438
00:12:04,050 --> 00:12:05,430
0,150 150,375 375,855 855,1005 1005,1380
these weird nuances and quirks

439
00:12:05,430 --> 00:12:06,360
0,135 135,225 225,390 390,630 630,930
where they have different features

440
00:12:06,360 --> 00:12:08,625
0,240 240,500 1090,1740 1740,1860 1860,2265
or different nomenclature or syntax

441
00:12:08,625 --> 00:12:10,965
0,150 150,285 285,495 495,815 2095,2340
to do certain things, in

442
00:12:10,965 --> 00:12:12,830
0,120 120,315 315,570 570,1295 1465,1865
some cases, different semantics of

443
00:12:13,180 --> 00:12:14,800
0,380 380,760
different operations.|
|

444
00:12:14,800 --> 00:12:16,060
0,350 490,795 795,960 960,1170 1170,1260
Where even though there's a
即使有一个SQL标准，但每个系统都会有所不同。

445
00:12:16,060 --> 00:12:16,855
0,225 225,450 450,690 690,750 750,795
sql standard, it's going to

446
00:12:16,855 --> 00:12:17,770
0,90 90,315 315,540 540,705 705,915
be different from one system

447
00:12:17,770 --> 00:12:18,880
0,150 150,225 225,470
to the next.|
|

448
00:12:19,650 --> 00:12:20,615
0,260 260,520 540,785 785,860 860,965
Who did take a guess
是谁猜到了是谁？我认为谁是最糟糕的SQL实现的最大罪魁祸首？更糟糕的不是正确的词，而是最偏离标准的那个。

449
00:12:20,615 --> 00:12:21,785
0,275 295,695 715,945 945,1050 1050,1170
who? Who do I think

450
00:12:21,785 --> 00:12:22,805
0,90 90,195 195,375 375,870 870,1020
is the biggest offender for

451
00:12:22,805 --> 00:12:24,350
0,90 90,335 445,900 900,1290 1290,1545
the worst sql implementationation worse

452
00:12:24,350 --> 00:12:25,010
0,150 150,270 270,375 375,495 495,660
is not the right word,

453
00:12:25,010 --> 00:12:26,405
0,150 150,410 790,1050 1050,1200 1200,1395
but like the one that

454
00:12:26,405 --> 00:12:27,410
0,375 375,510 510,630 630,825 825,1005
deviates from the standard the

455
00:12:27,410 --> 00:12:28,360
0,260
most.|
|

456
00:12:28,740 --> 00:12:29,500
0,245 245,335 335,425 425,515 515,760
Let me take a guess.|
让我猜猜。|

457
00:12:31,850 --> 00:12:32,920
0,275 275,500 500,755 755,890 890,1070
The top four out of
后面的前四名是肯定的。是的，我的天，他答对了。是的，米亚格将会是所有这些中他们会做各种怪事的地方。最近，他们现在有了一个标志，可以让它更严格，并试图更接近SQL标准，但在很长一段时间里，他们做了一系列奇怪的事情。我的问题是，我第一次开始使用数据库关系数据库是在20世纪90年代我上高中的时候，我们使用的是我的SQL3，所以我有所有的坏习惯，就像我从我的SQL中学到的一样，我想，哦，是的，这就是续集。然后你意识到，当你开始玩这样的其他系统时，他们正在做一些奇怪的事情。

458
00:12:32,920 --> 00:12:33,690
0,210 210,300 300,360 360,480 480,770
yes in the back. Yes

459
00:12:34,550 --> 00:12:35,515
0,395 395,635 635,740 740,845 845,965
my he got it right.

460
00:12:35,515 --> 00:12:36,895
0,255 255,795 795,960 960,1110 1110,1380
Yes, myag is gonna be

461
00:12:36,895 --> 00:12:39,160
0,395 1015,1245 1245,1395 1395,1715 1945,2265
the of all these where

462
00:12:39,160 --> 00:12:39,865
0,210 210,270 270,360 360,540 540,705
they're gonna do all sorts

463
00:12:39,865 --> 00:12:42,790
0,105 105,365 1555,1875 1875,2195 2635,2925
of weird. More recently they

464
00:12:42,790 --> 00:12:43,720
0,180 180,330 330,495 495,750 750,930
now have a flag where

465
00:12:43,720 --> 00:12:44,290
0,75 75,195 195,330 330,450 450,570
you can make it be

466
00:12:44,290 --> 00:12:45,520
0,165 165,470 640,960 960,1140 1140,1230
more strict and try to

467
00:12:45,520 --> 00:12:47,440
0,135 135,440 970,1320 1320,1665 1665,1920
be more closer to the

468
00:12:47,440 --> 00:12:48,595
0,225 225,500 700,960 960,1065 1065,1155
sql standard but for the

469
00:12:48,595 --> 00:12:49,405
0,210 210,480 480,645 645,735 735,810
longest time they do a

470
00:12:49,405 --> 00:12:50,410
0,90 90,195 195,345 345,635 745,1005
bunch of weird things. And

471
00:12:50,410 --> 00:12:51,910
0,195 195,465 465,690 690,980 1150,1500
my problem is that I

472
00:12:51,910 --> 00:12:53,410
0,210 210,345 345,540 540,1190 1210,1500
first started using databases relation

473
00:12:53,410 --> 00:12:54,850
0,405 405,585 585,860 1090,1335 1335,1440
databases in like when I

474
00:12:54,850 --> 00:12:55,495
0,90 90,180 180,360 360,540 540,645
was in high school in

475
00:12:55,495 --> 00:12:56,365
0,90 90,480 480,705 705,795 795,870
the nineties and we were

476
00:12:56,365 --> 00:12:57,925
0,150 150,345 345,630 630,935 1315,1560
using my sql three so

477
00:12:57,925 --> 00:12:58,735
0,105 105,225 225,390 390,585 585,810
I have all these bad

478
00:12:58,735 --> 00:13:00,175
0,335 505,810 810,1050 1050,1275 1275,1440
habits that like I picked

479
00:13:00,175 --> 00:13:00,940
0,165 165,300 300,450 450,705 705,765
up from my sql and

480
00:13:00,940 --> 00:13:01,525
0,120 120,195 195,330 330,480 480,585
I'm like oh yeah, this

481
00:13:01,525 --> 00:13:02,530
0,90 90,225 225,480 480,725 745,1005
is what sequel is. Then

482
00:13:02,530 --> 00:13:03,805
0,180 180,405 405,555 555,800 970,1275
you realize when you start

483
00:13:03,805 --> 00:13:05,065
0,180 180,345 345,570 570,905 985,1260
playing other systems like this

484
00:13:05,065 --> 00:13:06,190
0,275 295,630 630,855 855,975 975,1125
is crazy, they're doing some

485
00:13:06,190 --> 00:13:07,760
0,180 180,500
weird stuff.|
|

486
00:13:07,760 --> 00:13:09,125
0,255 255,570 570,720 720,1040 1090,1365
But it's gotten better. My
但一切都变好了。我的SQL8确实改进了很多。好的，我们来看一下所有这些聚合。GROUP是字符串日期和时间操作。这将是我们看到所有问题的地方，然后是一系列其他与SQL查询交互的不同方式。我们将要讨论的另一个主题是，编写时间的SQL语句的目标是尝试完成所有的计算。

487
00:13:09,125 --> 00:13:10,700
0,240 240,485 505,840 840,1175 1195,1575
sql eight has has certainly

488
00:13:10,700 --> 00:13:12,200
0,380 400,660 660,920 1090,1350 1350,1500
improved a lot. All right,

489
00:13:12,200 --> 00:13:13,415
0,120 120,225 225,440 850,1095 1095,1215
so we'll go through all

490
00:13:13,415 --> 00:13:15,010
0,105 105,300 300,840 840,1065 1065,1595
of these aggregations. Group is

491
00:13:15,420 --> 00:13:16,600
0,365 365,635 635,800 800,920 920,1180
the string date and time

492
00:13:16,620 --> 00:13:17,510
0,335 335,605 605,680 680,725 725,890
operations. That's going to be

493
00:13:17,510 --> 00:13:18,125
0,210 210,345 345,450 450,525 525,615
the one where we see

494
00:13:18,125 --> 00:13:19,325
0,105 105,225 225,485 775,1050 1050,1200
all the problems and then

495
00:13:19,325 --> 00:13:19,985
0,120 120,225 225,330 330,465 465,660
a bunch of other different

496
00:13:19,985 --> 00:13:21,830
0,270 270,635 865,1265 1435,1710 1710,1845
ways to to interact with

497
00:13:21,830 --> 00:13:24,155
0,255 255,650 910,1310 1630,2025 2025,2325
sql queries. And another theme

498
00:13:24,155 --> 00:13:24,965
0,195 195,345 345,495 495,630 630,810
about what we'll talk about

499
00:13:24,965 --> 00:13:26,735
0,275 685,975 975,1265 1315,1575 1575,1770
is the goal of writing

500
00:13:26,735 --> 00:13:28,160
0,300 300,575 685,1020 1020,1215 1215,1425
sql statement of time is

501
00:13:28,160 --> 00:13:29,390
0,350 550,795 795,885 885,1005 1005,1230
to try to do all

502
00:13:29,390 --> 00:13:30,860
0,225 225,830
the computation.|
|

503
00:13:30,860 --> 00:13:32,105
0,330 330,585 585,750 750,945 945,1245
On the the database server
在数据库服务器本身上，在一种主要的SQL查询中。这意味着我们不必执行SELECT操作，将一些数据返回到一个python程序或其他程序中，然后对其进行操作，然后将其推回并执行更多查询。我们希望在服务器端、数据库系统内部尽我们所能，因为我们希望能够将查询推送到数据，而不是将数据拉到查询。

504
00:13:32,105 --> 00:13:33,875
0,360 360,735 735,1115 1435,1665 1665,1770
itself, within one sort of

505
00:13:33,875 --> 00:13:35,825
0,195 195,720 720,945 945,1235 1645,1950
one overarching sql query. Meaning

506
00:13:35,825 --> 00:13:36,485
0,195 195,435 435,510 510,570 570,660
we don't want to have

507
00:13:36,485 --> 00:13:37,565
0,210 210,375 375,555 555,855 855,1080
to do a select, get

508
00:13:37,565 --> 00:13:38,930
0,150 150,345 345,665 685,1085 1105,1365
some data back into a

509
00:13:38,930 --> 00:13:40,070
0,300 300,480 480,630 630,840 840,1140
python program or something then

510
00:13:40,070 --> 00:13:41,405
0,345 345,740 880,1140 1140,1245 1245,1335
then then operate on it

511
00:13:41,405 --> 00:13:41,975
0,90 90,195 195,315 315,435 435,570
and then push it back

512
00:13:41,975 --> 00:13:42,995
0,120 120,225 225,345 345,725 775,1020
and do more queries. We

513
00:13:42,995 --> 00:13:43,520
0,90 90,195 195,270 270,315 315,525
want to try to do

514
00:13:43,520 --> 00:13:45,250
0,225 225,345 345,620 910,1310 1330,1730
everything we can on the

515
00:13:45,720 --> 00:13:46,835
0,320 320,500 500,635 635,845 845,1115
on, on the server side,

516
00:13:46,835 --> 00:13:48,440
0,180 180,270 270,480 480,845 1345,1605
inside the database system because

517
00:13:48,440 --> 00:13:48,860
0,120 120,210 210,285 285,345 345,420
we want to be able

518
00:13:48,860 --> 00:13:49,925
0,150 150,375 375,585 585,855 855,1065
to push the query to

519
00:13:49,925 --> 00:13:51,155
0,105 105,345 345,660 660,930 930,1230
the data, not pull the,

520
00:13:51,155 --> 00:13:52,325
0,365 445,705 705,900 900,1080 1080,1170
the, the data to the

521
00:13:52,325 --> 00:13:53,180
0,275
query.|
|

522
00:13:53,890 --> 00:13:55,155
0,400 570,845 845,995 995,1130 1130,1265
Again, this make more sense
再说一次，随着我们的前进，这更有意义。

523
00:13:55,155 --> 00:13:56,400
0,150 150,255 255,375 375,665
as we go along.|
|

524
00:13:57,170 --> 00:13:58,345
0,245 245,440 440,740 740,980 980,1175
All right. So for today
好的。因此，今天我们将使用一个简单的示例数据库，如下所示。EM有三张桌子，学生参加了课程，对吗？它基本上是在模仿一所大学。有学生，他们参加课程，他们被录取，他们在那里的各种课程中获得分数。

525
00:13:58,345 --> 00:13:59,770
0,195 195,345 345,555 555,845 1135,1425
we're using a simple example

526
00:13:59,770 --> 00:14:01,570
0,225 225,435 435,710 1060,1460 1510,1800
database like this. EM has

527
00:14:01,570 --> 00:14:03,400
0,195 195,500 670,1050 1050,1590 1590,1830
three tables, student enrolled in

528
00:14:03,400 --> 00:14:06,010
0,380 760,1080 1080,1730 2050,2415 2415,2610
course, right? It's basically trying

529
00:14:06,010 --> 00:14:07,090
0,90 90,285 285,435 435,740 760,1080
to mimic a university. There's

530
00:14:07,090 --> 00:14:09,745
0,180 180,360 360,510 510,800 2320,2655
students, they take classes and

531
00:14:09,745 --> 00:14:10,660
0,240 240,585 585,690 690,780 780,915
they're enrolled and they get

532
00:14:10,660 --> 00:14:11,730
0,270 270,480 480,585 585,750 750,1070
grades in the various courses

533
00:14:11,780 --> 00:14:12,880
0,245 245,350 350,610
that are there.|
|

534
00:14:12,950 --> 00:14:13,885
0,335 335,515 515,650 650,770 770,935
OK, so we'll use this
好的，我们将使用它作为示例数据库。

535
00:14:13,885 --> 00:14:16,270
0,275 1315,1650 1650,1920 1920,2190 2190,2385
as the sample database as

536
00:14:16,270 --> 00:14:17,340
0,105 105,225 225,500
we go along.|
|

537
00:14:18,230 --> 00:14:18,955
0,245 245,380 380,545 545,650 650,725
All right, first thing is
好的，第一件事是聚合。因此，集合函数是一种对一个数据序列或一包两个数据进行数学计算的方法，你基本上是要把它合并成一个单一值。

538
00:14:18,955 --> 00:14:21,390
0,485 1165,1410 1410,1655 1705,2175 2175,2435
aggregations. So ag aggregate functions

539
00:14:21,440 --> 00:14:24,310
0,400 840,1240 2100,2390 2390,2645 2645,2870
are A A way to

540
00:14:24,310 --> 00:14:27,690
0,470 520,920 1480,2300 2500,3030 3030,3380
compute some mathematical computation on

541
00:14:28,880 --> 00:14:30,385
0,380 380,760 780,1100 1100,1265 1265,1505
A A sequence of data

542
00:14:30,385 --> 00:14:31,530
0,315 315,480 480,615 615,765 765,1145
or a bag of twoples

543
00:14:31,850 --> 00:14:32,935
0,320 320,545 545,725 725,950 950,1085
and you're basically going to

544
00:14:32,935 --> 00:14:33,790
0,120 120,270 270,555 555,690 690,855
going to coalce it down

545
00:14:33,790 --> 00:14:35,500
0,255 255,510 510,720 720,1040
into a single value.|
|

546
00:14:35,500 --> 00:14:36,805
0,270 270,465 465,740 820,1140 1140,1305
So the classic things would
所以经典的东西是Average Min，Average Min，Max，Some Count。您正在尝试计算一个关系中所有两个列的最小值。

547
00:14:36,805 --> 00:14:39,445
0,165 165,485 715,1115 1945,2340 2340,2640
be average min, average min,

548
00:14:39,445 --> 00:14:41,845
0,305 805,1140 1140,1475 1945,2280 2280,2400
Max, some count. You're trying

549
00:14:41,845 --> 00:14:43,920
0,120 120,545 865,1265 1315,1695 1695,2075
to compute the min value

550
00:14:44,420 --> 00:14:46,825
0,400 630,905 905,1180 1650,2045 2045,2405
of a column across all

551
00:14:46,825 --> 00:14:48,720
0,515 535,935 1105,1410 1410,1605 1605,1895
twoils within within a relation.|
|

552
00:14:50,420 --> 00:14:51,400
0,245 245,395 395,605 605,815 815,980
So an simple example like
举个简单的例子，我们要计算学生的数量。那么，如果登录以at CS结尾，您是否有at CS电子邮件地址？

553
00:14:51,400 --> 00:14:52,135
0,225 225,450 450,555 555,645 645,735
this say we want to

554
00:14:52,135 --> 00:14:53,605
0,245 655,900 900,1020 1020,1260 1260,1470
get for the students, we

555
00:14:53,605 --> 00:14:55,405
0,90 90,210 210,450 450,815 1525,1800
want to count the number

556
00:14:55,405 --> 00:14:56,200
0,150 150,360 360,555 555,675 675,795
of students. So have a

557
00:14:56,200 --> 00:15:00,145
0,500 970,1370 1390,1790 2410,3050 3640,3945
login where the login ends

558
00:15:00,145 --> 00:15:01,315
0,180 180,390 390,815 895,1110 1110,1170
with at CS do you

559
00:15:01,315 --> 00:15:03,010
0,75 75,165 165,390 390,845 1375,1695
have an at CS email

560
00:15:03,010 --> 00:15:03,900
0,320
address?|
|

561
00:15:03,900 --> 00:15:05,040
0,180 180,390 390,705 705,990 990,1140
And so we just put
所以我们把Count函数放在这里，EM，然后放在它里面，实际上对Count没有影响，但我们计算登录，然后我们有我们的where调用，指定哪些twoil应该符合条件。

562
00:15:05,040 --> 00:15:06,680
0,120 120,300 300,570 570,920 1240,1640
the count function here, EM,

563
00:15:07,210 --> 00:15:08,115
0,245 245,455 455,695 695,785 785,905
and then inside of it

564
00:15:08,115 --> 00:15:09,345
0,150 150,375 375,645 645,960 960,1230
actually doesn't matter for count,

565
00:15:09,345 --> 00:15:11,300
0,240 240,840 840,1080 1080,1320 1320,1955
but we're account that logins

566
00:15:11,500 --> 00:15:12,090
0,245 245,335 335,410 410,485 485,590
and then we have our

567
00:15:12,090 --> 00:15:14,940
0,180 180,435 435,980 2290,2595 2595,2850
where call specifying what twoil

568
00:15:14,940 --> 00:15:16,080
0,135 135,650
should qualify.|
|

569
00:15:16,840 --> 00:15:18,060
0,400 450,710 710,830 830,995 995,1220
So again, in my example
同样，在我的示例中，我输入了LOG，您实际上不必这样做。你可以加上一个相等的星号，因为同样，它只是计算条目的数量。

570
00:15:18,060 --> 00:15:19,160
0,225 225,420 420,570 570,795 795,1100
here, I'm putting log in,

571
00:15:19,270 --> 00:15:19,980
0,230 230,410 410,515 515,605 605,710
you don't actually have to

572
00:15:19,980 --> 00:15:21,290
0,135 135,410 550,810 810,990 990,1310
do that. You could put

573
00:15:21,400 --> 00:15:23,955
0,305 305,610 1080,1505 1505,1780 2250,2555
a star that's equivalent because

574
00:15:23,955 --> 00:15:24,870
0,165 165,315 315,465 465,825 825,915
again, it's just counting the

575
00:15:24,870 --> 00:15:26,840
0,195 195,560 700,1280
number of entries.|
|

576
00:15:26,840 --> 00:15:27,670
0,120 120,240 240,375 375,525 525,830
You can actually put one
实际上你可以再放一次。也是等同的。无所谓。

577
00:15:28,290 --> 00:15:30,230
0,400 420,710 710,1000 1440,1700 1700,1940
again. Also equivalent. It doesn't

578
00:15:30,230 --> 00:15:31,300
0,260
matter.|
|

579
00:15:31,490 --> 00:15:32,230
0,260 260,350 350,425 425,545 545,740
Inside, you can really put
在里面，你真的可以放任何东西。你可以加一加一，加一。

580
00:15:32,230 --> 00:15:33,400
0,320 640,870 870,930 930,1020 1020,1170
anything. You can put one

581
00:15:33,400 --> 00:15:34,800
0,180 180,360 360,525 525,800
plus one, plus one.|
|

582
00:15:35,000 --> 00:15:36,475
0,350 350,700 720,1085 1085,1310 1310,1475
And the system should be
在这里的最后一个例子中，系统应该足够智能，能够意识到这一点。

583
00:15:36,475 --> 00:15:37,380
0,165 165,285 285,450 450,630 630,905
smart enough to realize that

584
00:15:37,670 --> 00:15:39,180
0,260 260,520 630,965 965,1205 1205,1510
in this last example here.|
|

585
00:15:39,820 --> 00:15:41,275
0,195 195,495 495,750 750,1040 1150,1455
I don't care what the
我不关心计数内部的表达式是什么，我也不会真正做那个数学运算，因为我只关心我得到的是什么数。

586
00:15:41,275 --> 00:15:42,100
0,225 225,450 450,615 615,720 720,825
expression is inside of the

587
00:15:42,100 --> 00:15:43,315
0,260 490,750 750,870 870,1080 1080,1215
count, and I won't actually

588
00:15:43,315 --> 00:15:44,545
0,105 105,255 255,545 895,1140 1140,1230
do that math because I

589
00:15:44,545 --> 00:15:46,240
0,135 135,315 315,605 715,1545 1545,1695
just care about what's the

590
00:15:46,240 --> 00:15:47,860
0,615 615,735 735,825 825,1070
countils that I have.|
|

591
00:15:49,310 --> 00:15:50,515
0,245 245,320 320,425 425,620 620,1205
You can have multiple aggregates
一个SELECT输出中可以有多个聚合。所以现在我们要计算平均绩点和计算学生人数。同样，有了这一点，让at CS登录。

592
00:15:50,515 --> 00:15:51,780
0,225 225,360 360,570 570,885 885,1265
in a single select output.

593
00:15:51,980 --> 00:15:52,690
0,260 260,410 410,545 545,665 665,710
So here now we're going

594
00:15:52,690 --> 00:15:54,690
0,60 60,375 375,710 1030,1395 1395,2000
to compute the average gpa

595
00:15:54,860 --> 00:15:57,355
0,400 450,850 2010,2360 2360,2420 2420,2495
and the counting of the

596
00:15:57,355 --> 00:15:58,890
0,105 105,225 225,485 895,1215 1215,1535
number of students. Again, with

597
00:15:59,600 --> 00:16:00,960
0,290 290,485 485,650 650,890 890,1360
that, have the at CS

598
00:16:01,850 --> 00:16:03,060
0,610
login.|
|

599
00:16:03,060 --> 00:16:04,725
0,150 150,285 285,560 1210,1500 1500,1665
And you get back a
然后，您将在两次计算的输出结果中返回单个条目或单个记录。

600
00:16:04,725 --> 00:16:05,960
0,275 295,540 540,675 675,900 900,1235
single entry or single record

601
00:16:06,370 --> 00:16:09,150
0,335 335,605 605,940 1320,1720 2520,2780
in the output result for

602
00:16:09,150 --> 00:16:10,620
0,120 120,255 255,770
the two computations.|
|

603
00:16:13,050 --> 00:16:14,170
0,275 275,410 410,590 590,815 815,1120
Important thing to understand though,
需要理解的重要一点是，对于聚合，因为您正在尝试合并内部的多个二元组，以获得单个标量值，所以您不能引用任何内容。

604
00:16:14,250 --> 00:16:15,605
0,260 260,755 755,1010 1010,1205 1205,1355
with aggregation, since you're trying

605
00:16:15,605 --> 00:16:17,540
0,165 165,525 525,845 1615,1845 1845,1935
to coalesce down, you know,

606
00:16:17,540 --> 00:16:19,295
0,240 240,770 970,1335 1335,1530 1530,1755
multiple twoples within, you know,

607
00:16:19,295 --> 00:16:20,465
0,345 345,525 525,615 615,825 825,1170
to to a single scalar

608
00:16:20,465 --> 00:16:23,050
0,245 895,1215 1215,1590 1590,1895 2185,2585
value, you can't reference anything.|
|

609
00:16:23,760 --> 00:16:25,965
0,240 240,560 940,1335 1335,1730 1930,2205
In the select output that
在不是的SELECT输出中，这不是聚合的一部分。

610
00:16:25,965 --> 00:16:27,720
0,420 420,785 1135,1560 1560,1680 1680,1755
isn't, that isn't part of

611
00:16:27,720 --> 00:16:28,860
0,90 90,590
the aggregate.|
|

612
00:16:28,930 --> 00:16:29,760
0,245 245,365 365,560 560,665 665,830
So I can't do something
所以我不能做这样的事。我不能选择平均GPA，在你加入了学生表，注册表，然后还吐出了学生表的课程ID。

613
00:16:29,760 --> 00:16:30,680
0,150 150,300 300,450 450,675 675,920
like this. I can't go

614
00:16:30,820 --> 00:16:33,150
0,275 275,380 380,530 530,1090 2040,2330
select the average gpa after

615
00:16:33,150 --> 00:16:34,170
0,180 180,390 390,600 600,795 795,1020
you join the student table,

616
00:16:34,170 --> 00:16:35,760
0,150 150,435 435,710 1060,1335 1335,1590
the enrolled table, and then

617
00:16:35,760 --> 00:16:37,995
0,315 315,540 540,800 1000,1400 1960,2235
also spit out the the

618
00:16:37,995 --> 00:16:40,035
0,165 165,455 775,1035 1035,1295 1735,2040
course ID of the roll

619
00:16:40,035 --> 00:16:40,980
0,305
table.|
|

620
00:16:41,330 --> 00:16:42,480
0,400
Right.|
正确的。|

621
00:16:42,480 --> 00:16:43,395
0,135 135,240 240,360 360,570 570,915
Because this is not defined,
因为这没有定义，所以这没有任何意义。

622
00:16:43,395 --> 00:16:44,780
0,270 270,665 685,930 930,1080 1080,1385
this doesn't make any sense.|
|

623
00:16:45,580 --> 00:16:48,120
0,400 630,950 950,1130 1130,1510 2250,2540
Right there, there isn't you.
就在那里，那里没有你。你排成多排，你你在浓缩它，向下，以平均水平。此上下文中的课程ID是什么？

624
00:16:48,120 --> 00:16:49,755
0,240 240,420 420,705 705,1280 1300,1635
You're taking multiple rows, you

625
00:16:49,755 --> 00:16:51,705
0,425 505,1020 1020,1110 1110,1680 1680,1950
you're condensing it, downing down,

626
00:16:51,705 --> 00:16:53,330
0,450 450,630 630,780 780,1025 1225,1625
collapsing down for the average.

627
00:16:53,800 --> 00:16:54,735
0,260 260,380 380,500 500,650 650,935
What is the course ID

628
00:16:54,735 --> 00:16:56,200
0,255 255,390 390,665
in this context?|
|

629
00:16:56,600 --> 00:16:58,240
0,400 450,755 755,1000
Right. It's nothing.|
正确的。那算不了什么。|

630
00:16:58,830 --> 00:16:59,900
0,230 230,305 305,550 690,935 935,1070
So if you, in this
所以，如果你，在这个例子中，你看这个，你真正想做的是你试图得到每个课程ID，得到平均GPA。

631
00:16:59,900 --> 00:17:01,790
0,180 180,420 420,770 1570,1815 1815,1890
case here, you sort of

632
00:17:01,790 --> 00:17:02,255
0,60 60,120 120,210 210,315 315,465
look at this, what you're

633
00:17:02,255 --> 00:17:03,040
0,120 120,285 285,390 390,510 510,785
really trying to do is

634
00:17:03,120 --> 00:17:03,920
0,305 305,410 410,515 515,650 650,800
you're trying to get for

635
00:17:03,920 --> 00:17:05,240
0,195 195,420 420,710 880,1170 1170,1320
each course ID, get the

636
00:17:05,240 --> 00:17:06,740
0,210 210,800
average gpa.|
|

637
00:17:07,890 --> 00:17:08,555
0,245 245,350 350,455 455,560 560,665
So what you need to
因此，你需要做的是把第一组条款称为什么。

638
00:17:08,555 --> 00:17:09,575
0,245 415,690 690,825 825,930 930,1020
do is what to call

639
00:17:09,575 --> 00:17:11,240
0,120 120,270 270,465 465,815
a group I clause.|
|

640
00:17:11,240 --> 00:17:13,670
0,380 430,765 765,930 930,1250 2050,2430
Where you're going to project
在这里，您将根据GROUP BY子句中的任何参数将两个油投影到存储桶中。

641
00:17:13,670 --> 00:17:15,710
0,435 435,740 1030,1560 1560,1815 1815,2040
twoils into buckets based on

642
00:17:15,710 --> 00:17:17,360
0,210 210,500 940,1380 1380,1515 1515,1650
whatever the parameters are in

643
00:17:17,360 --> 00:17:18,820
0,120 120,240 240,390 390,710
the group by clause.|
|

644
00:17:18,820 --> 00:17:20,340
0,150 150,345 345,795 795,960 960,1520
And then compute the aggregate
然后计算每个单独桶的总和。

645
00:17:20,540 --> 00:17:22,580
0,380 380,725 725,1025 1025,1360
on each individual bucket.|
|

646
00:17:23,030 --> 00:17:23,575
0,230 230,305 305,395 395,470 470,545
So you sort of think
所以你大概是这样想的。如果我首先在已注册表格和学生表格之间进行联接，我就有了基于联接的所有可能的组合，然后我将根据课程ID将它们分开，因为这就是我在我的组I子句中所做的。

647
00:17:23,575 --> 00:17:24,310
0,90 90,210 210,405 405,585 585,735
it like this. If I

648
00:17:24,310 --> 00:17:26,190
0,240 240,590 730,1130 1300,1590 1590,1880
first do the the join

649
00:17:26,720 --> 00:17:27,685
0,260 260,350 350,635 635,815 815,965
between the enrolllled table and

650
00:17:27,685 --> 00:17:29,200
0,120 120,315 315,635 1045,1320 1320,1515
the student table, I have

651
00:17:29,200 --> 00:17:30,760
0,270 270,620 970,1215 1215,1350 1350,1560
all the have all possible

652
00:17:30,760 --> 00:17:31,950
0,435 435,675 675,810 810,930 930,1190
combinations based on the join

653
00:17:32,510 --> 00:17:33,580
0,260 260,410 410,680 680,980 980,1070
and then now I'm going

654
00:17:33,580 --> 00:17:34,525
0,150 150,315 315,465 465,690 690,945
to split them up based

655
00:17:34,525 --> 00:17:35,470
0,150 150,315 315,510 510,675 675,945
on the the course ID

656
00:17:35,470 --> 00:17:36,355
0,225 225,435 435,510 510,615 615,885
because that's what I have

657
00:17:36,355 --> 00:17:38,125
0,330 330,665 1195,1455 1455,1605 1605,1770
in my in my group

658
00:17:38,125 --> 00:17:39,300
0,180 180,515
I clause.|
|

659
00:17:39,370 --> 00:17:40,680
0,275 275,470 470,755 755,1010 1010,1310
And then now I compute
然后现在我计算平均绩点，每个桶，每个桶。

660
00:17:40,680 --> 00:17:43,010
0,135 135,380 1450,1695 1695,1815 1815,2330
the average for the gpa,

661
00:17:43,060 --> 00:17:44,025
0,260 260,515 515,755 755,860 860,965
for each, for each of

662
00:17:44,025 --> 00:17:45,120
0,135 135,575
those buckets.|
|

663
00:17:46,730 --> 00:17:47,940
0,260 260,520
Makes sense.|
合乎道理。|

664
00:17:50,660 --> 00:17:51,475
0,245 245,365 365,545 545,695 695,815
And just matches up like
就像这样匹配。

665
00:17:51,475 --> 00:17:52,420
0,275
this.|
|

666
00:17:53,510 --> 00:17:54,670
0,275 275,530 530,770 770,905 905,1160
So again, the main takeaway,
所以，再一次，主要的外卖，再一次，你必须有任何东西在一个。

667
00:17:54,670 --> 00:17:55,345
0,120 120,300 300,465 465,570 570,675
this again, you have to

668
00:17:55,345 --> 00:17:56,790
0,245 355,615 615,840 840,1080 1080,1445
have anything that's in a.|
|

669
00:17:58,690 --> 00:17:59,790
0,485 485,680 680,860 860,1025 1025,1100
Editing that's not part of
编辑不属于聚合的内容必须出现在GROUP I子句中。再说一次，在这里，我没有学生的名字。我我不能，我不能把它放在那里。我必须把它放在GROUP BY子句中。

670
00:17:59,790 --> 00:18:01,815
0,75 75,620 1330,1650 1650,1845 1845,2025
an aggregation has to appear

671
00:18:01,815 --> 00:18:02,660
0,165 165,270 270,375 375,525 525,845
in the group I clause.

672
00:18:02,920 --> 00:18:03,720
0,260 260,365 365,470 470,605 605,800
So again, in this case

673
00:18:03,720 --> 00:18:04,650
0,270 270,480 480,675 675,780 780,930
here, I don't have the

674
00:18:04,650 --> 00:18:06,180
0,195 195,500 730,1050 1050,1260 1260,1530
student name. I I can't,

675
00:18:06,180 --> 00:18:07,100
0,135 135,360 360,480 480,630 630,920
I can't put that there.

676
00:18:07,180 --> 00:18:08,040
0,320 320,425 425,605 605,755 755,860
I'd have to put it

677
00:18:08,040 --> 00:18:08,760
0,180 180,360 360,465 465,570 570,720
in in the group by

678
00:18:08,760 --> 00:18:09,660
0,320
clause.|
|

679
00:18:10,530 --> 00:18:11,330
0,230 230,350 350,470 470,560 560,800
We can open the terminal
如果您希望我的SQL在某些情况下允许您这样做，我们可以打开终端。

680
00:18:11,330 --> 00:18:12,170
0,45 45,120 120,285 285,480 480,840
if you want my sql

681
00:18:12,170 --> 00:18:13,030
0,225 225,360 360,480 480,600 600,860
used to let you do

682
00:18:13,110 --> 00:18:15,520
0,245 245,350 350,485 485,760
this in some cases.|
|

683
00:18:16,460 --> 00:18:17,605
0,245 245,335 335,485 485,790 870,1145
But we can actually try
但我们实际上可以试着看看会发生什么。

684
00:18:17,605 --> 00:18:18,780
0,135 135,210 210,270 270,515
and see what happens.|
|

685
00:18:20,750 --> 00:18:21,930
0,275 275,440 440,755 755,905 905,1180
I hate typing on my.|
我讨厌在我的电脑上打字。|

686
00:18:23,110 --> 00:18:23,910
0,290 290,500 500,725 725,755 755,800
My surface, I'm going to
我的表面，我将在这里使用这台笔记本电脑。

687
00:18:23,910 --> 00:18:25,880
0,135 135,440 550,975 975,1250
use this laptop here.|
|

688
00:18:25,880 --> 00:18:27,180
0,225 225,345 345,510 510,800
I'll log into it.|
我会登录进去的。|

689
00:18:33,870 --> 00:18:34,610
0,230 230,380 380,560 560,665 665,740
All right, so we want
好的，我们要做的是Postgres，我有很多数据库系统在运行，所以我们要做的查询是。

690
00:18:34,610 --> 00:18:37,340
0,90 90,350 1990,2550 2550,2685 2685,2730
to do postgres I have

691
00:18:37,340 --> 00:18:38,120
0,60 60,150 150,330 330,555 555,780
a bunch of database systems

692
00:18:38,120 --> 00:18:39,695
0,320 760,1050 1050,1200 1200,1410 1410,1575
running, so the query we

693
00:18:39,695 --> 00:18:40,660
0,105 105,225 225,345 345,585 585,965
were trying to do was.|
|

694
00:18:45,730 --> 00:18:47,500
0,395 395,790
Essentially this.|
本质上就是这样。|

695
00:18:48,460 --> 00:18:50,085
0,365 365,620 620,830 830,1370 1370,1625
Right select average gpa course
从已注册加入注册表和学生表中右键选择平均GPA课程ID。

696
00:18:50,085 --> 00:18:51,810
0,255 255,495 495,945 945,1275 1275,1725
ID from enrolled joining enrolled

697
00:18:51,810 --> 00:18:53,260
0,135 135,300 300,465 465,740
table and student table.|
|

698
00:18:53,300 --> 00:18:54,820
0,400 540,815 815,1175 1175,1415 1415,1520
Right. So postgres doesn't let
正确的。所以Postgres不允许这样做，因为它规定课程ID必须出现在组I子句中。那很好。这正是我们所期待的。

699
00:18:54,820 --> 00:18:55,630
0,120 120,240 240,450 450,675 675,810
you do this because it

700
00:18:55,630 --> 00:18:57,385
0,240 240,620 760,1020 1020,1280 1480,1755
says the course ID has

701
00:18:57,385 --> 00:18:57,955
0,150 150,285 285,390 390,480 480,570
to appear in the group

702
00:18:57,955 --> 00:18:59,710
0,135 135,455 595,990 990,1235 1435,1755
I clause. That's good. That's

703
00:18:59,710 --> 00:19:00,860
0,75 75,240 240,560
what we expect.|
|

704
00:19:01,085 --> 00:19:01,490
0,75 75,150 150,210 210,285 285,405
Let's go over to my
让我们来看看我的SQL。

705
00:19:01,490 --> 00:19:02,700
0,440
sql.|
|

706
00:19:03,570 --> 00:19:04,415
0,275 275,470 470,635 635,740 740,845
My sql doesn't let you
我的SQL不允许您这样做，但让我看看在默认情况下是否将其设置为正确的模式。

707
00:19:04,415 --> 00:19:06,545
0,105 105,365 1705,1950 1950,2025 2025,2130
do it, but let me

708
00:19:06,545 --> 00:19:07,040
0,120 120,210 210,330 330,435 435,495
see if I put it

709
00:19:07,040 --> 00:19:08,855
0,75 75,180 180,390 390,740 1450,1815
in the right mode by

710
00:19:08,855 --> 00:19:09,840
0,365
default.|
|

711
00:19:11,670 --> 00:19:12,575
0,335 335,605 605,710 710,815 815,905
Right doesn't let you do
权利不允许你这样做，但有一种方法可以让它强制执行。

712
00:19:12,575 --> 00:19:13,295
0,105 105,225 225,375 375,480 480,720
it, but there's a way

713
00:19:13,295 --> 00:19:16,680
0,365 1105,1410 1410,2075
to it's enforcing.|
|

714
00:19:16,680 --> 00:19:19,185
0,255 255,705 705,980 1480,1880 2230,2505
It's enforcing the what mode
如果我转到传统模式，它会强制执行该模式。

715
00:19:19,185 --> 00:19:19,845
0,180 180,270 270,375 375,480 480,660
it's in if I go

716
00:19:19,845 --> 00:19:21,500
0,255 255,605
to traditional.|
|

717
00:19:22,670 --> 00:19:23,590
0,290 290,515 515,695 695,785 785,920
Then now run the same
然后，现在运行相同的查询。它让我这么做。

718
00:19:23,590 --> 00:19:25,210
0,320 970,1230 1230,1365 1365,1500 1500,1620
query. It lets me do

719
00:19:25,210 --> 00:19:25,960
0,260
it.|
|

720
00:19:26,250 --> 00:19:27,110
0,245 245,365 365,530 530,695 695,860
And it spits out course
上面写着课程编号。15445。

721
00:19:27,110 --> 00:19:28,750
0,260 700,1020 1020,1200 1200,1350 1350,1640
ID. Fifteen four, forty five.|
|

722
00:19:29,360 --> 00:19:30,860
0,210 210,405 405,740
Is that correct?|
对吗？|

723
00:19:32,410 --> 00:19:33,360
0,350 350,605 605,770 770,875 875,950
No, right, because what does
不，对，因为那是什么意思？这是所有课程的平均GP，但却吐出了其中的一个。所以这很糟糕。所以我们现在开始，接受同样的问题，我们将转到。

724
00:19:33,360 --> 00:19:34,230
0,120 120,345 345,615 615,705 705,870
that mean? It's the average

725
00:19:34,230 --> 00:19:36,045
0,360 360,495 495,645 645,950 1300,1815
gp for all courses, but's

726
00:19:36,045 --> 00:19:36,920
0,210 210,360 360,525 525,630 630,875
spitting out one of them.

727
00:19:37,300 --> 00:19:39,795
0,230 230,695 695,940 2100,2330 2330,2495
So that's bad. So let's

728
00:19:39,795 --> 00:19:40,680
0,150 150,420 420,645 645,750 750,885
go now, take the same

729
00:19:40,680 --> 00:19:42,500
0,320 880,1140 1140,1305 1305,1485 1485,1820
query and we'll go over

730
00:19:42,550 --> 00:19:44,620
0,400
to.|
|

731
00:19:45,080 --> 00:19:46,740
0,260 260,730
To sqlite.|
到SQLITE。|

732
00:19:48,250 --> 00:19:48,915
0,260 260,395 485,530 530,590 590,665
Who thinks it's going to
谁认为这会奏效？

733
00:19:48,915 --> 00:19:49,800
0,245
work?|
|

734
00:19:50,010 --> 00:19:50,600
0,275 275,380 380,455 455,530 530,590
Raise your hand if you
如果你答应了，请举手。

735
00:19:50,600 --> 00:19:51,820
0,105 105,380
say yes.|
|

736
00:19:51,860 --> 00:19:53,395
0,245 245,470 470,755 755,1055 1055,1535
And the work, meaning it'll
而工作，意味着它实际上将运行查询，我不是在说结果，对吗？

737
00:19:53,395 --> 00:19:54,445
0,195 195,315 315,420 420,695 775,1050
actually run the query, I'm

738
00:19:54,445 --> 00:19:55,350
0,75 75,180 180,315 315,555 555,905
not saying the result, correct?|
|

739
00:19:56,290 --> 00:19:58,095
0,260 260,520 1290,1535 1535,1640 1640,1805
Who thinks we have one?
谁认为我们有呢？是的，两个赞成谁说不？

740
00:19:58,095 --> 00:19:59,190
0,225 225,405 405,765 765,945 945,1095
Yes, two yeses who says

741
00:19:59,190 --> 00:20:00,120
0,290
no?|
|

742
00:20:01,120 --> 00:20:02,620
0,290 290,440 440,530 530,790
Mostly, we say no.|
大多数情况下，我们会说不。|

743
00:20:03,370 --> 00:20:06,405
0,245 245,350 350,610 1740,2140 2790,3035
He did it right. And
他做得很对。我还吐出了15，4，45，这和我的SQL值一样吗？

744
00:20:06,405 --> 00:20:07,215
0,135 135,285 285,420 420,540 540,810
I also spit out fifteen,

745
00:20:07,215 --> 00:20:08,355
0,270 270,420 420,695 805,1050 1050,1140
four, forty five, is that

746
00:20:08,355 --> 00:20:09,045
0,105 105,255 255,420 420,555 555,690
the same value as my

747
00:20:09,045 --> 00:20:10,140
0,395
sql?|
|

748
00:20:10,290 --> 00:20:13,020
0,335 335,770 770,1060 1830,2230
Yeah, gpa looks sorry.|
是啊，平均绩点看起来很抱歉。|

749
00:20:13,620 --> 00:20:16,120
0,380 380,515 515,650 650,910
Gba looks the same.|
GBA看起来也是一样的。|

750
00:20:16,120 --> 00:20:17,005
0,120 120,210 210,375 375,570 570,885
All right, let's go to
好了，我们去找先知吧。

751
00:20:17,005 --> 00:20:18,280
0,605
Oracle.|
|

752
00:20:20,210 --> 00:20:21,715
0,425 425,605 605,725 725,1000 1445,1505
Oracle doesn't like it. Let's
甲骨文不喜欢这样。我们去数据库吧。

753
00:20:21,715 --> 00:20:23,260
0,90 90,270 270,725
go to DB.|
|

754
00:20:25,350 --> 00:20:26,525
0,245 245,395 395,470 470,730 870,1175
B didn't like it. So
B不喜欢它。所以我的SQL，你可以这样做，如果你，如果你让A，B更像我的SQL 5，7和8，但是SQL，我不这样做。

755
00:20:26,525 --> 00:20:27,320
0,195 195,450 450,540 540,660 660,795
my sql, you can do

756
00:20:27,320 --> 00:20:28,550
0,260 370,660 660,810 810,1020 1020,1230
it if if you, if

757
00:20:28,550 --> 00:20:29,540
0,120 120,255 255,420 420,710 730,990
you make A B more

758
00:20:29,540 --> 00:20:30,275
0,120 120,255 255,495 495,600 600,735
like my sql five and

759
00:20:30,275 --> 00:20:31,595
0,180 180,375 375,665 805,1080 1080,1320
seven and eight, but sql,

760
00:20:31,595 --> 00:20:32,760
0,90 90,210 210,285 285,515
I Don do it.|
|

761
00:20:32,760 --> 00:20:35,055
0,180 180,440 1840,2085 2085,2175 2175,2295
So again, this is the
同样，这是第一个例子。我们会看到很多次的。

762
00:20:35,055 --> 00:20:35,925
0,225 225,495 495,735 735,795 795,870
first example. We'll see it

763
00:20:35,925 --> 00:20:37,260
0,135 135,425
many times.|
|

764
00:20:37,390 --> 00:20:39,020
0,490 660,980 980,1175 1175,1340 1340,1630
Sql standard says one thing,
SQL标准说明了一件事，但不同的系统做的事情是不同的。

765
00:20:39,280 --> 00:20:40,605
0,400 480,755 755,935 935,1160 1160,1325
but the different systems are

766
00:20:40,605 --> 00:20:41,820
0,120 120,300 300,605
doing different things.|
|

767
00:20:45,170 --> 00:20:45,925
0,275 275,380 380,455 455,590 590,755
Next thing you do is
接下来你要做的是，你可以有一个HAVING从句。比方说，如果您想要在这些aggreg上开始过滤您正在生成的聚合逗号，您可以添加一个havingving子句来指定。

768
00:20:45,925 --> 00:20:46,855
0,275 445,660 660,720 720,810 810,930
have you can have a

769
00:20:46,855 --> 00:20:48,385
0,225 225,605 925,1260 1260,1440 1440,1530
having clause. Say, if you

770
00:20:48,385 --> 00:20:49,590
0,90 90,195 195,375 375,885 885,1205
want to start filtering on

771
00:20:49,730 --> 00:20:51,625
0,260 260,395 395,820 1320,1580 1580,1895
on these aggreg the aggregate

772
00:20:51,625 --> 00:20:54,040
0,225 225,450 450,875 2035,2280 2280,2415
commum you're generating, you can

773
00:20:54,040 --> 00:20:55,630
0,165 165,330 330,645 645,950 1300,1590
add a havingving clause to

774
00:20:55,630 --> 00:20:57,040
0,560
specify.|
|

775
00:20:57,230 --> 00:20:58,750
0,400 810,1055 1055,1175 1175,1325 1325,1520
Whether, how many, what people
是否、有多少人、什么人应该匹配。

776
00:20:58,750 --> 00:21:00,100
0,210 210,500
should match.|
|

777
00:21:00,200 --> 00:21:01,350
0,290 290,470 470,605 605,680 680,1150
After you complete the aggregation.|
在您完成聚合之后。|

778
00:21:02,120 --> 00:21:02,840
0,180 180,375 375,525 525,645 645,720
Right. So say I want
正确的。比方说，我只想要那些平均绩点平均的学生。

779
00:21:02,840 --> 00:21:05,450
0,75 75,320 340,740 2080,2400 2400,2610
to get only only the

780
00:21:05,450 --> 00:21:06,365
0,225 225,420 420,555 555,705 705,915
students that have an average

781
00:21:06,365 --> 00:21:08,740
0,545
gpa.|
|

782
00:21:08,740 --> 00:21:10,795
0,255 255,435 435,675 675,1340 1720,2055
That's greater than 3.9 so
它大于3.9，所以在本例中，我计算的是选择平均GPA作为GPA的总和，并且我试图在WHERE子句中引用它，对吗？我不能这样做，因为此时系统实际上正在计算查询。

783
00:21:10,795 --> 00:21:11,725
0,180 180,315 315,510 510,675 675,930
in this case here, I'm

784
00:21:11,725 --> 00:21:13,795
0,300 300,420 420,905 1525,1830 1830,2070
computing the aggregation select average

785
00:21:13,795 --> 00:21:16,585
0,525 525,875 1765,2345 2425,2655 2655,2790
gpa as gpa and I'm

786
00:21:16,585 --> 00:21:17,610
0,105 105,240 240,495 495,750 750,1025
trying to reference it here

787
00:21:17,630 --> 00:21:18,600
0,260 260,350 350,455 455,635 635,970
inside of my where clause,

788
00:21:19,100 --> 00:21:20,680
0,400 630,905 905,1175 1175,1325 1325,1580
right? I can't do that

789
00:21:20,680 --> 00:21:22,285
0,380 580,870 870,1110 1110,1395 1395,1605
because at this point when

790
00:21:22,285 --> 00:21:23,620
0,165 165,420 420,720 720,945 945,1335
the system is actually calculating

791
00:21:23,620 --> 00:21:24,820
0,150 150,440
the query.|
|

792
00:21:24,820 --> 00:21:26,095
0,270 270,570 570,1005 1005,1170 1170,1275
It's computing aggregation as it
它一边运行，一边计算聚合。它不能，不知道最后的结果是什么。

793
00:21:26,095 --> 00:21:28,000
0,180 180,515 805,1110 1110,1535 1555,1905
goes along. It can't, doesn't

794
00:21:28,000 --> 00:21:29,005
0,105 105,195 195,300 300,560 700,1005
know what the final result

795
00:21:29,005 --> 00:21:30,100
0,305
is.|
|

796
00:21:30,790 --> 00:21:31,650
0,245 245,320 320,500 500,725 725,860
So the easy fix of
因此，解决这一问题的简单方法是有一个HAVING子句。

797
00:21:31,650 --> 00:21:32,625
0,165 165,345 345,465 465,705 705,975
this is to have a

798
00:21:32,625 --> 00:21:34,040
0,225 225,605
having clause.|
|

799
00:21:34,040 --> 00:21:34,985
0,150 150,270 270,525 525,810 810,945
Which is basically telling the
这基本上是在告诉系统形成性聚集是。

800
00:21:34,985 --> 00:21:38,020
0,245 805,1275 1275,1695 1695,2015
system formative aggregation is.|
|

801
00:21:38,210 --> 00:21:39,490
0,275 275,500 500,710 710,1040 1040,1280
Produce the output that's defined
生成SELECT语句中定义的输出，然后应用这个额外的筛选器。

802
00:21:39,490 --> 00:21:41,155
0,135 135,270 270,465 465,770 1270,1665
in the select statement, and

803
00:21:41,155 --> 00:21:42,630
0,360 360,630 630,840 840,1110 1110,1475
then apply this additional filter

804
00:21:43,520 --> 00:21:44,740
0,260 260,520
for having.|
|

805
00:21:46,310 --> 00:21:47,125
0,245 245,395 395,530 530,650 650,815
This is actually not correct
这其实也是不对的。在某些情况下，我认为SQL标准也不允许您这样做，对吗？因为即使我在这里有一个平均绩点的别名。

806
00:21:47,125 --> 00:21:48,550
0,275 445,705 705,825 825,1085 1195,1425
either. In some cases I

807
00:21:48,550 --> 00:21:49,195
0,120 120,195 195,300 300,510 510,645
don't think the sql standard

808
00:21:49,195 --> 00:21:49,980
0,135 135,255 255,375 375,510 510,785
lets you do this either,

809
00:21:50,480 --> 00:21:51,715
0,350 350,650 650,890 890,1085 1085,1235
right? Because even though I

810
00:21:51,715 --> 00:21:52,750
0,105 105,210 210,660 660,840 840,1035
have an alias up here

811
00:21:52,750 --> 00:21:54,420
0,165 165,315 315,830
for average gpa.|
|

812
00:21:54,490 --> 00:21:56,565
0,400 1290,1580 1580,1760 1760,1895 1895,2075
The data system can say,
数据系统会说，我不知道这是什么。

813
00:21:56,565 --> 00:21:57,315
0,225 225,435 435,510 510,615 615,750
I don't know what this

814
00:21:57,315 --> 00:21:58,360
0,275
is.|
|

815
00:21:58,630 --> 00:21:59,550
0,305 305,560 560,680 680,800 800,920
My sql that you do
您执行POST的我的SQL没有，所以您基本上必须重新编写Aggregation子句。

816
00:21:59,550 --> 00:22:02,190
0,260 1510,1875 1875,2130 2130,2370 2370,2640
it post does not, so

817
00:22:02,190 --> 00:22:02,910
0,195 195,300 300,375 375,480 480,720
instead you have to basically

818
00:22:02,910 --> 00:22:06,195
0,300 300,620 1870,2270 2320,2910 2910,3285
write the the aggregation clause

819
00:22:06,195 --> 00:22:07,120
0,365
again.|
|

820
00:22:07,240 --> 00:22:08,460
0,290 290,470 470,620 620,880 990,1220
And again, the database should
同样，数据库应该足够智能，能够识别GPA上的平均值与上面的平均值相同，因此计算相同的计算，而不是执行相同的计算，执行两次相同的计算。

821
00:22:08,460 --> 00:22:09,320
0,150 150,345 345,480 480,600 600,860
be smart enough to recognize

822
00:22:09,430 --> 00:22:11,235
0,400 570,970 1140,1490 1490,1700 1700,1805
that this average on the

823
00:22:11,235 --> 00:22:12,015
0,360 360,480 480,570 570,675 675,780
gpa is the same as

824
00:22:12,015 --> 00:22:12,980
0,105 105,285 285,570 570,690 690,965
that average gp up there,

825
00:22:13,060 --> 00:22:14,460
0,335 335,545 545,940 990,1250 1250,1400
and therefore compute the same

826
00:22:14,460 --> 00:22:16,815
0,470 760,1260 1260,1610 1990,2250 2250,2355
computation, don't perform, perform the

827
00:22:16,815 --> 00:22:18,280
0,135 135,540 540,875
same computation twice.|
|

828
00:22:20,030 --> 00:22:21,040
0,275 275,470 470,665 665,830 830,1010
So essentially just doing this
因此，本质上只是再次执行此操作，计算聚合，然后进行额外的过滤，以丢弃不需要的内容。

829
00:22:21,040 --> 00:22:22,645
0,225 225,540 540,615 615,1070 1330,1605
again, compute the aggregation and

830
00:22:22,645 --> 00:22:23,815
0,180 180,450 450,645 645,825 825,1170
then do the additional filtering

831
00:22:23,815 --> 00:22:24,445
0,150 150,270 270,375 375,510 510,630
to throw out things you

832
00:22:24,445 --> 00:22:25,800
0,335
don't.|
|

833
00:22:26,510 --> 00:22:27,880
0,260 260,520
Makes sense.|
合乎道理。|

834
00:22:29,550 --> 00:22:30,820
0,245 245,490
All right.|
好的。|

835
00:22:31,440 --> 00:22:33,370
0,430 900,1205 1205,1430 1430,1685 1685,1930
Strings and time stamps or
字符串和时间戳或日期，或者当事情变得非常奇怪时，不是奇怪，但就像，非常不一致。

836
00:22:33,780 --> 00:22:34,835
0,305 305,455 455,590 590,770 770,1055
dates or when things get

837
00:22:34,835 --> 00:22:36,875
0,395 1195,1455 1455,1605 1605,1830 1830,2040
really get really weird, not

838
00:22:36,875 --> 00:22:39,730
0,165 165,300 300,545 865,1265 2035,2855
weird, but like, really inconsistent.|
|

839
00:22:40,470 --> 00:22:41,900
0,305 305,530 530,755 755,1055 1055,1430
So for string function string
因此，对于字符串函数字符串操作或字符串数据类型，SQL标准规定，我指的是值中字符串的大小写，我指的是字符串和SELECT语句，我指的是您存储的实际数据。

840
00:22:41,900 --> 00:22:43,750
0,345 345,710 1030,1320 1320,1530 1530,1850
operations or string data types,

841
00:22:44,190 --> 00:22:46,775
0,400 960,1385 1385,1610 1610,2210 2210,2585
the sql standard specifies that

842
00:22:46,775 --> 00:22:48,290
0,395 655,960 960,1185 1185,1350 1350,1515
the, the case of the

843
00:22:48,290 --> 00:22:50,015
0,350 670,990 990,1155 1155,1400 1480,1725
strings within the values that

844
00:22:50,015 --> 00:22:50,735
0,105 105,240 240,405 405,600 600,720
I mean, the strings and

845
00:22:50,735 --> 00:22:51,640
0,120 120,285 285,510 510,675 675,905
the select statements, I mean

846
00:22:51,720 --> 00:22:52,810
0,305 305,470 470,620 620,800 800,1090
the actual data you're storing.|
|

847
00:22:53,460 --> 00:22:54,360
0,210 210,435 435,555 555,690 690,900
That they should be case
它们应该区分大小写，并且当您希望在SQL语句中包含常量字符串时，您希望使用单引号。

848
00:22:54,360 --> 00:22:56,775
0,320 880,1170 1170,1460 2080,2325 2325,2415
sensitive and that when you

849
00:22:56,775 --> 00:22:57,495
0,105 105,225 225,420 420,600 600,720
want to have in your

850
00:22:57,495 --> 00:23:00,225
0,240 240,515 1105,1505 1645,2075 2485,2730
sql statement constant strings, you

851
00:23:00,225 --> 00:23:01,370
0,90 90,195 195,375 375,645 645,1145
want to use single quotes.|
|

852
00:23:02,260 --> 00:23:04,545
0,640 810,1205 1205,1480 1560,1850 1850,2285
Postgres sql server and Oracle
Postgres SQL服务器和Oracle遵循My SQL的标准。

853
00:23:04,545 --> 00:23:06,380
0,210 210,390 390,665 1075,1380 1380,1835
follow the standard my sql

854
00:23:06,820 --> 00:23:08,120
0,400
is.|
|

855
00:23:08,570 --> 00:23:11,875
0,380 380,760 780,1100 1100,1900 3030,3305
By default, case insensitive and
默认情况下，不区分大小写，因此它们都支持使用单引号和双引号来表示常量和字符串。

856
00:23:11,875 --> 00:23:12,970
0,135 135,360 360,645 645,915 915,1095
then they both sql light

857
00:23:12,970 --> 00:23:14,520
0,320 400,675 675,840 840,1200 1200,1550
and and my sql support

858
00:23:14,660 --> 00:23:17,575
0,320 320,590 590,940 2280,2600 2600,2915
both single and double quotation

859
00:23:17,575 --> 00:23:19,840
0,305 745,1145 1165,1565 1615,2100 2100,2265
Marks to represent constants and

860
00:23:19,840 --> 00:23:20,700
0,320
strings.|
|

861
00:23:21,325 --> 00:23:21,760
0,75 75,150 150,225 225,300 300,435
So let's do what my
所以让我们做我的CEO做的事情，看看这有多奇怪。

862
00:23:21,760 --> 00:23:22,900
0,195 195,440 610,900 900,1035 1035,1140
CEO does and see how

863
00:23:22,900 --> 00:23:24,120
0,135 135,270 270,530
weird this is.|
|

864
00:23:25,100 --> 00:23:26,100
0,215 215,335 335,440 440,650 650,1000
So let's go back here.|
所以让我们回到这里。|

865
00:23:26,840 --> 00:23:28,220
0,320
EM.|
嗯。|

866
00:23:30,290 --> 00:23:32,790
0,380 380,760 1920,2165 2165,2255 2255,2500
Right, so you can represent
对，所以你可以像这样表示一个常量。

867
00:23:33,560 --> 00:23:35,640
0,290 290,530 530,770 770,1060
a constant like this.|
|

868
00:23:35,890 --> 00:23:37,035
0,320 320,620 620,860 860,980 980,1145
Right. So you can have
正确的。因此，您可以在我的SQL中使用不带FROM子句的SELECT语句，我可以表示。它基本上接受任何输入，我可以，它会把它吐出来。所以我加了一个逗号，我能做的就是一，二。

869
00:23:37,035 --> 00:23:38,745
0,210 210,420 420,725 745,1145 1435,1710
a select statement without a

870
00:23:38,745 --> 00:23:40,100
0,165 165,485 505,765 765,915 915,1355
from clause in my sql

871
00:23:40,690 --> 00:23:42,465
0,245 245,350 350,470 470,730 1500,1775
and I can represent. It

872
00:23:42,465 --> 00:23:43,635
0,255 255,555 555,780 780,1005 1005,1170
basically takes whatever the input

873
00:23:43,635 --> 00:23:45,120
0,245 355,720 720,975 975,1185 1185,1485
is and I can, it'll

874
00:23:45,120 --> 00:23:45,660
0,135 135,210 210,330 330,450 450,540
spit it out. So I

875
00:23:45,660 --> 00:23:47,490
0,90 90,180 180,620 970,1370 1570,1830
put a comma get I

876
00:23:47,490 --> 00:23:49,190
0,90 90,180 180,345 345,650 1300,1700
can do like one, two.|
|

877
00:23:50,700 --> 00:23:52,460
0,400 420,710 710,1000 1260,1610 1610,1760
Three like that. It'll make
像这样的三个。它将对输出中的所有内容进行通信。

878
00:23:52,460 --> 00:23:53,915
0,270 270,465 465,710 1060,1320 1320,1455
comm for all the things

879
00:23:53,915 --> 00:23:55,060
0,120 120,270 270,575
in the output.|
|

880
00:23:55,100 --> 00:23:56,680
0,400 510,860 860,1205 1205,1445 1445,1580
So for strings, I can
所以对于弦，我可以把它作为。

881
00:23:56,680 --> 00:23:58,280
0,150 150,300 300,560
have it as.|
|

882
00:23:58,980 --> 00:24:01,690
0,305 305,790 1530,1930 1980,2285 2285,2710
Double quotes and single quotes
在postgres中使用双引号和单引号。

883
00:24:03,060 --> 00:24:04,120
0,245 245,335 335,455 455,590 590,1060
in the case of postgres.|
|

884
00:24:05,490 --> 00:24:06,170
0,245 245,410 410,470 470,560 560,680
It won't let me do
它不允许我使用双引号。

885
00:24:06,170 --> 00:24:07,440
0,165 165,590
double quotes.|
|

886
00:24:08,710 --> 00:24:09,760
0,400
Right.|
正确的。|

887
00:24:09,760 --> 00:24:10,750
0,240 240,330 330,570 570,810 810,990
Can't do that because it's
无法执行此操作，因为它正在尝试查找名为Tupac的列。这是您转义列名的方式，但它将支持。

888
00:24:10,750 --> 00:24:11,290
0,105 105,195 195,315 315,420 420,540
trying to look for a

889
00:24:11,290 --> 00:24:12,430
0,240 240,495 495,840 840,1080 1080,1140
column name tupac. That's the

890
00:24:12,430 --> 00:24:13,825
0,90 90,210 210,315 315,560 1060,1395
way you sort of escape

891
00:24:13,825 --> 00:24:15,550
0,255 255,575 925,1185 1185,1410 1410,1725
column names, but it'll, it'll

892
00:24:15,550 --> 00:24:17,120
0,350
support.|
|

893
00:24:17,810 --> 00:24:19,200
0,320 320,760
Single quotes.|
单引号。|

894
00:24:19,550 --> 00:24:21,535
0,320 320,635 635,995 995,1240 1650,1985
So in sql light, they
因此，在SQL Light中，它们两者都支持。

895
00:24:21,535 --> 00:24:22,920
0,210 210,485
support both.|
|

896
00:24:24,070 --> 00:24:25,005
0,230 230,320 320,440 440,605 605,935
So that can go tupac
这样图帕克就可以像这样了。

897
00:24:25,005 --> 00:24:26,520
0,180 180,455
like this.|
|

898
00:24:26,820 --> 00:24:27,545
0,260 260,365 365,470 470,590 590,725
And I can go with
我可以用这样的单引号。

899
00:24:27,545 --> 00:24:29,860
0,195 195,665 865,1140 1140,1415
single quotes like that.|
|

900
00:24:29,900 --> 00:24:32,360
0,400 1080,1720
In Oracle.|
在甲骨文中。|

901
00:24:34,035 --> 00:24:35,500
0,120 120,315 315,785
It's single quotes.|
这是单引号。|

902
00:24:36,780 --> 00:24:37,895
0,260 260,365 365,545 545,680 680,1115
But it isn't like queries
但它与没有FROM子句的查询不同。

903
00:24:37,895 --> 00:24:39,720
0,285 285,435 435,600 600,935
without a from clause.|
|

904
00:24:40,690 --> 00:24:41,850
0,260 260,365 365,755 755,935 935,1160
So in Oracle they have
在甲骨文里，他们有一个奇怪的东西，叫做DUAL，DUAL表，这是一个假的表。

905
00:24:41,850 --> 00:24:42,930
0,270 270,525 525,750 750,930 930,1080
this weird thing called the

906
00:24:42,930 --> 00:24:44,775
0,410 490,735 735,945 945,1220 1600,1845
dual the dual table, and

907
00:24:44,775 --> 00:24:45,710
0,105 105,210 210,360 360,600 600,935
this is a fake table

908
00:24:45,910 --> 00:24:47,020
0,400
that.|
|

909
00:24:47,020 --> 00:24:48,655
0,270 270,435 435,920 1210,1500 1500,1635
Comes with Oracle allow you
允许您针对实际不存在的表编写此类查询。

910
00:24:48,655 --> 00:24:49,705
0,105 105,365 535,810 810,945 945,1050
to write these kind of

911
00:24:49,705 --> 00:24:51,445
0,455 835,1155 1155,1380 1380,1530 1530,1740
queries against tables that don't

912
00:24:51,445 --> 00:24:52,700
0,210 210,515
actually exist.|
|

913
00:24:52,990 --> 00:24:53,955
0,320 320,485 485,665 665,860 860,965
Right, so then I can
好的，如果你尝试这样做，我可以得到，从DUAL中选择星号。

914
00:24:53,955 --> 00:24:55,635
0,120 120,395 1225,1470 1470,1575 1575,1680
get that if you try

915
00:24:55,635 --> 00:24:56,550
0,90 90,195 195,405 405,675 675,915
to do like, select star

916
00:24:56,550 --> 00:24:58,140
0,320 370,920
from dual.|
|

917
00:25:01,710 --> 00:25:02,615
0,230 230,335 335,470 470,695 695,905
You just get like an
你就会变得像个X。

918
00:25:02,615 --> 00:25:03,720
0,245
X.|
|

919
00:25:04,870 --> 00:25:05,730
0,245 245,350 350,470 470,680 680,860
I think the newer version,
我认为更新的版本，他们摆脱了你不再需要的双重身份。这是，这是甲骨文21，所以它是一个相当新的版本，对吗？就像你不能做的那样。

920
00:25:05,730 --> 00:25:06,330
0,180 180,315 315,435 435,510 510,600
they got rid of the

921
00:25:06,330 --> 00:25:07,065
0,210 210,300 300,420 420,555 555,735
dual you don't need anymore.

922
00:25:07,065 --> 00:25:08,240
0,150 150,345 345,540 540,705 705,1175
This is, this is Oracle

923
00:25:08,470 --> 00:25:09,710
0,515 515,740 740,920 920,995 995,1240
21 so it's a rather

924
00:25:09,730 --> 00:25:13,215
0,350 350,610 960,1360 3120,3365 3365,3485
newer version, right? So like

925
00:25:13,215 --> 00:25:15,020
0,150 150,435 435,695
you can't do.|
|

926
00:25:15,620 --> 00:25:16,435
0,245 245,410 410,500 500,665 665,815
You can't do this, but
您不能这样做，但就像在postgresq或任何其他数据系统中一样，您可以将SQL视为计算器。你可以把任何你想要的东西放在那样的衣服里。

927
00:25:16,435 --> 00:25:17,995
0,105 105,240 240,755 835,1235 1285,1560
like in postgresq or any

928
00:25:17,995 --> 00:25:19,315
0,165 165,345 345,635 955,1200 1200,1320
other data system, you can

929
00:25:19,315 --> 00:25:20,425
0,275 535,855 855,930 930,1020 1020,1110
treat sql as like a

930
00:25:20,425 --> 00:25:22,015
0,455 625,885 885,1140 1140,1440 1440,1590
calculator. You can put whatever

931
00:25:22,015 --> 00:25:22,750
0,90 90,240 240,435 435,600 600,735
you want in clothes like

932
00:25:22,750 --> 00:25:24,000
0,260
that.|
|

933
00:25:24,350 --> 00:25:25,255
0,290 290,455 455,620 725,800 800,905
So, all right, let's go
所以，好了，让我们回到我的SQL。

934
00:25:25,255 --> 00:25:26,820
0,105 105,210 210,345 345,785
back to my sql.|
|

935
00:25:27,530 --> 00:25:28,380
0,260 260,440 440,515 515,605 605,850
And let's look at some
让我们来看看一些字符串函数。

936
00:25:28,460 --> 00:25:29,820
0,275 275,550
string functions.|
|

937
00:25:30,030 --> 00:25:31,080
0,400
So.|
所以。|

938
00:25:32,950 --> 00:25:34,960
0,260 260,410 410,635 635,970
I can call now.|
我现在可以打电话了。|

939
00:25:36,870 --> 00:25:37,880
0,275 275,380 380,590 590,860 860,1010
I can do select star
我可以从学生中选择STAR，其中名称等于Tupac，带有奇怪的大小写，然后它与字符串Tupac匹配。

940
00:25:37,880 --> 00:25:39,200
0,150 150,390 390,645 645,950 970,1320
from student where name equals

941
00:25:39,200 --> 00:25:41,900
0,500 520,920 1300,1620 1620,2120 2410,2700
tupac with weird casing and

942
00:25:41,900 --> 00:25:43,745
0,210 210,450 450,1040 1360,1665 1665,1845
then it matched on the

943
00:25:43,745 --> 00:25:45,580
0,165 165,575
string tupac.|
|

944
00:25:45,590 --> 00:25:47,530
0,335 335,670 780,1325 1325,1565 1565,1940
Right, because internally my sql
是的，因为在内部，我的SQL将VAR图表视为不区分大小写。

945
00:25:47,530 --> 00:25:48,750
0,300 300,630 630,735 735,900 900,1220
is treating the VAR chart

946
00:25:49,070 --> 00:25:50,860
0,305 305,500 500,1210
as case insensitive.|
|

947
00:25:51,510 --> 00:25:52,595
0,335 335,545 545,695 695,905 905,1085
So if you want to
所以如果你现在想的话。

948
00:25:52,595 --> 00:25:54,660
0,245
now.|
|

949
00:25:56,110 --> 00:25:57,735
0,260 260,380 380,515 515,790 1350,1625
If you want to treat
如果您想像对待任何其他数据库系统一样对待它，在这些数据库系统中，它实际上将案例视为真正的Barr，您可以在前面添加这个二进制标志。

950
00:25:57,735 --> 00:25:59,145
0,105 105,270 270,450 450,695 1075,1410
it like, you know, like

951
00:25:59,145 --> 00:26:00,195
0,240 240,435 435,660 660,900 900,1050
any other database system where

952
00:26:00,195 --> 00:26:01,125
0,150 150,300 300,525 525,765 765,930
it actually is actually looking

953
00:26:01,125 --> 00:26:01,965
0,150 150,255 255,465 465,675 675,840
at the case as a

954
00:26:01,965 --> 00:26:03,375
0,165 165,605 895,1140 1140,1245 1245,1410
true barr, you can add

955
00:26:03,375 --> 00:26:04,650
0,195 195,630 630,930 930,1140 1140,1275
this binary flag in front

956
00:26:04,650 --> 00:26:06,000
0,180 180,500
of the.|
|

957
00:26:06,000 --> 00:26:07,230
0,315 315,615 615,840 840,1065 1065,1230
Or keyword in front of
或列名称前面的关键字。这将把它视为一个二进制字符串，就像任何其他系统一样。

958
00:26:07,230 --> 00:26:08,760
0,195 195,405 405,740 970,1230 1230,1530
the column name. And that'll

959
00:26:08,760 --> 00:26:09,800
0,120 120,240 240,420 420,600 600,1040
treat it as a binary

960
00:26:10,600 --> 00:26:11,780
0,290 290,515 515,725 725,890 890,1180
string like any other system.|
|

961
00:26:12,610 --> 00:26:13,470
0,245 245,365 365,530 530,710 710,860
In this case here now
在这种情况下，现在它不匹配，但现在它告诉我有一个警告。

962
00:26:13,470 --> 00:26:14,460
0,105 105,315 315,525 525,750 750,990
it doesn't match, but now

963
00:26:14,460 --> 00:26:15,255
0,345 345,570 570,660 660,720 720,795
it tells me I have

964
00:26:15,255 --> 00:26:16,460
0,105 105,365
a warning.|
|

965
00:26:16,460 --> 00:26:17,000
0,210 210,285 285,405 405,465 465,540
So now I've got to
所以现在我要挂电话了，显示警告，这是我的SQL特有的。所以现在他们告诉我，二进制表达式已被弃用并被删除，他们至少告诉我如何正确编写它。

966
00:26:17,000 --> 00:26:18,430
0,165 165,435 435,720 720,975 975,1430
go now call show warnings,

967
00:26:18,540 --> 00:26:19,970
0,245 245,490 720,1025 1025,1205 1205,1430
and this is my sql

968
00:26:19,970 --> 00:26:21,515
0,260 850,1095 1095,1230 1230,1395 1395,1545
specific. So now they tell

969
00:26:21,515 --> 00:26:24,050
0,150 150,425 835,1235 1825,2295 2295,2535
me that the binary expression

970
00:26:24,050 --> 00:26:25,480
0,195 195,705 705,945 945,1110 1110,1430
is deprecated and be removed,

971
00:26:26,040 --> 00:26:26,855
0,260 260,410 410,590 590,725 725,815
and they tell me at

972
00:26:26,855 --> 00:26:27,965
0,210 210,450 450,720 720,975 975,1110
least how to write it

973
00:26:27,965 --> 00:26:28,920
0,275
correctly.|
|

974
00:26:29,350 --> 00:26:30,540
0,290 290,580 720,965 965,1055 1055,1190
So now I have to
所以现在我必须将名称转换为二进制，然后我就可以调用它了。

975
00:26:30,540 --> 00:26:33,165
0,290 520,920 1510,1875 1875,2240 2380,2625
cast the name as a

976
00:26:33,165 --> 00:26:34,410
0,425 625,900 900,1035 1035,1140 1140,1245
binary and then I can

977
00:26:34,410 --> 00:26:35,340
0,135 135,410
call it.|
|

978
00:26:35,500 --> 00:26:36,285
0,230 230,290 290,425 425,635 635,785
So if I change the
所以如果我再换一次弹壳，我就会得到图帕克。

979
00:26:36,285 --> 00:26:37,875
0,285 285,575 1135,1380 1380,1470 1470,1590
casing again, then I get

980
00:26:37,875 --> 00:26:38,840
0,395
tupac.|
|

981
00:26:39,660 --> 00:26:40,550
0,260 260,425 425,725 725,800 800,890
So this burns a lot
这会让很多人感到痛苦，因为他们，你会想，哦，如果你不知道你的VAR字符不区分大小写，你可以多次存储东西。

982
00:26:40,550 --> 00:26:41,240
0,105 105,270 270,420 420,525 525,690
of people because they up,

983
00:26:41,240 --> 00:26:42,400
0,150 150,270 270,405 405,680 760,1160
you end up like thinking,

984
00:26:42,420 --> 00:26:44,645
0,400 870,1270 1680,1910 1910,2075 2075,2225
oh, if you don't know

985
00:26:44,645 --> 00:26:45,880
0,150 150,285 285,495 495,815 835,1235
that your VAR char is

986
00:26:45,930 --> 00:26:47,765
0,290 290,970 1140,1400 1400,1580 1580,1835
case insensitive, you could store

987
00:26:47,765 --> 00:26:51,300
0,270 270,555 555,905
things multiple times.|
|

988
00:26:51,300 --> 00:26:52,455
0,105 105,350 430,765 765,945 945,1155
You know, thinking that it's
你知道，我以为情况会不同，因为情况不同，但我的SQL说它们是一样的。

989
00:26:52,455 --> 00:26:52,980
0,75 75,120 120,195 195,360 360,525
going to be different because

990
00:26:52,980 --> 00:26:54,225
0,105 105,225 225,360 360,620 940,1245
the case is different, but

991
00:26:54,225 --> 00:26:55,350
0,180 180,375 375,635 685,1020 1020,1125
my sql says they're the

992
00:26:55,350 --> 00:26:56,320
0,260
same.|
|

993
00:26:56,580 --> 00:26:57,560
0,260 260,380 380,515 515,740 740,980
Again, this is only my
同样，这只是我的SQL。我不知道有任何其他数据可以做到这一点，所以这是一个奇怪的数据。

994
00:26:57,560 --> 00:26:58,370
0,240 240,315 315,465 465,600 600,810
sql. I don't know any

995
00:26:58,370 --> 00:26:59,525
0,165 165,440 580,885 885,1035 1035,1155
other data that actually does

996
00:26:59,525 --> 00:27:01,070
0,275 805,1110 1110,1350 1350,1410 1410,1545
this, so that's a weird

997
00:27:01,070 --> 00:27:01,980
0,290
one.|
|

998
00:27:03,020 --> 00:27:05,160
0,1000 1050,1355 1355,1535 1535,1775 1775,2140
Yes' why the name has.|
是的，这就是为什么这个名字有。|

999
00:27:06,750 --> 00:27:07,600
0,700
Capitalized.|
大写的。|

1000
00:27:07,940 --> 00:27:09,020
0,120 120,300 300,620
When you store.|
当你储存的时候。|

1001
00:27:11,240 --> 00:27:12,235
0,320 320,515 515,680 680,845 845,995
The question is, why is
问题是，为什么这个名字要大写？

1002
00:27:12,235 --> 00:27:17,180
0,180 180,485 955,1595
the name capitalized?|
|

1003
00:27:22,280 --> 00:27:24,420
0,335 335,530 530,695 695,1000
So his question is.|
所以他的问题是。|

1004
00:27:25,280 --> 00:27:27,205
0,410 410,590 590,910 990,1370 1370,1925
I'm telling you, so there's
我告诉你，数据是以区分大小写的方式存储的，比较运算符当它实际使用WHERE子句时忽略了大小写。

1005
00:27:27,205 --> 00:27:28,300
0,120 120,435 435,615 615,915 915,1095
the data being stored with

1006
00:27:28,300 --> 00:27:30,480
0,120 120,270 270,830 1360,1760 1780,2180
the case sensitivity, the comparison

1007
00:27:30,770 --> 00:27:32,140
0,350 350,545 545,710 710,1205 1205,1370
operator when it actuallyutes the

1008
00:27:32,140 --> 00:27:34,140
0,195 195,560 910,1200 1200,1635 1635,2000
where clause is ignoring case.|
|

1009
00:27:36,130 --> 00:27:37,135
0,45 45,120 120,330 330,660 660,1005
So it's not calling whatever
所以它不会调用lib c中的字符串比较。

1010
00:27:37,135 --> 00:27:39,010
0,330 330,695 1345,1620 1620,1755 1755,1875
string compare that you have

1011
00:27:39,010 --> 00:27:40,540
0,120 120,330 330,620
in lib c.|
|

1012
00:27:40,550 --> 00:27:42,025
0,350 350,610 750,1100 1100,1310 1310,1475
It's calling either their own
它要么调用自己的版本，要么调用k的版本，并感觉到那个版本。

1013
00:27:42,025 --> 00:27:42,990
0,225 225,405 405,540 540,690 690,965
version of it or the

1014
00:27:43,040 --> 00:27:44,005
0,275 275,410 410,650 650,770 770,965
k and senses that version

1015
00:27:44,005 --> 00:27:44,860
0,165 165,425
of it.|
|

1016
00:27:45,610 --> 00:27:46,635
0,260 260,395 395,530 530,755 755,1025
Because that was some decision
因为这是20世纪90年代某人做出的一些决定，至今仍在延续。

1017
00:27:46,635 --> 00:27:47,460
0,180 180,375 375,600 600,750 750,825
that somebody made in the

1018
00:27:47,460 --> 00:27:49,080
0,150 150,620 850,1140 1140,1335 1335,1620
nineteen nineties that has carried

1019
00:27:49,080 --> 00:27:50,400
0,330 330,680
over today.|
|

1020
00:27:51,090 --> 00:27:53,160
0,400
Yes.|
是。|

1021
00:27:53,170 --> 00:27:53,835
0,260 260,350 350,425 425,530 530,665
Why do they make that
他们为什么要做出这样的决定？

1022
00:27:53,835 --> 00:27:54,880
0,275
decision?|
|

1023
00:27:55,460 --> 00:27:57,940
0,400 1740,2030 2030,2165 2165,2300 2300,2480
Uh, ask me that question
呃，最后再问我那个问题，从头到尾再说一遍。这可能是因为有人只是以一种方式做了，你知道，决定了怎么做。或者我的SQL，这家伙实际上在很多情况下试图效仿Oracle在某些情况下所做的事情。但甲骨文不会这么做。我没有头绪。

1024
00:27:57,940 --> 00:27:59,065
0,120 120,210 210,390 390,710 850,1125
at the very end, get

1025
00:27:59,065 --> 00:28:01,540
0,120 120,225 225,485 1735,2115 2115,2475
through all the again. It's

1026
00:28:01,540 --> 00:28:02,920
0,225 225,540 540,920 940,1230 1230,1380
probably because somebody just did

1027
00:28:02,920 --> 00:28:03,700
0,120 120,225 225,360 360,585 585,780
it the one way, you

1028
00:28:03,700 --> 00:28:04,840
0,260 550,825 825,945 945,1035 1035,1140
know, decided how to do

1029
00:28:04,840 --> 00:28:07,105
0,260 640,1040 1480,1770 1770,2130 2130,2265
it. Or my sql, the

1030
00:28:07,105 --> 00:28:08,170
0,165 165,485 565,795 795,900 900,1065
guy was actually in many

1031
00:28:08,170 --> 00:28:09,390
0,225 225,405 405,525 525,800 820,1220
cases trying to follow what

1032
00:28:09,440 --> 00:28:10,470
0,440 440,545 545,635 635,755 755,1030
Oracle did in some cases.

1033
00:28:10,670 --> 00:28:11,730
0,245 245,455 455,680 680,800 800,1060
But Oracle doesn't do this.

1034
00:28:12,140 --> 00:28:13,400
0,260 260,380 380,515 515,790
I have no idea.|
|

1035
00:28:14,070 --> 00:28:15,185
0,395 395,650 650,815 815,995 995,1115
Right, we can email the
对，我们可以给他还活着的人发邮件。

1036
00:28:15,185 --> 00:28:21,100
0,245 1255,1530 1530,1665 1665,1955
guy he still alive.|
|

1037
00:28:21,140 --> 00:28:22,330
0,275 275,470 470,635 635,875 875,1190
So yeah, I think there's
所以，是的，我认为很多时候，人们只是做一些事情，因为，就像一个人做了事情，没有真正考虑它的含义，或者他们试图复制其他系统，他们喜欢其他一些特定的功能。

1038
00:28:22,330 --> 00:28:23,250
0,75 75,210 210,360 360,570 570,920
a lot of times where

1039
00:28:24,080 --> 00:28:25,285
0,305 305,500 500,725 725,980 980,1205
people just did stuff because,

1040
00:28:25,285 --> 00:28:26,185
0,255 255,480 480,660 660,810 810,900
like one person did it

1041
00:28:26,185 --> 00:28:27,325
0,150 150,345 345,615 615,885 885,1140
without really thinking through the,

1042
00:28:27,325 --> 00:28:30,100
0,240 240,630 630,795 795,1055 2455,2775
the implications of it, or

1043
00:28:30,100 --> 00:28:31,015
0,225 225,330 330,450 450,690 690,915
they're trying to copy some

1044
00:28:31,015 --> 00:28:31,705
0,150 150,345 345,480 480,570 570,690
other system where they like

1045
00:28:31,705 --> 00:28:33,775
0,165 165,285 285,515 1555,1875 1875,2070
out some other particular feature

1046
00:28:33,775 --> 00:28:34,940
0,120 120,725
of functionality.|
|

1047
00:28:39,330 --> 00:28:40,660
0,260 260,520
Other questions?|
还有其他问题吗？|

1048
00:28:42,340 --> 00:28:43,530
0,320 320,425 425,650 650,920 920,1190
Let's see, many examples are
让我们看看，很多例子是为什么有人会这样做？这样做吧。

1049
00:28:43,530 --> 00:28:44,670
0,240 240,530 610,855 855,990 990,1140
why would anyone ever do

1050
00:28:44,670 --> 00:28:46,160
0,260 760,1005 1005,1095 1095,1215 1215,1490
this? Do it this way.|
|

1051
00:28:47,400 --> 00:28:48,255
0,195 195,390 390,600 600,735 735,855
All right, so I think
好的，我想我之前展示了一个类似这样的问题。只是要确保你能看到它。在SQL中有这样的LIKE操作，您可以使用它来进行基本字符串匹配或和模式匹配。

1052
00:28:48,255 --> 00:28:49,020
0,120 120,240 240,330 330,555 555,765
I showed a query like

1053
00:28:49,020 --> 00:28:49,935
0,120 120,380 400,675 675,810 810,915
this before. Just make sure

1054
00:28:49,935 --> 00:28:50,940
0,120 120,240 240,485 565,825 825,1005
you see it. So there's

1055
00:28:50,940 --> 00:28:53,760
0,150 150,470 1750,2145 2145,2535 2535,2820
this like operation in in

1056
00:28:53,760 --> 00:28:55,020
0,440 520,780 780,915 915,1065 1065,1260
sql and you use this

1057
00:28:55,020 --> 00:28:57,315
0,320 610,1010 1030,1640 1750,2025 2025,2295
for really primitive string matching

1058
00:28:57,315 --> 00:28:58,620
0,60 60,135 135,300 300,785
or and pattern matching.|
|

1059
00:28:58,750 --> 00:29:00,020
0,335 335,500 500,590 590,850 870,1270
So you would use a
所以你会用一个你喜欢的电话，然后你会说，嗯。

1060
00:29:00,070 --> 00:29:01,050
0,275 275,455 455,710 710,905 905,980
you call like and then

1061
00:29:01,050 --> 00:29:02,900
0,60 60,180 180,470 550,950
you would say, um.|
|

1062
00:29:02,900 --> 00:29:04,360
0,60 60,135 135,240 240,500 1060,1460
You would have a percent
您将有一个百分号来表示通配符，因此，如果您来自Unix世界之星，则正则表达式通常意味着匹配任何内容或点。

1063
00:29:04,380 --> 00:29:05,390
0,320 320,470 470,620 620,800 800,1010
sign to represent a wild

1064
00:29:05,390 --> 00:29:06,335
0,300 300,525 525,705 705,840 840,945
card, so instead, if you're

1065
00:29:06,335 --> 00:29:07,720
0,90 90,365 595,855 855,1095 1095,1385
coming from the unix world

1066
00:29:07,740 --> 00:29:09,670
0,400 750,1100 1100,1355 1355,1595 1595,1930
star, regular expression usually means

1067
00:29:10,230 --> 00:29:12,340
0,380 380,755 755,1025 1025,1300
match anything or dot.|
|

1068
00:29:12,410 --> 00:29:14,500
0,305 305,650 650,1235 1235,1510 1740,2090
In sql, it's the percent
在SQL中，它是百分号，可以匹配任何子字符串，包括空字符串。但是如果你想匹配一个字符，你可以使用下划线。

1069
00:29:14,500 --> 00:29:15,960
0,350 580,840 840,1050 1050,1170 1170,1460
sign, and that'll match it

1070
00:29:16,220 --> 00:29:18,430
0,320 320,560 560,880 1680,1970 1970,2210
any sub string, including empty

1071
00:29:18,430 --> 00:29:19,570
0,380 550,780 780,855 855,1005 1005,1140
strings. But if you want

1072
00:29:19,570 --> 00:29:20,920
0,75 75,240 240,450 450,740 1090,1350
to match one character, you

1073
00:29:20,920 --> 00:29:22,700
0,105 105,350 550,795 795,1340
would use the underscore.|
|

1074
00:29:22,740 --> 00:29:24,035
0,260 260,380 380,640 870,1160 1160,1295
And there is support for
而且还支持正则表达式。我忘记了这是否在SQL标准中，但每个人的做法略有不同。你可以编写更复杂的字符串匹配，字符串匹配模式。

1075
00:29:24,035 --> 00:29:25,415
0,240 240,735 735,1020 1020,1260 1260,1380
regular expressions. I forget whether

1076
00:29:25,415 --> 00:29:27,080
0,245 925,1200 1200,1320 1320,1410 1410,1665
that is in the sql

1077
00:29:27,080 --> 00:29:28,180
0,240 240,495 495,675 675,825 825,1100
standard, but everyone does it

1078
00:29:28,230 --> 00:29:30,680
0,320 320,640 1590,1865 1865,2135 2135,2450
slightly different. You can write

1079
00:29:30,680 --> 00:29:33,680
0,320 370,770 1240,1500 1500,1940 2740,3000
more complex string matching, string

1080
00:29:33,680 --> 00:29:34,900
0,270 270,530
matching patterns.|
|

1081
00:29:36,040 --> 00:29:36,720
0,275 275,305 305,380 380,515 515,680
There's a bunch of string
在SQL标准中也有许多字符串函数，它们可以做您所期望的事情。如果您熟悉python，那么所有的python函数、大写字母、小写的子字符串、替换字符串，所有这些都在SQL标准中，而且在很大程度上这些都将在中保持一致。

1082
00:29:36,720 --> 00:29:37,560
0,240 240,495 495,660 660,765 765,840
functions that also come in

1083
00:29:37,560 --> 00:29:38,780
0,75 75,285 285,560 730,975 975,1220
the sql standard to do

1084
00:29:38,830 --> 00:29:40,035
0,305 305,440 440,605 605,940 960,1205
things you could expect. If

1085
00:29:40,035 --> 00:29:41,085
0,150 150,270 270,420 420,765 765,1050
you're familiar with python, there's

1086
00:29:41,085 --> 00:29:43,635
0,165 165,285 285,540 540,815 2185,2550
all the python functions, uppererc

1087
00:29:43,635 --> 00:29:45,200
0,150 150,390 390,725 895,1215 1215,1565
case, lower case sub strings,

1088
00:29:45,550 --> 00:29:47,535
0,455 455,790 1290,1610 1610,1805 1805,1985
replacing strings, all that, all

1089
00:29:47,535 --> 00:29:48,410
0,225 225,300 300,390 390,615 615,875
that's in the sql standard

1090
00:29:48,760 --> 00:29:49,935
0,290 290,425 425,560 560,830 830,1175
and for the most part

1091
00:29:49,935 --> 00:29:50,850
0,255 255,495 495,690 690,765 765,915
these are going to be

1092
00:29:50,850 --> 00:29:52,960
0,315 315,710 760,1110 1110,1460
pretty consistent across the.|
|

1093
00:29:53,480 --> 00:29:55,340
0,245 245,410 410,730
The various systems.|
各种系统。|

1094
00:29:55,750 --> 00:29:57,890
0,275 275,470 470,790 1380,1760 1760,2140
Where things go wrong is
出错的地方是我们认为连接两个字符串的最简单的操作。这就是每个人都喜欢做一些略有不同的事情的地方。

1095
00:29:57,940 --> 00:29:58,710
0,290 290,440 440,560 560,680 680,770
which we think would be

1096
00:29:58,710 --> 00:30:00,210
0,60 60,195 195,495 495,885 885,1500
the most simple operation concatenating

1097
00:30:00,210 --> 00:30:01,875
0,210 210,530 910,1290 1290,1455 1455,1665
two strings. That's where everyone

1098
00:30:01,875 --> 00:30:02,775
0,150 150,255 255,360 360,615 615,900
likes to do something slightly

1099
00:30:02,775 --> 00:30:03,880
0,305
different.|
|

1100
00:30:03,880 --> 00:30:05,080
0,210 210,330 330,630 630,885 885,1200
So the sl standard says
所以sl标准说，双杠是在sl服务器中捕获字符串的方式。他们用加号。

1101
00:30:05,080 --> 00:30:08,110
0,350 1750,2010 2010,2175 2175,2480 2770,3030
the the double bar is

1102
00:30:08,110 --> 00:30:08,755
0,90 90,180 180,300 300,435 435,645
the way you can catch

1103
00:30:08,755 --> 00:30:12,390
0,365 1885,2285 2635,3015 3015,3375 3375,3635
strings in in sl server.

1104
00:30:12,410 --> 00:30:14,035
0,400 930,1190 1190,1325 1325,1460 1460,1625
They they use the plus

1105
00:30:14,035 --> 00:30:15,000
0,305
sign.|
|

1106
00:30:15,790 --> 00:30:16,845
0,260 260,365 365,455 455,605 605,1055
And then in my sql,
在我的SQL中，他们在默认模式下没有，他们没有双杠，他们不支持加号。您必须使用CONCAT函数。

1107
00:30:16,845 --> 00:30:20,390
0,365 865,1290 1290,1565 2605,3005 3145,3545
they don't have under the

1108
00:30:20,590 --> 00:30:21,585
0,275 275,470 470,650 650,875 875,995
default mode, they don't have

1109
00:30:21,585 --> 00:30:22,890
0,135 135,315 315,635 895,1140 1140,1305
the double bar, they don't

1110
00:30:22,890 --> 00:30:23,985
0,120 120,240 240,390 390,680 850,1095
support the plus sign. You

1111
00:30:23,985 --> 00:30:25,770
0,105 105,225 225,450 450,815 1345,1785
have to use the concat

1112
00:30:25,770 --> 00:30:26,620
0,290
function.|
|

1113
00:30:27,770 --> 00:30:28,645
0,395 395,635 635,710 710,785 785,875
Right. And we can see
正确的。我们很快就能看到这一点。

1114
00:30:28,645 --> 00:30:29,980
0,105 105,225 225,485
that real quickly.|
|

1115
00:30:30,430 --> 00:30:31,720
0,400
So.|
所以。|

1116
00:30:31,730 --> 00:30:32,790
0,275 275,410 410,500 500,620 620,1060
Going back to my sql.|
回到我的SQL。|

1117
00:30:38,070 --> 00:30:40,060
0,400
So.|
所以。|

1118
00:30:42,220 --> 00:30:42,825
0,245 245,305 305,380 380,485 485,605
Want to do something like
想要做这样的事情，对吗？

1119
00:30:42,825 --> 00:30:44,220
0,275 295,695
this, right?|
|

1120
00:30:44,780 --> 00:30:45,985
0,245 245,350 350,515 515,820 930,1205
I get another warning. I
我又得到了一个警告。我也有同样的警告。

1121
00:30:45,985 --> 00:30:47,580
0,150 150,575
share warnings.|
|

1122
00:30:50,750 --> 00:30:51,625
0,215 215,290 290,440 440,680 680,875
And it tells me it
它告诉我它不喜欢我的语法，对吗？

1123
00:30:51,625 --> 00:30:52,800
0,165 165,255 255,375 375,755 775,1175
doesn't like my syntax right?|
|

1124
00:30:54,960 --> 00:30:56,200
0,400 480,725 725,815 815,950 950,1240
That was the first warning
这是第一次警告性的繁荣。

1125
00:30:56,940 --> 00:30:58,140
0,400
boom.|
|

1126
00:30:58,140 --> 00:30:59,700
0,225 225,360 360,525 525,920 1180,1560
I get two warnings, says
我收到了两个警告，说双划线是or的同义词，因此它将被弃用。

1127
00:30:59,700 --> 00:31:01,650
0,375 375,735 735,1050 1050,1400 1420,1950
the double bar is synonym

1128
00:31:01,650 --> 00:31:03,000
0,225 225,360 360,620 910,1215 1215,1350
for the or, and therefore

1129
00:31:03,000 --> 00:31:05,580
0,255 255,465 465,555 555,1040
it's to be deprecated.|
|

1130
00:31:05,580 --> 00:31:06,300
0,105 105,210 330,435 435,570 570,720
And they didn't like the
他们不喜欢我的方式。

1131
00:31:06,300 --> 00:31:08,560
0,210 210,560
way I.|
|

1132
00:31:08,980 --> 00:31:11,010
0,400 690,1010 1010,1330 1620,1865 1865,2030
Was sending along the at
正在发送CS中的at符号，所以我们现在尝试呼叫。我们在我的SQL中更改了SQL模式。

1133
00:31:11,010 --> 00:31:13,590
0,210 210,420 420,830 1360,1760 2320,2580
sign in CS, so we

1134
00:31:13,590 --> 00:31:14,775
0,210 210,420 420,555 555,830 910,1185
now try to call. We

1135
00:31:14,775 --> 00:31:16,335
0,210 210,420 420,705 705,965 1315,1560
change the sql mode in

1136
00:31:16,335 --> 00:31:17,580
0,135 135,545
my sql.|
|

1137
00:31:17,580 --> 00:31:19,460
0,255 255,435 435,740 1240,1620 1620,1880
To follow the sql standard,
为了遵循SQL标准，现在我可以，我可以得到我想要的串联。

1138
00:31:19,780 --> 00:31:21,510
0,365 365,605 605,880 1350,1610 1610,1730
now I can, I can

1139
00:31:21,510 --> 00:31:22,710
0,260 310,555 555,975 975,1110 1110,1200
get the concatenation that I

1140
00:31:22,710 --> 00:31:23,460
0,260
want.|
|

1141
00:31:23,690 --> 00:31:24,880
0,400
EM.|
嗯。|

1142
00:31:26,110 --> 00:31:28,035
0,245 245,455 455,940 1020,1690 1710,1925
So again, it's concatenation. It
所以再说一次，它是串联的。那就太棒了。每个人都应该做同样的事情。但又一次，在MySQL的情况下，是90个S遗留下来的东西，他们正试图慢慢撤销。

1143
00:31:28,035 --> 00:31:30,525
0,75 75,315 315,695 2125,2385 2385,2490
would be super. Everyone should

1144
00:31:30,525 --> 00:31:31,275
0,90 90,180 180,315 315,540 540,750
do the same thing. But

1145
00:31:31,275 --> 00:31:33,405
0,275 1375,1620 1620,1710 1710,1800 1800,2130
again, in case of mysql

1146
00:31:33,405 --> 00:31:34,605
0,90 90,365 445,840 840,1095 1095,1200
is some legacy thing from

1147
00:31:34,605 --> 00:31:35,745
0,90 90,210 210,375 375,665 835,1140
the ninety s that they're

1148
00:31:35,745 --> 00:31:37,240
0,105 105,270 270,495 495,965
trying to slowly undo.|
|

1149
00:31:39,150 --> 00:31:40,240
0,230 230,460
All right.|
好的。|

1150
00:31:40,540 --> 00:31:41,870
0,275 275,410 410,670 720,1025 1025,1330
Date and time is probably
日期和时间可能是最糟糕的。

1151
00:31:42,190 --> 00:31:43,660
0,260 260,425 425,730
the worst one.|
|

1152
00:31:43,660 --> 00:31:45,400
0,350 730,1005 1005,1290 1290,1440 1440,1740
So the so standard defines
因此，SO标准定义了一系列定义日期类型、时间类型的方法。还有时间戳。

1153
00:31:45,400 --> 00:31:46,225
0,150 150,240 240,345 345,555 555,825
a bunch of ways to

1154
00:31:46,225 --> 00:31:49,350
0,305 1435,1755 1755,2075 2455,2790 2790,3125
define date types, time types.

1155
00:31:50,180 --> 00:31:52,600
0,275 275,550 1230,1840
Also time stamps.|
|

1156
00:31:52,600 --> 00:31:54,655
0,290 610,945 945,1275 1275,1635 1635,2055
EM, different calendar types, Julian
EM，不同的日历类型，儒略历。但是，语法又将如何变化，这将是相当恼人的。

1157
00:31:54,655 --> 00:31:57,250
0,915 915,1175 1795,2085 2085,2325 2325,2595
calendarian calendar. But how, again,

1158
00:31:57,250 --> 00:31:59,395
0,320 1240,1515 1515,1860 1860,2025 2025,2145
how the syntax is going

1159
00:31:59,395 --> 00:32:00,460
0,105 105,365 625,900 900,1005 1005,1065
to vary is going to

1160
00:32:00,460 --> 00:32:02,220
0,230 460,765 765,1220
be pretty annoying.|
|

1161
00:32:02,220 --> 00:32:02,685
0,165 165,225 225,300 300,375 375,465
So I want to give
所以我现在想给它一个演示，试着做一个看起来很简单的计算，一个简单的计算。我们只想数一数天数。

1162
00:32:02,685 --> 00:32:03,710
0,90 90,195 195,315 315,575 625,1025
it now a demo where

1163
00:32:04,450 --> 00:32:05,760
0,245 245,320 320,395 395,640 990,1310
try to do what would

1164
00:32:05,760 --> 00:32:07,650
0,210 210,345 345,450 450,710 1360,1890
seem like a simple calculation,

1165
00:32:07,650 --> 00:32:09,240
0,150 150,315 315,830 1240,1485 1485,1590
a simple computation. We just

1166
00:32:09,240 --> 00:32:10,100
0,90 90,195 195,390 390,585 585,860
want to count the number

1167
00:32:10,120 --> 00:32:11,480
0,400
days.|
|

1168
00:32:11,550 --> 00:32:13,355
0,400 630,950 950,1270 1440,1685 1685,1805
Since from today to the
从今天起到年初。

1169
00:32:13,355 --> 00:32:14,560
0,165 165,300 300,405 405,665
beginning of the year.|
|

1170
00:32:14,740 --> 00:32:16,830
0,290 290,425 425,1490 1490,1715 1715,2090
It's like 230 something 240
好像是230多岁，240多岁。只是天数，日历上的总天数。

1171
00:32:16,830 --> 00:32:18,240
0,290 430,690 690,810 810,1065 1065,1410
something. Just the number, the

1172
00:32:18,240 --> 00:32:19,610
0,255 255,480 480,720 720,1005 1005,1370
total number of calendar days.|
|

1173
00:32:20,390 --> 00:32:20,950
0,230 230,365 365,395 395,455 455,560
So we're going to do
因此，我们将首先在postgres中执行此操作，然后在我的SQL中执行此操作，然后在SQL服务器中执行此操作。

1174
00:32:20,950 --> 00:32:22,885
0,165 165,450 450,765 765,1310 1690,1935
this first in postgres and

1175
00:32:22,885 --> 00:32:23,760
0,90 90,225 225,330 330,540 540,875
then we'll do this in,

1176
00:32:24,590 --> 00:32:26,365
0,400 660,950 950,1390 1410,1655 1655,1775
in my sql and do

1177
00:32:26,365 --> 00:32:27,630
0,180 180,435 435,705 705,990 990,1265
this in, in sql server.|
|

1178
00:32:28,420 --> 00:32:29,130
0,245 245,350 350,485 485,620 620,710
So the first thing we
因此，我们需要做的第一件事是弄清楚如何获得电流。

1179
00:32:29,130 --> 00:32:29,685
0,75 75,180 180,300 300,420 420,555
need to do is figure

1180
00:32:29,685 --> 00:32:30,420
0,120 120,225 225,345 345,525 525,735
out how to get the

1181
00:32:30,420 --> 00:32:31,360
0,290
current.|
|

1182
00:32:31,360 --> 00:32:33,760
0,380 670,930 930,1190 1300,1700
Date the current time.|
指定当前时间的日期。|

1183
00:32:33,760 --> 00:32:37,390
0,320 910,1290 1290,1790 2110,2510 3040,3630
Right. Well, there in postgres
正确的。在postgres中有一个名为now的函数。

1184
00:32:37,390 --> 00:32:38,520
0,300 300,390 390,600 600,840 840,1130
there's a function called now.|
|

1185
00:32:39,260 --> 00:32:40,090
0,195 195,300 300,420 420,555 555,830
And that will give you.|
这会给你带来。|

1186
00:32:42,410 --> 00:32:43,165
0,245 245,350 350,470 470,590 590,755
You get back a time
你会得到一个时间戳。

1187
00:32:43,165 --> 00:32:44,100
0,305
stamp.|
|

1188
00:32:44,100 --> 00:32:45,320
0,105 105,195 195,315 315,590
With the current date.|
当前日期。|

1189
00:32:45,410 --> 00:32:47,040
0,400
In.|
在……里面。|

1190
00:32:49,530 --> 00:32:50,540
0,335 335,560 560,815 815,935 935,1010
In my sql, you can
在我的SQL中，您可以做同样的事情。

1191
00:32:50,540 --> 00:32:51,920
0,75 75,165 165,300 300,590
do the same thing.|
|

1192
00:32:51,920 --> 00:32:53,460
0,240 240,540 540,800
In sql lite.|
在SQL Lite中。|

1193
00:32:54,890 --> 00:32:55,585
0,245 245,395 395,455 455,545 545,695
They don't have A N
他们没有A-N功能。

1194
00:32:55,585 --> 00:32:56,720
0,305
function.|
|

1195
00:32:56,840 --> 00:32:58,660
0,380 380,880 1290,1655 1655,1745 1745,1820
In DB DB is going
在DB中，DB在很多方面几乎都会遵循Postgres，因为它们使用相同的SQL语法。

1196
00:32:58,660 --> 00:33:00,240
0,105 105,330 330,540 540,800 970,1580
to follow pretty much postgres

1197
00:33:00,380 --> 00:33:01,015
0,230 230,290 290,380 380,485 485,635
for a lot of things

1198
00:33:01,015 --> 00:33:01,960
0,165 165,480 480,690 690,810 810,945
because it's they use the

1199
00:33:01,960 --> 00:33:04,860
0,260 1090,1490 1570,1935 1935,2360
same same sql grammar.|
|

1200
00:33:04,900 --> 00:33:05,550
0,245 245,335 335,410 410,485 485,650
So they have a noun
所以它们有名词功能。

1201
00:33:05,550 --> 00:33:06,620
0,290
function.|
|

1202
00:33:07,000 --> 00:33:08,740
0,275 275,395 395,485 485,970
I go to Oracle.|
我去找先知。|

1203
00:33:09,970 --> 00:33:10,905
0,335 335,545 545,710 710,845 845,935
Or does not have A
或者没有A-N功能。

1204
00:33:10,905 --> 00:33:11,960
0,120 120,395
N function.|
|

1205
00:33:12,200 --> 00:33:13,180
0,230 230,380 380,605 605,830 830,980
All right, so there's another
好的，还有另一种方法可以得到时间戳。因此，在SQL标准中，有一个称为当前时间戳的函数。

1206
00:33:13,180 --> 00:33:13,915
0,120 120,195 195,285 285,510 510,735
way you can get the

1207
00:33:13,915 --> 00:33:14,845
0,150 150,435 435,675 675,795 795,930
time stamp. So in the

1208
00:33:14,845 --> 00:33:16,650
0,255 255,545 895,1320 1320,1485 1485,1805
sql standard, there's something called

1209
00:33:17,840 --> 00:33:18,895
0,245 245,410 410,635 635,845 845,1055
a function called current time

1210
00:33:18,895 --> 00:33:19,720
0,305
stamp.|
|

1211
00:33:20,660 --> 00:33:21,910
0,400 660,905 905,1055 1055,1145 1145,1250
Right, except it's not a
对，只是它不是一个函数。

1212
00:33:21,910 --> 00:33:23,220
0,260
function.|
|

1213
00:33:23,385 --> 00:33:24,900
0,60 60,150 150,545
It's a keyword.|
这是个关键词。|

1214
00:33:25,620 --> 00:33:27,130
0,260 260,485 485,830 830,1085 1085,1510
And then in my sql,
然后在我的SQL中，它们有函数，它们有关键字。

1215
00:33:27,930 --> 00:33:30,185
0,260 260,365 365,470 470,730 2010,2255
they have the function, they

1216
00:33:30,185 --> 00:33:32,300
0,105 105,225 225,605
have the keyword.|
|

1217
00:33:32,300 --> 00:33:33,960
0,225 225,770
In sqlite.|
在SQLITE中。|

1218
00:33:35,400 --> 00:33:35,930
0,60 60,120 120,195 195,285 285,530
They don't have the function.|
他们没有这个功能。|

1219
00:33:38,210 --> 00:33:39,840
0,245 245,350 350,455 455,850
They have the keyword.|
他们有关键字。|

1220
00:33:39,840 --> 00:33:41,520
0,210 210,390 390,890
And an Oracle.|
和一位先知。|

1221
00:33:42,770 --> 00:33:43,880
0,520
Doesn't.|
不会的。|

1222
00:33:43,880 --> 00:33:44,800
0,240 240,345 345,450 450,615 615,920
Gives us a weird error
给了我们一个奇怪的错误，我们一会儿回来，他们没有关键字，所以他们有这个函数，但我们得到了另一个奇怪的错误日期，时间间隔，精度，超出范围。

1223
00:33:45,180 --> 00:33:45,890
0,275 275,440 440,545 545,650 650,710
about that one, we'll come

1224
00:33:45,890 --> 00:33:46,250
0,90 90,180 180,240 240,285 285,360
back to that in a

1225
00:33:46,250 --> 00:33:48,290
0,260 760,1160 1660,1875 1875,1995 1995,2040
second and they don't have

1226
00:33:48,290 --> 00:33:48,875
0,75 75,315 315,420 420,495 495,585
the keyword, so they have

1227
00:33:48,875 --> 00:33:49,870
0,120 120,390 390,645 645,780 780,995
the function, but we're getting

1228
00:33:49,890 --> 00:33:51,425
0,260 260,425 425,620 620,910 1200,1535
this other weird error date,

1229
00:33:51,425 --> 00:33:53,285
0,255 255,690 690,1145 1495,1755 1755,1860
time interval, precision, out of

1230
00:33:53,285 --> 00:33:54,180
0,245
range.|
|

1231
00:33:54,250 --> 00:33:56,895
0,305 305,440 440,590 590,820 2400,2645
OK, so what's that? So
好的，那是什么？所以现在我们可能得回去了。

1232
00:33:56,895 --> 00:33:57,360
0,90 90,180 180,255 255,330 330,465
now we got to go

1233
00:33:57,360 --> 00:33:59,460
0,290 730,1130
back, maybe.|
|

1234
00:33:59,470 --> 00:34:00,945
0,305 305,575 575,905 905,1175 1175,1475
Oh, because it's, it's, it's
哦，因为它是，它是，它是先知。它不喜欢没有SELECT语句的SELECT子句，也就是FROM子句。所以让我们添加我们的假桌子DUAL，然后我们就正确了，但它是关键字。

1235
00:34:00,945 --> 00:34:02,510
0,455 625,885 885,1125 1125,1275 1275,1565
Oracle. It doesn't like having

1236
00:34:02,530 --> 00:34:03,710
0,305 305,485 485,680 680,875 875,1180
a select clause without a

1237
00:34:03,940 --> 00:34:05,150
0,305 305,560 560,755 755,890 890,1210
select statement, a from clause.

1238
00:34:05,530 --> 00:34:06,315
0,230 230,380 380,470 470,605 605,785
So let's add our fake

1239
00:34:06,315 --> 00:34:09,165
0,305 325,875 2365,2625 2625,2730 2730,2850
table dual, then we get

1240
00:34:09,165 --> 00:34:10,740
0,275 595,995 1105,1335 1380,1455 1455,1575
it right, but it's the

1241
00:34:10,740 --> 00:34:12,040
0,440
keyword.|
|

1242
00:34:12,550 --> 00:34:13,460
0,230 230,335 335,455 455,605 605,910
And not the time stamp,
而不是时间戳，对吗？

1243
00:34:13,780 --> 00:34:14,960
0,400
right?|
|

1244
00:34:15,030 --> 00:34:16,235
0,230 230,365 365,530 530,790 960,1205
All right, so now, so
好了，现在，至少现在我们可以得到当天的当前时间了。

1245
00:34:16,235 --> 00:34:16,895
0,90 90,240 240,435 435,570 570,660
at least now we can

1246
00:34:16,895 --> 00:34:19,475
0,120 120,395 685,1020 1020,1355 2305,2580
get the current time of

1247
00:34:19,475 --> 00:34:21,560
0,120 120,270 270,575
the current day.|
|

1248
00:34:21,560 --> 00:34:22,130
0,120 120,255 255,390 390,480 480,570
And so what we can
现在我们可以做的就是开始将字符串或变量转换为日期类型。然后在SQL标准中有这个提取函数，它允许我们提取数据时间戳的一部分。这就是说，先提取日期，然后将今天的日期作为字符串转换为日期类型。

1249
00:34:22,130 --> 00:34:23,465
0,120 120,240 240,495 495,950 1090,1335
do is now there we

1250
00:34:23,465 --> 00:34:25,625
0,135 135,420 420,1085 1465,1890 1890,2160
can start casting strings or

1251
00:34:25,625 --> 00:34:27,740
0,420 420,785 805,1110 1110,1415 1825,2115
varrs into date types. And

1252
00:34:27,740 --> 00:34:28,880
0,165 165,360 360,585 585,900 900,1140
then there's this extract function

1253
00:34:28,880 --> 00:34:29,720
0,150 150,240 240,495 495,675 675,840
in the sql standard that

1254
00:34:29,720 --> 00:34:31,100
0,180 180,375 375,570 570,890 1060,1380
allows us to extract some

1255
00:34:31,100 --> 00:34:32,630
0,270 270,600 600,870 870,1160 1210,1530
part of of that data

1256
00:34:32,630 --> 00:34:33,740
0,225 225,530 670,900 900,990 990,1110
time stamp. So this is

1257
00:34:33,740 --> 00:34:36,245
0,225 225,555 555,920 1960,2235 2235,2505
saying extract the and then

1258
00:34:36,245 --> 00:34:38,090
0,465 465,725 1135,1410 1410,1590 1590,1845
today's date as a string

1259
00:34:38,090 --> 00:34:40,960
0,465 465,740 2140,2400 2400,2565 2565,2870
casted into a date type.|
|

1260
00:34:41,570 --> 00:34:43,460
0,260 260,520 570,845 845,1120
All right. And again.|
好的。再来一次。|

1261
00:34:43,530 --> 00:34:45,050
0,485 485,1025 1025,1265 1265,1430 1430,1520
There's syntactic sugar for all
对于所有这些非标准的不同系统，都有句法上的甜头。所以在postgresl中，如果我试图给出字符串，它会抛出一个错误，因为它说它不能，我需要操作函数。你需要在日期上操作，但你给了我一个VAR字符，但我可以把这两个冒号加在最后，然后把日期放在最后。

1262
00:34:45,050 --> 00:34:46,115
0,120 120,330 330,645 645,915 915,1065
these different systems that that

1263
00:34:46,115 --> 00:34:47,660
0,90 90,210 210,450 450,815 1195,1545
are like non standard. So

1264
00:34:47,660 --> 00:34:49,535
0,350 370,1040 1300,1560 1560,1710 1710,1875
in postgresl if I try

1265
00:34:49,535 --> 00:34:50,720
0,180 180,360 360,540 540,845 865,1185
to give the string, it's

1266
00:34:50,720 --> 00:34:51,245
0,60 60,150 150,270 270,360 360,525
going to throw an error

1267
00:34:51,245 --> 00:34:52,175
0,180 180,285 285,405 405,540 540,930
because it says it can't.

1268
00:34:52,175 --> 00:34:53,630
0,210 210,315 315,495 495,815 1195,1455
I need to operate function.

1269
00:34:53,630 --> 00:34:54,260
0,90 90,180 180,330 330,495 495,630
You need to operate on

1270
00:34:54,260 --> 00:34:54,935
0,105 105,270 270,420 420,555 555,675
a date but you're giving

1271
00:34:54,935 --> 00:34:56,435
0,210 210,375 375,540 540,845 1255,1500
me a VAR char, but

1272
00:34:56,435 --> 00:34:57,245
0,90 90,180 180,315 315,540 540,810
I can add these the

1273
00:34:57,245 --> 00:34:58,270
0,240 240,540 540,660 660,780 780,1025
two colons at the end

1274
00:34:58,740 --> 00:34:59,660
0,245 245,380 380,575 575,770 770,920
and then put date at

1275
00:34:59,660 --> 00:35:00,600
0,105 105,350
the end.|
|

1276
00:35:00,600 --> 00:35:01,335
0,150 150,270 270,480 480,555 555,735
And then that's going to
然后，这将把它转换为日期类型。

1277
00:35:01,335 --> 00:35:04,170
0,255 255,465 465,755 1195,1595 2545,2835
cast it to a date

1278
00:35:04,170 --> 00:35:05,320
0,290
type.|
|

1279
00:35:05,320 --> 00:35:05,815
0,120 120,210 210,300 300,390 390,495
Can you see that or
你能看到这一点吗？抱歉的。

1280
00:35:05,815 --> 00:35:06,880
0,150 150,455
no? Sorry.|
|

1281
00:35:07,250 --> 00:35:08,400
0,400
Yeah.|
嗯。|

1282
00:35:10,810 --> 00:35:12,140
0,395 395,790
Shoot, sir.|
开枪吧，先生。|

1283
00:35:14,060 --> 00:35:15,840
0,180 180,300 300,560 910,1310
You do this, yeah.|
你要这么做，是的。|

1284
00:35:18,090 --> 00:35:18,890
0,245 245,305 305,410 410,530 530,800
I know it's wrong, sorry.
我知道这是不对的，对不起。让我们再试一次。

1285
00:35:18,890 --> 00:35:20,160
0,270 270,330 330,405 405,650
Let's try it again.|
|

1286
00:35:22,690 --> 00:35:24,340
0,260 260,470 470,740 740,1060
All right, so here.|
好了，这就是了。|

1287
00:35:25,710 --> 00:35:26,465
0,275 275,410 410,530 530,620 620,755
I can give it a
我可以给它一个字符串，然后我放上冒号，冒号，日期，这就把它转换成了日期，但这只是在。

1288
00:35:26,465 --> 00:35:27,530
0,305 415,675 675,780 780,885 885,1065
string and then I put

1289
00:35:27,530 --> 00:35:29,000
0,270 270,615 615,1005 1005,1260 1260,1470
colon, colon, date and that

1290
00:35:29,000 --> 00:35:30,790
0,255 255,375 375,650 1270,1530 1530,1790
converts it to a date,

1291
00:35:31,170 --> 00:35:33,880
0,245 245,470 470,725 725,1120
but that's only in.|
|

1292
00:35:33,970 --> 00:35:35,900
0,350 350,910
In postgres.|
在波斯格雷斯。|

1293
00:35:35,940 --> 00:35:37,090
0,275 275,515 515,620 620,815 815,1150
I can't do this in
除了ddb之外，我不能在任何其他系统中这样做，因为它们遵循相同的标准，对吗？所以如果我去。

1294
00:35:37,320 --> 00:35:38,885
0,290 290,500 500,820 1230,1475 1475,1565
any other system except for

1295
00:35:38,885 --> 00:35:40,100
0,120 120,450 450,765 765,1035 1035,1215
d DB because they follow

1296
00:35:40,100 --> 00:35:41,630
0,150 150,315 315,620 1030,1365 1365,1530
the same standard, right? So

1297
00:35:41,630 --> 00:35:43,120
0,60 60,165 165,440
if I go.|
|

1298
00:35:43,130 --> 00:35:44,095
0,245 245,365 365,725 725,905 905,965
To my sql, try to
对于我的SQL，尝试做同样的事情。他不喜欢这样。去Sqlite可不喜欢那样。转到鸭子数据库，否则Oracle不会像DUAL那样走下去。

1299
00:35:44,095 --> 00:35:45,535
0,60 60,165 165,300 300,575 1105,1440
do the same thing. Doesn't

1300
00:35:45,535 --> 00:35:47,250
0,135 135,425 865,1140 1140,1275 1275,1715
like that. Go to sqlite

1301
00:35:47,810 --> 00:35:49,825
0,365 365,485 485,760 1680,1925 1925,2015
doesn't like that. Go to

1302
00:35:49,825 --> 00:35:50,920
0,120 120,420 420,615 615,795 795,1095
duck DB or or Oracle

1303
00:35:50,920 --> 00:35:51,570
0,75 75,165 165,240 240,360 360,650
is not going like that

1304
00:35:51,920 --> 00:35:53,320
0,305 305,730
from dual.|
|

1305
00:35:55,030 --> 00:35:55,710
0,320 320,380 380,455 455,545 545,680
Doesn't know what a date
不知道什么是约会吗，艾米？这个数据库应该这样做，因为数据库遵循相同的语法，所以我们可以使用这个函数来提取。

1306
00:35:55,710 --> 00:35:58,460
0,290 520,920 1450,1680 1680,1910 2230,2750
is, EM? And this DB

1307
00:35:58,480 --> 00:36:00,750
0,260 260,380 380,640 1200,1600 1860,2270
should do it because DB

1308
00:36:00,750 --> 00:36:02,565
0,225 225,360 360,480 480,890 1570,1815
follows the same grammar, so

1309
00:36:02,565 --> 00:36:03,510
0,75 75,150 150,285 285,575 625,945
we can use this function

1310
00:36:03,510 --> 00:36:05,030
0,150 150,375 375,675 675,980 1120,1520
to maybe extract what the.|
|

1311
00:36:05,960 --> 00:36:07,040
0,320
The.|
这个。|

1312
00:36:07,860 --> 00:36:09,185
0,320 320,545 545,770 770,1085 1085,1325
Current date is, or try
当前日期是，或者试着计算出从现在到年初有多少天。那么让我们从Postgres开始吧。

1313
00:36:09,185 --> 00:36:09,830
0,90 90,180 180,360 360,525 525,645
to figure out how many

1314
00:36:09,830 --> 00:36:11,770
0,195 195,500 1030,1290 1290,1545 1545,1940
days since from now until

1315
00:36:11,940 --> 00:36:13,250
0,260 260,365 365,455 455,700 1080,1310
beginning of the year. So

1316
00:36:13,250 --> 00:36:14,800
0,165 165,255 255,375 375,830
let's start with postgres.|
|

1317
00:36:15,690 --> 00:36:16,550
0,260 260,365 365,500 500,680 680,860
So it turns out it's
所以事实证明，Postgres的情况很简单。

1318
00:36:16,550 --> 00:36:19,260
0,120 120,410 1330,1590 1590,2030
pretty simple with postgres.|
|

1319
00:36:19,790 --> 00:36:20,880
0,350 350,545 545,635 635,785 785,1090
So we can just cast
这样我们就可以抛出琴弦了。

1320
00:36:21,050 --> 00:36:22,640
0,290 290,580
the string.|
|

1321
00:36:22,890 --> 00:36:24,220
0,400 450,725 725,860 860,1025 1025,1330
Of today s current date.|
今天的S是现在的日期。|

1322
00:36:25,330 --> 00:36:28,230
0,400 1320,1565 1565,1715 1715,2020 2640,2900
To a day type and
转换为日期类型，然后减去它。

1323
00:36:28,230 --> 00:36:29,740
0,135 135,585 585,920
then subtract it.|
|

1324
00:36:29,740 --> 00:36:30,880
0,270 270,540 540,750 750,960 960,1140
From the string of the
从海流的琴弦。

1325
00:36:30,880 --> 00:36:31,880
0,290
current.|
|

1326
00:36:31,920 --> 00:36:33,200
0,400
Um.|
恩。|

1327
00:36:33,990 --> 00:36:34,900
0,305 305,485 485,590 590,665 665,910
The beginning of the year
年初，我们可以使用，我们想要，我们可以回到这里，使用当前时间戳，或者可能使用NOW函数。

1328
00:36:35,070 --> 00:36:37,145
0,275 275,395 395,500 500,760 1830,2075
and we could use, we

1329
00:36:37,145 --> 00:36:37,820
0,150 150,330 330,450 450,540 540,675
wanted to, we could go

1330
00:36:37,820 --> 00:36:38,825
0,210 210,450 450,615 615,780 780,1005
back here and use current

1331
00:36:38,825 --> 00:36:40,265
0,210 210,515 595,990 990,1275 1275,1440
time stamp or maybe use

1332
00:36:40,265 --> 00:36:41,560
0,120 120,285 285,605
the now function.|
|

1333
00:36:42,060 --> 00:36:43,520
0,245 245,350 350,470 470,730
And this should work.|
这应该会奏效。|

1334
00:36:43,640 --> 00:36:44,680
0,400
Right.|
正确的。|

1335
00:36:44,680 --> 00:36:47,050
0,290 310,600 600,795 795,1100 2080,2370
So that gets today, cast
所以这就是今天，把它作为一个日期，减去取案件的日期，然后在年初减去。我们得到了241，我认为这是正确的。

1336
00:36:47,050 --> 00:36:48,660
0,135 135,240 240,360 360,620 850,1610
it as a date, subtracting

1337
00:36:49,940 --> 00:36:51,505
0,305 305,470 470,695 695,940 1290,1565
taking the case's date and

1338
00:36:51,505 --> 00:36:52,720
0,420 420,690 690,960 960,1110 1110,1215
subtracting by the beginning of

1339
00:36:52,720 --> 00:36:53,560
0,75 75,320 370,615 615,705 705,840
the year. And we get

1340
00:36:53,830 --> 00:36:55,360
0,720 720,945 945,1155 1155,1365 1365,1530
241 which I assume is

1341
00:36:55,360 --> 00:36:56,160
0,320
correct.|
|

1342
00:36:58,490 --> 00:36:59,105
0,60 60,165 165,315 315,450 450,615
So let's try the same
现在让我们来尝试同样的事情。

1343
00:36:59,105 --> 00:37:01,560
0,210 210,515 535,935
thing now in.|
|

1344
00:37:02,330 --> 00:37:04,240
0,400 510,785 785,1180
In my sql.|
在我的SQL中。|

1345
00:37:04,500 --> 00:37:05,840
0,245 245,490 840,1100 1100,1205 1205,1340
So again, since they don't
再说一次，因为它们没有名词功能，所以我们将在强制转换时这样做。

1346
00:37:05,840 --> 00:37:06,845
0,90 90,240 240,495 495,765 765,1005
have the noun function, we'll

1347
00:37:06,845 --> 00:37:09,080
0,105 105,365 745,1020 1020,1505
do it for casting.|
|

1348
00:37:09,330 --> 00:37:09,980
0,245 245,350 350,455 455,545 545,650
So now we get a
所以现在我们得到了一个奇怪的数字，我们得到了729。

1349
00:37:09,980 --> 00:37:10,775
0,150 150,315 315,435 435,585 585,795
weird number, we get seven

1350
00:37:10,775 --> 00:37:12,580
0,210 210,515
twenty nine.|
|

1351
00:37:13,660 --> 00:37:14,560
0,60 60,290
What's that?|
那是什么？|

1352
00:37:16,100 --> 00:37:17,305
0,305 305,710 710,860 860,1025 1025,1205
And surprisingly, actually, somebody on
令人惊讶的是，实际上，YouTube上的一个人在所有地方的评论中告诉了我这是什么。这很奇怪。所以第一个数字是今天的当月减去一月份，所以八减一等于七。

1353
00:37:17,305 --> 00:37:18,940
0,275 775,1020 1020,1155 1155,1410 1410,1635
Youtube in a comment of

1354
00:37:18,940 --> 00:37:20,680
0,135 135,410 1300,1545 1545,1650 1650,1740
all places, told me what

1355
00:37:20,680 --> 00:37:22,945
0,75 75,320 1750,2010 2010,2130 2130,2265
it was. And this is

1356
00:37:22,945 --> 00:37:24,090
0,195 195,360 360,510 510,780 780,1145
weird. So the first number

1357
00:37:24,470 --> 00:37:27,850
0,400 1290,1760 1760,1955 1955,2290 2760,3380
is today's current month subtracted

1358
00:37:27,850 --> 00:37:30,210
0,260 280,680 1060,1365 1365,1670 1960,2360
by january, so eight minus

1359
00:37:30,290 --> 00:37:32,100
0,400 540,875 875,1210
one is seven.|
|

1360
00:37:32,500 --> 00:37:34,785
0,400 480,1010 1010,1360 1740,2165 2165,2285
Then it's uh, today's what
那就是呃，今天是三十号。所以今天的日期减去1月1日。所以这是29，你得到7，29，这是错误的。我不能这么做。

1361
00:37:34,785 --> 00:37:38,060
0,165 165,665 1375,2045 2185,2855 2875,3275
the thirtieth. So today's day

1362
00:37:38,470 --> 00:37:40,920
0,590 590,850 1200,1565 1565,1930 2220,2450
subtracted by january first. So

1363
00:37:40,920 --> 00:37:42,180
0,195 195,615 615,840 840,1005 1005,1260
that's 29 you get seven,

1364
00:37:42,180 --> 00:37:46,020
0,255 255,560 2920,3315 3315,3540 3540,3840
twenty nine, that's wrong. Can't

1365
00:37:46,020 --> 00:37:48,320
0,90 90,350
do that.|
|

1366
00:37:48,330 --> 00:37:48,995
0,230 230,290 290,380 380,485 485,665
So what we can do
所以我们能做的就是我们能做到。

1367
00:37:48,995 --> 00:37:51,420
0,240 240,545 805,1095 1095,1385
instead is we can.|
|

1368
00:37:52,230 --> 00:37:54,160
0,275 275,550
We can.|
我们可以的。|

1369
00:37:54,470 --> 00:37:55,560
0,400
Sorry.|
抱歉的。|

1370
00:37:56,500 --> 00:37:58,460
0,230 230,320 320,485 485,790
We can get the.|
我们可以拿到。|

1371
00:38:01,200 --> 00:38:02,440
0,320 320,640
Windows, sorry.|
Windows，对不起。|

1372
00:38:04,850 --> 00:38:07,255
0,245 245,490 1350,1640 1640,1930 2100,2405
There we. So what we're
我们到了。因此，我们现在要做的是获取今天的日期和年初，将其转换为Unix时间戳。

1373
00:38:07,255 --> 00:38:08,080
0,105 105,285 285,480 480,660 660,825
doing here now is we're

1374
00:38:08,080 --> 00:38:11,790
0,230 2650,2910 2910,3150 3150,3420 3420,3710
getting the date of today

1375
00:38:11,870 --> 00:38:12,565
0,260 260,380 380,515 515,620 620,695
and the beginning of the

1376
00:38:12,565 --> 00:38:13,780
0,245 625,960 960,1050 1050,1125 1125,1215
year, converting it to a

1377
00:38:13,780 --> 00:38:15,280
0,285 285,525 525,860
unix time stamp.|
|

1378
00:38:15,410 --> 00:38:17,305
0,395 395,605 605,875 875,1210 1650,1895
Unix time stamp is the
Unix时间戳是自Unix纪元1970年1月1日以来的秒数，因此我们现在将其转换为从今天开始的秒数。

1379
00:38:17,305 --> 00:38:18,460
0,135 135,315 315,605 625,915 915,1155
number of seconds since the

1380
00:38:18,460 --> 00:38:21,240
0,315 315,920 1390,1790 1840,2160 2160,2780
unix epochs january first 1970

1381
00:38:22,610 --> 00:38:23,575
0,245 245,425 425,635 635,770 770,965
so we're converting it now

1382
00:38:23,575 --> 00:38:24,270
0,135 135,195 195,300 300,435 435,695
to the number of seconds

1383
00:38:24,590 --> 00:38:26,120
0,290 290,580
from today.|
|

1384
00:38:26,680 --> 00:38:28,725
0,305 305,940 1470,1730 1730,1880 1880,2045
Since 1970 and then we
从1970年开始，然后我们从1月1日以来的数字中减去，再除以60秒。60分钟乘以24小时。

1385
00:38:28,725 --> 00:38:30,290
0,450 450,750 750,1085 1105,1335 1335,1565
subtract that from the number

1386
00:38:30,400 --> 00:38:33,180
0,400 600,935 935,1270 1800,2200 2430,2780
since january first and we

1387
00:38:33,180 --> 00:38:34,695
0,270 270,540 540,885 885,1215 1215,1515
divide that by sixty seconds

1388
00:38:34,695 --> 00:38:36,405
0,285 285,540 540,810 810,1145 1285,1710
times. Sixty minutes times 24

1389
00:38:36,405 --> 00:38:38,200
0,245
hours.|
|

1390
00:38:38,200 --> 00:38:38,770
0,105 105,195 195,300 300,420 420,570
And we get two forty
我们得到二百四十一。

1391
00:38:38,770 --> 00:38:39,580
0,290
one.|
|

1392
00:38:40,550 --> 00:38:41,920
0,335 335,670 840,1100 1100,1220 1220,1370
So this, this is my
所以，这是我最初的想法，然后发现我的电脑里有一个日期比较功能，你可以这么做。

1393
00:38:41,920 --> 00:38:43,675
0,290 340,740 1240,1470 1470,1590 1590,1755
original idea and then turns

1394
00:38:43,675 --> 00:38:45,520
0,275 475,795 795,1025 1345,1650 1650,1845
out there's a date diff

1395
00:38:45,520 --> 00:38:49,255
0,290 2830,3090 3090,3350 3400,3645 3645,3735
function in my you can

1396
00:38:49,255 --> 00:38:51,420
0,105 105,365
do this.|
|

1397
00:38:51,420 --> 00:38:53,760
0,350 640,945 945,1080 1080,1370
Process doesn't have it.|
进程不具备这种能力。|

1398
00:38:53,950 --> 00:38:54,975
0,275 275,500 500,695 695,800 800,1025
Dr deb doesn't have it.
黛布医生没有。看看甲骨文有没有。

1399
00:38:54,975 --> 00:38:55,910
0,180 180,240 240,480 480,630 630,935
See if Oracle has it.|
|

1400
00:38:58,690 --> 00:39:01,380
0,400 1740,2140 2220,2465 2465,2615 2615,2690
Ual right. They don't have
好的。他们做得不对。所以这是我的，这是我的事。

1401
00:39:01,380 --> 00:39:03,750
0,260 1810,2085 2085,2190 2190,2295 2295,2370
it right. So that's a

1402
00:39:03,750 --> 00:39:04,850
0,195 195,435 435,495 495,840 840,1100
my, that's a myl thing.|
|

1403
00:39:05,550 --> 00:39:07,090
0,290 290,425 425,670 900,1265 1265,1540
Right, so now let's try
好的，那么现在让我们在SQL Lite中尝试。因此，SQL Lite没有Date Diff。我们不能这么做。我们在波斯格雷斯做的减法。

1404
00:39:07,290 --> 00:39:09,470
0,400 540,860 860,1120 1680,1955 1955,2180
in sql lite. So sql

1405
00:39:09,470 --> 00:39:10,420
0,150 150,360 360,480 480,660 660,950
lite doesn't have date diff.

1406
00:39:11,310 --> 00:39:12,425
0,275 275,515 515,605 605,800 800,1115
We can't do that. That

1407
00:39:12,425 --> 00:39:13,370
0,570 570,660 660,750 750,840 840,945
subtraction that we did in

1408
00:39:13,370 --> 00:39:15,660
0,500
postgres.|
|

1409
00:39:15,660 --> 00:39:16,665
0,240 240,420 420,690 690,885 885,1005
The best solution I could
我能想到的最好的解决方案是将今天的时间戳转换为儒略历开始一年，儒略历是自朱利安·凯撒生日以来的天数。无论你笑在什么地方。但直到上世纪80年代，很多银行都在挤兑，对吧？然后你得到二百四十一，但我们得到的是一个。

1410
00:39:16,665 --> 00:39:18,770
0,135 135,285 285,575 985,1385 1705,2105
come up with is the

1411
00:39:19,780 --> 00:39:21,480
0,335 335,560 560,800 800,1150 1440,1700
convert the time stamp for

1412
00:39:21,480 --> 00:39:22,365
0,240 240,480 480,585 585,690 690,885
today and begin a year

1413
00:39:22,365 --> 00:39:24,225
0,195 195,345 345,795 795,1085 1615,1860
to the Julian calendar, which

1414
00:39:24,225 --> 00:39:24,980
0,90 90,165 165,285 285,465 465,755
is the number of days

1415
00:39:25,270 --> 00:39:27,285
0,320 320,740 740,1235 1235,1510 1680,2015
since Julian caesar's birthday. In

1416
00:39:27,285 --> 00:39:30,015
0,255 255,480 480,785 2245,2520 2520,2730
whatever B C you laugh.

1417
00:39:30,015 --> 00:39:30,525
0,165 165,225 225,330 330,420 420,510
But a lot of the

1418
00:39:30,525 --> 00:39:31,650
0,225 225,450 450,600 600,870 870,1125
banks ran off that in

1419
00:39:31,650 --> 00:39:32,685
0,120 120,255 255,530 550,870 870,1035
the in the up until

1420
00:39:32,685 --> 00:39:35,310
0,135 135,600 600,995 2275,2520 2520,2625
the eighties right? And then

1421
00:39:35,310 --> 00:39:36,440
0,120 120,375 375,645 645,825 825,1130
you get two forty one,

1422
00:39:36,850 --> 00:39:38,240
0,400 450,740 740,860 860,1070 1070,1390
but we're getting it as

1423
00:39:38,620 --> 00:39:39,640
0,400
a.|
|

1424
00:39:39,930 --> 00:39:40,960
0,275 275,410 410,635 635,755 755,1030
As a floating point number
作为一个浮点数，所以我们可以将它转换为一个整数，然后我们得到2401。

1425
00:39:41,310 --> 00:39:42,365
0,320 320,500 500,650 650,860 860,1055
so we can cast it

1426
00:39:42,365 --> 00:39:43,235
0,195 195,360 360,690 690,795 795,870
as an integer and then

1427
00:39:43,235 --> 00:39:44,020
0,75 75,195 195,345 345,495 495,785
we get two forty one.|
|

1428
00:39:45,380 --> 00:39:46,720
0,400
I.|
我。|

1429
00:39:46,720 --> 00:39:47,860
0,320 670,915 915,990 990,1065 1065,1140
I forget how to do
我忘记了如何在Oracle中做到这一点。我不会做先知的。这似乎是一件简单的事情，但所有这些东西都有很大的不同。

1430
00:39:47,860 --> 00:39:48,625
0,75 75,165 165,480 480,705 705,765
this in Oracle. Not going

1431
00:39:48,625 --> 00:39:51,720
0,30 30,90 90,165 165,575 2695,3095
to do an Oracle. The

1432
00:39:52,730 --> 00:39:53,590
0,290 290,470 470,605 605,695 695,860
seems like be a simple

1433
00:39:53,590 --> 00:39:55,380
0,320 490,750 750,900 900,1190 1390,1790
thing, but all these stuff

1434
00:39:56,270 --> 00:39:58,520
0,400 780,1265 1265,1540
is woefully different.|
|

1435
00:39:59,120 --> 00:39:59,995
0,275 275,455 455,620 620,755 755,875
Any questions about this so
到目前为止，对此有什么问题吗？

1436
00:39:59,995 --> 00:40:00,860
0,245
far?|
|

1437
00:40:01,800 --> 00:40:03,125
0,400 570,845 845,980 980,1085 1085,1325
Yes, so why do we
是的，既然如此，我们为什么要降低我的功能呢？

1438
00:40:03,125 --> 00:40:04,970
0,375 375,690 690,1025 1105,1505 1555,1845
want lower function my given

1439
00:40:04,970 --> 00:40:06,500
0,135 135,380 520,885 885,1250
that it case incent.|
|

1440
00:40:06,970 --> 00:40:07,605
0,260 260,350 350,425 425,515 515,635
Why would you want a
为什么你会想要一个更低的功能？

1441
00:40:07,605 --> 00:40:10,440
0,210 210,545
lower function?|
|

1442
00:40:14,230 --> 00:40:15,820
0,260 260,520
Good question.|
问得好。|

1443
00:40:15,860 --> 00:40:16,480
0,245 245,320 320,395 395,515 515,620
I mean, you might need
我的意思是，你可能需要它来清理数据。

1444
00:40:16,480 --> 00:40:19,060
0,75 75,240 240,495 495,830
it for data cleaning.|
|

1445
00:40:19,100 --> 00:40:20,460
0,275 275,550 570,845 845,1040 1040,1360
You might want it for.|
你可能需要它来做。|

1446
00:40:22,710 --> 00:40:23,500
0,275 275,425 425,470 470,545 545,790
Yeah, it's a good question.
是啊，这是个好问题。保持标准，对吗？

1447
00:40:23,610 --> 00:40:25,800
0,320 320,515 515,790 1170,1570
Maintain the standard, right?|
|

1448
00:40:26,260 --> 00:40:27,660
0,290 290,440 440,700 1020,1250 1250,1400
It could be. It doesn't
可能会吧。并不一定非得如此。在WHERE子句中，您也可以在FROM子句中使用它。所以如果我回到我的SQL。

1449
00:40:27,660 --> 00:40:28,320
0,75 75,150 150,375 375,600 600,660
have to be. Also in

1450
00:40:28,320 --> 00:40:29,160
0,90 90,255 255,540 540,735 735,840
the where clause you can

1451
00:40:29,160 --> 00:40:29,730
0,135 135,225 225,285 285,405 405,570
have it in the from

1452
00:40:29,730 --> 00:40:31,170
0,320 940,1170 1170,1230 1230,1320 1320,1440
clause. So if I go

1453
00:40:31,170 --> 00:40:32,780
0,135 135,240 240,360 360,800
back to my sql.|
|

1454
00:40:33,240 --> 00:40:35,600
0,350 350,620 620,845 845,1150
Right, so select star.|
好，那就选星星吧。|

1455
00:40:35,790 --> 00:40:37,660
0,395 395,790
From students.|
从学生那里。|

1456
00:40:39,350 --> 00:40:41,340
0,305 305,605 605,950 950,1480 1590,1990
Where name equals tupac, right?|
名字等于图帕克，对吗？|

1457
00:40:43,740 --> 00:40:46,235
0,400 1260,1660 1980,2225 2225,2360 2360,2495
Student right. So maybe I
学生对。所以，也许我想这么做。

1458
00:40:46,235 --> 00:40:47,020
0,75 75,150 150,270 270,465 465,785
want to do this, though.|
|

1459
00:40:49,470 --> 00:40:51,215
0,245 245,440 440,790 1410,1655 1655,1745
In my output, get a
在我的输出中，得到一个这样的小写字母。

1460
00:40:51,215 --> 00:40:52,620
0,270 270,405 405,665
lowercase like that.|
|

1461
00:40:55,110 --> 00:40:56,520
0,290 290,485 485,790
Yes. Sorry, yes.|
是。抱歉，是的。|

1462
00:40:56,900 --> 00:40:58,220
0,300 300,680
Reason why.|
原因就是。|

1463
00:41:02,420 --> 00:41:03,680
0,105 105,240 240,530 610,1010
They are all relation.|
他们都是亲戚。|

1464
00:41:08,060 --> 00:41:09,520
0,260 260,425 425,665 665,1000
At least from this.|
至少从这个角度来说是这样。|

1465
00:41:10,300 --> 00:41:11,630
0,365 365,650 650,830 830,1010 1010,1330
Yeah, so her question is
是的，所以她的问题是，为什么人们在他们的SQL中有所有这些奇怪的习语。

1466
00:41:12,580 --> 00:41:13,500
0,335 335,515 515,650 650,800 800,920
why do people have all

1467
00:41:13,500 --> 00:41:15,345
0,150 150,360 360,860 910,1310 1570,1845
these weird idioms in, in

1468
00:41:15,345 --> 00:41:18,200
0,275 325,725 745,1295
their, their sql.|
|

1469
00:41:18,380 --> 00:41:19,600
0,400 510,755 755,875 875,1055 1055,1220
When at a high level
当他们处于高水平时，他们似乎都在做同样的事情，但这是一次性的，事情不同，这与他的问题有关，为什么？为什么会有这些呢？

1470
00:41:19,600 --> 00:41:20,170
0,135 135,240 240,300 300,360 360,570
they seem to be all

1471
00:41:20,170 --> 00:41:21,085
0,240 240,375 375,510 510,675 675,915
sort doing the same thing,

1472
00:41:21,085 --> 00:41:21,925
0,180 180,345 345,510 510,705 705,840
but it's these one off,

1473
00:41:21,925 --> 00:41:23,320
0,275 385,630 630,875 925,1170 1170,1395
things are different and that's

1474
00:41:23,320 --> 00:41:24,265
0,180 180,270 270,375 375,600 600,945
related to his question why?

1475
00:41:24,265 --> 00:41:25,860
0,270 270,405 405,570 570,875
Why are all these?|
|

1476
00:41:25,860 --> 00:41:26,595
0,195 195,315 315,420 420,555 555,735
Why are all these different
为什么这些不同的系统有这么多不同的细微差别？因为有人在写文章，觉得很酷。

1477
00:41:26,595 --> 00:41:27,800
0,465 465,615 615,720 720,885 885,1205
nuances for these different systems?

1478
00:41:28,390 --> 00:41:29,490
0,320 320,575 575,785 785,950 950,1100
Because somebody was writing and

1479
00:41:29,490 --> 00:41:30,780
0,120 120,225 225,345 345,620
thought it was cool.|
|

1480
00:41:30,780 --> 00:41:32,415
0,350 820,1080 1080,1230 1230,1410 1410,1635
Right. And then they showed
正确的。然后他们向他们的朋友们展示了是的，这很酷。所以双冒号和Postgres我同意，这很酷，选角的事情，但他们只做这件事。

1481
00:41:32,415 --> 00:41:33,495
0,240 240,510 510,720 720,855 855,1080
their friends like yeah, that's

1482
00:41:33,495 --> 00:41:34,890
0,245 385,705 705,915 915,1155 1155,1395
cool. So the double colon

1483
00:41:34,890 --> 00:41:36,000
0,150 150,495 495,690 690,870 870,1110
and postgres I agree, that's

1484
00:41:36,000 --> 00:41:37,305
0,120 120,270 270,645 645,920 1060,1305
cool, that casting thing, but

1485
00:41:37,305 --> 00:41:38,540
0,135 135,345 345,540 540,815
they only do it.|
|

1486
00:41:38,960 --> 00:41:42,145
0,400 1890,2180 2180,2435 2435,2710 2940,3185
Right, the dole table, I
对，救济金桌上，我不知道是什么。

1487
00:41:42,145 --> 00:41:46,900
0,150 150,195 195,425
don't know what.|
|

1488
00:41:47,720 --> 00:41:49,570
0,380 380,760 1140,1415 1415,1610 1610,1850
Yeah, so give another example.
是的，那么再举一个例子。因此，在SQL中有一条捷径可供选择。基本上就是选择。因此，从学生中选择明星。

1489
00:41:49,570 --> 00:41:52,020
0,320 730,1050 1050,1170 1170,1670 2050,2450
So there's a shortcut in

1490
00:41:52,040 --> 00:41:54,210
0,580 960,1205 1205,1385 1385,1720 1770,2170
sql to do. Basically select.

1491
00:41:54,560 --> 00:41:57,570
0,320 320,575 575,910 1560,1960 2610,3010
So select star from student.|
|

1492
00:41:59,030 --> 00:41:59,890
0,260 260,365 365,485 485,605 605,860
Gives you all the tubes,
给你所有的管子，对吗？但是在Postgres中，我认为它也在SQL标准中，我只需要写表就可以了。

1493
00:41:59,890 --> 00:42:01,870
0,290 520,870 870,1140 1140,1670 1720,1980
right? But in postgres, which

1494
00:42:01,870 --> 00:42:02,410
0,120 120,225 225,360 360,480 480,540
I think is also in

1495
00:42:02,410 --> 00:42:03,175
0,75 75,270 270,480 480,675 675,765
the sql standard, I can

1496
00:42:03,175 --> 00:42:04,540
0,90 90,255 255,575 985,1245 1245,1365
just write table and get

1497
00:42:04,540 --> 00:42:05,880
0,210 210,560
that right.|
|

1498
00:42:06,110 --> 00:42:09,140
0,400 1590,1865 1865,2290
In my sql.|
在我的SQL中。|

1499
00:42:09,380 --> 00:42:11,000
0,275 275,395 395,500 500,760
I can do that.|
我能做到。|

1500
00:42:11,105 --> 00:42:13,820
0,105 105,365 1165,1515 1515,1775
That's cool sql light.|
这是很酷的SQL Light。|

1501
00:42:15,650 --> 00:42:17,220
0,305 305,530 530,635 635,910
Y doesn't like it.|
Y不喜欢这样。|

1502
00:42:17,220 --> 00:42:19,320
0,380 580,1250
In DB.|
在数据库中。|

1503
00:42:21,370 --> 00:42:22,305
0,260 260,365 365,590 590,815 815,935
They do it, but they
他们这样做了，但他们也有另一个，我想你就走吧。

1504
00:42:22,305 --> 00:42:23,445
0,105 105,210 210,375 375,665 895,1140
also have another one, I

1505
00:42:23,445 --> 00:42:25,080
0,105 105,225 225,360 360,635
think you just go.|
|

1506
00:42:25,490 --> 00:42:26,125
0,245 245,320 320,380 380,470 470,635
I think you just go
我想你现在就去取吧。还是真的是这样？

1507
00:42:26,125 --> 00:42:27,510
0,365 625,915 915,1050 1050,1140 1140,1385
fetch now. Or is it?|
|

1508
00:42:30,750 --> 00:42:32,040
0,400
From.|
从…。|

1509
00:42:32,050 --> 00:42:33,510
0,400 870,1115 1115,1220 1220,1340 1340,1460
Right, you can just do
好的，你可以这么做。

1510
00:42:33,510 --> 00:42:34,380
0,260
that.|
|

1511
00:42:35,670 --> 00:42:36,665
0,335 335,530 530,680 680,845 845,995
So they all had their
所以他们都有自己奇怪的习语。我的意思是，其中一些事情过去、现在和现在都是基于客户的反馈，就像客户所说的那样。我想，你知道，我需要在json上操作的函数。所以有人加了这句话。而且很多时候，这些功能在它们出现在标准中之前就被添加了。

1512
00:42:36,665 --> 00:42:37,835
0,240 240,690 690,885 885,990 990,1170
weird idioms. I mean, so

1513
00:42:37,835 --> 00:42:38,825
0,165 165,270 270,405 405,660 660,990
some of these things were,

1514
00:42:38,825 --> 00:42:40,595
0,365 565,870 870,1125 1125,1425 1425,1770
are, are based on customer

1515
00:42:40,595 --> 00:42:41,720
0,345 345,585 585,750 750,945 945,1125
feedback, like the customer says.

1516
00:42:41,720 --> 00:42:42,740
0,135 135,390 390,615 615,810 810,1020
I want, you know, I

1517
00:42:42,740 --> 00:42:43,550
0,135 135,345 345,570 570,705 705,810
need functions that operate on

1518
00:42:43,550 --> 00:42:45,250
0,470 490,885 885,1185 1185,1455 1455,1700
json. So somebody adds that.

1519
00:42:45,690 --> 00:42:46,910
0,400 420,680 680,815 815,965 965,1220
And a lot of times

1520
00:42:46,910 --> 00:42:48,670
0,315 315,615 615,840 840,1100 1360,1760
these features get added before

1521
00:42:48,780 --> 00:42:49,670
0,305 305,470 470,590 590,710 710,890
they show up in the

1522
00:42:49,670 --> 00:42:50,580
0,320
standard.|
|

1523
00:42:50,780 --> 00:42:52,510
0,395 395,725 725,935 935,1280 1280,1730
Right. So the json xml
正确的。因此，json XML就是一个很好的例子。

1524
00:42:52,510 --> 00:42:53,200
0,195 195,270 270,405 405,585 585,690
is a good example of

1525
00:42:53,200 --> 00:42:54,660
0,230
this.|
|

1526
00:42:54,670 --> 00:42:55,500
0,305 305,485 485,620 620,725 725,830
That got out of the
这超出了2006年SQL标准，但当时有很多最新的数据库。在前两个版本中，数千人对XML有一些支持。

1527
00:42:55,500 --> 00:42:56,895
0,225 225,480 480,1140 1140,1305 1305,1395
sql standard 2006 but a

1528
00:42:56,895 --> 00:42:58,200
0,120 120,240 240,405 405,1025 1045,1305
lot of lat databases at

1529
00:42:58,200 --> 00:42:58,785
0,135 135,300 300,420 420,480 480,585
the time. In the early

1530
00:42:58,785 --> 00:43:00,255
0,135 135,395 655,990 990,1245 1245,1470
two, thousands had some support

1531
00:43:00,255 --> 00:43:01,540
0,195 195,725
for xml.|
|

1532
00:43:01,740 --> 00:43:02,690
0,260 260,365 365,470 470,680 680,950
And so what happens is,
所以发生的事情是，就像，标准机构是，它是一群RANDO，它是不同公司的人。因此，在SQL标准机构中，有来自Oracle的人，有来自sbase的人，有来自IBM的人。

1533
00:43:02,690 --> 00:43:04,625
0,320 550,870 870,1170 1170,1550 1570,1935
like, the standards body is

1534
00:43:04,625 --> 00:43:05,810
0,390 390,765 765,975 975,1065 1065,1185
it's, it's a bunch of

1535
00:43:05,810 --> 00:43:06,980
0,420 420,720 720,855 855,1020 1020,1170
randos, it's the people at

1536
00:43:06,980 --> 00:43:08,390
0,195 195,530 970,1215 1215,1305 1305,1410
different companies. So in the

1537
00:43:08,390 --> 00:43:09,755
0,255 255,465 465,705 705,1230 1230,1365
sql standards body, there's somebody

1538
00:43:09,755 --> 00:43:10,990
0,165 165,540 540,720 720,900 900,1235
from Oracle, there's somebody from

1539
00:43:11,190 --> 00:43:12,730
0,545 545,845 845,1130 1130,1310 1310,1540
sbase, somebody from, you know,

1540
00:43:12,750 --> 00:43:13,940
0,610
IBM.|
|

1541
00:43:14,210 --> 00:43:15,205
0,245 245,380 380,500 500,680 680,995
And they show up the
然后他们出现在标准委员会，他们都试图获得他们拥有的任何东西，他们试图将其纳入标准。

1542
00:43:15,205 --> 00:43:16,660
0,315 315,665 895,1155 1155,1275 1275,1455
standards committee, and they all

1543
00:43:16,660 --> 00:43:17,425
0,150 150,225 225,390 390,600 600,765
try to get whatever they

1544
00:43:17,425 --> 00:43:18,715
0,255 255,870 870,990 990,1110 1110,1290
have, proprietary thing that they

1545
00:43:18,715 --> 00:43:19,720
0,305 355,630 630,750 750,855 855,1005
have, they try to get

1546
00:43:19,720 --> 00:43:21,200
0,180 180,390 390,585 585,860
that into the standard.|
|

1547
00:43:21,200 --> 00:43:22,900
0,320 760,1185 1185,1320 1320,1455 1455,1700
Right, Oracle probably do this.
没错，甲骨文可能就是这么做的。最好的例子是，最近Oracle在SQL标准中得到了他们版本的属性图查询。他们的密码是基于密码的，这是neo 4，j中的密码，现在是SQL标准中的PG Q。

1548
00:43:24,210 --> 00:43:25,220
0,260 260,425 425,635 635,800 800,1010
The best example, more recently

1549
00:43:25,220 --> 00:43:27,110
0,210 210,555 555,830 1180,1560 1560,1890
the Oracle got their version

1550
00:43:27,110 --> 00:43:29,030
0,240 240,480 480,735 735,1220 1630,1920
of property graph queries in

1551
00:43:29,030 --> 00:43:30,830
0,165 165,450 450,740 1300,1590 1590,1800
the sql standard. They base

1552
00:43:30,830 --> 00:43:32,300
0,375 375,585 585,1110 1110,1350 1350,1470
theirs on cipher, which is

1553
00:43:32,300 --> 00:43:33,650
0,120 120,315 315,435 435,710 910,1350
in neo four, j, that's

1554
00:43:33,650 --> 00:43:35,980
0,240 240,620 1480,1875 1875,2040 2040,2330
now the pg q stuff

1555
00:43:36,060 --> 00:43:37,460
0,260 260,365 365,590 590,850
in a sql standard.|
|

1556
00:43:37,560 --> 00:43:39,730
0,245 245,365 365,590 590,940 1590,2170
So they got their extensions
因此，他们在SQL标准中获得了图形查询的扩展，因为他们当时是唯一领先的。这就是这些东西在SQL标准中的显示方式。因此，如果每个人都对如何做某事有相互竞争的想法，你最终会得到最小的公分母，或者可以尝试支持每个人的东西。但是，没有人确切地支持这种支持和标准。

1557
00:43:39,840 --> 00:43:41,600
0,400 720,1025 1025,1430 1430,1640 1640,1760
for graph queries in the

1558
00:43:41,600 --> 00:43:42,850
0,225 225,500 580,840 840,975 975,1250
sql standard because they were

1559
00:43:43,140 --> 00:43:43,910
0,290 290,455 455,575 575,665 665,770
only ones ahead at the

1560
00:43:43,910 --> 00:43:45,245
0,260 370,615 615,960 960,1170 1170,1335
time. So that's how these

1561
00:43:45,245 --> 00:43:45,725
0,165 165,285 285,345 345,405 405,480
things show up in the

1562
00:43:45,725 --> 00:43:46,880
0,150 150,300 300,510 510,815 835,1155
sql standard. And so if

1563
00:43:46,880 --> 00:43:49,010
0,195 195,420 420,855 855,1220 1780,2130
everybody has competing ideas for

1564
00:43:49,010 --> 00:43:49,960
0,240 240,435 435,585 585,690 690,950
how something should be done,

1565
00:43:50,160 --> 00:43:50,825
0,245 245,365 365,485 485,575 575,665
you end up with the

1566
00:43:50,825 --> 00:43:51,845
0,165 165,375 375,795 795,900 900,1020
lowest common denominator or something

1567
00:43:51,845 --> 00:43:52,715
0,135 135,240 240,360 360,615 615,870
could try to supports everyone.

1568
00:43:52,715 --> 00:43:54,155
0,105 105,335 775,1020 1020,1170 1170,1440
But then no one exactly

1569
00:43:54,155 --> 00:43:55,870
0,255 255,545 925,1260 1260,1455 1455,1715
supports the supports, the standard.|
|

1570
00:43:57,875 --> 00:43:58,385
0,45 45,165 165,315 390,435 435,510
I'm not saying it's a
我不是说这是一件好事，而是像。

1571
00:43:58,385 --> 00:43:59,900
0,135 135,375 375,570 570,815
good thing, but like.|
|

1572
00:43:59,900 --> 00:44:01,085
0,440 640,915 915,1035 1035,1110 1110,1185
It's we live in a
我们也生活在一个不同的时代，有这么多不同的戴维斯公司，但没有一家公司，我说它拥有市场，可以根据意愿让人屈服。

1573
00:44:01,085 --> 00:44:02,260
0,165 165,435 435,675 675,870 870,1175
different time also too, where

1574
00:44:02,670 --> 00:44:04,510
0,470 470,710 710,1030 1200,1520 1520,1840
there's so many different Davis

1575
00:44:04,620 --> 00:44:07,355
0,400 870,1160 1160,1540 1650,2050 2490,2735
companies and there's one there

1576
00:44:07,355 --> 00:44:08,375
0,240 240,420 420,645 645,855 855,1020
isn't one company, I say

1577
00:44:08,375 --> 00:44:09,700
0,165 165,510 510,645 645,905 925,1325
that owns the market and

1578
00:44:10,110 --> 00:44:12,410
0,400 900,1220 1220,1625 1625,1960 2010,2300
and can bend people according

1579
00:44:12,410 --> 00:44:13,340
0,120 120,225 225,500
to the will.|
|

1580
00:44:13,340 --> 00:44:14,840
0,320 400,800
Right, so.|
对，所以。|

1581
00:44:14,840 --> 00:44:16,145
0,195 195,330 330,590 850,1125 1125,1305
I said before in the
我之前说过，在1980年S是IBM，是大公司，对吧？IBM是计算公司，所以无论IBM说什么，这都被认为是事实上的标准。

1582
00:44:16,145 --> 00:44:17,735
0,555 555,765 765,1185 1185,1380 1380,1590
1980 s IBM was, was

1583
00:44:17,735 --> 00:44:18,725
0,135 135,270 270,480 480,690 690,990
the huge company, right? IBM

1584
00:44:18,725 --> 00:44:20,260
0,195 195,495 495,845 925,1290 1290,1535
was the the computing company,

1585
00:44:20,490 --> 00:44:21,680
0,275 275,425 425,800 800,1010 1010,1190
so whatever IBM said, that

1586
00:44:21,680 --> 00:44:23,600
0,180 180,500 910,1305 1305,1560 1560,1920
was considered the de facto

1587
00:44:23,600 --> 00:44:24,540
0,290
standard.|
|

1588
00:44:24,540 --> 00:44:25,785
0,195 195,470 670,975 975,1065 1065,1245
And so that sort of
这就是我们今天使用SQL的原因。

1589
00:44:25,785 --> 00:44:26,805
0,195 195,300 300,420 420,695 745,1020
how we ended up with

1590
00:44:26,805 --> 00:44:28,060
0,285 285,545
sql today.|
|

1591
00:44:28,130 --> 00:44:28,975
0,260 260,380 380,575 575,665 665,845
But there isn't a company
但现在没有一家公司像这样，最接近的事情是谷歌推出他们的标准续集，名为Zeta Sequqel。它在内部被称为其他东西，但他们开放了一个解析器和，以及语法文件和规范，用于他们的SQL版本。

1592
00:44:28,975 --> 00:44:30,985
0,210 210,375 375,665 955,1355 1675,2010
like that now, like the

1593
00:44:30,985 --> 00:44:32,800
0,450 450,645 645,810 810,1085 1435,1815
closest thing would be Google

1594
00:44:32,800 --> 00:44:34,135
0,225 225,435 435,780 780,1110 1110,1335
put out their standard of

1595
00:44:34,135 --> 00:44:35,860
0,285 285,495 495,810 810,1235 1375,1725
sequel called zeta sequqel. Internally

1596
00:44:35,860 --> 00:44:36,775
0,150 150,270 270,450 450,660 660,915
it's called something else, but

1597
00:44:36,775 --> 00:44:38,250
0,315 315,585 585,765 765,945 945,1475
they open source a parser

1598
00:44:39,230 --> 00:44:40,435
0,335 335,560 560,725 725,980 980,1205
and, and, and the and

1599
00:44:40,435 --> 00:44:41,500
0,120 120,435 435,585 585,840 840,1065
the grammar file and and

1600
00:44:41,500 --> 00:44:43,075
0,165 165,470 640,930 930,1200 1200,1575
the spec for their version

1601
00:44:43,075 --> 00:44:44,560
0,330 330,845
of sql.|
|

1602
00:44:44,750 --> 00:44:46,510
0,350 350,635 635,970 1290,1580 1580,1760
Nobody uses it and Google
没有人使用它，而且谷歌很大，对吗？

1603
00:44:46,510 --> 00:44:47,980
0,150 150,345 345,680
is huge, right?|
|

1604
00:44:48,090 --> 00:44:48,875
0,275 275,560 560,695 695,725 725,785
The closest you're going to
你今天能得到的最接近的是Postgresl。很多这样的数据库公司。当您开始时，不是从头开始构建语法文件，而是使用postgresl文件，将其修改并注入到系统中。我们就是这么做的。Uct DB拿走了我们的代码，他们把它放到uct DB中，就像这一堆系统是基于Postgres语法的，因为这个开放源码，他们使用它，这是你今天最接近通用标准的地方。

1605
00:44:48,875 --> 00:44:50,150
0,135 135,315 315,495 495,1020 1020,1275
get today is postgresl. A

1606
00:44:50,150 --> 00:44:50,990
0,135 135,240 240,345 345,555 555,840
lot of these database companies.

1607
00:44:50,990 --> 00:44:51,920
0,285 285,480 480,600 600,780 780,930
When you start out, instead

1608
00:44:51,920 --> 00:44:53,360
0,105 105,380 640,960 960,1290 1290,1440
of building the grammar file

1609
00:44:53,360 --> 00:44:54,725
0,180 180,470 700,960 960,1155 1155,1365
from scratch, you go take

1610
00:44:54,725 --> 00:44:55,730
0,135 135,495 495,675 675,885 885,1005
the postgresl one, hack it

1611
00:44:55,730 --> 00:44:57,080
0,230 400,705 705,900 900,1200 1200,1350
up and, and inject into

1612
00:44:57,080 --> 00:44:58,370
0,150 150,440 670,1005 1005,1110 1110,1290
your system. That's what we

1613
00:44:58,370 --> 00:45:00,140
0,290 880,1125 1125,1380 1380,1635 1635,1770
did. And thenuct DB took

1614
00:45:00,140 --> 00:45:00,860
0,165 165,375 375,510 510,615 615,720
our code and they put

1615
00:45:00,860 --> 00:45:02,770
0,60 60,285 285,680 1210,1560 1560,1910
it inuct DB, like this

1616
00:45:02,970 --> 00:45:04,040
0,260 260,380 380,640 660,920 920,1070
bunch of systems are based

1617
00:45:04,040 --> 00:45:05,840
0,165 165,525 525,980 1000,1400 1540,1800
on postgres grammar because because

1618
00:45:05,840 --> 00:45:06,500
0,180 180,345 345,465 465,570 570,660
this open source and they

1619
00:45:06,500 --> 00:45:07,700
0,135 135,410 430,765 765,885 885,1200
use it, that's the closest

1620
00:45:07,700 --> 00:45:08,210
0,135 135,180 180,255 255,390 390,510
you're going to get to

1621
00:45:08,210 --> 00:45:09,580
0,150 150,405 405,660 660,980
a universal standard today.|
|

1622
00:45:09,620 --> 00:45:10,480
0,260 260,410 410,560 560,695 695,860
But again, I just showed
再说一次，我刚才向你们展示了怎样在Inducteeb中有，但那不在里面。

1623
00:45:10,480 --> 00:45:11,910
0,180 180,405 405,720 720,1010 1030,1430
you how there's from in

1624
00:45:12,530 --> 00:45:14,580
0,880 1110,1355 1355,1565 1565,1730 1730,2050
inducteeb but that's not in.|
|

1625
00:45:16,180 --> 00:45:19,165
0,150 150,650 970,1370 2520,2595 2595,2985
In postgresql right, they've adapted
在PostgreSQL Right中，他们对其进行了调整。

1626
00:45:19,165 --> 00:45:19,960
0,245
it.|
|

1627
00:45:22,190 --> 00:45:23,280
0,400
Yes.|
是。|

1628
00:45:27,580 --> 00:45:28,455
0,290 290,470 470,635 635,800 800,875
His question is, what's the
他的问题是，如果没有人遵循S的标准，那么有一个标准有什么意义？

1629
00:45:28,455 --> 00:45:29,070
0,90 90,165 165,285 285,435 435,615
point of having a standard

1630
00:45:29,070 --> 00:45:29,505
0,165 165,255 255,315 315,360 360,435
if no one s going

1631
00:45:29,505 --> 00:45:31,860
0,90 90,240 240,545
to follow it?|
|

1632
00:45:31,860 --> 00:45:32,685
0,135 135,270 270,450 450,600 600,825
I mean, there's a speed
我是说，这是有速度限制的。每个人都会开车过来，对吗？喜欢。

1633
00:45:32,685 --> 00:45:33,900
0,305 385,645 645,810 810,1020 1020,1215
limit. Everyone drives over it,

1634
00:45:33,900 --> 00:45:37,440
0,225 225,560
right? Like.|
|

1635
00:45:39,180 --> 00:45:40,055
0,320 320,500 500,605 605,710 710,875
I showed you much of
我向您展示了许多SELECT语句，如。

1636
00:45:40,055 --> 00:45:42,780
0,225 225,545 925,1320 1320,1715
select statements like the.|
|

1637
00:45:42,780 --> 00:45:43,875
0,135 135,270 270,435 435,720 720,1095
And that were slightly different
这在不同的系统之间略有不同，但你知道它在做什么，基本上是不同系统的细微差别。是的，你可能必须去阅读文档或询问gBT要做什么，但就像在高级别上一样，这些概念是相同的。

1638
00:45:43,875 --> 00:45:44,775
0,285 285,465 465,660 660,810 810,900
from one system to the

1639
00:45:44,775 --> 00:45:46,710
0,245 505,905 1165,1565 1585,1845 1845,1935
next, but you understood what

1640
00:45:46,710 --> 00:45:48,480
0,60 60,180 180,420 420,770 1510,1770
it was doing, basically the

1641
00:45:48,480 --> 00:45:50,070
0,480 480,600 600,810 810,1160 1330,1590
nuances of different systems. Yeah,

1642
00:45:50,070 --> 00:45:50,505
0,120 120,210 210,285 285,360 360,435
you may have to go

1643
00:45:50,505 --> 00:45:51,740
0,90 90,240 240,630 630,900 900,1235
read the documentation or ask

1644
00:45:51,760 --> 00:45:52,700
0,245 245,470 470,575 575,680 680,940
g BT what to do,

1645
00:45:52,930 --> 00:45:54,585
0,260 260,520 1080,1340 1340,1475 1475,1655
but like at a high

1646
00:45:54,585 --> 00:45:55,845
0,300 300,600 600,780 780,1155 1155,1260
level, the the concepts are

1647
00:45:55,845 --> 00:45:56,800
0,135 135,395
the same.|
|

1648
00:45:56,900 --> 00:45:58,000
0,400
Right.|
正确的。|

1649
00:45:58,740 --> 00:46:00,300
0,400
Um.|
恩。|

1650
00:46:00,370 --> 00:46:02,870
0,320 320,485 485,650 650,970 1740,2500
Just you know the specifics.
只是你知道细节。每个系统都将是不同的。

1651
00:46:03,190 --> 00:46:03,990
0,290 290,485 485,650 650,740 740,800
Each system is going to

1652
00:46:03,990 --> 00:46:04,940
0,75 75,320
be different.|
|

1653
00:46:06,550 --> 00:46:07,665
0,410 410,500 500,560 560,635 635,1115
Snowflake is a good outlier
事实上，雪花是一个很好的异常值。雪花是在2013年白手起家的。他们没有选择Postgres，他们说，他们只是想出了自己的语法，那里有雪花语法，有其他系统不支持的东西。如果我是，如果我今天从头开始构建一个新的数据系统，我就不会像雪花一样做了。那是一个不同的时代。我会从波斯格雷斯开始。

1654
00:46:07,665 --> 00:46:08,850
0,270 270,600 600,795 795,990 990,1185
actually. Snowflake started from scratch

1655
00:46:08,850 --> 00:46:10,500
0,165 165,1050 1050,1215 1215,1335 1335,1650
in 2013. {They,didn't} take postgres

1656
00:46:10,500 --> 00:46:11,385
0,150 150,435 435,675 675,780 780,885
they said they just came

1657
00:46:11,385 --> 00:46:12,110
0,75 75,135 135,195 195,300 300,725
up with their own grammar

1658
00:46:12,460 --> 00:46:14,625
0,460 480,1030 1110,1660 1680,1970 1970,2165
there snowflake grammar that has

1659
00:46:14,625 --> 00:46:15,525
0,195 195,330 330,480 480,675 675,900
things that other systems don't

1660
00:46:15,525 --> 00:46:17,685
0,275 1435,1695 1695,1845 1845,2025 2025,2160
support. If I was, if

1661
00:46:17,685 --> 00:46:18,555
0,120 120,270 270,450 450,675 675,870
I was building a new

1662
00:46:18,555 --> 00:46:19,605
0,165 165,420 420,675 675,870 870,1050
data system scratch today, I

1663
00:46:19,605 --> 00:46:21,165
0,150 150,425 895,1140 1140,1260 1260,1560
would not do what snowflake

1664
00:46:21,165 --> 00:46:21,960
0,255 255,465 465,540 540,630 630,795
did. It was a different

1665
00:46:21,960 --> 00:46:23,265
0,320 610,885 885,1035 1035,1170 1170,1305
time. I would start with

1666
00:46:23,265 --> 00:46:24,240
0,455
postgres.|
|

1667
00:46:24,240 --> 00:46:25,365
0,135 135,380 520,840 840,1020 1020,1125
And then expand upon it
然后像迪布那样对其进行扩展。

1668
00:46:25,365 --> 00:46:26,860
0,90 90,210 210,585 585,845
the way deeb did.|
|

1669
00:46:30,180 --> 00:46:31,460
0,400
Okay.|
好吧。|

1670
00:46:32,380 --> 00:46:33,390
0,260 260,380 380,640 720,950 950,1010
Keep going, because still a
继续前进，因为还有很多事情要做。

1671
00:46:33,390 --> 00:46:35,220
0,105 105,225 225,470
lot to cover.|
|

1672
00:46:36,130 --> 00:46:37,125
0,245 245,365 365,530 530,725 725,995
In the sake of time,
为了节省时间，我将跳过输出重定向。

1673
00:46:37,125 --> 00:46:38,565
0,270 270,330 330,495 495,845 1165,1440
I'm going to skip output

1674
00:46:38,565 --> 00:46:41,000
0,455
redirection.|
|

1675
00:46:41,070 --> 00:46:41,690
0,230 230,350 350,410 410,515 515,620
Because you're not really going
因为您在家庭作业中不会真的需要它，所以让我们跳到窗口函数。

1676
00:46:41,690 --> 00:46:42,730
0,75 75,195 195,420 420,705 705,1040
to need that for the

1677
00:46:42,750 --> 00:46:45,065
0,400 1290,1625 1625,1775 1775,2045 2045,2315
homework, let's jump ahead to

1678
00:46:45,065 --> 00:46:46,440
0,225 225,545
window functions.|
|

1679
00:46:47,660 --> 00:46:49,375
0,335 335,670 1200,1475 1475,1595 1595,1715
Right. So before we showed
正确的。因此，在我们展示聚合之前，他们正在计算整个输入集与输入到的关系的一次计算。

1680
00:46:49,375 --> 00:46:54,090
0,515 1735,2025 2025,2315 3085,3665 4315,4715
aggregations, they were computing of

1681
00:46:54,230 --> 00:46:56,740
0,350 350,665 665,1270 1920,2255 2255,2510
one shot calculation across the

1682
00:46:56,740 --> 00:47:00,730
0,320 1090,1490 1930,2250 2250,2570 3670,3990
entire input set to the

1683
00:47:00,730 --> 00:47:01,795
0,240 240,405 405,510 510,720 720,1065
relation that was being inputted

1684
00:47:01,795 --> 00:47:02,840
0,150 150,425
to the.|
|

1685
00:47:02,840 --> 00:47:04,040
0,290
EM.|
嗯。|

1686
00:47:04,260 --> 00:47:06,770
0,290 290,580 1860,2120 2120,2210 2210,2510
To, to, for the aggregate
TO、TO和您正在操作的FROM子句上的聚合函数。但也有一些时候，你可能需要进行所谓的滑动计算。

1687
00:47:06,770 --> 00:47:07,865
0,260 430,675 675,855 855,990 990,1095
function that you're operating on

1688
00:47:07,865 --> 00:47:10,310
0,90 90,240 240,575 1225,1625 2005,2445
the from clause. But there's

1689
00:47:10,310 --> 00:47:11,150
0,225 225,420 420,600 600,705 705,840
also times where you may

1690
00:47:11,150 --> 00:47:12,170
0,120 120,285 285,465 465,710 790,1020
need to want to what

1691
00:47:12,170 --> 00:47:13,480
0,105 105,255 255,405 405,690 690,1310
is called a sliding calculation

1692
00:47:13,860 --> 00:47:15,060
0,400
where.|
|

1693
00:47:15,350 --> 00:47:16,795
0,260 260,365 365,470 470,730 1050,1445
Think of like a rolling
当你从一个，两个PO到下一个的时候，想象一下滚动计票。在进行扫描时，您希望更新一些、某种聚合函数，以便对于从SELECT语句输出的每个单独的两个池，聚合是处理这两个池的时间的某种快照。

1694
00:47:16,795 --> 00:47:18,145
0,540 540,765 765,930 930,1125 1125,1350
tally as you go from

1695
00:47:18,145 --> 00:47:18,940
0,270 270,510 510,630 630,705 705,795
one, two po to the

1696
00:47:18,940 --> 00:47:20,100
0,195 195,390 390,600 600,870 870,1160
next. As you're scanning along,

1697
00:47:20,420 --> 00:47:21,780
0,245 245,350 350,575 575,940 960,1360
you want to update some,

1698
00:47:21,890 --> 00:47:23,010
0,290 290,425 425,500 500,845 845,1120
some kind of aggregate function

1699
00:47:23,660 --> 00:47:24,835
0,245 245,455 455,680 680,875 875,1175
so that for every single

1700
00:47:24,835 --> 00:47:26,730
0,255 255,545 835,1185 1185,1560 1560,1895
two pool that you're output

1701
00:47:27,260 --> 00:47:28,690
0,245 245,365 365,530 530,820 1170,1430
from your select statement, the

1702
00:47:28,690 --> 00:47:30,580
0,375 375,650 1120,1365 1365,1515 1515,1890
aggregate is sort of snapshot

1703
00:47:30,580 --> 00:47:31,915
0,150 150,345 345,555 555,860 1060,1335
in time of when that

1704
00:47:31,915 --> 00:47:33,260
0,210 210,345 345,935
twople was processed.|
|

1705
00:47:33,730 --> 00:47:34,845
0,350 350,530 530,760 780,1055 1055,1115
Right the way, it's like
顺便说一句，它就像一个聚合函数，在哪里？

1706
00:47:34,845 --> 00:47:36,680
0,105 105,435 435,675 675,1055
an aggregate function where?|
|

1707
00:47:36,680 --> 00:47:37,655
0,150 150,315 315,630 630,810 810,975
You're not grouping them into
对于每两个最终输出，您不会将它们分组到单个输出中，它将对该聚合进行自己的计算。

1708
00:47:37,655 --> 00:47:38,710
0,105 105,365 415,690 690,810 810,1055
a single output for every

1709
00:47:39,630 --> 00:47:41,290
0,305 305,605 605,1000 1140,1400 1400,1660
single final output for every

1710
00:47:41,460 --> 00:47:42,500
0,500 500,740 740,800 800,890 890,1040
twople it's going to have

1711
00:47:42,500 --> 00:47:43,790
0,150 150,410 520,1050 1050,1200 1200,1290
its own computation for that

1712
00:47:43,790 --> 00:47:44,920
0,500
aggregation.|
|

1713
00:47:45,330 --> 00:47:46,025
0,260 260,350 350,425 425,545 545,695
And so the way this
因此，按照这种方式，你会有一个A函数。这将是您的所有聚合函数，Min Max，Count，Average，正如我们之前看到的，以及一些额外的函数。然后您将指定要计算此计算的范围或范围的类型，基本上是如何分割数据并获取数据来源。

1714
00:47:46,025 --> 00:47:47,045
0,195 195,345 345,435 435,660 660,1020
works, you would have like

1715
00:47:47,045 --> 00:47:49,250
0,345 345,690 690,1085 1225,1625 1945,2205
A A function here. This

1716
00:47:49,250 --> 00:47:49,880
0,90 90,165 165,270 270,375 375,630
will be all your aggregate

1717
00:47:49,880 --> 00:47:52,420
0,225 225,495 495,800 1360,1760 2140,2540
functions, min Max, count, average,

1718
00:47:52,560 --> 00:47:54,275
0,245 245,350 350,470 470,730 1440,1715
as we saw before, as

1719
00:47:54,275 --> 00:47:55,240
0,120 120,210 210,360 360,615 615,965
well as some additional ones.

1720
00:47:55,800 --> 00:47:56,600
0,275 275,425 425,590 590,650 650,800
And then you're going to

1721
00:47:56,600 --> 00:47:58,790
0,650 1270,1545 1545,1695 1695,1950 1950,2190
specify what is the sort

1722
00:47:58,790 --> 00:48:00,010
0,225 225,555 555,780 780,930 930,1220
of scope or the range

1723
00:48:00,660 --> 00:48:01,970
0,365 365,710 710,860 860,1025 1025,1310
that you're going to compute

1724
00:48:01,970 --> 00:48:03,995
0,135 135,600 600,950 1390,1785 1785,2025
this calculation for basically of

1725
00:48:03,995 --> 00:48:04,760
0,135 135,300 300,495 495,645 645,765
how to slice up the

1726
00:48:04,760 --> 00:48:06,420
0,260 460,795 795,1035 1035,1340
data and source it.|
|

1727
00:48:06,420 --> 00:48:07,480
0,90 90,225 225,500
And sort it.|
然后把它分类。|

1728
00:48:09,020 --> 00:48:10,225
0,400 420,815 815,965 965,1055 1055,1205
So let's look at some
让我们来看一些这样的例子，这样我就可以拥有我以前拥有的所有聚合函数。

1729
00:48:10,225 --> 00:48:12,310
0,210 210,375 375,635 1225,1625 1825,2085
examples like this so I

1730
00:48:12,310 --> 00:48:13,300
0,105 105,225 225,435 435,615 615,990
can have all the aggregation

1731
00:48:13,300 --> 00:48:14,190
0,240 240,405 405,495 495,615 615,890
functions that I had before.|
|

1732
00:48:16,530 --> 00:48:17,690
0,275 275,485 485,770 770,995 995,1160
Mid Max account, so forth.
MID MAX帐户，等等。但是我有这些额外的参数，比如告诉我我的工具是第几行的行号，在我的输出中还有一个等级。如果是的话，我会把它们分类的。因此，如果我有一个ORDER BY子句ORDER BY学生按GPA排序，我可以使用RANK函数告诉您您的位置。您不能使用聚合函数来做到这一点，因为有些东西会崩溃。

1733
00:48:17,690 --> 00:48:18,440
0,135 135,255 255,375 375,525 525,750
But I have these these

1734
00:48:18,440 --> 00:48:19,565
0,240 240,510 510,765 765,945 945,1125
additional ones like the row

1735
00:48:19,565 --> 00:48:20,510
0,255 255,480 480,615 615,735 735,945
number that tell me what

1736
00:48:20,510 --> 00:48:22,750
0,350 760,1160 1240,1620 1620,1920 1920,2240
row my tool is, is

1737
00:48:22,920 --> 00:48:24,635
0,275 275,530 530,910 1260,1550 1550,1715
in my output as well

1738
00:48:24,635 --> 00:48:25,625
0,135 135,270 270,495 495,690 690,990
as a rank. If I'm,

1739
00:48:25,625 --> 00:48:27,260
0,300 300,555 555,815 1045,1410 1410,1635
I'm sorting them. So if

1740
00:48:27,260 --> 00:48:28,430
0,260 340,645 645,795 795,960 960,1170
I have an order by

1741
00:48:28,430 --> 00:48:30,610
0,320 580,980 1210,1500 1500,1665 1665,2180
clause order students by gpa,

1742
00:48:30,900 --> 00:48:31,610
0,275 275,410 410,515 515,605 605,710
I can tell you what

1743
00:48:31,610 --> 00:48:33,185
0,180 180,420 420,740 1090,1410 1410,1575
your position is using the

1744
00:48:33,185 --> 00:48:36,755
0,165 165,485 2965,3240 3240,3450 3450,3570
rank function. You can't do

1745
00:48:36,755 --> 00:48:37,880
0,120 120,210 210,375 375,825 825,1125
that with a aggregation function

1746
00:48:37,880 --> 00:48:39,515
0,240 240,560 1000,1290 1290,1455 1455,1635
because there's things that get

1747
00:48:39,515 --> 00:48:40,520
0,300 300,545
collapsed down.|
|

1748
00:48:41,520 --> 00:48:42,350
0,215 215,260 260,380 380,560 560,830
So in this case here,
在本例中，在本例中，我可以从行号中选择STAR，然后是空括号，因为我没有对其进行分区。这会给我这样的输出，它会告诉我什么。

1749
00:48:42,350 --> 00:48:43,370
0,300 300,525 525,720 720,885 885,1020
this example here, I can

1750
00:48:43,370 --> 00:48:44,375
0,225 225,495 495,705 705,870 870,1005
do select star from row

1751
00:48:44,375 --> 00:48:46,295
0,275 535,935 1105,1425 1425,1710 1710,1920
number over, and then the

1752
00:48:46,295 --> 00:48:48,215
0,180 180,815 1435,1680 1680,1815 1815,1920
empty parentheses, because I'm not

1753
00:48:48,215 --> 00:48:49,670
0,435 435,695 865,1125 1125,1365 1365,1455
partitioning it. And that'll give

1754
00:48:49,670 --> 00:48:50,555
0,195 195,390 390,525 525,720 720,885
me output like this, what

1755
00:48:50,555 --> 00:48:51,900
0,180 180,360 360,665
it'll tell me.|
|

1756
00:48:51,900 --> 00:48:52,875
0,240 240,390 390,525 525,750 750,975
Again, for all my output
再说一次，对于我所有的两个输出，我在列表中的位置是什么？

1757
00:48:52,875 --> 00:48:55,040
0,425 865,1265 1315,1545 1545,1770 1770,2165
twoils, where do I appear

1758
00:48:55,390 --> 00:48:56,240
0,230 230,320 320,470 470,605 605,850
in the list for that?|
|

1759
00:48:56,960 --> 00:48:58,100
0,400
Right.|
正确的。|

1760
00:48:59,750 --> 00:49:01,040
0,400
Um.|
恩。|

1761
00:49:02,170 --> 00:49:02,970
0,260 260,380 380,500 500,605 605,800
If you have the over
如果有OVER子句，则可以在计算窗口函数时指定希望如何将表分组在一起或将两个表分组在一起，然后可以使用PARTITION BY GROUP BY来说明如何对它们进行分组。

1762
00:49:02,970 --> 00:49:04,125
0,300 300,450 450,540 540,990 990,1155
clause, you can specify how

1763
00:49:04,125 --> 00:49:05,835
0,90 90,165 165,240 240,485 1405,1710
you want to group group

1764
00:49:05,835 --> 00:49:07,245
0,285 285,600 600,900 900,1155 1155,1410
tables together or group two

1765
00:49:07,245 --> 00:49:08,565
0,365 505,825 825,1080 1080,1170 1170,1320
together when computing the window

1766
00:49:08,565 --> 00:49:10,440
0,305 805,1095 1095,1385 1465,1725 1725,1875
function, and then you can

1767
00:49:10,440 --> 00:49:11,880
0,210 210,390 390,720 720,1040 1180,1440
use the partition by a

1768
00:49:11,880 --> 00:49:13,170
0,150 150,440 670,945 945,1110 1110,1290
group by of how to

1769
00:49:13,170 --> 00:49:14,480
0,150 150,390 390,770 820,1065 1065,1310
how to group them up.|
|

1770
00:49:15,000 --> 00:49:16,550
0,400 750,995 995,1115 1115,1325 1325,1550
So for this query here
因此，对于这里的查询，我们从ROLL表中选择课程ID和学生ID。我想要得到每个学生记录在滚动表中的行号。

1771
00:49:16,550 --> 00:49:17,405
0,195 195,375 375,615 615,735 735,855
we're doing select the course

1772
00:49:17,405 --> 00:49:18,245
0,225 225,420 420,540 540,660 660,840
ID and the student ID

1773
00:49:18,245 --> 00:49:19,790
0,195 195,315 315,495 495,815 1285,1545
from the roll table. And

1774
00:49:19,790 --> 00:49:21,095
0,135 135,255 255,330 330,560 940,1305
I want to get the

1775
00:49:21,095 --> 00:49:23,330
0,285 285,605 865,1140 1140,1415 1885,2235
row number of each each

1776
00:49:23,330 --> 00:49:24,740
0,270 270,590 850,1125 1125,1260 1260,1410
student record in the roll

1777
00:49:24,740 --> 00:49:25,860
0,290
table.|
|

1778
00:49:25,860 --> 00:49:27,090
0,350 670,945 945,1065 1065,1155 1155,1230
EM, but then I want
嗯，然后我想把它按课程划分，这样我就会得到每门课程的输出。它会告诉我每个学生的ID是什么，他们在那个组中处于什么位置。

1779
00:49:27,090 --> 00:49:27,975
0,90 90,420 420,555 555,705 705,885
to partition it by course

1780
00:49:28,125 --> 00:49:29,205
0,275 595,840 840,930 930,1005 1005,1080
I'd so I would get

1781
00:49:29,205 --> 00:49:30,165
0,180 180,360 360,510 510,765 765,960
an output like this for

1782
00:49:30,165 --> 00:49:32,025
0,150 150,435 435,815 1495,1740 1740,1860
every single course. It would

1783
00:49:32,025 --> 00:49:34,470
0,165 165,455 1675,1995 1995,2250 2250,2445
tell me for every student

1784
00:49:34,470 --> 00:49:36,000
0,260 280,680 760,1095 1095,1350 1350,1530
ID what, what position they

1785
00:49:36,000 --> 00:49:37,560
0,255 255,650 700,1100 1180,1425 1425,1560
are in that in that

1786
00:49:37,560 --> 00:49:38,280
0,290
group.|
|

1787
00:49:39,130 --> 00:49:40,395
0,275 275,395 395,640 750,1085 1085,1265
A sort of cluster like
一种像这样的星团。

1788
00:49:40,395 --> 00:49:41,500
0,275
this.|
|

1789
00:49:42,810 --> 00:49:43,340
0,245 245,305 305,365 365,440 440,530
Then, if you have an
然后，如果您有一个ORDER BY子句，那么您就可以控制如何在分区内或窗口内对管进行排序。

1790
00:49:43,340 --> 00:49:44,390
0,165 165,375 375,705 705,945 945,1050
order by clause, you can

1791
00:49:44,390 --> 00:49:45,965
0,260 430,750 750,1065 1065,1350 1350,1575
then control how the tubes

1792
00:49:45,965 --> 00:49:47,795
0,90 90,240 240,755 805,1205 1495,1830
will be sorted within within

1793
00:49:47,795 --> 00:49:48,950
0,225 225,360 360,690 690,945 945,1155
either a partition or with

1794
00:49:48,950 --> 00:49:50,280
0,225 225,420 420,680
within the window.|
|

1795
00:49:50,280 --> 00:49:51,120
0,315 315,480 480,540 540,660 660,840
Right. So in this case
正确的。所以在这种情况下，现在我可以了。

1796
00:49:51,120 --> 00:49:53,000
0,290 580,885 885,1065 1065,1340
here, now I can.|
|

1797
00:49:53,040 --> 00:49:55,560
0,320 320,515 515,740 740,1090
Order the students by.|
把学生按顺序排列。|

1798
00:49:55,560 --> 00:49:56,490
0,75 75,180 180,315 315,570 570,930
But the real table, based
而是基于课程ID的真实表格。

1799
00:49:56,490 --> 00:49:57,940
0,225 225,330 330,465 465,740
on the course ID.|
|

1800
00:49:58,890 --> 00:49:59,740
0,230 230,365 365,455 455,575 575,850
So there's a more complicated
这里有一个更复杂的例子，所以我们想找出每门课成绩第二高的学生。

1801
00:49:59,760 --> 00:50:00,815
0,320 320,560 560,800 800,980 980,1055
example here, so we want

1802
00:50:00,815 --> 00:50:01,595
0,90 90,270 270,450 450,630 630,780
to find the student with

1803
00:50:01,595 --> 00:50:04,010
0,165 165,435 435,765 765,1145 2155,2415
the second highest grade for

1804
00:50:04,010 --> 00:50:05,240
0,180 180,500
each course.|
|

1805
00:50:05,420 --> 00:50:07,015
0,400 990,1235 1235,1340 1340,1475 1475,1595
So for this one here,
对于这里的这个，我们将有一个嵌套的查询，我们稍后会讨论它，但基本上我有一个SELECT语句，它有一个FROM子句，除了那个FROM子句，我还有另一个查询。

1806
00:50:07,015 --> 00:50:07,375
0,135 135,180 180,210 210,270 270,360
we're going to have a

1807
00:50:07,375 --> 00:50:08,545
0,270 270,435 435,690 690,1005 1005,1170
nested query, which we'll discuss

1808
00:50:08,545 --> 00:50:09,775
0,105 105,195 195,455 715,990 990,1230
in a second, but basically

1809
00:50:09,775 --> 00:50:11,580
0,255 255,545 955,1275 1275,1500 1500,1805
I have a select statement

1810
00:50:12,290 --> 00:50:13,210
0,260 260,365 365,485 485,665 665,920
that has a from clause,

1811
00:50:13,210 --> 00:50:14,275
0,225 225,420 420,600 600,780 780,1065
and aside that from clause,

1812
00:50:14,275 --> 00:50:15,940
0,210 210,360 360,600 600,965
I have another query.|
|

1813
00:50:15,940 --> 00:50:17,080
0,320
Right.|
正确的。|

1814
00:50:17,080 --> 00:50:18,820
0,260 280,570 570,840 840,1220 1450,1740
And I can, inside this
在这个内部查询中，我可以在这里引用IM在注册表上进行查找，然后外部查询可以根据这个嵌套查询的输出进行过滤，从而在一秒钟内覆盖嵌套查询。

1815
00:50:18,820 --> 00:50:19,920
0,210 210,495 495,705 705,840 840,1100
inner query, I can reference

1816
00:50:22,250 --> 00:50:23,515
0,305 305,680 680,935 935,1055 1055,1265
here IM doing the lookup

1817
00:50:23,515 --> 00:50:24,520
0,90 90,165 165,435 435,695 775,1005
on the enrolllled table and

1818
00:50:24,520 --> 00:50:25,435
0,90 90,210 210,420 420,735 735,915
then the outer query can

1819
00:50:25,435 --> 00:50:26,680
0,135 135,425 445,960 960,1110 1110,1245
just do filtering based on

1820
00:50:26,680 --> 00:50:28,555
0,225 225,590 790,1190 1300,1590 1590,1875
the output of this nested

1821
00:50:28,555 --> 00:50:30,190
0,275 475,875 955,1230 1230,1395 1395,1635
query going cover nest queries

1822
00:50:30,190 --> 00:50:31,080
0,75 75,165 165,410
in a second.|
|

1823
00:50:31,860 --> 00:50:32,465
0,245 245,335 335,440 440,515 515,605
So the first thing we're
所以我们要做的第一件事是，按照课程ID对这两位学生进行分组。

1824
00:50:32,465 --> 00:50:32,825
0,30 30,75 75,150 150,255 255,360
going to do is going

1825
00:50:32,825 --> 00:50:34,580
0,120 120,285 285,450 450,875 1495,1755
to group the twoils by

1826
00:50:34,580 --> 00:50:35,920
0,105 105,225 225,500
the course ID.|
|

1827
00:50:35,920 --> 00:50:37,210
0,285 285,540 540,750 750,1005 1005,1290
Uh, and then sort them
嗯，然后按年级排序，然后我们就会得到排名。他们在这类成绩表中的位置是什么？

1828
00:50:37,210 --> 00:50:38,530
0,270 270,435 435,710 940,1200 1200,1320
by the grade and then

1829
00:50:38,530 --> 00:50:39,810
0,150 150,240 240,390 390,680 880,1280
we'll get the rank. What

1830
00:50:40,130 --> 00:50:42,400
0,260 260,515 515,910 1830,2120 2120,2270
is their position in the

1831
00:50:42,400 --> 00:50:43,590
0,120 120,240 240,500 580,870 870,1190
sort of list of grades?|
|

1832
00:50:44,690 --> 00:50:45,535
0,350 350,560 560,665 665,740 740,845
Right. And then in my
正确的。然后在我的WHERE调用中，我现在可以引用。

1833
00:50:45,535 --> 00:50:46,345
0,165 165,345 345,540 540,690 690,810
where calls here I can

1834
00:50:46,345 --> 00:50:49,840
0,255 255,635 715,1115
reference now the.|
|

1835
00:50:50,120 --> 00:50:51,970
0,400 540,905 905,1130 1130,1390 1470,1850
The window, the window function
在窗口中，窗口函数计算为列。

1836
00:50:51,970 --> 00:50:54,460
0,590 1060,1425 1425,1790
calculation for column.|
|

1837
00:50:54,530 --> 00:50:55,800
0,400
Right.|
正确的。|

1838
00:50:56,000 --> 00:50:57,150
0,320 320,530 530,725 725,890 890,1150
So any questions about this?|
对此有什么问题吗？|

1839
00:51:00,360 --> 00:51:01,560
0,350 370,770 790,1170
And also like.|
也喜欢。|

1840
00:51:02,180 --> 00:51:03,640
0,350 350,575 575,850 1050,1310 1310,1460
Basically, can you make a.|
基本上，你能做一个。|

1841
00:51:05,940 --> 00:51:06,785
0,245 245,395 395,560 560,665 665,845
The question is, can I,
问题是，我能，我能用群眼制作一个窗口函数吗？

1842
00:51:06,785 --> 00:51:07,505
0,180 180,300 300,450 450,570 570,720
can I make a window

1843
00:51:07,505 --> 00:51:10,960
0,225 225,480 480,690 690,965
function using group eyes?|
|

1844
00:51:13,400 --> 00:51:14,530
0,305 305,485 485,755 755,995 995,1130
Let try it what you're
让我们试一试你说的话。

1845
00:51:14,530 --> 00:51:16,200
0,230
saying.|
|

1846
00:51:17,180 --> 00:51:18,840
0,230 230,440 440,820
All right, so.|
好吧，那么。|

1847
00:51:22,400 --> 00:51:23,560
0,255 255,570 570,920
Then sort the.|
然后对。|

1848
00:51:25,870 --> 00:51:27,520
0,320 320,640
Right, so.|
对，所以。|

1849
00:51:28,040 --> 00:51:29,620
0,290 290,440 440,940
Is in postgresql.|
是在PostgreSQL中。|

1850
00:51:30,980 --> 00:51:33,120
0,320 320,640 690,1040 1040,1390 1740,2140
Right. So again, select from
正确的。同样，从行表中选择，然后我们将获得每个学生出现的行号。

1851
00:51:33,140 --> 00:51:34,645
0,260 260,425 425,730 1050,1325 1325,1505
the row table, and then

1852
00:51:34,645 --> 00:51:35,460
0,180 180,255 255,375 375,525 525,815
we'll get the row number

1853
00:51:37,340 --> 00:51:40,000
0,290 290,500 500,820 960,1360
where each student appears.|
|

1854
00:51:40,000 --> 00:51:41,260
0,320
EM.|
嗯。|

1855
00:51:41,490 --> 00:51:43,120
0,245 245,365 365,515 515,790 1230,1630
And then the second excuse,
然后第二个理由，第二个例子，是课程ID，学生ID，然后是行号。我们将按课程ID对其进行划分。然后，我们将按课程ID对它们和输出进行排序。

1856
00:51:43,170 --> 00:51:45,380
0,260 260,455 455,740 740,1090 1950,2210
the second example, was the

1857
00:51:45,380 --> 00:51:46,955
0,150 150,440 850,1110 1110,1350 1350,1575
course ID, student ID, and

1858
00:51:46,955 --> 00:51:48,125
0,105 105,210 210,345 345,635 865,1170
then the row number. We're

1859
00:51:48,125 --> 00:51:49,030
0,45 45,150 150,450 450,630 630,905
going to partition it by

1860
00:51:49,290 --> 00:51:51,020
0,275 275,425 425,700 1080,1475 1475,1730
the course ID. So then

1861
00:51:51,020 --> 00:51:51,935
0,135 135,195 195,270 270,500 610,915
we're just going to order

1862
00:51:51,935 --> 00:51:53,405
0,305 535,795 795,990 990,1200 1200,1470
them and the output by

1863
00:51:53,405 --> 00:51:54,680
0,240 240,360 360,635
the course ID.|
|

1864
00:51:54,680 --> 00:51:55,640
0,290
Right.|
正确的。|

1865
00:51:55,640 --> 00:51:56,855
0,350 370,660 660,825 825,1005 1005,1215
So again, this case here,
再一次，这个例子，我们看到每门课有15，45，7，21和26，这是注册的学生，然后这是他们在每一组中的位置。

1866
00:51:56,855 --> 00:51:57,820
0,195 195,375 375,570 570,720 720,965
we see that we have

1867
00:51:58,410 --> 00:51:59,645
0,245 245,425 425,740 740,1025 1025,1235
for each course, fifteen, forty

1868
00:51:59,645 --> 00:52:00,680
0,240 240,465 465,660 660,870 870,1035
five, seven, twenty one and

1869
00:52:00,680 --> 00:52:02,720
0,150 150,650 1300,1710 1710,1860 1860,2040
a 26 here's the students

1870
00:52:02,720 --> 00:52:03,890
0,135 135,405 405,540 540,800 910,1170
that enroll in them, and

1871
00:52:03,890 --> 00:52:04,810
0,120 120,240 240,360 360,570 570,920
then this is their position

1872
00:52:04,950 --> 00:52:07,180
0,365 365,695 695,965 965,1270
within within each group.|
|

1873
00:52:08,740 --> 00:52:09,735
0,245 245,365 365,515 515,740 740,995
And then my last example
然后我的最后一个例子是这样的，这就是你在问你是否可以做一个小组I。

1874
00:52:09,735 --> 00:52:11,025
0,150 150,270 270,545 865,1140 1140,1290
was like this, and this

1875
00:52:11,025 --> 00:52:11,960
0,135 135,375 375,600 600,690 690,935
is where you were asking

1876
00:52:11,980 --> 00:52:12,600
0,275 275,380 380,455 455,530 530,620
whether you can do a

1877
00:52:12,600 --> 00:52:14,960
0,135 135,410
group I.|
|

1878
00:52:14,960 --> 00:52:15,830
0,165 165,285 285,495 495,720 720,870
We're now here again so
我们现在又来了，这样我就能拿到第一个。内部查询将为我获取每条记录的排名位置。我删除您在排序输出中所处的排名。

1879
00:52:15,830 --> 00:52:17,645
0,90 90,210 210,470 520,920 1480,1815
I can get the first.

1880
00:52:17,645 --> 00:52:18,455
0,195 195,375 375,600 600,720 720,810
The inner query is going

1881
00:52:18,455 --> 00:52:20,420
0,90 90,210 210,420 420,755 1585,1965
to get me the rank

1882
00:52:20,420 --> 00:52:23,105
0,380 910,1310 1480,1800 1800,2120 2440,2685
position of every record. The

1883
00:52:23,105 --> 00:52:24,245
0,245 265,540 540,660 660,900 900,1140
rank where you are in

1884
00:52:24,245 --> 00:52:27,070
0,120 120,450 450,785 2215,2520 2520,2825
the sorting output me remove.|
|

1885
00:52:28,180 --> 00:52:29,820
0,290 290,440 440,590 590,880
This part here first.|
这部分先放在这里。|

1886
00:52:30,910 --> 00:52:32,190
0,305 305,470 470,785 785,1040 1040,1280
Right. So here's, here's the
正确的。下面是SELECT排名的、的内部查询的输出。所以对于每门课程，我都会拿到分数，我会按分数排序。然后，排名就是他们所处的位置。

1887
00:52:32,190 --> 00:52:33,410
0,240 240,360 360,620 670,945 945,1220
output of the, of the,

1888
00:52:33,610 --> 00:52:34,850
0,260 260,425 425,740 740,980 980,1240
the inner query of the

1889
00:52:34,930 --> 00:52:36,620
0,305 305,610 990,1295 1295,1445 1445,1690
select rank. So for every

1890
00:52:37,000 --> 00:52:38,630
0,400 900,1220 1220,1280 1280,1370 1370,1630
course I'm going to get

1891
00:52:38,680 --> 00:52:40,500
0,400 840,1235 1235,1520 1520,1760 1760,1820
the grades and I'm going

1892
00:52:40,500 --> 00:52:41,475
0,75 75,240 240,480 480,750 750,975
to order them by the

1893
00:52:41,475 --> 00:52:42,630
0,305 535,780 780,885 885,1005 1005,1155
grades. And then the rank

1894
00:52:42,630 --> 00:52:43,710
0,150 150,315 315,555 555,825 825,1080
is just where their position

1895
00:52:43,710 --> 00:52:45,820
0,320 730,1050 1050,1370
is in the.|
|

1896
00:52:45,950 --> 00:52:47,185
0,245 245,490 660,965 965,1130 1130,1235
You know, within the sort
你知道，在等级和等级的列表中可以有重复的。因此，如果我在这里说另一条记录，则插入到已注册。

1897
00:52:47,185 --> 00:52:48,000
0,75 75,210 210,375 375,510 510,815
of list of the grades

1898
00:52:48,620 --> 00:52:49,645
0,245 245,380 380,605 605,800 800,1025
and the rank can have

1899
00:52:49,645 --> 00:52:50,730
0,285 285,375 375,435 435,665 685,1085
repeats. So if I say

1900
00:52:51,740 --> 00:52:53,430
0,305 305,560 560,890 890,1355 1355,1690
another record here, insert into

1901
00:52:54,200 --> 00:52:55,680
0,850
enrolled.|
|

1902
00:52:56,490 --> 00:52:57,950
0,400 930,1160 1160,1235 1235,1325 1325,1460
Values, so we need a
价值，所以我们需要一个学生证。

1903
00:52:57,950 --> 00:52:59,280
0,150 150,410
student ID.|
|

1904
00:52:59,740 --> 00:53:01,680
0,350 350,610
Let's do.|
我们开始吧。|

1905
00:53:03,290 --> 00:53:05,040
0,335 335,740 740,1060
Have tupac take.|
让图帕克拿下。|

1906
00:53:07,540 --> 00:53:09,560
0,400 960,1235 1235,1490 1490,1745 1745,2020
Values course I would be
当然，我会15岁，7岁，21岁，假设他得了一分。

1907
00:53:10,030 --> 00:53:12,330
0,400 690,980 980,1160 1160,1450 1980,2300
fifteen, seven, twenty one and

1908
00:53:12,330 --> 00:53:13,490
0,270 270,405 405,570 570,810 810,1160
let's say he got a.|
|

1909
00:53:15,280 --> 00:53:16,580
0,270 270,345 345,450 450,710
Let's give a name.|
让我们给它起个名字。|

1910
00:53:16,850 --> 00:53:17,860
0,90 90,350
He's dead.|
他已经死了。|

1911
00:53:23,290 --> 00:53:24,900
0,245 245,335 335,485 485,790
What do I create?|
我要创造什么？|

1912
00:53:25,760 --> 00:53:27,100
0,305 305,440 440,730 900,1175 1175,1340
That order by order by
也许是按等级排序。

1913
00:53:27,100 --> 00:53:28,320
0,210 210,530
rank, maybe.|
|

1914
00:53:28,410 --> 00:53:29,540
0,400
Well.|
井。|

1915
00:53:36,040 --> 00:53:37,065
0,365 365,635 635,815 815,920 920,1025
That that screws out the
那就把隔板拧坏了，真抱歉。

1916
00:53:37,065 --> 00:53:38,760
0,305 355,630 630,905
partition that sorry.|
|

1917
00:53:39,880 --> 00:53:41,200
0,320 320,640
Right, so.|
对，所以。|

1918
00:53:42,150 --> 00:53:43,120
0,260 260,365 365,500 500,650 650,970
Here what we're doing is
在这里，我们正在做的是每一门课程，再一次，我们正在获得分数和排名。所以我们在这里插入了这张记录，Tupac，我们给了一个a，但还有另一个学生。

1919
00:53:44,250 --> 00:53:46,205
0,400 540,940 1170,1505 1505,1745 1745,1955
every single course, again, we're

1920
00:53:46,205 --> 00:53:47,990
0,150 150,330 330,555 555,905 1525,1785
getting the grade and in

1921
00:53:47,990 --> 00:53:49,715
0,120 120,380 640,915 915,1190 1480,1725
the rank. And so we

1922
00:53:49,715 --> 00:53:51,160
0,300 300,420 420,645 645,945 945,1445
inserted this record here, tupac,

1923
00:53:51,390 --> 00:53:52,460
0,260 260,395 395,545 545,820 840,1070
we gave an a, but

1924
00:53:52,460 --> 00:53:53,440
0,60 60,240 240,450 450,645 645,980
there was also another student.|
|

1925
00:53:54,060 --> 00:53:54,735
0,165 165,330 330,465 465,570 570,675
Who got an a in
他们在同一个班得到了a，因此他们都有相同的排名一的位置。

1926
00:53:54,735 --> 00:53:55,980
0,90 90,240 240,545 775,1080 1080,1245
the same class and therefore

1927
00:53:55,980 --> 00:53:56,715
0,135 135,285 285,435 435,570 570,735
they both have the same

1928
00:53:56,715 --> 00:53:58,360
0,240 240,495 495,705 705,995
rank position of one.|
|

1929
00:53:58,400 --> 00:53:59,695
0,275 275,545 545,890 890,1130 1130,1295
And then for the student
对于拿到c的学生，他们的坡道位置是3，所以你可以有重复的排名。行号则不会。

1930
00:53:59,695 --> 00:54:01,015
0,135 135,300 300,480 480,755 1015,1320
that got the c, their

1931
00:54:01,015 --> 00:54:02,605
0,240 240,525 525,825 825,1175 1315,1590
ramp position is three, so

1932
00:54:02,605 --> 00:54:03,520
0,180 180,330 330,420 420,540 540,915
rank you can have duplicates.

1933
00:54:03,520 --> 00:54:04,920
0,165 165,360 360,525 525,770
Row numbers will not.|
|

1934
00:54:07,240 --> 00:54:08,415
0,245 245,380 380,575 575,845 845,1175
So yeah, so you're proposing
所以是的，所以你打算做什么？一群随机的人？

1935
00:54:08,415 --> 00:54:09,525
0,150 150,270 270,545 715,990 990,1110
to do what? Bunch of

1936
00:54:09,525 --> 00:54:11,540
0,165 165,485
random group?|
|

1937
00:54:11,940 --> 00:54:14,080
0,400
Where?|
哪里?|

1938
00:54:15,760 --> 00:54:16,785
0,275 275,395 395,545 545,800 800,1025
And the inner query, or
内心的质疑，还是什么？抱歉的。

1939
00:54:16,785 --> 00:54:18,100
0,255 255,605
what? Sorry.|
|

1940
00:54:19,070 --> 00:54:20,545
0,260 260,520 540,860 860,1180 1230,1475
So basically like try, is
因此，基本上像Try一样，是否可以使用组BU重新创建相同的查询？

1941
00:54:20,545 --> 00:54:22,015
0,120 120,315 315,510 510,1055 1105,1470
it possible to recreate same

1942
00:54:22,015 --> 00:54:23,840
0,395 535,870 870,1095 1095,1385
query using group bu?|
|

1943
00:54:24,300 --> 00:54:25,055
0,260 260,395 395,530 530,650 650,755
The question is, is it
问题是，是否可以使用GROUP BY重新创建相同的查询？

1944
00:54:25,055 --> 00:54:25,730
0,120 120,225 225,450 450,555 555,675
possible to recreate the same

1945
00:54:25,730 --> 00:54:28,260
0,210 210,435 435,615 615,890
query using group by?|
|

1946
00:54:29,200 --> 00:54:30,180
0,275 275,575 575,755 755,920 920,980
You wouldn't. You wouldn't be
你不会的。你不会拿到军衔的。

1947
00:54:30,180 --> 00:54:30,830
0,75 75,150 150,225 225,360 360,650
able to get the rank.|
|

1948
00:54:32,260 --> 00:54:32,895
0,245 245,335 335,500 500,560 560,635
Because you wouldn't be able
因为你不能得到我的排序位置是什么？没有这方面的概念。

1949
00:54:32,895 --> 00:54:34,065
0,135 135,375 375,725 835,1080 1080,1170
to get what what is

1950
00:54:34,065 --> 00:54:35,355
0,150 150,390 390,675 675,900 900,1290
my sort position? There isn't

1951
00:54:35,355 --> 00:54:37,400
0,300 300,600 600,870 870,1145 1645,2045
a concept of that in.|
|

1952
00:54:38,440 --> 00:54:40,500
0,400 930,1480
In sql.|
在SQL中。|

1953
00:54:41,240 --> 00:54:43,675
0,400 630,1030 1410,1810 1920,2195 2195,2435
Right. So row number is
正确的。所以行号很有趣，因为它很有趣。

1954
00:54:43,675 --> 00:54:45,660
0,300 300,570 570,765 765,1025
interesting because it is.|
|

1955
00:54:46,620 --> 00:54:47,930
0,270 270,360 360,600 600,945 945,1310
Let's do that row number.|
让我们来做那个行号吧。|

1956
00:54:56,260 --> 00:54:57,625
0,210 210,330 330,710 970,1245 1245,1365
Make the pointer switch a
使指针切换为行号、行号。

1957
00:54:57,625 --> 00:54:59,780
0,120 120,375 375,755 1045,1445
row number, row number.|
|

1958
00:55:00,990 --> 00:55:02,075
0,245 245,365 365,515 515,770 770,1085
So row number is interesting
所以行号很有趣，因为它叫它排名，但相信我，它是行号。

1959
00:55:02,075 --> 00:55:04,145
0,335 985,1620 1620,1740 1740,1890 1890,2070
because it's calling it rank,

1960
00:55:04,145 --> 00:55:05,210
0,305 445,720 720,825 825,960 960,1065
but trust me, it's row

1961
00:55:05,210 --> 00:55:05,960
0,260
number.|
|

1962
00:55:06,090 --> 00:55:08,405
0,275 275,550 750,1150 1740,2105 2105,2315
It because again it's bag
这是因为它又是袋子代数。在这些关系中没有排序顺序，这是一个奇怪的概念。我们对编程的思考是这样的：你在那里是什么意思？没有排序，因为我们习惯于编程，在X86下，有排序，内存操作是如何发生的，这里没有任何这些。任何东西都可以是无序的。所以如果没有窗口函数，你就不能得到行号，因为没有办法说我在这个位置，在我的位置，我的输出中，在哪里。

1963
00:55:08,405 --> 00:55:09,845
0,525 525,750 750,945 945,1200 1200,1440
algebra. There is no sort

1964
00:55:09,845 --> 00:55:11,020
0,255 255,510 510,675 675,855 855,1175
order in in these relations

1965
00:55:11,190 --> 00:55:11,885
0,230 230,365 365,455 455,575 575,695
and that's a sort of

1966
00:55:11,885 --> 00:55:13,340
0,195 195,515 925,1185 1185,1305 1305,1455
weird concept. We think about

1967
00:55:13,340 --> 00:55:14,180
0,285 285,600 600,750 750,795 795,840
programming like what do you

1968
00:55:14,180 --> 00:55:15,400
0,90 90,300 300,570 570,720 720,1220
mean there? There's not ordering

1969
00:55:15,600 --> 00:55:16,310
0,245 245,335 335,470 470,575 575,710
like because we're used to

1970
00:55:16,310 --> 00:55:17,720
0,255 255,570 570,780 780,945 945,1410
programming and under X 86

1971
00:55:17,720 --> 00:55:20,015
0,210 210,470 1450,1905 1905,2055 2055,2295
where there ordering, how memory

1972
00:55:20,015 --> 00:55:21,890
0,360 360,755 1225,1485 1485,1740 1740,1875
operations occur, there isn't any

1973
00:55:21,890 --> 00:55:22,730
0,135 135,270 270,525 525,750 750,840
of that here. Everything can

1974
00:55:22,730 --> 00:55:25,895
0,90 90,650 1000,1400 2590,2940 2940,3165
be unordered. So without a

1975
00:55:25,895 --> 00:55:27,170
0,210 210,510 510,795 795,1155 1155,1275
window function you can't get

1976
00:55:27,170 --> 00:55:28,220
0,135 135,315 315,600 600,855 855,1050
a row number because there's

1977
00:55:28,220 --> 00:55:29,540
0,195 195,530 640,900 900,1095 1095,1320
no way to say where

1978
00:55:29,540 --> 00:55:31,085
0,135 135,360 360,740 1060,1335 1335,1545
do I exist in this

1979
00:55:31,085 --> 00:55:32,630
0,335 445,690 690,840 840,1145 1195,1545
position, in my position, my

1980
00:55:32,630 --> 00:55:33,280
0,350
output.|
|

1981
00:55:33,610 --> 00:55:34,920
0,400
Um.|
恩。|

1982
00:55:35,100 --> 00:55:36,620
0,590 590,890 890,1145 1145,1325 1325,1520
Oracle does have row number.
Oracle确实有行号。他们对你隐瞒了这件事。你可以得到它，但就像它是。

1983
00:55:36,620 --> 00:55:37,445
0,195 195,345 345,480 480,600 600,825
They hide it from you.

1984
00:55:37,445 --> 00:55:38,285
0,255 255,435 435,585 585,720 720,840
You can get it, but

1985
00:55:38,285 --> 00:55:39,460
0,150 150,545
like it's.|
|

1986
00:55:39,980 --> 00:55:41,040
0,320 320,410 410,500 500,785 785,1060
That's just an Oracle thing.|
这只是甲骨文的事情。|

1987
00:55:42,710 --> 00:55:44,130
0,320 320,635 635,905 905,1100 1100,1420
So, so the window functions
因此，窗函数允许您对平均值和所有其他聚合进行条件调整。它允许你以一种你不能以其他方式做到的方式来获得事物的顺序。

1988
00:55:44,210 --> 00:55:45,715
0,320 320,560 560,880 960,1295 1295,1505
allow you to condition doing

1989
00:55:45,715 --> 00:55:46,930
0,255 255,780 780,945 945,1110 1110,1215
the averages and all the

1990
00:55:46,930 --> 00:55:48,415
0,105 105,590 700,960 960,1170 1170,1485
other aggregates. It allows you

1991
00:55:48,415 --> 00:55:50,530
0,365 1075,1395 1395,1605 1605,1845 1845,2115
to get the order of

1992
00:55:50,530 --> 00:55:51,550
0,320 400,645 645,750 750,900 900,1020
things in a way that

1993
00:55:51,550 --> 00:55:52,150
0,120 120,285 285,420 420,510 510,600
you would not be able

1994
00:55:52,150 --> 00:55:53,480
0,90 90,165 165,255 255,500
to do it otherwise.|
|

1995
00:56:03,310 --> 00:56:04,230
0,245 245,350 350,500 500,665 665,920
So I should showed nessa
因此，我应该在前面展示Nessa的查询，但它们只是经过了更多的细节。Nessa查询，嵌套查询，一个非常强大的概念，有时称为子查询，它允许您在查询内有一个查询在查询内，在总体调用查询内有多个查询。

1996
00:56:04,230 --> 00:56:05,190
0,300 300,510 510,720 720,855 855,960
queries before, but they just

1997
00:56:05,190 --> 00:56:06,410
0,120 120,315 315,600 600,885 885,1220
go through more more detail.

1998
00:56:06,730 --> 00:56:08,085
0,290 290,455 455,740 740,1030 1080,1355
So a nessa query, nest

1999
00:56:08,085 --> 00:56:09,200
0,210 210,315 315,495 495,765 765,1115
queries, a really powerful concept,

2000
00:56:09,700 --> 00:56:11,400
0,350 350,605 605,785 785,1240 1380,1700
sometimes called sub queries, where

2001
00:56:11,400 --> 00:56:12,290
0,180 180,360 360,525 525,630 630,890
it allows you to have

2002
00:56:12,940 --> 00:56:14,115
0,320 320,670 690,935 935,1040 1040,1175
a query inside of a

2003
00:56:14,115 --> 00:56:15,480
0,240 240,575 985,1230 1230,1305 1305,1365
query inside inside of a

2004
00:56:15,480 --> 00:56:16,620
0,210 210,405 405,540 540,780 780,1140
query, you have multiple queries

2005
00:56:16,620 --> 00:56:18,620
0,165 165,440 670,1290 1290,1500 1500,2000
inside of overarching calling queries.|
|

2006
00:56:19,220 --> 00:56:19,970
0,105 105,225 225,345 345,540 540,750
And you would need this
你需要这个，因为你想要表达某些计算。如果没有这些嵌套查询，就很难表达某些计算，除非取出数据，进行一些计算，然后将其放回数据库系统中。因此，它允许我们把这些东西放在一起，创造出更复杂的逻辑，而不是其他方式。

2007
00:56:19,970 --> 00:56:20,345
0,135 135,210 210,270 270,330 330,375
because you want to be

2008
00:56:20,345 --> 00:56:22,000
0,90 90,365 445,795 795,1065 1065,1655
able to express certain computations.

2009
00:56:22,890 --> 00:56:23,690
0,260 260,350 350,500 500,665 665,800
It would be difficult to

2010
00:56:23,690 --> 00:56:25,025
0,165 165,330 330,750 750,1080 1080,1335
express certain computations without these

2011
00:56:25,025 --> 00:56:26,765
0,285 285,695 955,1320 1320,1590 1590,1740
nested queries without taking the

2012
00:56:26,765 --> 00:56:28,130
0,150 150,455 595,870 870,1005 1005,1365
data out, doing some computation

2013
00:56:28,130 --> 00:56:28,925
0,210 210,315 315,450 450,570 570,795
and then putting it back

2014
00:56:28,925 --> 00:56:30,380
0,255 255,375 375,570 570,905 1225,1455
in the database system. So

2015
00:56:30,380 --> 00:56:31,040
0,75 75,255 255,450 450,555 555,660
it allows us to put

2016
00:56:31,040 --> 00:56:32,800
0,135 135,330 330,615 615,980 1360,1760
these things together to create

2017
00:56:33,150 --> 00:56:35,710
0,400 510,910 1320,1720 2040,2300 2300,2560
more complex logic than we

2018
00:56:35,760 --> 00:56:36,470
0,275 275,425 425,530 530,620 620,710
would not be able to

2019
00:56:36,470 --> 00:56:37,580
0,210 210,590
otherwise do.|
|

2020
00:56:37,800 --> 00:56:38,840
0,260 260,395 395,590 590,890 890,1040
And these inner queries can
这些内部查询几乎可以出现在SELECT磁带中的任何地方，但实际上，像SELECT输出中的任何查询，FROM子句，WHERE子句，都可以放入UPDATE查询和删除查询，对吧。

2021
00:56:38,840 --> 00:56:40,580
0,290 400,800 850,1250 1360,1635 1635,1740
appear almost anywhere inside of

2022
00:56:40,580 --> 00:56:42,005
0,230 370,675 675,840 840,1100 1150,1425
a select tape, but actually

2023
00:56:42,005 --> 00:56:43,520
0,275 295,600 600,935 1165,1425 1425,1515
really any query like you

2024
00:56:43,520 --> 00:56:44,255
0,75 75,195 195,315 315,450 450,735
can have in the select

2025
00:56:44,255 --> 00:56:45,350
0,285 285,450 450,630 630,900 900,1095
output, the from clause, the

2026
00:56:45,350 --> 00:56:46,700
0,165 165,500 880,1140 1140,1245 1245,1350
where clause, you can put

2027
00:56:46,700 --> 00:56:47,930
0,195 195,435 435,825 825,1035 1035,1230
an update queries and delete

2028
00:56:47,930 --> 00:56:49,720
0,500 760,1160
queries, right.|
|

2029
00:56:50,390 --> 00:56:51,355
0,290 290,425 425,545 545,740 740,965
And they can now reference
现在，它们可以引用您自己的查询中的所有表。这是一个非常强大的构造。

2030
00:56:51,355 --> 00:56:52,495
0,165 165,300 300,575 595,915 915,1140
all the tables within your

2031
00:56:52,495 --> 00:56:53,935
0,165 165,455 925,1215 1215,1275 1275,1440
own query. It's a very

2032
00:56:53,935 --> 00:56:55,680
0,335 475,875
powerful construct.|
|

2033
00:56:55,680 --> 00:56:56,445
0,210 210,285 285,495 495,690 690,765
So the basic idea is
所以基本的想法是这样的。在这里，我们从名称表中进行选择，然后我想要获取至少注册了一门课程的学生的姓名。所以你可以想到这一点，这是顶部的选择器。这称为外部查询。然后这个内部部分，我们称之为内部查询。

2034
00:56:56,445 --> 00:56:57,560
0,135 135,285 285,540 540,825 825,1115
something like this. So here

2035
00:56:57,610 --> 00:56:58,785
0,275 275,440 440,790 810,1070 1070,1175
we're doing select from the

2036
00:56:58,785 --> 00:57:00,540
0,165 165,485 1015,1290 1290,1530 1530,1755
name table and then I

2037
00:57:00,540 --> 00:57:02,910
0,105 105,210 210,470 2020,2250 2250,2370
want to get the name

2038
00:57:02,910 --> 00:57:03,840
0,120 120,240 240,530 550,810 810,930
of a student that is

2039
00:57:03,840 --> 00:57:05,100
0,105 105,225 225,780 780,1050 1050,1260
at least enrolled in one

2040
00:57:05,100 --> 00:57:06,915
0,320 640,1040 1360,1605 1605,1710 1710,1815
course. So you can think

2041
00:57:06,915 --> 00:57:08,250
0,105 105,315 315,600 600,935 1045,1335
of this out, this select

2042
00:57:08,250 --> 00:57:09,090
0,180 180,330 330,465 465,630 630,840
der in the top part.

2043
00:57:09,090 --> 00:57:10,100
0,255 255,375 375,495 495,660 660,1010
That's called the outer query.

2044
00:57:10,330 --> 00:57:11,520
0,260 260,520 570,845 845,1010 1010,1190
And then this inner part

2045
00:57:11,520 --> 00:57:12,150
0,165 165,285 285,390 390,495 495,630
here, we would call this

2046
00:57:12,150 --> 00:57:13,260
0,180 180,500
inner query.|
|

2047
00:57:13,670 --> 00:57:14,820
0,400
So.|
所以。|

2048
00:57:14,950 --> 00:57:17,520
0,485 485,860 860,1150 1410,2260 2280,2570
Ner queries are notoriously difficult
众所周知，数据库系统很难优化NER查询，因为您认为执行此查询最愚蠢的方法是，对于我的学生表中的每个TIL，重新运行这个程序。

2049
00:57:17,520 --> 00:57:18,860
0,150 150,375 375,675 675,930 930,1340
for database systems to optimize,

2050
00:57:21,070 --> 00:57:22,005
0,260 260,380 380,530 530,725 725,935
because you think about the

2051
00:57:22,005 --> 00:57:22,965
0,300 300,405 405,600 600,810 810,960
stupidest way to execute this

2052
00:57:22,965 --> 00:57:24,390
0,210 210,375 375,635 955,1215 1215,1425
query would be for every

2053
00:57:24,390 --> 00:57:25,920
0,300 300,705 705,900 900,1190 1210,1530
single til in my student

2054
00:57:25,920 --> 00:57:28,220
0,320 760,1275 1275,1530 1530,1850
table, rerun this thing.|
|

2055
00:57:29,040 --> 00:57:29,795
0,260 260,380 380,500 500,605 605,755
Get the list of all
获取所有学生ID的列表，然后计算int。

2056
00:57:29,795 --> 00:57:31,265
0,180 180,315 315,845 865,1170 1170,1470
the student IDs, then compute

2057
00:57:31,265 --> 00:57:32,220
0,120 120,365
the int.|
|

2058
00:57:32,510 --> 00:57:33,595
0,245 245,365 365,500 500,760 810,1085
The way to really execute
真正执行此操作的方法是，这只是本例的连接。

2059
00:57:33,595 --> 00:57:34,435
0,150 150,390 390,615 615,720 720,840
this is this is just

2060
00:57:34,435 --> 00:57:35,640
0,165 165,455 595,840 840,945 945,1205
a join for this one

2061
00:57:35,810 --> 00:57:38,140
0,335 335,670
example here.|
|

2062
00:57:38,140 --> 00:57:39,145
0,255 255,450 450,600 600,780 780,1005
This one's easy to do
这个很容易做，因为，呃，你知道，你正在寻找这个，这个东西来匹配这里的东西。因此，您可以将其转换为质量谓词。当内部查询和adQuery之间存在非平凡的关系时，事情会变得更加复杂。我们不会我们会，我们会在本学期晚些时候讨论这个，但是。

2063
00:57:39,145 --> 00:57:41,290
0,365 475,875 1705,1935 1935,2010 2010,2145
because, eh, you know, you're

2064
00:57:41,290 --> 00:57:42,310
0,135 135,315 315,570 570,840 840,1020
looking for this, this thing

2065
00:57:42,310 --> 00:57:43,825
0,150 150,330 330,615 615,980 1270,1515
to match something here. So

2066
00:57:43,825 --> 00:57:45,025
0,90 90,210 210,485 835,1080 1080,1200
you can do convert that

2067
00:57:45,025 --> 00:57:46,660
0,105 105,210 210,435 435,995 1315,1635
to a quality predicate. Things

2068
00:57:46,660 --> 00:57:48,390
0,180 180,330 330,620 850,1155 1155,1730
get more complicated when there's

2069
00:57:48,950 --> 00:57:50,245
0,350 350,680 680,935 935,1190 1190,1295
non trivial relations between the

2070
00:57:50,245 --> 00:57:51,180
0,135 135,315 315,405 405,465 465,935
inner query and the adquery.

2071
00:57:51,380 --> 00:57:53,095
0,260 260,610 840,1220 1220,1520 1520,1715
We won't we'll, we'll come

2072
00:57:53,095 --> 00:57:53,695
0,120 120,240 240,405 405,525 525,600
into that later in the

2073
00:57:53,695 --> 00:57:54,860
0,270 270,635
semester, but.|
|

2074
00:57:55,420 --> 00:57:58,430
0,275 275,425 425,700 2460,2735 2735,3010
This is something is the
这是数据库系统中最难的，唯一正确嵌套查询的系统是名为umbra的系统，这是德国的一个学术系统。Dee b现在做得很正确，原因有两个。一是因为他们抄袭了什么。

2075
00:57:58,690 --> 00:58:00,810
0,490 600,875 875,1085 1085,1420 1800,2120
hardest of database systems and

2076
00:58:00,810 --> 00:58:02,060
0,180 180,435 435,735 735,945 945,1250
the only system that does

2077
00:58:02,500 --> 00:58:04,290
0,275 275,395 395,650 650,970 1440,1790
nest of queries correctly is

2078
00:58:04,290 --> 00:58:06,045
0,225 225,435 435,660 660,1160 1510,1755
the system called umbra, which

2079
00:58:06,045 --> 00:58:08,430
0,105 105,365 1675,2010 2010,2235 2235,2385
is a academic system out

2080
00:58:08,430 --> 00:58:11,490
0,120 120,380 2020,2550 2550,2805 2805,3060
of Germany. Dee b does

2081
00:58:11,490 --> 00:58:12,945
0,210 210,495 495,860 1030,1305 1305,1455
it correctly now for two

2082
00:58:12,945 --> 00:58:14,600
0,275 325,675 675,915 915,1125 1125,1655
reasons. One, because they copied

2083
00:58:14,620 --> 00:58:15,480
0,400
what.|
|

2084
00:58:15,480 --> 00:58:16,850
0,375 375,650 700,975 975,1095 1095,1370
Umbra did it in papers.
本影在报纸上做到了。这并不是说他们偷走了创意。然后我们上个学期也给他们寄了7，21个补丁，所以我们为他们修复了它。他们可以用侧向吃水正确地执行其中一些嵌套查询。D DB可能是对这一点的最好模仿。很多时候，有一堆启发式的黑客。同样，我们将在稍后讨论这个问题。

2085
00:58:17,200 --> 00:58:17,940
0,275 275,350 350,455 455,560 560,740
It's not like they stole

2086
00:58:17,940 --> 00:58:19,695
0,150 150,440 1240,1500 1500,1620 1620,1755
the ideas. And then we

2087
00:58:19,695 --> 00:58:20,535
0,135 135,240 240,360 360,690 690,840
also sent them patches last

2088
00:58:20,535 --> 00:58:21,300
0,225 225,360 360,450 450,585 585,765
semester out of seven, twenty

2089
00:58:21,300 --> 00:58:22,185
0,225 225,405 405,540 540,720 720,885
one, so we fixed it

2090
00:58:22,185 --> 00:58:23,660
0,135 135,395 775,1050 1050,1200 1200,1475
for them. They can do

2091
00:58:23,890 --> 00:58:24,750
0,245 245,320 320,410 410,560 560,860
some of these nest queries

2092
00:58:24,750 --> 00:58:27,930
0,290 730,1020 1020,1320 1320,1700 2890,3180
correctly with lateral drawins. D

2093
00:58:27,930 --> 00:58:28,590
0,195 195,300 300,450 450,570 570,660
DB is probably the best

2094
00:58:28,590 --> 00:58:29,910
0,390 390,540 540,800 940,1200 1200,1320
imitation of this. A lot

2095
00:58:29,910 --> 00:58:30,450
0,120 120,270 270,435 435,465 465,540
of times there's a bunch

2096
00:58:30,450 --> 00:58:32,970
0,105 105,620 1030,1670 1960,2295 2295,2520
of heuristics hacks. Again, we'll

2097
00:58:32,970 --> 00:58:33,960
0,120 120,270 270,530
cover this later.|
|

2098
00:58:34,910 --> 00:58:35,725
0,275 275,470 470,590 590,725 725,815
My sql was always the
我的SQL总是最差的。不过，情况已经好多了。所以这里有一个类似这样的查询。我们想要得到写在15,445中的学生的名字，所以我们有一个外部查询，我们说我们想要从学生表中获得名字，然后我们想要这个WHERE子句。我们想要指定一个逻辑，它会让我们得到参加445课程的那组人的学生号，所以这是一种思考你想要如何实际构建它的方法。从外部查询开始，即您希望输出的总体计算是什么，然后计算出内部部分需要单独是什么。

2099
00:58:35,725 --> 00:58:36,805
0,245 325,645 645,765 765,930 930,1080
worst. It's gotten much better

2100
00:58:36,805 --> 00:58:40,390
0,275 1705,2105 3115,3405 3405,3465 3465,3585
though. So here's a query

2101
00:58:40,390 --> 00:58:41,035
0,135 135,330 330,510 510,600 600,645
like this. We want to

2102
00:58:41,035 --> 00:58:41,635
0,60 60,165 165,330 330,480 480,600
get the name of the

2103
00:58:41,635 --> 00:58:43,000
0,240 240,525 525,825 825,1140 1140,1365
students wrote in fifteen, four

2104
00:58:43,000 --> 00:58:44,310
0,180 180,470 760,990 990,1065 1065,1310
forty five, so we have

2105
00:58:44,330 --> 00:58:45,910
0,260 260,470 470,850 1200,1460 1460,1580
the outer query that we

2106
00:58:45,910 --> 00:58:46,735
0,260 310,570 570,675 675,750 750,825
say we want to get

2107
00:58:46,735 --> 00:58:47,380
0,75 75,210 210,360 360,480 480,645
the name from the student

2108
00:58:47,380 --> 00:58:48,610
0,290 670,930 930,1050 1050,1155 1155,1230
table and then we want

2109
00:58:48,610 --> 00:58:49,375
0,60 60,135 135,270 270,495 495,765
to have this where clause.

2110
00:58:49,375 --> 00:58:50,335
0,150 150,225 225,330 330,765 765,960
We want to specify the

2111
00:58:50,335 --> 00:58:51,850
0,275 475,875 895,1200 1200,1365 1365,1515
logic that will get us

2112
00:58:51,850 --> 00:58:53,665
0,240 240,450 450,710 1300,1620 1620,1815
the student ID of the

2113
00:58:53,665 --> 00:58:54,235
0,120 120,210 210,330 330,450 450,570
set of people that are

2114
00:58:54,235 --> 00:58:55,840
0,275 475,735 735,900 900,1205 1375,1605
taking four forty five, so

2115
00:58:55,840 --> 00:58:56,335
0,45 45,105 105,210 210,360 360,495
this is a way to

2116
00:58:56,335 --> 00:58:56,965
0,90 90,195 195,330 330,480 480,630
sort of think about how

2117
00:58:56,965 --> 00:58:57,955
0,120 120,270 270,540 540,795 795,990
you want actually construct this.

2118
00:58:57,955 --> 00:58:58,645
0,150 150,240 240,315 315,465 465,690
Start with the outer query

2119
00:58:58,645 --> 00:59:00,790
0,120 120,225 225,330 330,935 1615,2145
of what the overarching computation

2120
00:59:00,790 --> 00:59:01,450
0,120 120,285 285,465 465,555 555,660
of the output you want

2121
00:59:01,450 --> 00:59:02,455
0,105 105,350 550,795 795,885 885,1005
to be and then you

2122
00:59:02,455 --> 00:59:03,400
0,150 150,330 330,525 525,720 720,945
figure out what the inner

2123
00:59:03,400 --> 00:59:05,040
0,225 225,405 405,525 525,770 1000,1640
part needs to be separately.|
|

2124
00:59:05,650 --> 00:59:06,435
0,215 215,260 260,365 365,545 545,785
So in this case here,
在本例中，我们可以将这里的英语部分转换为这样的查询，但现在我们需要能够在外部查询的WHERE子句中引用它或执行我们想要的检查，并使用之前的INK子句。

2125
00:59:06,435 --> 00:59:07,530
0,180 180,360 360,585 585,825 825,1095
we can convert this English

2126
00:59:07,530 --> 00:59:10,185
0,225 225,530 670,1070 1240,1640 2350,2655
part here into a query

2127
00:59:10,185 --> 00:59:11,565
0,150 150,425 805,1065 1065,1230 1230,1380
like this, but now we

2128
00:59:11,565 --> 00:59:11,940
0,75 75,135 135,180 180,255 255,375
need to be able to

2129
00:59:11,940 --> 00:59:14,565
0,225 225,590 940,1340 1780,2180 2320,2625
reference it or do the

2130
00:59:14,565 --> 00:59:15,780
0,180 180,300 300,420 420,695 955,1215
check that we want in

2131
00:59:15,780 --> 00:59:16,425
0,105 105,240 240,450 450,570 570,645
the where clause of the

2132
00:59:16,425 --> 00:59:17,940
0,165 165,515 865,1140 1140,1290 1290,1515
outer query and we use

2133
00:59:17,940 --> 00:59:19,470
0,350 400,735 735,915 915,1220 1270,1530
that ink clause that we

2134
00:59:19,470 --> 00:59:20,500
0,120 120,380
had before.|
|

2135
00:59:21,560 --> 00:59:22,560
0,230 230,320 320,470 470,680 680,1000
So in this case here,
所以在这个例子中，现在我们看到学生ID在。

2136
00:59:23,360 --> 00:59:24,385
0,320 320,515 515,665 665,800 800,1025
now we see that the

2137
00:59:24,385 --> 00:59:26,640
0,255 255,545 775,1095 1095,1415
student ID in the.|
|

2138
00:59:26,640 --> 00:59:27,690
0,210 210,450 450,720 720,930 930,1050
In this where clause, here
在这个WHERE子句中，下面是引用添加查询中的学生ID的添加查询，但内部查询中的第二个学生ID引用了、中、注册表中的学生ID。

2139
00:59:27,690 --> 00:59:28,560
0,75 75,150 150,285 285,540 540,870
are the add query that's

2140
00:59:28,560 --> 00:59:29,760
0,375 375,525 525,660 660,915 915,1200
referencing the student ID from

2141
00:59:29,760 --> 00:59:31,200
0,270 270,495 495,660 660,1010 1180,1440
the the add query, but

2142
00:59:31,200 --> 00:59:32,235
0,150 150,405 405,645 645,855 855,1035
the second student ID in

2143
00:59:32,235 --> 00:59:33,645
0,90 90,240 240,575 655,1035 1035,1410
the inner query, that's referencing

2144
00:59:33,645 --> 00:59:34,710
0,150 150,285 285,545 595,870 870,1065
the student ID in the,

2145
00:59:34,710 --> 00:59:35,940
0,315 315,630 630,795 795,900 900,1230
in the, in the enroll

2146
00:59:35,940 --> 00:59:36,840
0,320
table.|
|

2147
00:59:36,840 --> 00:59:39,045
0,330 330,680 820,1460 1630,1995 1995,2205
So the parser in the
因此，数据库系统中的解析器足够智能，能够识别列被引用的上下文，从而知道您正在查看的是哪个表。

2148
00:59:39,045 --> 00:59:39,930
0,150 150,360 360,585 585,765 765,885
database system is smart enough

2149
00:59:39,930 --> 00:59:41,655
0,105 105,350 850,1140 1140,1430 1450,1725
to recognize the context of

2150
00:59:41,655 --> 00:59:42,735
0,225 225,495 495,735 735,915 915,1080
where a column is being

2151
00:59:42,735 --> 00:59:45,110
0,545 625,930 930,1235 1555,1955 1975,2375
referenced to know which table

2152
00:59:45,430 --> 00:59:46,740
0,320 320,455 455,760
you're looking at.|
|

2153
00:59:46,780 --> 00:59:48,030
0,245 245,335 335,545 545,910 990,1250
In the cases where it
在它不知道两个事物具有相同名称的情况下，它将抛出一个错误，并使您限定列所在的表名。

2154
00:59:48,030 --> 00:59:49,860
0,240 240,465 465,830 1360,1650 1650,1830
doesn't know that two things

2155
00:59:49,860 --> 00:59:51,075
0,135 135,240 240,390 390,680 790,1215
have the same name, it'll

2156
00:59:51,075 --> 00:59:52,350
0,150 150,270 270,420 420,725 1015,1275
throw an error and make

2157
00:59:52,350 --> 00:59:54,680
0,135 135,680 1510,1800 1800,2010 2010,2330
you qualify the table name

2158
00:59:54,880 --> 00:59:55,935
0,305 305,530 530,740 740,890 890,1055
where a column is coming

2159
00:59:55,935 --> 00:59:56,840
0,305
from.|
|

2160
00:59:58,820 --> 00:59:59,560
0,275 275,440 440,485 485,575 575,740
So there's a bunch different
因此，您可以通过多种不同的方式与Nesta查询进行交互。您可以设置WHERE子句，这样您就可以拥有嵌套查询中的每一行都必须满足某种约束的ALL命令或ALL操作符之类的东西。你可以吃任何一种。

2161
00:59:59,560 --> 01:00:00,775
0,210 210,465 465,765 765,1005 1005,1215
ways you can interact with

2162
01:00:00,775 --> 01:00:02,545
0,330 330,725 1165,1455 1455,1620 1620,1770
nesta queries. You can set

2163
01:00:02,545 --> 01:00:04,150
0,180 180,725 1105,1380 1380,1500 1500,1605
where clauses so you can

2164
01:00:04,150 --> 01:00:05,500
0,210 210,480 480,800 820,1095 1095,1350
have things like an all

2165
01:00:05,500 --> 01:00:07,225
0,300 300,465 465,710 730,1130 1360,1725
command or all operator that

2166
01:00:07,225 --> 01:00:08,605
0,365 415,780 780,1080 1080,1275 1275,1380
that every row in the

2167
01:00:08,605 --> 01:00:09,715
0,240 240,405 405,570 570,705 705,1110
nested query has to satisfy

2168
01:00:09,715 --> 01:00:11,245
0,225 225,405 405,495 495,935 1285,1530
some kind of restraint. You

2169
01:00:11,245 --> 01:00:12,500
0,90 90,210 210,485
can have any.|
|

2170
01:00:12,500 --> 01:00:14,045
0,260 340,675 675,960 960,1290 1290,1545
Or sometimes called sum is
或者有时称为SUM是别名SOE，您可以说至少有一行与我的子查询匹配。In子句是我之前展示过的。它等于Any，然后就存在。我的意思是我想找到我知道至少有一个匹配的东西。对不起，只有一行是退回的，但我并不关心里面有什么。

2171
01:00:14,045 --> 01:00:16,385
0,120 120,575 1225,1865 2005,2250 2250,2340
the alias SOE where you

2172
01:00:16,385 --> 01:00:17,765
0,120 120,395 745,990 990,1140 1140,1380
can say at least one

2173
01:00:17,765 --> 01:00:19,750
0,335 985,1305 1305,1515 1515,1680 1680,1985
row match my sub query.

2174
01:00:20,190 --> 01:00:21,770
0,245 245,425 425,785 785,1180 1320,1580
The in clause is that

2175
01:00:21,770 --> 01:00:22,460
0,120 120,225 225,390 390,600 600,690
I showed before. It's the

2176
01:00:22,460 --> 01:00:23,960
0,135 135,270 270,510 510,890 1150,1500
same thing as is equals

2177
01:00:23,960 --> 01:00:25,775
0,350 850,1110 1110,1335 1335,1620 1620,1815
any and then exists. Just

2178
01:00:25,775 --> 01:00:26,870
0,195 195,515 655,915 915,1005 1005,1095
means that I want to

2179
01:00:26,870 --> 01:00:28,070
0,135 135,330 330,650 700,990 990,1200
find something where I know

2180
01:00:28,070 --> 01:00:29,300
0,390 390,735 735,870 870,1035 1035,1230
there's there's at least one

2181
01:00:29,300 --> 01:00:31,115
0,290 610,1010 1120,1485 1485,1620 1620,1815
match. Sorry, there's just one

2182
01:00:31,115 --> 01:00:32,000
0,195 195,420 420,660 660,810 810,885
row being return, but I

2183
01:00:32,000 --> 01:00:32,780
0,180 180,330 330,480 480,705 705,780
don't actually care what's in

2184
01:00:32,780 --> 01:00:33,380
0,260
it.|
|

2185
01:00:35,300 --> 01:00:36,600
0,290 290,440 440,545 545,905 905,1300
So I can rewrite the
所以我可以重写我以前的例子，而不是使用in，我可以使用Any，它被认为是等价的。

2186
01:00:37,010 --> 01:00:37,900
0,275 275,380 380,455 455,680 680,890
example I have before instead

2187
01:00:37,900 --> 01:00:39,055
0,60 60,210 210,530 760,1020 1020,1155
of using in I can

2188
01:00:39,055 --> 01:00:40,900
0,275 415,815 985,1275 1275,1560 1560,1845
use any and it's considered

2189
01:00:40,900 --> 01:00:41,920
0,380
equivalent.|
|

2190
01:00:42,590 --> 01:00:43,645
0,245 245,490 540,785 785,890 890,1055
And so we can show
因此，我们可以非常迅速地展示波斯格雷斯是如何为此选择不同的计划的，你可以看到它是如何实际执行的。

2191
01:00:43,645 --> 01:00:45,625
0,165 165,360 360,695 1285,1755 1755,1980
real quickly how postgres picks

2192
01:00:45,625 --> 01:00:47,215
0,165 165,390 390,540 540,785 1345,1590
different plans for this, and

2193
01:00:47,215 --> 01:00:47,890
0,120 120,240 240,330 330,540 540,675
you see how it's actually

2194
01:00:47,890 --> 01:00:49,220
0,195 195,620
being executed.|
|

2195
01:00:49,540 --> 01:00:50,800
0,230
Hmm.|
嗯。|

2196
01:00:57,510 --> 01:00:58,510
0,320 320,485 485,635 635,710 710,1000
Right. So here's our query.|
正确的。下面是我们的查询。|

2197
01:01:00,010 --> 01:01:00,930
0,245 245,350 350,500 500,650 650,920
We have ris and tupac
我们请里斯和图帕克来上课。所以在SQL中，你可以把这个解释过的关键字放在它前面，放在任何查询前面，如果系统支持它，它会返回查询计划，并告诉你如果它真的试图执行这个东西，它会执行什么操作。

2198
01:01:00,930 --> 01:01:03,300
0,165 165,300 300,560 1840,2145 2145,2370
taking the class. So in

2199
01:01:03,300 --> 01:01:04,410
0,435 435,630 630,750 750,870 870,1110
sql you can put this

2200
01:01:04,410 --> 01:01:05,415
0,330 330,660 660,780 780,900 900,1005
explained keyword in front of

2201
01:01:05,415 --> 01:01:07,040
0,245 655,945 945,1110 1110,1290 1290,1625
it and of any query

2202
01:01:07,480 --> 01:01:08,355
0,275 275,410 410,680 680,755 755,875
and what that's going to

2203
01:01:08,355 --> 01:01:09,795
0,275 505,780 780,900 900,1140 1140,1440
do, if the system supports

2204
01:01:09,795 --> 01:01:10,980
0,180 180,495 495,645 645,905 925,1185
it, it'll come back with

2205
01:01:10,980 --> 01:01:12,195
0,135 135,375 375,710 850,1110 1110,1215
the query plan and tell

2206
01:01:12,195 --> 01:01:14,850
0,135 135,425 1195,1595 2215,2445 2445,2655
you what operations would it

2207
01:01:14,850 --> 01:01:16,290
0,380 490,750 750,930 930,1215 1215,1440
execute if it actually tried

2208
01:01:16,290 --> 01:01:17,520
0,165 165,345 345,495 495,770
to execute this thing.|
|

2209
01:01:17,530 --> 01:01:18,640
0,400
Right.|
正确的。|

2210
01:01:19,510 --> 01:01:20,295
0,245 245,320 320,395 395,530 530,785
So when we run that,
所以当我们运行它时，我们会得到类似这样的东西，它会告诉我们基本上是一个树形结构。所以这些是叶节点，然后它建立了这个最终输出。所以这告诉我们POST想要对注册的表进行强制扫描，然后它会对它进行散列，因为它在那里进行散列，我们稍后会讨论什么是散列，然后扫描学生表，然后通过匹配学生ID，学生ID和招生ID。所以Postgres足够聪明地转换了这个。

2211
01:01:20,295 --> 01:01:21,260
0,225 225,360 360,525 525,690 690,965
we get something like this

2212
01:01:21,670 --> 01:01:22,760
0,530 530,590 590,695 695,830 830,1090
that's going to tell us

2213
01:01:23,080 --> 01:01:24,710
0,400 780,1025 1025,1145 1145,1325 1325,1630
basically as a tree structure.

2214
01:01:25,060 --> 01:01:26,055
0,400 420,695 695,800 800,860 860,995
So these are the leaf

2215
01:01:26,055 --> 01:01:27,075
0,450 450,615 615,720 720,825 825,1020
nodes and then it builds

2216
01:01:27,075 --> 01:01:28,160
0,135 135,315 315,450 450,690 690,1085
up this the final output.

2217
01:01:28,360 --> 01:01:29,480
0,335 335,545 545,680 680,830 830,1120
So this is telling us

2218
01:01:29,890 --> 01:01:31,020
0,350 350,560 560,635 635,695 695,1130
post wants to do aential

2219
01:01:31,020 --> 01:01:32,685
0,225 225,390 390,660 660,920 1420,1665
scan the enrolled table and

2220
01:01:32,685 --> 01:01:33,360
0,105 105,285 285,345 345,435 435,675
then it's going to hash

2221
01:01:33,360 --> 01:01:34,635
0,260 490,840 840,1080 1080,1170 1170,1275
it because it's doing a

2222
01:01:34,635 --> 01:01:35,505
0,195 195,300 300,405 405,585 585,870
hash one up there, which

2223
01:01:35,505 --> 01:01:36,450
0,270 270,390 390,525 525,780 780,945
we'll cover what hash is

2224
01:01:36,450 --> 01:01:38,120
0,165 165,470 790,1035 1035,1275 1275,1670
later on, and then does

2225
01:01:38,470 --> 01:01:39,800
0,380 380,650 650,830 830,1025 1025,1330
scan on the student table

2226
01:01:40,210 --> 01:01:41,985
0,245 245,350 350,575 575,940 1500,1775
and then now does by

2227
01:01:41,985 --> 01:01:45,150
0,315 315,435 435,555 555,815 2905,3165
matching the student ID, student

2228
01:01:45,150 --> 01:01:46,430
0,195 195,465 465,840 840,1020 1020,1280
ID with enroll student ID.

2229
01:01:46,750 --> 01:01:48,060
0,335 335,800 800,1010 1010,1190 1190,1310
So postgres was smart enough

2230
01:01:48,060 --> 01:01:49,540
0,195 195,480 480,830
to convert this.|
|

2231
01:01:49,950 --> 01:01:51,635
0,485 485,785 785,1175 1175,1460 1460,1685
Nested query into a join,
将查询嵌套到连接中，当您拥有这些类型的引用时，这始终是执行某些操作的最快方式。

2232
01:01:51,635 --> 01:01:52,520
0,195 195,450 450,705 705,810 810,885
which is always going to

2233
01:01:52,520 --> 01:01:53,405
0,120 120,270 270,615 615,735 735,885
be the fastest way to

2234
01:01:53,405 --> 01:01:54,965
0,195 195,485 1135,1380 1380,1470 1470,1560
execute something when you have

2235
01:01:54,965 --> 01:01:56,740
0,120 120,225 225,300 300,815
these kind of references.|
|

2236
01:01:57,010 --> 01:01:57,780
0,245 245,350 350,485 485,620 620,770
We can try the same
我们可以在我的SQL中尝试相同的操作。

2237
01:01:57,780 --> 01:01:59,400
0,195 195,345 345,480 480,890
thing in my sql.|
|

2238
01:02:06,410 --> 01:02:07,885
0,245 245,335 335,580 870,1205 1205,1475
But you get their explained
但你会知道，他们解释的产出很糟糕。有一种方法可以得到，我忘记了语法，你必须放入一个扩展的或类似的东西。

2239
01:02:07,885 --> 01:02:10,735
0,180 180,285 285,545 2485,2760 2760,2850
output is terrible. There's a

2240
01:02:10,735 --> 01:02:13,180
0,165 165,285 285,515 2005,2295 2295,2445
way to get, I forget

2241
01:02:13,180 --> 01:02:14,140
0,120 120,510 510,705 705,825 825,960
the syntax, you gotta put

2242
01:02:14,140 --> 01:02:15,160
0,105 105,345 345,675 675,870 870,1020
like an extended or something

2243
01:02:15,160 --> 01:02:16,260
0,150 150,410
like that.|
|

2244
01:02:17,170 --> 01:02:17,820
0,290 290,425 425,500 500,575 575,650
I forget how to do
我忘记了如何在我的SQL中这样做。有一种方法可以让事情变得更好。

2245
01:02:17,820 --> 01:02:18,495
0,90 90,195 195,300 300,525 525,675
it in my sql. There's

2246
01:02:18,495 --> 01:02:19,530
0,45 45,135 135,240 240,485 745,1035
a way to get something

2247
01:02:19,530 --> 01:02:21,740
0,120 120,195 195,315 315,590
a little bit better.|
|

2248
01:02:22,200 --> 01:02:23,750
0,400 420,830 830,1120 1385,1475 1475,1550
In sql light, I don't
在SQL Light中，我认为您无法做到这一点。你可以做到的。

2249
01:02:23,750 --> 01:02:24,520
0,90 90,210 210,360 360,510 510,770
think you can do this.

2250
01:02:25,170 --> 01:02:26,600
0,245 245,350 350,485 485,760
You can do this.|
|

2251
01:02:30,180 --> 01:02:31,540
0,315 315,710
Any different.|
有什么不同吗。|

2252
01:02:32,165 --> 01:02:33,160
0,60 60,305
What's that?|
那是什么？|

2253
01:02:34,890 --> 01:02:37,480
0,400
This.|
这。|

2254
01:02:38,370 --> 01:02:40,680
0,245 245,490 1110,1445 1445,1690
All right, sql light.|
好了，SQL Light。|

2255
01:02:43,660 --> 01:02:44,610
0,245 245,395 395,515 515,710 710,950
They don't like the select
他们不喜欢SELECT语句。

2256
01:02:44,610 --> 01:02:46,740
0,320
statement.|
|

2257
01:02:48,640 --> 01:02:50,175
0,260 260,470 470,820 1080,1340 1340,1535
Which is surprising. Why doesn't
这是令人惊讶的。为什么这不管用呢？看看d DB是否能做到这一点？

2258
01:02:50,175 --> 01:02:51,345
0,105 105,365 745,960 960,1035 1035,1170
that work? See if d

2259
01:02:51,345 --> 01:02:52,800
0,180 180,300 300,575
DB does it?|
|

2260
01:02:53,550 --> 01:02:54,710
0,260 260,365 365,485 485,760 870,1160
Think of the airport. TV
想想机场吧。电视上有很漂亮的。

2261
01:02:54,710 --> 01:02:57,460
0,195 195,450 450,800
has very pretty.|
|

2262
01:02:57,470 --> 01:02:58,330
0,260 260,365 365,560 560,770 770,860
They give you, they give
它们给你，它们给你漂亮的小树，你很容易被逗乐。这给你留下了深刻的印象，哦我的天哪，Unicode输出，但是的，它给了你，展示了什么是物理计划，然后。

2263
01:02:58,330 --> 01:03:04,345
0,90 90,210 210,390 390,710 5710,6015
you nice little trees, you

2264
01:03:04,345 --> 01:03:08,095
0,180 180,405 405,875 2995,3360 3360,3750
are easily amused. This impresses

2265
01:03:08,095 --> 01:03:10,330
0,270 270,900 900,1245 1245,1595 1975,2235
you unicode output for oh

2266
01:03:10,330 --> 01:03:13,375
0,120 120,380 2230,2475 2475,2720 2800,3045
my gosh, but yeah, it

2267
01:03:13,375 --> 01:03:14,905
0,245 985,1275 1275,1380 1380,1440 1440,1530
gives, shows you what the

2268
01:03:14,905 --> 01:03:17,910
0,180 180,390 390,665 2485,2745 2745,3005
physical plan is and then.|
|

2269
01:03:19,190 --> 01:03:19,840
0,260 260,380 380,470 470,530 530,650
We can try it an
我们可以试着成为先知。

2270
01:03:19,840 --> 01:03:21,320
0,530
Oracle.|
|

2271
01:03:22,640 --> 01:03:23,970
0,400 420,695 695,815 815,995 995,1330
Right has the right output.|
Right具有正确的输出。|

2272
01:03:27,710 --> 01:03:29,845
0,400 1080,1480 1590,1850 1850,1940 1940,2135
I, well, we need this
我，好吧，我们还需要这个，让飞机离开Oracle和SQL服务器是一个巨大的痛苦，但我对此感到惊讶。

2273
01:03:29,845 --> 01:03:31,630
0,225 225,345 345,665 1285,1590 1590,1785
another time there's getting the

2274
01:03:31,630 --> 01:03:32,770
0,165 165,420 420,690 690,1050 1050,1140
plane out of Oracle and

2275
01:03:32,770 --> 01:03:33,550
0,195 195,360 360,525 525,630 630,780
sql server is a huge

2276
01:03:33,550 --> 01:03:35,160
0,255 255,450 450,690 690,1040 1210,1610
pain, but I'm surprised that.|
|

2277
01:03:36,870 --> 01:03:38,020
0,350 350,455 455,710 710,875 875,1150
Sql light doesn't support this.|
SQL Light不支持这一点。|

2278
01:03:44,510 --> 01:03:45,175
0,305 305,365 365,440 440,485 485,665
I'm not going to debug
我不会现场调试的。

2279
01:03:45,175 --> 01:03:46,880
0,150 150,425
this live.|
|

2280
01:03:48,150 --> 01:03:48,860
0,290 290,425 425,545 545,620 620,710
Yeah, I don't know why
是啊，我不知道它为什么不喜欢那样。让我们试试看。

2281
01:03:48,860 --> 01:03:49,865
0,60 60,225 225,330 330,590 700,1005
it doesn't like that. Let's

2282
01:03:49,865 --> 01:03:50,980
0,135 135,425
try in.|
|

2283
01:03:55,030 --> 01:03:55,860
0,290 290,425 425,515 515,680 680,830
Ah, there we go. They
啊，又来了。他们不喜欢任何像In这样的人。好的，在单光灯下，如果我跑了，解释一下。

2284
01:03:55,860 --> 01:03:56,960
0,120 120,315 315,615 615,825 825,1100
didn't like any like in.

2285
01:03:57,520 --> 01:03:59,205
0,305 305,610 1020,1295 1295,1460 1460,1685
Alright, so in single light,

2286
01:03:59,205 --> 01:04:02,040
0,165 165,270 270,495 495,845
if I run, explain.|
|

2287
01:04:04,670 --> 01:04:06,180
0,245 245,365 365,640
I get this.|
我明白了。|

2288
01:04:08,910 --> 01:04:09,950
0,335 335,515 515,665 665,920 920,1040
So the way sql light
因此，就像SQL Light所做的那样，这就是。

2289
01:04:09,950 --> 01:04:11,300
0,210 210,390 390,650
does, which is.|
|

2290
01:04:11,810 --> 01:04:14,000
0,470 470,695 695,970
Genius is that.|
天才就是这样。|

2291
01:04:15,230 --> 01:04:16,390
0,275 275,425 425,815 815,950 950,1160
The way itutes your query
它处理查询计划的方式是将查询计划转换为自己的DSL操作码，并且它有自己的VM来运行类似于JVM的代码。您获取Java代码，将其转换为Java字节码，然后JVM执行或解释它。这就是SQL Lite所做的。

2292
01:04:16,390 --> 01:04:17,545
0,195 195,405 405,765 765,900 900,1155
plan, it converts the query

2293
01:04:17,545 --> 01:04:20,070
0,270 270,605 1465,1740 1740,1950 1950,2525
plan into its own dsl

2294
01:04:20,480 --> 01:04:21,355
0,320 320,635 635,710 710,770 770,875
op codes, and it has

2295
01:04:21,355 --> 01:04:22,890
0,120 120,285 285,755 925,1230 1230,1535
its own vm that runs

2296
01:04:23,150 --> 01:04:25,150
0,350 350,850 1140,1400 1400,1535 1535,2000
the codes like the jvm.

2297
01:04:25,150 --> 01:04:26,290
0,240 240,450 450,735 735,930 930,1140
You take Java code, convert

2298
01:04:26,290 --> 01:04:27,390
0,105 105,315 315,645 645,840 840,1100
it into Java byte code,

2299
01:04:27,500 --> 01:04:28,855
0,260 260,395 395,545 545,1010 1010,1355
and then the jvm executes

2300
01:04:28,855 --> 01:04:30,190
0,120 120,255 255,525 525,785 985,1335
it or interprets it. That's

2301
01:04:30,190 --> 01:04:32,300
0,90 90,300 300,435 435,710
what sql lite does.|
|

2302
01:04:32,300 --> 01:04:34,280
0,350 400,780 780,1070 1270,1575 1575,1980
EM, we'll discuss query compilations
嗯，我们将在本学期晚些时候讨论查询编译。

2303
01:04:34,280 --> 01:04:36,660
0,345 345,540 540,615 615,890
later in this semester.|
|

2304
01:04:36,930 --> 01:04:37,630
0,230 230,305 305,380 380,455 455,700
So you got to put
所以你得把解释计划。

2305
01:04:37,830 --> 01:04:39,380
0,350 350,700
explain plan.|
|

2306
01:04:41,090 --> 01:04:44,160
0,335 335,670 1740,2140
Planet that extended.|
这颗行星延伸了。|

2307
01:04:44,280 --> 01:04:45,335
0,335 335,485 485,845 845,980 980,1055
There's some syntax to get
有一些语法可以获得真正的计划，不管是什么。相信我，它就在那里。

2308
01:04:45,335 --> 01:04:46,595
0,90 90,240 240,545 565,965 985,1260
the real plan, whatever. Trust

2309
01:04:46,595 --> 01:04:47,560
0,105 105,225 225,455 475,720 720,965
me, it's there all right.|
|

2310
01:04:51,390 --> 01:04:53,075
0,400 780,1100 1100,1340 1340,1535 1535,1685
So yeah, so they all
所以是的，所以它们都做一些略有不同的事情，然后如果系统是智能的，您可以尝试将其转换为联接。

2311
01:04:53,075 --> 01:04:55,280
0,135 135,390 390,705 705,1025 1945,2205
do something slightly different and

2312
01:04:55,280 --> 01:04:56,120
0,210 210,420 420,540 540,690 690,840
then if the system is

2313
01:04:56,120 --> 01:04:56,600
0,120 120,210 210,285 285,360 360,480
smart, you can try to

2314
01:04:56,600 --> 01:04:57,880
0,135 135,225 225,470 760,1020 1020,1280
convert it into a join.|
|

2315
01:04:59,960 --> 01:05:01,120
0,410 410,665 665,860 860,1025 1025,1160
So skip this and sake
所以跳过这段时间吧，因为我们得熬过去。

2316
01:05:01,120 --> 01:05:02,200
0,120 120,330 330,615 615,825 825,1080
a time, because we got

2317
01:05:02,200 --> 01:05:05,000
0,210 210,300 300,560
to get through.|
|

2318
01:05:05,470 --> 01:05:06,110
0,230 230,290 290,335 335,395 395,640
I want to get through
我想通过侧向连接和。

2319
01:05:06,130 --> 01:05:08,560
0,440 440,740 740,1030
lateral joins and.|
|

2320
01:05:09,040 --> 01:05:12,050
0,400 600,1150 1920,2180 2180,2525 2525,3010
And cte so lateral joins
侧向连接是一个较新的概念，但是。

2321
01:05:12,100 --> 01:05:15,050
0,400 540,940 1740,2105 2105,2380 2550,2950
are a newer concept, but.|
|

2322
01:05:16,000 --> 01:05:16,855
0,180 180,330 330,510 510,705 705,855
And not all systems are
并不是所有的系统都会支持它，但基本的想法是，它将允许你拥有一个。

2323
01:05:16,855 --> 01:05:18,120
0,75 75,210 210,375 375,635 865,1265
going to support it, but

2324
01:05:18,170 --> 01:05:19,470
0,275 275,550 600,860 860,1010 1010,1300
the basic idea is that

2325
01:05:19,610 --> 01:05:20,605
0,320 320,380 380,485 485,755 755,995
it's going to allow you

2326
01:05:20,605 --> 01:05:22,300
0,105 105,365 385,785
to have a.|
|

2327
01:05:22,300 --> 01:05:26,640
0,350 1300,1830 1830,2150 2680,3080 3940,4340
A nested query reference data
嵌套查询引用与其相邻的另一个查询中的数据。因此，通常情况下，如果您有两个Nesta查询，其中一个sa查询不能引用另一个Nesta查询中的内容，因为它不知道其中的内容，但具有横向联接。

2328
01:05:26,870 --> 01:05:30,000
0,400 540,940 1020,1420 1860,2290 2730,3130
in in another query that

2329
01:05:30,050 --> 01:05:32,220
0,350 350,920 920,1070 1070,1330 1770,2170
is adjacent to it. So

2330
01:05:32,390 --> 01:05:33,910
0,400 960,1190 1190,1265 1265,1385 1385,1520
normally if you have two

2331
01:05:33,910 --> 01:05:35,590
0,255 255,710 970,1230 1230,1485 1485,1680
nesta queries, one sa query

2332
01:05:35,590 --> 01:05:36,625
0,255 255,450 450,780 780,930 930,1035
can't reference what's inside the

2333
01:05:36,625 --> 01:05:37,915
0,135 135,390 390,665 865,1110 1110,1290
other nesta query because it

2334
01:05:37,915 --> 01:05:39,025
0,285 285,420 420,645 645,960 960,1110
doesn't know about what's inside

2335
01:05:39,025 --> 01:05:40,270
0,105 105,335 805,1050 1050,1140 1140,1245
of it, but with a

2336
01:05:40,270 --> 01:05:41,740
0,450 450,740
lateral join.|
|

2337
01:05:41,840 --> 01:05:42,565
0,260 260,410 410,530 530,605 605,725
It allows you to do
它允许您这样做。您几乎可以认为这是一个for循环。每一个人，每一个人都有一张桌子。

2338
01:05:42,565 --> 01:05:43,375
0,165 165,315 315,465 465,600 600,810
this. You can almost think

2339
01:05:43,375 --> 01:05:45,520
0,455 535,855 855,1080 1080,1385 1855,2145
it's a for loop. Where

2340
01:05:45,520 --> 01:05:46,980
0,225 225,560 730,975 975,1140 1140,1460
one table for every single,

2341
01:05:47,270 --> 01:05:49,120
0,290 290,580
every single.|
|

2342
01:05:49,190 --> 01:05:50,470
0,305 305,560 560,890 890,1145 1145,1280
Every single t in the
外部循环中的每个单独的t，外部for循环。你可以做一些。你可以在这里运行一些查询，做一些计算。

2343
01:05:50,470 --> 01:05:51,760
0,260 340,645 645,825 825,1065 1065,1290
outer, outer for loop. You

2344
01:05:51,760 --> 01:05:53,050
0,150 150,375 375,710 940,1185 1185,1290
can do some. You can

2345
01:05:53,050 --> 01:05:53,815
0,165 165,330 330,510 510,645 645,765
run some query, do some

2346
01:05:53,815 --> 01:05:55,060
0,405 405,725
computation here.|
|

2347
01:05:55,410 --> 01:05:56,375
0,230 230,290 290,470 470,740 740,965
So in this simple example
所以在这个简单的例子中，我有两个两个嵌套的查询。我有一个SELECT 1作为X，所以这是返回一个2，它有一个值为1的列，然后我的横向连接现在可以引用这个第一个查询的输出，只需在它上加1。

2348
01:05:56,375 --> 01:05:59,390
0,305 1015,1275 1275,1470 1470,1805 2725,3015
here I have two two

2349
01:05:59,390 --> 01:06:00,620
0,165 165,285 285,710 970,1185 1185,1230
nest of queries. I have

2350
01:06:00,620 --> 01:06:01,715
0,120 120,315 315,510 510,780 780,1095
a select one as as

2351
01:06:01,715 --> 01:06:02,825
0,285 285,480 480,600 600,855 855,1110
X, so this is turning

2352
01:06:02,825 --> 01:06:03,500
0,150 150,270 270,420 420,585 585,675
back a single two that

2353
01:06:03,500 --> 01:06:04,190
0,105 105,285 285,480 480,615 615,690
has one column with a

2354
01:06:04,190 --> 01:06:06,050
0,165 165,500 880,1155 1155,1430 1510,1860
value one, and then my

2355
01:06:06,050 --> 01:06:08,345
0,435 435,630 630,950 1330,1730 1930,2295
lateral join here can now

2356
01:06:08,345 --> 01:06:10,895
0,365 745,1145 1705,2085 2085,2370 2370,2550
reference the the output of

2357
01:06:10,895 --> 01:06:12,425
0,195 195,435 435,705 705,1025 1255,1530
this first query here and

2358
01:06:12,425 --> 01:06:13,295
0,165 165,360 360,570 570,735 735,870
just do plus one on

2359
01:06:13,295 --> 01:06:13,840
0,275
it.|
|

2360
01:06:14,010 --> 01:06:15,070
0,350 350,530 530,605 605,755 755,1060
Right. So I get I
正确的。所以我知道我得到了一个和两个。

2361
01:06:15,120 --> 01:06:16,025
0,290 290,455 455,605 605,755 755,905
get one and two that

2362
01:06:16,025 --> 01:06:17,100
0,275
way.|
|

2363
01:06:17,830 --> 01:06:19,125
0,380 380,830 830,965 965,1175 1175,1295
Without lateral you can't do
如果没有横向，您将无法执行此操作，因为这将被视为两个完全独立的查询，我们可以在Postgres中执行此操作并快速查看。

2364
01:06:19,125 --> 01:06:20,700
0,275 865,1125 1125,1275 1275,1425 1425,1575
this because this would be

2365
01:06:20,700 --> 01:06:22,650
0,225 225,560 1210,1530 1530,1740 1740,1950
treated as completely two separate

2366
01:06:22,650 --> 01:06:24,225
0,470 970,1260 1260,1395 1395,1485 1485,1575
queries, which we can do

2367
01:06:24,225 --> 01:06:25,185
0,75 75,165 165,570 570,810 810,960
this in postgres and see

2368
01:06:25,185 --> 01:06:26,200
0,135 135,395
real quickly.|
|

2369
01:06:27,870 --> 01:06:29,720
0,400
Right.|
正确的。|

2370
01:06:30,840 --> 01:06:33,380
0,320 320,575 575,910 1140,1540
So select star from.|
因此，请选择星号。|

2371
01:06:33,980 --> 01:06:35,230
0,245 245,335 335,725 725,965 965,1250
In an intercase like one
在像AS这样的案件中。

2372
01:06:35,230 --> 01:06:36,500
0,380
as.|
|

2373
01:06:39,960 --> 01:06:41,080
0,400
Sorry.|
抱歉的。|

2374
01:06:41,550 --> 01:06:42,900
0,275 275,425 425,700
Yep, yep, yep.|
是的，是的，是的。|

2375
01:06:43,340 --> 01:06:44,820
0,260 260,520
Is X.|
是X。|

2376
01:06:45,400 --> 01:06:47,060
0,350 350,560 560,820
S T one.|
S TONE。|

2377
01:06:48,720 --> 01:06:49,325
0,305 305,425 425,470 470,530 530,605
Right, so I can get
好的，所以我可以拿回一个有一个的两个人，对吗？但如果我尝试将另一个嵌套查询放在它旁边，则两个都是y。

2378
01:06:49,325 --> 01:06:50,135
0,105 105,225 225,405 405,705 705,810
back a single twople that

2379
01:06:50,135 --> 01:06:51,880
0,245 985,1245 1245,1350 1350,1470 1470,1745
has one in it, right?

2380
01:06:52,530 --> 01:06:53,285
0,245 245,335 335,470 470,620 620,755
But if I try to

2381
01:06:53,285 --> 01:06:54,755
0,275 535,840 840,1110 1110,1275 1275,1470
put another nested query next

2382
01:06:54,755 --> 01:06:59,140
0,150 150,395 2515,2915 3625,4005 4005,4385
to it, two has y.|
|

2383
01:07:00,830 --> 01:07:02,600
0,380 380,970
As t2.|
作为T2。|

2384
01:07:03,410 --> 01:07:04,900
0,400 630,950 950,1055 1055,1175 1175,1490
Right, I'm getting the cartesian
是的，我得到了笛卡尔乘积，但我不能引用这个东西的内部。我不能去T点X加一。

2385
01:07:04,900 --> 01:07:06,060
0,210 210,390 390,525 525,870 870,1160
product, but I can't reference

2386
01:07:06,260 --> 01:07:07,105
0,275 275,395 395,545 545,710 710,845
inside of this thing. I

2387
01:07:07,105 --> 01:07:09,040
0,240 240,485 955,1260 1260,1565 1615,1935
can't go t one dot

2388
01:07:09,040 --> 01:07:10,520
0,285 285,555 555,860
X plus one.|
|

2389
01:07:11,420 --> 01:07:13,390
0,400 990,1250 1250,1370 1370,1700 1700,1970
Right, because it doesn't know
对，因为它不知道t 1，因为这些查询是分开运行的。

2390
01:07:13,390 --> 01:07:14,610
0,285 285,510 510,750 750,960 960,1220
about t one because those

2391
01:07:15,770 --> 01:07:17,540
0,350 350,530 530,785 785,1270
queries are running separately.|
|

2392
01:07:17,550 --> 01:07:18,635
0,275 275,425 425,605 605,770 770,1085
If I add the lateral
如果我加上横向关键字。

2393
01:07:18,635 --> 01:07:19,940
0,425
keyword.|
|

2394
01:07:22,630 --> 01:07:24,300
0,400 420,820 870,1160 1160,1370 1370,1670
Now my my second nested
现在，我的第二个嵌套查询可以引用第一个查询中的任何内容，对吗？

2395
01:07:24,300 --> 01:07:26,670
0,290 1180,1560 1560,1940 2050,2295 2295,2370
query can reference whatever is

2396
01:07:26,670 --> 01:07:27,950
0,75 75,180 180,330 330,620 880,1280
in the first one, right?|
|

2397
01:07:28,820 --> 01:07:29,680
0,260 260,365 365,485 485,665 665,860
And you can chain these
你可以将这些东西链接在一起，想链接多少次就链接多少次。

2398
01:07:29,680 --> 01:07:32,035
0,240 240,590 1720,1965 1965,2115 2115,2355
things together as many times

2399
01:07:32,035 --> 01:07:33,160
0,180 180,285 285,545
as you want.|
|

2400
01:07:33,650 --> 01:07:34,330
0,290 290,365 365,485 485,590 590,680
Let's go back to it
让我们快速返回它，看看这个查询计划是什么。从理论上讲，您应该将其转换为联接。

2401
01:07:34,330 --> 01:07:34,855
0,165 165,315 315,390 390,450 450,525
quickly and see what the

2402
01:07:34,855 --> 01:07:35,485
0,165 165,330 330,450 450,540 540,630
query plan for this one

2403
01:07:35,485 --> 01:07:36,565
0,105 105,365 475,765 765,945 945,1080
would be. In theory, you

2404
01:07:36,565 --> 01:07:37,195
0,135 135,285 285,420 420,525 525,630
should convert this to a

2405
01:07:37,195 --> 01:07:38,340
0,275
join.|
|

2406
01:07:40,640 --> 01:07:43,645
0,215 215,430 1110,1510 2490,2825 2825,3005
Oh, all right, it did.
哦，好吧，是这样的。一条捷径？忽略它，因为它基本上是在说，我知道答案是什么。我不需要运行任何东西，只需吐出答案即可。这就是它所做的。就像SELECT 1+1一样，它知道如何在不运行查询的情况下进行计算。

2407
01:07:43,645 --> 01:07:45,850
0,105 105,450 450,660 660,935 1945,2205
A shortcut? Ignore that because

2408
01:07:45,850 --> 01:07:47,575
0,260 580,960 960,1340 1360,1635 1635,1725
it basically says, I know

2409
01:07:47,575 --> 01:07:48,130
0,60 60,150 150,315 315,480 480,555
what the answer is. I

2410
01:07:48,130 --> 01:07:48,775
0,135 135,180 180,255 255,450 450,645
don't have to run anything

2411
01:07:48,775 --> 01:07:49,375
0,105 105,225 225,375 375,495 495,600
and just spits out the

2412
01:07:49,375 --> 01:07:50,220
0,210 210,450 450,510 510,600 600,845
answer. That's what it did.

2413
01:07:50,660 --> 01:07:51,790
0,335 335,560 560,725 725,905 905,1130
Like select one plus one,

2414
01:07:51,790 --> 01:07:52,930
0,180 180,440 610,855 855,945 945,1140
it knows how to compute

2415
01:07:52,930 --> 01:07:53,940
0,210 210,465 465,630 630,735 735,1010
that without running a query.|
|

2416
01:07:54,990 --> 01:07:56,270
0,400 720,1025 1025,1085 1085,1160 1160,1280
Alright, let's have a more
好的，让我们举一个更复杂的例子。假设我想要计算每门课程的注册人数，然后我想计算每门课程的注册人数。然后我还想知道这门课上所有学生的平均绩点。因此，是的，您可以不使用稍后的联接来编写此代码。我只是想向您展示如何使用稍后的联接来实现这一点。因此将有两个嵌套查询。

2417
01:07:56,270 --> 01:07:57,425
0,270 270,630 630,885 885,1035 1035,1155
complicated example. So say I

2418
01:07:57,425 --> 01:07:58,160
0,75 75,180 180,465 465,585 585,735
want to calculate the number

2419
01:07:58,160 --> 01:07:59,210
0,180 180,375 375,525 525,930 930,1050
of students that enrolled in

2420
01:07:59,210 --> 01:08:01,925
0,195 195,530 1420,1740 1740,2060 2470,2715
each course and then I

2421
01:08:01,925 --> 01:08:02,390
0,60 60,150 150,300 300,405 405,465
want to count the number

2422
01:08:02,390 --> 01:08:02,975
0,90 90,210 210,420 420,480 480,585
of students enrolled in each

2423
01:08:02,975 --> 01:08:03,995
0,275 325,585 585,720 720,885 885,1020
course. And then I also

2424
01:08:03,995 --> 01:08:04,655
0,90 90,165 165,255 255,435 435,660
want to get all the,

2425
01:08:04,655 --> 01:08:07,115
0,165 165,390 390,1055 1435,1835 2155,2460
the average gpa of all

2426
01:08:07,115 --> 01:08:08,110
0,180 180,360 360,525 525,690 690,995
the students in that course.

2427
01:08:09,630 --> 01:08:10,760
0,275 275,545 545,815 815,965 965,1130
And so yes, you can

2428
01:08:10,760 --> 01:08:11,465
0,180 180,315 315,465 465,615 615,705
write this without using doing

2429
01:08:11,465 --> 01:08:12,110
0,75 75,240 240,465 465,585 585,645
a later join. I just

2430
01:08:12,110 --> 01:08:12,620
0,75 75,180 180,300 300,405 405,510
want to show you how

2431
01:08:12,620 --> 01:08:12,980
0,90 90,150 150,225 225,300 300,360
to do this with a

2432
01:08:12,980 --> 01:08:14,285
0,150 150,470 700,960 960,1155 1155,1305
later join. So there's two

2433
01:08:14,285 --> 01:08:14,840
0,90 90,120 120,195 195,300 300,555
going to be two nested

2434
01:08:14,840 --> 01:08:15,800
0,410
queries.|
|

2435
01:08:15,800 --> 01:08:16,850
0,290 310,570 570,690 690,855 855,1050
Where we had a select
其中，我们在外部有一条SELECT语句。对于课程表中的每两个学生，我要计算注册学生的数量。然后，对于课程表中的每个学生，我想计算所有普通学生的平均GPA。

2436
01:08:16,850 --> 01:08:17,885
0,180 180,315 315,560 670,900 900,1035
statement on the the outer

2437
01:08:17,885 --> 01:08:19,540
0,305 595,915 915,1095 1095,1305 1305,1655
part. And for every single

2438
01:08:19,920 --> 01:08:20,990
0,455 455,650 650,725 725,860 860,1070
twople that's in the course

2439
01:08:20,990 --> 01:08:22,625
0,320 730,990 990,1140 1140,1320 1320,1635
table, I want then compute

2440
01:08:22,625 --> 01:08:24,365
0,120 120,240 240,600 600,905 1495,1740
the number enrolled students. And

2441
01:08:24,365 --> 01:08:25,295
0,165 165,405 405,555 555,705 705,930
then again, for every single

2442
01:08:25,295 --> 01:08:26,110
0,180 180,285 285,375 375,525 525,815
student in the course table,

2443
01:08:26,310 --> 01:08:27,305
0,245 245,335 335,410 410,695 695,995
I want to compute the

2444
01:08:27,305 --> 01:08:29,240
0,330 330,905 1165,1440 1440,1710 1710,1935
average gpa of all the

2445
01:08:29,240 --> 01:08:30,440
0,240 240,560
eneral students.|
|

2446
01:08:30,590 --> 01:08:31,420
0,335 335,500 500,575 575,680 680,830
Right, so I could write
对，这样我就可以这样写了。我们有两个和两个嵌套的查询，都是带有横向关键字的，这里的第一个查询，我再次计算了它内部的，计数，我能够引用外部查询中的，相邻的查询。下面这一张也是一样的。我可以把这本书放在那里参考。现在我不在这里展示这个例子，因为他们是人为的。

2447
01:08:31,420 --> 01:08:32,260
0,135 135,285 285,525 525,705 705,840
it as this. We have

2448
01:08:32,260 --> 01:08:33,960
0,195 195,495 495,890 910,1215 1215,1700
two and two nest queries

2449
01:08:34,040 --> 01:08:35,170
0,245 245,425 425,620 620,875 875,1130
that are that are with

2450
01:08:35,170 --> 01:08:37,030
0,135 135,435 435,830 1420,1710 1710,1860
the lateral keyword where again

2451
01:08:37,030 --> 01:08:37,810
0,105 105,240 240,390 390,585 585,780
the first one here I

2452
01:08:37,810 --> 01:08:40,500
0,330 330,650 1780,2160 2160,2415 2415,2690
compute the, the, the count

2453
01:08:40,880 --> 01:08:42,145
0,400 570,845 845,950 950,1055 1055,1265
again inside of it I'm

2454
01:08:42,145 --> 01:08:43,825
0,135 135,285 285,545 895,1335 1335,1680
able to reference what's in

2455
01:08:43,825 --> 01:08:45,265
0,225 225,345 345,585 585,905 1195,1440
the outer query here, the

2456
01:08:45,265 --> 01:08:46,735
0,345 345,635 955,1200 1200,1335 1335,1470
adjacent query. And then for

2457
01:08:46,735 --> 01:08:47,995
0,120 120,255 255,420 420,725 955,1260
this one down here, same

2458
01:08:47,995 --> 01:08:48,895
0,225 225,420 420,555 555,705 705,900
thing. I can have this

2459
01:08:48,895 --> 01:08:50,905
0,305 505,945 945,1205 1285,1685 1735,2010
one referenced there. Now I'm

2460
01:08:50,905 --> 01:08:51,870
0,90 90,225 225,405 405,645 645,965
not showing this example here

2461
01:08:52,160 --> 01:08:54,240
0,400 600,875 875,1415 1415,1690
because they contrived but.|
|

2462
01:08:54,240 --> 01:08:55,665
0,120 120,270 270,510 510,860 1030,1425
In the second, later query
在第二个，我也可以参考的第二个查询中是第一个，这些东西被改变成一起改变。再说一次，当你想到SEL时，这是一个不同的概念，因为sl没有指定，或者我们没有指定数据系统应该执行任何操作的顺序。我们并不是真的这么做，我们只是在说而已。而是我们想要的计算执行的顺序，来计算我们想要的答案。

2463
01:08:55,665 --> 01:08:56,820
0,225 225,375 375,525 525,785 895,1155
I can also reference was

2464
01:08:56,820 --> 01:08:58,035
0,105 105,225 225,405 405,710 910,1215
in the first one, these

2465
01:08:58,035 --> 01:08:59,010
0,210 210,420 420,645 645,810 810,975
things get changed to get

2466
01:08:59,010 --> 01:09:00,600
0,240 240,560 1030,1305 1305,1455 1455,1590
changed together. And again, this

2467
01:09:00,600 --> 01:09:01,605
0,105 105,225 225,465 465,795 795,1005
is a different concept when

2468
01:09:01,605 --> 01:09:02,370
0,105 105,210 210,330 330,615 615,765
you think of SEL, because

2469
01:09:02,370 --> 01:09:04,005
0,375 375,870 870,1125 1125,1215 1215,1635
sl unord we're not specifying

2470
01:09:04,005 --> 01:09:05,175
0,180 180,455 475,720 720,885 885,1170
the or we don't specify

2471
01:09:05,175 --> 01:09:06,060
0,135 135,300 300,480 480,690 690,885
the order in which the

2472
01:09:06,060 --> 01:09:07,935
0,180 180,500 520,920 1120,1515 1515,1875
data system should should execute

2473
01:09:07,935 --> 01:09:09,690
0,365 895,1170 1170,1245 1245,1455 1455,1755
anything. We're not really doing

2474
01:09:09,690 --> 01:09:10,710
0,270 270,510 510,675 675,870 870,1020
that, we're just telling it.

2475
01:09:10,710 --> 01:09:11,805
0,90 90,180 180,345 345,650 850,1095
But the order we we

2476
01:09:11,805 --> 01:09:13,830
0,105 105,240 240,785 1135,1535 1795,2025
want the computation to to

2477
01:09:13,830 --> 01:09:14,835
0,180 180,570 570,660 660,900 900,1005
be performeded to compute the

2478
01:09:14,835 --> 01:09:16,200
0,180 180,375 375,540 540,845
answer that we want.|
|

2479
01:09:16,320 --> 01:09:17,870
0,245 245,350 350,590 590,970 1200,1550
So the database system can
因此，数据库系统可以决定，我是要将其重写为一组连接并同时执行它们，还是决定一个接一个地执行，然后我们可以真正快速地测试postgres，看看它有什么作用。

2480
01:09:17,870 --> 01:09:18,710
0,315 315,525 525,645 645,765 765,840
decide, do I want to

2481
01:09:18,710 --> 01:09:19,685
0,285 285,555 555,780 780,870 870,975
rewrite this as a bunch

2482
01:09:19,685 --> 01:09:20,720
0,135 135,480 480,600 600,810 810,1035
of joins and just execute

2483
01:09:20,720 --> 01:09:22,805
0,180 180,405 405,1070 1750,1995 1995,2085
them all concurrently, or we

2484
01:09:22,805 --> 01:09:23,620
0,135 135,300 300,435 435,555 555,815
can decide to do it

2485
01:09:23,790 --> 01:09:26,705
0,290 290,515 515,850 2550,2810 2810,2915
one after another, which we

2486
01:09:26,705 --> 01:09:27,890
0,90 90,335 445,735 735,1065 1065,1185
can then test postgres real

2487
01:09:27,890 --> 01:09:28,430
0,150 150,300 300,405 405,480 480,540
quickly and see what it

2488
01:09:28,430 --> 01:09:29,300
0,230
does.|
|

2489
01:09:29,510 --> 01:09:29,930
0,75 75,135 135,195 195,285 285,420
I don't think I have
我不认为我在这里抄袭过。

2490
01:09:29,930 --> 01:09:31,240
0,315 315,590
copied here.|
|

2491
01:09:31,250 --> 01:09:32,760
0,400
Hmm.|
嗯。|

2492
01:09:35,270 --> 01:09:36,790
0,395 395,790 1110,1340 1340,1460 1460,1520
Yeah, sorry, I don't have
是的，对不起，我不需要很快地复制粘贴它。

2493
01:09:36,790 --> 01:09:37,375
0,60 60,195 195,405 405,495 495,585
to copy paste it real

2494
01:09:37,375 --> 01:09:39,080
0,245
quickly.|
|

2495
01:09:39,330 --> 01:09:40,055
0,245 245,365 365,485 485,560 560,725
You can try it online
你可以稍后在网上试一下。

2496
01:09:40,055 --> 01:09:41,580
0,335
later.|
|

2497
01:09:42,520 --> 01:09:43,140
0,245 245,395 395,515 515,560 560,620
The last thing I want
我想向您展示的最后一件事是公用表表达式。

2498
01:09:43,140 --> 01:09:44,250
0,75 75,210 210,390 390,680 790,1110
to show you is common

2499
01:09:44,250 --> 01:09:45,660
0,255 255,740
table expressions.|
|

2500
01:09:46,140 --> 01:09:48,190
0,290 290,580 1170,1640 1640,1805 1805,2050
And so cte were added
因此，CTE是在1020年前增加的。

2501
01:09:48,480 --> 01:09:51,660
0,920 920,1270 1410,1810
1020 years ago.|
|

2502
01:09:51,660 --> 01:09:54,165
0,290 730,1020 1020,1310 2020,2340 2340,2505
And this is similar to
这类似于嵌套查询，类似于。

2503
01:09:54,165 --> 01:09:55,640
0,270 270,615 615,810 810,1095 1095,1475
nested queries are similar to.|
|

2504
01:09:57,060 --> 01:09:58,395
0,210 210,360 360,590 790,1125 1125,1335
If you're writing data to
如果您要将数据写入临时表或类似的东西，这是我们指定希望实现的查询的一种方式。

2505
01:09:58,395 --> 01:09:59,100
0,150 150,315 315,480 480,600 600,705
a temp table or something

2506
01:09:59,100 --> 01:10:00,570
0,120 120,380 820,1110 1110,1215 1215,1470
like that, it's a way

2507
01:10:00,570 --> 01:10:02,895
0,225 225,405 405,740 1690,2190 2190,2325
for us to specify a

2508
01:10:02,895 --> 01:10:03,585
0,210 210,360 360,465 465,585 585,690
query that we want to

2509
01:10:03,585 --> 01:10:05,220
0,180 180,755
get materialized.|
|

2510
01:10:05,220 --> 01:10:05,640
0,180 180,255 255,345 345,375 375,420
Maybe we don't want to
也许我们不想用这个词。我们希望指定一个查询，该查询可能是。

2511
01:10:05,640 --> 01:10:06,780
0,90 90,195 195,440 760,1020 1020,1140
use that word. We want

2512
01:10:06,780 --> 01:10:07,875
0,165 165,465 465,585 585,855 855,1095
to specify a query that

2513
01:10:07,875 --> 01:10:08,980
0,135 135,395
could be.|
|

2514
01:10:09,110 --> 01:10:11,215
0,460 570,845 845,1145 1145,1450 1770,2105
Stored in quotation Marks at
存储在某个虚拟表处的引号中。

2515
01:10:11,215 --> 01:10:13,200
0,330 330,720 720,1115
some virtual table.|
|

2516
01:10:13,200 --> 01:10:14,055
0,240 240,420 420,555 555,645 645,855
And then we can have
然后我们可以有另一个引用的查询，无论它里面是什么。

2517
01:10:14,055 --> 01:10:15,510
0,315 315,570 570,705 705,965 1195,1455
another query of reference, whatever

2518
01:10:15,510 --> 01:10:16,880
0,180 180,390 390,510 510,740
is inside of it.|
|

2519
01:10:17,560 --> 01:10:18,720
0,400
Right.|
正确的。|

2520
01:10:18,790 --> 01:10:19,830
0,320 320,485 485,620 620,815 815,1040
So in my really simple
在我非常简单的例子中，我有这个WITH子句。我给我的CTE一个名字，然后我有我的as语句，然后这个圆括号里的任何东西，这里的任何SELECT查询都将绑定到这个。

2521
01:10:19,830 --> 01:10:22,245
0,240 240,560 790,1095 1095,1400 2110,2415
example here, I have this

2522
01:10:22,245 --> 01:10:24,315
0,240 240,605 1075,1380 1380,1685 1765,2070
with clause. I give my

2523
01:10:24,315 --> 01:10:26,115
0,390 390,585 585,875 1435,1695 1695,1800
cte a name, then I

2524
01:10:26,115 --> 01:10:27,660
0,120 120,270 270,545 1045,1365 1365,1545
have my as statement, and

2525
01:10:27,660 --> 01:10:29,060
0,210 210,540 540,690 690,855 855,1400
then whatever's inside this parentheses,

2526
01:10:29,350 --> 01:10:30,855
0,305 305,470 470,680 680,1000 1200,1505
whatever select query here is

2527
01:10:30,855 --> 01:10:32,150
0,135 135,210 210,390 390,725 895,1295
going to get bound to

2528
01:10:32,530 --> 01:10:33,600
0,400
this.|
|

2529
01:10:33,750 --> 01:10:36,290
0,400 960,1310 1310,1660 2160,2405 2405,2540
This name here, and then
在这里输入这个名称，然后在Width语句后面的下面进行编辑。

2530
01:10:36,290 --> 01:10:38,080
0,360 360,620 730,1035 1035,1340 1390,1790
editing that comes below after

2531
01:10:38,280 --> 01:10:39,800
0,260 260,470 470,760
the width statement.|
|

2532
01:10:39,800 --> 01:10:41,015
0,195 195,450 450,765 765,1035 1035,1215
Can then reference it as
然后可以引用它，就好像它是一个表。

2533
01:10:41,015 --> 01:10:41,800
0,135 135,255 255,360 360,495 495,785
if it was a table.|
|

2534
01:10:45,670 --> 01:10:46,780
0,400
Right.|
正确的。|

2535
01:10:46,990 --> 01:10:49,070
0,260 260,440 440,760 1590,1835 1835,2080
So again, some like this,
再说一次，像这样的，所以我基本上是AS子句约束了一些东西。

2536
01:10:49,300 --> 01:10:51,255
0,400 450,850 1080,1480 1500,1760 1760,1955
so I essentially the as

2537
01:10:51,255 --> 01:10:52,970
0,255 255,450 450,975 975,1320 1320,1715
clause is binding things to.|
|

2538
01:10:54,310 --> 01:10:56,040
0,395 395,680 680,970 1080,1490 1490,1730
Names to whatever, whatever's inside
不管是什么名字，不管我的宽度声明里有什么。因此，我又有了一个无表查询。选择1和2，将产生1，2有一列1，一列2，但是在我的。

2539
01:10:56,040 --> 01:10:57,525
0,225 225,435 435,630 630,950 1120,1485
my width statement here. So

2540
01:10:57,525 --> 01:10:59,295
0,210 210,405 405,755 895,1295 1435,1770
I have again a no

2541
01:10:59,295 --> 01:11:00,450
0,270 270,585 585,855 855,1035 1035,1155
table query. Select one and

2542
01:11:00,450 --> 01:11:01,125
0,165 165,390 390,435 435,510 510,675
two that's going to produce

2543
01:11:01,125 --> 01:11:02,850
0,195 195,435 435,735 735,1085 1435,1725
one, two has a one

2544
01:11:02,850 --> 01:11:03,675
0,150 150,285 285,480 480,675 675,825
column of one, one column

2545
01:11:03,675 --> 01:11:05,520
0,150 150,425 805,1080 1080,1355 1465,1845
of two, but then within

2546
01:11:05,520 --> 01:11:07,220
0,380
my.|
|

2547
01:11:07,220 --> 01:11:08,030
0,120 120,270 270,495 495,660 660,810
With my width statement up
在这里使用我的Width语句，我现在可以给列命名，然后可以在下面的查询中引用这些名称。

2548
01:11:08,030 --> 01:11:08,915
0,165 165,330 330,465 465,645 645,885
here, I can give now

2549
01:11:08,915 --> 01:11:10,550
0,270 270,480 480,935 1165,1455 1455,1635
names the columns, which then

2550
01:11:10,550 --> 01:11:11,620
0,135 135,255 255,630 630,780 780,1070
can be referenced down below

2551
01:11:11,670 --> 01:11:13,700
0,400 750,995 995,1270
in the query.|
|

2552
01:11:16,270 --> 01:11:17,160
0,245 245,335 335,455 455,650 650,890
You can do weird things
你也可以做一些奇怪的事情，就像你实际上可以做的一样，在postgres中会让你给列命名相同的东西，但是当你在下面实际尝试引用它时，它会抛出一个错误。同样，这个示例中的语法大致相同，但语义在不同的系统中可能会有所不同。

2553
01:11:17,160 --> 01:11:18,290
0,255 255,450 450,570 570,780 780,1130
too, like you can actually,

2554
01:11:18,670 --> 01:11:19,845
0,320 320,740 740,875 875,995 995,1175
in postgres will let you

2555
01:11:19,845 --> 01:11:20,865
0,195 195,420 420,615 615,915 915,1020
actually name the columns the

2556
01:11:20,865 --> 01:11:23,415
0,165 165,485 1555,1815 1815,2075 2275,2550
same thing, but then when

2557
01:11:23,415 --> 01:11:24,120
0,195 195,360 360,450 450,540 540,705
you actually try to reference

2558
01:11:24,120 --> 01:11:25,215
0,180 180,440 460,855 855,990 990,1095
it below, it'll throw an

2559
01:11:25,215 --> 01:11:29,310
0,245 1555,1955 3295,3555 3555,3810 3810,4095
error. So again, this example

2560
01:11:29,310 --> 01:11:30,680
0,195 195,390 390,810 810,1065 1065,1370
where the syntax is, is

2561
01:11:30,730 --> 01:11:31,680
0,320 320,500 500,665 665,815 815,950
roughly the same, but the

2562
01:11:31,680 --> 01:11:33,285
0,710 730,975 975,1080 1080,1290 1290,1605
semantics can be different across

2563
01:11:33,285 --> 01:11:34,840
0,270 270,555 555,935
across different systems.|
|

2564
01:11:35,370 --> 01:11:36,635
0,320 320,485 485,680 680,1000 1020,1265
Let's see. So let's how
让我们看看。那么让我们来看看我们真正想要如何使用它。因此，对于这个问题，我想再次找到注册了至少一门课程的最高ID的学生记录。同样，您展示了示例如何使用嵌套查询来实现这一点，就像我们对连接所做的那样。但现在我们可以使用CTE，在CT中，我要做的第一件事是从注册表中计算最大学生ID。

2565
01:11:36,635 --> 01:11:37,070
0,120 120,225 225,285 285,345 345,435
we actually want to use

2566
01:11:37,070 --> 01:11:37,745
0,150 150,270 270,345 345,465 465,675
this. So for this one,

2567
01:11:37,745 --> 01:11:39,275
0,335 655,900 900,1020 1020,1260 1260,1530
again, want to find the

2568
01:11:39,275 --> 01:11:40,325
0,210 210,495 495,750 750,915 915,1050
student record that has the

2569
01:11:40,325 --> 01:11:41,450
0,150 150,435 435,720 720,1050 1050,1125
highest ID that's enrolled in

2570
01:11:41,450 --> 01:11:43,010
0,120 120,315 315,620 1120,1410 1410,1560
least one course. Again, you

2571
01:11:43,010 --> 01:11:43,775
0,135 135,300 300,495 495,660 660,765
showed how examples how to

2572
01:11:43,775 --> 01:11:45,305
0,90 90,335 565,900 900,1260 1260,1530
do this with nested queries

2573
01:11:45,305 --> 01:11:46,270
0,105 105,180 180,300 300,450 450,965
that we do with joins.

2574
01:11:47,160 --> 01:11:47,915
0,230 230,350 350,485 485,575 575,755
But now we can do

2575
01:11:47,915 --> 01:11:49,715
0,195 195,330 330,755 1165,1530 1530,1800
with the cte where inside

2576
01:11:49,715 --> 01:11:50,840
0,165 165,615 615,870 870,990 990,1125
the CT, first thing I'm

2577
01:11:50,840 --> 01:11:52,450
0,60 60,150 150,360 360,710 1060,1610
going to do is compute

2578
01:11:53,040 --> 01:11:54,875
0,275 275,515 515,755 755,1030 1560,1835
the Max student ID from

2579
01:11:54,875 --> 01:11:56,220
0,105 105,450 450,725
the enrolled table.|
|

2580
01:11:56,220 --> 01:11:57,210
0,165 165,315 315,585 585,810 810,990
And then now in my
现在，在下面的SELECT语句中，我可以引用CTE来获取Max ID，然后对其进行联接。

2581
01:11:57,210 --> 01:11:58,725
0,210 210,390 390,555 555,830 1240,1515
select statement down below, I

2582
01:11:58,725 --> 01:12:00,645
0,210 210,545 685,990 990,1445 1645,1920
can reference my cte to

2583
01:12:00,645 --> 01:12:02,490
0,165 165,345 345,555 555,875 1585,1845
get that Max ID and

2584
01:12:02,490 --> 01:12:04,005
0,255 255,540 540,830 1030,1335 1335,1515
then do my join on

2585
01:12:04,005 --> 01:12:04,860
0,275
that.|
|

2586
01:12:07,020 --> 01:12:08,090
0,260 260,410 410,650 650,920 920,1070
Again, the data session should
同样，数据会话应该足够智能，能够意识到，哦，我只需运行CTE一次，具体化它，然后现在我就可以在调用它的任何查询中引用它，就像它是一个临时表一样。

2587
01:12:08,090 --> 01:12:08,960
0,135 135,300 300,420 420,600 600,870
be smart enough to realize

2588
01:12:08,960 --> 01:12:10,370
0,350 610,945 945,1155 1155,1305 1305,1410
that, oh, I only have

2589
01:12:10,370 --> 01:12:12,365
0,105 105,360 360,740 1330,1620 1620,1995
to run this, the cte

2590
01:12:12,365 --> 01:12:14,165
0,335 475,975 975,1265 1345,1620 1620,1800
once, materialize it, and then

2591
01:12:14,165 --> 01:12:15,095
0,225 225,405 405,525 525,720 720,930
now I can reference it

2592
01:12:15,095 --> 01:12:16,070
0,135 135,255 255,375 375,635 715,975
as if it was a

2593
01:12:16,070 --> 01:12:18,275
0,165 165,470 790,1190 1690,1995 1995,2205
temp table in any query

2594
01:12:18,275 --> 01:12:19,420
0,225 225,465 465,645 645,840 840,1145
below that that calls it.|
|

2595
01:12:23,130 --> 01:12:24,340
0,275 275,440 440,635 635,800 800,1210
And any question about cts.|
还有任何关于CTS的问题。|

2596
01:12:27,930 --> 01:12:29,100
0,400
Okay.|
好吧。|

2597
01:12:29,450 --> 01:12:30,595
0,290 290,395 395,515 515,790 840,1145
There to finish up, right.
就这样结束了，对。因此，希望从这一切中得到的主要结论是，SQL不是一种已死的语言。你可以用它做很多很酷的事情。您希望尝试在一条语句中进行尽可能多的计算。现在它可以，可以是嵌套的查询，可以做里面的许多奇怪的事情。我们无法避免在客户端和服务器之间来回往返，因为从理论上讲，数据库系统应该足够智能，知道执行您提供给它的查询的最佳方式是什么。

2598
01:12:30,595 --> 01:12:31,990
0,305 355,755 835,1140 1140,1290 1290,1395
So again, hopefully the main

2599
01:12:31,990 --> 01:12:32,470
0,120 120,240 240,330 330,405 405,480
take away from all of

2600
01:12:32,470 --> 01:12:33,250
0,105 105,255 255,450 450,705 705,780
this is that sql is

2601
01:12:33,250 --> 01:12:33,985
0,90 90,165 165,285 285,510 510,735
not a dead language. There's

2602
01:12:33,985 --> 01:12:34,465
0,45 45,120 120,225 225,345 345,480
a lot of cool things

2603
01:12:34,465 --> 01:12:35,100
0,105 105,195 195,300 300,390 390,635
you can do with it.

2604
01:12:36,260 --> 01:12:37,420
0,245 245,335 335,485 485,785 785,1160
You want to try to

2605
01:12:37,420 --> 01:12:38,530
0,240 240,375 375,555 555,960 960,1110
do as much computations as

2606
01:12:38,530 --> 01:12:39,540
0,135 135,285 285,510 510,735 735,1010
you can within a single

2607
01:12:40,370 --> 01:12:41,725
0,400 780,1025 1025,1115 1115,1190 1190,1355
statement. Now it can be,

2608
01:12:41,725 --> 01:12:42,640
0,165 165,255 255,525 525,810 810,915
can be nested queries, can

2609
01:12:42,640 --> 01:12:43,090
0,90 90,195 195,270 270,345 345,450
do much of all the

2610
01:12:43,090 --> 01:12:44,070
0,165 165,405 405,615 615,735 735,980
weird stuff inside of it.

2611
01:12:44,750 --> 01:12:45,820
0,260 260,455 455,665 665,860 860,1070
We wouldn't avoid the round

2612
01:12:45,820 --> 01:12:46,675
0,270 270,435 435,585 585,720 720,855
trips going back and forth

2613
01:12:46,675 --> 01:12:48,385
0,135 135,285 285,575 595,995 1435,1710
between the client and and

2614
01:12:48,385 --> 01:12:50,275
0,165 165,455 625,930 930,1235 1615,1890
the server because again, the

2615
01:12:50,275 --> 01:12:51,780
0,240 240,605 715,990 990,1185 1185,1505
database system should in theory

2616
01:12:51,830 --> 01:12:52,800
0,335 335,530 530,650 650,740 740,970
be smart enough to know

2617
01:12:52,850 --> 01:12:53,830
0,365 365,455 455,605 605,785 785,980
what's the best way to

2618
01:12:53,830 --> 01:12:54,580
0,195 195,300 300,450 450,585 585,750
execute the query that you're

2619
01:12:54,580 --> 01:12:55,620
0,165 165,405 405,645 645,810 810,1040
giving to giving to it.|
|

2620
01:12:56,270 --> 01:12:57,145
0,230 230,320 320,485 485,695 695,875
Soon as you take stuff
一旦您从数据库中取出一些东西，就在上面做一些Python代码。这显然超出了数据库系统的范围。所以我们无法对其进行优化。不能优化这一点，因为那是一段Python代码。如果你把所有的东西都放在数据库系统里，它应该能够很好地努力如何进一步优化它。

2621
01:12:57,145 --> 01:12:58,975
0,135 135,225 225,300 300,545 1555,1830
out of the database, do

2622
01:12:58,975 --> 01:12:59,755
0,135 135,435 435,585 585,690 690,780
some python code on it.

2623
01:12:59,755 --> 01:13:01,240
0,240 240,495 495,795 795,1110 1110,1485
That's obviously outside the purview

2624
01:13:01,240 --> 01:13:02,380
0,60 60,135 135,300 300,620 910,1140
of the database system. So

2625
01:13:02,380 --> 01:13:03,505
0,90 90,390 390,675 675,855 855,1125
we can't optimize it. Can't

2626
01:13:03,505 --> 01:13:04,740
0,255 255,450 450,645 645,945 945,1235
optimize that, that python code.

2627
01:13:05,120 --> 01:13:05,980
0,230 230,305 305,500 500,725 725,860
If you keep everything inside

2628
01:13:05,980 --> 01:13:07,450
0,105 105,285 285,620 1030,1320 1320,1470
of database system, it should

2629
01:13:07,450 --> 01:13:08,350
0,90 90,180 180,440 520,780 780,900
be able to make a

2630
01:13:08,350 --> 01:13:09,550
0,105 105,285 285,620 700,990 990,1200
good effort how to optimize

2631
01:13:09,550 --> 01:13:10,380
0,135 135,410
it further.|
|

2632
01:13:10,380 --> 01:13:11,130
0,255 255,450 450,600 600,660 660,750
And again, also the main
再说一次，所有这一切的主要结论是，没有人确切地遵循SQL标准。每个单独的数据库系统都将略有不同。

2633
01:13:11,130 --> 01:13:11,715
0,240 240,330 330,405 405,480 480,585
takeaway from all of this

2634
01:13:11,715 --> 01:13:13,080
0,135 135,395 865,1110 1110,1230 1230,1365
is that there is a

2635
01:13:13,080 --> 01:13:15,020
0,225 225,500 730,1080 1080,1430 1540,1940
sql standard nobody follows exactly.

2636
01:13:15,370 --> 01:13:16,620
0,320 320,515 515,710 710,995 995,1250
Every single database system is

2637
01:13:16,620 --> 01:13:17,420
0,105 105,150 150,270 270,480 480,800
going to be slightly different.|
|

2638
01:13:19,220 --> 01:13:20,440
0,350 350,635 635,815 815,980 980,1220
People claim that, oh, it's
人们声称，哦，如果你支持SQL就太好了，因为这样你就可以随身携带了。就像如果我在我的SQL上阅读我的应用程序，我可以很容易地将它移植到Postgres。无论您一开始选择什么数据系统，这都不是时代的情况，您将在很长一段时间内被困在移动的数据系统中。

2639
01:13:20,440 --> 01:13:21,685
0,255 255,510 510,645 645,825 825,1245
great if you support sql

2640
01:13:21,685 --> 01:13:22,420
0,195 195,315 315,420 420,510 510,735
because then you can go

2641
01:13:22,420 --> 01:13:23,515
0,240 240,405 405,720 720,915 915,1095
and be portable. Like if

2642
01:13:23,515 --> 01:13:24,570
0,105 105,225 225,435 435,720 720,1055
I read my application on

2643
01:13:25,010 --> 01:13:26,545
0,275 275,440 440,910 1140,1400 1400,1535
on my sql, I could

2644
01:13:26,545 --> 01:13:27,370
0,180 180,405 405,600 600,735 735,825
very easily just port it

2645
01:13:27,370 --> 01:13:28,690
0,90 90,590 820,1065 1065,1170 1170,1320
to postgres. That is not

2646
01:13:28,690 --> 01:13:31,495
0,135 135,380 1720,2115 2115,2510 2530,2805
the case of times whatever

2647
01:13:31,495 --> 01:13:32,260
0,180 180,405 405,585 585,690 690,765
data system you pick at

2648
01:13:32,260 --> 01:13:33,535
0,120 120,410 700,1080 1080,1155 1155,1275
the beginning, that's what you're

2649
01:13:33,535 --> 01:13:34,060
0,30 30,75 75,195 195,360 360,525
going to be stuck with

2650
01:13:34,060 --> 01:13:37,780
0,120 120,195 195,360 360,2930 3460,3720
for a long times to

2651
01:13:37,780 --> 01:13:39,100
0,260
move.|
|

2652
01:13:39,140 --> 01:13:40,530
0,275 275,500 500,800 800,1070 1070,1390
All alright, so last thing,
好了，最后一件事，家庭作业。第一，它将在今天出版。它将编写SQL查询。进行基本数据分析。今年，我们将要求你在Sqel Light和Date Bam上做到这一点。

2653
01:13:40,700 --> 01:13:41,950
0,350 350,700 720,1010 1010,1085 1085,1250
homework. One, it be out

2654
01:13:41,950 --> 01:13:43,375
0,320 790,1095 1095,1155 1155,1245 1245,1425
today. It's gonna be writing

2655
01:13:43,375 --> 01:13:44,530
0,285 285,540 540,675 675,885 885,1155
sql queries. Do basic data

2656
01:13:44,530 --> 01:13:46,480
0,320 1210,1530 1530,1710 1710,1845 1845,1950
analysis. This year we're gonna

2657
01:13:46,480 --> 01:13:47,005
0,180 180,300 300,375 375,450 450,525
require you to do it

2658
01:13:47,005 --> 01:13:48,310
0,165 165,465 465,675 675,930 930,1305
on sqel light and ductee

2659
01:13:48,310 --> 01:13:51,440
0,380
bam.|
|

2660
01:13:53,210 --> 01:13:54,550
0,365 365,620 620,845 845,1100 1100,1340
Reason why is because you
原因是，因为您编写相同的查询，语法会略有不同，不会太差，但您将运行相同的查询和sqlite，然后运行ducteeb，您将看到哪个速度更快，这个顿悟比另一个快得多，猜测得更快。

2661
01:13:54,550 --> 01:13:55,375
0,240 240,465 465,570 570,690 690,825
write, you write the same

2662
01:13:55,375 --> 01:13:56,665
0,335 475,855 855,960 960,1080 1080,1290
query, syntax will be slightly

2663
01:13:56,665 --> 01:13:57,400
0,210 210,330 330,480 480,585 585,735
different, it won't be too

2664
01:13:57,400 --> 01:13:59,200
0,260 550,950 1180,1515 1515,1650 1650,1800
bad, but you'll run the

2665
01:13:59,200 --> 01:14:00,460
0,180 180,450 450,645 645,1080 1080,1260
same query and sqlite and

2666
01:14:00,460 --> 01:14:01,750
0,135 135,210 210,300 300,860 1030,1290
you're run the ducteeb and

2667
01:14:01,750 --> 01:14:05,725
0,180 180,285 285,495 495,860 3700,3975
you'll see which faster you

2668
01:14:05,725 --> 01:14:07,840
0,120 120,225 225,815 1525,1845 1845,2115
have this epiphany much faster

2669
01:14:07,840 --> 01:14:10,290
0,195 195,285 285,420 420,710 2050,2450
than the other one, guess

2670
01:14:10,490 --> 01:14:16,580
0,400
faster.|
|

2671
01:14:16,800 --> 01:14:18,380
0,305 305,610 870,1175 1175,1340 1340,1580
More efficient, says more efficient
更有效率，说更有效率的曲帕格并非如此。这也不是答案。

2672
01:14:18,380 --> 01:14:27,530
0,380 760,4640 8440,8685 8685,8895 8895,9150
Qu partg is not. That's

2673
01:14:27,530 --> 01:14:32,840
0,75 75,150 150,285 285,590
not the answer either.|
|

2674
01:14:35,375 --> 01:14:36,245
0,75 75,180 180,285 285,515 535,870
That's not the reason. Okay?
这不是原因。好吧?所以您运行这些查询时，ducteeb应该会更快。

2675
01:14:36,245 --> 01:14:37,790
0,335 535,825 825,990 990,1140 1140,1545
So you run these queries,

2676
01:14:37,790 --> 01:14:40,120
0,540 540,720 720,870 870,1160
ducteeb should be faster.|
|

2677
01:14:40,120 --> 01:14:41,130
0,195 195,270 270,480 480,720 720,1010
You'll be like okay why
你会说，好吧，为什么这就是这学期剩下的时间，就是谈论你如何建立一个系统，每克28克，这取决于它是不是你还没有打到暴徒，还没有闭上你的嘴，我用剪刀的底部打你，告诉你抬起头，展示给我看它是什么，因为你的脸被打了回去，我有黑板敲打，f不能追踪，风格就像是大便，你不能在多米尼加穿，或者你得叫我多米尼加黑色偷偷的黑色皮革，我整个黑色的脏八发送去你到了每一个大门，你得到了你的勇气，试图滑冰，这是你的第一个错误，我在排队买蛋糕，你的粉丝看到你醒来。

2678
01:14:41,330 --> 01:14:42,160
0,380 380,485 485,605 605,725 725,830
that's the rest of this

2679
01:14:42,160 --> 01:14:48,100
0,320 3790,4035 4035,4140 4140,4400 5650,5940
semester be it for talking

2680
01:14:48,100 --> 01:15:10,285
0,150 150,285 285,435 435,570 570,22185
how you build a systemfuck

2681
01:15:10,285 --> 01:15:12,030
0,270 270,575 685,1215 1215,1410 1410,1745
hook up 28 a gram

2682
01:15:12,110 --> 01:15:13,500
0,335 335,560 560,725 725,1040 1040,1390
depending on if it's up

2683
01:15:13,610 --> 01:15:14,560
0,260 260,485 485,605 605,755 755,950
you ain't hit the mob

2684
01:15:14,560 --> 01:15:15,895
0,320 460,765 765,960 960,1155 1155,1335
yet still got your shut

2685
01:15:15,895 --> 01:15:16,915
0,225 225,510 510,765 765,900 900,1020
up I smack you with

2686
01:15:16,915 --> 01:15:18,235
0,165 165,405 405,735 735,1155 1155,1320
the bottom of cliper tell

2687
01:15:18,235 --> 01:15:19,450
0,180 180,375 375,665 775,1065 1065,1215
you look up show me

2688
01:15:19,450 --> 01:15:20,410
0,105 105,240 240,450 450,735 735,960
what it sa at for

2689
01:15:20,410 --> 01:15:21,505
0,150 150,330 330,540 540,795 795,1095
a blow your face back

2690
01:15:21,505 --> 01:15:22,825
0,240 240,375 375,540 540,1020 1020,1320
I got a blackboard taps

2691
01:15:22,825 --> 01:15:24,240
0,240 240,510 510,885 885,1110 1110,1415
the f can't trace that

2692
01:15:24,290 --> 01:15:25,555
0,320 320,485 485,725 725,1025 1025,1265
styl is like t for

2693
01:15:25,555 --> 01:15:26,755
0,270 270,510 510,825 825,1020 1020,1200
poop you can't lace that

2694
01:15:26,755 --> 01:15:28,240
0,150 150,300 300,1065 1065,1320 1320,1485
at the Dominican or you

2695
01:15:28,240 --> 01:15:29,995
0,255 255,510 510,675 675,1395 1395,1755
got call me Dominican black

2696
01:15:29,995 --> 01:15:31,690
0,435 435,690 690,1095 1095,1380 1380,1695
sclly black leather black Su

2697
01:15:31,690 --> 01:15:33,325
0,555 555,750 750,1005 1005,1335 1335,1635
timberlands my whole black dirty

2698
01:15:33,325 --> 01:15:34,255
0,225 225,435 435,630 630,795 795,930
eight to send you to

2699
01:15:34,255 --> 01:15:35,575
0,150 150,420 420,785 925,1185 1185,1320
the per gates you get

2700
01:15:35,575 --> 01:15:36,745
0,495 495,660 660,810 810,1005 1005,1170
youravat trying to skate and

2701
01:15:36,745 --> 01:15:38,245
0,210 210,330 330,600 600,995 1195,1500
that's your first mistake I

2702
01:15:38,245 --> 01:15:39,250
0,180 180,435 435,660 660,810 810,1005
in line for that cake

2703
01:15:39,250 --> 01:15:40,330
0,180 180,450 450,690 690,840 840,1080
your fam see you wake.|
|

2704
01:15:40,460 --> 01:15:41,560
0,290 290,485 485,650 650,845 845,1100
My grand is heavy weight,
我的体重很重，红色的韦比告诉他我是如何生活的，我生活得很好。

2705
01:15:41,560 --> 01:15:42,690
0,195 195,390 390,555 555,825 825,1130
the red, the webby state

2706
01:15:43,280 --> 01:15:44,395
0,275 275,500 500,710 710,950 950,1115
how I'm living to tell

2707
01:15:44,395 --> 01:15:50,484
0,150 150,315 315,585 585,965
him I living great.|
|

