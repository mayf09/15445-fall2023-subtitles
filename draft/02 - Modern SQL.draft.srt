1
00:00:34,900 --> 00:00:37,620
0,400
{All,right}.|
好的。|

2
00:00:37,690 --> 00:00:39,885
0,230 230,410 410,680 680,1000 1920,2195
All right, so {} some
好的，上节课的一些快速的东西，行政的东西，

3
00:00:39,885 --> 00:00:41,550
0,180 180,485 625,1065 1065,1320 1320,1665
quick things, administrative things from

4
00:00:41,550 --> 00:00:43,815
0,240 240,405 405,690 690,1070 1930,2265
from last class,| {} it's
|才过了一天，我们已经收到电子邮件了，

5
00:00:43,815 --> 00:00:44,505
0,105 105,225 225,360 360,540 540,690
only been one day. We

6
00:00:44,505 --> 00:00:46,460
0,120 120,375 375,755 1015,1415 1555,1955
already got emails,| {} so
|第一件事是，

7
00:00:46,930 --> 00:00:47,810
0,260 260,395 395,530 530,635 635,880
the first thing is that,|
|

8
00:00:47,860 --> 00:00:48,945
0,260 260,365 365,515 515,785 785,1085
I made a mistake last
上节课我犯了一个错误，

9
00:00:48,945 --> 00:00:50,100
0,270 270,480 480,645 645,855 855,1155
class,| I said Ted Codd
|我说 Ted Codd 在宾夕法尼亚大学获得了博士学位，

10
00:00:50,100 --> 00:00:51,950
0,120 120,270 270,780 780,1130 1450,1850
got his PhD at Penn,|
|

11
00:00:52,360 --> 00:00:53,085
0,245 245,320 320,410 410,650 650,725
he got his PhD at
他实际是在密歇根获得博士学位，

12
00:00:53,085 --> 00:00:54,465
0,245 655,930 930,1110 1110,1260 1260,1380
Michigan,| where all the great
|所有优秀的数据人都在那里获得了博士学位，

13
00:00:54,465 --> 00:00:55,760
0,195 195,375 375,540 540,705 705,1295
data people got their PHDs,|
|

14
00:00:56,560 --> 00:00:58,905
0,400 1500,1790 1790,1955 1955,2240 2240,2345
so Michael {Stonebraker -} got
Michael Stonebraker 在那里获得了他的博士学位，

15
00:00:58,905 --> 00:00:59,700
0,105 105,255 255,405 405,585 585,795
his {PHD -} there,| Ted
|Ted Codd 在那里得到了他的博士学位，

16
00:00:59,700 --> 00:01:00,345
0,165 165,285 285,375 375,495 495,645
Codd got his {PHD -}

17
00:01:00,345 --> 00:01:01,410
0,180 180,390 390,705 705,900 900,1065
there,| David DeWitt another famous
|David Dewitt 也是，另一个著名的 David ，

18
00:01:01,410 --> 00:01:02,490
0,210 210,530 700,930 930,990 990,1080
Davis guy,| so it was
|所以不是宾夕法尼亚，而是密歇根。

19
00:01:02,490 --> 00:01:04,455
0,165 165,465 465,765 765,1070 1720,1965
not Penn it was, it

20
00:01:04,455 --> 00:01:05,790
0,105 105,365 835,1065 1065,1185 1185,1335
was Michigan.| The other thing
|另一件事是人们对音频有这样的抱怨，

21
00:01:05,790 --> 00:01:07,785
0,135 135,390 390,765 765,1160 1720,1995
is people complain that about

22
00:01:07,785 --> 00:01:09,315
0,120 120,365 745,1005 1005,1265 1285,1530
the audio,| {Dear,Andy}, the
|亲爱的 Andy ，你课上的音频很烂，

23
00:01:09,315 --> 00:01:10,245
0,150 150,300 300,405 405,585 585,930
audio of your class sucks,|
|

24
00:01:10,245 --> 00:01:11,040
0,75 75,165 165,465 465,645 645,795
so I can't see you
所以我看你请不起音响工程师，是这样吗，

25
00:01:11,040 --> 00:01:11,940
0,150 150,270 270,510 510,780 780,900
afford a sound engineer, do

26
00:01:11,940 --> 00:01:13,110
0,90 90,350 550,870 870,1050 1050,1170
it right,| Andy, I love
|Andy ，我喜欢这门课，但我听不下去，

27
00:01:13,110 --> 00:01:13,860
0,150 150,345 345,495 495,600 600,750
the course, but I can't

28
00:01:13,860 --> 00:01:14,445
0,135 135,300 300,390 390,465 465,585
listen {to,it},| because the audio
|因为音频太混乱了，

29
00:01:14,445 --> 00:01:15,465
0,135 135,345 345,540 540,750 750,1020
is messed up,| what happened
|你这么做的时候发生了什么，

30
00:01:15,465 --> 00:01:16,410
0,270 270,435 435,570 570,780 780,945
while you're doing this,| I
|我失去了活下去的方式。

31
00:01:16,410 --> 00:01:18,470
0,150 150,285 285,420 420,710 1660,2060
lost a {way,to -} live.| So
|所以上次是我的错，

32
00:01:18,760 --> 00:01:20,025
0,400 510,770 770,905 905,1070 1070,1265
that that was my fault

33
00:01:20,025 --> 00:01:21,015
0,195 195,435 435,630 630,780 780,990
last time,| so we're double
|所以我们正在重复录制，

34
00:01:21,015 --> 00:01:22,320
0,330 330,525 525,755 925,1170 1170,1305
recording,| so hopefully we won't
|所以希望这次我们在发布它时不会有任何问题。

35
00:01:22,320 --> 00:01:24,600
0,75 75,320 400,800 1690,1980 1980,2280
have any issues with posting

36
00:01:24,600 --> 00:01:25,665
0,225 225,450 450,710 730,975 975,1065
it this time.| And then
|然后我们收到了关于你的电子邮件，

37
00:01:25,665 --> 00:01:26,850
0,165 165,330 330,575 745,1035 1035,1185
we actually got emails about

38
00:01:26,850 --> 00:01:29,270
0,260 940,1200 1200,1460 1690,2055 2055,2420
you,| which is surprising, right,|
|这很令人惊讶，对吗，|

39
00:01:29,950 --> 00:01:31,140
0,275 275,470 665,815 815,980 980,1190
I saw DJ {2PL -}
我上个月在匹兹堡的 [21桥表演] 中看了 DJ 2PL 的表演，

40
00:01:31,140 --> 00:01:33,030
0,240 240,510 510,860 1480,1740 1740,1890
last month performing at the

41
00:01:33,030 --> 00:01:34,605
0,290 610,1065 1065,1275 1275,1455 1455,1575
[bridge 21 over show] in

42
00:01:34,605 --> 00:01:36,860
0,540 540,735 735,840 840,1115 1855,2255
Pittsburgh,| is that true?| {All,right}.|
|这是真的吗？|好的。|

43
00:01:37,270 --> 00:01:38,100
0,320 320,455 455,760
You're very lucky
你很幸运得到像他这样的 DJ ，他很贵，

44
00:01:38,100 --> 00:01:39,150
0,345 345,465 465,675 675,840 840,1050
DJ like that, he is

45
00:01:39,150 --> 00:01:41,610
0,380 1690,2070 2070,2220 2220,2340 2340,2460
expensive,| [] have a lot
|[]有很多钱，

46
00:01:41,610 --> 00:01:43,725
0,105 105,350 1660,1920 1920,2025 2025,2115
of money,| does not have
|[]没有很多钱，好的，

47
00:01:43,725 --> 00:01:44,510
0,75 75,165 165,255 255,435 435,785
a lot of money, okay.|
|

48
00:01:45,670 --> 00:01:47,715
0,400 1140,1580 1580,1745 1745,1910 1910,2045
Yo, DJ {2PL -} is
哟，DJ 2PL 很搞笑，他是单身吗，

49
00:01:47,715 --> 00:01:49,380
0,245 475,750 750,960 960,1295 1375,1665
ridiculous, is he single,| I'm
|我在为我的朋友问，

50
00:01:49,380 --> 00:01:54,530
0,180 180,360 360,590 4660,4905 4905,5150
asking for {my,friend},| and then
|然后她就像没有拇指的 Taylor Swift ，

51
00:01:54,610 --> 00:01:55,995
0,350 350,500 500,815 815,1130 1130,1385
she's like Taylor Swift without

52
00:01:55,995 --> 00:01:57,255
0,270 270,810 810,975 975,1110 1110,1260
any thumbs,| I dont know
|我不知道是什么意思，

53
00:01:57,255 --> 00:02:01,340
0,335 2305,2705 3385,3645 3645,3795 3795,4085
means,| so are you single?|
|那么你是单身吗？|

54
00:02:01,900 --> 00:02:09,250
0,465 465,740 1120,1520 3850,4250 7030,7350
I'm not.| All right, anyway.
我不是。|好的，不管怎样，那是他们的问题。

55
00:02:09,250 --> 00:02:12,850
0,285 285,420 420,710 2650,3050 3160,3600
That's their problem.| So today's
|所以今天的课，我们来讲讲 SQL ，

56
00:02:12,850 --> 00:02:13,615
0,135 135,285 285,390 390,525 525,765
class we to talk about

57
00:02:13,615 --> 00:02:16,420
0,485 625,1025 1555,1955 2245,2580 2580,2805
SQL,| {} the last class
|上一节课我们花时间讨论了关系模型，

58
00:02:16,420 --> 00:02:17,155
0,165 165,315 315,480 480,630 630,735
we spent time talk on

59
00:02:17,155 --> 00:02:18,835
0,375 375,635 1015,1320 1320,1515 1515,1680
relational model,| we talked about
|我们讨论了，

60
00:02:18,835 --> 00:02:20,200
0,275 355,630 630,870 870,1170 1170,1365
how,| in my opinion, that
|在我看来，它是对于每个可能的数据库的高级数据模型，

61
00:02:20,200 --> 00:02:22,140
0,255 255,650 970,1275 1275,1560 1560,1940
a superior data model for

62
00:02:22,280 --> 00:02:23,470
0,350 350,635 635,905 905,1085 1085,1190
every possible database,| you can
|你可以认为，

63
00:02:23,470 --> 00:02:24,600
0,105 105,195 195,315 315,590 730,1130
sort of think of,| the
|关系数据模型可以用来表示

64
00:02:24,860 --> 00:02:26,310
0,410 410,665 665,935 935,1175 1175,1450
relational data model can be

65
00:02:27,080 --> 00:02:28,945
0,380 380,650 650,940 1470,1730 1730,1865
used to represent| pretty much
|几乎所有不同的模式。

66
00:02:28,945 --> 00:02:30,250
0,210 210,360 360,540 540,1020 1020,1305
all the different schemes, that

67
00:02:30,250 --> 00:02:31,735
0,180 180,285 285,435 435,740 1240,1485
that are out there.| And
|然后，我们展示了关系代数如何构建块，

68
00:02:31,735 --> 00:02:32,620
0,75 75,180 180,375 375,675 675,885
then we showed how relational

69
00:02:32,620 --> 00:02:33,870
0,315 315,390 390,540 540,830 850,1250
algebra was the building block|
|

70
00:02:34,130 --> 00:02:35,440
0,400 420,725 725,875 875,1070 1070,1310
for how we would execute
关于我们如何在关系数据库上执行查询或定义查询。

71
00:02:35,440 --> 00:02:37,530
0,480 480,860 1000,1380 1380,1815 1815,2090
queries or define queries {to,operate,over},

72
00:02:39,380 --> 00:02:41,185
0,275 275,380 380,620 620,970 1530,1805
on a relational database.| So
|所以，今天的课程真正要讨论的是 SQL ，

73
00:02:41,185 --> 00:02:42,340
0,375 375,540 540,720 720,915 915,1155
today's class is really now

74
00:02:42,340 --> 00:02:43,540
0,180 180,360 360,630 630,1065 1065,1200
to talk about SQL,| which
|它是一种用于与数据库系统交互的声明性或非过程性语言。

75
00:02:43,540 --> 00:02:45,775
0,260 580,870 870,1580 1750,2040 2040,2235
is a declarative or {non-procedural

76
00:02:45,775 --> 00:02:48,930
0,555 555,875 1105,1505 2335,2850 2850,3155
-} language for interacting with

77
00:02:49,190 --> 00:02:50,560
0,275 275,530 530,910
a database system.|
|

78
00:02:50,560 --> 00:02:52,510
0,320 1150,1470 1470,1575 1575,1740 1740,1950
And we'll see over time
我们将看到，随着时间的推移， SQL 已经发展，

79
00:02:52,510 --> 00:02:53,550
0,135 135,285 285,540 540,705 705,1040
is that SQL has evolved,|
|

80
00:02:53,630 --> 00:02:55,375
0,400 660,935 935,1115 1115,1420 1500,1745
where in the beginning, in
在最初的时候，在 1970 年代，当它第一次被定义时，

81
00:02:55,375 --> 00:02:56,290
0,90 90,285 285,720 720,840 840,915
the {1970s -}, when it

82
00:02:56,290 --> 00:02:57,190
0,120 120,360 360,615 615,765 765,900
was first defined,| it was
|它对关系数据库应该是什么样子有非常严格的要求，

83
00:02:57,190 --> 00:02:59,125
0,255 255,540 540,860 1030,1430 1690,1935
very strict about what a

84
00:02:59,125 --> 00:03:00,420
0,240 240,525 525,780 780,990 990,1295
relational database should look like,|
|

85
00:03:00,830 --> 00:03:02,710
0,400 870,1145 1145,1265 1265,1510 1560,1880
but in the last 40
但在过去的 40 年里，

86
00:03:02,710 --> 00:03:04,450
0,320 370,795 795,1130 1150,1455 1455,1740
years,| it's expanded to support
|它得到了扩展，以支持看起来不像是关系的东西，例如 json 。

87
00:03:04,450 --> 00:03:06,060
0,315 315,650 790,1155 1155,1275 1275,1610
things that don't look relational,

88
00:03:06,080 --> 00:03:07,820
0,290 290,665 665,860 860,1150
like json, for example.|
|

89
00:03:07,820 --> 00:03:09,260
0,350 700,945 945,1140 1140,1335 1335,1440
{} So let's, let's start
所以，让我们从头开始，谈谈 SQL 是如何开始的，

90
00:03:09,260 --> 00:03:10,055
0,165 165,375 375,525 525,630 630,795
the beginning, talk about how

91
00:03:10,055 --> 00:03:11,030
0,240 240,390 390,645 645,855 855,975
SQL got started,| and then
|然后我们将讨论在它的现代版本中可以做的更有趣的事情。

92
00:03:11,030 --> 00:03:13,595
0,195 195,360 360,680 1840,2205 2205,2565
we'll talk about the more

93
00:03:13,595 --> 00:03:15,365
0,395 955,1245 1245,1380 1380,1515 1515,1770
interesting things you can do

94
00:03:15,365 --> 00:03:16,810
0,365 385,735 735,1005 1005,1185 1185,1445
in modern versions of it.|
|

95
00:03:17,700 --> 00:03:20,780
0,395 395,790 1350,1750 2430,2870 2870,3080
So the the SQL goes
所以 SQL 回到 1970 年代，

96
00:03:20,780 --> 00:03:22,210
0,255 255,435 435,525 525,770 820,1430
back to the {1970s -}|
|

97
00:03:22,590 --> 00:03:24,350
0,275 275,550 960,1235 1235,1445 1445,1760
and again for Ted Codd,
Ted Codd ，当他写第一篇论文时，

98
00:03:24,350 --> 00:03:25,115
0,90 90,195 195,360 360,540 540,765
when he wrote that first

99
00:03:25,115 --> 00:03:26,810
0,335 685,960 960,1275 1275,1515 1515,1695
paper,| he didn't define a
|他还没有定义用于操作关系数据库的编程语言，

100
00:03:26,810 --> 00:03:28,865
0,240 240,620 880,1280 1510,1800 1800,2055
programming language for operating relational

101
00:03:28,865 --> 00:03:30,370
0,435 435,525 525,600 600,750 750,1505
databases,| it was all mathematical,|
|这一切都是数学上的，|

102
00:03:30,840 --> 00:03:32,260
0,350 350,620 620,845 845,1085 1085,1420
people said like, oh, the,
人们说，哦，这篇论文是如此深不可测，

103
00:03:33,400 --> 00:03:34,960
0,260 700,945 945,1050 1050,1275 1275,1560
the, you know, the paper

104
00:03:34,960 --> 00:03:36,265
0,195 195,345 345,930 930,1080 1080,1305
was so inscrutable,| nobody can
|没有人能理解它，

105
00:03:36,265 --> 00:03:38,095
0,270 270,575 1285,1545 1545,1695 1695,1830
understand it,| if you actually
|如果你真的读了，

106
00:03:38,095 --> 00:03:38,890
0,105 105,210 210,420 420,585 585,795
read it,| it's actually pretty
|它实际上是很容易理解的，

107
00:03:38,890 --> 00:03:40,600
0,350 490,1095 1095,1365 1365,1470 1470,1710
easily understandable,| it's just people
|我想，那时候人们只是不喜欢数学而已。

108
00:03:40,600 --> 00:03:41,605
0,300 300,420 420,660 660,885 885,1005
didn't like math back in

109
00:03:41,605 --> 00:03:43,285
0,90 90,195 195,300 300,545 1405,1680
the day, I guess.| So
|然后他，

110
00:03:43,285 --> 00:03:45,540
0,270 270,665
then he,|
|

111
00:03:45,610 --> 00:03:47,220
0,275 275,500 500,1055 1055,1445 1445,1610
some people {at,IBM} saws paper|
一些 IBM 的人看着论文，|

112
00:03:47,220 --> 00:03:48,170
0,210 210,390 390,510 510,660 660,950
and try to start building,
试图开始建立实验性的关系数据库，

113
00:03:48,730 --> 00:03:50,430
0,245 245,455 455,950 950,1145 1145,1700
you know, experimental relational databases|
|

114
00:03:50,430 --> 00:03:51,285
0,135 135,315 315,525 525,690 690,855
to see whether they can
看看他们是否真的能把他的数学思想付诸实践。

115
00:03:51,285 --> 00:03:53,280
0,195 195,465 465,845 1105,1770 1770,1995
actually take his mathematical ideas

116
00:03:53,280 --> 00:03:54,240
0,180 180,285 285,530 670,900 900,960
and put it, put it

117
00:03:54,240 --> 00:03:55,890
0,135 135,440 1000,1275 1275,1455 1455,1650
into practice.| And so the
|最早的关系数据库语言，

118
00:03:55,890 --> 00:03:58,110
0,255 255,620 1090,1575 1575,1905 1905,2220
very first relational database language,|
|

119
00:03:58,110 --> 00:03:59,180
0,210 210,315 315,510 510,765 765,1070
as far as I know
据我所知是这个称为 SQUARE 的东西，

120
00:04:00,550 --> 00:04:01,650
0,260 260,395 395,560 560,815 815,1100
was this thing called SQUARE,|
|

121
00:04:01,650 --> 00:04:04,070
0,165 165,615 615,960 960,1340 1360,2420
that IBM invented in 1971|
IBM 在 1971 年发明的，|

122
00:04:05,080 --> 00:04:06,200
0,260 260,380 380,545 545,785 785,1120
and this was for a
这是为了一个更早的项目，

123
00:04:06,280 --> 00:04:07,755
0,400 480,845 845,1055 1055,1295 1295,1475
earlier project,| that IBM was
|IBM 为最早的关系数据库系统之一开发的，

124
00:04:07,755 --> 00:04:09,465
0,305 535,935 1315,1560 1560,1620 1620,1710
developing for one of the

125
00:04:09,465 --> 00:04:10,890
0,180 180,465 465,735 735,1085 1105,1425
first relational database systems,| probably
|可能是第一个，

126
00:04:10,890 --> 00:04:13,125
0,225 225,450 450,770 1660,1965 1965,2235
the first one,| which sounds
|听起来像是一支奇怪的实验性摇滚乐队，

127
00:04:13,125 --> 00:04:13,950
0,225 225,360 360,480 480,585 585,825
it sounds like a weird

128
00:04:13,950 --> 00:04:15,735
0,495 495,720 720,1040 1330,1650 1650,1785
experimental rock band,| it's called
|它被称为 Peterlee Relational Test Vehicle ，

129
00:04:15,735 --> 00:04:17,100
0,165 165,405 405,690 690,1080 1080,1365
the {Peterlee -} Relational Test

130
00:04:17,100 --> 00:04:18,450
0,320 790,1020 1020,1110 1110,1215 1215,1350
Vehicle,| but that was the
|但这是他们建造的第一件作为早期原型的东西，

131
00:04:18,450 --> 00:04:19,575
0,180 180,345 345,510 510,765 765,1125
first thing they built as

132
00:04:19,575 --> 00:04:21,525
0,255 255,465 465,1200 1200,1595 1675,1950
an early prototype| to show
|表明你可以将 Ted Codd 的想法实际应用到真实系统中。

133
00:04:21,525 --> 00:04:22,320
0,105 105,195 195,360 360,585 585,795
that you could take ted

134
00:04:22,320 --> 00:04:23,370
0,345 345,555 555,750 750,915 915,1050
codd's ideas and actually put

135
00:04:23,370 --> 00:04:24,770
0,260 370,705 705,900 900,1080 1080,1400
it into a real system.|
|

136
00:04:25,400 --> 00:04:26,830
0,270 270,495 495,780 780,1080 1080,1430
The problem with SQUARE, though,
然而， SQUARE 的问题是，

137
00:04:26,850 --> 00:04:28,085
0,275 275,550 660,920 920,1025 1025,1235
is that,| you can never
|你永远不能真正重用它，

138
00:04:28,085 --> 00:04:29,705
0,365 445,870 870,1140 1140,1425 1425,1620
actually reuse it,| because you
|因为你必须垂直编写奇怪的符号，

139
00:04:29,705 --> 00:04:31,145
0,150 150,285 285,545 805,1155 1155,1440
had to write in weird

140
00:04:31,145 --> 00:04:34,595
0,545 955,1625 1855,2255 2995,3270 3270,3450
notation vertically,| which you can't
|而你实际上不能这样做，

141
00:04:34,595 --> 00:04:36,830
0,120 120,425 745,990 990,1235 1945,2235
really do,| so this is
|这是论文中的一篇，

142
00:04:36,830 --> 00:04:38,375
0,290 490,890 1060,1290 1290,1350 1350,1545
from the one of the

143
00:04:38,375 --> 00:04:39,970
0,365 655,990 990,1170 1170,1305 1305,1595
papers, right,| you would write,|
|你需要写，|

144
00:04:40,620 --> 00:04:41,400
0,225 225,345 345,465 465,570 570,780
this is how to do
这就是如何按部门在 sales 表上进行扫描，

145
00:04:41,400 --> 00:04:43,080
0,350 610,960 960,1290 1290,1530 1530,1680
a scan on on the

146
00:04:43,080 --> 00:04:44,505
0,225 225,465 465,705 705,1040 1150,1425
sales table by department,| like
|你会用这种奇怪的垂直方式编写，

147
00:04:44,505 --> 00:04:45,300
0,150 150,330 330,525 525,645 645,795
you would write in this

148
00:04:45,300 --> 00:04:46,875
0,315 315,705 705,1050 1050,1290 1290,1575
weird vertical way,| with characters
|使用即使在今天你也不会在键盘上使用的字符，

149
00:04:46,875 --> 00:04:47,640
0,255 255,360 360,510 510,630 630,765
that you wouldn't have on

150
00:04:47,640 --> 00:04:49,695
0,120 120,530 580,900 900,1220 1750,2055
a keyboard even today,| so
|所以实际上从来没有人这样做过。

151
00:04:49,695 --> 00:04:50,535
0,180 180,375 375,540 540,675 675,840
no one actually ever did

152
00:04:50,535 --> 00:04:51,460
0,275
this.|
|

153
00:04:51,500 --> 00:04:54,055
0,245 245,490 840,1540 2130,2405 2405,2555
So then IBM threw that
然后 IBM 抛弃了这个，

154
00:04:54,055 --> 00:04:55,105
0,210 210,405 405,555 555,750 750,1050
away| and they started building
|他们开始构建一种新的查询语言，名为 SEQUEL ，

155
00:04:55,105 --> 00:04:57,070
0,395 835,1140 1140,1395 1395,1680 1680,1965
a new query language called

156
00:04:57,070 --> 00:04:58,705
0,500 610,975 975,1170 1170,1410 1410,1635
SEQUEL,| spelled S E {Q,U}
|拼写为 S E Q U E L ，

157
00:04:58,705 --> 00:05:00,580
0,210 210,515 865,1265 1435,1725 1725,1875
E L,| {} for the
|对于 System R 项目，

158
00:05:00,580 --> 00:05:01,825
0,180 180,420 420,705 705,1035 1035,1245
System R project,| which is
|这是我们将在整个学期中讨论的。

159
00:05:01,825 --> 00:05:02,890
0,150 150,390 390,615 615,765 765,1065
a system we'll talk about

160
00:05:02,890 --> 00:05:04,165
0,270 270,405 405,710 880,1140 1140,1275
throughout the semester.| But this
|但这是 IBM 开始构建的第二个关系数据库系统，

161
00:05:04,165 --> 00:05:05,575
0,150 150,420 420,720 720,1005 1005,1410
was the the second relational

162
00:05:05,575 --> 00:05:06,805
0,255 255,510 510,720 720,1065 1065,1230
database system that IBM started

163
00:05:06,805 --> 00:05:07,690
0,255 255,480 480,615 615,735 735,885
building| to try to show
|试图证明 Ted Codd 的工作实际上是可以完成的。

164
00:05:07,690 --> 00:05:09,880
0,180 180,375 375,920 1690,1980 1980,2190
that Ted Codd's work could

165
00:05:09,880 --> 00:05:11,170
0,135 135,195 195,440 820,1095 1095,1290
actually be done.| The Peter
|Peter Lee 团队是在英国，

166
00:05:11,170 --> 00:05:11,950
0,210 210,390 390,555 555,675 675,780
Lee one that was in

167
00:05:11,950 --> 00:05:12,865
0,225 225,525 525,705 705,795 795,915
the UK,| that was a
|那是一个很小的团队，

168
00:05:12,865 --> 00:05:14,200
0,180 180,485 595,885 885,1095 1095,1335
small team,| the System R
|System R 项目在圣何塞的 IBM 研究中心，

169
00:05:14,200 --> 00:05:15,810
0,320 610,900 900,1125 1125,1335 1335,1610
project was in San Jose

170
00:05:16,700 --> 00:05:17,830
0,275 275,575 575,755 755,935 935,1130
at IBM research| and that
|这是一项非常重要的任务。

171
00:05:17,830 --> 00:05:18,685
0,195 195,270 270,390 390,615 615,855
that was a major, major

172
00:05:18,685 --> 00:05:19,720
0,515
undertaking.|
|

173
00:05:19,760 --> 00:05:21,760
0,400 660,920 920,1115 1115,1450 1530,2000
{} So they defined SQL
所以他们早在 1972 年就定义了 SQL ，

174
00:05:21,760 --> 00:05:24,505
0,225 225,420 420,1245 1245,1520 2440,2745
back in 1972,| {this,was} Don
|这是 Don Chamberlin 和 Boyce ，

175
00:05:24,505 --> 00:05:26,125
0,450 450,645 645,935 1255,1515 1515,1620
Chamberlin and Boyce,| they work
|他们使用这种查询语言，

176
00:05:26,125 --> 00:05:28,380
0,90 90,195 195,360 360,635 1855,2255
in this query language| and
|他们的想法是结构化英语查询语言，

177
00:05:28,400 --> 00:05:30,325
0,335 335,670 900,1205 1205,1640 1640,1925
the {idea,is} the Structured English

178
00:05:30,325 --> 00:05:31,680
0,255 255,575
Query Language,|
|

179
00:05:31,690 --> 00:05:33,195
0,400 510,770 770,860 860,1265 1265,1505
but in the {1980s -},|
但是在 1980 年代，|

180
00:05:33,195 --> 00:05:34,380
0,335 355,645 645,975 975,1065 1065,1185
when, when IBM put out
当 IBM 推出商业关系数据库系统时，

181
00:05:34,380 --> 00:05:36,045
0,290 430,810 810,1155 1155,1395 1395,1665
a commercial relational database system,|
|

182
00:05:36,045 --> 00:05:37,905
0,195 195,420 420,915 915,1265 1585,1860
they got sued for the
他们被起诉使用术语 SEQUEL ，比如名字 SEQUEL ，

183
00:05:37,905 --> 00:05:39,255
0,210 210,645 645,960 960,1185 1185,1350
term SEQUEL, like the name

184
00:05:39,255 --> 00:05:40,515
0,485 505,885 885,1095 1095,1170 1170,1260
SEQUEL,| because there was some
|因为有其他系统或其他软件在使用它，

185
00:05:40,515 --> 00:05:41,955
0,165 165,485 625,900 900,1140 1140,1440
other system or some other

186
00:05:41,955 --> 00:05:43,200
0,180 180,285 285,545 895,1140 1140,1245
piece of software that was

187
00:05:43,200 --> 00:05:44,250
0,165 165,470 550,795 795,915 915,1050
using it,| so then they
|所以他们就将其[恢复]为 SQL ，

188
00:05:44,250 --> 00:05:45,100
0,260
just

189
00:05:45,230 --> 00:05:48,370
0,485 485,590 590,755 755,1060 2430,3140
reverted it back to SQL,|

190
00:05:48,370 --> 00:05:50,170
0,225 225,375 375,650 1240,1515 1515,1800
just the letters, the Structured
只有字母，结构化查询语言。

191
00:05:50,170 --> 00:05:52,280
0,195 195,500
Query Language.|
|

192
00:05:52,530 --> 00:05:54,605
0,245 245,410 410,730 1530,1820 1820,2075
There was another very famous
同一时间还有另一个非常著名的项目，

193
00:05:54,605 --> 00:05:55,895
0,365 415,675 675,810 810,1005 1005,1290
project at the same time|
|

194
00:05:55,895 --> 00:05:57,335
0,285 285,845 925,1170 1170,1245 1245,1440
at Berkeley in the {1970s
在 1970 年代的伯克利，

195
00:05:57,335 --> 00:05:58,295
0,405 405,525 525,690 690,855 855,960
-},| when System R was
|当 System R 刚刚开始时，

196
00:05:58,295 --> 00:06:01,085
0,180 180,515 1285,1560 1560,2015 2515,2790
getting started,| called Ingres,| who
|这个项目叫做 Ingres ，|这里有人听说过 Ingres 吗？

197
00:06:01,085 --> 00:06:02,880
0,225 225,330 330,450 450,875
here heard of Ingres?|
|

198
00:06:03,720 --> 00:06:05,210
0,400 840,1115 1115,1325 1325,1430 1430,1490
Nobody, who here {hears -}
没人，有人听说过 Postgres ？

199
00:06:05,210 --> 00:06:06,940
0,90 90,590
of Postgres?|
|

200
00:06:07,080 --> 00:06:07,715
0,260 260,335 335,380 380,470 470,635
You want to know why
你想知道为什么 Postgres 被称为 Postgres ，

201
00:06:07,715 --> 00:06:09,020
0,345 345,465 465,615 615,1095 1095,1305
postgres is called Postgres,| because
|因为它是 Post-Ingres ，

202
00:06:09,020 --> 00:06:11,045
0,255 255,560 700,1310 1600,1845 1845,2025
it's {Post-Ingres -},| the guy
|Stonebraker 当他构建 Ingres 时，

203
00:06:11,045 --> 00:06:12,050
0,210 210,465 465,735 735,915 915,1005
that built, {Stonebraker -}, when

204
00:06:12,050 --> 00:06:14,285
0,105 105,285 285,800 1510,1800 1800,2235
he built Ingres,| he commercialized
|他在 1970 年代末将其商业化，

205
00:06:14,285 --> 00:06:15,605
0,285 285,570 570,825 825,1110 1110,1320
it in the the late

206
00:06:15,605 --> 00:06:16,625
0,435 435,615 615,735 735,840 840,1020
{1970s -}| and then went
|然后在 1980 年代回到伯克利，

207
00:06:16,625 --> 00:06:17,930
0,255 255,465 465,795 795,975 975,1305
back to Berkeley {1980s -},|
|

208
00:06:17,930 --> 00:06:18,820
0,105 105,225 225,375 375,570 570,890
they built a new system,|
他们建立了一个新的系统，|

209
00:06:19,200 --> 00:06:19,865
0,260 260,365 365,455 455,530 530,665
that was supposed to be
这个系统应该是 Post-Ingres ，

210
00:06:19,865 --> 00:06:21,560
0,240 240,755 1165,1515 1515,1575 1575,1695
{Post-Ingres -},| that's why it's
|这就是为什么它被称为 Postgres 。

211
00:06:21,560 --> 00:06:24,995
0,135 135,620 2020,2420 2440,3080 3160,3435
called Postgres.| The Postgres, sorry,
|Postgres ，抱歉， Ingres 有另一种查询语言，称为 QUEL ，

212
00:06:24,995 --> 00:06:26,495
0,485 595,870 870,1020 1020,1230 1230,1500
Ingres had this other query

213
00:06:26,495 --> 00:06:28,600
0,305 685,1020 1020,1385
language, called QUEL,|
|

214
00:06:28,600 --> 00:06:30,025
0,180 180,450 450,1050 1050,1305 1305,1425
and so SQL, the [plan]
所以 SQL 单词的[计划]是， SQL 到 QUEL ，

215
00:06:30,025 --> 00:06:30,625
0,75 75,150 150,300 300,465 465,600
of the words is that,

216
00:06:30,625 --> 00:06:32,250
0,375 375,645 645,1065 1065,1290 1290,1625
[] the SQL to QUEL,|
|

217
00:06:32,920 --> 00:06:34,015
0,225 225,405 405,585 585,900 900,1095
because they the IBM guys
因为 IBM 的人知道伯克利的人在做什么，

218
00:06:34,015 --> 00:06:34,825
0,180 180,315 315,450 450,540 540,810
knew what what the Berkeley

219
00:06:34,825 --> 00:06:35,605
0,120 120,255 255,465 465,675 675,780
people were doing| and they
|他们会试图构建一种更好的查询语言。

220
00:06:35,605 --> 00:06:36,250
0,90 90,195 195,300 300,450 450,645
would try to build a

221
00:06:36,250 --> 00:06:37,885
0,180 180,390 390,680 1180,1470 1470,1635
better query language.| {Stonebraker -}
|Stonebraker 会辩称 QUEL 更好，

222
00:06:37,885 --> 00:06:38,710
0,210 210,390 390,510 510,675 675,825
would argue that QUEL is

223
00:06:38,710 --> 00:06:40,930
0,290 1300,1545 1545,1620 1620,1850 1960,2220
better,| but of course no
|但当然今天没有人使用它。

224
00:06:40,930 --> 00:06:42,865
0,105 105,255 255,450 450,740 1390,1935
one uses that today.| IBM
|IBM 发布了几款，

225
00:06:42,865 --> 00:06:46,375
0,270 270,570 570,905 1075,1475 3265,3510
released a couple of,| in
|在 1970 年代， IBM 从 IMS 上赚了很多钱，

226
00:06:46,375 --> 00:06:47,575
0,75 75,270 270,675 675,1095 1095,1200
the {1970s -}, IBM was

227
00:06:47,575 --> 00:06:48,355
0,135 135,270 270,405 405,540 540,780
making a lot of money

228
00:06:48,355 --> 00:06:49,555
0,300 300,525 525,765 765,1020 1020,1200
off of {IMS -},| which
|这是一个非关系型系统，不支持 SQL ，

229
00:06:49,555 --> 00:06:51,000
0,105 105,365 475,765 765,1080 1080,1445
is a non relational system,

230
00:06:51,110 --> 00:06:52,615
0,350 350,515 515,970 1170,1415 1415,1505
didn't support SQL,| and then
|然后他们意识到 SQL 会有用武之地，

231
00:06:52,615 --> 00:06:54,310
0,210 210,525 525,875 1225,1590 1590,1695
they realized that SQL was

232
00:06:54,310 --> 00:06:55,090
0,90 90,165 165,285 285,495 495,780
going to go somewhere,| relational
|关系数据库也会有用武之地，

233
00:06:55,090 --> 00:06:55,660
0,180 180,330 330,405 405,465 465,570
database were going to go

234
00:06:55,660 --> 00:06:56,815
0,260 490,720 720,870 870,1050 1050,1155
somewhere,| so they released a
|所以，他们发布了更早的原型，比如 System/38 SQL/DS ，

235
00:06:56,815 --> 00:06:58,290
0,120 120,330 330,975 975,1170 1170,1475
much early prototypes, like {System/38

236
00:06:58,370 --> 00:07:00,940
0,610 840,1250 1250,1660 2190,2435 2435,2570
-} {SQL/DS -},| but the
|但真正成功的是 DB2 ，

237
00:07:00,940 --> 00:07:02,605
0,225 225,465 465,770 970,1365 1365,1665
big one that that really

238
00:07:02,605 --> 00:07:04,135
0,165 165,375 375,725 805,1245 1245,1530
took off was {DB2 -},|
|

239
00:07:04,135 --> 00:07:05,310
0,255 255,390 390,615 615,870 870,1175
which is still around today.|
它至今仍在使用。|

240
00:07:06,530 --> 00:07:08,155
0,380 380,1060 1080,1340 1340,1460 1460,1625
Again, IBM was a big
IBM 是计算机界的巨头，

241
00:07:08,155 --> 00:07:09,235
0,405 405,495 495,615 615,885 885,1080
juggernaut in the computing world,|
|

242
00:07:09,235 --> 00:07:11,065
0,210 210,360 360,810 810,1145 1585,1830
so whatever IBM said they
所以无论 IBM 说他们要做什么，

243
00:07:11,065 --> 00:07:11,740
0,90 90,165 165,255 255,420 420,675
were going to do,| that
|这都成了事实上的标准，

244
00:07:11,740 --> 00:07:12,565
0,180 180,330 330,555 555,705 705,825
sort of became the de

245
00:07:12,565 --> 00:07:14,275
0,360 360,665 1015,1245 1245,1320 1320,1710
facto standard,| so when IBM
|所以，当 IBM 推出支持 SQL 的关系数据库时，

246
00:07:14,275 --> 00:07:15,070
0,180 180,360 360,495 495,570 570,795
came out with a relational

247
00:07:15,070 --> 00:07:16,960
0,300 300,570 570,810 810,1340 1570,1890
database that supported SQL,| even
|尽管存在像 QUEL 这样的竞争语言，

248
00:07:16,960 --> 00:07:17,995
0,210 210,345 345,495 495,765 765,1035
though there were competing languages

249
00:07:17,995 --> 00:07:20,820
0,300 300,605 1165,1565 1975,2490 2490,2825
like QUEL,| everyone coalesced around
|但每个人都聚集在 SQL 周围。

250
00:07:21,800 --> 00:07:23,160
0,400 510,1030
around SQL.|
|

251
00:07:24,400 --> 00:07:25,815
0,400 420,815 815,965 965,1130 1130,1415
So, SQL became a standard
所以， SQL 成为了 ANSI 标准，

252
00:07:25,815 --> 00:07:27,045
0,375 375,600 600,900 900,1080 1080,1230
in, a ANSI standard,| it
|它是美国国家标准学会，

253
00:07:27,045 --> 00:07:28,260
0,210 210,525 525,810 810,1065 1065,1215
was American Standard Institute,| in
|在 1986 年，

254
00:07:28,260 --> 00:07:29,925
0,230 340,645 645,855 855,1160 1420,1665
{1986 - - -},| and
|并于 1987 年成为国际标准。

255
00:07:29,925 --> 00:07:31,485
0,195 195,525 525,870 870,1215 1215,1560
it became an international standard

256
00:07:31,485 --> 00:07:35,100
0,365 415,2535 2535,2825 2935,3300 3300,3615
in 1987.| {And,so} even though
|尽管它现在是一个有 50 60 年历史的语言，

257
00:07:35,100 --> 00:07:37,670
0,375 375,650 1390,2175 2175,2325 2325,2570
it's a {50,60} year old

258
00:07:37,750 --> 00:07:39,720
0,395 395,790 1200,1460 1460,1670 1670,1970
language now,| it has evolved
|但它已经随着时间的推移而演变和扩展。

259
00:07:39,720 --> 00:07:41,895
0,330 330,705 705,1035 1035,1370 1810,2175
and expanded over time.| So
|最新版本的 SQL 标准是在今年 3 月于 2023 年发布的，

260
00:07:41,895 --> 00:07:43,140
0,225 225,465 465,840 840,1110 1110,1245
the latest version of the

261
00:07:43,140 --> 00:07:44,130
0,240 240,480 480,720 720,855 855,990
SQL standard actually came out

262
00:07:44,130 --> 00:07:45,165
0,120 120,330 330,555 555,765 765,1035
in March this year in

263
00:07:45,165 --> 00:07:47,745
0,815 1855,2115 2115,2265 2265,2430 2430,2580
2023| and {} sees her
|看看她的列表，

264
00:07:47,745 --> 00:07:48,645
0,180 180,360 360,495 495,705 705,900
list here,| the history of
|所有更新的历史，

265
00:07:48,645 --> 00:07:49,995
0,150 150,375 375,695 895,1155 1155,1350
all the updates,| the various
|以及他们随着时间的推移添加的各种功能，

266
00:07:49,995 --> 00:07:51,320
0,285 285,600 600,765 765,1005 1005,1325
features they've added over time,|
|

267
00:07:51,840 --> 00:07:53,370
0,380 490,750 750,945 945,1365 1365,1530
and the main takeaway from
从这份清单中得到的主要结论是，

268
00:07:53,370 --> 00:07:54,480
0,255 255,495 495,645 645,990 990,1110
this, from this listing here

269
00:07:54,480 --> 00:07:57,620
0,135 135,410 1300,1700 2350,2745 2745,3140
is that,| as as programs
|随着程序的发展，应用程序的发展，

270
00:07:57,700 --> 00:07:59,355
0,400 510,905 905,1220 1220,1445 1445,1655
evolved, applications evolved,| or the
|或者软件开发中的趋势的发展，

271
00:07:59,355 --> 00:08:01,245
0,300 300,695 745,1095 1095,1445 1555,1890
trends in in development software

272
00:08:01,245 --> 00:08:03,015
0,240 240,435 435,725 1135,1545 1545,1770
development has evolved,| SQL has,
|SQL 已经一直在跟随它，

273
00:08:03,015 --> 00:08:04,935
0,365 985,1290 1290,1515 1515,1740 1740,1920
has, has moved along with

274
00:08:04,935 --> 00:08:06,360
0,270 270,570 570,825 825,1125 1125,1425
it| and adopted the ideas
|采用了这些想法，并采用了新的功能。

275
00:08:06,360 --> 00:08:07,910
0,270 270,590 640,1020 1020,1275 1275,1550
and adopted new new capabilities.|
|

276
00:08:08,770 --> 00:08:10,905
0,365 365,730 810,1115 1115,1880 1880,2135
So, in in 2023, the
所以，在 2023 年，已经推出的两大功能是

277
00:08:10,905 --> 00:08:11,790
0,225 225,420 420,630 630,795 795,885
big two features that have

278
00:08:11,790 --> 00:08:13,200
0,105 105,315 315,680 970,1260 1260,1410
come out is| now you
|现在你可以直接在 SQL 中进行属性图查询。

279
00:08:13,200 --> 00:08:14,840
0,135 135,410 520,870 870,1140 1140,1640
can do property graph queries

280
00:08:15,160 --> 00:08:16,580
0,350 350,590 590,1060
directly in SQL.|
|

281
00:08:16,590 --> 00:08:17,960
0,260 260,520 630,890 890,1070 1070,1370
So somebody brought up {Neo4j
所以上节课有人提到了 Neo4j ，

282
00:08:17,960 --> 00:08:19,595
0,135 135,315 315,525 525,830 1180,1635
- -} last class,| that's,
|那就是一个特殊用途的图形数据模型数据库系统，

283
00:08:19,595 --> 00:08:22,000
0,425 565,960 960,1290 1290,1625 2005,2405
that's a special purpose graph

284
00:08:22,200 --> 00:08:24,160
0,320 320,605 605,935 935,1300
data model database system,|
|

285
00:08:24,160 --> 00:08:24,805
0,105 105,240 240,375 375,525 525,645
but now you don't need
但是现在你不再需要它了，

286
00:08:24,805 --> 00:08:25,705
0,225 225,465 465,645 645,795 795,900
that anymore,| because now you
|因为你现在可以直接在 SQL 中运行图形查询，

287
00:08:25,705 --> 00:08:27,310
0,120 120,395 685,990 990,1350 1350,1605
can run graph queries directly

288
00:08:27,310 --> 00:08:28,675
0,270 270,735 735,990 990,1125 1125,1365
in SQL,| because the SQL
|因为 SQL 标准支持它。

289
00:08:28,675 --> 00:08:30,000
0,255 255,525 525,815
standard supports it.|
|

290
00:08:30,010 --> 00:08:31,365
0,305 305,515 515,785 785,1070 1070,1355
They also add support for
它们还添加了对多维数组的支持，

291
00:08:31,365 --> 00:08:33,390
0,270 270,720 720,1205 1705,1935 1935,2025
multi dimensional arrays,| so I
|我之前说过，

292
00:08:33,390 --> 00:08:34,305
0,135 135,405 405,705 705,840 840,915
said before,| that a lot
|很多机器学习的东西都是基于数组或矩阵的，

293
00:08:34,305 --> 00:08:35,510
0,165 165,345 345,525 525,825 825,1205
of machine learning stuff is

294
00:08:35,620 --> 00:08:36,980
0,305 305,500 500,785 785,875 875,1360
based on arrays or matrices,|
|

295
00:08:37,270 --> 00:08:38,445
0,245 245,350 350,515 515,820 840,1175
now you can operate directly
现在你可以直接在 SQL 上操作这些东西。

296
00:08:38,445 --> 00:08:40,260
0,225 225,635 655,930 930,1205 1555,1815
on SQL these things.| Now
|现在，仅仅因为标准有定义，

297
00:08:40,260 --> 00:08:41,595
0,260 340,630 630,810 810,1050 1050,1335
just because the standard has

298
00:08:41,595 --> 00:08:42,555
0,360 360,510 510,705 705,795 795,960
defines it,| doesn't mean every
|并不意味着每个系统都会支持它，

299
00:08:42,555 --> 00:08:43,350
0,195 195,345 345,450 450,600 600,795
system is going to support

300
00:08:43,350 --> 00:08:45,975
0,180 180,470 2080,2340 2340,2520 2520,2625
it, right,| I don't think
|我不认为任何系统真正支持多维数组的东西，

301
00:08:45,975 --> 00:08:47,420
0,195 195,480 480,810 810,1110 1110,1445
any system really supports the

302
00:08:47,920 --> 00:08:50,085
0,400 630,1115 1115,1280 1280,1570 1650,2165
multi dimensional array stuff,| Oracle
|Oracle 支持属性图之类的东西，

303
00:08:50,085 --> 00:08:51,015
0,180 180,300 300,465 465,690 690,930
supports the property graph stuff,|
|

304
00:08:51,015 --> 00:08:51,975
0,375 375,495 495,660 660,825 825,960
Postgres will eventually get there,|
Postgres 最终将到达那里，|

305
00:08:51,975 --> 00:08:53,130
0,180 180,285 285,405 405,1050 1050,1155
{DuckDB - -} eventually, {DuckDB
DuckDB 最终会到达， DuckdB 有一个原型。

306
00:08:53,130 --> 00:08:53,895
0,90 90,195 195,300 300,660 660,765
-} has a prototype for

307
00:08:53,895 --> 00:08:54,400
0,245
it.|
|

308
00:08:54,400 --> 00:08:55,705
0,320 610,885 885,1080 1080,1170 1170,1305
But because it's in the
但是因为它在标准中，

309
00:08:55,705 --> 00:08:57,055
0,275 565,900 900,1170 1170,1245 1245,1350
standard,| now everyone's going to
|现在每个数据库都将去支持它。

310
00:08:57,055 --> 00:08:57,790
0,210 210,375 375,450 450,585 585,735
actually be able to support

311
00:08:57,790 --> 00:08:58,540
0,260
it.|
|

312
00:08:59,000 --> 00:08:59,695
0,245 245,365 365,500 500,605 605,695
So I would say, in
所以，在我看来，

313
00:08:59,695 --> 00:09:02,365
0,180 180,515 955,1355 1375,1775 2365,2670
my opinion,| the minimum support
|要说你的数据库支持 SQL 的最小支持

314
00:09:02,365 --> 00:09:03,295
0,165 165,315 315,495 495,795 795,930
you need for SQL to

315
00:09:03,295 --> 00:09:04,315
0,165 165,300 300,405 405,665 715,1020
say that your database support

316
00:09:04,315 --> 00:09:06,025
0,485 625,990 990,1305 1305,1545 1545,1710
SQL| is defined in the
|是在 SQL-92 标准中定义的，

317
00:09:06,025 --> 00:09:08,310
0,285 285,690 690,995 1675,2040 2040,2285
{SQL-92 -} standard,| that's {like\,,SELECT}
|比如 SELECT INSERT UPDATE DELETE CREATE 表，

318
00:09:08,540 --> 00:09:10,140
0,485 485,695 695,1100 1100,1295 1295,1600
INSERT UPDATE DELETE CREATE tables,|
|

319
00:09:10,490 --> 00:09:12,360
0,335 335,545 545,710 710,1010 1010,1870
that's, that's the basic functionality.|
这是基本的功能。|

320
00:09:13,070 --> 00:09:14,110
0,260 260,395 395,545 545,725 725,1040
So again, even though sql
再说一次，尽管 SQL 已经有 50 多年的历史，

321
00:09:14,110 --> 00:09:15,145
0,180 180,405 405,600 600,765 765,1035
is over 50 years old,|
|

322
00:09:15,145 --> 00:09:16,110
0,345 345,480 480,585 585,690 690,965
it's not a dead language|
但它并不是一种过时的语言，|

323
00:09:16,190 --> 00:09:17,320
0,260 260,500 500,755 755,980 980,1130
and there's updates all the
而且一直在更新。

324
00:09:17,320 --> 00:09:18,220
0,260
time.|
|

325
00:09:18,220 --> 00:09:19,330
0,150 150,225 225,470 520,870 870,1110
And of course, every ten
当然，每隔十年，每隔五年，

326
00:09:19,330 --> 00:09:20,965
0,270 270,570 570,810 810,1130 1270,1635
years, every five years,| some
|就会有一些新技术问世，

327
00:09:20,965 --> 00:09:22,330
0,240 240,515 595,870 870,1110 1110,1365
new technology comes out| and
|人们说 SQL 已经死了，

328
00:09:22,330 --> 00:09:23,760
0,290 460,765 765,960 960,1200 1200,1430
people say that SQL is

329
00:09:23,840 --> 00:09:25,480
0,400 1050,1280 1280,1430 1430,1550 1550,1640
dead| and it's about to
|它即将被取代，

330
00:09:25,480 --> 00:09:27,685
0,120 120,410 1540,1800 1800,1980 1980,2205
be replaced,| 10 years ago,
|10 年前，它是 NoSQL ，

331
00:09:27,685 --> 00:09:28,990
0,135 135,225 225,405 405,815 1045,1305
it was {NoSQL -},| And
|现在最热门的是 ChatGPT 或矢量数据库，

332
00:09:28,990 --> 00:09:30,060
0,105 105,240 240,420 420,690 690,1070
the hot thing now is

333
00:09:30,560 --> 00:09:32,640
0,305 305,910 930,1250 1250,1490 1490,2080
{ChatGPT -} or vector databases,|
|

334
00:09:32,930 --> 00:09:33,595
0,260 260,395 395,500 500,575 575,665
so you see a lot
所以你在 Twitter 或社交媒体上看到很多这样的事情，

335
00:09:33,595 --> 00:09:34,300
0,90 90,240 240,405 405,525 525,705
of these kind of things

336
00:09:34,300 --> 00:09:36,595
0,320 340,705 705,1070 1870,2130 2130,2295
on Twitter or on social

337
00:09:36,595 --> 00:09:37,780
0,255 255,450 450,585 585,855 855,1185
media,| where they claim SQL
|他们声称 SQL 将会消亡，

338
00:09:37,780 --> 00:09:38,850
0,75 75,165 165,270 270,530 670,1070
is going to die,| because
|因为 ChatGPT 将取代它，

339
00:09:39,320 --> 00:09:40,240
0,290 290,635 635,725 725,800 800,920
{ChatGPT -} is going to

340
00:09:40,240 --> 00:09:41,110
0,210 210,375 375,555 555,735 735,870
replace it| or natural language
|或者自然语言将取代它，

341
00:09:41,110 --> 00:09:41,695
0,120 120,180 180,270 270,420 420,585
is going to replace it,

342
00:09:41,695 --> 00:09:42,580
0,275
right,|
|

343
00:09:42,710 --> 00:09:44,575
0,290 290,580 1290,1610 1610,1760 1760,1865
this is all a bunch
这都是一堆炒作，

344
00:09:44,575 --> 00:09:46,885
0,120 120,485 1105,1595 1615,2015 2065,2310
of hype,| it's interesting, but
|这很有趣，但它不会替代 SQL ，

345
00:09:46,885 --> 00:09:47,530
0,150 150,285 285,405 405,495 495,645
it's not going to replace

346
00:09:47,530 --> 00:09:49,120
0,440 760,1155 1155,1260 1260,1395 1395,1590
SQL,| SQL was here before
|在你出生之前， SQL 就在这里了，

347
00:09:49,120 --> 00:09:50,545
0,150 150,255 255,530 880,1290 1290,1425
you were born,| SQL be
|当你死的时候， SQL 仍在这里。

348
00:09:50,545 --> 00:09:54,390
0,180 180,330 330,420 420,665 3445,3845
here when you die.| And
|我已经就此发表了公开声明，

349
00:09:54,740 --> 00:09:56,755
0,470 470,695 695,980 980,1330 1620,2015
I've made public statements basically

350
00:09:56,755 --> 00:09:57,810
0,285 285,495 495,720 720,795 795,1055
about this,| there's an article
|他们去年在杂志上引用了我的一篇文章。

351
00:09:59,060 --> 00:10:00,685
0,260 260,470 470,635 635,880 1290,1625
they quoted me in last

352
00:10:00,685 --> 00:10:03,120
0,335 1405,1665 1665,2055 2055,2190 2190,2435
year, some magazines or something,|
|

353
00:10:03,170 --> 00:10:04,150
0,260 260,455 455,695 695,860 860,980
I basically said you need
我说，你需要指导 SQL ，

354
00:10:04,150 --> 00:10:04,960
0,105 105,240 240,570 570,705 705,810
to know SQL,| if you
|如果你想在计算机科学中做任何事情。

355
00:10:04,960 --> 00:10:05,785
0,90 90,150 150,300 300,540 540,825
want to do anything in

356
00:10:05,785 --> 00:10:07,080
0,300 300,540 540,845
in computer science.|
|

357
00:10:07,520 --> 00:10:08,780
0,245 245,490
All right,|
好的，|

358
00:10:09,440 --> 00:10:11,120
0,380 380,760
so the,
所以，在像 SQL 这样的关系语言中，

359
00:10:11,120 --> 00:10:12,140
0,105 105,225 225,495 495,780 780,1020
in a relational language like

360
00:10:12,140 --> 00:10:13,090
0,345 345,540 540,615 615,705 705,950
SQL,| it's going to have
|它将由三个部分组成，

361
00:10:13,740 --> 00:10:15,260
0,290 290,580 1050,1400 1400,1460 1460,1520
three parts,| there's going to
|将会有 DML ，数据操作语言，

362
00:10:15,260 --> 00:10:16,520
0,150 150,330 330,800 850,1110 1110,1260
be the DML, the data

363
00:10:16,520 --> 00:10:18,425
0,675 675,1010 1270,1605 1605,1725 1725,1905
manipulation language,| that's how we're
|这就是我们的 SELECT INSERT UPDATE DELETE 查询，

364
00:10:18,425 --> 00:10:20,495
0,150 150,485 1435,1710 1710,1845 1845,2070
going to, that's our SELECT

365
00:10:20,495 --> 00:10:21,710
0,360 360,570 570,750 750,1005 1005,1215
INSERT UPDATE DELETE queries,| that
|在我们的数据库中与之交互，

366
00:10:21,710 --> 00:10:22,900
0,240 240,525 525,780 780,915 915,1190
interact with in our database,|
|

367
00:10:23,430 --> 00:10:24,590
0,245 245,380 380,530 530,980 980,1160
would be the DDL, the
将会有 DDL ，数据定义语言，

368
00:10:24,590 --> 00:10:25,670
0,165 165,330 330,495 495,765 765,1080
data definition {} language,| that's
|即 CREATE TABLE 语句， CREATE VIEW 语句，

369
00:10:25,670 --> 00:10:26,780
0,135 135,315 315,570 570,885 885,1110
the CREATE TABLE statement, the

370
00:10:26,780 --> 00:10:28,205
0,180 180,500 820,1110 1110,1290 1290,1425
CREATE {VIEW,statement},| to create the
|用于创建我们数据库中的对象实体，

371
00:10:28,205 --> 00:10:30,020
0,405 405,540 540,785 805,1205
entities of the objects

372
00:10:30,360 --> 00:10:32,225
0,260 260,395 395,670 1440,1700 1700,1865
in our database| and then
|然后会有，我们不会真的讨论这一点，

373
00:10:32,225 --> 00:10:33,110
0,195 195,420 420,705 705,780 780,885
there be, we're not really

374
00:10:33,110 --> 00:10:33,815
0,75 75,135 135,300 300,540 540,705
going to cover this,| but
|但将会有 DCL ，数据控制语言，

375
00:10:33,815 --> 00:10:34,745
0,120 120,195 195,330 330,750 750,930
there'll be the DCL, the

376
00:10:34,745 --> 00:10:36,320
0,210 210,450 450,725 1045,1455 1455,1575
data control language,| that's for
|用于类似安全和访问控制，

377
00:10:36,320 --> 00:10:37,930
0,260 280,630 630,945 945,1260 1260,1610
like security and access control,|
|

378
00:10:38,340 --> 00:10:39,530
0,305 305,575 575,845 845,1010 1010,1190
some systems allow you have,|
有些系统允许你，|

379
00:10:39,530 --> 00:10:40,745
0,320 550,765 765,870 870,1005 1005,1215
like, you know, you can
你可以指定允许哪些用户可以查看

380
00:10:40,745 --> 00:10:41,990
0,420 420,600 600,870 870,1110 1110,1245
specify what users are allowed

381
00:10:41,990 --> 00:10:43,010
0,120 120,240 240,420 420,930 930,1020
to see| what rows or
|哪些行、哪些列或哪些表等，

382
00:10:43,010 --> 00:10:43,925
0,120 120,465 465,585 585,705 705,915
what columns or what tables

383
00:10:43,925 --> 00:10:45,110
0,210 210,360 360,635 835,1080 1080,1185
and so forth,| so the
|所以， SQL 标准为这些内容指定了（标准）。

384
00:10:45,110 --> 00:10:46,610
0,270 270,560 580,1050 1050,1290 1290,1500
SQL standard specifies for, for

385
00:10:46,610 --> 00:10:47,700
0,150 150,440
these things.|
|

386
00:10:48,250 --> 00:10:49,260
0,320 320,530 530,695 695,875 875,1010
Another big thing,| we'll see
另一个重要的东西，|我们将在本学期晚些时候看到的是事务的定义，

387
00:10:49,260 --> 00:10:50,690
0,150 150,255 255,345 345,650 1030,1430
later in the semester is

388
00:10:50,950 --> 00:10:53,460
0,230 230,455 455,740 740,1030 2250,2510
the definition of transactions,| how
|如何定义一组你希望以隔离方式原子发生的 SQL 语句，

389
00:10:53,460 --> 00:10:54,255
0,90 90,270 270,525 525,675 675,795
do you define a bunch

390
00:10:54,255 --> 00:10:55,335
0,135 135,390 390,665 745,990 990,1080
of SQL statements you want

391
00:10:55,335 --> 00:10:57,375
0,75 75,225 225,965 1705,1950 1950,2040
to happen atomically in an

392
00:10:57,375 --> 00:10:59,280
0,345 345,665 835,1235 1255,1650 1650,1905
isolated way,| and again, the
|同样， SQL 标准支持这一点。

393
00:10:59,280 --> 00:11:00,960
0,240 240,435 435,690 690,1010 1420,1680
SQL standard supports this.| So
|我们会在这学期看到这些零星的东西，

394
00:11:00,960 --> 00:11:01,950
0,195 195,510 510,705 705,870 870,990
again, we'll see bits and

395
00:11:01,950 --> 00:11:02,775
0,165 165,315 315,480 480,690 690,825
pieces of this as we

396
00:11:02,775 --> 00:11:03,930
0,90 90,255 255,420 420,725 805,1155
go throughout this semester,| but
|但在今天的课程中，

397
00:11:03,930 --> 00:11:05,580
0,240 240,645 645,920 1240,1530 1530,1650
for today's lecture,| we're really
|我们真正要关注的是第一个， DML 。

398
00:11:05,580 --> 00:11:06,465
0,120 120,210 210,390 390,660 660,885
going to focus on the

399
00:11:06,465 --> 00:11:08,080
0,165 165,420 420,660 660,1085
first one, the DML.|
|

400
00:11:08,350 --> 00:11:09,770
0,245 245,425 425,755 755,1085 1085,1420
And in reminder from, from
从我们上节课讲到的提醒一下，

401
00:11:09,970 --> 00:11:11,925
0,290 290,440 440,700 1050,1450 1710,1955
picking up where we we

402
00:11:11,925 --> 00:11:13,830
0,120 120,255 255,420 420,725 1525,1905
talked about last class,| SQL
|SQL 基于袋子的，

403
00:11:13,830 --> 00:11:14,160
0,75 75,135 135,165 165,210 210,330
is going to be based

404
00:11:14,160 --> 00:11:16,065
0,180 180,470 580,980 1450,1740 1740,1905
on bags,| meaning there could
|这意味着可能会有重复的，

405
00:11:16,065 --> 00:11:18,315
0,135 135,695 1045,1445 1705,2025 2025,2250
be duplicates,| {} whereas relational
|而关系代数是基于集合的，

406
00:11:18,315 --> 00:11:19,610
0,405 405,570 570,765 765,975 975,1295
algebra was based on sets|
|

407
00:11:20,080 --> 00:11:21,150
0,320 320,545 545,710 710,845 845,1070
and we see some cases|
我们看到了一些情况，|

408
00:11:21,150 --> 00:11:22,440
0,350 580,870 870,975 975,1110 1110,1290
where we'll have to add
我们必须在 SQL 语句中添加额外的东西来处理这个问题。

409
00:11:22,440 --> 00:11:23,415
0,270 270,495 495,615 615,720 720,975
extra stuff in our SQL

410
00:11:23,415 --> 00:11:26,370
0,270 270,665 2485,2730 2730,2835 2835,2955
statements to, to deal with

411
00:11:26,370 --> 00:11:27,100
0,260
that.|
|

412
00:11:28,480 --> 00:11:29,745
0,260 260,520 540,815 815,1055 1055,1265
So today, again, is supposed
所以，今天应该是一个关于现代 SQL 的速成课程，

413
00:11:29,745 --> 00:11:30,450
0,75 75,120 120,210 210,420 420,705
to be a crash course

414
00:11:30,450 --> 00:11:31,905
0,345 345,705 705,1035 1035,1200 1200,1455
on modern SQL,| I'm assuming
|我假设每个人，无论你是否知道，

415
00:11:31,905 --> 00:11:33,660
0,395 1075,1335 1335,1440 1440,1590 1590,1755
everyone, whether or not you

416
00:11:33,660 --> 00:11:34,680
0,120 120,195 195,270 270,530 730,1020
know it or not,| you
|你已经足够了解 SQL-92 标准，

417
00:11:34,680 --> 00:11:35,730
0,210 210,465 465,675 675,810 810,1050
know enough from the {SQL-92

418
00:11:35,730 --> 00:11:38,820
0,435 435,740 1360,1650 1650,2480 2830,3090
-} standard,| SELECT {INSERT,UPDATE,DELETE}| and
|SELECT INSERT UPDATE DELETE,|我想谈谈，

419
00:11:38,820 --> 00:11:39,590
0,105 105,180 180,270 270,450 450,770
I want to talk about

420
00:11:39,640 --> 00:11:40,900
0,400
the,|
|

421
00:11:40,900 --> 00:11:41,680
0,165 165,240 240,330 330,510 510,780
I want to talk about
我想谈谈你可以用它们做的更复杂的事情，

422
00:11:41,680 --> 00:11:43,840
0,350 430,830 1240,1830 1830,2010 2010,2160
the more sophisticated things you

423
00:11:43,840 --> 00:11:45,360
0,120 120,225 225,330 330,590 1120,1520
can do with them,| but,
|但是最重要的主题将是，

424
00:11:45,850 --> 00:11:47,595
0,260 260,395 395,1250 1250,1535 1535,1745
but the overarching theme also

425
00:11:47,595 --> 00:11:48,510
0,120 120,300 300,480 480,705 705,915
will be is that,| we
|我们将会打开终端，

426
00:11:48,510 --> 00:11:49,520
0,165 165,300 300,375 375,495 495,1010
will open up the terminal,|
|

427
00:11:49,630 --> 00:11:50,445
0,350 350,470 470,575 575,695 695,815
we'll try a bunch of
我们将在不同的数据库系统中尝试一系列这样的查询，

428
00:11:50,445 --> 00:11:51,465
0,135 135,480 480,600 600,750 750,1020
these queries in different database

429
00:11:51,465 --> 00:11:53,055
0,365 805,1095 1095,1230 1230,1380 1380,1590
systems,| and we will see
|我们将看到，

430
00:11:53,055 --> 00:11:54,165
0,210 210,465 465,735 735,930 930,1110
that,| even though there is
|即使有一个 SQL 标准，

431
00:11:54,165 --> 00:11:55,725
0,210 210,540 540,845 1075,1335 1335,1560
a SQL standard,| there is
|也有一个国际公认的文档，

432
00:11:55,725 --> 00:11:58,080
0,365 775,1200 1200,1475 1915,2205 2205,2355
an internationally recognized document,| that
|说明了 SQL 应该是什么样子的，

433
00:11:58,080 --> 00:11:59,085
0,165 165,405 405,555 555,870 870,1005
says here's what sql should

434
00:11:59,085 --> 00:12:00,100
0,135 135,425
look like,|
|

435
00:12:00,440 --> 00:12:02,005
0,350 350,755 755,1010 1010,1340 1340,1565
nobody implements it exactly that
没有人会完全以这种方式实现它，

436
00:12:02,005 --> 00:12:03,000
0,275
way,

437
00:12:03,000 --> 00:12:04,050
0,350 520,870 870,930 930,975 975,1050
right,| everyone's going to have
|每个人都会有这些奇怪的细微差别和怪癖，

438
00:12:04,050 --> 00:12:05,430
0,150 150,375 375,855 855,1005 1005,1380
these weird nuances and quirks,|
|

439
00:12:05,430 --> 00:12:06,360
0,135 135,225 225,390 390,630 630,930
where they have different features
他们有不同的功能或不同的命名或语法来做某些事情，

440
00:12:06,360 --> 00:12:08,625
0,240 240,500 1090,1740 1740,1860 1860,2265
or different nomenclature or syntax

441
00:12:08,625 --> 00:12:10,965
0,150 150,285 285,495 495,815 2095,2340
to do certain things,| in
|在某些情况下，不同操作的不同语义，

442
00:12:10,965 --> 00:12:12,830
0,120 120,315 315,570 570,1295 1465,1865
some cases, different semantics of

443
00:12:13,180 --> 00:12:14,800
0,380 380,760
different operations,|
|

444
00:12:14,800 --> 00:12:16,060
0,350 490,795 795,960 960,1170 1170,1260
where even though there's a
即使有一个 SQL 标准，

445
00:12:16,060 --> 00:12:16,855
0,225 225,450 450,690 690,750 750,795
SQL standard,| it's going to
|但每个系统都会有所不同。

446
00:12:16,855 --> 00:12:17,770
0,90 90,315 315,540 540,705 705,915
be different from one system

447
00:12:17,770 --> 00:12:18,880
0,150 150,225 225,470
to the next.|
|

448
00:12:19,650 --> 00:12:20,615
0,260 260,520 540,785 785,860 860,965
Who did, take a guess
猜猜是谁，

449
00:12:20,615 --> 00:12:21,785
0,275 295,695 715,945 945,1050 1050,1170
who,| who do I think
|我认为谁是最糟糕的 SQL 实现的最大罪魁祸首，

450
00:12:21,785 --> 00:12:22,805
0,90 90,195 195,375 375,870 870,1020
is the biggest offender for

451
00:12:22,805 --> 00:12:24,350
0,90 90,335 445,900 900,1290 1290,1545
the worst SQL implementationation,| worse
|更糟糕的不是正确的词，

452
00:12:24,350 --> 00:12:25,010
0,150 150,270 270,375 375,495 495,660
is not the right word,|
|

453
00:12:25,010 --> 00:12:26,405
0,150 150,410 790,1050 1050,1200 1200,1395
but like the one that
而是像最偏离标准的那个，

454
00:12:26,405 --> 00:12:27,410
0,375 375,510 510,630 630,825 825,1005
deviates from the standard the

455
00:12:27,410 --> 00:12:28,360
0,260
most,|
|

456
00:12:28,740 --> 00:12:29,500
0,245 245,335 335,425 425,515 515,760
let me take a guess.|
让我猜猜。|

457
00:12:31,850 --> 00:12:32,920
0,275 275,500 500,755 755,890 890,1070
The top four out of.|
前四名是。|

458
00:12:32,920 --> 00:12:33,690
0,210 210,300 300,360 360,480 480,770
Yes, in the back, yes.|
好的，后面的，好的。|

459
00:12:34,550 --> 00:12:35,515
0,395 395,635 635,740 740,845 845,965
MySQL, he got it right,|
MySQL ，他是对的，|

460
00:12:35,515 --> 00:12:36,895
0,255 255,795 795,960 960,1110 1110,1380
yes, MySQL is gonna be
是的， MySQL 将会是所有这些中[]，

461
00:12:36,895 --> 00:12:39,160
0,395 1015,1245 1245,1395 1395,1715 1945,2265
the of all these,| where
|他们会做各种奇怪的事情，

462
00:12:39,160 --> 00:12:39,865
0,210 210,270 270,360 360,540 540,705
they're gonna do all sorts

463
00:12:39,865 --> 00:12:42,790
0,105 105,365 1555,1875 1875,2195 2635,2925
of weird,| more recently, they
|最近，他们有了一个标志，

464
00:12:42,790 --> 00:12:43,720
0,180 180,330 330,495 495,750 750,930
now have a flag,| where
|可以让它更严格，

465
00:12:43,720 --> 00:12:44,290
0,75 75,195 195,330 330,450 450,570
you can make it be

466
00:12:44,290 --> 00:12:45,520
0,165 165,470 640,960 960,1140 1140,1230
more strict| and try to
|并试图更接近 SQL 标准，

467
00:12:45,520 --> 00:12:47,440
0,135 135,440 970,1320 1320,1665 1665,1920
be more closer to the

468
00:12:47,440 --> 00:12:48,595
0,225 225,500 700,960 960,1065 1065,1155
SQL standard,| but for the
|但在很长一段时间里，他们做了一系列奇怪的事情。

469
00:12:48,595 --> 00:12:49,405
0,210 210,480 480,645 645,735 735,810
longest time, they do a

470
00:12:49,405 --> 00:12:50,410
0,90 90,195 195,345 345,635 745,1005
bunch of weird things.| And
|我的问题是，

471
00:12:50,410 --> 00:12:51,910
0,195 195,465 465,690 690,980 1150,1500
my problem is that,| I
|我第一次开始使用关系数据库是在，

472
00:12:51,910 --> 00:12:53,410
0,210 210,345 345,540 540,1190 1210,1500
first started using databases, relation

473
00:12:53,410 --> 00:12:54,850
0,405 405,585 585,860 1090,1335 1335,1440
databases in like,| when I
|90 年代，我上高中的时候，

474
00:12:54,850 --> 00:12:55,495
0,90 90,180 180,360 360,540 540,645
was in high school in

475
00:12:55,495 --> 00:12:56,365
0,90 90,480 480,705 705,795 795,870
the 90s| and we were
|我们使用的是 MySQL 3 ，

476
00:12:56,365 --> 00:12:57,925
0,150 150,345 345,630 630,935 1315,1560
using {MySQL -} 3,| so
|所以我有所有的坏习惯，

477
00:12:57,925 --> 00:12:58,735
0,105 105,225 225,390 390,585 585,810
I have all these bad

478
00:12:58,735 --> 00:13:00,175
0,335 505,810 810,1050 1050,1275 1275,1440
habits,| that like I picked
|我从 MySQL 中学到的，

479
00:13:00,175 --> 00:13:00,940
0,165 165,300 300,450 450,705 705,765
up from {MySQL -}| and
|我想，哦，是的，这就是 SQL ，

480
00:13:00,940 --> 00:13:01,525
0,120 120,195 195,330 330,480 480,585
I'm like oh yeah, this

481
00:13:01,525 --> 00:13:02,530
0,90 90,225 225,480 480,725 745,1005
is what SQL is,| then
|然后你意识到，

482
00:13:02,530 --> 00:13:03,805
0,180 180,405 405,555 555,800 970,1275
you realize,| when you start
|当你开始使用其他系统时，

483
00:13:03,805 --> 00:13:05,065
0,180 180,345 345,570 570,905 985,1260
playing other systems,| like this
|这太疯狂了，他们在做一些奇怪的事情，

484
00:13:05,065 --> 00:13:06,190
0,275 295,630 630,855 855,975 975,1125
is crazy, they're doing some

485
00:13:06,190 --> 00:13:07,760
0,180 180,500
weird stuff,|
|

486
00:13:07,760 --> 00:13:09,125
0,255 255,570 570,720 720,1040 1090,1365
but it's gotten better,| {MySQL
但一切都变好了，|MySQL 8 确实改进了很多。

487
00:13:09,125 --> 00:13:10,700
0,240 240,485 505,840 840,1175 1195,1575
-} 8 has has certainly

488
00:13:10,700 --> 00:13:12,200
0,380 400,660 660,920 1090,1350 1350,1500
improved a lot.| All right,
|好的，我们来看一下所有这些 Aggregations, Group by ，

489
00:13:12,200 --> 00:13:13,415
0,120 120,225 225,440 850,1095 1095,1215
so we'll go through all

490
00:13:13,415 --> 00:13:15,010
0,105 105,300 300,840 840,1065 1065,1595
of these aggregations, group bys,|
|

491
00:13:15,420 --> 00:13:16,600
0,365 365,635 635,800 800,920 920,1180
the string date and time
字符串、日期和时间操作，

492
00:13:16,620 --> 00:13:17,510
0,335 335,605 605,680 680,725 725,890
operations,| that's going to be
|这将是我们看到所有问题的地方，

493
00:13:17,510 --> 00:13:18,125
0,210 210,345 345,450 450,525 525,615
the one where we see

494
00:13:18,125 --> 00:13:19,325
0,105 105,225 225,485 775,1050 1050,1200
all the problems| and then
|然后是一系列其他与 SQL 查询交互的不同方式。

495
00:13:19,325 --> 00:13:19,985
0,120 120,225 225,330 330,465 465,660
a bunch of other different

496
00:13:19,985 --> 00:13:21,830
0,270 270,635 865,1265 1435,1710 1710,1845
ways to to interact with

497
00:13:21,830 --> 00:13:24,155
0,255 255,650 910,1310 1630,2025 2025,2325
SQL queries.| And another theme
|我们将要讨论的另一个主题是，

498
00:13:24,155 --> 00:13:24,965
0,195 195,345 345,495 495,630 630,810
about what we'll talk about

499
00:13:24,965 --> 00:13:26,735
0,275 685,975 975,1265 1315,1575 1575,1770
is| the goal of writing
|编写 SQL 语句的目标常常是

500
00:13:26,735 --> 00:13:28,160
0,300 300,575 685,1020 1020,1215 1215,1425
SQL statement oftentimes is

501
00:13:28,160 --> 00:13:29,390
0,350 550,795 795,885 885,1005 1005,1230
to| try to do all
|尝试在数据库服务器本身上完成所有的计算，

502
00:13:29,390 --> 00:13:30,860
0,225 225,830
the computation

503
00:13:30,860 --> 00:13:32,105
0,330 330,585 585,750 750,945 945,1245
on the the database server

504
00:13:32,105 --> 00:13:33,875
0,360 360,735 735,1115 1435,1665 1665,1770
itself,| within one sort of
|在一种主要的 SQL 查询中。

505
00:13:33,875 --> 00:13:35,825
0,195 195,720 720,945 945,1235 1645,1950
one overarching SQL query,| meaning
|这意味着我们不必执行 SELECT 操作，

506
00:13:35,825 --> 00:13:36,485
0,195 195,435 435,510 510,570 570,660
we don't want to have

507
00:13:36,485 --> 00:13:37,565
0,210 210,375 375,555 555,855 855,1080
to do a SELECT,| get
|将一些数据返回到一个 Python 程序或其他程序中，

508
00:13:37,565 --> 00:13:38,930
0,150 150,345 345,665 685,1085 1105,1365
some data back into a

509
00:13:38,930 --> 00:13:40,070
0,300 300,480 480,630 630,840 840,1140
Python program or something,| then
|然后对其进行操作，

510
00:13:40,070 --> 00:13:41,405
0,345 345,740 880,1140 1140,1245 1245,1335
then then operate on it|
|

511
00:13:41,405 --> 00:13:41,975
0,90 90,195 195,315 315,435 435,570
and then push it back
然后将其推回并执行更多查询，

512
00:13:41,975 --> 00:13:42,995
0,120 120,225 225,345 345,725 775,1020
and do more queries,| we
|我们希望尽可能做任何事，

513
00:13:42,995 --> 00:13:43,520
0,90 90,195 195,270 270,315 315,525
want to try to do

514
00:13:43,520 --> 00:13:45,250
0,225 225,345 345,620 910,1310 1330,1730
everything we can| on the
|在服务器端，在数据库系统之中，

515
00:13:45,720 --> 00:13:46,835
0,320 320,500 500,635 635,845 845,1115
on, on the server side,

516
00:13:46,835 --> 00:13:48,440
0,180 180,270 270,480 480,845 1345,1605
inside the database system,| because
|因为我们希望能够将查询推送到数据，

517
00:13:48,440 --> 00:13:48,860
0,120 120,210 210,285 285,345 345,420
we want to be able

518
00:13:48,860 --> 00:13:49,925
0,150 150,375 375,585 585,855 855,1065
to push the query to

519
00:13:49,925 --> 00:13:51,155
0,105 105,345 345,660 660,930 930,1230
the data,| not pull the,
|而不是拉取数据到查询。

520
00:13:51,155 --> 00:13:52,325
0,365 445,705 705,900 900,1080 1080,1170
the, the data to the

521
00:13:52,325 --> 00:13:53,180
0,275
query.|
|

522
00:13:53,890 --> 00:13:55,155
0,400 570,845 845,995 995,1130 1130,1265
Again, this make more sense
随着我们的前进，这更有意义。

523
00:13:55,155 --> 00:13:56,400
0,150 150,255 255,375 375,665
as we go along.|
|

524
00:13:57,170 --> 00:13:58,345
0,245 245,440 440,740 740,980 980,1175
All right, so for today
好的，今天我们将使用一个简单的示例数据库，

525
00:13:58,345 --> 00:13:59,770
0,195 195,345 345,555 555,845 1135,1425
we're using a simple example

526
00:13:59,770 --> 00:14:01,570
0,225 225,435 435,710 1060,1460 1510,1800
database like this,| {} has
|有三张表， student enrolled 和 course ，

527
00:14:01,570 --> 00:14:03,400
0,195 195,500 670,1050 1050,1590 1590,1830
three tables, student, enrolled and

528
00:14:03,400 --> 00:14:06,010
0,380 760,1080 1080,1730 2050,2415 2415,2610
course, right,| it's basically trying
|它基本上是在模仿一所大学，

529
00:14:06,010 --> 00:14:07,090
0,90 90,285 285,435 435,740 760,1080
to mimic a university,| there's
|有学生，他们参加课程，他们被录取，

530
00:14:07,090 --> 00:14:09,745
0,180 180,360 360,510 510,800 2320,2655
students, they take classes and

531
00:14:09,745 --> 00:14:10,660
0,240 240,585 585,690 690,780 780,915
they're enrolled| and they get
|他们在那里的各种课程中获得分数。

532
00:14:10,660 --> 00:14:11,730
0,270 270,480 480,585 585,750 750,1070
grades in the various courses

533
00:14:11,780 --> 00:14:12,880
0,245 245,350 350,610
that are there.|
|

534
00:14:12,950 --> 00:14:13,885
0,335 335,515 515,650 650,770 770,935
Okay, so we'll use this
好的，我们将使用它作为示例数据库。

535
00:14:13,885 --> 00:14:16,270
0,275 1315,1650 1650,1920 1920,2190 2190,2385
as the sample database as

536
00:14:16,270 --> 00:14:17,340
0,105 105,225 225,500
we go along.|
|

537
00:14:18,230 --> 00:14:18,955
0,245 245,380 380,545 545,650 650,725
All right, first thing is
好的，第一件事是聚合，

538
00:14:18,955 --> 00:14:21,390
0,485 1165,1410 1410,1655 1705,2175 2175,2435
aggregations,| so {aggregate -} functions
|聚合函数是一种方式，

539
00:14:21,440 --> 00:14:24,310
0,400 840,1240 2100,2390 2390,2645 2645,2870
are a, a way| to
|对一个数据序列或一个 tuple 袋子进行数学计算，

540
00:14:24,310 --> 00:14:27,690
0,470 520,920 1480,2300 2500,3030 3030,3380
compute some mathematical computation on

541
00:14:28,880 --> 00:14:30,385
0,380 380,760 780,1100 1100,1265 1265,1505
a a sequence of data

542
00:14:30,385 --> 00:14:31,530
0,315 315,480 480,615 615,765 765,1145
or a bag of tuples|
|

543
00:14:31,850 --> 00:14:32,935
0,320 320,545 545,725 725,950 950,1085
and you're basically going to
你是要把它合并成一个单一值。

544
00:14:32,935 --> 00:14:33,790
0,120 120,270 270,555 555,690 690,855
going to coalesce it down

545
00:14:33,790 --> 00:14:35,500
0,255 255,510 510,720 720,1040
into a single value.|
|

546
00:14:35,500 --> 00:14:36,805
0,270 270,465 465,740 820,1140 1140,1305
So the classic things would
所以经典的东西是 AVG MIN MAX SUM COUNT ，

547
00:14:36,805 --> 00:14:39,445
0,165 165,485 715,1115 1945,2340 2340,2640
be AVG, MIN, AVG, MIN,

548
00:14:39,445 --> 00:14:41,845
0,305 805,1140 1140,1475 1945,2280 2280,2400
MAX, SUM, COUNT,| you're trying
|你尝试计算一个列的最小值，

549
00:14:41,845 --> 00:14:43,920
0,120 120,545 865,1265 1315,1695 1695,2075
to compute the min value

550
00:14:44,420 --> 00:14:46,825
0,400 630,905 905,1180 1650,2045 2045,2405
of a column| across all
|在一个关系中所有 tuple 中。

551
00:14:46,825 --> 00:14:48,720
0,515 535,935 1105,1410 1410,1605 1605,1895
tuples, within within a relation.|
|

552
00:14:50,420 --> 00:14:51,400
0,245 245,395 395,605 605,815 815,980
So an simple example like
举个简单的例子，

553
00:14:51,400 --> 00:14:52,135
0,225 225,450 450,555 555,645 645,735
this,| say we want to
|比如我们想要，

554
00:14:52,135 --> 00:14:53,605
0,245 655,900 900,1020 1020,1260 1260,1470
get,| for the students, we
|对于学生，我们要计算学生的数量，

555
00:14:53,605 --> 00:14:55,405
0,90 90,210 210,450 450,815 1525,1800
want to count the number

556
00:14:55,405 --> 00:14:56,200
0,150 150,360 360,555 555,675 675,795
of students,| so have a
|如果 login 以 @cs 结尾，

557
00:14:56,200 --> 00:15:00,145
0,500 970,1370 1390,1790 2410,3050 3640,3945
login, where the login ends

558
00:15:00,145 --> 00:15:01,315
0,180 180,390 390,815 895,1110 1110,1170
with {@cs -},| do you
|是否有 @cs 电子邮件地址。

559
00:15:01,315 --> 00:15:03,010
0,75 75,165 165,390 390,845 1375,1695
have an {@cs -} email

560
00:15:03,010 --> 00:15:03,900
0,320
address.|
|

561
00:15:03,900 --> 00:15:05,040
0,180 180,390 390,705 705,990 990,1140
And so we just put
所以我们把 COUNT 函数放在这里，

562
00:15:05,040 --> 00:15:06,680
0,120 120,300 300,570 570,920 1240,1640
the count function here, {}|
|

563
00:15:07,210 --> 00:15:08,115
0,245 245,455 455,695 695,785 785,905
and then inside of it,
然后放在它里面，实际上对 COUNT 没有影响，

564
00:15:08,115 --> 00:15:09,345
0,150 150,375 375,645 645,960 960,1230
actually doesn't matter for COUNT,|
|

565
00:15:09,345 --> 00:15:11,300
0,240 240,840 840,1080 1080,1320 1320,1955
but we're account that logins|
但我们计算 logins ，|

566
00:15:11,500 --> 00:15:11,890
0,245 245,335 335,410 410,485 485,590
and then we have our
然后我们有 where 子句，

567
00:15:11,990 --> 00:15:14,840
0,180 180,435 435,980 2290,2595 2595,2850
where clause| specifying what tuple
|指定哪个 tuple 应该符合条件。

568
00:15:14,940 --> 00:15:16,080
0,135 135,650
should qualify.|
|

569
00:15:16,840 --> 00:15:18,060
0,400 450,710 710,830 830,995 995,1220
So again, in my example
再说一次，在我的示例中，我放入了 login ，

570
00:15:18,060 --> 00:15:19,160
0,225 225,420 420,570 570,795 795,1100
here, I'm putting {login -},|
|

571
00:15:19,270 --> 00:15:19,980
0,230 230,410 410,515 515,605 605,710
you don't actually have to
你实际上不必这样做，

572
00:15:19,980 --> 00:15:21,290
0,135 135,410 550,810 810,990 990,1310
do that,| you could put
|你可以放入一个星号，那是等同的，

573
00:15:21,400 --> 00:15:23,955
0,305 305,610 1080,1505 1505,1780 2250,2555
a star, that's equivalent,| because
|因为，它只是计算条目的数量。

574
00:15:23,955 --> 00:15:24,870
0,165 165,315 315,465 465,825 825,915
again, it's just counting the

575
00:15:24,870 --> 00:15:26,840
0,195 195,560 700,1280
number of entries.|
|

576
00:15:26,840 --> 00:15:27,670
0,120 120,240 240,375 375,525 525,830
You can actually put 1,|
你也可以放入 1 ，|

577
00:15:28,290 --> 00:15:30,230
0,400 420,710 710,1000 1440,1700 1700,1940
again, also equivalent, it doesn't
也是等同的，没有关系。

578
00:15:30,230 --> 00:15:31,300
0,260
matter.|
|

579
00:15:31,490 --> 00:15:32,230
0,260 260,350 350,425 425,545 545,740
Inside, you can really put
在里面，你可以放任何东西，

580
00:15:32,230 --> 00:15:33,400
0,320 640,870 870,930 930,1020 1020,1170
anything,| you can put {1+1+1
|你可以放入 1+1+1 。

581
00:15:33,400 --> 00:15:34,800
0,180 180,360 360,525 525,800
- - - -}.|
|

582
00:15:35,000 --> 00:15:36,475
0,350 350,700 720,1085 1085,1310 1310,1475
And the {database,system} should be
数据库系统应该足够智能，能够意识到这一点，

583
00:15:36,475 --> 00:15:37,380
0,165 165,285 285,450 450,630 630,905
smart enough to realize that,|
|

584
00:15:37,670 --> 00:15:39,180
0,260 260,520 630,965 965,1205 1205,1510
in this last example here,|
在这里的最后一个例子中，|

585
00:15:39,820 --> 00:15:41,275
0,195 195,495 495,750 750,1040 1150,1455
I don't care what the
我不关心 COUNT 内部的表达式是什么，

586
00:15:41,275 --> 00:15:42,100
0,225 225,450 450,615 615,720 720,825
expression is inside of the

587
00:15:42,100 --> 00:15:43,315
0,260 490,750 750,870 870,1080 1080,1215
COUNT,| and I won't actually
|我也不会真正做那个数学运算，

588
00:15:43,315 --> 00:15:44,545
0,105 105,255 255,545 895,1140 1140,1230
do that math,| because I
|因为我只关心我得到的 tuple 的数。

589
00:15:44,545 --> 00:15:46,240
0,135 135,315 315,605 715,1545 1545,1695
just care about what's the

590
00:15:46,240 --> 00:15:47,860
0,615 615,735 735,825 825,1070
{count,tuples} that I have.|
|

591
00:15:49,310 --> 00:15:50,515
0,245 245,320 320,425 425,620 620,1205
You can have multiple aggregates
你可以在一个 SELECT 输出中可以有多个聚合，

592
00:15:50,515 --> 00:15:51,780
0,225 225,360 360,570 570,885 885,1265
in a single SELECT output,|
|

593
00:15:51,980 --> 00:15:52,690
0,260 260,410 410,545 545,665 665,710
so here now we're going
所以现在我们要计算平均绩点和学生人数，

594
00:15:52,690 --> 00:15:54,690
0,60 60,375 375,710 1030,1395 1395,2000
to compute the average gpa

595
00:15:54,860 --> 00:15:57,355
0,400 450,850 2010,2360 2360,2420 2420,2495
and the counting of the

596
00:15:57,355 --> 00:15:58,890
0,105 105,225 225,485 895,1215 1215,1535
number of students,| again, with
|同样，使用 @cs 匹配 login 。

597
00:15:59,600 --> 00:16:00,960
0,290 290,485 485,650 650,890 890,1360
that, have the {@cs -}

598
00:16:01,850 --> 00:16:03,060
0,610
login.|
|

599
00:16:03,060 --> 00:16:04,725
0,150 150,285 285,560 1210,1500 1500,1665
And you get back a
然后，你将在输出结果中得到单个条目或单个记录，

600
00:16:04,725 --> 00:16:05,960
0,275 295,540 540,675 675,900 900,1235
single entry or single record

601
00:16:06,370 --> 00:16:09,150
0,335 335,605 605,940 1320,1720 2520,2780
in the output result| for
|对于这两次计算。

602
00:16:09,150 --> 00:16:10,620
0,120 120,255 255,770
the two computations.|
|

603
00:16:13,050 --> 00:16:14,170
0,275 275,410 410,590 590,815 815,1120
Important thing to understand though,
对于聚合，需要理解的重要一点是，

604
00:16:14,250 --> 00:16:15,605
0,260 260,755 755,1010 1010,1205 1205,1355
with aggregation,| since you're trying
|虽然你尝试合并多个 tuple 到单个标量值，

605
00:16:15,605 --> 00:16:17,540
0,165 165,525 525,845 1615,1845 1845,1935
to coalesce down, you know,

606
00:16:17,540 --> 00:16:19,295
0,240 240,770 970,1335 1335,1530 1530,1755
multiple tuples within, you know,

607
00:16:19,295 --> 00:16:20,465
0,345 345,525 525,615 615,825 825,1170
to to a single scalar

608
00:16:20,465 --> 00:16:23,050
0,245 895,1215 1215,1590 1590,1895 2185,2585
value,| you can't reference anything
|但是你不能引用 SELECT 输出的任何内容，

609
00:16:23,760 --> 00:16:25,965
0,240 240,560 940,1335 1335,1730 1930,2205
in the SELECT output,| that
|那不是聚合的一部分。

610
00:16:25,965 --> 00:16:27,720
0,420 420,785 1135,1560 1560,1680 1680,1755
isn't, that isn't part of

611
00:16:27,720 --> 00:16:28,860
0,90 90,590
the aggregate.|
|

612
00:16:28,930 --> 00:16:29,760
0,245 245,365 365,560 560,665 665,830
So I can't do something
所以我不能做这样的事，

613
00:16:29,760 --> 00:16:30,680
0,150 150,300 300,450 450,675 675,920
like this,| I can't go
|我不能 SELECT AVG(s.gpa) ，

614
00:16:30,820 --> 00:16:33,150
0,275 275,380 380,530 530,1090 2040,2330
SELECT the average gpa,| after
|在你 JOIN student 表和 enrolled 表之后，

615
00:16:33,150 --> 00:16:34,170
0,180 180,390 390,600 600,795 795,1020
you join the student table,

616
00:16:34,170 --> 00:16:35,760
0,150 150,435 435,710 1060,1335 1335,1590
the enrolled table,| and then
|然后还获取 enrolled 表的 cid ，

617
00:16:35,760 --> 00:16:37,995
0,315 315,540 540,800 1000,1400 1960,2235
also spit out the the

618
00:16:37,995 --> 00:16:40,035
0,165 165,455 775,1035 1035,1295 1735,2040
course id of the enrolled

619
00:16:40,035 --> 00:16:40,980
0,305
table,

620
00:16:41,330 --> 00:16:42,480
0,400
right,|
|

621
00:16:42,480 --> 00:16:43,395
0,135 135,240 240,360 360,570 570,915
because this is not defined,
因为这没有定义，这没有任何意义，

622
00:16:43,395 --> 00:16:44,780
0,270 270,665 685,930 930,1080 1080,1385
this doesn't make any sense,

623
00:16:45,580 --> 00:16:48,120
0,400 630,950 950,1130 1130,1510 2250,2540
right,| there, there isn't,| you,
|这里没有，|你使用多行，

624
00:16:48,120 --> 00:16:49,755
0,240 240,420 420,705 705,1280 1300,1635
you're taking multiple rows,| you
|你[压缩]它，以获得平均值，

625
00:16:49,755 --> 00:16:51,705
0,425 505,1020 1020,1110 1110,1680 1680,1950
you're condensing it {down\,,closing,it} down,

626
00:16:51,705 --> 00:16:53,330
0,450 450,630 630,780 780,1025 1225,1625
collapsing down for the average,|
|

627
00:16:53,800 --> 00:16:54,735
0,260 260,380 380,500 500,650 650,935
what is the course id
在这个上下文中的 cid 是什么，

628
00:16:54,735 --> 00:16:56,200
0,255 255,390 390,665
in this context,

629
00:16:56,600 --> 00:16:58,240
0,400 450,755 755,1000
right,| it's nothing.|
|它什么都不是。|

630
00:16:58,830 --> 00:16:59,900
0,230 230,305 305,550 690,935 935,1070
So, if you, in this
所以，在这个例子中，

631
00:16:59,900 --> 00:17:01,790
0,180 180,420 420,770 1570,1815 1815,1890
case here,| you sort of
|你看这个，

632
00:17:01,790 --> 00:17:02,255
0,60 60,120 120,210 210,315 315,465
look at this,| what you're
|你真正想做的是，

633
00:17:02,255 --> 00:17:03,040
0,120 120,285 285,390 390,510 510,785
really trying to do is,|
|

634
00:17:03,120 --> 00:17:03,920
0,305 305,410 410,515 515,650 650,800
you're trying to get for
你试图得到每个 cid ，得到 gpa 平均值，

635
00:17:03,920 --> 00:17:05,240
0,195 195,420 420,710 880,1170 1170,1320
each course id, get the

636
00:17:05,240 --> 00:17:06,740
0,210 210,800
average gpa,|
|

637
00:17:07,890 --> 00:17:08,555
0,245 245,350 350,455 455,560 560,665
so what you need to
所以，你需要做的是 GROUP BY 子句，

638
00:17:08,555 --> 00:17:09,575
0,245 415,690 690,825 825,930 930,1020
do is, what to call

639
00:17:09,575 --> 00:17:11,240
0,120 120,270 270,465 465,815
a GROUP BY clause,|
|

640
00:17:11,240 --> 00:17:13,670
0,380 430,765 765,930 930,1250 2050,2430
where you're going to project
你将 tuple 投影到桶中，

641
00:17:13,670 --> 00:17:15,710
0,435 435,740 1030,1560 1560,1815 1815,2040
tuples into buckets,| based on
|根据 GROUP BY 子句中的参数，

642
00:17:15,710 --> 00:17:17,360
0,210 210,500 940,1380 1380,1515 1515,1650
whatever the parameters are in

643
00:17:17,360 --> 00:17:18,820
0,120 120,240 240,390 390,710
the GROUP BY clause,|
|

644
00:17:18,820 --> 00:17:20,340
0,150 150,345 345,795 795,960 960,1520
and then compute the aggregate
然后计算每个单独桶的聚合。

645
00:17:20,540 --> 00:17:22,580
0,380 380,725 725,1025 1025,1360
on each individual bucket.|
|

646
00:17:23,030 --> 00:17:23,575
0,230 230,305 305,395 395,470 470,545
So you sort of think
所以你大概是这样想的，

647
00:17:23,575 --> 00:17:24,310
0,90 90,210 210,405 405,585 585,735
it like this,| if I
|如果我首先在 enrolled 表和 student 表之间进行 JOIN ，

648
00:17:24,310 --> 00:17:26,190
0,240 240,590 730,1130 1300,1590 1590,1880
first do the the JOIN

649
00:17:26,720 --> 00:17:27,685
0,260 260,350 350,635 635,815 815,965
between the enrolled table and

650
00:17:27,685 --> 00:17:29,200
0,120 120,315 315,635 1045,1320 1320,1515
the student table,| I have
|我就有了基于 JOIN 的所有可能的组合，

651
00:17:29,200 --> 00:17:30,760
0,270 270,620 970,1215 1215,1350 1350,1560
all the, {I,have} all possible

652
00:17:30,760 --> 00:17:31,950
0,435 435,675 675,810 810,930 930,1190
combinations based on the JOIN|
|

653
00:17:32,510 --> 00:17:33,580
0,260 260,410 410,680 680,980 980,1070
and then now I'm going
然后我将根据 cid 将它们分开，

654
00:17:33,580 --> 00:17:34,525
0,150 150,315 315,465 465,690 690,945
to split them up based

655
00:17:34,525 --> 00:17:35,470
0,150 150,315 315,510 510,675 675,945
on the the course id,|
|

656
00:17:35,470 --> 00:17:36,355
0,225 225,435 435,510 510,615 615,885
because that's what I have
因为这就在我的 GROUP BY 子句中，

657
00:17:36,355 --> 00:17:38,125
0,330 330,665 1195,1455 1455,1605 1605,1770
in my, in my GROUP

658
00:17:38,125 --> 00:17:39,300
0,180 180,515
BY clause,|
|

659
00:17:39,370 --> 00:17:40,680
0,275 275,470 470,755 755,1010 1010,1310
and then now I compute
然后现在我对每个桶计算平均绩点。

660
00:17:40,680 --> 00:17:43,010
0,135 135,380 1450,1695 1695,1815 1815,2330
the average for the gpa,

661
00:17:43,060 --> 00:17:44,025
0,260 260,515 515,755 755,860 860,965
for each, for each of

662
00:17:44,025 --> 00:17:45,120
0,135 135,575
those buckets.|
|

663
00:17:46,730 --> 00:17:47,940
0,260 260,520
Makes sense?|
能理解吗？|

664
00:17:50,660 --> 00:17:51,475
0,245 245,365 365,545 545,695 695,815
And just matches up like
就像这样匹配。

665
00:17:51,475 --> 00:17:52,420
0,275
this.|
|

666
00:17:53,510 --> 00:17:54,670
0,275 275,530 530,770 770,905 905,1160
So again, the main takeaway
所以，这里的主要观点是，

667
00:17:54,670 --> 00:17:55,345
0,120 120,300 300,465 465,570 570,675
this again,| you have to
|你必须有任何东西在一个，

668
00:17:55,345 --> 00:17:56,790
0,245 355,615 615,840 840,1080 1080,1445
have anything that's in a,|
|

669
00:17:58,690 --> 00:17:59,790
0,485 485,680 680,860 860,1025 1025,1100
anything that's not part of
不属于聚合的任何东西必须出现在 GROUP BY 子句中。

670
00:17:59,790 --> 00:18:01,815
0,75 75,620 1330,1650 1650,1845 1845,2025
an aggregation, has to appear

671
00:18:01,815 --> 00:18:02,660
0,165 165,270 270,375 375,525 525,845
in the GROUP BY clause.|
|

672
00:18:02,920 --> 00:18:03,720
0,260 260,365 365,470 470,605 605,800
So again, in this case
再说一次，在这里，

673
00:18:03,720 --> 00:18:04,650
0,270 270,480 480,675 675,780 780,930
here,| I don't have the
|我没有 s.name ，

674
00:18:04,650 --> 00:18:06,180
0,195 195,500 730,1050 1050,1260 1260,1530
student name,| I I can't,
|我不能把它放在那里，

675
00:18:06,180 --> 00:18:07,100
0,135 135,360 360,480 480,630 630,920
I can't put that there,|
|

676
00:18:07,180 --> 00:18:08,040
0,320 320,425 425,605 605,755 755,860
I'd have to put it
我必须把它放在 GROUP BY 子句中。

677
00:18:08,040 --> 00:18:08,760
0,180 180,360 360,465 465,570 570,720
in in the GROUP BY

678
00:18:08,760 --> 00:18:09,660
0,320
clause.|
|

679
00:18:10,530 --> 00:18:11,330
0,230 230,350 350,470 470,560 560,800
We can open the terminal
如果你希望，我们可以打开终端。

680
00:18:11,330 --> 00:18:12,170
0,45 45,120 120,285 285,480 480,840
if you want,| {MySQL -}
|MySQL 允许你做一些例子，

681
00:18:12,170 --> 00:18:13,030
0,225 225,360 360,480 480,600 600,860
used to let you do

682
00:18:13,110 --> 00:18:15,520
0,245 245,350 350,485 485,760
this in some cases,|
|

683
00:18:16,460 --> 00:18:17,605
0,245 245,335 335,485 485,790 870,1145
but we can actually try
让我们试着看看会发生什么。

684
00:18:17,605 --> 00:18:18,780
0,135 135,210 210,270 270,515
and see what happens.|
|

685
00:18:20,750 --> 00:18:21,930
0,275 275,440 440,755 755,905 905,1180
I hate typing on my,
我讨厌在我的 Surface 上打字，

686
00:18:23,110 --> 00:18:23,910
0,290 290,500 500,725 725,755 755,800
my Surface,| I'm going to
|我将使用这台笔记本电脑，

687
00:18:23,910 --> 00:18:25,880
0,135 135,440 550,975 975,1250
use this laptop here,|
|

688
00:18:25,880 --> 00:18:27,180
0,225 225,345 345,510 510,800
I'll log into it.|
我会登录进去。|

689
00:18:33,870 --> 00:18:34,610
0,230 230,380 380,560 560,665 665,740
All right, so we want
好的，我们要做的是 Postgres ，

690
00:18:34,610 --> 00:18:37,340
0,90 90,350 1990,2550 2550,2685 2685,2730
to do Postgres,| I have
|我有很多数据库系统在运行，

691
00:18:37,340 --> 00:18:38,120
0,60 60,150 150,330 330,555 555,780
a bunch of database systems

692
00:18:38,120 --> 00:18:39,695
0,320 760,1050 1050,1200 1200,1410 1410,1575
running,| so the query we
|所以我们要做的查询是，

693
00:18:39,695 --> 00:18:40,660
0,105 105,225 225,345 345,585 585,965
were trying to do was,|
|

694
00:18:45,730 --> 00:18:47,500
0,395 395,790
[essentially] this,
本质上是这样的，

695
00:18:48,460 --> 00:18:50,085
0,365 365,620 620,830 830,1370 1370,1625
right,| select average gpa course
|SELECT AVG(s.gpa), e.cid FROM enrolled AS e JOIN student AS s ON e.sid = s.sid; 。

696
00:18:50,085 --> 00:18:51,810
0,255 255,495 495,945 945,1275 1275,1725
id from enrolled joining enrolled

697
00:18:51,810 --> 00:18:53,260
0,135 135,300 300,465 465,740
table and student table,

698
00:18:53,300 --> 00:18:54,820
0,400 540,815 815,1175 1175,1415 1415,1520
right.| So Postgres doesn't let
|所以 Postgres 不允许你这样做，

699
00:18:54,820 --> 00:18:55,630
0,120 120,240 240,450 450,675 675,810
you do this,| because it
|因为它规定 cid 必须出现在 GROUP BY 子句中，

700
00:18:55,630 --> 00:18:57,385
0,240 240,620 760,1020 1020,1280 1480,1755
says the course id has

701
00:18:57,385 --> 00:18:57,955
0,150 150,285 285,390 390,480 480,570
to appear in the GROUP

702
00:18:57,955 --> 00:18:59,710
0,135 135,455 595,990 990,1235 1435,1755
BY clause,| that's good, that's
|这很好，这正是我们所期待的。

703
00:18:59,710 --> 00:19:00,860
0,75 75,240 240,560
what we expect.|
|

704
00:19:01,085 --> 00:19:01,490
0,75 75,150 150,210 210,285 285,405
Let's go over to {MySQL
让我们来看看 MySQL ，

705
00:19:01,490 --> 00:19:02,700
0,440
-},|
|

706
00:19:03,570 --> 00:19:04,415
0,275 275,470 470,635 635,740 740,845
{MySQL -} doesn't let you
MySQL 不允许你这样做，

707
00:19:04,415 --> 00:19:06,545
0,105 105,365 1705,1950 1950,2025 2025,2130
do it,| but let me
|但让我看看，在默认情况下是否将其设置为正确的模式，

708
00:19:06,545 --> 00:19:07,040
0,120 120,210 210,330 330,435 435,495
see if I put it

709
00:19:07,040 --> 00:19:08,855
0,75 75,180 180,390 390,740 1450,1815
in the right mode by

710
00:19:08,855 --> 00:19:09,840
0,365
default,|
|

711
00:19:11,670 --> 00:19:12,575
0,335 335,605 605,710 710,815 815,905
right, doesn't let you do
是的，不允许你这样做，

712
00:19:12,575 --> 00:19:13,295
0,105 105,225 225,375 375,480 480,720
it,| but there's a way
|但有一种方法可以，

713
00:19:13,295 --> 00:19:16,680
0,365 1105,1410 1410,2075
to,| it's enforcing,
|它会强制执行某种模式，

714
00:19:16,680 --> 00:19:19,185
0,255 255,705 705,980 1480,1880 2230,2505
it's enforcing the what mode

715
00:19:19,185 --> 00:19:19,845
0,180 180,270 270,375 375,480 480,660
it's in,| if I go
|如果我转到传统模式，

716
00:19:19,845 --> 00:19:21,500
0,255 255,605
to traditional,|
|

717
00:19:22,670 --> 00:19:23,590
0,290 290,515 515,695 695,785 785,920
then now run the same
然后，现在运行相同的查询，

718
00:19:23,590 --> 00:19:25,210
0,320 970,1230 1230,1365 1365,1500 1500,1620
query,| it lets me do
|它会让我这么做，

719
00:19:25,210 --> 00:19:25,960
0,260
it,|
|

720
00:19:26,250 --> 00:19:27,110
0,245 245,365 365,530 530,695 695,860
and it spits out course
它输出 cid 15-445 ，

721
00:19:27,110 --> 00:19:28,750
0,260 700,1020 1020,1200 1200,1350 1350,1640
id {15-445 - - -},|
|

722
00:19:29,360 --> 00:19:30,860
0,210 210,405 405,740
is that correct?|
这是正确的吗？|

723
00:19:32,410 --> 00:19:33,360
0,350 350,605 605,770 770,875 875,950
No, right, because what does
不对，是吧，因为那是什么意思，

724
00:19:33,360 --> 00:19:34,230
0,120 120,345 345,615 615,705 705,870
that mean,| it's the average
|这是所有课程的平均绩点，

725
00:19:34,230 --> 00:19:36,045
0,360 360,495 495,645 645,950 1300,1815
gpa for all courses,| {but,that's}
|但是它却输出了其中的一个，

726
00:19:36,045 --> 00:19:36,920
0,210 210,360 360,525 525,630 630,875
spitting out one of them,|
|

727
00:19:37,300 --> 00:19:39,795
0,230 230,695 695,940 2100,2330 2330,2495
so that's bad.| So let's
所以这很糟糕。|所以我们现在开始，使用同样的查询，

728
00:19:39,795 --> 00:19:40,680
0,150 150,420 420,645 645,750 750,885
go now, take the same

729
00:19:40,680 --> 00:19:42,500
0,320 880,1140 1140,1305 1305,1485 1485,1820
query| and we'll go over
|我们将转到 SQLite 。

730
00:19:42,550 --> 00:19:44,620
0,400
to,

731
00:19:45,080 --> 00:19:46,740
0,260 260,730
to SQLite.|
|

732
00:19:48,250 --> 00:19:48,915
0,260 260,395 485,530 530,590 590,665
Who thinks it's going to
谁认为它会工作，

733
00:19:48,915 --> 00:19:49,800
0,245
work,|
|

734
00:19:50,010 --> 00:19:50,600
0,275 275,380 380,455 455,530 530,590
raise your hand if you
如果你回答是的，请举手，

735
00:19:50,600 --> 00:19:51,820
0,105 105,380
say yes,|
|

736
00:19:51,860 --> 00:19:53,395
0,245 245,470 470,755 755,1055 1055,1535
and the work meaning it'll
而工作意味着它将运行查询，

737
00:19:53,395 --> 00:19:54,445
0,195 195,315 315,420 420,695 775,1050
actually run the query,| I'm
|我不是在说结果正确，

738
00:19:54,445 --> 00:19:55,350
0,75 75,180 180,315 315,555 555,905
not saying the result correct,|
|

739
00:19:56,290 --> 00:19:58,095
0,260 260,520 1290,1535 1535,1640 1640,1805
who thinks?| We have one
谁认为？|我们有一个，两个是的。

740
00:19:58,095 --> 00:19:59,190
0,225 225,405 405,765 765,945 945,1095
yes, two yesesf.| Who says
|谁认为不会？

741
00:19:59,190 --> 00:20:00,120
0,290
no?|
|

742
00:20:01,120 --> 00:20:02,620
0,290 290,440 440,530 530,790
Most people say no.|
大多数人说不会。|

743
00:20:03,370 --> 00:20:06,405
0,245 245,350 350,610 1740,2140 2790,3035
It did it, right,| and
它完成了，|它还输出了 15-445 ，

744
00:20:06,405 --> 00:20:07,215
0,135 135,285 285,420 420,540 540,810
it also spit out {15-445

745
00:20:07,215 --> 00:20:08,355
0,270 270,420 420,695 805,1050 1050,1140
- - -},| is that
|这和 MySQL 的值一样吗？

746
00:20:08,355 --> 00:20:09,045
0,105 105,255 255,420 420,555 555,690
the same value as my

747
00:20:09,045 --> 00:20:10,140
0,395
sql?|
|

748
00:20:10,290 --> 00:20:13,020
0,335 335,770 770,1060 1830,2230
Yeah, gpa looks, sorry,
是的，绩点看起来，抱歉，绩点看起来是一样的。

749
00:20:13,620 --> 00:20:16,120
0,380 380,515 515,650 650,910
gpa looks the same,|
|

750
00:20:16,120 --> 00:20:17,005
0,120 120,210 210,375 375,570 570,885
All right, let's go to
好的，我们转到 Oracle ，

751
00:20:17,005 --> 00:20:18,280
0,605
Oracle,|
|

752
00:20:20,210 --> 00:20:21,715
0,425 425,605 605,725 725,1000 1445,1505
Oracle doesn't like it.| Let's
Oracle 不喜欢这样。|我们转到 DuckDB ，

753
00:20:21,715 --> 00:20:23,260
0,90 90,270 270,725
go to DuckDB,|
|

754
00:20:25,350 --> 00:20:26,525
0,245 245,395 395,470 470,730 870,1175
DuckDB didn't like it.| So
DuckDB 不喜欢这样。|所以 MySQL ，你可以这样做，

755
00:20:26,525 --> 00:20:27,320
0,195 195,450 450,540 540,660 660,795
MySQL, you can do

756
00:20:27,320 --> 00:20:28,550
0,260 370,660 660,810 810,1020 1020,1230
it,| if if you, if
|你可以让它这样做，

757
00:20:28,550 --> 00:20:29,540
0,120 120,255 255,420 420,710 730,990
you make it be,| more
|比如在 MySQL 5.7 和 8 上，

758
00:20:29,540 --> 00:20:30,275
0,120 120,255 255,495 495,600 600,735
like {MySQL -} {5.7 -

759
00:20:30,275 --> 00:20:31,595
0,180 180,375 375,665 805,1080 1080,1320
-} and 8,| but {SQLite
|但是 SQLite 会这样做。

760
00:20:31,595 --> 00:20:32,760
0,90 90,210 210,285 285,515
-} will do it.|
|

761
00:20:32,760 --> 00:20:35,055
0,180 180,440 1840,2085 2085,2175 2175,2295
So again, this is the
所以，这是第一个例子，

762
00:20:35,055 --> 00:20:35,925
0,225 225,495 495,735 735,795 795,870
first example,| we'll see it
|我们会看到很多次，

763
00:20:35,925 --> 00:20:37,260
0,135 135,425
many times,|
|

764
00:20:37,390 --> 00:20:39,020
0,490 660,980 980,1175 1175,1340 1340,1630
SQL standard says one thing,|
SQL 标准说的一件事情，|

765
00:20:39,280 --> 00:20:40,605
0,400 480,755 755,935 935,1160 1160,1325
but the different systems are
但是不同的系统做不同的事情。

766
00:20:40,605 --> 00:20:41,820
0,120 120,300 300,605
doing different things.|
|

767
00:20:45,170 --> 00:20:45,925
0,275 275,380 380,455 455,590 590,755
Next thing you do is
接下来你要做的是，

768
00:20:45,925 --> 00:20:46,855
0,275 445,660 660,720 720,810 810,930
have,| you can have a
|你可以有一个 HAVING 子句，

769
00:20:46,855 --> 00:20:48,385
0,225 225,605 925,1260 1260,1440 1440,1530
HAVING clause,| say, if you
|比如，如果你想要在你生成的这些聚合列上过滤，

770
00:20:48,385 --> 00:20:49,590
0,90 90,195 195,375 375,885 885,1205
want to start filtering on

771
00:20:49,730 --> 00:20:51,625
0,260 260,395 395,820 1320,1580 1580,1895
on these aggregation, the aggregate

772
00:20:51,625 --> 00:20:54,040
0,225 225,450 450,875 2035,2280 2280,2415
columns you're generating,| you can
|你可以添加一个 HAVING 子句来指定，

773
00:20:54,040 --> 00:20:55,630
0,165 165,330 330,645 645,950 1300,1590
add a HAVING clause to

774
00:20:55,630 --> 00:20:57,040
0,560
specify|
|

775
00:20:57,230 --> 00:20:58,750
0,400 810,1055 1055,1175 1175,1325 1325,1520
whether, how many, what people
什么人应该匹配，

776
00:20:58,750 --> 00:21:00,100
0,210 210,500
should match,|
|

777
00:21:00,200 --> 00:21:01,350
0,290 290,470 470,605 605,680 680,1150
after you complete the aggregation,
在你完成聚合之后，

778
00:21:02,120 --> 00:21:02,840
0,180 180,375 375,525 525,645 645,720
right,| so say I want
|比如，我只想要，

779
00:21:02,840 --> 00:21:05,450
0,75 75,320 340,740 2080,2400 2400,2610
to get only,| {show,me,only} the
|展示那些平均绩点大于 3.9 的学生，

780
00:21:05,450 --> 00:21:06,365
0,225 225,420 420,555 555,705 705,915
students that have an average

781
00:21:06,365 --> 00:21:08,740
0,545
gpa

782
00:21:08,740 --> 00:21:10,795
0,255 255,435 435,675 675,1340 1720,2055
that's greater than 3.9,| so
|所以在本例中，

783
00:21:10,795 --> 00:21:11,725
0,180 180,315 315,510 510,675 675,930
in this case here,| I'm
|我计算的是聚合 SELECT AVG(s.gpa) AS avg_gpa ，

784
00:21:11,725 --> 00:21:13,795
0,300 300,420 420,905 1525,1830 1830,2070
computing the aggregation SELECT average

785
00:21:13,795 --> 00:21:16,585
0,525 525,875 1765,2345 2425,2655 2655,2790
gpa as avg_gpa| and I'm
|并且我试图在 WHERE 子句中引用它，

786
00:21:16,585 --> 00:21:17,610
0,105 105,240 240,495 495,750 750,1025
trying to reference it here

787
00:21:17,630 --> 00:21:18,600
0,260 260,350 350,455 455,635 635,970
inside of my WHERE clause,

788
00:21:19,100 --> 00:21:20,680
0,400 630,905 905,1175 1175,1325 1325,1580
right,| I can't do that,|
|我不能这样做，|

789
00:21:20,680 --> 00:21:22,285
0,380 580,870 870,1110 1110,1395 1395,1605
because at this point, when
因为此时系统正在计算查询，

790
00:21:22,285 --> 00:21:23,620
0,165 165,420 420,720 720,945 945,1335
the system is actually calculating

791
00:21:23,620 --> 00:21:24,820
0,150 150,440
the query,|
|

792
00:21:24,820 --> 00:21:26,095
0,270 270,570 570,1005 1005,1170 1170,1275
it's computing aggregation as it
它一边运行，一边计算聚合，

793
00:21:26,095 --> 00:21:28,000
0,180 180,515 805,1110 1110,1535 1555,1905
goes along,| it can't, doesn't
|它不知道最后的结果是什么，

794
00:21:28,000 --> 00:21:29,005
0,105 105,195 195,300 300,560 700,1005
know what the final result

795
00:21:29,005 --> 00:21:30,100
0,305
is,|
|

796
00:21:30,790 --> 00:21:31,650
0,245 245,320 320,500 500,725 725,860
so the easy fix of
所以，解决这一问题的简单方法是有一个 HAVING 子句，

797
00:21:31,650 --> 00:21:32,625
0,165 165,345 345,465 465,705 705,975
this is to have a

798
00:21:32,625 --> 00:21:34,040
0,225 225,605
HAVING clause,|
|

799
00:21:34,040 --> 00:21:34,985
0,150 150,270 270,525 525,810 810,945
which is basically telling the
这基本上是在告诉系统，

800
00:21:34,985 --> 00:21:38,020
0,245 805,1275 1275,1695 1695,2015
system,| {okay\,,formative} aggregation is
|[形成聚合]是生成在 SELECT 语句中定义的输出，

801
00:21:38,210 --> 00:21:39,490
0,275 275,500 500,710 710,1040 1040,1280
produce the output that's defined

802
00:21:39,490 --> 00:21:41,155
0,135 135,270 270,465 465,770 1270,1665
in the SELECT statement,| and
|然后应用这个 HAVING 额外的过滤器。

803
00:21:41,155 --> 00:21:42,630
0,360 360,630 630,840 840,1110 1110,1475
then apply this additional filter

804
00:21:43,520 --> 00:21:44,740
0,260 260,520
for HAVING.|
|

805
00:21:46,310 --> 00:21:47,125
0,245 245,395 395,530 530,650 650,815
This is actually not correct
在某些情况下，这其实也是不对的，

806
00:21:47,125 --> 00:21:48,550
0,275 445,705 705,825 825,1085 1195,1425
either, In some cases,| I
|我也不认为 SQL 标准允许你这样做，

807
00:21:48,550 --> 00:21:49,195
0,120 120,195 195,300 300,510 510,645
don't think the SQL standard

808
00:21:49,195 --> 00:21:49,980
0,135 135,255 255,375 375,510 510,785
lets you do this either,

809
00:21:50,480 --> 00:21:51,715
0,350 350,650 650,890 890,1085 1085,1235
right,| because even though I
|因为即使我在这里有一个平均绩点的别名，

810
00:21:51,715 --> 00:21:52,750
0,105 105,210 210,660 660,840 840,1035
have an alias up here

811
00:21:52,750 --> 00:21:54,420
0,165 165,315 315,830
for average gpa,|
|

812
00:21:54,490 --> 00:21:56,565
0,400 1290,1580 1580,1760 1760,1895 1895,2075
the data system can say,
数据系统会说，我不知道这是什么，

813
00:21:56,565 --> 00:21:57,315
0,225 225,435 435,510 510,615 615,750
I don't know what this

814
00:21:57,315 --> 00:21:58,360
0,275
is,|
|

815
00:21:58,630 --> 00:21:59,550
0,305 305,560 560,680 680,800 800,920
{MySQL -} that you do
MySQL 可以这样做， Postgres 不能，

816
00:21:59,550 --> 00:22:02,190
0,260 1510,1875 1875,2130 2130,2370 2370,2640
it, Postgres does not,| so
|除非你必须重新编写聚合子句，

817
00:22:02,190 --> 00:22:02,910
0,195 195,300 300,375 375,480 480,720
instead you have to basically

818
00:22:02,910 --> 00:22:06,195
0,300 300,620 1870,2270 2320,2910 2910,3285
write the the aggregation clause

819
00:22:06,195 --> 00:22:07,120
0,365
again,|
|

820
00:22:07,240 --> 00:22:08,460
0,290 290,470 470,620 620,880 990,1220
and again, the database should
同样，数据库应该足够智能，能够识别，

821
00:22:08,460 --> 00:22:09,320
0,150 150,345 345,480 480,600 600,860
be smart enough to recognize

822
00:22:09,430 --> 00:22:11,235
0,400 570,970 1140,1490 1490,1700 1700,1805
that,| this average on the
|这个 gpa 上的平均值与上面的 avg_gpa 相同，

823
00:22:11,235 --> 00:22:12,015
0,360 360,480 480,570 570,675 675,780
gpa is the same as

824
00:22:12,015 --> 00:22:12,980
0,105 105,285 285,570 570,690 690,965
that {avg_gpa -} up there,|
|

825
00:22:13,060 --> 00:22:14,460
0,335 335,545 545,940 990,1250 1250,1400
and therefore compute the same
因此计算相同的计算，而不是执行两次相同的计算。

826
00:22:14,460 --> 00:22:16,815
0,470 760,1260 1260,1610 1990,2250 2250,2355
computation, don't perform, perform the

827
00:22:16,815 --> 00:22:18,280
0,135 135,540 540,875
same computation twice.|
|

828
00:22:20,030 --> 00:22:21,040
0,275 275,470 470,665 665,830 830,1010
So essentially just doing this
所以，本质上只是再次执行此操作，

829
00:22:21,040 --> 00:22:22,645
0,225 225,540 540,615 615,1070 1330,1605
again,| compute the aggregation and
|计算聚合，然后进行额外的过滤，以丢弃不需要的内容。

830
00:22:22,645 --> 00:22:23,815
0,180 180,450 450,645 645,825 825,1170
then do the additional filtering

831
00:22:23,815 --> 00:22:24,445
0,150 150,270 270,375 375,510 510,630
to throw out things you

832
00:22:24,445 --> 00:22:25,800
0,335
don't.|
|

833
00:22:26,510 --> 00:22:27,880
0,260 260,520
Makes sense?|
能理解吗？|

834
00:22:29,550 --> 00:22:30,820
0,245 245,490
All right,
好的，

835
00:22:31,440 --> 00:22:33,370
0,430 900,1205 1205,1430 1430,1685 1685,1930
strings and {timestamps -} or
字符串和时间戳或日期，

836
00:22:33,780 --> 00:22:34,835
0,305 305,455 455,590 590,770 770,1055
dates| of when things get
|在这里事情变得非常奇怪，

837
00:22:34,835 --> 00:22:36,875
0,395 1195,1455 1455,1605 1605,1830 1830,2040
really get really weird,| not
|不是奇怪，但是非常不一致。

838
00:22:36,875 --> 00:22:39,730
0,165 165,300 300,545 865,1265 2035,2855
weird, but like, really inconsistent.|
|

839
00:22:40,470 --> 00:22:41,900
0,305 305,530 530,755 755,1055 1055,1430
So for string function, string
对于字符串函数或字符串数据类型，

840
00:22:41,900 --> 00:22:43,750
0,345 345,710 1030,1320 1320,1530 1530,1850
operations {or,sorry}, string data types,|
|

841
00:22:44,190 --> 00:22:46,775
0,400 960,1385 1385,1610 1610,2210 2210,2585
the SQL standard specifies that,|
SQL 标准规定，|

842
00:22:46,775 --> 00:22:48,290
0,395 655,960 960,1185 1185,1350 1350,1515
the, the case of the
值中字符串的大小写，

843
00:22:48,290 --> 00:22:50,015
0,350 670,990 990,1155 1155,1400 1480,1725
strings within the values,| that
|我指的不是字符串和 SELECT 语句，

844
00:22:50,015 --> 00:22:50,735
0,105 105,240 240,405 405,600 600,720
I {don't,mean} the strings and

845
00:22:50,735 --> 00:22:51,640
0,120 120,285 285,510 510,675 675,905
the select statements,| I mean
|我指的是你存储的实际数据，

846
00:22:51,720 --> 00:22:52,810
0,305 305,470 470,620 620,800 800,1090
the actual data you're storing,|
|

847
00:22:53,460 --> 00:22:54,360
0,210 210,435 435,555 555,690 690,900
that they should be case
它们应该区分大小写，

848
00:22:54,360 --> 00:22:56,775
0,320 880,1170 1170,1460 2080,2325 2325,2415
sensitive| and that when you
|当你希望在 SQL 语句中包含常量字符串时，

849
00:22:56,775 --> 00:22:57,495
0,105 105,225 225,420 420,600 600,720
want to have in your

850
00:22:57,495 --> 00:23:00,225
0,240 240,515 1105,1505 1645,2075 2485,2730
SQL statement constant strings,| you
|你应该使用单引号，

851
00:23:00,225 --> 00:23:01,370
0,90 90,195 195,375 375,645 645,1145
want to use single quotes,|
|

852
00:23:02,260 --> 00:23:04,545
0,640 810,1205 1205,1480 1560,1850 1850,2285
Postgres, SQL Server and Oracle
Postgres, SQL Server 和 Oracle 都遵循标准，

853
00:23:04,545 --> 00:23:06,380
0,210 210,390 390,665 1075,1380 1380,1835
follow the standard,| {MySQL -}
|而 MySQL 是，默认情况下，不区分大小写，

854
00:23:06,820 --> 00:23:08,120
0,400
is,

855
00:23:08,570 --> 00:23:11,875
0,380 380,760 780,1100 1100,1900 3030,3305
by default, case insensitive| and
|然后 SQLite 和 MySQL 都支持

856
00:23:11,875 --> 00:23:12,970
0,135 135,360 360,645 645,915 915,1095
then they both {SQLite -}

857
00:23:12,970 --> 00:23:14,520
0,320 400,675 675,840 840,1200 1200,1550
and and {MySQL -} support|
|

858
00:23:14,660 --> 00:23:17,575
0,320 320,590 590,940 2280,2600 2600,2915
both single and double quotation
使用单引号和双引号来表示常量和字符串。

859
00:23:17,575 --> 00:23:19,840
0,305 745,1145 1165,1565 1615,2100 2100,2265
marks to represent constants and

860
00:23:19,840 --> 00:23:20,700
0,320
strings.|
|

861
00:23:21,325 --> 00:23:21,760
0,75 75,150 150,225 225,300 300,435
So let's do what {MySQL
所以让我们操作 MySQL ，

862
00:23:21,760 --> 00:23:22,900
0,195 195,440 610,900 900,1035 1035,1140
-} does| and see how
|看看这有多奇怪。

863
00:23:22,900 --> 00:23:24,120
0,135 135,270 270,530
weird this is.|
|

864
00:23:25,100 --> 00:23:26,100
0,215 215,335 335,440 440,650 650,1000
So let's go back here,
所以让我们回到这里，

865
00:23:26,840 --> 00:23:28,220
0,320
{}

866
00:23:30,290 --> 00:23:32,790
0,380 380,760 1920,2165 2165,2255 2255,2500
right,| so you can represent
|所以你可以像这样表示一个常量，

867
00:23:33,560 --> 00:23:35,640
0,290 290,530 530,770 770,1060
a constant like this,

868
00:23:35,890 --> 00:23:37,035
0,320 320,620 620,860 860,980 980,1145
right,| so you can have
|你可以在 MySQL 中使用不带 FROM 子句的 SELECT 语句，

869
00:23:37,035 --> 00:23:38,745
0,210 210,420 420,725 745,1145 1435,1710
a SELECT statement without a

870
00:23:38,745 --> 00:23:40,100
0,165 165,485 505,765 765,915 915,1355
FROM clause in {MySQL -}|
|

871
00:23:40,690 --> 00:23:42,465
0,245 245,350 350,470 470,730 1500,1775
and I can represent,| it
我可以表示，|它基本上接受任何输入，

872
00:23:42,465 --> 00:23:43,635
0,255 255,555 555,780 780,1005 1005,1170
basically takes whatever the input

873
00:23:43,635 --> 00:23:45,120
0,245 355,720 720,975 975,1185 1185,1485
is| and I can, it'll
|我可以，它会把它输出出来，

874
00:23:45,120 --> 00:23:45,660
0,135 135,210 210,330 330,450 450,540
spit it out,| so I
|所以我加了一个逗号，

875
00:23:45,660 --> 00:23:47,490
0,90 90,180 180,620 970,1370 1570,1830
put a comma,| like I
|比如，我可以做 1 2 3 ，像这样，

876
00:23:47,490 --> 00:23:49,190
0,90 90,180 180,345 345,650 1300,1700
can do like 1, 2,

877
00:23:50,700 --> 00:23:52,460
0,400 420,710 710,1000 1260,1610 1610,1760
3, like that,| it'll make
|它将对输出中的所有内容进行[排列]。

878
00:23:52,460 --> 00:23:53,915
0,270 270,465 465,710 1060,1320 1320,1455
columns for all the things

879
00:23:53,915 --> 00:23:55,060
0,120 120,270 270,575
in the output.|
|

880
00:23:55,100 --> 00:23:56,680
0,400 510,860 860,1205 1205,1445 1445,1580
So for strings,| I can
所以对于字符串，|我可以放在单引号或双引号中，

881
00:23:56,680 --> 00:23:58,280
0,150 150,300 300,560
have it as

882
00:23:58,980 --> 00:24:01,690
0,305 305,790 1530,1930 1980,2285 2285,2710
double quotes and single quotes|
|

883
00:24:03,060 --> 00:24:04,120
0,245 245,335 335,455 455,590 590,1060
in the case of Postgres,
在 Postgres 中，它不允许我使用双引号，

884
00:24:05,490 --> 00:24:06,170
0,245 245,410 410,470 470,560 560,680
it won't let me do

885
00:24:06,170 --> 00:24:07,440
0,165 165,590
double quotes,

886
00:24:08,710 --> 00:24:09,760
0,400
right,|
|

887
00:24:09,760 --> 00:24:10,750
0,240 240,330 330,570 570,810 810,990
can't do that,| because it's
无法执行这个操作，|因为它在尝试查找名为 tupac 的列，

888
00:24:10,750 --> 00:24:11,290
0,105 105,195 195,315 315,420 420,540
trying to look for a

889
00:24:11,290 --> 00:24:12,430
0,240 240,495 495,840 840,1080 1080,1140
column name tupac,| that's the
|这是你转义列名的方式，

890
00:24:12,430 --> 00:24:13,825
0,90 90,210 210,315 315,560 1060,1395
way you sort of escape

891
00:24:13,825 --> 00:24:15,550
0,255 255,575 925,1185 1185,1410 1410,1725
column names,| but it'll, it'll
|但它将支持单引号。

892
00:24:15,550 --> 00:24:17,120
0,350
support

893
00:24:17,810 --> 00:24:19,200
0,320 320,760
single quotes.|
|

894
00:24:19,550 --> 00:24:21,535
0,320 320,635 635,995 995,1240 1650,1985
So in {SQLite -}, they
在 SQLite 中，它们两者都支持，

895
00:24:21,535 --> 00:24:22,920
0,210 210,485
support both,|
|

896
00:24:24,070 --> 00:24:25,005
0,230 230,320 320,440 440,605 605,935
so that can go tupac
可以像这样获取 tupac ，

897
00:24:25,005 --> 00:24:26,520
0,180 180,455
like this,|
|

898
00:24:26,820 --> 00:24:27,545
0,260 260,365 365,470 470,590 590,725
and I can go with
我也可以用这样的单引号。

899
00:24:27,545 --> 00:24:29,860
0,195 195,665 865,1140 1140,1415
single quotes like that.|
|

900
00:24:29,900 --> 00:24:32,360
0,400 1080,1720
In Oracle,
在 Oracle 中，它是单引号，

901
00:24:34,035 --> 00:24:35,500
0,120 120,315 315,785
it's single quotes,|
|

902
00:24:36,780 --> 00:24:37,895
0,260 260,365 365,545 545,680 680,1115
but it isn't like queries
但它没有没有 FROM 子句的查询，

903
00:24:37,895 --> 00:24:39,720
0,285 285,435 435,600 600,935
without a FROM clause,|
|

904
00:24:40,690 --> 00:24:41,850
0,260 260,365 365,755 755,935 935,1160
so in Oracle, they have
在 Oracle 中，他们有一个奇怪的东西，叫做 DUAL 表，

905
00:24:41,850 --> 00:24:42,930
0,270 270,525 525,750 750,930 930,1080
this weird thing called the

906
00:24:42,930 --> 00:24:44,775
0,410 490,735 735,945 945,1220 1600,1845
DUAL, the DUAL table,| and
|这是一个 Oracle 中假的表，

907
00:24:44,775 --> 00:24:45,710
0,105 105,210 210,360 360,600 600,935
this is a fake table

908
00:24:45,910 --> 00:24:47,020
0,400
that

909
00:24:47,020 --> 00:24:48,655
0,270 270,435 435,920 1210,1500 1500,1635
comes with Oracle,| allow you
|允许你对实际不存在的表编写查询，

910
00:24:48,655 --> 00:24:49,705
0,105 105,365 535,810 810,945 945,1050
to write these kind of

911
00:24:49,705 --> 00:24:51,445
0,455 835,1155 1155,1380 1380,1530 1530,1740
queries against tables that don't

912
00:24:51,445 --> 00:24:52,700
0,210 210,515
actually exist,

913
00:24:52,990 --> 00:24:53,955
0,320 320,485 485,665 665,860 860,965
right,| so then I can
|然后我可以得到，

914
00:24:53,955 --> 00:24:55,635
0,120 120,395 1225,1470 1470,1575 1575,1680
get that,| if you try
|如果你尝试， SELECT * FROM DUAL ，

915
00:24:55,635 --> 00:24:56,550
0,90 90,195 195,405 405,675 675,915
to do like, SELECT star

916
00:24:56,550 --> 00:24:58,140
0,320 370,920
from DUAL,|
|

917
00:25:01,710 --> 00:25:02,615
0,230 230,335 335,470 470,695 695,905
you just get like an
你只会得到一个 X ，

918
00:25:02,615 --> 00:25:03,720
0,245
X,|
|

919
00:25:04,870 --> 00:25:05,730
0,245 245,350 350,470 470,680 680,860
I think the newer version,|
我认为更新的版本，|

920
00:25:05,730 --> 00:25:06,330
0,180 180,315 315,435 435,510 510,600
they got rid of the
他们避免了 DUAL ，你不再需要，

921
00:25:06,330 --> 00:25:07,065
0,210 210,300 300,420 420,555 555,735
DUAL, you don't need anymore,|
|

922
00:25:07,065 --> 00:25:08,240
0,150 150,345 345,540 540,705 705,1175
this is, this is Oracle
这是 Oracle 21 ，

923
00:25:08,470 --> 00:25:09,710
0,515 515,740 740,920 920,995 995,1240
21,| so it's a rather
|所以它是一个相当新的版本，

924
00:25:09,730 --> 00:25:13,215
0,350 350,610 960,1360 3120,3365 3365,3485
newer version, right,| so like
|比如你不能这样做，

925
00:25:13,215 --> 00:25:15,020
0,150 150,435 435,695
you can't do,

926
00:25:15,620 --> 00:25:16,435
0,245 245,410 410,500 500,665 665,815
you can't do this,| but
|但在 Postgres 或任何其他数据库系统中，

927
00:25:16,435 --> 00:25:17,995
0,105 105,240 240,755 835,1235 1285,1560
like in Postgres or any

928
00:25:17,995 --> 00:25:19,315
0,165 165,345 345,635 955,1200 1200,1320
other database system,| you can
|你可以将 SQL 当作计算器，

929
00:25:19,315 --> 00:25:20,425
0,275 535,855 855,930 930,1020 1020,1110
treat SQL as like a

930
00:25:20,425 --> 00:25:22,015
0,455 625,885 885,1140 1140,1440 1440,1590
calculator,| you can put whatever
|你可以把任何你想要的东西放在子句中。

931
00:25:22,015 --> 00:25:22,750
0,90 90,240 240,435 435,600 600,735
you want in clause like

932
00:25:22,750 --> 00:25:24,000
0,260
that.|
|

933
00:25:24,350 --> 00:25:25,255
0,290 290,455 455,620 725,800 800,905
So, all right, let's go
好的，让我们回到 MySQL ，

934
00:25:25,255 --> 00:25:26,820
0,105 105,210 210,345 345,785
back to {MySQL -},|
|

935
00:25:27,530 --> 00:25:28,380
0,260 260,440 440,515 515,605 605,850
and let's look at some
让我们来看一些字符串函数。

936
00:25:28,460 --> 00:25:29,820
0,275 275,550
string functions.|
|

937
00:25:30,030 --> 00:25:31,080
0,400
So,
所以，我现在可以调用，

938
00:25:32,950 --> 00:25:34,960
0,260 260,410 410,635 635,970
I can call now,|
|

939
00:25:36,870 --> 00:25:37,880
0,275 275,380 380,590 590,860 860,1010
I can do SELECT star
我可以做 SELECT * FROM student WHERE name = 'TuPaC';

940
00:25:37,880 --> 00:25:39,200
0,150 150,390 390,645 645,950 970,1320
FROM student WHERE name equals

941
00:25:39,200 --> 00:25:41,900
0,500 520,920 1300,1620 1620,2120 2410,2700
TuPaC,| with weird casing| and
|带有奇怪的大小写，|然后它与字符串 Tupac 匹配，

942
00:25:41,900 --> 00:25:43,745
0,210 210,450 450,1040 1360,1665 1665,1845
then it matched on the

943
00:25:43,745 --> 00:25:45,580
0,165 165,575
string Tupac,

944
00:25:45,590 --> 00:25:47,530
0,335 335,670 780,1325 1325,1565 1565,1940
right,| because internally {MySQL -}
|因为在内部 MySQL 将 varchar 视为不区分大小写。

945
00:25:47,530 --> 00:25:48,750
0,300 300,630 630,735 735,900 900,1220
is treating the varchars

946
00:25:49,070 --> 00:25:50,860
0,305 305,500 500,1210
as case insensitive.|
|

947
00:25:51,510 --> 00:25:52,595
0,335 335,545 545,695 695,905 905,1085
So if you want to
所以如果你现在想要，

948
00:25:52,595 --> 00:25:54,660
0,245
now,|
|

949
00:25:56,110 --> 00:25:57,735
0,260 260,380 380,515 515,790 1350,1625
if you want to treat
如果你想像对待任何其他数据库系统一样对待它，

950
00:25:57,735 --> 00:25:59,145
0,105 105,270 270,450 450,695 1075,1410
it like, you know, like

951
00:25:59,145 --> 00:26:00,195
0,240 240,435 435,660 660,900 900,1050
any other database system,| where
|它的大小写视为 TuPaC ，

952
00:26:00,195 --> 00:26:01,125
0,150 150,300 300,525 525,765 765,930
it actually is actually looking

953
00:26:01,125 --> 00:26:01,965
0,150 150,255 255,465 465,675 675,840
at the case as a

954
00:26:01,965 --> 00:26:03,375
0,165 165,605 895,1140 1140,1245 1245,1410
{TuPaC -},| you can add
|你可以在列名前面添加这个 BINARY 标志或关键字，

955
00:26:03,375 --> 00:26:04,650
0,195 195,630 630,930 930,1140 1140,1275
this BINARY flag in front

956
00:26:04,650 --> 00:26:06,000
0,180 180,500
of the,

957
00:26:06,000 --> 00:26:07,230
0,315 315,615 615,840 840,1065 1065,1230
or keyword in front of

958
00:26:07,230 --> 00:26:08,760
0,195 195,405 405,740 970,1230 1230,1530
the column name,| and that'll
|这将把它视为一个 BINARY 字符串，

959
00:26:08,760 --> 00:26:09,800
0,120 120,240 240,420 420,600 600,1040
treat it as a binary

960
00:26:10,600 --> 00:26:11,780
0,290 290,515 515,725 725,890 890,1180
string,| like any other system,|
|就像任何其他系统一样，|

961
00:26:12,610 --> 00:26:13,470
0,245 245,365 365,530 530,710 710,860
in this case here, now
在这种情况下，现在它不匹配，

962
00:26:13,470 --> 00:26:14,460
0,105 105,315 315,525 525,750 750,990
it doesn't match,| but now
|但现在它告诉我有一个警告。

963
00:26:14,460 --> 00:26:15,255
0,345 345,570 570,660 660,720 720,795
it tells me I have

964
00:26:15,255 --> 00:26:16,460
0,105 105,365
a warning.|
|

965
00:26:16,460 --> 00:26:17,000
0,210 210,285 285,405 405,465 465,540
So now I've got to
所以现在我要调用 show warnings ，

966
00:26:17,000 --> 00:26:18,430
0,165 165,435 435,720 720,975 975,1430
go now call show warnings,|
|

967
00:26:18,540 --> 00:26:19,970
0,245 245,490 720,1025 1025,1205 1205,1430
and this is {MySQL -}
这是 MySQL 特有的，

968
00:26:19,970 --> 00:26:21,515
0,260 850,1095 1095,1230 1230,1395 1395,1545
specific,| so now they tell
|所以现在他们告诉我，

969
00:26:21,515 --> 00:26:24,050
0,150 150,425 835,1235 1825,2295 2295,2535
me that,| the binary expression
|BINARY 表达式已被弃用并被删除，

970
00:26:24,050 --> 00:26:25,480
0,195 195,705 705,945 945,1110 1110,1430
is deprecated and be removed,|
|

971
00:26:26,040 --> 00:26:26,855
0,260 260,410 410,590 590,725 725,815
and they tell me at
他们至少告诉我如何正确编写它，

972
00:26:26,855 --> 00:26:27,965
0,210 210,450 450,720 720,975 975,1110
least how to write it

973
00:26:27,965 --> 00:26:28,920
0,275
correctly,|
|

974
00:26:29,350 --> 00:26:30,540
0,290 290,580 720,965 965,1055 1055,1190
so now I have to
所以现在我必须 CAST(name AS BINARY) ，

975
00:26:30,540 --> 00:26:33,165
0,290 520,920 1510,1875 1875,2240 2380,2625
CAST the name AS a

976
00:26:33,165 --> 00:26:34,410
0,425 625,900 900,1035 1035,1140 1140,1245
BINARY| and then I can
|然后我就可以调用它了。

977
00:26:34,410 --> 00:26:35,340
0,135 135,410
call it.|
|

978
00:26:35,500 --> 00:26:36,285
0,230 230,290 290,425 425,635 635,785
So if I change the
所以如果我再换一次大小写，

979
00:26:36,285 --> 00:26:37,875
0,285 285,575 1135,1380 1380,1470 1470,1590
casing again,| then I get
|我就会得到 Tupac 。

980
00:26:37,875 --> 00:26:38,840
0,395
Tupac.|
|

981
00:26:39,660 --> 00:26:40,550
0,260 260,425 425,725 725,800 800,890
So this burns a lot
这会让很多人感到痛苦，

982
00:26:40,550 --> 00:26:41,240
0,105 105,270 270,420 420,525 525,690
of people,| because they up,
|因为他们会想，

983
00:26:41,240 --> 00:26:42,400
0,150 150,270 270,405 405,680 760,1160
you end up like thinking,|
|

984
00:26:42,420 --> 00:26:44,645
0,400 870,1270 1680,1910 1910,2075 2075,2225
oh, if you don't know
哦，如果你不知道 varchar 不区分大小写，

985
00:26:44,645 --> 00:26:45,880
0,150 150,285 285,495 495,815 835,1235
that your {varchar -} is

986
00:26:45,930 --> 00:26:47,765
0,290 290,970 1140,1400 1400,1580 1580,1835
case insensitive,| you could store
|你可以多次存储东西，

987
00:26:47,765 --> 00:26:51,300
0,270 270,555 555,905
things multiple times,|
|

988
00:26:51,300 --> 00:26:52,455
0,105 105,350 430,765 765,945 945,1155
you know, thinking that it's
以为情况会不同，

989
00:26:52,455 --> 00:26:52,980
0,75 75,120 120,195 195,360 360,525
going to be different,| because
|因为大小写不同，

990
00:26:52,980 --> 00:26:54,225
0,105 105,225 225,360 360,620 940,1245
the case is different,| but
|但是 MySQL 说它们是一样的。

991
00:26:54,225 --> 00:26:55,350
0,180 180,375 375,635 685,1020 1020,1125
{MySQL -} says they're the

992
00:26:55,350 --> 00:26:56,320
0,260
same.|
|

993
00:26:56,580 --> 00:26:57,560
0,260 260,380 380,515 515,740 740,980
Again, this is only {MySQL
再说一次，这只是 MySQL ，

994
00:26:57,560 --> 00:26:58,370
0,240 240,315 315,465 465,600 600,810
-},| I don't know any
|我不知道有任何其他数据这样做，

995
00:26:58,370 --> 00:26:59,525
0,165 165,440 580,885 885,1035 1035,1155
other data that actually does

996
00:26:59,525 --> 00:27:01,070
0,275 805,1110 1110,1350 1350,1410 1410,1545
this,| so that's a weird
|所以这是一个奇怪的特性。

997
00:27:01,070 --> 00:27:01,980
0,290
one.|
|

998
00:27:03,020 --> 00:27:05,160
0,1000 1050,1355 1355,1535 1535,1775 1775,2140

999
00:27:06,750 --> 00:27:07,600
0,700

1000
00:27:07,940 --> 00:27:09,020
0,120 120,300 300,620

1001
00:27:11,240 --> 00:27:12,235
0,320 320,515 515,680 680,845 845,995
The question is, why is
问题是，为什么这个名字要大写？

1002
00:27:12,235 --> 00:27:17,180
0,180 180,485 955,1595
the name capitalized?|
|

1003
00:27:22,280 --> 00:27:24,420
0,335 335,530 530,695 695,1000
So his question is,|
所以他的问题是，|

1004
00:27:25,280 --> 00:27:27,205
0,410 410,590 590,910 990,1370 1370,1925
I'm telling you,| so there's
我告诉你，|数据是以区分大小写的方式存储的，

1005
00:27:27,205 --> 00:27:28,300
0,120 120,435 435,615 615,915 915,1095
the data being stored with

1006
00:27:28,300 --> 00:27:30,480
0,120 120,270 270,830 1360,1760 1780,2180
the case sensitivity,| the comparison
|比较运算符，当它实际使用 WHERE 子句时忽略了大小写，

1007
00:27:30,770 --> 00:27:32,140
0,350 350,545 545,710 710,1205 1205,1370
operator, when it {actually,executes} the

1008
00:27:32,140 --> 00:27:34,140
0,195 195,560 910,1200 1200,1635 1635,2000
WHERE clause is ignoring case,|
|

1009
00:27:36,130 --> 00:27:37,135
0,45 45,120 120,330 330,660 660,1005
so it's not calling whatever
所以它不会调用 libc 中的字符串比较，

1010
00:27:37,135 --> 00:27:39,010
0,330 330,695 1345,1620 1620,1755 1755,1875
string compare that you have

1011
00:27:39,010 --> 00:27:40,540
0,120 120,330 330,620
in {libc -},|
|

1012
00:27:40,550 --> 00:27:42,025
0,350 350,610 750,1100 1100,1310 1310,1475
it's calling either their own
它要么调用自己的版本，

1013
00:27:42,025 --> 00:27:42,990
0,225 225,405 405,540 540,690 690,965
version of it| or the
|或者大小写不敏感的版本，

1014
00:27:43,040 --> 00:27:44,005
0,275 275,410 410,650 650,770 770,965
case {insensitive - -} version

1015
00:27:44,005 --> 00:27:44,860
0,165 165,425
of it,|
|

1016
00:27:45,610 --> 00:27:46,635
0,260 260,395 395,530 530,755 755,1025
because that was some decision
因为这是 1990 年代某人做出一些决定，

1017
00:27:46,635 --> 00:27:47,460
0,180 180,375 375,600 600,750 750,825
that somebody made in the

1018
00:27:47,460 --> 00:27:49,080
0,150 150,620 850,1140 1140,1335 1335,1620
{1990s -},| that has carried
|至今仍在延续。

1019
00:27:49,080 --> 00:27:50,400
0,330 330,680
over today.|
|

1020
00:27:51,090 --> 00:27:53,160
0,400
Yes.|
好的。|

1021
00:27:53,170 --> 00:27:53,835
0,260 260,350 350,425 425,530 530,665
Why do they make that
他们为什么要做出这样的决定？

1022
00:27:53,835 --> 00:27:54,880
0,275
decision?|
|

1023
00:27:55,460 --> 00:27:57,940
0,400 1740,2030 2030,2165 2165,2300 2300,2480
{} Ask me that question
最后再问我那个问题，

1024
00:27:57,940 --> 00:27:59,065
0,120 120,210 210,390 390,710 850,1125
at the very end,| get
|从头到尾再说一遍，

1025
00:27:59,065 --> 00:28:01,540
0,120 120,225 225,485 1735,2115 2115,2475
through all the again,| it's
|这可能是因为有人只是以一种方式做了，

1026
00:28:01,540 --> 00:28:02,920
0,225 225,540 540,920 940,1230 1230,1380
probably because somebody just did

1027
00:28:02,920 --> 00:28:03,700
0,120 120,225 225,360 360,585 585,780
it the one way,| you
|决定了怎么做，

1028
00:28:03,700 --> 00:28:04,840
0,260 550,825 825,945 945,1035 1035,1140
know, decided how to do

1029
00:28:04,840 --> 00:28:07,105
0,260 640,1040 1480,1770 1770,2130 2130,2265
it,| or {MySQL -}, the
|或者 MySQL 在很多情况下试图效仿 Oracle 在某些情况下所做的事情，

1030
00:28:07,105 --> 00:28:08,170
0,165 165,485 565,795 795,900 900,1065
guy was actually in many

1031
00:28:08,170 --> 00:28:09,390
0,225 225,405 405,525 525,800 820,1220
cases trying to follow what

1032
00:28:09,440 --> 00:28:10,470
0,440 440,545 545,635 635,755 755,1030
Oracle did in some cases,|
|

1033
00:28:10,670 --> 00:28:11,730
0,245 245,455 455,680 680,800 800,1060
but Oracle doesn't do this,|
但是 Oracle 没有这么做，|

1034
00:28:12,140 --> 00:28:13,400
0,260 260,380 380,515 515,790
I have no idea,
我没有头绪，

1035
00:28:14,070 --> 00:28:15,185
0,395 395,650 650,815 815,995 995,1115
right,| we can email the
|我们可以给他还活着的人发邮件。

1036
00:28:15,185 --> 00:28:21,100
0,245 1255,1530 1530,1665 1665,1955
guy he still alive.|
|

1037
00:28:21,140 --> 00:28:22,330
0,275 275,470 470,635 635,875 875,1190
So yeah, I think there's
所以，是的，我认为很多时候，人们只是做一些事情，

1038
00:28:22,330 --> 00:28:23,250
0,75 75,210 210,360 360,570 570,920
a lot of times where

1039
00:28:24,080 --> 00:28:25,285
0,305 305,500 500,725 725,980 980,1205
people just did stuff,| because,
|因为，就像一个人做了事情，没有真正考虑它的含义，

1040
00:28:25,285 --> 00:28:26,185
0,255 255,480 480,660 660,810 810,900
like one person did it

1041
00:28:26,185 --> 00:28:27,325
0,150 150,345 345,615 615,885 885,1140
without really thinking through the,

1042
00:28:27,325 --> 00:28:30,100
0,240 240,630 630,795 795,1055 2455,2775
the implications of it,| or
|或者他们试图复制其他系统，

1043
00:28:30,100 --> 00:28:31,015
0,225 225,330 330,450 450,690 690,915
they're trying to copy some

1044
00:28:31,015 --> 00:28:31,705
0,150 150,345 345,480 480,570 570,690
other system,| where they like
|他们喜欢其他一些特定的功能。

1045
00:28:31,705 --> 00:28:33,775
0,165 165,285 285,515 1555,1875 1875,2070
out some other particular feature

1046
00:28:33,775 --> 00:28:34,940
0,120 120,725
of functionality.|
|

1047
00:28:39,330 --> 00:28:40,660
0,260 260,520
Other questions?|
还有其他问题吗？|

1048
00:28:42,340 --> 00:28:43,530
0,320 320,425 425,650 650,920 920,1190
We'll see many examples are
我们会看看很多例子，为什么有人会这样做。

1049
00:28:43,530 --> 00:28:44,670
0,240 240,530 610,855 855,990 990,1140
why would anyone ever do

1050
00:28:44,670 --> 00:28:46,160
0,260 760,1005 1005,1095 1095,1215 1215,1490
this, do it this way.|
|

1051
00:28:47,400 --> 00:28:48,255
0,195 195,390 390,600 600,735 735,855
All right, so I think
好的，我想我之前展示了一个类似这样的查询，

1052
00:28:48,255 --> 00:28:49,020
0,120 120,240 240,330 330,555 555,765
I showed a query like

1053
00:28:49,020 --> 00:28:49,935
0,120 120,380 400,675 675,810 810,915
this before,| just make sure
|只是确保你看到它。

1054
00:28:49,935 --> 00:28:50,940
0,120 120,240 240,485 565,825 825,1005
you see it.| So there's
|在 SQL 中有这样的 LIKE 操作，

1055
00:28:50,940 --> 00:28:53,760
0,150 150,470 1750,2145 2145,2535 2535,2820
this LIKE operation in in

1056
00:28:53,760 --> 00:28:55,020
0,440 520,780 780,915 915,1065 1065,1260
SQL| and you use this
|你可以使用它来进行基本字符串匹配或和模式匹配，

1057
00:28:55,020 --> 00:28:57,315
0,320 610,1010 1030,1640 1750,2025 2025,2295
for really primitive string matching

1058
00:28:57,315 --> 00:28:58,620
0,60 60,135 135,300 300,785
or and pattern matching,|
|

1059
00:28:58,750 --> 00:29:00,020
0,335 335,500 500,590 590,850 870,1270
so you would use a,
所以你调用 LIKE ，然后你说，

1060
00:29:00,070 --> 00:29:01,050
0,275 275,455 455,710 710,905 905,980
you call LIKE and then

1061
00:29:01,050 --> 00:29:02,900
0,60 60,180 180,470 550,950
you would say, {}|
|

1062
00:29:02,900 --> 00:29:04,360
0,60 60,135 135,240 240,500 1060,1460
you would have a percent
你可以有一个百分号来表示通配符，

1063
00:29:04,380 --> 00:29:05,390
0,320 320,470 470,620 620,800 800,1010
sign to represent a wild

1064
00:29:05,390 --> 00:29:06,335
0,300 300,525 525,705 705,840 840,945
card,| so instead, if you're
|如果你来自 Unix 世界，

1065
00:29:06,335 --> 00:29:07,720
0,90 90,365 595,855 855,1095 1095,1385
coming from the Unix world,|
|

1066
00:29:07,740 --> 00:29:09,670
0,400 750,1100 1100,1355 1355,1595 1595,1930
star regular expression usually means
星号正则表达式通常意味着匹配任何内容，或者点号，

1067
00:29:10,230 --> 00:29:12,340
0,380 380,755 755,1025 1025,1300
match anything or dot,|
|

1068
00:29:12,410 --> 00:29:14,500
0,305 305,650 650,1235 1235,1510 1740,2090
in SQL, it's the percent
在 SQL 中，它是百分号，

1069
00:29:14,500 --> 00:29:15,960
0,350 580,840 840,1050 1050,1170 1170,1460
sign,| and that'll match it
|可以匹配任何子字符串，包括空字符串，

1070
00:29:16,220 --> 00:29:18,430
0,320 320,560 560,880 1680,1970 1970,2210
any sub string, including empty

1071
00:29:18,430 --> 00:29:19,570
0,380 550,780 780,855 855,1005 1005,1140
strings,| but if you want
|但是如果你想匹配一个字符，你可以使用下划线，

1072
00:29:19,570 --> 00:29:20,920
0,75 75,240 240,450 450,740 1090,1350
to match one character, you

1073
00:29:20,920 --> 00:29:22,700
0,105 105,350 550,795 795,1340
would use the underscore,|
|

1074
00:29:22,740 --> 00:29:24,035
0,260 260,380 380,640 870,1160 1160,1295
and there is support for
而且还支持正则表达式，

1075
00:29:24,035 --> 00:29:25,415
0,240 240,735 735,1020 1020,1260 1260,1380
regular expressions,| I forget whether
|我忘记了这是否在 SQL 标准中，

1076
00:29:25,415 --> 00:29:27,080
0,245 925,1200 1200,1320 1320,1410 1410,1665
that is in the SQL

1077
00:29:27,080 --> 00:29:28,180
0,240 240,495 495,675 675,825 825,1100
standard,| but everyone does it
|但每个人的做法略有不同，

1078
00:29:28,230 --> 00:29:30,680
0,320 320,640 1590,1865 1865,2135 2135,2450
slightly different,| you can write
|你可以编写更复杂的字符串匹配模式。

1079
00:29:30,680 --> 00:29:33,680
0,320 370,770 1240,1500 1500,1940 2740,3000
more complex string matching, string

1080
00:29:33,680 --> 00:29:34,900
0,270 270,530
matching patterns.|
|

1081
00:29:36,040 --> 00:29:36,720
0,275 275,305 305,380 380,515 515,680
There's a bunch of string
在 SQL 标准中也有许多字符串函数，

1082
00:29:36,720 --> 00:29:37,560
0,240 240,495 495,660 660,765 765,840
functions that also come in

1083
00:29:37,560 --> 00:29:38,780
0,75 75,285 285,560 730,975 975,1220
the SQL standard| to do
|可以做你所期望的事情，

1084
00:29:38,830 --> 00:29:40,035
0,305 305,440 440,605 605,940 960,1205
things you could expect,| if
|如果你熟悉 Python ，

1085
00:29:40,035 --> 00:29:41,085
0,150 150,270 270,420 420,765 765,1050
you're familiar with Python,| there's
|那么所有的 Python 函数，

1086
00:29:41,085 --> 00:29:43,635
0,165 165,285 285,540 540,815 2185,2550
all the python functions,| upper
|大写字母，小写字母，子字符串，替换字符串，

1087
00:29:43,635 --> 00:29:45,200
0,150 150,390 390,725 895,1215 1215,1565
case, lower case, sub strings,

1088
00:29:45,550 --> 00:29:47,535
0,455 455,790 1290,1610 1610,1805 1805,1985
replacing strings,| all that, all
|所有这些都在 SQL 标准中，

1089
00:29:47,535 --> 00:29:48,410
0,225 225,300 300,390 390,615 615,875
that's in the SQL standard|
|

1090
00:29:48,760 --> 00:29:49,935
0,290 290,425 425,560 560,830 830,1175
and for the most part,|
而且在很大程度上，|

1091
00:29:49,935 --> 00:29:50,850
0,255 255,495 495,690 690,765 765,915
these are going to be
这些都将在各种系统中保持一致。

1092
00:29:50,850 --> 00:29:52,960
0,315 315,710 760,1110 1110,1460
pretty consistent across the

1093
00:29:53,480 --> 00:29:55,340
0,245 245,410 410,730
the various systems.|
|

1094
00:29:55,750 --> 00:29:57,890
0,275 275,470 470,790 1380,1760 1760,2140
Where things go wrong is,|
不一样的地方是，|

1095
00:29:57,940 --> 00:29:58,710
0,290 290,440 440,560 560,680 680,770
which we think would be
我们认为最简单的操作，连接两个字符串，

1096
00:29:58,710 --> 00:30:00,210
0,60 60,195 195,495 495,885 885,1500
the most simple operation, concatenating

1097
00:30:00,210 --> 00:30:01,875
0,210 210,530 910,1290 1290,1455 1455,1665
two strings,| that's where everyone
|这是每个人喜欢做一些略有不同的事情的地方。

1098
00:30:01,875 --> 00:30:02,775
0,150 150,255 255,360 360,615 615,900
likes to do something slightly

1099
00:30:02,775 --> 00:30:03,880
0,305
different.|
|

1100
00:30:03,880 --> 00:30:05,080
0,210 210,330 330,630 630,885 885,1200
So the SQL standard says,|
所以 SQL 标准说，|

1101
00:30:05,080 --> 00:30:08,110
0,350 1750,2010 2010,2175 2175,2480 2770,3030
the the double bar is
双竖线是连接字符串的方式，

1102
00:30:08,110 --> 00:30:08,755
0,90 90,180 180,300 300,435 435,645
the way you can concat

1103
00:30:08,755 --> 00:30:12,390
0,365 1885,2285 2635,3015 3015,3375 3375,3635
strings,| in in SQL Server,
|在 SQL Server 中，他们使用加号，

1104
00:30:12,410 --> 00:30:14,035
0,400 930,1190 1190,1325 1325,1460 1460,1625
they, they use the plus

1105
00:30:14,035 --> 00:30:15,000
0,305
sign,|
|

1106
00:30:15,790 --> 00:30:16,845
0,260 260,365 365,455 455,605 605,1055
and then in {MySQL -},
在 MySQL 中，他们在默认模式下没有，

1107
00:30:16,845 --> 00:30:20,390
0,365 865,1290 1290,1565 2605,3005 3145,3545
they don't have under the

1108
00:30:20,590 --> 00:30:21,585
0,275 275,470 470,650 650,875 875,995
default mode,| they don't have
|他们没有双竖线，他们不支持加号，

1109
00:30:21,585 --> 00:30:22,890
0,135 135,315 315,635 895,1140 1140,1305
the double bar, they don't

1110
00:30:22,890 --> 00:30:23,985
0,120 120,240 240,390 390,680 850,1095
support the plus sign,| you
|你必须使用 CONCAT 函数，

1111
00:30:23,985 --> 00:30:25,770
0,105 105,225 225,450 450,815 1345,1785
have to use the CONCAT

1112
00:30:25,770 --> 00:30:26,620
0,290
function,

1113
00:30:27,770 --> 00:30:28,645
0,395 395,635 635,710 710,785 785,875
right,| and we can see
|我们很快能看到这一点。

1114
00:30:28,645 --> 00:30:29,980
0,105 105,225 225,485
that real quickly.|
|

1115
00:30:30,430 --> 00:30:31,720
0,400
So,
所以，回到 MySQL ，

1116
00:30:31,730 --> 00:30:32,790
0,275 275,410 410,500 500,620 620,1060
going back to {MySQL -},|
|

1117
00:30:38,070 --> 00:30:40,060
0,400
so,
所以，想要做这样的事情，

1118
00:30:42,220 --> 00:30:42,825
0,245 245,305 305,380 380,485 485,605
want to do something like

1119
00:30:42,825 --> 00:30:44,220
0,275 295,695
this, right,|
|

1120
00:30:44,780 --> 00:30:45,985
0,245 245,350 350,515 515,820 930,1205
I get another warning,| I
我又得到了一个警告，|我显示警告，

1121
00:30:45,985 --> 00:30:47,580
0,150 150,575
show warnings,|
|

1122
00:30:50,750 --> 00:30:51,625
0,215 215,290 290,440 440,680 680,875
and it tells me it
它告诉我它不喜欢我的语法，

1123
00:30:51,625 --> 00:30:52,800
0,165 165,255 255,375 375,755 775,1175
doesn't like my syntax, right,|
|

1124
00:30:54,960 --> 00:30:56,200
0,400 480,725 725,815 815,950 950,1240
that was the first {one\,,sorry},|
这是第一个，抱歉，|

1125
00:30:56,940 --> 00:30:58,140
0,400
boom,
我收到了两个警告，

1126
00:30:58,140 --> 00:30:59,700
0,225 225,360 360,525 525,920 1180,1560
I get two warnings,| says
|说双竖线是 OR 的同义词，因此它将被弃用，

1127
00:30:59,700 --> 00:31:01,650
0,375 375,735 735,1050 1050,1400 1420,1950
the double bar is synonym

1128
00:31:01,650 --> 00:31:03,000
0,225 225,360 360,620 910,1215 1215,1350
for the OR, and therefore

1129
00:31:03,000 --> 00:31:05,580
0,255 255,465 465,555 555,1040
it's to be deprecated,|
|

1130
00:31:05,580 --> 00:31:06,300
0,105 105,210 330,435 435,570 570,720
and they didn't like the
他们不喜欢我的方式，

1131
00:31:06,300 --> 00:31:08,560
0,210 210,560
way,| I
|我发送的 @cs ，

1132
00:31:08,980 --> 00:31:11,010
0,400 690,1010 1010,1330 1620,1865 1865,2030
was sending along the {@cs

1133
00:31:11,010 --> 00:31:13,590
0,210 210,420 420,830 1360,1760 2320,2580
- - -},| so we
|所以我们现在尝试调用，

1134
00:31:13,590 --> 00:31:14,775
0,210 210,420 420,555 555,830 910,1185
now try to call,| we
|我们修改 MySQL 的 sql_mode ，

1135
00:31:14,775 --> 00:31:16,335
0,210 210,420 420,705 705,965 1315,1560
change the {sql_mode -} in

1136
00:31:16,335 --> 00:31:17,580
0,135 135,545
{MySQL -},|
|

1137
00:31:17,580 --> 00:31:19,460
0,255 255,435 435,740 1240,1620 1620,1880
to follow the sql standard,|
为了遵循 SQL 标准，|

1138
00:31:19,780 --> 00:31:21,510
0,365 365,605 605,880 1350,1610 1610,1730
now I can, I can
现在我可以得到我想要的连接。

1139
00:31:21,510 --> 00:31:22,710
0,260 310,555 555,975 975,1110 1110,1200
get the concatenation that I

1140
00:31:22,710 --> 00:31:23,460
0,260
want.|
|

1141
00:31:23,690 --> 00:31:24,880
0,400

1142
00:31:26,110 --> 00:31:28,035
0,245 245,455 455,940 1020,1690 1710,1925
So again, it's concatenation,| it
所以再说一次，它是连接，|它非常（多），每个系统都应该做同样的事情，

1143
00:31:28,035 --> 00:31:30,525
0,75 75,315 315,695 2125,2385 2385,2490
would be super, everyone should

1144
00:31:30,525 --> 00:31:31,275
0,90 90,180 180,315 315,540 540,750
do the same thing,| but
|但又一次，在 MySQL 的情况下，

1145
00:31:31,275 --> 00:31:33,405
0,275 1375,1620 1620,1710 1710,1800 1800,2130
again, in case of MySQL,|
|

1146
00:31:33,405 --> 00:31:34,605
0,90 90,365 445,840 840,1095 1095,1200
is some legacy thing from
是 90 年代遗留下来的东西，

1147
00:31:34,605 --> 00:31:35,745
0,90 90,210 210,375 375,665 835,1140
the {90s -},| that they're
|他们试图慢慢撤销。

1148
00:31:35,745 --> 00:31:37,240
0,105 105,270 270,495 495,965
trying to slowly undo.|
|

1149
00:31:39,150 --> 00:31:40,240
0,230 230,460
All right,
好的，日期和时间可能是最糟糕的。

1150
00:31:40,540 --> 00:31:41,870
0,275 275,410 410,670 720,1025 1025,1330
date and time is probably

1151
00:31:42,190 --> 00:31:43,660
0,260 260,425 425,730
the worst one.|
|

1152
00:31:43,660 --> 00:31:45,400
0,350 730,1005 1005,1290 1290,1440 1440,1740
So the SQL standard defines
SQL 标准定义了一系列方法，

1153
00:31:45,400 --> 00:31:46,225
0,150 150,240 240,345 345,555 555,825
a bunch of ways| to
|定义日期类型、时间类型以及时间戳，

1154
00:31:46,225 --> 00:31:49,350
0,305 1435,1755 1755,2075 2455,2790 2790,3125
define date types, time types,

1155
00:31:50,180 --> 00:31:52,600
0,275 275,550 1230,1840
also {timestamps -},|
|

1156
00:31:52,600 --> 00:31:54,655
0,290 610,945 945,1275 1275,1635 1635,2055
{} different calendar types, Julian
不同的日历类型，儒略历，格里高利历，

1157
00:31:54,655 --> 00:31:57,250
0,915 915,1175 1795,2085 2085,2325 2325,2595
{calendar\,,Gregorian} calendar,| but how, again,
|但是，再一次，语法如何变化，是相当恼人的。

1158
00:31:57,250 --> 00:31:59,395
0,320 1240,1515 1515,1860 1860,2025 2025,2145
how the syntax is going

1159
00:31:59,395 --> 00:32:00,460
0,105 105,365 625,900 900,1005 1005,1065
to vary, is going to

1160
00:32:00,460 --> 00:32:02,220
0,230 460,765 765,1220
be pretty annoying.|
|

1161
00:32:02,220 --> 00:32:02,685
0,165 165,225 225,300 300,375 375,465
So I want to give
所以我现在想给它一个 demo ，

1162
00:32:02,685 --> 00:32:03,710
0,90 90,195 195,315 315,575 625,1025
it now a demo,| where
|试着做一个看起来很简单的计算，

1163
00:32:04,450 --> 00:32:05,760
0,245 245,320 320,395 395,640 990,1310
try to do what would

1164
00:32:05,760 --> 00:32:07,650
0,210 210,345 345,450 450,710 1360,1890
seem like a simple calculation,

1165
00:32:07,650 --> 00:32:09,240
0,150 150,315 315,830 1240,1485 1485,1590
a simple computation,| we just
|我们只想数一数天数，

1166
00:32:09,240 --> 00:32:10,100
0,90 90,195 195,390 390,585 585,860
want to count the number

1167
00:32:10,120 --> 00:32:11,480
0,400
days,|
|

1168
00:32:11,550 --> 00:32:13,355
0,400 630,950 950,1270 1440,1685 1685,1805
since from today to the
从今天起到年初，

1169
00:32:13,355 --> 00:32:14,560
0,165 165,300 300,405 405,665
beginning of the year,|
|

1170
00:32:14,740 --> 00:32:16,830
0,290 290,425 425,1490 1490,1715 1715,2090
it's like 230 something, 240
好像是 230 天， 240 天，

1171
00:32:16,830 --> 00:32:18,240
0,290 430,690 690,810 810,1065 1065,1410
something,| just the number, the
|只是天数，日历上的总天数。

1172
00:32:18,240 --> 00:32:19,610
0,255 255,480 480,720 720,1005 1005,1370
total number of calendar days.|
|

1173
00:32:20,390 --> 00:32:20,950
0,230 230,365 365,395 395,455 455,560
So we're going to do
我们将首先在 Postgres 中执行此操作，

1174
00:32:20,950 --> 00:32:22,885
0,165 165,450 450,765 765,1310 1690,1935
this first in Postgres| and
|然后在 MySQL 中执行此操作，

1175
00:32:22,885 --> 00:32:23,760
0,90 90,225 225,330 330,540 540,875
then we'll do this in,

1176
00:32:24,590 --> 00:32:26,365
0,400 660,950 950,1390 1410,1655 1655,1775
in {MySQL -}| and do
|然后在 SQL Server 中执行此操作。

1177
00:32:26,365 --> 00:32:27,630
0,180 180,435 435,705 705,990 990,1265
this in, in SQL Server.|
|

1178
00:32:28,420 --> 00:32:29,130
0,245 245,350 350,485 485,620 620,710
So the first thing we
所以，我们需要做的第一件事是

1179
00:32:29,130 --> 00:32:29,685
0,75 75,180 180,300 300,420 420,555
need to do is figure

1180
00:32:29,685 --> 00:32:30,420
0,120 120,225 225,345 345,525 525,735
out| how to get the
|如何获得当前日期，当前时间。

1181
00:32:30,420 --> 00:32:31,360
0,290
current,

1182
00:32:31,360 --> 00:32:33,760
0,380 670,930 930,1190 1300,1700
date, the current time,

1183
00:32:33,760 --> 00:32:37,390
0,320 910,1290 1290,1790 2110,2510 3040,3630
right.| Well, there's in Postgres,
|好的，在 Postgres 中有一个名为 NOW 的函数，

1184
00:32:37,390 --> 00:32:38,520
0,300 300,390 390,600 600,840 840,1130
there's a function called NOW,|
|

1185
00:32:39,260 --> 00:32:40,090
0,195 195,300 300,420 420,555 555,830
and that will give you,
这会给你一个时间戳以及当前日期，

1186
00:32:42,410 --> 00:32:43,165
0,245 245,350 350,470 470,590 590,755
you get back a {timestamp

1187
00:32:43,165 --> 00:32:44,100
0,305
-}

1188
00:32:44,100 --> 00:32:45,320
0,105 105,195 195,315 315,590
with the current date,|
|

1189
00:32:45,410 --> 00:32:47,040
0,400
in,
在 MySQL 中，你可以做同样的事情，

1190
00:32:49,530 --> 00:32:50,540
0,335 335,560 560,815 815,935 935,1010
in {MySQL -}, you can

1191
00:32:50,540 --> 00:32:51,920
0,75 75,165 165,300 300,590
do the same thing,|
|

1192
00:32:51,920 --> 00:32:53,460
0,240 240,540 540,800
in {SQLite -},
在 SQLite 中，他们没有 NOW 函数，

1193
00:32:54,890 --> 00:32:55,585
0,245 245,395 395,455 455,545 545,695
they don't have a NOW

1194
00:32:55,585 --> 00:32:56,720
0,305
function,|
|

1195
00:32:56,840 --> 00:32:58,660
0,380 380,880 1290,1655 1655,1745 1745,1820
in DuckDB, DuckDB is going
在 DuckDB 中， DuckDB 在很多方面几乎都会遵循 Postgres ，

1196
00:32:58,660 --> 00:33:00,240
0,105 105,330 330,540 540,800 970,1580
to follow pretty much Postgres

1197
00:33:00,380 --> 00:33:01,015
0,230 230,290 290,380 380,485 485,635
for a lot of things,|
|

1198
00:33:01,015 --> 00:33:01,960
0,165 165,480 480,690 690,810 810,945
because it's they use the
因为它们使用相同的 SQL 语法，

1199
00:33:01,960 --> 00:33:04,860
0,260 1090,1490 1570,1935 1935,2360
same same SQL grammar,|
|

1200
00:33:04,900 --> 00:33:05,550
0,245 245,335 335,410 410,485 485,650
so they have a NOW
所以它们有 NOW 函数，

1201
00:33:05,550 --> 00:33:06,620
0,290
function,|
|

1202
00:33:07,000 --> 00:33:08,740
0,275 275,395 395,485 485,970
I go to Oracle,|
我切换到 Oracle ，|

1203
00:33:09,970 --> 00:33:10,905
0,335 335,545 545,710 710,845 845,935
Oracle does not have a
Oracle 没有 NOW 函数。

1204
00:33:10,905 --> 00:33:11,960
0,120 120,395
NOW function.|
|

1205
00:33:12,200 --> 00:33:13,180
0,230 230,380 380,605 605,830 830,980
All right, so there's another
好的，还有另一种方法可以得到时间戳，

1206
00:33:13,180 --> 00:33:13,915
0,120 120,195 195,285 285,510 510,735
way you can get the

1207
00:33:13,915 --> 00:33:14,845
0,150 150,435 435,675 675,795 795,930
{timestamp -},| so in the
|在 SQL 标准中，

1208
00:33:14,845 --> 00:33:16,650
0,255 255,545 895,1320 1320,1485 1485,1805
sql standard,| there's something called,
|有一个叫做 CURRENT_TIMESTAMP 的函数，

1209
00:33:17,840 --> 00:33:18,895
0,245 245,410 410,635 635,845 845,1055
a function called {CURRENT_TIMESTAMP -

1210
00:33:18,895 --> 00:33:19,720
0,305
-},

1211
00:33:20,660 --> 00:33:21,910
0,400 660,905 905,1055 1055,1145 1145,1250
right,| except it's not a
|只是它不是一个函数，它是个关键词，

1212
00:33:21,910 --> 00:33:23,220
0,260
function,

1213
00:33:23,385 --> 00:33:24,900
0,60 60,150 150,545
it's a keyword,|
|

1214
00:33:25,620 --> 00:33:27,130
0,260 260,485 485,830 830,1085 1085,1510
and then in {MySQL -},
然后在 MySQL 中，它们有这个函数，它们有这个关键字，

1215
00:33:27,930 --> 00:33:30,185
0,260 260,365 365,470 470,730 2010,2255
they have the function, they

1216
00:33:30,185 --> 00:33:32,300
0,105 105,225 225,605
have the keyword,|
|

1217
00:33:32,300 --> 00:33:33,960
0,225 225,770
in SQLite,
在 SQLite 中，他们没有这个函数，他们有这个关键词，

1218
00:33:35,400 --> 00:33:35,930
0,60 60,120 120,195 195,285 285,530
they don't have the function,

1219
00:33:38,210 --> 00:33:39,840
0,245 245,350 350,455 455,850
they have the keyword,|
|

1220
00:33:39,840 --> 00:33:41,520
0,210 210,390 390,890
and on Oracle,
在 Oracle 中，没有，

1221
00:33:42,770 --> 00:33:43,880
0,520
doesn't,|
|

1222
00:33:43,880 --> 00:33:44,800
0,240 240,345 345,450 450,615 615,920
gives us a weird error
给了我们一个奇怪的错误，

1223
00:33:45,180 --> 00:33:45,890
0,275 275,440 440,545 545,650 650,710
about that one,| we'll come
|我们一会儿回来，

1224
00:33:45,890 --> 00:33:46,250
0,90 90,180 180,240 240,285 285,360
back to that in a

1225
00:33:46,250 --> 00:33:48,290
0,260 760,1160 1660,1875 1875,1995 1995,2040
second| and they don't have
|他们没有关键词，

1226
00:33:48,290 --> 00:33:48,875
0,75 75,315 315,420 420,495 495,585
the keyword,| so they have
|所以他们有这个函数，但我们得到了一个奇怪的错误，

1227
00:33:48,875 --> 00:33:49,870
0,120 120,390 390,645 645,780 780,995
the function, but we're getting

1228
00:33:49,890 --> 00:33:51,425
0,260 260,425 425,620 620,910 1200,1535
this other weird error,| {datetime
|日期时间，间隔精度超出范围，

1229
00:33:51,425 --> 00:33:53,285
0,255 255,690 690,1145 1495,1755 1755,1860
-} interval precision out of

1230
00:33:53,285 --> 00:33:54,180
0,245
range.|
|

1231
00:33:54,250 --> 00:33:56,895
0,305 305,440 440,590 590,820 2400,2645
Okay, so what's that,| So
好的，那是什么，|所以现在我们可能得回去，

1232
00:33:56,895 --> 00:33:57,360
0,90 90,180 180,255 255,330 330,465
now we got to go

1233
00:33:57,360 --> 00:33:59,460
0,290 730,1130
back, maybe,|
|

1234
00:33:59,470 --> 00:34:00,945
0,305 305,575 575,905 905,1175 1175,1475
oh, because it's, it's, it's
哦，因为它是 Oracle ，

1235
00:34:00,945 --> 00:34:02,510
0,455 625,885 885,1125 1125,1275 1275,1565
Oracle,| It doesn't like having
|它没有没有 FROM 子句的 SELECT 语句，

1236
00:34:02,530 --> 00:34:03,710
0,305 305,485 485,680 680,875 875,1180
a SELECT clause without, a

1237
00:34:03,940 --> 00:34:05,150
0,305 305,560 560,755 755,890 890,1210
SELECT statement {without,a} FROM clause,|
|

1238
00:34:05,530 --> 00:34:06,315
0,230 230,380 380,470 470,605 605,785
so let's add our fake
所以让我们添加我们的假表 DUAL ，

1239
00:34:06,315 --> 00:34:09,165
0,305 325,875 2365,2625 2625,2730 2730,2850
table DUAL,| then, we get
|然后我们就正确了，

1240
00:34:09,165 --> 00:34:10,740
0,275 595,995 1105,1335 1380,1455 1455,1575
it right,| but it's the
|但它是关键字，而不是时间戳。

1241
00:34:10,740 --> 00:34:12,040
0,440
keyword,

1242
00:34:12,550 --> 00:34:13,460
0,230 230,335 335,455 455,605 605,910
and not the {timestamp -},

1243
00:34:13,780 --> 00:34:14,960
0,400
right.|
|

1244
00:34:15,030 --> 00:34:16,235
0,230 230,365 365,530 530,790 960,1205
All right, so now, so
好了，至少现在我们可以得到当天的当前时间了，

1245
00:34:16,235 --> 00:34:16,895
0,90 90,240 240,435 435,570 570,660
at least now we can

1246
00:34:16,895 --> 00:34:19,475
0,120 120,395 685,1020 1020,1355 2305,2580
get the current time of

1247
00:34:19,475 --> 00:34:21,560
0,120 120,270 270,575
the current day,|
|

1248
00:34:21,560 --> 00:34:22,130
0,120 120,255 255,390 390,480 480,570
and so what we can
现在我们可以做的是，

1249
00:34:22,130 --> 00:34:23,465
0,120 120,240 240,495 495,950 1090,1335
do is now,| there we
|我们可以开始将字符串或变量转换为日期类型，

1250
00:34:23,465 --> 00:34:25,625
0,135 135,420 420,1085 1465,1890 1890,2160
can start casting strings or

1251
00:34:25,625 --> 00:34:27,740
0,420 420,785 805,1110 1110,1415 1825,2115
varchars into date types,| and
|然后在 SQL 标准中有这个 EXTRACT 函数，

1252
00:34:27,740 --> 00:34:28,880
0,165 165,360 360,585 585,900 900,1140
then there's this EXTRACT function

1253
00:34:28,880 --> 00:34:29,720
0,150 150,240 240,495 495,675 675,840
in the SQL standard,| that
|它允许我们提取数据时间戳的一部分，

1254
00:34:29,720 --> 00:34:31,100
0,180 180,375 375,570 570,890 1060,1380
allows us to extract some

1255
00:34:31,100 --> 00:34:32,630
0,270 270,600 600,870 870,1160 1210,1530
part of of that data

1256
00:34:32,630 --> 00:34:33,740
0,225 225,530 670,900 900,990 990,1110
{timestamp -},| so this is
|这就是，先提取日期，

1257
00:34:33,740 --> 00:34:36,245
0,225 225,555 555,920 1960,2235 2235,2505
saying extract {the,day,from}| and then
|然后将今天的日期作为字符串转换为日期类型。

1258
00:34:36,245 --> 00:34:38,090
0,465 465,725 1135,1410 1410,1590 1590,1845
today's date as a string

1259
00:34:38,090 --> 00:34:40,960
0,465 465,740 2140,2400 2400,2565 2565,2870
casted into a date type.|
|

1260
00:34:41,570 --> 00:34:43,460
0,260 260,520 570,845 845,1120
All right, and again,
好的，再次，这些不同的系统有语法糖，

1261
00:34:43,530 --> 00:34:45,050
0,485 485,1025 1025,1265 1265,1430 1430,1520
there's syntactic sugar for all

1262
00:34:45,050 --> 00:34:46,115
0,120 120,330 330,645 645,915 915,1065
these different systems,| that that
|它们是非标准的。

1263
00:34:46,115 --> 00:34:47,660
0,90 90,210 210,450 450,815 1195,1545
are like non standard.| So
|在 Postgres 中，

1264
00:34:47,660 --> 00:34:49,535
0,350 370,1040 1300,1560 1560,1710 1710,1875
in Postgres,| if I try
|如果我试图给出字符串，它会抛出一个错误，

1265
00:34:49,535 --> 00:34:50,720
0,180 180,360 360,540 540,845 865,1185
to give the string, it's

1266
00:34:50,720 --> 00:34:51,245
0,60 60,150 150,270 270,360 360,525
going to throw an error,|
|

1267
00:34:51,245 --> 00:34:52,175
0,180 180,285 285,405 405,540 540,930
because it says it can't,|
因为它说它不能，|

1268
00:34:52,175 --> 00:34:53,630
0,210 210,315 315,495 495,815 1195,1455
I need to operate, {the,extract,function}
EXTRACT 函数需要要在日期上操作，

1269
00:34:53,630 --> 00:34:54,260
0,90 90,180 180,330 330,495 495,630
{} need to operate on

1270
00:34:54,260 --> 00:34:54,935
0,105 105,270 270,420 420,555 555,675
a date,| but you're giving
|但你给了一个 varchar ，

1271
00:34:54,935 --> 00:34:56,435
0,210 210,375 375,540 540,845 1255,1500
me a {varchar -},| but
|但我可以把这两个冒号加在最后，

1272
00:34:56,435 --> 00:34:57,245
0,90 90,180 180,315 315,540 540,810
I can add these the

1273
00:34:57,245 --> 00:34:58,270
0,240 240,540 540,660 660,780 780,1025
two colons at the end|
|

1274
00:34:58,740 --> 00:34:59,660
0,245 245,380 380,575 575,770 770,920
and then put date at
然后把 date 放在最后，

1275
00:34:59,660 --> 00:35:00,600
0,105 105,350
the end,|
|

1276
00:35:00,600 --> 00:35:01,335
0,150 150,270 270,480 480,555 555,735
and then that's going to
然后，这将把它转换为日期类型。

1277
00:35:01,335 --> 00:35:04,170
0,255 255,465 465,755 1195,1595 2545,2835
cast it to a DATE

1278
00:35:04,170 --> 00:35:05,320
0,290
type.|
|

1279
00:35:05,320 --> 00:35:05,815
0,120 120,210 210,300 300,390 390,495
Can you see that or
你能看到这吗，抱歉，

1280
00:35:05,815 --> 00:35:06,880
0,150 150,455
no, sorry,|
|

1281
00:35:07,250 --> 00:35:08,400
0,400

1282
00:35:10,810 --> 00:35:12,140
0,395 395,790

1283
00:35:14,060 --> 00:35:15,840
0,180 180,300 300,560 910,1310
{let,me} do this, yeah,|
让我这么做，是的，|

1284
00:35:18,090 --> 00:35:18,890
0,245 245,305 305,410 410,530 530,800
I know it's wrong, sorry,
我知道这是不对的，抱歉，让我们再试一次。

1285
00:35:18,890 --> 00:35:20,160
0,270 270,330 330,405 405,650
let's try it again.|
|

1286
00:35:22,690 --> 00:35:24,340
0,260 260,470 470,740 740,1060
All right, so here
好了，这就是了。|

1287
00:35:25,710 --> 00:35:26,465
0,275 275,410 410,530 530,620 620,755
I can give it a
我可以给它一个字符串，

1288
00:35:26,465 --> 00:35:27,530
0,305 415,675 675,780 780,885 885,1065
string| and then I put
|然后我放上 ::date ，

1289
00:35:27,530 --> 00:35:29,000
0,270 270,615 615,1005 1005,1260 1260,1470
{::date - -}| and that
|这就把它转换成了日期，

1290
00:35:29,000 --> 00:35:30,790
0,255 255,375 375,650 1270,1530 1530,1790
converts it to a date,|
|

1291
00:35:31,170 --> 00:35:33,880
0,245 245,470 470,725 725,1120
but that's only in,
但这只是在 Postgres 中，

1292
00:35:33,970 --> 00:35:35,900
0,350 350,910
in Postgres,|
|

1293
00:35:35,940 --> 00:35:37,090
0,275 275,515 515,620 620,815 815,1150
I can't do this in
我不能在任何其他系统中这样做，除了 DuckDB ，

1294
00:35:37,320 --> 00:35:38,885
0,290 290,500 500,820 1230,1475 1475,1565
any other system, except for

1295
00:35:38,885 --> 00:35:40,100
0,120 120,450 450,765 765,1035 1035,1215
{DuckDB -},| because they follow
|因为它们遵循相同的标准。

1296
00:35:40,100 --> 00:35:41,630
0,150 150,315 315,620 1030,1365 1365,1530
the same standard, right.| So
|所以如果我去 MySQL ，

1297
00:35:41,630 --> 00:35:43,120
0,60 60,165 165,440
if I go

1298
00:35:43,130 --> 00:35:44,095
0,245 245,365 365,725 725,905 905,965
to {MySQL -},| try to
|尝试做同样的事情，

1299
00:35:44,095 --> 00:35:45,535
0,60 60,165 165,300 300,575 1105,1440
do the same thing,| doesn't
|不像那样。

1300
00:35:45,535 --> 00:35:47,250
0,135 135,425 865,1140 1140,1275 1275,1715
like that.| Go to SQLite,
|去 SQLite ，不像那样。

1301
00:35:47,810 --> 00:35:49,825
0,365 365,485 485,760 1680,1925 1925,2015
doesn't like that.| Go to
|去 Oracle ，不像那样。

1302
00:35:49,825 --> 00:35:50,920
0,120 120,420 420,615 615,795 795,1095
{DuckDB -}, { -} Oracle

1303
00:35:50,920 --> 00:35:51,570
0,75 75,165 165,240 240,360 360,650
is not going like that,|
|

1304
00:35:51,920 --> 00:35:53,320
0,305 305,730
FROM DUAL,|
FROM DUAL ，|

1305
00:35:55,030 --> 00:35:55,710
0,320 320,380 380,455 455,545 545,680
doesn't know what a DATE
不知道 DATE 是什么。

1306
00:35:55,710 --> 00:35:58,460
0,290 520,920 1450,1680 1680,1910 2230,2750
is.| {} And this DuckDB
|这个 DuckDB 应该这样做，

1307
00:35:58,480 --> 00:36:00,750
0,260 260,380 380,640 1200,1600 1860,2270
should do it,| because DuckDB
|因为 DuckDB 遵循相同的语法。

1308
00:36:00,750 --> 00:36:02,565
0,225 225,360 360,480 480,890 1570,1815
follows the same grammar.| So
|所以我们可以使用 EXTRACT 函数来提取当前日期，

1309
00:36:02,565 --> 00:36:03,510
0,75 75,150 150,285 285,575 625,945
we can use EXTRACT function

1310
00:36:03,510 --> 00:36:05,030
0,150 150,375 375,675 675,980 1120,1520
to maybe extract what the,

1311
00:36:05,960 --> 00:36:07,040
0,320
the

1312
00:36:07,860 --> 00:36:09,185
0,320 320,545 545,770 770,1085 1085,1325
current date is,| or try
|或者试着计算出从现在到年初有多少天。

1313
00:36:09,185 --> 00:36:09,830
0,90 90,180 180,360 360,525 525,645
to figure out how many

1314
00:36:09,830 --> 00:36:11,770
0,195 195,500 1030,1290 1290,1545 1545,1940
days since from now until

1315
00:36:11,940 --> 00:36:13,250
0,260 260,365 365,455 455,700 1080,1310
beginning of the year.| So
|那么让我们从 Postgres 开始吧，

1316
00:36:13,250 --> 00:36:14,800
0,165 165,255 255,375 375,830
let's start with postgres,|
|

1317
00:36:15,690 --> 00:36:16,550
0,260 260,365 365,500 500,680 680,860
so it turns out, it's
所以事实证明， Postgres 的情况很简单，

1318
00:36:16,550 --> 00:36:19,260
0,120 120,410 1330,1590 1590,2030
pretty simple with Postgres,|
|

1319
00:36:19,790 --> 00:36:20,880
0,350 350,545 545,635 635,785 785,1090
so we can just cast
我们可以将今天的当前日期字符串转换为日期类型

1320
00:36:21,050 --> 00:36:22,640
0,290 290,580
the string

1321
00:36:22,890 --> 00:36:24,220
0,400 450,725 725,860 860,1025 1025,1330
of {today's -} current date

1322
00:36:25,330 --> 00:36:28,230
0,400 1320,1565 1565,1715 1715,2020 2640,2900
to a DATE type| and
|然后减去年初时的日期字符串，

1323
00:36:28,230 --> 00:36:29,740
0,135 135,585 585,920
then subtract it

1324
00:36:29,740 --> 00:36:30,880
0,270 270,540 540,750 750,960 960,1140
from the string of the

1325
00:36:30,880 --> 00:36:31,880
0,290
current,

1326
00:36:31,920 --> 00:36:33,200
0,400
{}

1327
00:36:33,990 --> 00:36:34,900
0,305 305,485 485,590 590,665 665,910
the beginning of the year|
|

1328
00:36:35,070 --> 00:36:37,145
0,275 275,395 395,500 500,760 1830,2075
and we could use, we
我们可以使用，我们想要，我们可以回到这里，

1329
00:36:37,145 --> 00:36:37,820
0,150 150,330 330,450 450,540 540,675
wanted to, we could go

1330
00:36:37,820 --> 00:36:38,825
0,210 210,450 450,615 615,780 780,1005
back here| and use {CURRENT_TIMESTAMP
|使用 CURRENT_TIMESTAMP 或使用 NOW 函数，

1331
00:36:38,825 --> 00:36:40,265
0,210 210,515 595,990 990,1275 1275,1440
- -} or maybe use

1332
00:36:40,265 --> 00:36:41,560
0,120 120,285 285,605
the NOW function,|
|

1333
00:36:42,060 --> 00:36:43,520
0,245 245,350 350,470 470,730
and this should work,
这应该会工作。

1334
00:36:43,640 --> 00:36:44,680
0,400
right.|
|

1335
00:36:44,680 --> 00:36:47,050
0,290 310,600 600,795 795,1100 2080,2370
So that gets today, cast
所以获取今天，把它转换成日期，减去，

1336
00:36:47,050 --> 00:36:48,660
0,135 135,240 240,360 360,620 850,1610
it as a date, subtracting,|
|

1337
00:36:49,940 --> 00:36:51,505
0,305 305,470 470,695 695,940 1290,1565
taking the today's date and
获取今天的日期，然后减去年初的。

1338
00:36:51,505 --> 00:36:52,720
0,420 420,690 690,960 960,1110 1110,1215
subtracting by the beginning of

1339
00:36:52,720 --> 00:36:53,560
0,75 75,320 370,615 615,705 705,840
the year.| And we get
|我们得到 241 ，我认为这是正确的。

1340
00:36:53,830 --> 00:36:55,360
0,720 720,945 945,1155 1155,1365 1365,1530
241, which I assume is

1341
00:36:55,360 --> 00:36:56,160
0,320
correct.|
|

1342
00:36:58,490 --> 00:36:59,105
0,60 60,165 165,315 315,450 450,615
So let's try the same
现在让我们来尝试同样的事情，在 MySQL 中，

1343
00:36:59,105 --> 00:37:01,560
0,210 210,515 535,935
thing now in,

1344
00:37:02,330 --> 00:37:04,240
0,400 510,785 785,1180
in {MySQL -},|
|

1345
00:37:04,500 --> 00:37:05,840
0,245 245,490 840,1100 1100,1205 1205,1340
so again, since they don't
因为它们没有 NOW 函数，

1346
00:37:05,840 --> 00:37:06,845
0,90 90,240 240,495 495,765 765,1005
have the NOW function,| we'll
|所以我们将在转换时这样做，

1347
00:37:06,845 --> 00:37:09,080
0,105 105,365 745,1020 1020,1505
do it for casting,|
|

1348
00:37:09,330 --> 00:37:09,980
0,245 245,350 350,455 455,545 545,650
so now we get a
现在我们得到了一个奇怪的数字，我们得到了 729 ，

1349
00:37:09,980 --> 00:37:10,775
0,150 150,315 315,435 435,585 585,795
weird number, we get {729

1350
00:37:10,775 --> 00:37:12,580
0,210 210,515
- -},|
|

1351
00:37:13,660 --> 00:37:14,560
0,60 60,290
what's that,|
那是什么，|

1352
00:37:16,100 --> 00:37:17,305
0,305 305,710 710,860 860,1025 1025,1205
and surprisingly, actually,| somebody on
令人惊讶的是，| YouTube 上的一个人在[]地方的评论中，

1353
00:37:17,305 --> 00:37:18,940
0,275 775,1020 1020,1155 1155,1410 1410,1635
Youtube in a comment of

1354
00:37:18,940 --> 00:37:20,680
0,135 135,410 1300,1545 1545,1650 1650,1740
[] places,| told me what
|告诉了我这是什么，

1355
00:37:20,680 --> 00:37:22,945
0,75 75,320 1750,2010 2010,2130 2130,2265
it was,| and this is
|这很奇怪，

1356
00:37:22,945 --> 00:37:24,090
0,195 195,360 360,510 510,780 780,1145
weird,| so the first number
|所以第一个数字是今天的当月减去一月，

1357
00:37:24,470 --> 00:37:27,850
0,400 1290,1760 1760,1955 1955,2290 2760,3380
is today's current month subtracted

1358
00:37:27,850 --> 00:37:30,210
0,260 280,680 1060,1365 1365,1670 1960,2360
by January,| so 8 minus
|所以 8 减 1 等于 7 ，

1359
00:37:30,290 --> 00:37:32,100
0,400 540,875 875,1210
1 is 7,|
|

1360
00:37:32,500 --> 00:37:34,785
0,400 480,1010 1010,1360 1740,2165 2165,2285
then it's, {} today's what
然后今天是 30 号，

1361
00:37:34,785 --> 00:37:38,060
0,165 165,665 1375,2045 2185,2855 2875,3275
the 30th,| so today's day
|所以今天的日期减去 1 月 1 日，

1362
00:37:38,470 --> 00:37:40,920
0,590 590,850 1200,1565 1565,1930 2220,2450
subtracted by January first,| so
|所以这是 29 ，

1363
00:37:40,920 --> 00:37:42,180
0,195 195,615 615,840 840,1005 1005,1260
that's 29,| you get {729
|你得到 729 ，

1364
00:37:42,180 --> 00:37:46,020
0,255 255,560 2920,3315 3315,3540 3540,3840
- -},| that's wrong, {I,can't}
|这是错误的，我不能这么做。|

1365
00:37:46,020 --> 00:37:48,320
0,90 90,350
do that.|
|

1366
00:37:48,330 --> 00:37:48,995
0,230 230,290 290,380 380,485 485,665
So what we can do
所以我们能做的是，

1367
00:37:48,995 --> 00:37:51,420
0,240 240,545 805,1095 1095,1385
instead is,| we can,
|我们可以，抱歉，

1368
00:37:52,230 --> 00:37:54,160
0,275 275,550
we can,

1369
00:37:54,470 --> 00:37:55,560
0,400
sorry,|
抱歉，|

1370
00:37:56,500 --> 00:37:58,460
0,230 230,320 320,485 485,790
we can get the,|
我们可以，|

1371
00:38:01,200 --> 00:38:02,440
0,320 320,640

1372
00:38:04,850 --> 00:38:07,255
0,245 245,490 1350,1640 1640,1930 2100,2405
there we,| so what we're
我们到了，|所以，我们现在要做的是，

1373
00:38:07,255 --> 00:38:08,080
0,105 105,285 285,480 480,660 660,825
doing here now is,| we're
|获取今天的日期和年初，

1374
00:38:08,080 --> 00:38:11,790
0,230 2650,2910 2910,3150 3150,3420 3420,3710
getting the date of today

1375
00:38:11,870 --> 00:38:12,565
0,260 260,380 380,515 515,620 620,695
and the beginning of the

1376
00:38:12,565 --> 00:38:13,780
0,245 625,960 960,1050 1050,1125 1125,1215
year,| converting it to a
|将其转换为 UNIX_TIMESTAMP ，

1377
00:38:13,780 --> 00:38:15,280
0,285 285,525 525,860
{UNIX_TIMESTAMP - -},|
|

1378
00:38:15,410 --> 00:38:17,305
0,395 395,605 605,875 875,1210 1650,1895
{UNIX_TIMESTAMP - -} is the
UNIX_TIMESTAMP 是自 Unix epoch 1970 年 1 月 1 日以来的秒数，

1379
00:38:17,305 --> 00:38:18,460
0,135 135,315 315,605 625,915 915,1155
number of seconds since the

1380
00:38:18,460 --> 00:38:21,240
0,315 315,920 1390,1790 1840,2160 2160,2780
UNIX epochs, {like,January} first 1970,|
|

1381
00:38:22,610 --> 00:38:23,575
0,245 245,425 425,635 635,770 770,965
so we're converting it now
所以我们现在将其转换为从 1970 年到今天的秒数，

1382
00:38:23,575 --> 00:38:24,270
0,135 135,195 195,300 300,435 435,695
to the number of seconds

1383
00:38:24,590 --> 00:38:26,120
0,290 290,580
from today

1384
00:38:26,680 --> 00:38:28,725
0,305 305,940 1470,1730 1730,1880 1880,2045
since 1970| and then we
|然后我们减去从 1 月 1 日以来的数字，

1385
00:38:28,725 --> 00:38:30,290
0,450 450,750 750,1085 1105,1335 1335,1565
subtract that from the number

1386
00:38:30,400 --> 00:38:33,180
0,400 600,935 935,1270 1800,2200 2430,2780
since January first| and we
|再除以 60 秒乘以 60 分钟乘以 24 小时，

1387
00:38:33,180 --> 00:38:34,695
0,270 270,540 540,885 885,1215 1215,1515
divide that by 60 seconds

1388
00:38:34,695 --> 00:38:36,405
0,285 285,540 540,810 810,1145 1285,1710
times 60 minutes times 24

1389
00:38:36,405 --> 00:38:38,200
0,245
hours,|
|

1390
00:38:38,200 --> 00:38:38,770
0,105 105,195 195,300 300,420 420,570
and we get {241 -
我们得到二百四十一。

1391
00:38:38,770 --> 00:38:39,580
0,290
-}.|
|

1392
00:38:40,550 --> 00:38:41,920
0,335 335,670 840,1100 1100,1220 1220,1370
So this, this is my
所以，这是我最初的想法，

1393
00:38:41,920 --> 00:38:43,675
0,290 340,740 1240,1470 1470,1590 1590,1755
original idea| and then turns
|然后发现 MySQL 中有一个 DATEDIFF 函数，

1394
00:38:43,675 --> 00:38:45,520
0,275 475,795 795,1025 1345,1650 1650,1845
out there's a {DATEDIFF -}

1395
00:38:45,520 --> 00:38:49,255
0,290 2830,3090 3090,3350 3400,3645 3645,3735
function in MySQL,| you can
|你可以这么做，

1396
00:38:49,255 --> 00:38:51,420
0,105 105,365
do this,|
|

1397
00:38:51,420 --> 00:38:53,760
0,350 640,945 945,1080 1080,1370
{but,Postgres} doesn't have it,|
但是 Postgres 没有这个，|

1398
00:38:53,950 --> 00:38:54,975
0,275 275,500 500,695 695,800 800,1025
{DuckDB -} doesn't have it,|
DuckDB 没有这个，|

1399
00:38:54,975 --> 00:38:55,910
0,180 180,240 240,480 480,630 630,935
see if Oracle has it,
看看 Oracle 有没有这个， DUAL ，

1400
00:38:58,690 --> 00:39:01,380
0,400 1740,2140 2220,2465 2465,2615 2615,2690
DUAL, right,| they don't have
|他们没有这个。

1401
00:39:01,380 --> 00:39:03,750
0,260 1810,2085 2085,2190 2190,2295 2295,2370
it.| {All,right}, so that's a
|好的，所以这是 MySQL 的东西。

1402
00:39:03,750 --> 00:39:04,850
0,195 195,435 435,495 495,840 840,1100
MySQL, that's a MySQL thing.|
|

1403
00:39:05,550 --> 00:39:07,090
0,290 290,425 425,670 900,1265 1265,1540
{All,right}, so now let's try
好的，现在让我们在 SQLite 中尝试，

1404
00:39:07,290 --> 00:39:09,470
0,400 540,860 860,1120 1680,1955 1955,2180
in {SQLite -},| so {SQLite
|所以， SQLite 没有 DATEDIFF ，

1405
00:39:09,470 --> 00:39:10,420
0,150 150,360 360,480 480,660 660,950
-} doesn't have {DATEDIFF -},|
|

1406
00:39:11,310 --> 00:39:12,425
0,275 275,515 515,605 605,800 800,1115
we can't do that, that
我们不能做在 Postgres 中的减法，

1407
00:39:12,425 --> 00:39:13,370
0,570 570,660 660,750 750,840 840,945
subtraction that we did in

1408
00:39:13,370 --> 00:39:15,660
0,500
Postgres,|
|

1409
00:39:15,660 --> 00:39:16,665
0,240 240,420 420,690 690,885 885,1005
the best solution I could
我能想到的最好的解决方案是，

1410
00:39:16,665 --> 00:39:18,770
0,135 135,285 285,575 985,1385 1705,2105
come up with is| the
|将今天和年初的时间戳转换为儒略历，

1411
00:39:19,780 --> 00:39:21,480
0,335 335,560 560,800 800,1150 1440,1700
convert the {timestamp -} for

1412
00:39:21,480 --> 00:39:22,365
0,240 240,480 480,585 585,690 690,885
today and begin a year

1413
00:39:22,365 --> 00:39:24,225
0,195 195,345 345,795 795,1085 1615,1860
to the Julian calendar,| which
|这是自 Julian Caesar 生日以来的天数，

1414
00:39:24,225 --> 00:39:24,980
0,90 90,165 165,285 285,465 465,755
is the number of days

1415
00:39:25,270 --> 00:39:27,285
0,320 320,740 740,1235 1235,1510 1680,2015
since Julian Caesar's birthday,| in
|在公元前什么时候，

1416
00:39:27,285 --> 00:39:30,015
0,255 255,480 480,785 2245,2520 2520,2730
whatever {BC -},| you laugh,
|你笑了，但直到上世纪 80 年代，很多银行都在用，

1417
00:39:30,015 --> 00:39:30,525
0,165 165,225 225,330 330,420 420,510
but a lot of the

1418
00:39:30,525 --> 00:39:31,650
0,225 225,450 450,600 600,870 870,1125
banks ran off that in

1419
00:39:31,650 --> 00:39:32,685
0,120 120,255 255,530 550,870 870,1035
the in the up until

1420
00:39:32,685 --> 00:39:35,310
0,135 135,600 600,995 2275,2520 2520,2625
the 80s, right,| and then
|然后你得到 241 ，

1421
00:39:35,310 --> 00:39:36,440
0,120 120,375 375,645 645,825 825,1130
you get {241 - -},|
|

1422
00:39:36,850 --> 00:39:38,240
0,400 450,740 740,860 860,1070 1070,1390
but we're getting it as
但我们得到的是一个浮点数，

1423
00:39:38,620 --> 00:39:39,640
0,400
a,

1424
00:39:39,930 --> 00:39:40,960
0,275 275,410 410,635 635,755 755,1030
as a floating point number,|
|

1425
00:39:41,310 --> 00:39:42,365
0,320 320,500 500,650 650,860 860,1055
so we can cast it
所以我们可以将它转换为一个整数，然后我们得到 241 。

1426
00:39:42,365 --> 00:39:43,235
0,195 195,360 360,690 690,795 795,870
as an integer and then

1427
00:39:43,235 --> 00:39:44,020
0,75 75,195 195,345 345,495 495,785
we get {241 - -}.|
|

1428
00:39:45,380 --> 00:39:46,720
0,400
I,
我忘了如何在 Oracle 中做到这一点，

1429
00:39:46,720 --> 00:39:47,860
0,320 670,915 915,990 990,1065 1065,1140
I forget how to do

1430
00:39:47,860 --> 00:39:48,625
0,75 75,165 165,480 480,705 705,765
this in Oracle,| {I'm,not} going
|我不在 Oracle 中做了。

1431
00:39:48,625 --> 00:39:51,720
0,30 30,90 90,165 165,575 2695,3095
to do in Oracle.| {The,main,point,again,is},
|主要的观点是，这似乎是一件简单的事情，

1432
00:39:52,730 --> 00:39:53,590
0,290 290,470 470,605 605,695 695,860
seems like be a simple

1433
00:39:53,590 --> 00:39:55,380
0,320 490,750 750,900 900,1190 1390,1790
thing,| but all these {timestamp,stuff}
|但所有这些时间戳的东西都有很大的不同。

1434
00:39:56,270 --> 00:39:58,520
0,400 780,1265 1265,1540
is woefully different.|
|

1435
00:39:59,120 --> 00:39:59,995
0,275 275,455 455,620 620,755 755,875
Any questions about this so
到目前为止，对此有什么问题吗？

1436
00:39:59,995 --> 00:40:00,860
0,245
far?|
|

1437
00:40:01,800 --> 00:40:03,125
0,400 570,845 845,980 980,1085 1085,1325

1438
00:40:03,125 --> 00:40:04,970
0,375 375,690 690,1025 1105,1505 1555,1845

1439
00:40:04,970 --> 00:40:06,500
0,135 135,380 520,885 885,1250

1440
00:40:06,970 --> 00:40:07,605
0,260 260,350 350,425 425,515 515,635
Why would you want a
为什么想要一个小写函数？

1441
00:40:07,605 --> 00:40:10,440
0,210 210,545
lower function?|
|

1442
00:40:14,230 --> 00:40:15,820
0,260 260,520
Good question.|
好问题。|

1443
00:40:15,860 --> 00:40:16,480
0,245 245,320 320,395 395,515 515,620
I mean, you might need
我的意思是，你可能需要它来清理数据，

1444
00:40:16,480 --> 00:40:19,060
0,75 75,240 240,495 495,830
it for data cleaning,|
|

1445
00:40:19,100 --> 00:40:20,460
0,275 275,550 570,845 845,1040 1040,1360
you might want it for.|
你可能需要它来做。|

1446
00:40:22,710 --> 00:40:23,500
0,275 275,425 425,470 470,545 545,790
Yeah, it's a good question,|
是的，这是个好问题，|

1447
00:40:23,610 --> 00:40:25,800
0,320 320,515 515,790 1170,1570
maintain the standard, right,|
保持标准，|

1448
00:40:26,260 --> 00:40:27,660
0,290 290,440 440,700 1020,1250 1250,1400
it could be,| it doesn't
它可能会，|并不一定非得如此，

1449
00:40:27,660 --> 00:40:28,320
0,75 75,150 150,375 375,600 600,660
have to be,| also in
|也可以在 WHERE 子句中，

1450
00:40:28,320 --> 00:40:29,160
0,90 90,255 255,540 540,735 735,840
the WHERE clause,| you can
|你也可以在 FROM 子句中使用它。

1451
00:40:29,160 --> 00:40:29,730
0,135 135,225 225,285 285,405 405,570
have it in the FROM

1452
00:40:29,730 --> 00:40:31,170
0,320 940,1170 1170,1230 1230,1320 1320,1440
clause.| So if I go
|所以如果我回到 MySQL ，

1453
00:40:31,170 --> 00:40:32,780
0,135 135,240 240,360 360,800
back to {MySQL -},

1454
00:40:33,240 --> 00:40:35,600
0,350 350,620 620,845 845,1150
right,| so SELECT *
|SELECT * FROM students WHERE name = 'Tupac';

1455
00:40:35,790 --> 00:40:37,660
0,395 395,790
FROM students

1456
00:40:39,350 --> 00:40:41,340
0,305 305,605 605,950 950,1480 1590,1990
WHERE name equals Tupac, right,|
|

1457
00:40:43,740 --> 00:40:46,235
0,400 1260,1660 1980,2225 2225,2360 2360,2495
student, right,| so maybe I
student ，|所以，也许我想在输出中这么做，

1458
00:40:46,235 --> 00:40:47,020
0,75 75,150 150,270 270,465 465,785
want to do this though,

1459
00:40:49,470 --> 00:40:51,215
0,245 245,440 440,790 1410,1655 1655,1745
in my output,| get a
|得到一个这样的小写字母。

1460
00:40:51,215 --> 00:40:52,620
0,270 270,405 405,665
lowercase like that.|
|

1461
00:40:55,110 --> 00:40:56,520
0,290 290,485 485,790
Yes, sorry, yes.|
是的，抱歉，是的。|

1462
00:40:56,900 --> 00:40:58,220
0,300 300,680

1463
00:41:02,420 --> 00:41:03,680
0,105 105,240 240,530 610,1010

1464
00:41:08,060 --> 00:41:09,520
0,260 260,425 425,665 665,1000

1465
00:41:10,300 --> 00:41:11,630
0,365 365,650 650,830 830,1010 1010,1330
Yeah, so her question is,|
是的，所以她的问题是，|

1466
00:41:12,580 --> 00:41:13,500
0,335 335,515 515,650 650,800 800,920
why do people have all
为什么人们在他们的 SQL 中有所有这些奇怪的习语，

1467
00:41:13,500 --> 00:41:15,345
0,150 150,360 360,860 910,1310 1570,1845
these weird idioms in, in

1468
00:41:15,345 --> 00:41:18,200
0,275 325,725 745,1295
their, their SQL,|
|

1469
00:41:18,380 --> 00:41:19,600
0,400 510,755 755,875 875,1055 1055,1220
when at a high level,
在高级别上，他们似乎都在做同样的事情，

1470
00:41:19,600 --> 00:41:20,170
0,135 135,240 240,300 300,360 360,570
they seem to be all

1471
00:41:20,170 --> 00:41:21,085
0,240 240,375 375,510 510,675 675,915
sort doing the same thing,|
|

1472
00:41:21,085 --> 00:41:21,925
0,180 180,345 345,510 510,705 705,840
but it's these {one-off -}
但这是[一次性的]事情不同，

1473
00:41:21,925 --> 00:41:23,320
0,275 385,630 630,875 925,1170 1170,1395
things are different| and that's
|这与他的问题有关，

1474
00:41:23,320 --> 00:41:24,265
0,180 180,270 270,375 375,600 600,945
related to his question,| why,
|为什么这些不同的系统有这么多不同的细微差别，

1475
00:41:24,265 --> 00:41:25,860
0,270 270,405 405,570 570,875
why are all these,

1476
00:41:25,860 --> 00:41:26,595
0,195 195,315 315,420 420,555 555,735
why are all these different

1477
00:41:26,595 --> 00:41:27,800
0,465 465,615 615,720 720,885 885,1205
nuances for these different systems,|
|

1478
00:41:28,390 --> 00:41:29,490
0,320 320,575 575,785 785,950 950,1100
because somebody was writing and
因为有人在编写，觉得它很酷，

1479
00:41:29,490 --> 00:41:30,780
0,120 120,225 225,345 345,620
thought it was cool,

1480
00:41:30,780 --> 00:41:32,415
0,350 820,1080 1080,1230 1230,1410 1410,1635
right,| and then they showed
|然后向他们的朋友们展示，

1481
00:41:32,415 --> 00:41:33,495
0,240 240,510 510,720 720,855 855,1080
their friends,| like yeah, that's
|是的，这很酷，

1482
00:41:33,495 --> 00:41:34,890
0,245 385,705 705,915 915,1155 1155,1395
cool,| So the double colon
|所以双冒号和 Postgres ，

1483
00:41:34,890 --> 00:41:36,000
0,150 150,495 495,690 690,870 870,1110
and Postgres,| I agree, that's
|我同意，这很酷，

1484
00:41:36,000 --> 00:41:37,305
0,120 120,270 270,645 645,920 1060,1305
cool,| that casting thing, but
|转换的事情，但他们只做这件事，

1485
00:41:37,305 --> 00:41:38,540
0,135 135,345 345,540 540,815
they only do it,

1486
00:41:38,960 --> 00:41:42,145
0,400 1890,2180 2180,2435 2435,2710 2940,3185
right,| the DUAL table, I
|DUAL 表，我不知道是什么。

1487
00:41:42,145 --> 00:41:46,900
0,150 150,195 195,425
don't know what.|
|

1488
00:41:47,720 --> 00:41:49,570
0,380 380,760 1140,1415 1415,1610 1610,1850
Yeah, so give another example,|
是的，那么再举一个例子，|

1489
00:41:49,570 --> 00:41:52,020
0,320 730,1050 1050,1170 1170,1670 2050,2450
so there's a shortcut in
在 SQL 中有一条捷径，

1490
00:41:52,040 --> 00:41:54,210
0,580 960,1205 1205,1385 1385,1720 1770,2170
SQL,| to do basically {SELECT,*},|
|执行 SELECT * ，|

1491
00:41:54,560 --> 00:41:57,570
0,320 320,575 575,910 1560,1960 2610,3010
so SELECT * FROM student,
所以， SELECT * FROM student; 给你所有的 tuple ，

1492
00:41:59,030 --> 00:41:59,890
0,260 260,365 365,485 485,605 605,860
gives you all the tuples,

1493
00:41:59,890 --> 00:42:01,870
0,290 520,870 870,1140 1140,1670 1720,1980
right,| But in postgres, which
|但是在 Postgres 中，我认为它也在 SQL 标准中，

1494
00:42:01,870 --> 00:42:02,410
0,120 120,225 225,360 360,480 480,540
I think is also in

1495
00:42:02,410 --> 00:42:03,175
0,75 75,270 270,480 480,675 675,765
the SQL standard,| I can
|我只需要写 TABLE 就可以了，

1496
00:42:03,175 --> 00:42:04,540
0,90 90,255 255,575 985,1245 1245,1365
just write TABLE and get

1497
00:42:04,540 --> 00:42:05,880
0,210 210,560
that right,|
|

1498
00:42:06,110 --> 00:42:09,140
0,400 1590,1865 1865,2290
in {MySQL -},
在 MySQL 中，我可以这样做，这很酷，

1499
00:42:09,380 --> 00:42:11,000
0,275 275,395 395,500 500,760
I can do that,

1500
00:42:11,105 --> 00:42:13,820
0,105 105,365 1165,1515 1515,1775
that's cool,| {SQLite -},
|在 SQLite 中，不是这样，

1501
00:42:15,650 --> 00:42:17,220
0,305 305,530 530,635 635,910
{}, doesn't like it,|
|

1502
00:42:17,220 --> 00:42:19,320
0,380 580,1250
in DuckDB,
在 DuckDB 中，可以这样做，

1503
00:42:21,370 --> 00:42:22,305
0,260 260,365 365,590 590,815 815,935
they do it,| but they
|但他们也有另一个，

1504
00:42:22,305 --> 00:42:23,445
0,105 105,210 210,375 375,665 895,1140
also have another one,| I
|我想你只需要 FETCH ，

1505
00:42:23,445 --> 00:42:25,080
0,105 105,225 225,360 360,635
think you just go,

1506
00:42:25,490 --> 00:42:26,125
0,245 245,320 320,380 380,470 470,635
I think you just go

1507
00:42:26,125 --> 00:42:27,510
0,365 625,915 915,1050 1050,1140 1140,1385
FETCH,| no, or is it
|不是，或者是 FROM ，

1508
00:42:30,750 --> 00:42:32,040
0,400
FROM,

1509
00:42:32,050 --> 00:42:33,510
0,400 870,1115 1115,1220 1220,1340 1340,1460
right,| you can just do
|你可以这么做。

1510
00:42:33,510 --> 00:42:34,380
0,260
that.|
|

1511
00:42:35,670 --> 00:42:36,665
0,335 335,530 530,680 680,845 845,995
So they all had their
所以他们都有自己奇怪的习语，

1512
00:42:36,665 --> 00:42:37,835
0,240 240,690 690,885 885,990 990,1170
weird idioms,| I mean, so
|我的意思是，其中一些事情东西基于客户的反馈，

1513
00:42:37,835 --> 00:42:38,825
0,165 165,270 270,405 405,660 660,990
some of these things were,

1514
00:42:38,825 --> 00:42:40,595
0,365 565,870 870,1125 1125,1425 1425,1770
are, are based on customer

1515
00:42:40,595 --> 00:42:41,720
0,345 345,585 585,750 750,945 945,1125
feedback,| like the customer says,
|比如客户说，我需要在 json 上操作的函数，

1516
00:42:41,720 --> 00:42:42,740
0,135 135,390 390,615 615,810 810,1020
I want, you know, I

1517
00:42:42,740 --> 00:42:43,550
0,135 135,345 345,570 570,705 705,810
need functions that operate on

1518
00:42:43,550 --> 00:42:45,250
0,470 490,885 885,1185 1185,1455 1455,1700
json,| so somebody adds that,|
|所以有人加了这个，|

1519
00:42:45,690 --> 00:42:46,910
0,400 420,680 680,815 815,965 965,1220
and a lot of times
而且很多时候，这些特性在它们出现在标准中之前就被添加了，

1520
00:42:46,910 --> 00:42:48,670
0,315 315,615 615,840 840,1100 1360,1760
these features get added before

1521
00:42:48,780 --> 00:42:49,670
0,305 305,470 470,590 590,710 710,890
they show up in the

1522
00:42:49,670 --> 00:42:50,580
0,320
standard,

1523
00:42:50,780 --> 00:42:52,510
0,395 395,725 725,935 935,1280 1280,1730
right,| so the json xml
|json xml 就是一个很好的例子，

1524
00:42:52,510 --> 00:42:53,200
0,195 195,270 270,405 405,585 585,690
is a good example of

1525
00:42:53,200 --> 00:42:54,660
0,230
this,|
|

1526
00:42:54,670 --> 00:42:55,500
0,305 305,485 485,620 620,725 725,830
that got out of the
这来自在 2006 年 SQL 标准，

1527
00:42:55,500 --> 00:42:56,895
0,225 225,480 480,1140 1140,1305 1305,1395
SQL standard 2006,| but a
|但有很多关系型数据库，

1528
00:42:56,895 --> 00:42:58,200
0,120 120,240 240,405 405,1025 1045,1305
lot of relational databases,| at
|在 2000 年早期已经有了 xml 的支持。

1529
00:42:58,200 --> 00:42:58,785
0,135 135,300 300,420 420,480 480,585
the time in the early

1530
00:42:58,785 --> 00:43:00,255
0,135 135,395 655,990 990,1245 1245,1470
{2000s -} had some support

1531
00:43:00,255 --> 00:43:01,540
0,195 195,725
for xml.|
|

1532
00:43:01,740 --> 00:43:02,690
0,260 260,365 365,470 470,680 680,950
And so what happens is,|
所以发生的事情是，|

1533
00:43:02,690 --> 00:43:04,625
0,320 550,870 870,1170 1170,1550 1570,1935
like, the standards body is
标准机构是一群陌生人，

1534
00:43:04,625 --> 00:43:05,810
0,390 390,765 765,975 975,1065 1065,1185
it's, it's a bunch of

1535
00:43:05,810 --> 00:43:06,980
0,420 420,720 720,855 855,1020 1020,1170
randos,| it's the people at
|它是不同公司的人，

1536
00:43:06,980 --> 00:43:08,390
0,195 195,530 970,1215 1215,1305 1305,1410
different companies,| so in the
|所以，在 SQL 标准机构中，

1537
00:43:08,390 --> 00:43:09,755
0,255 255,465 465,705 705,1230 1230,1365
SQL standards body,| there's somebody
|有来自 Oracle 的人，

1538
00:43:09,755 --> 00:43:10,990
0,165 165,540 540,720 720,900 900,1235
from Oracle,| there's somebody from
|有来自 Sybase 的人，

1539
00:43:11,190 --> 00:43:12,730
0,545 545,845 845,1130 1130,1310 1310,1540
Sybase,| somebody from, you know,
|有来自 IBM 的人，

1540
00:43:12,750 --> 00:43:13,940
0,610
IBM,|
|

1541
00:43:14,210 --> 00:43:15,205
0,245 245,380 380,500 500,680 680,995
and they show up the
然后他们出现在标准委员会，

1542
00:43:15,205 --> 00:43:16,660
0,315 315,665 895,1155 1155,1275 1275,1455
standards committee,| and they all
|他们都试图获得他们拥有的任何东西，

1543
00:43:16,660 --> 00:43:17,425
0,150 150,225 225,390 390,600 600,765
try to get whatever they

1544
00:43:17,425 --> 00:43:18,715
0,255 255,870 870,990 990,1110 1110,1290
have, proprietary thing that they

1545
00:43:18,715 --> 00:43:19,720
0,305 355,630 630,750 750,855 855,1005
have,| they try to get
|他们试图将其纳入标准，

1546
00:43:19,720 --> 00:43:21,200
0,180 180,390 390,585 585,860
that into the standard,

1547
00:43:21,200 --> 00:43:22,900
0,320 760,1185 1185,1320 1320,1455 1455,1700
right,| Oracle probably do this,|
|Oracle 可能会这么做，|

1548
00:43:24,210 --> 00:43:25,220
0,260 260,425 425,635 635,800 800,1010
the best example, more recently,|
最好的例子是，最近的，|

1549
00:43:25,220 --> 00:43:27,110
0,210 210,555 555,830 1180,1560 1560,1890
the Oracle got their version
Oracle 在 SQL 标准中得到了他们版本的属性图查询，

1550
00:43:27,110 --> 00:43:29,030
0,240 240,480 480,735 735,1220 1630,1920
of property graph queries in

1551
00:43:29,030 --> 00:43:30,830
0,165 165,450 450,740 1300,1590 1590,1800
the SQL standard,| they base
|他们基于他们的密码，这是 Neo4j ，

1552
00:43:30,830 --> 00:43:32,300
0,375 375,585 585,1110 1110,1350 1350,1470
theirs on cipher, which is

1553
00:43:32,300 --> 00:43:33,650
0,120 120,315 315,435 435,710 910,1350
in {Neo4j - -},| that's
|现在是 SQL 标准中的 PGQ ，

1554
00:43:33,650 --> 00:43:35,980
0,240 240,620 1480,1875 1875,2040 2040,2330
now the PGQ stuff

1555
00:43:36,060 --> 00:43:37,460
0,260 260,365 365,590 590,850
in a SQL standard,|
|

1556
00:43:37,560 --> 00:43:39,730
0,245 245,365 365,590 590,940 1590,2170
so they got their extensions
所以，他们的图形查询扩展获得了 SQL 标准，

1557
00:43:39,840 --> 00:43:41,600
0,400 720,1025 1025,1430 1430,1640 1640,1760
for graph queries in the

1558
00:43:41,600 --> 00:43:42,850
0,225 225,500 580,840 840,975 975,1250
SQL standard,| because they were
|因为他们当时是唯一领先的。

1559
00:43:43,140 --> 00:43:43,910
0,290 290,455 455,575 575,665 665,770
only ones ahead at the

1560
00:43:43,910 --> 00:43:45,245
0,260 370,615 615,960 960,1170 1170,1335
time.| So that's how these
|这就是这些东西在 SQL 标准中的显示方式，

1561
00:43:45,245 --> 00:43:45,725
0,165 165,285 285,345 345,405 405,480
things show up in the

1562
00:43:45,725 --> 00:43:46,880
0,150 150,300 300,510 510,815 835,1155
SQL standard,| and so if
|如果每个人都对如何做某事有相互竞争的想法，

1563
00:43:46,880 --> 00:43:49,010
0,195 195,420 420,855 855,1220 1780,2130
everybody has competing ideas for

1564
00:43:49,010 --> 00:43:49,960
0,240 240,435 435,585 585,690 690,950
how something should be done,|
|

1565
00:43:50,160 --> 00:43:50,825
0,245 245,365 365,485 485,575 575,665
you end up with the
你最终会得到最小的公分母，或者可以尝试支持每个人的东西，

1566
00:43:50,825 --> 00:43:51,845
0,165 165,375 375,795 795,900 900,1020
lowest common denominator or something

1567
00:43:51,845 --> 00:43:52,715
0,135 135,240 240,360 360,615 615,870
could try to supports everyone,|
|

1568
00:43:52,715 --> 00:43:54,155
0,105 105,335 775,1020 1020,1170 1170,1440
but then no one exactly
但是，没有人确切地支持标准。

1569
00:43:54,155 --> 00:43:55,870
0,255 255,545 925,1260 1260,1455 1455,1715
supports the, supports the standard.|
|

1570
00:43:57,875 --> 00:43:58,385
0,45 45,165 165,315 390,435 435,510
I'm not saying it's a
我不是说这是一件好事，而是像，

1571
00:43:58,385 --> 00:43:59,900
0,135 135,375 375,570 570,815
good thing, but like,|
|

1572
00:43:59,900 --> 00:44:01,085
0,440 640,915 915,1035 1035,1110 1110,1185
it's we live in a
我们也生活在一个不同的时代，

1573
00:44:01,085 --> 00:44:02,260
0,165 165,435 435,675 675,870 870,1175
different time also too,| where
|有这么多不同的数据库公司，

1574
00:44:02,670 --> 00:44:04,510
0,470 470,710 710,1030 1200,1520 1520,1840
there's so many different database

1575
00:44:04,620 --> 00:44:07,355
0,400 870,1160 1160,1540 1650,2050 2490,2735
companies| and there's one, there
|但没有一家公司，我说它拥有市场，

1576
00:44:07,355 --> 00:44:08,375
0,240 240,420 420,645 645,855 855,1020
isn't one company, I say

1577
00:44:08,375 --> 00:44:09,700
0,165 165,510 510,645 645,905 925,1325
that owns the market| and
|可以根据意愿让人屈服。

1578
00:44:10,110 --> 00:44:12,410
0,400 900,1220 1220,1625 1625,1960 2010,2300
and can bend people according

1579
00:44:12,410 --> 00:44:13,340
0,120 120,225 225,500
to the will

1580
00:44:13,340 --> 00:44:14,840
0,320 400,800
right.| So,
|所以，我之前说过，在 1980 年代之前， IBM 是大公司，

1581
00:44:14,840 --> 00:44:16,145
0,195 195,330 330,590 850,1125 1125,1305
I said before in the

1582
00:44:16,145 --> 00:44:17,735
0,555 555,765 765,1185 1185,1380 1380,1590
{1980s -}, IBM was, was

1583
00:44:17,735 --> 00:44:18,725
0,135 135,270 270,480 480,690 690,990
the huge company, right,| IBM
|IBM 是那个计算公司，

1584
00:44:18,725 --> 00:44:20,260
0,195 195,495 495,845 925,1290 1290,1535
was the the computing company,|
|

1585
00:44:20,490 --> 00:44:21,680
0,275 275,425 425,800 800,1010 1010,1190
so whatever IBM said, that
所以无论 IBM 说什么，这都被认为是事实上的标准，

1586
00:44:21,680 --> 00:44:23,600
0,180 180,500 910,1305 1305,1560 1560,1920
was considered the de facto

1587
00:44:23,600 --> 00:44:24,540
0,290
standard,|
|

1588
00:44:24,540 --> 00:44:25,785
0,195 195,470 670,975 975,1065 1065,1245
and so that sort of
这就是我们今天使用 SQL 的原因。

1589
00:44:25,785 --> 00:44:26,805
0,195 195,300 300,420 420,695 745,1020
how we ended up with

1590
00:44:26,805 --> 00:44:28,060
0,285 285,545
SQL today.|
|

1591
00:44:28,130 --> 00:44:28,975
0,260 260,380 380,575 575,665 665,845
But there isn't a company
但是现在没有一家公司像这样，

1592
00:44:28,975 --> 00:44:30,985
0,210 210,375 375,665 955,1355 1675,2010
like that now,| like the
|最接近的事情是 Google 推出他们的 SQL 标准，名为 ZetaSQL ，

1593
00:44:30,985 --> 00:44:32,800
0,450 450,645 645,810 810,1085 1435,1815
closest thing would be Google

1594
00:44:32,800 --> 00:44:34,135
0,225 225,435 435,780 780,1110 1110,1335
put out their standard of

1595
00:44:34,135 --> 00:44:35,860
0,285 285,495 495,810 810,1235 1375,1725
SQL called {ZetaSQL -},| internally
|它在内部被称为其他东西，

1596
00:44:35,860 --> 00:44:36,775
0,150 150,270 270,450 450,660 660,915
it's called something else,| but
|但他们开放了一个解析器以及语法文件和规范，

1597
00:44:36,775 --> 00:44:38,250
0,315 315,585 585,765 765,945 945,1475
they open source a parser

1598
00:44:39,230 --> 00:44:40,435
0,335 335,560 560,725 725,980 980,1205
and, and, and the and

1599
00:44:40,435 --> 00:44:41,500
0,120 120,435 435,585 585,840 840,1065
the grammar file and and

1600
00:44:41,500 --> 00:44:43,075
0,165 165,470 640,930 930,1200 1200,1575
the spec| for their version
|用于他们的 SQL 版本，

1601
00:44:43,075 --> 00:44:44,560
0,330 330,845
of SQL,|
|

1602
00:44:44,750 --> 00:44:46,510
0,350 350,635 635,970 1290,1580 1580,1760
nobody uses it| and Google
没有人使用它，|而且谷歌很大，

1603
00:44:46,510 --> 00:44:47,980
0,150 150,345 345,680
is huge, right,|
|

1604
00:44:48,090 --> 00:44:48,875
0,275 275,560 560,695 695,725 725,785
the closest you're going to
你今天能得到的最接近的是 Postgres ，

1605
00:44:48,875 --> 00:44:50,150
0,135 135,315 315,495 495,1020 1020,1275
get today is Postgres,| a
|很多这样的数据库公司，

1606
00:44:50,150 --> 00:44:50,990
0,135 135,240 240,345 345,555 555,840
lot of these database companies,|
|

1607
00:44:50,990 --> 00:44:51,920
0,285 285,480 480,600 600,780 780,930
when you start out,| instead
当你开始时，|不是从头开始构建语法文件，

1608
00:44:51,920 --> 00:44:53,360
0,105 105,380 640,960 960,1290 1290,1440
of building the grammar file

1609
00:44:53,360 --> 00:44:54,725
0,180 180,470 700,960 960,1155 1155,1365
from scratch,| you go take
|而是使用 Postgres 的，

1610
00:44:54,725 --> 00:44:55,730
0,135 135,495 495,675 675,885 885,1005
the Postgres one,| hack it
|将其修改并注入到系统中，

1611
00:44:55,730 --> 00:44:57,080
0,230 400,705 705,900 900,1200 1200,1350
up and, and inject into

1612
00:44:57,080 --> 00:44:58,370
0,150 150,440 670,1005 1005,1110 1110,1290
your system,| that's what we
|我们就是这么做的，

1613
00:44:58,370 --> 00:45:00,140
0,290 880,1125 1125,1380 1380,1635 1635,1770
did,| and {DuckDB -} took
|而 DuckDB 拿走了我们的代码，他们把它放到 DuckDB 中，

1614
00:45:00,140 --> 00:45:00,860
0,165 165,375 375,510 510,615 615,720
our code and they put

1615
00:45:00,860 --> 00:45:02,770
0,60 60,285 285,680 1210,1560 1560,1910
it {DuckDB -},| like this
|这一堆系统是基于 Postgres 语法的，

1616
00:45:02,970 --> 00:45:04,040
0,260 260,380 380,640 660,920 920,1070
bunch of systems are based

1617
00:45:04,040 --> 00:45:05,840
0,165 165,525 525,980 1000,1400 1540,1800
on Postgres grammar,| because because
|因为这个开放源码，他们使用它，

1618
00:45:05,840 --> 00:45:06,500
0,180 180,345 345,465 465,570 570,660
this open source and they

1619
00:45:06,500 --> 00:45:07,700
0,135 135,410 430,765 765,885 885,1200
use it,| that's the closest
|这是你今天最接近通用标准的地方。

1620
00:45:07,700 --> 00:45:08,210
0,135 135,180 180,255 255,390 390,510
you're going to get to

1621
00:45:08,210 --> 00:45:09,580
0,150 150,405 405,660 660,980
a universal standard today.|
|

1622
00:45:09,620 --> 00:45:10,480
0,260 260,410 410,560 560,695 695,860
But again, I just showed
再说一次，我刚才向你们展示了 FROM 在 DuckDB 中，

1623
00:45:10,480 --> 00:45:11,910
0,180 180,405 405,720 720,1010 1030,1430
you how there's FROM in

1624
00:45:12,530 --> 00:45:14,580
0,880 1110,1355 1355,1565 1565,1730 1730,2050
DuckDB,| but that's not in,
|但那不在 Postgres 中，

1625
00:45:16,180 --> 00:45:19,165
0,150 150,650 970,1370 2520,2595 2595,2985
in Postgres, right,| they've adapted
|他们对其进行了调整。

1626
00:45:19,165 --> 00:45:19,960
0,245
it.|
|

1627
00:45:22,190 --> 00:45:23,280
0,400
Yes.|
是的。|

1628
00:45:27,580 --> 00:45:28,455
0,290 290,470 470,635 635,800 800,875
His question is,| what's the
他的问题是，|如果没有人遵循标准，那么有一个标准有什么意义？

1629
00:45:28,455 --> 00:45:29,070
0,90 90,165 165,285 285,435 435,615
point of having a standard,

1630
00:45:29,070 --> 00:45:29,505
0,165 165,255 255,315 315,360 360,435
if no {one's -} going

1631
00:45:29,505 --> 00:45:31,860
0,90 90,240 240,545
to follow it?|
|

1632
00:45:31,860 --> 00:45:32,685
0,135 135,270 270,450 450,600 600,825
I mean, there's a speed
我是说，这里有限速，但是每个人开车都会超过它，

1633
00:45:32,685 --> 00:45:33,900
0,305 385,645 645,810 810,1020 1020,1215
limit, everyone drives over it,

1634
00:45:33,900 --> 00:45:37,440
0,225 225,560
right,| like,|
|就像，|

1635
00:45:39,180 --> 00:45:40,055
0,320 320,500 500,605 605,710 710,875
I showed you much of
我向你展示了许多 SELECT 语句，比如，

1636
00:45:40,055 --> 00:45:42,780
0,225 225,545 925,1320 1320,1715
SELECT statements, like the,|
|

1637
00:45:42,780 --> 00:45:43,875
0,135 135,270 270,435 435,720 720,1095
and that were slightly different
这在不同的系统之间略有不同，

1638
00:45:43,875 --> 00:45:44,775
0,285 285,465 465,660 660,810 810,900
from one system to the

1639
00:45:44,775 --> 00:45:46,710
0,245 505,905 1165,1565 1585,1845 1845,1935
next,| but you understood what
|但你知道它在做什么，

1640
00:45:46,710 --> 00:45:48,480
0,60 60,180 180,420 420,770 1510,1770
it was doing,| basically the
|不同系统的细微差别，

1641
00:45:48,480 --> 00:45:50,070
0,480 480,600 600,810 810,1160 1330,1590
nuances of different systems,| yeah,
|是的，你可能必须去阅读文档或询问 ChatGPT 要做什么，

1642
00:45:50,070 --> 00:45:50,505
0,120 120,210 210,285 285,360 360,435
you may have to go

1643
00:45:50,505 --> 00:45:51,740
0,90 90,240 240,630 630,900 900,1235
read the documentation or ask

1644
00:45:51,760 --> 00:45:52,700
0,245 245,470 470,575 575,680 680,940
{ChatGPT -} what to do,|
|

1645
00:45:52,930 --> 00:45:54,585
0,260 260,520 1080,1340 1340,1475 1475,1655
but like at a high
但就像在高级别上一样，这些概念是相同的，

1646
00:45:54,585 --> 00:45:55,845
0,300 300,600 600,780 780,1155 1155,1260
level, the the concepts are

1647
00:45:55,845 --> 00:45:56,800
0,135 135,395
the same,

1648
00:45:56,900 --> 00:45:58,000
0,400
right,|
|

1649
00:45:58,740 --> 00:46:00,300
0,400

1650
00:46:00,370 --> 00:46:02,870
0,320 320,485 485,650 650,970 1740,2500
just you know the specifics,
只是你知道特性，每个系统都将是不同的。

1651
00:46:03,190 --> 00:46:03,990
0,290 290,485 485,650 650,740 740,800
Each system is going to

1652
00:46:03,990 --> 00:46:04,940
0,75 75,320
be different.|
|

1653
00:46:06,550 --> 00:46:07,665
0,410 410,500 500,560 560,635 635,1115
Snowflake is a good outlier,|
Snowflake 是一个很好的[异类]，|

1654
00:46:07,665 --> 00:46:08,850
0,270 270,600 600,795 795,990 990,1185
actually Snowflake started from scratch
Snowflake 是在 2013 年从头开始的，

1655
00:46:08,850 --> 00:46:10,500
0,165 165,1050 1050,1215 1215,1335 1335,1650
in 2013,| {they,didn't} take Postgres,|
|他们没有选择 Postgres ，|

1656
00:46:10,500 --> 00:46:11,385
0,150 150,435 435,675 675,780 780,885
they said they just came
他们说，他们想出了自己的语法， Snowflake 语法，

1657
00:46:11,385 --> 00:46:12,110
0,75 75,135 135,195 195,300 300,725
up with their own grammar

1658
00:46:12,460 --> 00:46:14,625
0,460 480,1030 1110,1660 1680,1970 1970,2165
their Snowflake grammar,| that has
|有其他系统不支持的东西。

1659
00:46:14,625 --> 00:46:15,525
0,195 195,330 330,480 480,675 675,900
things that other systems don't

1660
00:46:15,525 --> 00:46:17,685
0,275 1435,1695 1695,1845 1845,2025 2025,2160
support.| If I was, if
|如果我今天从头开始构建一个新的数据库系统，

1661
00:46:17,685 --> 00:46:18,555
0,120 120,270 270,450 450,675 675,870
I was building a new

1662
00:46:18,555 --> 00:46:19,605
0,165 165,420 420,675 675,870 870,1050
database system scratch today,| I
|我不会像 Snowflake 一样做，

1663
00:46:19,605 --> 00:46:21,165
0,150 150,425 895,1140 1140,1260 1260,1560
would not do what Snowflake

1664
00:46:21,165 --> 00:46:21,960
0,255 255,465 465,540 540,630 630,795
did,| it was a different
|那是一个不同的时间，

1665
00:46:21,960 --> 00:46:23,265
0,320 610,885 885,1035 1035,1170 1170,1305
time,| I would start with
|我会从 Postgres 开始，

1666
00:46:23,265 --> 00:46:24,240
0,455
Postgres,|
|

1667
00:46:24,240 --> 00:46:25,365
0,135 135,380 520,840 840,1020 1020,1125
and then expand upon it
然后像 DuckDB 那样对其进行扩展。

1668
00:46:25,365 --> 00:46:26,860
0,90 90,210 210,585 585,845
the way DuckDB did.|
|

1669
00:46:30,180 --> 00:46:31,460
0,400
Okay,
好的，继续前进，因为还有很多事情要做，

1670
00:46:32,380 --> 00:46:33,390
0,260 260,380 380,640 720,950 950,1010
keep going, because still a

1671
00:46:33,390 --> 00:46:35,220
0,105 105,225 225,470
lot to cover,|
|

1672
00:46:36,130 --> 00:46:37,125
0,245 245,365 365,530 530,725 725,995
in the sake of time,
为了节省时间，我将跳过输出重定向，

1673
00:46:37,125 --> 00:46:38,565
0,270 270,330 330,495 495,845 1165,1440
I'm going to skip output

1674
00:46:38,565 --> 00:46:41,000
0,455
redirection,|
|

1675
00:46:41,070 --> 00:46:41,690
0,230 230,350 350,410 410,515 515,620
because you're not really going
因为你在家庭作业中不会需要它，

1676
00:46:41,690 --> 00:46:42,730
0,75 75,195 195,420 420,705 705,1040
to need that for the

1677
00:46:42,750 --> 00:46:45,065
0,400 1290,1625 1625,1775 1775,2045 2045,2315
homework,| let's jump ahead to
|所以让我们跳到窗口函数。

1678
00:46:45,065 --> 00:46:46,440
0,225 225,545
window functions.|
|

1679
00:46:47,660 --> 00:46:49,375
0,335 335,670 1200,1475 1475,1595 1595,1715
{All,right}, so before we showed
好的，在我们展示聚合之前，

1680
00:46:49,375 --> 00:46:54,090
0,515 1735,2025 2025,2315 3085,3665 4315,4715
aggregations,| they were computing {sort,of}
|他们计算整个输入集的一次计算，

1681
00:46:54,230 --> 00:46:56,740
0,350 350,665 665,1270 1920,2255 2255,2510
one shot calculation across the

1682
00:46:56,740 --> 00:47:00,730
0,320 1090,1490 1930,2250 2250,2570 3670,3990
entire input set| to the
|对于输入到聚合函数的关系，

1683
00:47:00,730 --> 00:47:01,795
0,240 240,405 405,510 510,720 720,1065
relation, that was being inputted

1684
00:47:01,795 --> 00:47:02,840
0,150 150,425
to the

1685
00:47:02,840 --> 00:47:04,040
0,290
{}

1686
00:47:04,260 --> 00:47:06,770
0,290 290,580 1860,2120 2120,2210 2210,2510
to, to, for the aggregate

1687
00:47:06,770 --> 00:47:07,865
0,260 430,675 675,855 855,990 990,1095
function,| that you're operating on
|那个你在操作的 FROM 子句（的函数），

1688
00:47:07,865 --> 00:47:10,310
0,90 90,240 240,575 1225,1625 2005,2445
the FROM clause,| but there's
|但也有一些时候，

1689
00:47:10,310 --> 00:47:11,150
0,225 225,420 420,600 600,705 705,840
also times,| where you may
|你可能需要进行所谓的滑动计算，

1690
00:47:11,150 --> 00:47:12,170
0,120 120,285 285,465 465,710 790,1020
need to want to what

1691
00:47:12,170 --> 00:47:13,480
0,105 105,255 255,405 405,690 690,1310
is called a sliding calculation,|
|

1692
00:47:13,860 --> 00:47:15,060
0,400
where
想象一下滚动计票，

1693
00:47:15,350 --> 00:47:16,795
0,260 260,365 365,470 470,730 1050,1445
think of like a rolling

1694
00:47:16,795 --> 00:47:18,145
0,540 540,765 765,930 930,1125 1125,1350
tally| as you go from
|当你从一个 tuple 到下一个，

1695
00:47:18,145 --> 00:47:18,940
0,270 270,510 510,630 630,705 705,795
one {tuple -} to the

1696
00:47:18,940 --> 00:47:20,100
0,195 195,390 390,600 600,870 870,1160
next,| as you're scanning along,|
|在你进行扫描时，|

1697
00:47:20,420 --> 00:47:21,780
0,245 245,350 350,575 575,940 960,1360
you want to update some,
你希望更新一些聚合函数，

1698
00:47:21,890 --> 00:47:23,010
0,290 290,425 425,500 500,845 845,1120
some kind of aggregate function,|
|

1699
00:47:23,660 --> 00:47:24,835
0,245 245,455 455,680 680,875 875,1175
so that for every single
对于从 SELECT 语句输出的每个单独的 tuple ，

1700
00:47:24,835 --> 00:47:26,730
0,255 255,545 835,1185 1185,1560 1560,1895
{tuple -}, that you're output

1701
00:47:27,260 --> 00:47:28,690
0,245 245,365 365,530 530,820 1170,1430
from your SELECT statement,| the
|聚合是处理 tuple 时的某种快照，

1702
00:47:28,690 --> 00:47:30,580
0,375 375,650 1120,1365 1365,1515 1515,1890
aggregate is sort of snapshot

1703
00:47:30,580 --> 00:47:31,915
0,150 150,345 345,555 555,860 1060,1335
in time of when that

1704
00:47:31,915 --> 00:47:33,260
0,210 210,345 345,935
tuple was processed,

1705
00:47:33,730 --> 00:47:34,845
0,350 350,530 530,760 780,1055 1055,1115
right,| the way, it's like
|它就像一个聚合函数，

1706
00:47:34,845 --> 00:47:36,680
0,105 105,435 435,675 675,1055
an aggregate function,| where
|你不会将它们分组到单个最终输出中，

1707
00:47:36,680 --> 00:47:37,655
0,150 150,315 315,630 630,810 810,975
you're not grouping them into

1708
00:47:37,655 --> 00:47:38,710
0,105 105,365 415,690 690,810 810,1055
a single output, for every

1709
00:47:39,630 --> 00:47:41,290
0,305 305,605 605,1000 1140,1400 1400,1660
single final output,| for every
|对于每个 tuple ，它对该聚合进行自己的计算。

1710
00:47:41,460 --> 00:47:42,500
0,500 500,740 740,800 800,890 890,1040
tuple, it's going to have

1711
00:47:42,500 --> 00:47:43,790
0,150 150,410 520,1050 1050,1200 1200,1290
its own computation for that

1712
00:47:43,790 --> 00:47:44,920
0,500
aggregation.|
|

1713
00:47:45,330 --> 00:47:46,025
0,260 260,350 350,425 425,545 545,695
And so the way this
所以，按照这种方式，

1714
00:47:46,025 --> 00:47:47,045
0,195 195,345 345,435 435,660 660,1020
works,| you would have like
|你会在这里有一个函数，

1715
00:47:47,045 --> 00:47:49,250
0,345 345,690 690,1085 1225,1625 1945,2205
a, a function here,| this
|这将是你的所有聚合函数，

1716
00:47:49,250 --> 00:47:49,880
0,90 90,165 165,270 270,375 375,630
will be all your aggregate

1717
00:47:49,880 --> 00:47:52,420
0,225 225,495 495,800 1360,1760 2140,2540
functions,| Min, Max, Count, Avg,
|Min Max Count Avg ，正如我们之前看到的，

1718
00:47:52,560 --> 00:47:54,275
0,245 245,350 350,470 470,730 1440,1715
as we saw before,| as
|以及一些额外的函数，

1719
00:47:54,275 --> 00:47:55,240
0,120 120,210 210,360 360,615 615,965
well as some additional ones,|
|

1720
00:47:55,800 --> 00:47:56,600
0,275 275,425 425,590 590,650 650,800
and then you're going to
然后你将指定要计算此计算的范围或范围的类型，

1721
00:47:56,600 --> 00:47:58,790
0,650 1270,1545 1545,1695 1695,1950 1950,2190
specify what is the sort

1722
00:47:58,790 --> 00:48:00,010
0,225 225,555 555,780 780,930 930,1220
of scope or the range

1723
00:48:00,660 --> 00:48:01,970
0,365 365,710 710,860 860,1025 1025,1310
that you're going to compute

1724
00:48:01,970 --> 00:48:03,995
0,135 135,600 600,950 1390,1785 1785,2025
this calculation for| basically of
|基本上是如何分割数据并对它进行分类。

1725
00:48:03,995 --> 00:48:04,760
0,135 135,300 300,495 495,645 645,765
how to slice up the

1726
00:48:04,760 --> 00:48:06,420
0,260 460,795 795,1035 1035,1340
data and source it

1727
00:48:06,420 --> 00:48:07,480
0,90 90,225 225,500
and sort it.|
|

1728
00:48:09,020 --> 00:48:10,225
0,400 420,815 815,965 965,1055 1055,1205
So let's look at some
让我们来看一些这样的例子，

1729
00:48:10,225 --> 00:48:12,310
0,210 210,375 375,635 1225,1625 1825,2085
examples like this,| so I
|我可以拥有我以前拥有的所有聚合函数，

1730
00:48:12,310 --> 00:48:13,300
0,105 105,225 225,435 435,615 615,990
can have all the aggregation

1731
00:48:13,300 --> 00:48:14,190
0,240 240,405 405,495 495,615 615,890
functions that I had before,|
|

1732
00:48:16,530 --> 00:48:17,690
0,275 275,485 485,770 770,995 995,1160
Min Max Count, so forth,|
Min Max Count ，等等，|

1733
00:48:17,690 --> 00:48:18,440
0,135 135,255 255,375 375,525 525,750
but I have these these
但是我有这些额外的函数，

1734
00:48:18,440 --> 00:48:19,565
0,240 240,510 510,765 765,945 945,1125
additional ones,| like the {ROW_NUMBER
|比如 ROW_NUMBER ，告诉我 tuple 在输出中的第几行，

1735
00:48:19,565 --> 00:48:20,510
0,255 255,480 480,615 615,735 735,945
-}, that tell me what

1736
00:48:20,510 --> 00:48:22,750
0,350 760,1160 1240,1620 1620,1920 1920,2240
row my tuple is, is

1737
00:48:22,920 --> 00:48:24,635
0,275 275,530 530,910 1260,1550 1550,1715
in my output,| as well
|还有 RANK ，如果我对它们排序，

1738
00:48:24,635 --> 00:48:25,625
0,135 135,270 270,495 495,690 690,990
as a rank, if I'm,

1739
00:48:25,625 --> 00:48:27,260
0,300 300,555 555,815 1045,1410 1410,1635
I'm sorting them,| so if
|所以，如果我有一个 ORDER BY 子句，对学生按 gpa 排序，

1740
00:48:27,260 --> 00:48:28,430
0,260 340,645 645,795 795,960 960,1170
I have an ORDER BY

1741
00:48:28,430 --> 00:48:30,610
0,320 580,980 1210,1500 1500,1665 1665,2180
clause, order students by gpa,|
|

1742
00:48:30,900 --> 00:48:31,610
0,275 275,410 410,515 515,605 605,710
I can tell you what
我可以使用 RANK 函数告诉你所在的位置，

1743
00:48:31,610 --> 00:48:33,185
0,180 180,420 420,740 1090,1410 1410,1575
your position is using the

1744
00:48:33,185 --> 00:48:36,755
0,165 165,485 2965,3240 3240,3450 3450,3570
RANK function,| you can't do
|你不能使用聚合函数来做到这一点，

1745
00:48:36,755 --> 00:48:37,880
0,120 120,210 210,375 375,825 825,1125
that with a aggregation function,|
|

1746
00:48:37,880 --> 00:48:39,515
0,240 240,560 1000,1290 1290,1455 1455,1635
because there's things that get
因为有些东西会崩溃。

1747
00:48:39,515 --> 00:48:40,520
0,300 300,545
collapsed down.|
|

1748
00:48:41,520 --> 00:48:42,350
0,215 215,260 260,380 380,560 560,830
So in this case here,
所以，在本例中，

1749
00:48:42,350 --> 00:48:43,370
0,300 300,525 525,720 720,885 885,1020
this example here,| I can
|我可以做 SELECT *, ROW_NUMBER() OVER ，然后是空括号，

1750
00:48:43,370 --> 00:48:44,375
0,225 225,495 495,705 705,870 870,1005
do SELECT * {} {ROW_NUMBER

1751
00:48:44,375 --> 00:48:46,295
0,275 535,935 1105,1425 1425,1710 1710,1920
-} OVER and then the

1752
00:48:46,295 --> 00:48:48,215
0,180 180,815 1435,1680 1680,1815 1815,1920
empty parentheses,| because I'm not
|因为我没有对其进行分区，

1753
00:48:48,215 --> 00:48:49,670
0,435 435,695 865,1125 1125,1365 1365,1455
partitioning it,| and that'll give
|这会给我这样的输出，

1754
00:48:49,670 --> 00:48:50,555
0,195 195,390 390,525 525,720 720,885
me output like this,| what
|它会告诉我，

1755
00:48:50,555 --> 00:48:51,900
0,180 180,360 360,665
it'll tell me,|
|

1756
00:48:51,900 --> 00:48:52,875
0,240 240,390 390,525 525,750 750,975
again, for all my output
对于我所有的 tuple ，

1757
00:48:52,875 --> 00:48:55,040
0,425 865,1265 1315,1545 1545,1770 1770,2165
tuples,| where do I appear
|我在列表中的位置是什么，

1758
00:48:55,390 --> 00:48:56,240
0,230 230,320 320,470 470,605 605,850
in the list for that,

1759
00:48:56,960 --> 00:48:58,100
0,400
right.|
|

1760
00:48:59,750 --> 00:49:01,040
0,400

1761
00:49:02,170 --> 00:49:02,970
0,260 260,380 380,500 500,605 605,800
If you have the OVER
如果你有 OVER 子句，

1762
00:49:02,970 --> 00:49:04,125
0,300 300,450 450,540 540,990 990,1155
clause,| you can specify how
|你可以指定希望如何将 tuple 分组在一起，

1763
00:49:04,125 --> 00:49:05,835
0,90 90,165 165,240 240,485 1405,1710
you want to group, group

1764
00:49:05,835 --> 00:49:07,245
0,285 285,600 600,900 900,1155 1155,1410
tables together or group tuples

1765
00:49:07,245 --> 00:49:08,565
0,365 505,825 825,1080 1080,1170 1170,1320
together,| when computing the window
|在计算窗口函数时，

1766
00:49:08,565 --> 00:49:10,440
0,305 805,1095 1095,1385 1465,1725 1725,1875
function,| and then you can
|然后可以使用 PARTITION BY ，就像 GROUP BY ，来说明如何对它们进行分组，

1767
00:49:10,440 --> 00:49:11,880
0,210 210,390 390,720 720,1040 1180,1440
use the PARTITION BY, like

1768
00:49:11,880 --> 00:49:13,170
0,150 150,440 670,945 945,1110 1110,1290
GROUP BY, of how to

1769
00:49:13,170 --> 00:49:14,480
0,150 150,390 390,770 820,1065 1065,1310
how to group them up,|
|

1770
00:49:15,000 --> 00:49:16,550
0,400 750,995 995,1115 1115,1325 1325,1550
so for this query here,|
所以，对于这里的查询，|

1771
00:49:16,550 --> 00:49:17,405
0,195 195,375 375,615 615,735 735,855
we're doing SELECT the course
我们从 enrolled 表中 SELECT cid, sid ，

1772
00:49:17,405 --> 00:49:18,245
0,225 225,420 420,540 540,660 660,840
id and the student id

1773
00:49:18,245 --> 00:49:19,790
0,195 195,315 315,495 495,815 1285,1545
from the enrolled table,| and
|我想要得到每个学生记录在 enrolled 表中的 ROW_NUMBER ，

1774
00:49:19,790 --> 00:49:21,095
0,135 135,255 255,330 330,560 940,1305
I want to get the

1775
00:49:21,095 --> 00:49:23,330
0,285 285,605 865,1140 1140,1415 1885,2235
{ROW_NUMBER -} of each, each

1776
00:49:23,330 --> 00:49:24,740
0,270 270,590 850,1125 1125,1260 1260,1410
student record in the enrolled

1777
00:49:24,740 --> 00:49:25,860
0,290
table,|
|

1778
00:49:25,860 --> 00:49:27,090
0,350 670,945 945,1065 1065,1155 1155,1230
{} but then I want
然后我想把它按 cid 划分，

1779
00:49:27,090 --> 00:49:27,975
0,90 90,420 420,555 555,705 705,885
to partition it by course

1780
00:49:28,125 --> 00:49:29,205
0,275 595,840 840,930 930,1005 1005,1080
id,| so I would get
|这样我会得到这样的输出，

1781
00:49:29,205 --> 00:49:30,165
0,180 180,360 360,510 510,765 765,960
an output like this,| for
|对于每个课程，它会告诉我，

1782
00:49:30,165 --> 00:49:32,025
0,150 150,435 435,815 1495,1740 1740,1860
every single course, it would

1783
00:49:32,025 --> 00:49:34,470
0,165 165,455 1675,1995 1995,2250 2250,2445
tell me,| for every student
|对于每个 sid ，他们在那个组中处于什么位置，

1784
00:49:34,470 --> 00:49:36,000
0,260 280,680 760,1095 1095,1350 1350,1530
id what, what position they

1785
00:49:36,000 --> 00:49:37,560
0,255 255,650 700,1100 1180,1425 1425,1560
are in that, in that

1786
00:49:37,560 --> 00:49:38,280
0,290
group,|
|

1787
00:49:39,130 --> 00:49:40,395
0,275 275,395 395,640 750,1085 1085,1265
{} sort of [class] like
像这样的[课程]。

1788
00:49:40,395 --> 00:49:41,500
0,275
this.|
|

1789
00:49:42,810 --> 00:49:43,340
0,245 245,305 305,365 365,440 440,530
Then, if you have an
然后，如果你有一个 ORDER BY 子句，

1790
00:49:43,340 --> 00:49:44,390
0,165 165,375 375,705 705,945 945,1050
ORDER BY clause,| you can
|那么你就可以控制 tuple 如何排序，

1791
00:49:44,390 --> 00:49:45,965
0,260 430,750 750,1065 1065,1350 1350,1575
then control how the tuples

1792
00:49:45,965 --> 00:49:47,795
0,90 90,240 240,755 805,1205 1495,1830
will be sorted| within, within
|在分区内或窗口内，

1793
00:49:47,795 --> 00:49:48,950
0,225 225,360 360,690 690,945 945,1155
either a partition or with,

1794
00:49:48,950 --> 00:49:50,280
0,225 225,420 420,680
within the window,

1795
00:49:50,280 --> 00:49:51,120
0,315 315,480 480,540 540,660 660,840
right,| so in this case
|所以在这种情况下，

1796
00:49:51,120 --> 00:49:53,000
0,290 580,885 885,1065 1065,1340
here,| now I can
|现在我对学生进行排序，

1797
00:49:53,040 --> 00:49:55,560
0,320 320,515 515,740 740,1090
order the students by,|
|

1798
00:49:55,560 --> 00:49:56,490
0,75 75,180 180,315 315,570 570,930
from the enrolled table, based
在 enrolled 表上，通过 cid （进行排序）。

1799
00:49:56,490 --> 00:49:57,940
0,225 225,330 330,465 465,740
on the course id.|
|

1800
00:49:58,890 --> 00:49:59,740
0,230 230,365 365,455 455,575 575,850
So there's a more complicated
这里有一个更复杂的例子，

1801
00:49:59,760 --> 00:50:00,815
0,320 320,560 560,800 800,980 980,1055
example here,| so we want
|我们想找出每门课成绩第二高的学生。

1802
00:50:00,815 --> 00:50:01,595
0,90 90,270 270,450 450,630 630,780
to find the student with

1803
00:50:01,595 --> 00:50:04,010
0,165 165,435 435,765 765,1145 2155,2415
the second highest grade for

1804
00:50:04,010 --> 00:50:05,240
0,180 180,500
each course.|
|

1805
00:50:05,420 --> 00:50:07,015
0,400 990,1235 1235,1340 1340,1475 1475,1595
So for this one here,|
对于这里的这个，|

1806
00:50:07,015 --> 00:50:07,375
0,135 135,180 180,210 210,270 270,360
we're going to have a
我们将有一个嵌套的查询，我们稍后会讨论它，

1807
00:50:07,375 --> 00:50:08,545
0,270 270,435 435,690 690,1005 1005,1170
nested query, which we'll discuss

1808
00:50:08,545 --> 00:50:09,775
0,105 105,195 195,455 715,990 990,1230
in a second,| but basically
|但基本上我有一个 SELECT 语句，它有一个 FROM 子句，

1809
00:50:09,775 --> 00:50:11,580
0,255 255,545 955,1275 1275,1500 1500,1805
I have a SELECT statement

1810
00:50:12,290 --> 00:50:13,210
0,260 260,365 365,485 485,665 665,920
that has a FROM clause,|
|

1811
00:50:13,210 --> 00:50:14,275
0,225 225,420 420,600 600,780 780,1065
and inside that FROM clause,
在那个 FROM 子句中，我还有另一个查询，

1812
00:50:14,275 --> 00:50:15,940
0,210 210,360 360,600 600,965
I have another query,

1813
00:50:15,940 --> 00:50:17,080
0,320
right,|
|

1814
00:50:17,080 --> 00:50:18,820
0,260 280,570 570,840 840,1220 1450,1740
and I can, inside this
在这个内部查询中，

1815
00:50:18,820 --> 00:50:19,920
0,210 210,495 495,705 705,840 840,1100
inner query,| I can reference,
|我在 enrolled 表上进行查找，

1816
00:50:22,250 --> 00:50:23,515
0,305 305,680 680,935 935,1055 1055,1265
here, I'm doing the lookup

1817
00:50:23,515 --> 00:50:24,520
0,90 90,165 165,435 435,695 775,1005
on the enrolled table| and
|然后外部查询可以进行过滤，

1818
00:50:24,520 --> 00:50:25,435
0,90 90,210 210,420 420,735 735,915
then the outer query can

1819
00:50:25,435 --> 00:50:26,680
0,135 135,425 445,960 960,1110 1110,1245
just do filtering| based on
|根据这个嵌套查询的输出，

1820
00:50:26,680 --> 00:50:28,555
0,225 225,590 790,1190 1300,1590 1590,1875
the output of this nested

1821
00:50:28,555 --> 00:50:30,190
0,275 475,875 955,1230 1230,1395 1395,1635
query,| {I'm,going,to} cover nest queries
|我会在稍后讲到嵌套查询。

1822
00:50:30,190 --> 00:50:31,080
0,75 75,165 165,410
in a second.|
|

1823
00:50:31,860 --> 00:50:32,465
0,245 245,335 335,440 440,515 515,605
So the first thing we're
所以我们要做的第一件事是，

1824
00:50:32,465 --> 00:50:32,825
0,30 30,75 75,150 150,255 255,360
going to do is going

1825
00:50:32,825 --> 00:50:34,580
0,120 120,285 285,450 450,875 1495,1755
to| group the tuples by
|按照 cid 对这 tuple 进行分组，

1826
00:50:34,580 --> 00:50:35,920
0,105 105,225 225,500
the course id,|
|

1827
00:50:35,920 --> 00:50:37,210
0,285 285,540 540,750 750,1005 1005,1290
{} and then sort them
然后按成绩排序，

1828
00:50:37,210 --> 00:50:38,530
0,270 270,435 435,710 940,1200 1200,1320
by the grade| and then
|然后我们就会得到排名，

1829
00:50:38,530 --> 00:50:39,810
0,150 150,240 240,390 390,680 880,1280
we'll get the rank,| what
|他们在成绩列表中的位置是什么，

1830
00:50:40,130 --> 00:50:42,400
0,260 260,515 515,910 1830,2120 2120,2270
is their position in the

1831
00:50:42,400 --> 00:50:43,590
0,120 120,240 240,500 580,870 870,1190
sort of list of grades,

1832
00:50:44,690 --> 00:50:45,535
0,350 350,560 560,665 665,740 740,845
right,| and then in my
|然后在我的 WHERE 子句中，

1833
00:50:45,535 --> 00:50:46,345
0,165 165,345 345,540 540,690 690,810
WHERE clause here,| I can
|我现在可以引用窗口函数对列的计算。

1834
00:50:46,345 --> 00:50:49,840
0,255 255,635 715,1115
reference now the,

1835
00:50:50,120 --> 00:50:51,970
0,400 540,905 905,1130 1130,1390 1470,1850
the window, the window function

1836
00:50:51,970 --> 00:50:54,460
0,590 1060,1425 1425,1790
calculation of column,

1837
00:50:54,530 --> 00:50:55,800
0,400
right.|
|

1838
00:50:56,000 --> 00:50:57,150
0,320 320,530 530,725 725,890 890,1150
So any questions about this?|
对此有什么问题吗？|

1839
00:51:00,360 --> 00:51:01,560
0,350 370,770 790,1170

1840
00:51:02,180 --> 00:51:03,640
0,350 350,575 575,850 1050,1310 1310,1460

1841
00:51:05,940 --> 00:51:06,785
0,245 245,395 395,560 560,665 665,845
The question is,| can I,
问题是，|我能用 GROUP BY 制作一个窗口函数吗，

1842
00:51:06,785 --> 00:51:07,505
0,180 180,300 300,450 450,570 570,720
can I make a window

1843
00:51:07,505 --> 00:51:10,960
0,225 225,480 480,690 690,965
function using GROUP BYs,|
|

1844
00:51:13,400 --> 00:51:14,530
0,305 305,485 485,755 755,995 995,1130
let try it what you're
让我们试一试你说的。

1845
00:51:14,530 --> 00:51:16,200
0,230
saying.|
|

1846
00:51:17,180 --> 00:51:18,840
0,230 230,440 440,820
All right, so.|
好的，那么。|

1847
00:51:22,400 --> 00:51:23,560
0,255 255,570 570,920

1848
00:51:25,870 --> 00:51:27,520
0,320 320,640
{All,right}, so,
好的，在 Postgres 中，

1849
00:51:28,040 --> 00:51:29,620
0,290 290,440 440,940
is in Postgres,

1850
00:51:30,980 --> 00:51:33,120
0,320 320,640 690,1040 1040,1390 1740,2140
right,| so again, SELECT FROM
|同样， SELECT FROM enrolled 表，

1851
00:51:33,140 --> 00:51:34,645
0,260 260,425 425,730 1050,1325 1325,1505
the enrolled table,| and then
|然后我们获得每个学生出现的 ROW_NUMBER 。

1852
00:51:34,645 --> 00:51:35,460
0,180 180,255 255,375 375,525 525,815
we'll get the {ROW_NUMBER -}

1853
00:51:37,340 --> 00:51:40,000
0,290 290,500 500,820 960,1360
where each student appears.|
|

1854
00:51:40,000 --> 00:51:41,260
0,320

1855
00:51:41,490 --> 00:51:43,120
0,245 245,365 365,515 515,790 1230,1630
And then the second, {excuse,me},
然后第二个例子是，

1856
00:51:43,170 --> 00:51:45,380
0,260 260,455 455,740 740,1090 1950,2210
the second example was,| the
|cid sid ，然后是 ROW_NUMBER ，

1857
00:51:45,380 --> 00:51:46,955
0,150 150,440 850,1110 1110,1350 1350,1575
course id, student id, and

1858
00:51:46,955 --> 00:51:48,125
0,105 105,210 210,345 345,635 865,1170
then the {ROW_NUMBER -},| we're
|我们将按 cid 对其进行划分，

1859
00:51:48,125 --> 00:51:49,030
0,45 45,150 150,450 450,630 630,905
going to partition it by

1860
00:51:49,290 --> 00:51:51,020
0,275 275,425 425,700 1080,1475 1475,1730
the course id,| so then
|然后，我们将按 cid 对它们和输出进行排序，

1861
00:51:51,020 --> 00:51:51,935
0,135 135,195 195,270 270,500 610,915
we're just going to order

1862
00:51:51,935 --> 00:51:53,405
0,305 535,795 795,990 990,1200 1200,1470
them and the output by

1863
00:51:53,405 --> 00:51:54,680
0,240 240,360 360,635
the course id,

1864
00:51:54,680 --> 00:51:55,640
0,290
right,|
|

1865
00:51:55,640 --> 00:51:56,855
0,350 370,660 660,825 825,1005 1005,1215
so again, this case here,
所以，这个例子我们看到，

1866
00:51:56,855 --> 00:51:57,820
0,195 195,375 375,570 570,720 720,965
we see that we have,|
|

1867
00:51:58,410 --> 00:51:59,645
0,245 245,425 425,740 740,1025 1025,1235
for each course, {15-445 -
对于每门课， 15-445, 721, 826 ，

1868
00:51:59,645 --> 00:52:00,680
0,240 240,465 465,660 660,870 870,1035
-}, {721 - -} and

1869
00:52:00,680 --> 00:52:02,720
0,150 150,650 1300,1710 1710,1860 1860,2040
{826 -},| here's the students
|这是注册的学生，

1870
00:52:02,720 --> 00:52:03,890
0,135 135,405 405,540 540,800 910,1170
that enroll in them,| and
|然后这是他们在每一组中的位置。

1871
00:52:03,890 --> 00:52:04,810
0,120 120,240 240,360 360,570 570,920
then this is their position

1872
00:52:04,950 --> 00:52:07,180
0,365 365,695 695,965 965,1270
within, within each group.|
|

1873
00:52:08,740 --> 00:52:09,735
0,245 245,365 365,515 515,740 740,995
And then my last example
然后我的最后一个例子是这样的，

1874
00:52:09,735 --> 00:52:11,025
0,150 150,270 270,545 865,1140 1140,1290
was like this,| and this
|这就是你问的，是否可以使用一个 GROUP BY ，

1875
00:52:11,025 --> 00:52:11,960
0,135 135,375 375,600 600,690 690,935
is where you were asking,

1876
00:52:11,980 --> 00:52:12,600
0,275 275,380 380,455 455,530 530,620
whether you can do a

1877
00:52:12,600 --> 00:52:14,960
0,135 135,410
GROUP BY,|
|

1878
00:52:14,960 --> 00:52:15,830
0,165 165,285 285,495 495,720 720,870
we're now here again,| so
我们现在又来了，|这样我就能拿到第一个，

1879
00:52:15,830 --> 00:52:17,645
0,90 90,210 210,470 520,920 1480,1815
I can get the first,|
|

1880
00:52:17,645 --> 00:52:18,455
0,195 195,375 375,600 600,720 720,810
the inner query is going
内部查询将为我获取每条记录的排名位置，

1881
00:52:18,455 --> 00:52:20,420
0,90 90,210 210,420 420,755 1585,1965
to get me the rank

1882
00:52:20,420 --> 00:52:23,105
0,380 910,1310 1480,1800 1800,2120 2440,2685
position of every record,| the
|你在排序输出中所处的排名，

1883
00:52:23,105 --> 00:52:24,245
0,245 265,540 540,660 660,900 900,1140
rank where you are in

1884
00:52:24,245 --> 00:52:27,070
0,120 120,450 450,785 2215,2520 2520,2825
the sorting output,| {let,me} remove
|让我先删除这里的这一部分，

1885
00:52:28,180 --> 00:52:29,820
0,290 290,440 440,590 590,880
this part here first,

1886
00:52:30,910 --> 00:52:32,190
0,305 305,470 470,785 785,1040 1040,1280
right,| so here's, here's the
|下面是 SELECT RANK 的内部查询的输出，

1887
00:52:32,190 --> 00:52:33,410
0,240 240,360 360,620 670,945 945,1220
output of the, of the,

1888
00:52:33,610 --> 00:52:34,850
0,260 260,425 425,740 740,980 980,1240
the inner query of the

1889
00:52:34,930 --> 00:52:36,620
0,305 305,610 990,1295 1295,1445 1445,1690
SELECT RANK,| so for every
|所以对于每门课程，

1890
00:52:37,000 --> 00:52:38,630
0,400 900,1220 1220,1280 1280,1370 1370,1630
course,| I'm going to get
|我都会拿到分数，我会按分数排序，

1891
00:52:38,680 --> 00:52:40,500
0,400 840,1235 1235,1520 1520,1760 1760,1820
the grades and I'm going

1892
00:52:40,500 --> 00:52:41,475
0,75 75,240 240,480 480,750 750,975
to order them by the

1893
00:52:41,475 --> 00:52:42,630
0,305 535,780 780,885 885,1005 1005,1155
grades,| and then the rank
|然后，排名就是他们所处的位置，

1894
00:52:42,630 --> 00:52:43,710
0,150 150,315 315,555 555,825 825,1080
is just where their position

1895
00:52:43,710 --> 00:52:45,820
0,320 730,1050 1050,1370
is| in the,
|在成绩列表中，

1896
00:52:45,950 --> 00:52:47,185
0,245 245,490 660,965 965,1130 1130,1235
you know, within the sort

1897
00:52:47,185 --> 00:52:48,000
0,75 75,210 210,375 375,510 510,815
of list of the grades|
|

1898
00:52:48,620 --> 00:52:49,645
0,245 245,380 380,605 605,800 800,1025
and the rank can have
rank 可以有重复的，

1899
00:52:49,645 --> 00:52:50,730
0,285 285,375 375,435 435,665 685,1085
repeats,| so if I {say,insert}
|如果我在这里插入另一条记录，

1900
00:52:51,740 --> 00:52:53,430
0,305 305,560 560,890 890,1355 1355,1690
another record here,| INSERT INTO
|INSERT INTO enrolled VALUES ，

1901
00:52:54,200 --> 00:52:55,680
0,850
enrolled

1902
00:52:56,490 --> 00:52:57,950
0,400 930,1160 1160,1235 1235,1325 1325,1460
VALUES,| so we need a
|所以我们需要一个 sid ，我们做 tupac 所使用的，

1903
00:52:57,950 --> 00:52:59,280
0,150 150,410
student id,

1904
00:52:59,740 --> 00:53:01,680
0,350 350,610
let's do,

1905
00:53:03,290 --> 00:53:05,040
0,335 335,740 740,1060
have tupac take,|
|

1906
00:53:07,540 --> 00:53:09,560
0,400 960,1235 1235,1490 1490,1745 1745,2020
VALUES, course id would be
VALUES ， cid 是 15-721 ，

1907
00:53:10,030 --> 00:53:12,330
0,400 690,980 980,1160 1160,1450 1980,2300
{15-721 - - -}| and
|他获得，给他一个 A ，他是[]。

1908
00:53:12,330 --> 00:53:13,490
0,270 270,405 405,570 570,810 810,1160
let's say he got a,

1909
00:53:15,280 --> 00:53:16,580
0,270 270,345 345,450 450,710
let's give a name,

1910
00:53:16,850 --> 00:53:17,860
0,90 90,350
he's [].|
|

1911
00:53:23,290 --> 00:53:24,900
0,245 245,335 335,485 485,790
What about I create,|
我创建的在哪，|

1912
00:53:25,760 --> 00:53:27,100
0,305 305,440 440,730 900,1175 1175,1340
that order, by order by
也许是按 rank 排序，

1913
00:53:27,100 --> 00:53:28,320
0,210 210,530
rank, maybe,|
|

1914
00:53:28,410 --> 00:53:29,540
0,400
well,
好吧，那把分区破坏了，抱歉。

1915
00:53:36,040 --> 00:53:37,065
0,365 365,635 635,815 815,920 920,1025
that that screws out the

1916
00:53:37,065 --> 00:53:38,760
0,305 355,630 630,905
partition that, sorry,

1917
00:53:39,880 --> 00:53:41,200
0,320 320,640
right.| So,
|所以，这里我们做的是，

1918
00:53:42,150 --> 00:53:43,120
0,260 260,365 365,500 500,650 650,970
here what we're doing is,|
|

1919
00:53:44,250 --> 00:53:46,205
0,400 540,940 1170,1505 1505,1745 1745,1955
every single course, again, we're
每一门课程，我们获得分数，然后按 rank 排序，

1920
00:53:46,205 --> 00:53:47,990
0,150 150,330 330,555 555,905 1525,1785
getting the grade {and,sort,of} in

1921
00:53:47,990 --> 00:53:49,715
0,120 120,380 640,915 915,1190 1480,1725
the rank,| and so we
|我们在这里插入了这条记录 Tupac ，给了他 A ，

1922
00:53:49,715 --> 00:53:51,160
0,300 300,420 420,645 645,945 945,1445
inserted this record here, Tupac,

1923
00:53:51,390 --> 00:53:52,460
0,260 260,395 395,545 545,820 840,1070
we gave an A,| but
|但是这里还有另一个学生在同一门课程中得到 A ，

1924
00:53:52,460 --> 00:53:53,440
0,60 60,240 240,450 450,645 645,980
there was also another student

1925
00:53:54,060 --> 00:53:54,735
0,165 165,330 330,465 465,570 570,675
who got an A in

1926
00:53:54,735 --> 00:53:55,980
0,90 90,240 240,545 775,1080 1080,1245
the same class| and therefore
|所以他们都有相同的排名位置 1 ，

1927
00:53:55,980 --> 00:53:56,715
0,135 135,285 285,435 435,570 570,735
they both have the same

1928
00:53:56,715 --> 00:53:58,360
0,240 240,495 495,705 705,995
rank position of 1,|
|

1929
00:53:58,400 --> 00:53:59,695
0,275 275,545 545,890 890,1130 1130,1295
and then for the student
然后，对于拿到 C 的学生，

1930
00:53:59,695 --> 00:54:01,015
0,135 135,300 300,480 480,755 1015,1320
that got the C,| their
|他们的排名位置是 3 ，

1931
00:54:01,015 --> 00:54:02,605
0,240 240,525 525,825 825,1175 1315,1590
rank position is 3,| so
|所以你可以有重复的排名，行号则不会。

1932
00:54:02,605 --> 00:54:03,520
0,180 180,330 330,420 420,540 540,915
rank you can have duplicates.

1933
00:54:03,520 --> 00:54:04,920
0,165 165,360 360,525 525,770
row numbers will not.|
|

1934
00:54:07,240 --> 00:54:08,415
0,245 245,380 380,575 575,845 845,1175
So, yeah, so you're proposing
所以，是的，你打算做什么，

1935
00:54:08,415 --> 00:54:09,525
0,150 150,270 270,545 715,990 990,1110
to do what,| bunch of
|rank 分组，

1936
00:54:09,525 --> 00:54:11,540
0,165 165,485
rank group,|
|

1937
00:54:11,940 --> 00:54:14,080
0,400
where,|
哪里，|

1938
00:54:15,760 --> 00:54:16,785
0,275 275,395 395,545 545,800 800,1025
at the inner query, or
在内部查询，还是什么，抱歉。

1939
00:54:16,785 --> 00:54:18,100
0,255 255,605
what, sorry.|
|

1940
00:54:19,070 --> 00:54:20,545
0,260 260,520 540,860 860,1180 1230,1475

1941
00:54:20,545 --> 00:54:22,015
0,120 120,315 315,510 510,1055 1105,1470

1942
00:54:22,015 --> 00:54:23,840
0,395 535,870 870,1095 1095,1385

1943
00:54:24,300 --> 00:54:25,055
0,260 260,395 395,530 530,650 650,755
The question is,| is it
问题是，|是否可以使用 GROUP BY 重新创建相同的查询，

1944
00:54:25,055 --> 00:54:25,730
0,120 120,225 225,450 450,555 555,675
possible to recreate the same

1945
00:54:25,730 --> 00:54:28,260
0,210 210,435 435,615 615,890
query using GROUP BY,|
|

1946
00:54:29,200 --> 00:54:30,180
0,275 275,575 575,755 755,920 920,980
you wouldn't, you wouldn't be
你不会得到 rank ，

1947
00:54:30,180 --> 00:54:30,830
0,75 75,150 150,225 225,360 360,650
able to get the rank,|
|

1948
00:54:32,260 --> 00:54:32,895
0,245 245,335 335,500 500,560 560,635
because you wouldn't be able
因为你不能得到我的排序位置是什么，

1949
00:54:32,895 --> 00:54:34,065
0,135 135,375 375,725 835,1080 1080,1170
to get what what is

1950
00:54:34,065 --> 00:54:35,355
0,150 150,390 390,675 675,900 900,1290
my sort position,| there isn't
|在 SQL 中没有这方面的概念，

1951
00:54:35,355 --> 00:54:37,400
0,300 300,600 600,870 870,1145 1645,2045
a concept of that in,

1952
00:54:38,440 --> 00:54:40,500
0,400 930,1480
in SQL,

1953
00:54:41,240 --> 00:54:43,675
0,400 630,1030 1410,1810 1920,2195 2195,2435
right,| so {ROW_NUMBER -} is
|所以 ROW_NUMBER 很有趣，因为它，

1954
00:54:43,675 --> 00:54:45,660
0,300 300,570 570,765 765,1025
interesting, because it is,|
|

1955
00:54:46,620 --> 00:54:47,930
0,270 270,360 360,600 600,945 945,1310
let's do that {ROW_NUMBER -},|
让我们来做 ROW_NUMBER ，|

1956
00:54:56,260 --> 00:54:57,625
0,210 210,330 330,710 970,1245 1245,1365
make the point, switch a
换个地方，换成 ROW_NUMBER ，

1957
00:54:57,625 --> 00:54:59,780
0,120 120,375 375,755 1045,1445
{ROW_NUMBER -},| {ROW_NUMBER -},|
|ROW_NUMBER ，|

1958
00:55:00,990 --> 00:55:02,075
0,245 245,365 365,515 515,770 770,1085
so {ROW_NUMBER -} is interesting,
所以 ROW_NUMBER 很有趣，因为，

1959
00:55:02,075 --> 00:55:04,145
0,335 985,1620 1620,1740 1740,1890 1890,2070
because,| it's calling it rank,
|它叫做 rank ，但相信我，它是 row_number ，

1960
00:55:04,145 --> 00:55:05,210
0,305 445,720 720,825 825,960 960,1065
but trust me, it's {row_number

1961
00:55:05,210 --> 00:55:05,960
0,260
-},|
|

1962
00:55:06,090 --> 00:55:08,405
0,275 275,550 750,1150 1740,2105 2105,2315
it because, again it's bag
这是因为它是袋子代数，

1963
00:55:08,405 --> 00:55:09,845
0,525 525,750 750,945 945,1200 1200,1440
algebra,| there is no sort
|在这些关系中没有排序顺序，

1964
00:55:09,845 --> 00:55:11,020
0,255 255,510 510,675 675,855 855,1175
order in in these relations|
|

1965
00:55:11,190 --> 00:55:11,885
0,230 230,365 365,455 455,575 575,695
and that's a sort of
这是一个奇怪的概念，

1966
00:55:11,885 --> 00:55:13,340
0,195 195,515 925,1185 1185,1305 1305,1455
weird concept,| we think about
|我们对编程的思考是，

1967
00:55:13,340 --> 00:55:14,180
0,285 285,600 600,750 750,795 795,840
programming like,| what do you
|你在那里是什么意思，

1968
00:55:14,180 --> 00:55:15,400
0,90 90,300 300,570 570,720 720,1220
mean there,| there's not ordering,|
|这里没有排序，|

1969
00:55:15,600 --> 00:55:16,310
0,245 245,335 335,470 470,575 575,710
like because we're used to
因为我们习惯于在 x86 下编程，

1970
00:55:16,310 --> 00:55:17,720
0,255 255,570 570,780 780,945 945,1410
programming and under {x86 -}|
|

1971
00:55:17,720 --> 00:55:20,015
0,210 210,470 1450,1905 1905,2055 2055,2295
where there ordering,| how memory
那里有排序，|内存操作是如何发生的，

1972
00:55:20,015 --> 00:55:21,890
0,360 360,755 1225,1485 1485,1740 1740,1875
operations occur,| there isn't any
|这里没有任何这些，

1973
00:55:21,890 --> 00:55:22,730
0,135 135,270 270,525 525,750 750,840
of that here,| Everything can
|任何东西都可以是无序的，

1974
00:55:22,730 --> 00:55:25,895
0,90 90,650 1000,1400 2590,2940 2940,3165
be unordered,| so without a
|所以如果没有窗口函数，你就不能得到 row_number ，

1975
00:55:25,895 --> 00:55:27,170
0,210 210,510 510,795 795,1155 1155,1275
window function, you can't get

1976
00:55:27,170 --> 00:55:28,220
0,135 135,315 315,600 600,855 855,1050
a {row_number -},| because there's
|因为没有办法说，

1977
00:55:28,220 --> 00:55:29,540
0,195 195,530 640,900 900,1095 1095,1320
no way to say,| where
|我在我的输出中的这个位置，

1978
00:55:29,540 --> 00:55:31,085
0,135 135,360 360,740 1060,1335 1335,1545
do I exist in this

1979
00:55:31,085 --> 00:55:32,630
0,335 445,690 690,840 840,1145 1195,1545
position, in my position, my

1980
00:55:32,630 --> 00:55:33,280
0,350
output,|
|

1981
00:55:33,610 --> 00:55:34,920
0,400

1982
00:55:35,100 --> 00:55:36,620
0,590 590,890 890,1145 1145,1325 1325,1520
Oracle does have {row_number -},|
Oracle 确实有 row_number ，|

1983
00:55:36,620 --> 00:55:37,445
0,195 195,345 345,480 480,600 600,825
they hide it from you,|
他们对你隐藏了，|

1984
00:55:37,445 --> 00:55:38,285
0,255 255,435 435,585 585,720 720,840
you can't get it, but
你不能得到它，但它只是 Oracle 的事情。

1985
00:55:38,285 --> 00:55:39,460
0,150 150,545
like it's,

1986
00:55:39,980 --> 00:55:41,040
0,320 320,410 410,500 500,785 785,1060
that's just an Oracle thing.|
|

1987
00:55:42,710 --> 00:55:44,130
0,320 320,635 635,905 905,1100 1100,1420
So, so the window functions
所以，窗函数允许你，

1988
00:55:44,210 --> 00:55:45,715
0,320 320,560 560,880 960,1295 1295,1505
allow you to| condition doing
|对平均值和所有其他聚合进行条件调整，

1989
00:55:45,715 --> 00:55:46,930
0,255 255,780 780,945 945,1110 1110,1215
the averages and all the

1990
00:55:46,930 --> 00:55:48,415
0,105 105,590 700,960 960,1170 1170,1485
other aggregates,| it allows you
|它允许你获得事物的顺序，

1991
00:55:48,415 --> 00:55:50,530
0,365 1075,1395 1395,1605 1605,1845 1845,2115
to get the order of

1992
00:55:50,530 --> 00:55:51,550
0,320 400,645 645,750 750,900 900,1020
things,| in a way that
|以一种你不能以其他方式做到的方式。

1993
00:55:51,550 --> 00:55:52,150
0,120 120,285 285,420 420,510 510,600
you would not be able

1994
00:55:52,150 --> 00:55:53,480
0,90 90,165 165,255 255,500
to do it otherwise.|
|

1995
00:56:03,310 --> 00:56:04,230
0,245 245,350 350,500 500,665 665,920
So I should showed nested
我应该在前面展示了嵌套查询，

1996
00:56:04,230 --> 00:56:05,190
0,300 300,510 510,720 720,855 855,960
queries before,| but there just
|但只是展示更多的细节。

1997
00:56:05,190 --> 00:56:06,410
0,120 120,315 315,600 600,885 885,1220
go through more, more detail.|
|

1998
00:56:06,730 --> 00:56:08,085
0,290 290,455 455,740 740,1030 1080,1355
So a nested query, nested
所以嵌套查询是一个非常强大的概念，

1999
00:56:08,085 --> 00:56:09,200
0,210 210,315 315,495 495,765 765,1115
queries, a really powerful concept,|
|

2000
00:56:09,700 --> 00:56:11,400
0,350 350,605 605,785 785,1240 1380,1700
sometimes called sub queries,| where
有时称为子查询，|它允许你在查询内有一个查询，

2001
00:56:11,400 --> 00:56:12,290
0,180 180,360 360,525 525,630 630,890
it allows you to have

2002
00:56:12,940 --> 00:56:14,115
0,320 320,670 690,935 935,1040 1040,1175
a query inside of a

2003
00:56:14,115 --> 00:56:15,480
0,240 240,575 985,1230 1230,1305 1305,1365
query| inside, inside of a
|在查询内，

2004
00:56:15,480 --> 00:56:16,620
0,210 210,405 405,540 540,780 780,1140
query,| you have multiple queries
|你可以在总体调用查询内有多个查询，

2005
00:56:16,620 --> 00:56:18,620
0,165 165,440 670,1290 1290,1500 1500,2000
inside of overarching calling queries,|
|

2006
00:56:19,220 --> 00:56:19,970
0,105 105,225 225,345 345,540 540,750
and you would need this,|
你需要这个，|

2007
00:56:19,970 --> 00:56:20,345
0,135 135,210 210,270 270,330 330,375
because you want to be
因为你想要表达某些计算，

2008
00:56:20,345 --> 00:56:22,000
0,90 90,365 445,795 795,1065 1065,1655
able to express certain computations,|
|

2009
00:56:22,890 --> 00:56:23,690
0,260 260,350 350,500 500,665 665,800
it would be difficult to
如果没有这些嵌套查询，就很难表达某些计算，

2010
00:56:23,690 --> 00:56:25,025
0,165 165,330 330,750 750,1080 1080,1335
express certain computations without these

2011
00:56:25,025 --> 00:56:26,765
0,285 285,695 955,1320 1320,1590 1590,1740
nested queries,| without taking the
|除非取出数据，进行一些计算，

2012
00:56:26,765 --> 00:56:28,130
0,150 150,455 595,870 870,1005 1005,1365
data out, doing some computation|
|

2013
00:56:28,130 --> 00:56:28,925
0,210 210,315 315,450 450,570 570,795
and then putting it back
然后将其放回数据库系统中，

2014
00:56:28,925 --> 00:56:30,380
0,255 255,375 375,570 570,905 1225,1455
in the database system,| so
|所以，它允许我们把这些东西放在一起，

2015
00:56:30,380 --> 00:56:31,040
0,75 75,255 255,450 450,555 555,660
it allows us to put

2016
00:56:31,040 --> 00:56:32,800
0,135 135,330 330,615 615,980 1360,1760
these things together| to create
|创造出更复杂的逻辑，

2017
00:56:33,150 --> 00:56:35,710
0,400 510,910 1320,1720 2040,2300 2300,2560
more complex logic,| than we
|而不是其他方式。

2018
00:56:35,760 --> 00:56:36,470
0,275 275,425 425,530 530,620 620,710
would not be able to

2019
00:56:36,470 --> 00:56:37,580
0,210 210,590
otherwise do.|
|

2020
00:56:37,800 --> 00:56:38,840
0,260 260,395 395,590 590,890 890,1040
And these inner queries can
这些内部查询几乎可以出现在 SELECT []中的任何地方，

2021
00:56:38,840 --> 00:56:40,580
0,290 400,800 850,1250 1360,1635 1635,1740
appear almost anywhere inside of

2022
00:56:40,580 --> 00:56:42,005
0,230 370,675 675,840 840,1100 1150,1425
a SELECT [],| but actually
|实际上，可以出现在任何查询，

2023
00:56:42,005 --> 00:56:43,520
0,275 295,600 600,935 1165,1425 1425,1515
really any query,| like you
|比如，你可以在 SELECT 输出， FROM 子句， WHERE 子句，

2024
00:56:43,520 --> 00:56:44,255
0,75 75,195 195,315 315,450 450,735
can have in the SELECT

2025
00:56:44,255 --> 00:56:45,350
0,285 285,450 450,630 630,900 900,1095
output, the FROM clause, the

2026
00:56:45,350 --> 00:56:46,700
0,165 165,500 880,1140 1140,1245 1245,1350
WHERE clause,| you can put
|你可以放入 UPDATE 查询和 DELETE 查询，

2027
00:56:46,700 --> 00:56:47,930
0,195 195,435 435,825 825,1035 1035,1230
an UPDATE queries and DELETE

2028
00:56:47,930 --> 00:56:49,720
0,500 760,1160
queries, right,|
|

2029
00:56:50,390 --> 00:56:51,355
0,290 290,425 425,545 545,740 740,965
and they can now reference
现在，它们可以引用你自己的查询中的所有表，

2030
00:56:51,355 --> 00:56:52,495
0,165 165,300 300,575 595,915 915,1140
all the tables within your

2031
00:56:52,495 --> 00:56:53,935
0,165 165,455 925,1215 1215,1275 1275,1440
own query,| it's a very
|这是一个非常强大的[构造]。

2032
00:56:53,935 --> 00:56:55,680
0,335 475,875
powerful construct.|
|

2033
00:56:55,680 --> 00:56:56,445
0,210 210,285 285,495 495,690 690,765
So the basic idea is
所以基本的想法是这样的，

2034
00:56:56,445 --> 00:56:57,560
0,135 135,285 285,540 540,825 825,1115
something like this,| so here
|这里，我们做 SELECT FROM student 表，

2035
00:56:57,610 --> 00:56:58,785
0,275 275,440 440,790 810,1070 1070,1175
we're doing SELECT FROM the

2036
00:56:58,785 --> 00:57:00,540
0,165 165,485 1015,1290 1290,1530 1530,1755
student table| and then I
|然后我想要获取学生的姓名，

2037
00:57:00,540 --> 00:57:02,910
0,105 105,210 210,470 2020,2250 2250,2370
want to get the name

2038
00:57:02,910 --> 00:57:03,840
0,120 120,240 240,530 550,810 810,930
of a student,| that is
|他至少注册了一门课程。

2039
00:57:03,840 --> 00:57:05,100
0,105 105,225 225,780 780,1050 1050,1260
at least enrolled in one

2040
00:57:05,100 --> 00:57:06,915
0,320 640,1040 1360,1605 1605,1710 1710,1815
course.| So you can think
|所以你可以想到，

2041
00:57:06,915 --> 00:57:08,250
0,105 105,315 315,600 600,935 1045,1335
of,| this out, this SELECT
|这是上面部分的 SELECT ，

2042
00:57:08,250 --> 00:57:09,090
0,180 180,330 330,465 465,630 630,840
[] in the top part,|
|

2043
00:57:09,090 --> 00:57:10,100
0,255 255,375 375,495 495,660 660,1010
that's called the Outer Query,|
称为外部查询，|

2044
00:57:10,330 --> 00:57:11,520
0,260 260,520 570,845 845,1010 1010,1190
and then this inner part
然后这个内部部分，我们称之为内部查询。

2045
00:57:11,520 --> 00:57:12,150
0,165 165,285 285,390 390,495 495,630
here, we would call this

2046
00:57:12,150 --> 00:57:13,260
0,180 180,500
Inner Query.|
|

2047
00:57:13,670 --> 00:57:14,820
0,400
So,
所以，众所周知，数据库系统很难优化嵌套查询，

2048
00:57:14,950 --> 00:57:17,520
0,485 485,860 860,1150 1410,2260 2280,2570
nested queries are notoriously difficult

2049
00:57:17,520 --> 00:57:18,860
0,150 150,375 375,675 675,930 930,1340
for database systems to optimize,|
|

2050
00:57:21,070 --> 00:57:22,005
0,260 260,380 380,530 530,725 725,935
because you think about the
因为你认为执行此查询最愚蠢的方法是，

2051
00:57:22,005 --> 00:57:22,965
0,300 300,405 405,600 600,810 810,960
stupidest way to execute this

2052
00:57:22,965 --> 00:57:24,390
0,210 210,375 375,635 955,1215 1215,1425
query would be,| for every
|对于我的 student 表中的每个 tuple ，重新运行这个东西，

2053
00:57:24,390 --> 00:57:25,920
0,300 300,705 705,900 900,1190 1210,1530
single tuple in my student

2054
00:57:25,920 --> 00:57:28,220
0,320 760,1275 1275,1530 1530,1850
table, rerun this thing,|
|

2055
00:57:29,040 --> 00:57:29,795
0,260 260,380 380,500 500,605 605,755
get the list of all
获取所有 sid 的列表，然后计算 IN ，

2056
00:57:29,795 --> 00:57:31,265
0,180 180,315 315,845 865,1170 1170,1470
the student ids, then compute

2057
00:57:31,265 --> 00:57:32,220
0,120 120,365
the IN,|
|

2058
00:57:32,510 --> 00:57:33,595
0,245 245,365 365,500 500,760 810,1085
the way to really execute
真正执行此操作的方法是，

2059
00:57:33,595 --> 00:57:34,435
0,150 150,390 390,615 615,720 720,840
this is,| this is just
|这只是 JOIN ，对于这里的例子，

2060
00:57:34,435 --> 00:57:35,640
0,165 165,455 595,840 840,945 945,1205
a JOIN, for this one

2061
00:57:35,810 --> 00:57:38,140
0,335 335,670
example here,|
|

2062
00:57:38,140 --> 00:57:39,145
0,255 255,450 450,600 600,780 780,1005
this one's easy to do,|
这个很容易做，|

2063
00:57:39,145 --> 00:57:41,290
0,365 475,875 1705,1935 1935,2010 2010,2145
because, {} you know, you're
因为，你在寻找这个东西来匹配这里的东西，

2064
00:57:41,290 --> 00:57:42,310
0,135 135,315 315,570 570,840 840,1020
looking for this, this thing

2065
00:57:42,310 --> 00:57:43,825
0,150 150,330 330,615 615,980 1270,1515
to match something here,| so
|所以，你可以将其转换为[质量]谓词，

2066
00:57:43,825 --> 00:57:45,025
0,90 90,210 210,485 835,1080 1080,1200
you can do convert that

2067
00:57:45,025 --> 00:57:46,660
0,105 105,210 210,435 435,995 1315,1635
to a [quality] predicate,| things
|事情会变得更加复杂，

2068
00:57:46,660 --> 00:57:48,390
0,180 180,330 330,620 850,1155 1155,1730
get more complicated,| when there's
|当内部查询和外部查询之间存在非平凡的关系时，

2069
00:57:48,950 --> 00:57:50,245
0,350 350,680 680,935 935,1190 1190,1295
{non-trivial -} relations between the

2070
00:57:50,245 --> 00:57:51,180
0,135 135,315 315,405 405,465 465,935
inner query and the {outer,query},|
|

2071
00:57:51,380 --> 00:57:53,095
0,260 260,610 840,1220 1220,1520 1520,1715
we won't, we'll, we'll come
我们会在本学期晚些时候讨论这个，

2072
00:57:53,095 --> 00:57:53,695
0,120 120,240 240,405 405,525 525,600
into that later in the

2073
00:57:53,695 --> 00:57:54,860
0,270 270,635
semester,| but,
|但是，这是数据库系统中最难的部分，

2074
00:57:55,420 --> 00:57:58,430
0,275 275,425 425,700 2460,2735 2735,3010
this is something, {this,is} the

2075
00:57:58,690 --> 00:58:00,810
0,490 600,875 875,1085 1085,1420 1800,2120
{hardest,part} of database systems| and
|唯一正确嵌套查询的系统是名为 Umbra 的系统，

2076
00:58:00,810 --> 00:58:02,060
0,180 180,435 435,735 735,945 945,1250
the only system that does

2077
00:58:02,500 --> 00:58:04,290
0,275 275,395 395,650 650,970 1440,1790
{nested -} queries correctly is

2078
00:58:04,290 --> 00:58:06,045
0,225 225,435 435,660 660,1160 1510,1755
the system called Umbra,| which
|这是德国的一个学术系统，

2079
00:58:06,045 --> 00:58:08,430
0,105 105,365 1675,2010 2010,2235 2235,2385
is a academic system out

2080
00:58:08,430 --> 00:58:11,490
0,120 120,380 2020,2550 2550,2805 2805,3060
of Germany,| {DuckDB -} does
|DuckDB 现在做得很正确，

2081
00:58:11,490 --> 00:58:12,945
0,210 210,495 495,860 1030,1305 1305,1455
it correctly now,| for two
|原因有两个，

2082
00:58:12,945 --> 00:58:14,600
0,275 325,675 675,915 915,1125 1125,1655
reasons,| one, because they copied
|一是因为他们复制了 Umbra 所做的，

2083
00:58:14,620 --> 00:58:15,480
0,400
what

2084
00:58:15,480 --> 00:58:16,850
0,375 375,650 700,975 975,1095 1095,1370
Umbra did,| it in papers,
|它在论文上，并不是说他们偷走了创意，

2085
00:58:17,200 --> 00:58:17,940
0,275 275,350 350,455 455,560 560,740
it's not like they stole

2086
00:58:17,940 --> 00:58:19,695
0,150 150,440 1240,1500 1500,1620 1620,1755
the ideas,| and then we
|然后我们上个学期 721 课程之后也给他们发了补丁，

2087
00:58:19,695 --> 00:58:20,535
0,135 135,240 240,360 360,690 690,840
also sent them patches last

2088
00:58:20,535 --> 00:58:21,300
0,225 225,360 360,450 450,585 585,765
semester out of {721 -

2089
00:58:21,300 --> 00:58:22,185
0,225 225,405 405,540 540,720 720,885
-},| so we fixed it
|所以我们为他们修复了它，

2090
00:58:22,185 --> 00:58:23,660
0,135 135,395 775,1050 1050,1200 1200,1475
for them,| they can do
|他们可以正确地执行其中一些嵌套查询，

2091
00:58:23,890 --> 00:58:24,750
0,245 245,320 320,410 410,560 560,860
some of these nested queries

2092
00:58:24,750 --> 00:58:27,930
0,290 730,1020 1020,1320 1320,1700 2890,3180
correctly with {[] -},| {DuckDB
|DuckDB 可能是对这一点的最好模仿，

2093
00:58:27,930 --> 00:58:28,590
0,195 195,300 300,450 450,570 570,660
-} is probably the best

2094
00:58:28,590 --> 00:58:29,910
0,390 390,540 540,800 940,1200 1200,1320
imitation of this,| a lot
|很多时候，有一堆启发式的 hack ，

2095
00:58:29,910 --> 00:58:30,450
0,120 120,270 270,435 435,465 465,540
of times there's a bunch

2096
00:58:30,450 --> 00:58:32,970
0,105 105,620 1030,1670 1960,2295 2295,2520
of heuristics hacks,| again, we'll
|同样，我们将在稍后讨论这个问题。

2097
00:58:32,970 --> 00:58:33,960
0,120 120,270 270,530
cover this later.|
|

2098
00:58:34,910 --> 00:58:35,725
0,275 275,470 470,590 590,725 725,815
{MySQL -} was always the
MySQL 总是最差的，

2099
00:58:35,725 --> 00:58:36,805
0,245 325,645 645,765 765,930 930,1080
worst,| it's gotten much better
|不过，情况已经好多了。

2100
00:58:36,805 --> 00:58:40,390
0,275 1705,2105 3115,3405 3405,3465 3465,3585
though.| So here's a query
|所以这里有一个类似这样的查询，

2101
00:58:40,390 --> 00:58:41,035
0,135 135,330 330,510 510,600 600,645
like this,| we want to
|我们想要得到在 15-445 注册的学生的名字，

2102
00:58:41,035 --> 00:58:41,635
0,60 60,165 165,330 330,480 480,600
get the name of the

2103
00:58:41,635 --> 00:58:43,000
0,240 240,525 525,825 825,1140 1140,1365
students enrolled in {15-445 -

2104
00:58:43,000 --> 00:58:44,310
0,180 180,470 760,990 990,1065 1065,1310
- -},| so we have
|所以我们有一个外部查询，

2105
00:58:44,330 --> 00:58:45,910
0,260 260,470 470,850 1200,1460 1460,1580
the outer query,| that we
|我们说我们想要从学生表中获得名字，

2106
00:58:45,910 --> 00:58:46,735
0,260 310,570 570,675 675,750 750,825
say we want to get

2107
00:58:46,735 --> 00:58:47,380
0,75 75,210 210,360 360,480 480,645
the name from the student

2108
00:58:47,380 --> 00:58:48,610
0,290 670,930 930,1050 1050,1155 1155,1230
table| and then we want
|然后我们想要这个 WHERE 子句，

2109
00:58:48,610 --> 00:58:49,375
0,60 60,135 135,270 270,495 495,765
to have this WHERE clause,|
|

2110
00:58:49,375 --> 00:58:50,335
0,150 150,225 225,330 330,765 765,960
we want to specify the
我们想要指定一个逻辑，

2111
00:58:50,335 --> 00:58:51,850
0,275 475,875 895,1200 1200,1365 1365,1515
logic,| that will get us
|它会让我们得到参加 445 课程的那组人的 sid ，

2112
00:58:51,850 --> 00:58:53,665
0,240 240,450 450,710 1300,1620 1620,1815
the student id of the

2113
00:58:53,665 --> 00:58:54,235
0,120 120,210 210,330 330,450 450,570
set of people that are

2114
00:58:54,235 --> 00:58:55,840
0,275 475,735 735,900 900,1205 1375,1605
taking {445 - -},| so
|所以这是一种思考方式，

2115
00:58:55,840 --> 00:58:56,335
0,45 45,105 105,210 210,360 360,495
this is a way to

2116
00:58:56,335 --> 00:58:56,965
0,90 90,195 195,330 330,480 480,630
sort of think about,| how
|你想要如何实际构建它，

2117
00:58:56,965 --> 00:58:57,955
0,120 120,270 270,540 540,795 795,990
you want actually construct this,|
|

2118
00:58:57,955 --> 00:58:58,645
0,150 150,240 240,315 315,465 465,690
start with the outer query|
从外部查询开始，|

2119
00:58:58,645 --> 00:59:00,790
0,120 120,225 225,330 330,935 1615,2145
of what the overarching computation
你希望输出的总体计算是什么，

2120
00:59:00,790 --> 00:59:01,450
0,120 120,285 285,465 465,555 555,660
of the output you want

2121
00:59:01,450 --> 00:59:02,455
0,105 105,350 550,795 795,885 885,1005
to be| and then you
|然后得到内部部分单独需要的是什么。

2122
00:59:02,455 --> 00:59:03,400
0,150 150,330 330,525 525,720 720,945
figure out what the inner

2123
00:59:03,400 --> 00:59:05,040
0,225 225,405 405,525 525,770 1000,1640
part needs to be separately.|
|

2124
00:59:05,650 --> 00:59:06,435
0,215 215,260 260,365 365,545 545,785
So in this case here,|
在本例中，|

2125
00:59:06,435 --> 00:59:07,530
0,180 180,360 360,585 585,825 825,1095
we can convert this English
我们可以将这里的英语部分转换为这样的查询，

2126
00:59:07,530 --> 00:59:10,185
0,225 225,530 670,1070 1240,1640 2350,2655
part here into a query

2127
00:59:10,185 --> 00:59:11,565
0,150 150,425 805,1065 1065,1230 1230,1380
like this,| but now we
|但现在我们需要引用它，

2128
00:59:11,565 --> 00:59:11,940
0,75 75,135 135,180 180,255 255,375
need to be able to

2129
00:59:11,940 --> 00:59:14,565
0,225 225,590 940,1340 1780,2180 2320,2625
reference it| or do the
|或执行我们想要的检查，

2130
00:59:14,565 --> 00:59:15,780
0,180 180,300 300,420 420,695 955,1215
check that we want,| in
|在外部查询的 WHERE 子句中，

2131
00:59:15,780 --> 00:59:16,425
0,105 105,240 240,450 450,570 570,645
the WHERE clause of the

2132
00:59:16,425 --> 00:59:17,940
0,165 165,515 865,1140 1140,1290 1290,1515
outer query| and we use
|并使用之前的 IN 子句。

2133
00:59:17,940 --> 00:59:19,470
0,350 400,735 735,915 915,1220 1270,1530
that IN clause that we

2134
00:59:19,470 --> 00:59:20,500
0,120 120,380
had before.|
|

2135
00:59:21,560 --> 00:59:22,560
0,230 230,320 320,470 470,680 680,1000
So in this case here,|
所以在这个例子中，|

2136
00:59:23,360 --> 00:59:24,385
0,320 320,515 515,665 665,800 800,1025
now we see that the
现在我们看到这个 sid ，

2137
00:59:24,385 --> 00:59:26,640
0,255 255,545 775,1095 1095,1415
student id in the,|
|

2138
00:59:26,640 --> 00:59:27,690
0,210 210,450 450,720 720,930 930,1050
in this WHERE clause, here
在外部查询中的 WHERE 子句中，

2139
00:59:27,690 --> 00:59:28,560
0,75 75,150 150,285 285,540 540,870
are the outer query,| that's
|它引用外部查询中的 sid ，

2140
00:59:28,560 --> 00:59:29,760
0,375 375,525 525,660 660,915 915,1200
referencing the student id from

2141
00:59:29,760 --> 00:59:31,200
0,270 270,495 495,660 660,1010 1180,1440
the the outer query,| but
|但第二个在内部查询中的 sid ，

2142
00:59:31,200 --> 00:59:32,235
0,150 150,405 405,645 645,855 855,1035
the second student id in

2143
00:59:32,235 --> 00:59:33,645
0,90 90,240 240,575 655,1035 1035,1410
the inner query,| that's referencing
|引用 enrolled 表中的 sid 。

2144
00:59:33,645 --> 00:59:34,710
0,150 150,285 285,545 595,870 870,1065
the student id in the,

2145
00:59:34,710 --> 00:59:35,940
0,315 315,630 630,795 795,900 900,1230
in the, in the enrolled

2146
00:59:35,940 --> 00:59:36,840
0,320
table.|
|

2147
00:59:36,840 --> 00:59:39,045
0,330 330,680 820,1460 1630,1995 1995,2205
So the parser in the
所以，数据库系统中的解析器足够智能，

2148
00:59:39,045 --> 00:59:39,930
0,150 150,360 360,585 585,765 765,885
database system is smart enough|
|

2149
00:59:39,930 --> 00:59:41,655
0,105 105,350 850,1140 1140,1430 1450,1725
to recognize the context of
能够识别列被引用的上下文，

2150
00:59:41,655 --> 00:59:42,735
0,225 225,495 495,735 735,915 915,1080
where a column is being

2151
00:59:42,735 --> 00:59:45,110
0,545 625,930 930,1235 1555,1955 1975,2375
referenced| to know which table
|从而知道你正在查看的是哪个表，

2152
00:59:45,430 --> 00:59:46,740
0,320 320,455 455,760
you're looking at,|
|

2153
00:59:46,780 --> 00:59:48,030
0,245 245,335 335,545 545,910 990,1250
in the cases where it
在它不知道的情况下，

2154
00:59:48,030 --> 00:59:49,860
0,240 240,465 465,830 1360,1650 1650,1830
doesn't know,| that two things
|两个事物具有相同名称，

2155
00:59:49,860 --> 00:59:51,075
0,135 135,240 240,390 390,680 790,1215
have the same name,| it'll
|它将抛出一个错误，

2156
00:59:51,075 --> 00:59:52,350
0,150 150,270 270,420 420,725 1015,1275
throw an error| and make
|并使你限定列所在的表名。

2157
00:59:52,350 --> 00:59:54,680
0,135 135,680 1510,1800 1800,2010 2010,2330
you qualify the table name

2158
00:59:54,880 --> 00:59:55,935
0,305 305,530 530,740 740,890 890,1055
where a column is coming

2159
00:59:55,935 --> 00:59:56,840
0,305
from.|
|

2160
00:59:58,820 --> 00:59:59,560
0,275 275,440 440,485 485,575 575,740
So there's a bunch different
所以，你可以通过多种不同的方式与嵌套查询进行交互，

2161
00:59:59,560 --> 01:00:00,775
0,210 210,465 465,765 765,1005 1005,1215
ways you can interact with

2162
01:00:00,775 --> 01:00:02,545
0,330 330,725 1165,1455 1455,1620 1620,1770
nested queries,| you can set
|你可以设置 WHERE 子句，

2163
01:00:02,545 --> 01:00:04,150
0,180 180,725 1105,1380 1380,1500 1500,1605
WHERE clauses,| so you can
|你可以有 ALL 命令或 ALL 操作符，

2164
01:00:04,150 --> 01:00:05,500
0,210 210,480 480,800 820,1095 1095,1350
have things like an ALL

2165
01:00:05,500 --> 01:00:07,225
0,300 300,465 465,710 730,1130 1360,1725
command or ALL operator,| that
|嵌套查询中的每一行都必须满足某种约束，

2166
01:00:07,225 --> 01:00:08,605
0,365 415,780 780,1080 1080,1275 1275,1380
that every row in the

2167
01:00:08,605 --> 01:00:09,715
0,240 240,405 405,570 570,705 705,1110
nested query has to satisfy

2168
01:00:09,715 --> 01:00:11,245
0,225 225,405 405,495 495,935 1285,1530
some kind of restraint,| you
|你可以有 ANY ，

2169
01:00:11,245 --> 01:00:12,500
0,90 90,210 210,485
can have ANY,|
|

2170
01:00:12,500 --> 01:00:14,045
0,260 340,675 675,960 960,1290 1290,1545
or sometimes called SOME is
或者有时称为 SOME ，它是别名， SOME ，

2171
01:00:14,045 --> 01:00:16,385
0,120 120,575 1225,1865 2005,2250 2250,2340
the alias, SOME,| where you
|你可以说至少有一行与我的子查询匹配，

2172
01:00:16,385 --> 01:00:17,765
0,120 120,395 745,990 990,1140 1140,1380
can say at least one

2173
01:00:17,765 --> 01:00:19,750
0,335 985,1305 1305,1515 1515,1680 1680,1985
row match my sub query,|
|

2174
01:00:20,190 --> 01:00:21,770
0,245 245,425 425,785 785,1180 1320,1580
the IN clause is that
IN 子句是我之前展示过的，

2175
01:00:21,770 --> 01:00:22,460
0,120 120,225 225,390 390,600 600,690
I showed before,| it's the
|它等同于 ANY ，

2176
01:00:22,460 --> 01:00:23,960
0,135 135,270 270,510 510,890 1150,1500
same thing as is equals

2177
01:00:23,960 --> 01:00:25,775
0,350 850,1110 1110,1335 1335,1620 1620,1815
ANY| and then EXISTS,| just
|然后是 EXISTS ，|意思是我想要找到，

2178
01:00:25,775 --> 01:00:26,870
0,195 195,515 655,915 915,1005 1005,1095
means that I want to

2179
01:00:26,870 --> 01:00:28,070
0,135 135,330 330,650 700,990 990,1200
find something,| where I know
|我知道至少有一个匹配的东西，

2180
01:00:28,070 --> 01:00:29,300
0,390 390,735 735,870 870,1035 1035,1230
there's there's at least one

2181
01:00:29,300 --> 01:00:31,115
0,290 610,1010 1120,1485 1485,1620 1620,1815
match,| sorry, there's just one
|抱歉，只有一行返回，

2182
01:00:31,115 --> 01:00:32,000
0,195 195,420 420,660 660,810 810,885
row being return,| but I
|但我并不关心里面有什么。

2183
01:00:32,000 --> 01:00:32,780
0,180 180,330 330,480 480,705 705,780
don't actually care what's in

2184
01:00:32,780 --> 01:00:33,380
0,260
it.|
|

2185
01:00:35,300 --> 01:00:36,600
0,290 290,440 440,545 545,905 905,1300
So I can rewrite the
所以我可以重写我之前的例子，

2186
01:00:37,010 --> 01:00:37,900
0,275 275,380 380,455 455,680 680,890
example I have before,| instead
|不是使用 IN ，我可以使用 ANY ，

2187
01:00:37,900 --> 01:00:39,055
0,60 60,210 210,530 760,1020 1020,1155
of using IN, I can

2188
01:00:39,055 --> 01:00:40,900
0,275 415,815 985,1275 1275,1560 1560,1845
use ANY| and it's considered
|它被认为是等价的。

2189
01:00:40,900 --> 01:00:41,920
0,380
equivalent.|
|

2190
01:00:42,590 --> 01:00:43,645
0,245 245,490 540,785 785,890 890,1055
And so we can show
所以，我们可以很快地展示，

2191
01:00:43,645 --> 01:00:45,625
0,165 165,360 360,695 1285,1755 1755,1980
real quickly,| how postgres picks
|Postgres 是如何为此选择不同的计划的，

2192
01:00:45,625 --> 01:00:47,215
0,165 165,390 390,540 540,785 1345,1590
different plans for this,| and
|你可以看到实际它是如何执行的。

2193
01:00:47,215 --> 01:00:47,890
0,120 120,240 240,330 330,540 540,675
you see how it's actually

2194
01:00:47,890 --> 01:00:49,220
0,195 195,620
being executed.|
|

2195
01:00:49,540 --> 01:00:50,800
0,230

2196
01:00:57,510 --> 01:00:58,510
0,320 320,485 485,635 635,710 710,1000
Right, so here's our query,|
好的，这是我们的查询，|

2197
01:01:00,010 --> 01:01:00,930
0,245 245,350 350,500 500,650 650,920
we have RZA and Tupac
我们有 RZA 和 Tupac 选择了课程，

2198
01:01:00,930 --> 01:01:03,300
0,165 165,300 300,560 1840,2145 2145,2370
taking the class,| so in
|所以在 SQL 中，

2199
01:01:03,300 --> 01:01:04,410
0,435 435,630 630,750 750,870 870,1110
SQL,| you can put this
|你可以把这个 EXPLAIN 关键字放在它前面，

2200
01:01:04,410 --> 01:01:05,415
0,330 330,660 660,780 780,900 900,1005
EXPLAIN keyword in front of

2201
01:01:05,415 --> 01:01:07,040
0,245 655,945 945,1110 1110,1290 1290,1625
it| and of any query|
|放在任何查询前面，|

2202
01:01:07,480 --> 01:01:08,355
0,275 275,410 410,680 680,755 755,875
and what that's going to
它会执行，

2203
01:01:08,355 --> 01:01:09,795
0,275 505,780 780,900 900,1140 1140,1440
do,| if the system supports
|如果系统支持它，

2204
01:01:09,795 --> 01:01:10,980
0,180 180,495 495,645 645,905 925,1185
it,| it'll come back with
|它会返回查询计划，

2205
01:01:10,980 --> 01:01:12,195
0,135 135,375 375,710 850,1110 1110,1215
the query plan| and tell
|告诉你它会执行什么操作，

2206
01:01:12,195 --> 01:01:14,850
0,135 135,425 1195,1595 2215,2445 2445,2655
you what operations would it

2207
01:01:14,850 --> 01:01:16,290
0,380 490,750 750,930 930,1215 1215,1440
execute,| if it actually tried
|如果它试图执行这个东西。

2208
01:01:16,290 --> 01:01:17,520
0,165 165,345 345,495 495,770
to execute this thing,

2209
01:01:17,530 --> 01:01:18,640
0,400
right.|
|

2210
01:01:19,510 --> 01:01:20,295
0,245 245,320 320,395 395,530 530,785
So when we run that,|
所以当我们运行它时，|

2211
01:01:20,295 --> 01:01:21,260
0,225 225,360 360,525 525,690 690,965
we get something like this,|
我们会得到类似这样的东西，|

2212
01:01:21,670 --> 01:01:22,760
0,530 530,590 590,695 695,830 830,1090
that's going to tell us
它会告诉我们基本上是一个树形结构，

2213
01:01:23,080 --> 01:01:24,710
0,400 780,1025 1025,1145 1145,1325 1325,1630
basically as a tree structure,|
|

2214
01:01:25,060 --> 01:01:26,055
0,400 420,695 695,800 800,860 860,995
so these are the leaf
所以这些是叶节点，

2215
01:01:26,055 --> 01:01:27,075
0,450 450,615 615,720 720,825 825,1020
nodes| and then it builds
|然后它建立了这个最终输出，

2216
01:01:27,075 --> 01:01:28,160
0,135 135,315 315,450 450,690 690,1085
up this the final output,|
|

2217
01:01:28,360 --> 01:01:29,480
0,335 335,545 545,680 680,830 830,1120
so this is telling us,|
所以这告诉我们，|

2218
01:01:29,890 --> 01:01:31,020
0,350 350,560 560,635 635,695 695,1130
Postgres wants to do aential
Postgres 想要对 enrolled 表进行强制扫描，

2219
01:01:31,020 --> 01:01:32,685
0,225 225,390 390,660 660,920 1420,1665
scan the enrolled table| and
|然后它会对它进行散列，

2220
01:01:32,685 --> 01:01:33,360
0,105 105,285 285,345 345,435 435,675
then it's going to hash

2221
01:01:33,360 --> 01:01:34,635
0,260 490,840 840,1080 1080,1170 1170,1275
it,| because it's doing a
|因为它在那里进行散列，

2222
01:01:34,635 --> 01:01:35,505
0,195 195,300 300,405 405,585 585,870
hash one up there,| which
|我们稍后会讨论什么是散列，

2223
01:01:35,505 --> 01:01:36,450
0,270 270,390 390,525 525,780 780,945
we'll cover what hash is

2224
01:01:36,450 --> 01:01:38,120
0,165 165,470 790,1035 1035,1275 1275,1670
later on,| and then does
|然后扫描 student 表，

2225
01:01:38,470 --> 01:01:39,800
0,380 380,650 650,830 830,1025 1025,1330
scan on the student table|
|

2226
01:01:40,210 --> 01:01:41,985
0,245 245,350 350,575 575,940 1500,1775
and then now does by
然后通过匹配 sid ，

2227
01:01:41,985 --> 01:01:45,150
0,315 315,435 435,555 555,815 2905,3165
matching the student id,| student
|sid 和 enrolled 的 sid 。

2228
01:01:45,150 --> 01:01:46,430
0,195 195,465 465,840 840,1020 1020,1280
id with enrolled student id.|
|

2229
01:01:46,750 --> 01:01:48,060
0,335 335,800 800,1010 1010,1190 1190,1310
So Postgres was smart enough|
所以 Postgres 足够聪明，|

2230
01:01:48,060 --> 01:01:49,540
0,195 195,480 480,830
to convert this
转换这个嵌套查询到 JOIN ，

2231
01:01:49,950 --> 01:01:51,635
0,485 485,785 785,1175 1175,1460 1460,1685
nested query into a JOIN,|
|这始终是执行某些操作的最快方式，

2232
01:01:51,635 --> 01:01:52,520
0,195 195,450 450,705 705,810 810,885
which is always going to

2233
01:01:52,520 --> 01:01:53,405
0,120 120,270 270,615 615,735 735,885
be the fastest way to

2234
01:01:53,405 --> 01:01:54,965
0,195 195,485 1135,1380 1380,1470 1470,1560
execute something,| when you have
|当你拥有这些类型的引用时。

2235
01:01:54,965 --> 01:01:56,740
0,120 120,225 225,300 300,815
these kind of references.|
|

2236
01:01:57,010 --> 01:01:57,780
0,245 245,350 350,485 485,620 620,770
We can try the same
我们可以在 MySQL 中尝试相同的操作，

2237
01:01:57,780 --> 01:01:59,400
0,195 195,345 345,480 480,890
thing in {MySQL -},|
|

2238
01:02:06,410 --> 01:02:07,885
0,245 245,335 335,580 870,1205 1205,1475
but you get their explained
但你得到，他们解释的输出很糟糕，

2239
01:02:07,885 --> 01:02:10,735
0,180 180,285 285,545 2485,2760 2760,2850
output is terrible,| there's a
|有一种方法可以得到，

2240
01:02:10,735 --> 01:02:13,180
0,165 165,285 285,515 2005,2295 2295,2445
way to get,| I forget
|我忘记了语法，

2241
01:02:13,180 --> 01:02:14,140
0,120 120,510 510,705 705,825 825,960
the syntax,| you gotta put
|你必须放入一个 EXTENDED 或类似的东西，

2242
01:02:14,140 --> 01:02:15,160
0,105 105,345 345,675 675,870 870,1020
like an EXTENDED or something

2243
01:02:15,160 --> 01:02:16,260
0,150 150,410
like that,|
|

2244
01:02:17,170 --> 01:02:17,820
0,290 290,425 425,500 500,575 575,650
I forget how to do
我忘记了如何在 MySQL 中这样做，

2245
01:02:17,820 --> 01:02:18,495
0,90 90,195 195,300 300,525 525,675
it in {MySQL -},| there's
|有一种方法可以让事情变得更好。

2246
01:02:18,495 --> 01:02:19,530
0,45 45,135 135,240 240,485 745,1035
a way to get something

2247
01:02:19,530 --> 01:02:21,740
0,120 120,195 195,315 315,590
a little bit better.|
|

2248
01:02:22,200 --> 01:02:23,750
0,400 420,830 830,1120 1385,1475 1475,1550
In {SQLite -}, I don't
在 SQLite 中，我不认为你可以做到这个，

2249
01:02:23,750 --> 01:02:24,520
0,90 90,210 210,360 360,510 510,770
think you can do this,|
|

2250
01:02:25,170 --> 01:02:26,600
0,245 245,350 350,485 485,760
you can do this,|
你可以做到，|

2251
01:02:30,180 --> 01:02:31,540
0,315 315,710

2252
01:02:32,165 --> 01:02:33,160
0,60 60,305
what's that,|
那是什么，|

2253
01:02:34,890 --> 01:02:37,480
0,400

2254
01:02:38,370 --> 01:02:40,680
0,245 245,490 1110,1445 1445,1690
all right, {SQLite -},|
好的， SQLite ，|

2255
01:02:43,660 --> 01:02:44,610
0,245 245,395 395,515 515,710 710,950
they don't like the SELECT
他们不喜欢 SELECT 语句，

2256
01:02:44,610 --> 01:02:46,740
0,320
statement,|
|

2257
01:02:48,640 --> 01:02:50,175
0,260 260,470 470,820 1080,1340 1340,1535
which is surprising,| why doesn't
这是令人惊讶的，|为什么这不管用。

2258
01:02:50,175 --> 01:02:51,345
0,105 105,365 745,960 960,1035 1035,1170
that work.| See if {DuckDB
|看看 DuckDB 是否能做到这个，

2259
01:02:51,345 --> 01:02:52,800
0,180 180,300 300,575
-} does it,|
|

2260
01:02:53,550 --> 01:02:54,710
0,260 260,365 365,485 485,760 870,1160
it give the output,| DuckDB
它给出输出，|DuckDB 有很漂亮的，

2261
01:02:54,710 --> 01:02:57,460
0,195 195,450 450,800
has very pretty,|
|

2262
01:02:57,470 --> 01:02:58,330
0,260 260,365 365,560 560,770 770,860
they give you, they give
它们给你漂亮的树，

2263
01:02:58,330 --> 01:03:04,345
0,90 90,210 210,390 390,710 5710,6015
you nice little trees,| {you,guys}
|你们很容易被逗乐，

2264
01:03:04,345 --> 01:03:08,095
0,180 180,405 405,875 2995,3360 3360,3750
are easily amused,| this impresses
|这给你留下了深刻的印象， unicode 输出，

2265
01:03:08,095 --> 01:03:10,330
0,270 270,900 900,1245 1245,1595 1975,2235
you, unicode output for,| oh
|我的天，

2266
01:03:10,330 --> 01:03:13,375
0,120 120,380 2230,2475 2475,2720 2800,3045
my gosh,| but yeah, it
|但是，是的，它你展示了什么是物理计划。

2267
01:03:13,375 --> 01:03:14,905
0,245 985,1275 1275,1380 1380,1440 1440,1530
gives, shows you what the

2268
01:03:14,905 --> 01:03:17,910
0,180 180,390 390,665 2485,2745 2745,3005
physical plan is.| And then
|然后，我们可以在 Oracle 上尝试，

2269
01:03:19,190 --> 01:03:19,840
0,260 260,380 380,470 470,530 530,650
we can try it on

2270
01:03:19,840 --> 01:03:21,320
0,530
Oracle,|
|

2271
01:03:22,640 --> 01:03:23,970
0,400 420,695 695,815 815,995 995,1330
right, has the right output,|
好的，有正确的输出，|

2272
01:03:27,710 --> 01:03:29,845
0,400 1080,1480 1590,1850 1850,1940 1940,2135
{} well, we need this
好吧，我们其他时间再看这个，

2273
01:03:29,845 --> 01:03:31,630
0,225 225,345 345,665 1285,1590 1590,1785
another time,| there's getting the
|获得 Oracle 和 SQL Server 的计划是一个巨大的痛苦。

2274
01:03:31,630 --> 01:03:32,770
0,165 165,420 420,690 690,1050 1050,1140
plan out of Oracle and

2275
01:03:32,770 --> 01:03:33,550
0,195 195,360 360,525 525,630 630,780
SQL Server is a huge

2276
01:03:33,550 --> 01:03:35,160
0,255 255,450 450,690 690,1040 1210,1610
pain.| But I'm surprised that,|
|但我对此感到惊讶，|

2277
01:03:36,870 --> 01:03:38,020
0,350 350,455 455,710 710,875 875,1150
{SQLite -} doesn't support this,|
SQLLite 不支持这个，|

2278
01:03:44,510 --> 01:03:45,175
0,305 305,365 365,440 440,485 485,665
I'm not going to debug
我不会现场调试，

2279
01:03:45,175 --> 01:03:46,880
0,150 150,425
this live,|
|

2280
01:03:48,150 --> 01:03:48,860
0,290 290,425 425,545 545,620 620,710
yeah, I don't know why
我不知道它为什么不喜欢那样，

2281
01:03:48,860 --> 01:03:49,865
0,60 60,225 225,330 330,590 700,1005
it doesn't like that,| let's
|让我们试试 IN ，

2282
01:03:49,865 --> 01:03:50,980
0,135 135,425
try IN,|
|

2283
01:03:55,030 --> 01:03:55,860
0,290 290,425 425,515 515,680 680,830
ah, there we go,| they
啊，来了，|他们不喜欢 ANY ，喜欢 IN 。

2284
01:03:55,860 --> 01:03:56,960
0,120 120,315 315,615 615,825 825,1100
didn't like ANY, like IN.|
|

2285
01:03:57,520 --> 01:03:59,205
0,305 305,610 1020,1295 1295,1460 1460,1685
Alright, so in {SQLite -},|
好的，在 SQLite 中，|

2286
01:03:59,205 --> 01:04:02,040
0,165 165,270 270,495 495,845
if I run EXPLAIN,|
如果我运行 EXPLAIN ，|

2287
01:04:04,670 --> 01:04:06,180
0,245 245,365 365,640
I get this,|
我得到这个，|

2288
01:04:08,910 --> 01:04:09,950
0,335 335,515 515,665 665,920 920,1040
so the way {SQLite -}
所以， SQLite 所做的方式，

2289
01:04:09,950 --> 01:04:11,300
0,210 210,390 390,650
does,| which is,
|是这样的，

2290
01:04:11,810 --> 01:04:14,000
0,470 470,695 695,970
[genius], is that,|
|

2291
01:04:15,230 --> 01:04:16,390
0,275 275,425 425,815 815,950 950,1160
the way itutes your query
它处理查询计划的方式是，

2292
01:04:16,390 --> 01:04:17,545
0,195 195,405 405,765 765,900 900,1155
plan,| it converts the query
|将查询计划转换为自己的 DSL 操作码，

2293
01:04:17,545 --> 01:04:20,070
0,270 270,605 1465,1740 1740,1950 1950,2525
plan into its own DSL

2294
01:04:20,480 --> 01:04:21,355
0,320 320,635 635,710 710,770 770,875
op codes,| and it has
|它有自己的虚拟机来运行操作码，

2295
01:04:21,355 --> 01:04:22,890
0,120 120,285 285,755 925,1230 1230,1535
its own vm that runs

2296
01:04:23,150 --> 01:04:25,150
0,350 350,850 1140,1400 1400,1535 1535,2000
the {op,codes},| like the JVM,|
|就像是 JVM ，|

2297
01:04:25,150 --> 01:04:26,290
0,240 240,450 450,735 735,930 930,1140
you take Java code, convert
你获取 Java 代码，将其转换为 Java 字节码，

2298
01:04:26,290 --> 01:04:27,390
0,105 105,315 315,645 645,840 840,1100
it into Java byte code,|
|

2299
01:04:27,500 --> 01:04:28,855
0,260 260,395 395,545 545,1010 1010,1355
and then the JVM executes
然后 JVM 执行它或解释它，

2300
01:04:28,855 --> 01:04:30,190
0,120 120,255 255,525 525,785 985,1335
it or interprets it,| that's
|这就是 SQLite 所做的。

2301
01:04:30,190 --> 01:04:32,300
0,90 90,300 300,435 435,710
what SQLite does.|
|

2302
01:04:32,300 --> 01:04:34,280
0,350 400,780 780,1070 1270,1575 1575,1980
{All,right}, we'll discuss query compilations
好的，我们将在本学期晚些时候讨论查询编译。

2303
01:04:34,280 --> 01:04:36,660
0,345 345,540 540,615 615,890
later in this semester.|
|

2304
01:04:36,930 --> 01:04:37,630
0,230 230,305 305,380 380,455 455,700
So you got to put
所以你把 EXPLAIN PLAN,

2305
01:04:37,830 --> 01:04:39,380
0,350 350,700
EXPLAIN PLAN,|
|

2306
01:04:41,090 --> 01:04:44,160
0,335 335,670 1740,2140
PLAN, that EXTENDED,|
PLAN ， EXTENDED ，|

2307
01:04:44,280 --> 01:04:45,335
0,335 335,485 485,845 845,980 980,1055
there's some syntax to get
有一些语法可以获得真正的计划，

2308
01:04:45,335 --> 01:04:46,595
0,90 90,240 240,545 565,965 985,1260
the real plan, whatever,| Trust
|相信我，它就在那里。

2309
01:04:46,595 --> 01:04:47,560
0,105 105,225 225,455 475,720 720,965
me, it's there.| All right,|
|好的，|

2310
01:04:51,390 --> 01:04:53,075
0,400 780,1100 1100,1340 1340,1535 1535,1685
so yeah, so they all
所以，是的，所以它们都做一些略有不同的事情，

2311
01:04:53,075 --> 01:04:55,280
0,135 135,390 390,705 705,1025 1945,2205
do something slightly different| and
|然后如果系统是智能的，

2312
01:04:55,280 --> 01:04:56,120
0,210 210,420 420,540 540,690 690,840
then if the system is

2313
01:04:56,120 --> 01:04:56,600
0,120 120,210 210,285 285,360 360,480
smart,| you can try to
|你可以尝试将其转换为 JOIN 。

2314
01:04:56,600 --> 01:04:57,880
0,135 135,225 225,470 760,1020 1020,1280
convert it into a JOIN.|
|

2315
01:04:59,960 --> 01:05:01,120
0,410 410,665 665,860 860,1025 1025,1160
So skip this and sake
所以跳过这段时间，

2316
01:05:01,120 --> 01:05:02,200
0,120 120,330 330,615 615,825 825,1080
a time,| because we got
|因为我们要完成，

2317
01:05:02,200 --> 01:05:05,000
0,210 210,300 300,560
to get through,|
|

2318
01:05:05,470 --> 01:05:06,110
0,230 230,290 290,335 335,395 395,640
I want to get through
我想完成 LATERAL JOIN 和 CTE 。

2319
01:05:06,130 --> 01:05:08,560
0,440 440,740 740,1030
LATERAL JOINs and
|

2320
01:05:09,040 --> 01:05:12,050
0,400 600,1150 1920,2180 2180,2525 2525,3010
and CTE.| So lateral joins
|横向连接是一个较新的概念，

2321
01:05:12,100 --> 01:05:15,050
0,400 540,940 1740,2105 2105,2380 2550,2950
are a newer concept,| but,
|但是，并不是所有的系统都会支持它，

2322
01:05:16,000 --> 01:05:16,855
0,180 180,330 330,510 510,705 705,855
and not all systems are

2323
01:05:16,855 --> 01:05:18,120
0,75 75,210 210,375 375,635 865,1265
going to support it,| but
|但基本的想法是，

2324
01:05:18,170 --> 01:05:19,470
0,275 275,550 600,860 860,1010 1010,1300
the basic idea is that,|
|

2325
01:05:19,610 --> 01:05:20,605
0,320 320,380 380,485 485,755 755,995
it's going to allow you
它将允许你拥有一个，

2326
01:05:20,605 --> 01:05:22,300
0,105 105,365 385,785
to have a,|
|

2327
01:05:22,300 --> 01:05:26,640
0,350 1300,1830 1830,2150 2680,3080 3940,4340
a nested query reference data
嵌套查询引用与其相邻的另一个查询中的数据。

2328
01:05:26,870 --> 01:05:30,000
0,400 540,940 1020,1420 1860,2290 2730,3130
in in another query that

2329
01:05:30,050 --> 01:05:32,220
0,350 350,920 920,1070 1070,1330 1770,2170
is adjacent to it.| So
|所以，通常情况下，

2330
01:05:32,390 --> 01:05:33,910
0,400 960,1190 1190,1265 1265,1385 1385,1520
normally,| if you have two
|如果你有两个嵌套查询，

2331
01:05:33,910 --> 01:05:35,590
0,255 255,710 970,1230 1230,1485 1485,1680
nested queries,| one nested query
|一个嵌套查询不能引用另一个嵌套查询中的内容，

2332
01:05:35,590 --> 01:05:36,625
0,255 255,450 450,780 780,930 930,1035
can't reference what's inside the

2333
01:05:36,625 --> 01:05:37,915
0,135 135,390 390,665 865,1110 1110,1290
other nested query,| because it
|因为它不知道其中的内容，

2334
01:05:37,915 --> 01:05:39,025
0,285 285,420 420,645 645,960 960,1110
doesn't know about what's inside

2335
01:05:39,025 --> 01:05:40,270
0,105 105,335 805,1050 1050,1140 1140,1245
of it,| but with a
|但是具有横向连接，

2336
01:05:40,270 --> 01:05:41,740
0,450 450,740
LATERAL JOIN,|
|

2337
01:05:41,840 --> 01:05:42,565
0,260 260,410 410,530 530,605 605,725
it allows you to do
它允许你这样做，

2338
01:05:42,565 --> 01:05:43,375
0,165 165,315 315,465 465,600 600,810
this,| you can almost think
|你可以认为这是一个 for 循环，

2339
01:05:43,375 --> 01:05:45,520
0,455 535,855 855,1080 1080,1385 1855,2145
it's a for loop,| where
|一张表，每一个外部 for 循环中的 tuple ，

2340
01:05:45,520 --> 01:05:46,980
0,225 225,560 730,975 975,1140 1140,1460
one table, for every single,

2341
01:05:47,270 --> 01:05:49,120
0,290 290,580
every single,

2342
01:05:49,190 --> 01:05:50,470
0,305 305,560 560,890 890,1145 1145,1280
every single tuple in the

2343
01:05:50,470 --> 01:05:51,760
0,260 340,645 645,825 825,1065 1065,1290
outer, outer for loop,| you
|你可以做一些查询，

2344
01:05:51,760 --> 01:05:53,050
0,150 150,375 375,710 940,1185 1185,1290
can do some, you can

2345
01:05:53,050 --> 01:05:53,815
0,165 165,330 330,510 510,645 645,765
run some query,| do some
|在这里做一些计算。

2346
01:05:53,815 --> 01:05:55,060
0,405 405,725
computation here.|
|

2347
01:05:55,410 --> 01:05:56,375
0,230 230,290 290,470 470,740 740,965
So in this simple example
所以在这个简单的例子中，我有两个两个嵌套的查询。我有一个SELECT 1作为X，所以这是返回一个2，它有一个值为1的列，然后我的横向连接现在可以引用这个第一个查询的输出，只需在它上加1。

2348
01:05:56,375 --> 01:05:59,390
0,305 1015,1275 1275,1470 1470,1805 2725,3015
here I have two two

2349
01:05:59,390 --> 01:06:00,620
0,165 165,285 285,710 970,1185 1185,1230
nest of queries. I have

2350
01:06:00,620 --> 01:06:01,715
0,120 120,315 315,510 510,780 780,1095
a select one as as

2351
01:06:01,715 --> 01:06:02,825
0,285 285,480 480,600 600,855 855,1110
X, so this is turning

2352
01:06:02,825 --> 01:06:03,500
0,150 150,270 270,420 420,585 585,675
back a single two that

2353
01:06:03,500 --> 01:06:04,190
0,105 105,285 285,480 480,615 615,690
has one column with a

2354
01:06:04,190 --> 01:06:06,050
0,165 165,500 880,1155 1155,1430 1510,1860
value one, and then my

2355
01:06:06,050 --> 01:06:08,345
0,435 435,630 630,950 1330,1730 1930,2295
lateral join here can now

2356
01:06:08,345 --> 01:06:10,895
0,365 745,1145 1705,2085 2085,2370 2370,2550
reference the the output of

2357
01:06:10,895 --> 01:06:12,425
0,195 195,435 435,705 705,1025 1255,1530
this first query here and

2358
01:06:12,425 --> 01:06:13,295
0,165 165,360 360,570 570,735 735,870
just do plus one on

2359
01:06:13,295 --> 01:06:13,840
0,275
it.|
|

2360
01:06:14,010 --> 01:06:15,070
0,350 350,530 530,605 605,755 755,1060
Right. So I get I
正确的。所以我知道我得到了一个和两个。

2361
01:06:15,120 --> 01:06:16,025
0,290 290,455 455,605 605,755 755,905
get one and two that

2362
01:06:16,025 --> 01:06:17,100
0,275
way.|
|

2363
01:06:17,830 --> 01:06:19,125
0,380 380,830 830,965 965,1175 1175,1295
Without lateral you can't do
如果没有横向，您将无法执行此操作，因为这将被视为两个完全独立的查询，我们可以在Postgres中执行此操作并快速查看。

2364
01:06:19,125 --> 01:06:20,700
0,275 865,1125 1125,1275 1275,1425 1425,1575
this because this would be

2365
01:06:20,700 --> 01:06:22,650
0,225 225,560 1210,1530 1530,1740 1740,1950
treated as completely two separate

2366
01:06:22,650 --> 01:06:24,225
0,470 970,1260 1260,1395 1395,1485 1485,1575
queries, which we can do

2367
01:06:24,225 --> 01:06:25,185
0,75 75,165 165,570 570,810 810,960
this in postgres and see

2368
01:06:25,185 --> 01:06:26,200
0,135 135,395
real quickly.|
|

2369
01:06:27,870 --> 01:06:29,720
0,400
Right.|
正确的。|

2370
01:06:30,840 --> 01:06:33,380
0,320 320,575 575,910 1140,1540
So select star from.|
因此，请选择星号。|

2371
01:06:33,980 --> 01:06:35,230
0,245 245,335 335,725 725,965 965,1250
In an intercase like one
在像AS这样的案件中。

2372
01:06:35,230 --> 01:06:36,500
0,380
as.|
|

2373
01:06:39,960 --> 01:06:41,080
0,400
Sorry.|
抱歉的。|

2374
01:06:41,550 --> 01:06:42,900
0,275 275,425 425,700
Yep, yep, yep.|
是的，是的，是的。|

2375
01:06:43,340 --> 01:06:44,820
0,260 260,520
Is X.|
是X。|

2376
01:06:45,400 --> 01:06:47,060
0,350 350,560 560,820
S T one.|
S TONE。|

2377
01:06:48,720 --> 01:06:49,325
0,305 305,425 425,470 470,530 530,605
Right, so I can get
好的，所以我可以拿回一个有一个的两个人，对吗？但如果我尝试将另一个嵌套查询放在它旁边，则两个都是y。

2378
01:06:49,325 --> 01:06:50,135
0,105 105,225 225,405 405,705 705,810
back a single twople that

2379
01:06:50,135 --> 01:06:51,880
0,245 985,1245 1245,1350 1350,1470 1470,1745
has one in it, right?

2380
01:06:52,530 --> 01:06:53,285
0,245 245,335 335,470 470,620 620,755
But if I try to

2381
01:06:53,285 --> 01:06:54,755
0,275 535,840 840,1110 1110,1275 1275,1470
put another nested query next

2382
01:06:54,755 --> 01:06:59,140
0,150 150,395 2515,2915 3625,4005 4005,4385
to it, two has y.|
|

2383
01:07:00,830 --> 01:07:02,600
0,380 380,970
As t2.|
作为T2。|

2384
01:07:03,410 --> 01:07:04,900
0,400 630,950 950,1055 1055,1175 1175,1490
Right, I'm getting the cartesian
是的，我得到了笛卡尔乘积，但我不能引用这个东西的内部。我不能去T点X加一。

2385
01:07:04,900 --> 01:07:06,060
0,210 210,390 390,525 525,870 870,1160
product, but I can't reference

2386
01:07:06,260 --> 01:07:07,105
0,275 275,395 395,545 545,710 710,845
inside of this thing. I

2387
01:07:07,105 --> 01:07:09,040
0,240 240,485 955,1260 1260,1565 1615,1935
can't go t one dot

2388
01:07:09,040 --> 01:07:10,520
0,285 285,555 555,860
X plus one.|
|

2389
01:07:11,420 --> 01:07:13,390
0,400 990,1250 1250,1370 1370,1700 1700,1970
Right, because it doesn't know
对，因为它不知道t 1，因为这些查询是分开运行的。

2390
01:07:13,390 --> 01:07:14,610
0,285 285,510 510,750 750,960 960,1220
about t one because those

2391
01:07:15,770 --> 01:07:17,540
0,350 350,530 530,785 785,1270
queries are running separately.|
|

2392
01:07:17,550 --> 01:07:18,635
0,275 275,425 425,605 605,770 770,1085
If I add the lateral
如果我加上横向关键字。

2393
01:07:18,635 --> 01:07:19,940
0,425
keyword.|
|

2394
01:07:22,630 --> 01:07:24,300
0,400 420,820 870,1160 1160,1370 1370,1670
Now my my second nested
现在，我的第二个嵌套查询可以引用第一个查询中的任何内容，对吗？

2395
01:07:24,300 --> 01:07:26,670
0,290 1180,1560 1560,1940 2050,2295 2295,2370
query can reference whatever is

2396
01:07:26,670 --> 01:07:27,950
0,75 75,180 180,330 330,620 880,1280
in the first one, right?|
|

2397
01:07:28,820 --> 01:07:29,680
0,260 260,365 365,485 485,665 665,860
And you can chain these
你可以将这些东西链接在一起，想链接多少次就链接多少次。

2398
01:07:29,680 --> 01:07:32,035
0,240 240,590 1720,1965 1965,2115 2115,2355
things together as many times

2399
01:07:32,035 --> 01:07:33,160
0,180 180,285 285,545
as you want.|
|

2400
01:07:33,650 --> 01:07:34,330
0,290 290,365 365,485 485,590 590,680
Let's go back to it
让我们快速返回它，看看这个查询计划是什么。从理论上讲，您应该将其转换为联接。

2401
01:07:34,330 --> 01:07:34,855
0,165 165,315 315,390 390,450 450,525
quickly and see what the

2402
01:07:34,855 --> 01:07:35,485
0,165 165,330 330,450 450,540 540,630
query plan for this one

2403
01:07:35,485 --> 01:07:36,565
0,105 105,365 475,765 765,945 945,1080
would be. In theory, you

2404
01:07:36,565 --> 01:07:37,195
0,135 135,285 285,420 420,525 525,630
should convert this to a

2405
01:07:37,195 --> 01:07:38,340
0,275
join.|
|

2406
01:07:40,640 --> 01:07:43,645
0,215 215,430 1110,1510 2490,2825 2825,3005
Oh, all right, it did.
哦，好吧，是这样的。一条捷径？忽略它，因为它基本上是在说，我知道答案是什么。我不需要运行任何东西，只需吐出答案即可。这就是它所做的。就像SELECT 1+1一样，它知道如何在不运行查询的情况下进行计算。

2407
01:07:43,645 --> 01:07:45,850
0,105 105,450 450,660 660,935 1945,2205
A shortcut? Ignore that because

2408
01:07:45,850 --> 01:07:47,575
0,260 580,960 960,1340 1360,1635 1635,1725
it basically says, I know

2409
01:07:47,575 --> 01:07:48,130
0,60 60,150 150,315 315,480 480,555
what the answer is. I

2410
01:07:48,130 --> 01:07:48,775
0,135 135,180 180,255 255,450 450,645
don't have to run anything

2411
01:07:48,775 --> 01:07:49,375
0,105 105,225 225,375 375,495 495,600
and just spits out the

2412
01:07:49,375 --> 01:07:50,220
0,210 210,450 450,510 510,600 600,845
answer. That's what it did.

2413
01:07:50,660 --> 01:07:51,790
0,335 335,560 560,725 725,905 905,1130
Like select one plus one,

2414
01:07:51,790 --> 01:07:52,930
0,180 180,440 610,855 855,945 945,1140
it knows how to compute

2415
01:07:52,930 --> 01:07:53,940
0,210 210,465 465,630 630,735 735,1010
that without running a query.|
|

2416
01:07:54,990 --> 01:07:56,270
0,400 720,1025 1025,1085 1085,1160 1160,1280
Alright, let's have a more
好的，让我们举一个更复杂的例子。假设我想要计算每门课程的注册人数，然后我想计算每门课程的注册人数。然后我还想知道这门课上所有学生的平均绩点。因此，是的，您可以不使用稍后的联接来编写此代码。我只是想向您展示如何使用稍后的联接来实现这一点。因此将有两个嵌套查询。

2417
01:07:56,270 --> 01:07:57,425
0,270 270,630 630,885 885,1035 1035,1155
complicated example. So say I

2418
01:07:57,425 --> 01:07:58,160
0,75 75,180 180,465 465,585 585,735
want to calculate the number

2419
01:07:58,160 --> 01:07:59,210
0,180 180,375 375,525 525,930 930,1050
of students that enrolled in

2420
01:07:59,210 --> 01:08:01,925
0,195 195,530 1420,1740 1740,2060 2470,2715
each course and then I

2421
01:08:01,925 --> 01:08:02,390
0,60 60,150 150,300 300,405 405,465
want to count the number

2422
01:08:02,390 --> 01:08:02,975
0,90 90,210 210,420 420,480 480,585
of students enrolled in each

2423
01:08:02,975 --> 01:08:03,995
0,275 325,585 585,720 720,885 885,1020
course. And then I also

2424
01:08:03,995 --> 01:08:04,655
0,90 90,165 165,255 255,435 435,660
want to get all the,

2425
01:08:04,655 --> 01:08:07,115
0,165 165,390 390,1055 1435,1835 2155,2460
the average gpa of all

2426
01:08:07,115 --> 01:08:08,110
0,180 180,360 360,525 525,690 690,995
the students in that course.

2427
01:08:09,630 --> 01:08:10,760
0,275 275,545 545,815 815,965 965,1130
And so yes, you can

2428
01:08:10,760 --> 01:08:11,465
0,180 180,315 315,465 465,615 615,705
write this without using doing

2429
01:08:11,465 --> 01:08:12,110
0,75 75,240 240,465 465,585 585,645
a later join. I just

2430
01:08:12,110 --> 01:08:12,620
0,75 75,180 180,300 300,405 405,510
want to show you how

2431
01:08:12,620 --> 01:08:12,980
0,90 90,150 150,225 225,300 300,360
to do this with a

2432
01:08:12,980 --> 01:08:14,285
0,150 150,470 700,960 960,1155 1155,1305
later join. So there's two

2433
01:08:14,285 --> 01:08:14,840
0,90 90,120 120,195 195,300 300,555
going to be two nested

2434
01:08:14,840 --> 01:08:15,800
0,410
queries.|
|

2435
01:08:15,800 --> 01:08:16,850
0,290 310,570 570,690 690,855 855,1050
Where we had a select
其中，我们在外部有一条SELECT语句。对于课程表中的每两个学生，我要计算注册学生的数量。然后，对于课程表中的每个学生，我想计算所有普通学生的平均GPA。

2436
01:08:16,850 --> 01:08:17,885
0,180 180,315 315,560 670,900 900,1035
statement on the the outer

2437
01:08:17,885 --> 01:08:19,540
0,305 595,915 915,1095 1095,1305 1305,1655
part. And for every single

2438
01:08:19,920 --> 01:08:20,990
0,455 455,650 650,725 725,860 860,1070
twople that's in the course

2439
01:08:20,990 --> 01:08:22,625
0,320 730,990 990,1140 1140,1320 1320,1635
table, I want then compute

2440
01:08:22,625 --> 01:08:24,365
0,120 120,240 240,600 600,905 1495,1740
the number enrolled students. And

2441
01:08:24,365 --> 01:08:25,295
0,165 165,405 405,555 555,705 705,930
then again, for every single

2442
01:08:25,295 --> 01:08:26,110
0,180 180,285 285,375 375,525 525,815
student in the course table,

2443
01:08:26,310 --> 01:08:27,305
0,245 245,335 335,410 410,695 695,995
I want to compute the

2444
01:08:27,305 --> 01:08:29,240
0,330 330,905 1165,1440 1440,1710 1710,1935
average gpa of all the

2445
01:08:29,240 --> 01:08:30,440
0,240 240,560
eneral students.|
|

2446
01:08:30,590 --> 01:08:31,420
0,335 335,500 500,575 575,680 680,830
Right, so I could write
对，这样我就可以这样写了。我们有两个和两个嵌套的查询，都是带有横向关键字的，这里的第一个查询，我再次计算了它内部的，计数，我能够引用外部查询中的，相邻的查询。下面这一张也是一样的。我可以把这本书放在那里参考。现在我不在这里展示这个例子，因为他们是人为的。

2447
01:08:31,420 --> 01:08:32,260
0,135 135,285 285,525 525,705 705,840
it as this. We have

2448
01:08:32,260 --> 01:08:33,960
0,195 195,495 495,890 910,1215 1215,1700
two and two nest queries

2449
01:08:34,040 --> 01:08:35,170
0,245 245,425 425,620 620,875 875,1130
that are that are with

2450
01:08:35,170 --> 01:08:37,030
0,135 135,435 435,830 1420,1710 1710,1860
the lateral keyword where again

2451
01:08:37,030 --> 01:08:37,810
0,105 105,240 240,390 390,585 585,780
the first one here I

2452
01:08:37,810 --> 01:08:40,500
0,330 330,650 1780,2160 2160,2415 2415,2690
compute the, the, the count

2453
01:08:40,880 --> 01:08:42,145
0,400 570,845 845,950 950,1055 1055,1265
again inside of it I'm

2454
01:08:42,145 --> 01:08:43,825
0,135 135,285 285,545 895,1335 1335,1680
able to reference what's in

2455
01:08:43,825 --> 01:08:45,265
0,225 225,345 345,585 585,905 1195,1440
the outer query here, the

2456
01:08:45,265 --> 01:08:46,735
0,345 345,635 955,1200 1200,1335 1335,1470
adjacent query. And then for

2457
01:08:46,735 --> 01:08:47,995
0,120 120,255 255,420 420,725 955,1260
this one down here, same

2458
01:08:47,995 --> 01:08:48,895
0,225 225,420 420,555 555,705 705,900
thing. I can have this

2459
01:08:48,895 --> 01:08:50,905
0,305 505,945 945,1205 1285,1685 1735,2010
one referenced there. Now I'm

2460
01:08:50,905 --> 01:08:51,870
0,90 90,225 225,405 405,645 645,965
not showing this example here

2461
01:08:52,160 --> 01:08:54,240
0,400 600,875 875,1415 1415,1690
because they contrived but.|
|

2462
01:08:54,240 --> 01:08:55,665
0,120 120,270 270,510 510,860 1030,1425
In the second, later query
在第二个，我也可以参考的第二个查询中是第一个，这些东西被改变成一起改变。再说一次，当你想到SEL时，这是一个不同的概念，因为sl没有指定，或者我们没有指定数据系统应该执行任何操作的顺序。我们并不是真的这么做，我们只是在说而已。而是我们想要的计算执行的顺序，来计算我们想要的答案。

2463
01:08:55,665 --> 01:08:56,820
0,225 225,375 375,525 525,785 895,1155
I can also reference was

2464
01:08:56,820 --> 01:08:58,035
0,105 105,225 225,405 405,710 910,1215
in the first one, these

2465
01:08:58,035 --> 01:08:59,010
0,210 210,420 420,645 645,810 810,975
things get changed to get

2466
01:08:59,010 --> 01:09:00,600
0,240 240,560 1030,1305 1305,1455 1455,1590
changed together. And again, this

2467
01:09:00,600 --> 01:09:01,605
0,105 105,225 225,465 465,795 795,1005
is a different concept when

2468
01:09:01,605 --> 01:09:02,370
0,105 105,210 210,330 330,615 615,765
you think of SEL, because

2469
01:09:02,370 --> 01:09:04,005
0,375 375,870 870,1125 1125,1215 1215,1635
sl unord we're not specifying

2470
01:09:04,005 --> 01:09:05,175
0,180 180,455 475,720 720,885 885,1170
the or we don't specify

2471
01:09:05,175 --> 01:09:06,060
0,135 135,300 300,480 480,690 690,885
the order in which the

2472
01:09:06,060 --> 01:09:07,935
0,180 180,500 520,920 1120,1515 1515,1875
data system should should execute

2473
01:09:07,935 --> 01:09:09,690
0,365 895,1170 1170,1245 1245,1455 1455,1755
anything. We're not really doing

2474
01:09:09,690 --> 01:09:10,710
0,270 270,510 510,675 675,870 870,1020
that, we're just telling it.

2475
01:09:10,710 --> 01:09:11,805
0,90 90,180 180,345 345,650 850,1095
But the order we we

2476
01:09:11,805 --> 01:09:13,830
0,105 105,240 240,785 1135,1535 1795,2025
want the computation to to

2477
01:09:13,830 --> 01:09:14,835
0,180 180,570 570,660 660,900 900,1005
be performeded to compute the

2478
01:09:14,835 --> 01:09:16,200
0,180 180,375 375,540 540,845
answer that we want.|
|

2479
01:09:16,320 --> 01:09:17,870
0,245 245,350 350,590 590,970 1200,1550
So the database system can
因此，数据库系统可以决定，我是要将其重写为一组连接并同时执行它们，还是决定一个接一个地执行，然后我们可以真正快速地测试postgres，看看它有什么作用。

2480
01:09:17,870 --> 01:09:18,710
0,315 315,525 525,645 645,765 765,840
decide, do I want to

2481
01:09:18,710 --> 01:09:19,685
0,285 285,555 555,780 780,870 870,975
rewrite this as a bunch

2482
01:09:19,685 --> 01:09:20,720
0,135 135,480 480,600 600,810 810,1035
of joins and just execute

2483
01:09:20,720 --> 01:09:22,805
0,180 180,405 405,1070 1750,1995 1995,2085
them all concurrently, or we

2484
01:09:22,805 --> 01:09:23,620
0,135 135,300 300,435 435,555 555,815
can decide to do it

2485
01:09:23,790 --> 01:09:26,705
0,290 290,515 515,850 2550,2810 2810,2915
one after another, which we

2486
01:09:26,705 --> 01:09:27,890
0,90 90,335 445,735 735,1065 1065,1185
can then test postgres real

2487
01:09:27,890 --> 01:09:28,430
0,150 150,300 300,405 405,480 480,540
quickly and see what it

2488
01:09:28,430 --> 01:09:29,300
0,230
does.|
|

2489
01:09:29,510 --> 01:09:29,930
0,75 75,135 135,195 195,285 285,420
I don't think I have
我不认为我在这里抄袭过。

2490
01:09:29,930 --> 01:09:31,240
0,315 315,590
copied here.|
|

2491
01:09:31,250 --> 01:09:32,760
0,400
Hmm.|
嗯。|

2492
01:09:35,270 --> 01:09:36,790
0,395 395,790 1110,1340 1340,1460 1460,1520
Yeah, sorry, I don't have
是的，对不起，我不需要很快地复制粘贴它。

2493
01:09:36,790 --> 01:09:37,375
0,60 60,195 195,405 405,495 495,585
to copy paste it real

2494
01:09:37,375 --> 01:09:39,080
0,245
quickly.|
|

2495
01:09:39,330 --> 01:09:40,055
0,245 245,365 365,485 485,560 560,725
You can try it online
你可以稍后在网上试一下。

2496
01:09:40,055 --> 01:09:41,580
0,335
later.|
|

2497
01:09:42,520 --> 01:09:43,140
0,245 245,395 395,515 515,560 560,620
The last thing I want
我想向您展示的最后一件事是公用表表达式。

2498
01:09:43,140 --> 01:09:44,250
0,75 75,210 210,390 390,680 790,1110
to show you is common

2499
01:09:44,250 --> 01:09:45,660
0,255 255,740
table expressions.|
|

2500
01:09:46,140 --> 01:09:48,190
0,290 290,580 1170,1640 1640,1805 1805,2050
And so cte were added
因此，CTE是在1020年前增加的。

2501
01:09:48,480 --> 01:09:51,660
0,920 920,1270 1410,1810
1020 years ago.|
|

2502
01:09:51,660 --> 01:09:54,165
0,290 730,1020 1020,1310 2020,2340 2340,2505
And this is similar to
这类似于嵌套查询，类似于。

2503
01:09:54,165 --> 01:09:55,640
0,270 270,615 615,810 810,1095 1095,1475
nested queries are similar to.|
|

2504
01:09:57,060 --> 01:09:58,395
0,210 210,360 360,590 790,1125 1125,1335
If you're writing data to
如果您要将数据写入临时表或类似的东西，这是我们指定希望实现的查询的一种方式。

2505
01:09:58,395 --> 01:09:59,100
0,150 150,315 315,480 480,600 600,705
a temp table or something

2506
01:09:59,100 --> 01:10:00,570
0,120 120,380 820,1110 1110,1215 1215,1470
like that, it's a way

2507
01:10:00,570 --> 01:10:02,895
0,225 225,405 405,740 1690,2190 2190,2325
for us to specify a

2508
01:10:02,895 --> 01:10:03,585
0,210 210,360 360,465 465,585 585,690
query that we want to

2509
01:10:03,585 --> 01:10:05,220
0,180 180,755
get materialized.|
|

2510
01:10:05,220 --> 01:10:05,640
0,180 180,255 255,345 345,375 375,420
Maybe we don't want to
也许我们不想用这个词。我们希望指定一个查询，该查询可能是。

2511
01:10:05,640 --> 01:10:06,780
0,90 90,195 195,440 760,1020 1020,1140
use that word. We want

2512
01:10:06,780 --> 01:10:07,875
0,165 165,465 465,585 585,855 855,1095
to specify a query that

2513
01:10:07,875 --> 01:10:08,980
0,135 135,395
could be.|
|

2514
01:10:09,110 --> 01:10:11,215
0,460 570,845 845,1145 1145,1450 1770,2105
Stored in quotation Marks at
存储在某个虚拟表处的引号中。

2515
01:10:11,215 --> 01:10:13,200
0,330 330,720 720,1115
some virtual table.|
|

2516
01:10:13,200 --> 01:10:14,055
0,240 240,420 420,555 555,645 645,855
And then we can have
然后我们可以有另一个引用的查询，无论它里面是什么。

2517
01:10:14,055 --> 01:10:15,510
0,315 315,570 570,705 705,965 1195,1455
another query of reference, whatever

2518
01:10:15,510 --> 01:10:16,880
0,180 180,390 390,510 510,740
is inside of it.|
|

2519
01:10:17,560 --> 01:10:18,720
0,400
Right.|
正确的。|

2520
01:10:18,790 --> 01:10:19,830
0,320 320,485 485,620 620,815 815,1040
So in my really simple
在我非常简单的例子中，我有这个WITH子句。我给我的CTE一个名字，然后我有我的as语句，然后这个圆括号里的任何东西，这里的任何SELECT查询都将绑定到这个。

2521
01:10:19,830 --> 01:10:22,245
0,240 240,560 790,1095 1095,1400 2110,2415
example here, I have this

2522
01:10:22,245 --> 01:10:24,315
0,240 240,605 1075,1380 1380,1685 1765,2070
with clause. I give my

2523
01:10:24,315 --> 01:10:26,115
0,390 390,585 585,875 1435,1695 1695,1800
cte a name, then I

2524
01:10:26,115 --> 01:10:27,660
0,120 120,270 270,545 1045,1365 1365,1545
have my as statement, and

2525
01:10:27,660 --> 01:10:29,060
0,210 210,540 540,690 690,855 855,1400
then whatever's inside this parentheses,

2526
01:10:29,350 --> 01:10:30,855
0,305 305,470 470,680 680,1000 1200,1505
whatever select query here is

2527
01:10:30,855 --> 01:10:32,150
0,135 135,210 210,390 390,725 895,1295
going to get bound to

2528
01:10:32,530 --> 01:10:33,600
0,400
this.|
|

2529
01:10:33,750 --> 01:10:36,290
0,400 960,1310 1310,1660 2160,2405 2405,2540
This name here, and then
在这里输入这个名称，然后在Width语句后面的下面进行编辑。

2530
01:10:36,290 --> 01:10:38,080
0,360 360,620 730,1035 1035,1340 1390,1790
editing that comes below after

2531
01:10:38,280 --> 01:10:39,800
0,260 260,470 470,760
the width statement.|
|

2532
01:10:39,800 --> 01:10:41,015
0,195 195,450 450,765 765,1035 1035,1215
Can then reference it as
然后可以引用它，就好像它是一个表。

2533
01:10:41,015 --> 01:10:41,800
0,135 135,255 255,360 360,495 495,785
if it was a table.|
|

2534
01:10:45,670 --> 01:10:46,780
0,400
Right.|
正确的。|

2535
01:10:46,990 --> 01:10:49,070
0,260 260,440 440,760 1590,1835 1835,2080
So again, some like this,
再说一次，像这样的，所以我基本上是AS子句约束了一些东西。

2536
01:10:49,300 --> 01:10:51,255
0,400 450,850 1080,1480 1500,1760 1760,1955
so I essentially the as

2537
01:10:51,255 --> 01:10:52,970
0,255 255,450 450,975 975,1320 1320,1715
clause is binding things to.|
|

2538
01:10:54,310 --> 01:10:56,040
0,395 395,680 680,970 1080,1490 1490,1730
Names to whatever, whatever's inside
不管是什么名字，不管我的宽度声明里有什么。因此，我又有了一个无表查询。选择1和2，将产生1，2有一列1，一列2，但是在我的。

2539
01:10:56,040 --> 01:10:57,525
0,225 225,435 435,630 630,950 1120,1485
my width statement here. So

2540
01:10:57,525 --> 01:10:59,295
0,210 210,405 405,755 895,1295 1435,1770
I have again a no

2541
01:10:59,295 --> 01:11:00,450
0,270 270,585 585,855 855,1035 1035,1155
table query. Select one and

2542
01:11:00,450 --> 01:11:01,125
0,165 165,390 390,435 435,510 510,675
two that's going to produce

2543
01:11:01,125 --> 01:11:02,850
0,195 195,435 435,735 735,1085 1435,1725
one, two has a one

2544
01:11:02,850 --> 01:11:03,675
0,150 150,285 285,480 480,675 675,825
column of one, one column

2545
01:11:03,675 --> 01:11:05,520
0,150 150,425 805,1080 1080,1355 1465,1845
of two, but then within

2546
01:11:05,520 --> 01:11:07,220
0,380
my.|
|

2547
01:11:07,220 --> 01:11:08,030
0,120 120,270 270,495 495,660 660,810
With my width statement up
在这里使用我的Width语句，我现在可以给列命名，然后可以在下面的查询中引用这些名称。

2548
01:11:08,030 --> 01:11:08,915
0,165 165,330 330,465 465,645 645,885
here, I can give now

2549
01:11:08,915 --> 01:11:10,550
0,270 270,480 480,935 1165,1455 1455,1635
names the columns, which then

2550
01:11:10,550 --> 01:11:11,620
0,135 135,255 255,630 630,780 780,1070
can be referenced down below

2551
01:11:11,670 --> 01:11:13,700
0,400 750,995 995,1270
in the query.|
|

2552
01:11:16,270 --> 01:11:17,160
0,245 245,335 335,455 455,650 650,890
You can do weird things
你也可以做一些奇怪的事情，就像你实际上可以做的一样，在postgres中会让你给列命名相同的东西，但是当你在下面实际尝试引用它时，它会抛出一个错误。同样，这个示例中的语法大致相同，但语义在不同的系统中可能会有所不同。

2553
01:11:17,160 --> 01:11:18,290
0,255 255,450 450,570 570,780 780,1130
too, like you can actually,

2554
01:11:18,670 --> 01:11:19,845
0,320 320,740 740,875 875,995 995,1175
in postgres will let you

2555
01:11:19,845 --> 01:11:20,865
0,195 195,420 420,615 615,915 915,1020
actually name the columns the

2556
01:11:20,865 --> 01:11:23,415
0,165 165,485 1555,1815 1815,2075 2275,2550
same thing, but then when

2557
01:11:23,415 --> 01:11:24,120
0,195 195,360 360,450 450,540 540,705
you actually try to reference

2558
01:11:24,120 --> 01:11:25,215
0,180 180,440 460,855 855,990 990,1095
it below, it'll throw an

2559
01:11:25,215 --> 01:11:29,310
0,245 1555,1955 3295,3555 3555,3810 3810,4095
error. So again, this example

2560
01:11:29,310 --> 01:11:30,680
0,195 195,390 390,810 810,1065 1065,1370
where the syntax is, is

2561
01:11:30,730 --> 01:11:31,680
0,320 320,500 500,665 665,815 815,950
roughly the same, but the

2562
01:11:31,680 --> 01:11:33,285
0,710 730,975 975,1080 1080,1290 1290,1605
semantics can be different across

2563
01:11:33,285 --> 01:11:34,840
0,270 270,555 555,935
across different systems.|
|

2564
01:11:35,370 --> 01:11:36,635
0,320 320,485 485,680 680,1000 1020,1265
Let's see. So let's how
让我们看看。那么让我们来看看我们真正想要如何使用它。因此，对于这个问题，我想再次找到注册了至少一门课程的最高ID的学生记录。同样，您展示了示例如何使用嵌套查询来实现这一点，就像我们对连接所做的那样。但现在我们可以使用CTE，在CT中，我要做的第一件事是从注册表中计算最大学生ID。

2565
01:11:36,635 --> 01:11:37,070
0,120 120,225 225,285 285,345 345,435
we actually want to use

2566
01:11:37,070 --> 01:11:37,745
0,150 150,270 270,345 345,465 465,675
this. So for this one,

2567
01:11:37,745 --> 01:11:39,275
0,335 655,900 900,1020 1020,1260 1260,1530
again, want to find the

2568
01:11:39,275 --> 01:11:40,325
0,210 210,495 495,750 750,915 915,1050
student record that has the

2569
01:11:40,325 --> 01:11:41,450
0,150 150,435 435,720 720,1050 1050,1125
highest ID that's enrolled in

2570
01:11:41,450 --> 01:11:43,010
0,120 120,315 315,620 1120,1410 1410,1560
least one course. Again, you

2571
01:11:43,010 --> 01:11:43,775
0,135 135,300 300,495 495,660 660,765
showed how examples how to

2572
01:11:43,775 --> 01:11:45,305
0,90 90,335 565,900 900,1260 1260,1530
do this with nested queries

2573
01:11:45,305 --> 01:11:46,270
0,105 105,180 180,300 300,450 450,965
that we do with joins.

2574
01:11:47,160 --> 01:11:47,915
0,230 230,350 350,485 485,575 575,755
But now we can do

2575
01:11:47,915 --> 01:11:49,715
0,195 195,330 330,755 1165,1530 1530,1800
with the cte where inside

2576
01:11:49,715 --> 01:11:50,840
0,165 165,615 615,870 870,990 990,1125
the CT, first thing I'm

2577
01:11:50,840 --> 01:11:52,450
0,60 60,150 150,360 360,710 1060,1610
going to do is compute

2578
01:11:53,040 --> 01:11:54,875
0,275 275,515 515,755 755,1030 1560,1835
the Max student ID from

2579
01:11:54,875 --> 01:11:56,220
0,105 105,450 450,725
the enrolled table.|
|

2580
01:11:56,220 --> 01:11:57,210
0,165 165,315 315,585 585,810 810,990
And then now in my
现在，在下面的SELECT语句中，我可以引用CTE来获取Max ID，然后对其进行联接。

2581
01:11:57,210 --> 01:11:58,725
0,210 210,390 390,555 555,830 1240,1515
select statement down below, I

2582
01:11:58,725 --> 01:12:00,645
0,210 210,545 685,990 990,1445 1645,1920
can reference my cte to

2583
01:12:00,645 --> 01:12:02,490
0,165 165,345 345,555 555,875 1585,1845
get that Max ID and

2584
01:12:02,490 --> 01:12:04,005
0,255 255,540 540,830 1030,1335 1335,1515
then do my join on

2585
01:12:04,005 --> 01:12:04,860
0,275
that.|
|

2586
01:12:07,020 --> 01:12:08,090
0,260 260,410 410,650 650,920 920,1070
Again, the data session should
同样，数据会话应该足够智能，能够意识到，哦，我只需运行CTE一次，具体化它，然后现在我就可以在调用它的任何查询中引用它，就像它是一个临时表一样。

2587
01:12:08,090 --> 01:12:08,960
0,135 135,300 300,420 420,600 600,870
be smart enough to realize

2588
01:12:08,960 --> 01:12:10,370
0,350 610,945 945,1155 1155,1305 1305,1410
that, oh, I only have

2589
01:12:10,370 --> 01:12:12,365
0,105 105,360 360,740 1330,1620 1620,1995
to run this, the cte

2590
01:12:12,365 --> 01:12:14,165
0,335 475,975 975,1265 1345,1620 1620,1800
once, materialize it, and then

2591
01:12:14,165 --> 01:12:15,095
0,225 225,405 405,525 525,720 720,930
now I can reference it

2592
01:12:15,095 --> 01:12:16,070
0,135 135,255 255,375 375,635 715,975
as if it was a

2593
01:12:16,070 --> 01:12:18,275
0,165 165,470 790,1190 1690,1995 1995,2205
temp table in any query

2594
01:12:18,275 --> 01:12:19,420
0,225 225,465 465,645 645,840 840,1145
below that that calls it.|
|

2595
01:12:23,130 --> 01:12:24,340
0,275 275,440 440,635 635,800 800,1210
And any question about cts.|
还有任何关于CTS的问题。|

2596
01:12:27,930 --> 01:12:29,100
0,400
Okay.|
好吧。|

2597
01:12:29,450 --> 01:12:30,595
0,290 290,395 395,515 515,790 840,1145
There to finish up, right.
就这样结束了，对。因此，希望从这一切中得到的主要结论是，SQL不是一种已死的语言。你可以用它做很多很酷的事情。您希望尝试在一条语句中进行尽可能多的计算。现在它可以，可以是嵌套的查询，可以做里面的许多奇怪的事情。我们无法避免在客户端和服务器之间来回往返，因为从理论上讲，数据库系统应该足够智能，知道执行您提供给它的查询的最佳方式是什么。

2598
01:12:30,595 --> 01:12:31,990
0,305 355,755 835,1140 1140,1290 1290,1395
So again, hopefully the main

2599
01:12:31,990 --> 01:12:32,470
0,120 120,240 240,330 330,405 405,480
take away from all of

2600
01:12:32,470 --> 01:12:33,250
0,105 105,255 255,450 450,705 705,780
this is that sql is

2601
01:12:33,250 --> 01:12:33,985
0,90 90,165 165,285 285,510 510,735
not a dead language. There's

2602
01:12:33,985 --> 01:12:34,465
0,45 45,120 120,225 225,345 345,480
a lot of cool things

2603
01:12:34,465 --> 01:12:35,100
0,105 105,195 195,300 300,390 390,635
you can do with it.

2604
01:12:36,260 --> 01:12:37,420
0,245 245,335 335,485 485,785 785,1160
You want to try to

2605
01:12:37,420 --> 01:12:38,530
0,240 240,375 375,555 555,960 960,1110
do as much computations as

2606
01:12:38,530 --> 01:12:39,540
0,135 135,285 285,510 510,735 735,1010
you can within a single

2607
01:12:40,370 --> 01:12:41,725
0,400 780,1025 1025,1115 1115,1190 1190,1355
statement. Now it can be,

2608
01:12:41,725 --> 01:12:42,640
0,165 165,255 255,525 525,810 810,915
can be nested queries, can

2609
01:12:42,640 --> 01:12:43,090
0,90 90,195 195,270 270,345 345,450
do much of all the

2610
01:12:43,090 --> 01:12:44,070
0,165 165,405 405,615 615,735 735,980
weird stuff inside of it.

2611
01:12:44,750 --> 01:12:45,820
0,260 260,455 455,665 665,860 860,1070
We wouldn't avoid the round

2612
01:12:45,820 --> 01:12:46,675
0,270 270,435 435,585 585,720 720,855
trips going back and forth

2613
01:12:46,675 --> 01:12:48,385
0,135 135,285 285,575 595,995 1435,1710
between the client and and

2614
01:12:48,385 --> 01:12:50,275
0,165 165,455 625,930 930,1235 1615,1890
the server because again, the

2615
01:12:50,275 --> 01:12:51,780
0,240 240,605 715,990 990,1185 1185,1505
database system should in theory

2616
01:12:51,830 --> 01:12:52,800
0,335 335,530 530,650 650,740 740,970
be smart enough to know

2617
01:12:52,850 --> 01:12:53,830
0,365 365,455 455,605 605,785 785,980
what's the best way to

2618
01:12:53,830 --> 01:12:54,580
0,195 195,300 300,450 450,585 585,750
execute the query that you're

2619
01:12:54,580 --> 01:12:55,620
0,165 165,405 405,645 645,810 810,1040
giving to giving to it.|
|

2620
01:12:56,270 --> 01:12:57,145
0,230 230,320 320,485 485,695 695,875
Soon as you take stuff
一旦您从数据库中取出一些东西，就在上面做一些Python代码。这显然超出了数据库系统的范围。所以我们无法对其进行优化。不能优化这一点，因为那是一段Python代码。如果你把所有的东西都放在数据库系统里，它应该能够很好地努力如何进一步优化它。

2621
01:12:57,145 --> 01:12:58,975
0,135 135,225 225,300 300,545 1555,1830
out of the database, do

2622
01:12:58,975 --> 01:12:59,755
0,135 135,435 435,585 585,690 690,780
some python code on it.

2623
01:12:59,755 --> 01:13:01,240
0,240 240,495 495,795 795,1110 1110,1485
That's obviously outside the purview

2624
01:13:01,240 --> 01:13:02,380
0,60 60,135 135,300 300,620 910,1140
of the database system. So

2625
01:13:02,380 --> 01:13:03,505
0,90 90,390 390,675 675,855 855,1125
we can't optimize it. Can't

2626
01:13:03,505 --> 01:13:04,740
0,255 255,450 450,645 645,945 945,1235
optimize that, that python code.

2627
01:13:05,120 --> 01:13:05,980
0,230 230,305 305,500 500,725 725,860
If you keep everything inside

2628
01:13:05,980 --> 01:13:07,450
0,105 105,285 285,620 1030,1320 1320,1470
of database system, it should

2629
01:13:07,450 --> 01:13:08,350
0,90 90,180 180,440 520,780 780,900
be able to make a

2630
01:13:08,350 --> 01:13:09,550
0,105 105,285 285,620 700,990 990,1200
good effort how to optimize

2631
01:13:09,550 --> 01:13:10,380
0,135 135,410
it further.|
|

2632
01:13:10,380 --> 01:13:11,130
0,255 255,450 450,600 600,660 660,750
And again, also the main
再说一次，所有这一切的主要结论是，没有人确切地遵循SQL标准。每个单独的数据库系统都将略有不同。

2633
01:13:11,130 --> 01:13:11,715
0,240 240,330 330,405 405,480 480,585
takeaway from all of this

2634
01:13:11,715 --> 01:13:13,080
0,135 135,395 865,1110 1110,1230 1230,1365
is that there is a

2635
01:13:13,080 --> 01:13:15,020
0,225 225,500 730,1080 1080,1430 1540,1940
sql standard nobody follows exactly.

2636
01:13:15,370 --> 01:13:16,620
0,320 320,515 515,710 710,995 995,1250
Every single database system is

2637
01:13:16,620 --> 01:13:17,420
0,105 105,150 150,270 270,480 480,800
going to be slightly different.|
|

2638
01:13:19,220 --> 01:13:20,440
0,350 350,635 635,815 815,980 980,1220
People claim that, oh, it's
人们声称，哦，如果你支持SQL就太好了，因为这样你就可以随身携带了。就像如果我在我的SQL上阅读我的应用程序，我可以很容易地将它移植到Postgres。无论您一开始选择什么数据系统，这都不是时代的情况，您将在很长一段时间内被困在移动的数据系统中。

2639
01:13:20,440 --> 01:13:21,685
0,255 255,510 510,645 645,825 825,1245
great if you support sql

2640
01:13:21,685 --> 01:13:22,420
0,195 195,315 315,420 420,510 510,735
because then you can go

2641
01:13:22,420 --> 01:13:23,515
0,240 240,405 405,720 720,915 915,1095
and be portable. Like if

2642
01:13:23,515 --> 01:13:24,570
0,105 105,225 225,435 435,720 720,1055
I read my application on

2643
01:13:25,010 --> 01:13:26,545
0,275 275,440 440,910 1140,1400 1400,1535
on my sql, I could

2644
01:13:26,545 --> 01:13:27,370
0,180 180,405 405,600 600,735 735,825
very easily just port it

2645
01:13:27,370 --> 01:13:28,690
0,90 90,590 820,1065 1065,1170 1170,1320
to postgres. That is not

2646
01:13:28,690 --> 01:13:31,495
0,135 135,380 1720,2115 2115,2510 2530,2805
the case of times whatever

2647
01:13:31,495 --> 01:13:32,260
0,180 180,405 405,585 585,690 690,765
data system you pick at

2648
01:13:32,260 --> 01:13:33,535
0,120 120,410 700,1080 1080,1155 1155,1275
the beginning, that's what you're

2649
01:13:33,535 --> 01:13:34,060
0,30 30,75 75,195 195,360 360,525
going to be stuck with

2650
01:13:34,060 --> 01:13:37,780
0,120 120,195 195,360 360,2930 3460,3720
for a long times to

2651
01:13:37,780 --> 01:13:39,100
0,260
move.|
|

2652
01:13:39,140 --> 01:13:40,530
0,275 275,500 500,800 800,1070 1070,1390
All alright, so last thing,
好了，最后一件事，家庭作业。第一，它将在今天出版。它将编写SQL查询。进行基本数据分析。今年，我们将要求你在Sqel Light和Date Bam上做到这一点。

2653
01:13:40,700 --> 01:13:41,950
0,350 350,700 720,1010 1010,1085 1085,1250
homework. One, it be out

2654
01:13:41,950 --> 01:13:43,375
0,320 790,1095 1095,1155 1155,1245 1245,1425
today. It's gonna be writing

2655
01:13:43,375 --> 01:13:44,530
0,285 285,540 540,675 675,885 885,1155
sql queries. Do basic data

2656
01:13:44,530 --> 01:13:46,480
0,320 1210,1530 1530,1710 1710,1845 1845,1950
analysis. This year we're gonna

2657
01:13:46,480 --> 01:13:47,005
0,180 180,300 300,375 375,450 450,525
require you to do it

2658
01:13:47,005 --> 01:13:48,310
0,165 165,465 465,675 675,930 930,1305
on sqel light and ductee

2659
01:13:48,310 --> 01:13:51,440
0,380
bam.|
|

2660
01:13:53,210 --> 01:13:54,550
0,365 365,620 620,845 845,1100 1100,1340
Reason why is because you
原因是，因为您编写相同的查询，语法会略有不同，不会太差，但您将运行相同的查询和sqlite，然后运行ducteeb，您将看到哪个速度更快，这个顿悟比另一个快得多，猜测得更快。

2661
01:13:54,550 --> 01:13:55,375
0,240 240,465 465,570 570,690 690,825
write, you write the same

2662
01:13:55,375 --> 01:13:56,665
0,335 475,855 855,960 960,1080 1080,1290
query, syntax will be slightly

2663
01:13:56,665 --> 01:13:57,400
0,210 210,330 330,480 480,585 585,735
different, it won't be too

2664
01:13:57,400 --> 01:13:59,200
0,260 550,950 1180,1515 1515,1650 1650,1800
bad, but you'll run the

2665
01:13:59,200 --> 01:14:00,460
0,180 180,450 450,645 645,1080 1080,1260
same query and sqlite and

2666
01:14:00,460 --> 01:14:01,750
0,135 135,210 210,300 300,860 1030,1290
you're run the ducteeb and

2667
01:14:01,750 --> 01:14:05,725
0,180 180,285 285,495 495,860 3700,3975
you'll see which faster you

2668
01:14:05,725 --> 01:14:07,840
0,120 120,225 225,815 1525,1845 1845,2115
have this epiphany much faster

2669
01:14:07,840 --> 01:14:10,290
0,195 195,285 285,420 420,710 2050,2450
than the other one, guess

2670
01:14:10,490 --> 01:14:16,580
0,400
faster.|
|

2671
01:14:16,800 --> 01:14:18,380
0,305 305,610 870,1175 1175,1340 1340,1580
More efficient, says more efficient
更有效率，说更有效率的曲帕格并非如此。这也不是答案。

2672
01:14:18,380 --> 01:14:27,530
0,380 760,4640 8440,8685 8685,8895 8895,9150
Qu partg is not. That's

2673
01:14:27,530 --> 01:14:32,840
0,75 75,150 150,285 285,590
not the answer either.|
|

2674
01:14:35,375 --> 01:14:36,245
0,75 75,180 180,285 285,515 535,870
That's not the reason. Okay?
这不是原因。好吧?所以您运行这些查询时，ducteeb应该会更快。

2675
01:14:36,245 --> 01:14:37,790
0,335 535,825 825,990 990,1140 1140,1545
So you run these queries,

2676
01:14:37,790 --> 01:14:40,120
0,540 540,720 720,870 870,1160
ducteeb should be faster.|
|

2677
01:14:40,120 --> 01:14:41,130
0,195 195,270 270,480 480,720 720,1010
You'll be like okay why
你会说，好吧，为什么这就是这学期剩下的时间，就是谈论你如何建立一个系统，每克28克，这取决于它是不是你还没有打到暴徒，还没有闭上你的嘴，我用剪刀的底部打你，告诉你抬起头，展示给我看它是什么，因为你的脸被打了回去，我有黑板敲打，f不能追踪，风格就像是大便，你不能在多米尼加穿，或者你得叫我多米尼加黑色偷偷的黑色皮革，我整个黑色的脏八发送去你到了每一个大门，你得到了你的勇气，试图滑冰，这是你的第一个错误，我在排队买蛋糕，你的粉丝看到你醒来。

2678
01:14:41,330 --> 01:14:42,160
0,380 380,485 485,605 605,725 725,830
that's the rest of this

2679
01:14:42,160 --> 01:14:48,100
0,320 3790,4035 4035,4140 4140,4400 5650,5940
semester be it for talking

2680
01:14:48,100 --> 01:15:10,285
0,150 150,285 285,435 435,570 570,22185
how you build a systemfuck

2681
01:15:10,285 --> 01:15:12,030
0,270 270,575 685,1215 1215,1410 1410,1745
hook up 28 a gram

2682
01:15:12,110 --> 01:15:13,500
0,335 335,560 560,725 725,1040 1040,1390
depending on if it's up

2683
01:15:13,610 --> 01:15:14,560
0,260 260,485 485,605 605,755 755,950
you ain't hit the mob

2684
01:15:14,560 --> 01:15:15,895
0,320 460,765 765,960 960,1155 1155,1335
yet still got your shut

2685
01:15:15,895 --> 01:15:16,915
0,225 225,510 510,765 765,900 900,1020
up I smack you with

2686
01:15:16,915 --> 01:15:18,235
0,165 165,405 405,735 735,1155 1155,1320
the bottom of cliper tell

2687
01:15:18,235 --> 01:15:19,450
0,180 180,375 375,665 775,1065 1065,1215
you look up show me

2688
01:15:19,450 --> 01:15:20,410
0,105 105,240 240,450 450,735 735,960
what it sa at for

2689
01:15:20,410 --> 01:15:21,505
0,150 150,330 330,540 540,795 795,1095
a blow your face back

2690
01:15:21,505 --> 01:15:22,825
0,240 240,375 375,540 540,1020 1020,1320
I got a blackboard taps

2691
01:15:22,825 --> 01:15:24,240
0,240 240,510 510,885 885,1110 1110,1415
the f can't trace that

2692
01:15:24,290 --> 01:15:25,555
0,320 320,485 485,725 725,1025 1025,1265
styl is like t for

2693
01:15:25,555 --> 01:15:26,755
0,270 270,510 510,825 825,1020 1020,1200
poop you can't lace that

2694
01:15:26,755 --> 01:15:28,240
0,150 150,300 300,1065 1065,1320 1320,1485
at the Dominican or you

2695
01:15:28,240 --> 01:15:29,995
0,255 255,510 510,675 675,1395 1395,1755
got call me Dominican black

2696
01:15:29,995 --> 01:15:31,690
0,435 435,690 690,1095 1095,1380 1380,1695
sclly black leather black Su

2697
01:15:31,690 --> 01:15:33,325
0,555 555,750 750,1005 1005,1335 1335,1635
timberlands my whole black dirty

2698
01:15:33,325 --> 01:15:34,255
0,225 225,435 435,630 630,795 795,930
eight to send you to

2699
01:15:34,255 --> 01:15:35,575
0,150 150,420 420,785 925,1185 1185,1320
the per gates you get

2700
01:15:35,575 --> 01:15:36,745
0,495 495,660 660,810 810,1005 1005,1170
youravat trying to skate and

2701
01:15:36,745 --> 01:15:38,245
0,210 210,330 330,600 600,995 1195,1500
that's your first mistake I

2702
01:15:38,245 --> 01:15:39,250
0,180 180,435 435,660 660,810 810,1005
in line for that cake

2703
01:15:39,250 --> 01:15:40,330
0,180 180,450 450,690 690,840 840,1080
your fam see you wake.|
|

2704
01:15:40,460 --> 01:15:41,560
0,290 290,485 485,650 650,845 845,1100
My grand is heavy weight,
我的体重很重，红色的韦比告诉他我是如何生活的，我生活得很好。

2705
01:15:41,560 --> 01:15:42,690
0,195 195,390 390,555 555,825 825,1130
the red, the webby state

2706
01:15:43,280 --> 01:15:44,395
0,275 275,500 500,710 710,950 950,1115
how I'm living to tell

2707
01:15:44,395 --> 01:15:50,484
0,150 150,315 315,585 585,965
him I living great.|
|
