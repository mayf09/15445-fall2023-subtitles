1
00:00:32,200 --> 00:00:33,375
0,400 570,830 830,935 935,1040 1040,1175
So you got a show
你这周末有场演出，是吗？

2
00:00:33,375 --> 00:00:50,130
0,135 135,330 330,665 2275,2675 8335,16755
this weekend, right?| {} {Is,it,real}?|
|这是真的吗？|

3
00:00:50,130 --> 00:00:51,080
0,150 150,255 255,360 360,585 585,950
We're announce in class on,
我们在星期三的课堂上宣布。

4
00:00:52,060 --> 00:00:54,345
0,400 1170,1445 1445,1720 1980,2210 2210,2285
on on Wednesday.| We have
|我们有很多事情要讨论，

5
00:00:54,345 --> 00:00:55,515
0,75 75,305 595,900 900,1080 1080,1170
a lot to discuss, a

6
00:00:55,515 --> 00:00:55,980
0,75 75,165 165,225 225,345 345,465
lot to go over,| so
|所以，让我们直接开始吧。

7
00:00:55,980 --> 00:00:56,840
0,150 150,255 255,390 390,555 555,860
let's jump right into it.|
|

8
00:00:57,700 --> 00:00:59,760
0,400 1320,1595 1595,1730 1730,1955 1955,2060
So on the [] of
所以在你们的[]，

9
00:00:59,760 --> 00:01:00,360
0,150 150,440
you guys,|
|

10
00:01:00,360 --> 00:01:02,190
0,380 490,870 870,1200 1200,1545 1545,1830
obviously project zero was was
项目 #0 昨晚就该交了，

11
00:01:02,190 --> 00:01:03,810
0,195 195,405 405,710 1180,1425 1425,1620
due last night,| we haven't
|我们还没有完成，也没有看到每个人的结果，

12
00:01:03,810 --> 00:01:04,530
0,165 165,360 360,525 525,645 645,720
gone through yet and looked

13
00:01:04,530 --> 00:01:06,230
0,60 60,195 195,500 1000,1350 1350,1700
at the results for everyone,|
|

14
00:01:06,340 --> 00:01:07,020
0,260 260,365 365,440 440,545 545,680
I think we had about
我想我们有大约 150 人完成了，

15
00:01:07,020 --> 00:01:09,345
0,645 645,915 915,1250 1420,1770 1770,2325
150 something people completed,| that's
|这很好，

16
00:01:09,345 --> 00:01:11,810
0,245 1465,1815 1815,2040 2040,2190 2190,2465
good,| project #1 has out
|项目 #1 已经放出了，截至到，

17
00:01:11,860 --> 00:01:13,280
0,275 275,545 545,680 680,970 1020,1420
and that'll be due on,|
|

18
00:01:14,050 --> 00:01:15,405
0,400 510,860 860,1085 1085,1235 1235,1355
sorry, homework #1 has been
抱歉，家庭作业 #1 已经放出一段时间了，

19
00:01:15,405 --> 00:01:16,440
0,245 415,645 645,720 720,885 885,1035
out for a while,| but
|但我们将最后期限推迟到了 15 号，

20
00:01:16,440 --> 00:01:17,385
0,120 120,360 360,480 480,795 795,945
we bumped the deadline up

21
00:01:17,385 --> 00:01:20,085
0,210 210,545 1285,1685 2275,2550 2550,2700
to this 15th,| four days
|也就是四天后，

22
00:01:20,085 --> 00:01:21,840
0,120 120,365 1045,1395 1395,1635 1635,1755
from now,| so that should
|所以这会在 Gradescope 反应出来，

23
00:01:21,840 --> 00:01:23,090
0,230 250,570 570,750 750,930 930,1250
be reflected in {Gradescope -}|
|

24
00:01:23,260 --> 00:01:24,360
0,260 260,455 455,740 740,965 965,1100
and then project #1 is
然后项目 #1 已经放出，将在 10 月 1 日截止。

25
00:01:24,360 --> 00:01:25,260
0,180 180,360 360,570 570,660 660,900
out and that'll be due

26
00:01:25,260 --> 00:01:27,840
0,380 610,960 960,1310 2080,2370 2370,2580
on October 1st.| Any questions
|任何关于家庭作业 #1 的问题，

27
00:01:27,840 --> 00:01:30,165
0,180 180,375 375,710 1900,2190 2190,2325
about homework #1| and know
|知道有人在 Piazza 上张贴了关于项目 #1 的帖子，

28
00:01:30,165 --> 00:01:31,305
0,105 105,365 475,720 720,885 885,1140
there somebody there was somebody

29
00:01:31,305 --> 00:01:32,715
0,225 225,390 390,735 735,995 1045,1410
post on Piazza about project

30
00:01:32,715 --> 00:01:34,245
0,300 300,495 495,870 870,1200 1200,1530
#1,| the leaderboard assignment doesn't
|排行榜的作业还没有工作，

31
00:01:34,245 --> 00:01:36,540
0,240 240,545 1135,1530 1530,1950 1950,2295
work yet,| {we're,still}, we're fixing
|我们仍然，我们正在解决这个问题，

32
00:01:36,540 --> 00:01:37,710
0,260 430,690 690,870 870,990 990,1170
that| and we'll push that
|我们会在本周晚些时候把它推送到 GitHub 上，

33
00:01:37,710 --> 00:01:39,640
0,150 150,560 820,1220
on Github later,

34
00:01:39,650 --> 00:01:42,000
0,400 1110,1510 1620,1925 1925,2090 2090,2350
later, later, later this week,|
|

35
00:01:42,230 --> 00:01:43,000
0,245 245,455 455,545 545,665 665,770
then I'll now it's on
然后我将在周三讨论排行榜是什么，

36
00:01:43,000 --> 00:01:44,500
0,290 400,705 705,870 870,1245 1245,1500
Wednesday what the leaderboard is,|
|

37
00:01:44,500 --> 00:01:45,570
0,255 255,345 345,690 690,840 840,1070
what the implications of it
它的含义是什么，为什么它很重要。

38
00:01:46,700 --> 00:01:49,220
0,275 275,410 410,530 530,790
and why it matters.|
|

39
00:01:49,550 --> 00:01:51,340
0,245 245,490 1290,1520 1520,1640 1640,1790
All right, the other thing,
好的，另外一件事，是额外的事情，

40
00:01:51,340 --> 00:01:52,420
0,150 150,270 270,510 510,780 780,1080
that's going on for for

41
00:01:52,420 --> 00:01:53,860
0,345 345,710 1030,1275 1275,1365 1365,1440
additional things,| if you want
|如果你想学习我们在这门课上讨论的以外的东西，

42
00:01:53,860 --> 00:01:55,075
0,60 60,290 640,945 945,1110 1110,1215
to learn beyond the stuff

43
00:01:55,075 --> 00:01:55,675
0,135 135,255 255,405 405,495 495,600
we're talking about in the

44
00:01:55,675 --> 00:01:57,085
0,275 655,1005 1005,1245 1245,1305 1305,1410
course,| {} there's a couple
|接下来会有几场关于数据库的讨论，

45
00:01:57,085 --> 00:01:59,245
0,120 120,360 360,755 1285,1685 1855,2160
of database talks that are

46
00:01:59,245 --> 00:02:01,195
0,225 225,545 985,1260 1260,1535 1615,1950
coming up,| so today after
|所以今天课后的 4:30 ，

47
00:02:01,195 --> 00:02:02,290
0,210 210,360 360,525 525,810 810,1095
class at {4:30 -},| we're
|我们有 Qdrant 的人，来自德国，

48
00:02:02,290 --> 00:02:03,720
0,210 210,570 570,840 840,1170 1170,1430
having the the Qdrant guys,

49
00:02:04,100 --> 00:02:05,800
0,260 260,380 380,640 960,1450 1470,1700
out of Germany,| they're one
|它们是向量数据库之一，

50
00:02:05,800 --> 00:02:06,985
0,60 60,180 180,405 405,975 975,1185
of these vector databases,| that
|针对 LLM 或 ChatGBT 之类的设置，

51
00:02:06,985 --> 00:02:08,110
0,255 255,480 480,615 615,855 855,1125
target {LLMs - -} or

52
00:02:08,110 --> 00:02:10,530
0,165 165,585 585,765 765,1010 1780,2420
{ChatGPT -} kind of setups,|
|

53
00:02:10,670 --> 00:02:11,830
0,320 320,395 395,605 605,905 905,1160
they'll be talking about their
他们将谈论他们系统的内部结构，

54
00:02:11,830 --> 00:02:12,810
0,195 195,405 405,495 495,660 660,980
the internals of their system|
|

55
00:02:13,250 --> 00:02:14,155
0,245 245,455 455,560 560,740 740,905
and that'll be again {4:30
这将是在 4:30 ，通过 Zoom 。

56
00:02:14,155 --> 00:02:16,255
0,180 180,405 405,755 1225,1625 1765,2100
-} over Zoom.| Tomorrow at
|明天下午 6 点，

57
00:02:16,255 --> 00:02:17,665
0,255 420,630 630,855 855,1200 1200,1410
{6:00pm -},| the Databricks people
|Databricks 的人在盖茨大楼的某个地方开展讲座，

58
00:02:17,665 --> 00:02:20,230
0,330 330,660 660,995 2155,2430 2430,2565
giving talks somewhere, somewhere in

59
00:02:20,230 --> 00:02:21,595
0,165 165,470 640,945 945,1080 1080,1365
Gates Building,| it's a recruiting
|这是一场招聘讲座，

60
00:02:21,595 --> 00:02:23,125
0,275 295,695 1015,1275 1275,1380 1380,1530
talk,| but these are probably
|但这些可能会满足你的需求，

61
00:02:23,125 --> 00:02:24,580
0,150 150,255 255,390 390,665 1195,1455
going to feed you| and
|然后你可以与他们谈论在那里找到工作的问题，

62
00:02:24,580 --> 00:02:25,075
0,105 105,195 195,285 285,405 405,495
then you can talk to

63
00:02:25,075 --> 00:02:26,280
0,150 150,375 375,630 630,900 900,1205
them about getting jobs there,|
|

64
00:02:27,350 --> 00:02:29,160
0,515 515,680 680,970 1320,1565 1565,1810
Databricks has hired pretty much
在过去的两三年里， Databricks 录取了几乎所有我最好的学生，

65
00:02:29,240 --> 00:02:30,415
0,275 275,500 500,725 725,905 905,1175
almost all my best students

66
00:02:30,415 --> 00:02:31,780
0,225 225,330 330,575 985,1245 1245,1365
in the last two or

67
00:02:31,780 --> 00:02:33,730
0,120 120,380 1390,1710 1710,1815 1815,1950
three years,| they've all gone
|他们都去了 Databricks ，

68
00:02:33,730 --> 00:02:34,930
0,105 105,650 730,975 975,1080 1080,1200
to Databricks| and I was
|我在 7 月份在那里，他们都做得很好，

69
00:02:34,930 --> 00:02:35,980
0,260 310,570 570,750 750,915 915,1050
there in July and they're

70
00:02:35,980 --> 00:02:38,020
0,105 105,285 285,590 1750,1980 1980,2040
all doing great,| they have
|他们有很多钱，但没有给我们任何钱。

71
00:02:38,020 --> 00:02:39,265
0,60 60,150 150,240 240,470 850,1245
a lot of money {and,they,don't}

72
00:02:39,265 --> 00:02:43,255
0,60 60,150 150,395 3295,3795 3795,3990
give us any.| {And,then,OtterTune} is
|然后 OtterTune 是我的初创公司，

73
00:02:43,255 --> 00:02:45,000
0,195 195,360 360,815 1195,1470 1470,1745
actually my startup,| but my,
|我以前的博士生，也是联合创始人， Dana Van Aken ，

74
00:02:45,050 --> 00:02:46,615
0,400 540,860 860,1175 1175,1355 1355,1565
my former PhD student, who's

75
00:02:46,615 --> 00:02:47,580
0,165 165,375 375,585 585,690 690,965
a {co-founder -} with me,

76
00:02:47,810 --> 00:02:48,805
0,365 365,470 470,770 770,935 935,995
Dana Van Aken,| she'll be
|她将发表演讲，

77
00:02:48,805 --> 00:02:49,780
0,135 135,300 300,570 570,945
giving a talk about,|
|

78
00:02:49,880 --> 00:02:51,625
0,400 840,1130 1130,1295 1295,1520 1520,1745
{} what, what we're doing
我们如何利用机器学习来优化数据库系统， Postgres MySQL ，

79
00:02:51,625 --> 00:02:52,690
0,345 345,555 555,675 675,825 825,1065
using machine learning to optimize

80
00:02:52,690 --> 00:02:55,180
0,240 240,590 1750,2205 2205,2325 2325,2490
database systems, {Postgres,Mysql},| next week.|
|在下周。|

81
00:02:55,180 --> 00:02:56,935
0,290 370,830 1060,1365 1365,1545 1545,1755
Yes.| {Where,can,we,have} information about the
是的。|我们在哪里找到关于地点的信息？

82
00:02:56,935 --> 00:03:00,235
0,335 2125,2445 2445,2685 2685,2955 2955,3300
location.| So my talks, the
|所以我的演讲， Qdrant 这个， OtterTune 这个，是在 Zoom 上，

83
00:03:00,235 --> 00:03:01,900
0,390 390,635 745,1020 1020,1295 1315,1665
Qdrant one, OtterTune one, that's

84
00:03:01,900 --> 00:03:03,295
0,135 135,470 700,960 960,1185 1185,1395
on Zoom,| and then if
|然后如果你打开幻灯片，

85
00:03:03,295 --> 00:03:03,865
0,90 90,165 165,240 240,360 360,570
you go on the slides,|
|

86
00:03:03,865 --> 00:03:04,750
0,210 210,390 390,585 585,750 750,885
the link here will take
这里的链接会把你带到日程，

87
00:03:04,750 --> 00:03:05,515
0,135 135,360 360,570 570,660 660,765
you to whatever it is

88
00:03:05,515 --> 00:03:07,860
0,210 210,545 1675,1950 1950,2085 2085,2345
on {the,calendar},| somewhere in Gates,|
|盖茨大楼的某个地方，|

89
00:03:09,100 --> 00:03:11,330
0,335 335,515 515,710 710,1060 1830,2230
for the Databricks one.| Yep.|
对于 Databricks 这个。|是的。|

90
00:03:12,460 --> 00:03:14,700
0,400 1440,1700 1700,1820 1820,1940 1940,2240
{Other,questions},| again these are optional,|
还有其他问题吗，|这些也是可选的，|

91
00:03:14,700 --> 00:03:15,180
0,120 120,225 225,330 330,420 420,480
these are like, if you
如果你想要超越课程中要谈论的东西。

92
00:03:15,180 --> 00:03:15,720
0,60 60,135 135,270 270,420 420,540
want to go beyond the

93
00:03:15,720 --> 00:03:16,170
0,105 105,180 180,270 270,375 375,450
stuff to talk about in

94
00:03:16,170 --> 00:03:17,100
0,75 75,320 520,750 750,825 825,930
the course.| And what I
|我喜欢这种演讲的地方是，

95
00:03:17,100 --> 00:03:17,835
0,180 180,375 375,510 510,615 615,735
like about these kind of

96
00:03:17,835 --> 00:03:19,515
0,180 180,360 360,635 1075,1455 1455,1680
talks is,| like even if
|即使你现在什么都不懂，

97
00:03:19,515 --> 00:03:20,445
0,90 90,375 375,585 585,750 750,930
you don't understand anything right

98
00:03:20,445 --> 00:03:22,230
0,305 1015,1320 1320,1500 1500,1665 1665,1785
away,| we hit these a
|我们整个学期都在谈论这些话题，

99
00:03:22,230 --> 00:03:23,160
0,90 90,180 180,300 300,590 640,930
lot of these topics throughout

100
00:03:23,160 --> 00:03:24,225
0,135 135,440 610,870 870,945 945,1065
the semester| and then you
|然后你就会意识到我并没有疯，

101
00:03:24,225 --> 00:03:26,000
0,305 715,1065 1065,1200 1200,1440 1440,1775
realize I'm not crazy,| well,
|好吧，我是疯了，但不是那么疯狂，

102
00:03:26,020 --> 00:03:26,955
0,350 350,515 515,665 665,785 785,935
I'm crazy, but like not

103
00:03:26,955 --> 00:03:28,050
0,180 180,420 420,615 615,825 825,1095
that crazy,| that like I'm
|我不是在胡编乱造，

104
00:03:28,050 --> 00:03:29,085
0,135 135,390 390,615 615,825 825,1035
not making stuff up,| these
|这就是我们在本学期要讨论的内容，

105
00:03:29,085 --> 00:03:30,210
0,275 445,705 705,840 840,1005 1005,1125
are the things we're talking

106
00:03:30,210 --> 00:03:31,395
0,150 150,240 240,330 330,650 940,1185
about in this semester,| You
|你应该知道适用于建立真正的系统。

107
00:03:31,395 --> 00:03:32,360
0,180 180,405 405,600 600,720 720,965
know, you need to know

108
00:03:32,410 --> 00:03:34,140
0,290 290,635 635,910 1200,1520 1520,1730
are applicable to building real

109
00:03:34,140 --> 00:03:35,600
0,290
systems.|
|

110
00:03:36,770 --> 00:03:38,305
0,260 260,520 810,1085 1085,1280 1280,1535
All right, so last class
好的，上一节课我们谈到了，

111
00:03:38,305 --> 00:03:41,130
0,210 210,420 420,755 2365,2595 2595,2825
we talked about,| you know,
|你们会有什么样的框架的初始设置，

112
00:03:41,510 --> 00:03:42,820
0,305 305,575 575,950 950,1130 1130,1310
the initial setup for what

113
00:03:42,820 --> 00:03:43,600
0,180 180,435 435,675 675,720 720,780
the framework you're going to

114
00:03:43,600 --> 00:03:44,500
0,105 105,210 210,315 315,585 585,900
have in our minds| for
|描述我们如何建立一个数据管理系统，

115
00:03:44,500 --> 00:03:45,340
0,345 345,510 510,690 690,750 750,840
describing how we're going to

116
00:03:45,340 --> 00:03:47,110
0,260 760,1035 1035,1230 1230,1485 1485,1770
build a database management system,|
|

117
00:03:47,110 --> 00:03:49,090
0,240 240,465 465,795 795,1190 1660,1980
and we discussed how it
我们讨论了它如何成为面向磁盘的架构，

118
00:03:49,090 --> 00:03:52,830
0,225 225,530 1690,2205 2205,2510 3340,3740
was a disk-oriented architecture,| where
|其中系统中的所有组件都基于这一关键前提，

119
00:03:53,330 --> 00:03:54,610
0,365 365,665 665,950 950,1145 1145,1280
all the components in the

120
00:03:54,610 --> 00:03:58,105
0,255 255,510 510,800 2890,3255 3255,3495
system are really based around

121
00:03:58,105 --> 00:03:59,490
0,165 165,375 375,630 630,1050 1050,1385
this, this key premise,| that
|数据库的主要搜索位置，

122
00:03:59,810 --> 00:04:01,180
0,320 320,620 620,950 950,1205 1205,1370
the primary search location of

123
00:04:01,180 --> 00:04:02,410
0,120 120,380 490,750 750,975 975,1230
the database,| when is when
|当它处于静止状态时，

124
00:04:02,410 --> 00:04:03,775
0,165 165,300 300,465 465,770 1090,1365
it is at rest,| will
|将位于某些非易失性磁盘上，

125
00:04:03,775 --> 00:04:05,770
0,150 150,425 925,1325 1465,1755 1755,1995
be on some, some {non-volatile

126
00:04:05,770 --> 00:04:08,155
0,435 435,920 1300,1545 1545,2085 2085,2385
-} disk, right,| SSD, spinning
|SSD ，旋转磁盘硬盘，并不重要。

127
00:04:08,155 --> 00:04:09,030
0,120 120,270 270,435 435,645 645,875
disk hard drive, doesn't matter.|
|

128
00:04:09,520 --> 00:04:11,095
0,240 240,530 700,1050 1050,1365 1365,1575
And that the components of
系统的组件实际上是，

129
00:04:11,095 --> 00:04:12,210
0,105 105,270 270,480 480,750 750,1115
the system are really about|
|

130
00:04:12,620 --> 00:04:13,960
0,365 365,605 605,875 875,1160 1160,1340
moving the data back and
在磁盘和内存之间来回移动数据，

131
00:04:13,960 --> 00:04:15,625
0,270 270,650 940,1350 1350,1440 1440,1665
forth between disk and memory,|
|

132
00:04:15,625 --> 00:04:16,830
0,285 285,495 495,570 570,900 900,1205
because it's a {Von,Neumann} architecture,|
因为它是一个冯·诺伊曼架构，|

133
00:04:16,880 --> 00:04:18,030
0,275 275,560 560,755 755,890 890,1150
you can't operate on it,
当它处于静止状态时，你不能对其进行操作。

134
00:04:18,200 --> 00:04:20,100
0,365 365,635 635,755 755,1060
while it's at rest,

135
00:04:20,390 --> 00:04:21,505
0,320 320,485 485,725 725,920 920,1115
right.| So that's really what
|所以，这就是我们试图实现的总体目标。

136
00:04:21,505 --> 00:04:23,755
0,210 210,545 1465,1785 1785,2025 2025,2250
the, the, the big picture

137
00:04:23,755 --> 00:04:24,430
0,150 150,255 255,435 435,525 525,675
of what we're trying to

138
00:04:24,430 --> 00:04:25,585
0,290 520,750 750,810 810,930 930,1155
achieve.| And of course now
|当然，现在由于磁盘速度很慢，

139
00:04:25,585 --> 00:04:27,190
0,240 240,435 435,660 660,995 1345,1605
since disk is slow,| we
|我们需要使用一系列技巧和其他技术，

140
00:04:27,190 --> 00:04:27,595
0,120 120,225 225,285 285,330 330,405
need to do a bunch

141
00:04:27,595 --> 00:04:28,570
0,135 135,585 585,810 810,885 885,975
of tricks and a bunch

142
00:04:28,570 --> 00:04:31,320
0,90 90,210 210,500 670,1070 2350,2750
of other techniques| to, to
|来隐藏磁盘访问的停滞，

143
00:04:31,370 --> 00:04:33,055
0,400 810,1100 1100,1415 1415,1520 1520,1685
hide the stalls of going

144
00:04:33,055 --> 00:04:35,035
0,165 165,665 1075,1350 1350,1815 1815,1980
to disk| by maximizing amount
|通过最大化顺序 IO 的数量。

145
00:04:35,035 --> 00:04:36,760
0,90 90,345 345,725 1345,1575 1575,1725
of sequential IO.| And we'll
|我们今天一开始就会看到，

146
00:04:36,760 --> 00:04:37,870
0,230 370,615 615,735 735,915 915,1110
see in the beginning right

147
00:04:37,870 --> 00:04:39,000
0,240 240,525 525,765 765,870 870,1130
away today,| we'll talk about
|今天我们将讨论不同的方法，

148
00:04:39,320 --> 00:04:41,155
0,350 350,635 635,970 1020,1420 1590,1835
{different,method},| an alternative to what
|这是我们上一节课讨论的另一种方法，

149
00:04:41,155 --> 00:04:41,875
0,90 90,210 210,345 345,510 510,720
we talked about last class,|
|

150
00:04:41,875 --> 00:04:43,150
0,180 180,315 315,420 420,935 985,1275
that tried to maximize sequential
它试图最大化顺序 IO 。

151
00:04:43,150 --> 00:04:44,000
0,165 165,440
{IO -}.|
|

152
00:04:44,610 --> 00:04:45,275
0,260 260,380 380,485 485,605 605,665
And then again, there'll be
然后，还会有其他东西，比如过滤器和索引，

153
00:04:45,275 --> 00:04:46,340
0,135 135,300 300,465 465,840 840,1065
other things like filters and

154
00:04:46,340 --> 00:04:47,510
0,315 315,405 405,525 525,800 880,1170
indexes,| a way to reduce
|这是一种减少必须实际查看的数据量的方法，

155
00:04:47,510 --> 00:04:48,140
0,135 135,240 240,345 345,495 495,630
the amount of data we

156
00:04:48,140 --> 00:04:48,875
0,75 75,240 240,420 420,555 555,735
have to actually look at,|
|

157
00:04:48,875 --> 00:04:50,320
0,165 165,270 270,405 405,815
when we run queries.|
当我们在运行查询时。|

158
00:04:50,540 --> 00:04:51,625
0,245 245,410 410,590 590,770 770,1085
Then we also talked about
然后我们还讨论了一种面向页面的存储方案，

159
00:04:51,625 --> 00:04:53,550
0,395 595,900 900,1365 1365,1605 1605,1925
a page oriented storage scheme,|
|

160
00:04:54,440 --> 00:04:56,250
0,275 275,590 590,800 800,1150 1410,1810
the slotted page architecture,| where
插槽页面架构，|它允许我们在堆文件中存储任意长度、可变长度的 tuple ，

161
00:04:56,630 --> 00:04:57,610
0,245 245,395 395,605 605,785 785,980
it would allow us to

162
00:04:57,610 --> 00:04:59,575
0,320 520,1050 1050,1320 1320,1740 1740,1965
store tuples of arbitrary length,

163
00:04:59,575 --> 00:05:01,630
0,240 240,435 435,755 1615,1890 1890,2055
variable length sizes across these

164
00:05:01,630 --> 00:05:03,340
0,210 210,470 880,1170 1170,1455 1455,1710
heap files| and then we
|然后我们可以根据需要扩展 tuple 的大小，

165
00:05:03,340 --> 00:05:05,275
0,255 255,645 645,1040 1120,1520 1660,1935
could expand the the the

166
00:05:05,275 --> 00:05:06,580
0,195 195,360 360,465 465,875 985,1305
size of the tuple as

167
00:05:06,580 --> 00:05:08,095
0,320 460,705 705,930 930,1230 1230,1515
needed,| you know, according to
|根据它是否适合页面。

168
00:05:08,095 --> 00:05:08,800
0,240 240,345 345,465 465,600 600,705
according to whether it fit

169
00:05:08,800 --> 00:05:09,480
0,90 90,180 180,315 315,435 435,680
in the page or not.|
|

170
00:05:10,000 --> 00:05:11,180
0,260
{All,right}.|
好的。|

171
00:05:12,240 --> 00:05:13,130
0,305 305,470 470,605 605,755 755,890
So I would say what
所以我会说，我们上次所描述的是，

172
00:05:13,130 --> 00:05:14,470
0,105 105,270 270,690 690,960 960,1340
we were describing last time

173
00:05:14,910 --> 00:05:16,340
0,400 600,845 845,980 980,1265 1265,1430
is,| what I'll loosely term
|我将粗略地称为面向 tuple 的存储方案，

174
00:05:16,340 --> 00:05:17,900
0,210 210,480 480,810 810,1200 1200,1560
to as a {tuple-oriented -}

175
00:05:17,900 --> 00:05:19,160
0,330 330,680
storage scheme,|
|

176
00:05:19,340 --> 00:05:20,155
0,245 245,350 350,500 500,665 665,815
what that really means is
这实际上意味着，

177
00:05:20,155 --> 00:05:21,445
0,165 165,405 405,755 775,1080 1080,1290
that,| the, the system is
|这个系统实际上是关于，

178
00:05:21,445 --> 00:05:22,390
0,225 225,495 495,720 720,840 840,945
really about,| I got a
|我有一个 tuple ，我要把它放在某个地方，

179
00:05:22,390 --> 00:05:23,155
0,285 285,435 435,555 555,660 660,765
tuple, I got to put

180
00:05:23,155 --> 00:05:24,895
0,90 90,335 775,1065 1065,1355 1465,1740
it somewhere, right,| and, and
|页面的布局基于这一点，

181
00:05:24,895 --> 00:05:26,170
0,275 325,675 675,870 870,975 975,1275
the pages of the layout,

182
00:05:26,170 --> 00:05:27,265
0,135 135,705 705,795 795,900 900,1095
the layouts of the pages

183
00:05:27,265 --> 00:05:28,825
0,180 180,425 595,945 945,1275 1275,1560
are really based around this,|
|

184
00:05:28,825 --> 00:05:29,755
0,195 195,360 360,495 495,615 615,930
like I got a tuple,
我有一个 tuple ，让我把它存储起来。

185
00:05:29,755 --> 00:05:30,810
0,300 300,510 510,630 630,780 780,1055
like let me store it.|
|

186
00:05:31,800 --> 00:05:32,930
0,275 275,485 485,710 710,935 935,1130
And so in this, in
所以，在这个架构中，

187
00:05:32,930 --> 00:05:33,905
0,120 120,380 490,735 735,840 840,975
this architecture,| if you wanted
|如果你想要插入一个新的 tuple ，

188
00:05:33,905 --> 00:05:34,870
0,90 90,300 300,420 420,540 540,965
to insert a new tuple,|
|

189
00:05:35,310 --> 00:05:35,915
0,230 230,320 320,425 425,515 515,605
the way you would do
你可以做的方法是，

190
00:05:35,915 --> 00:05:36,905
0,90 90,335 505,750 750,870 870,990
it is,| you go look
|你可以查看页面目录，

191
00:05:36,905 --> 00:05:38,405
0,75 75,165 165,360 360,875 1135,1500
at the page directory| and
|在堆文件中找到某个位置，

192
00:05:38,405 --> 00:05:40,610
0,365 715,1115 1435,1695 1695,1920 1920,2205
find somewhere in your heap

193
00:05:40,610 --> 00:05:41,915
0,260 580,855 855,1035 1035,1185 1185,1305
files,| a page with a
|一个有空闲插槽的页面，

194
00:05:41,915 --> 00:05:43,565
0,165 165,485 1105,1350 1350,1470 1470,1650
free slot,| we said that
|我们说页面目录维护了元数据，

195
00:05:43,565 --> 00:05:44,480
0,165 165,330 330,600 600,690 690,915
the page directory had maintained

196
00:05:44,480 --> 00:05:46,025
0,525 525,660 660,950 1030,1350 1350,1545
metadata| about what what space
|关于哪些空间是可用的。

197
00:05:46,025 --> 00:05:47,220
0,180 180,485
is available.|
|

198
00:05:47,850 --> 00:05:49,070
0,260 260,520 690,980 980,1115 1115,1220
And then once we have
然后一旦我们有了，我们想要插入 tuple 的页面，

199
00:05:49,070 --> 00:05:49,685
0,120 120,285 285,435 435,525 525,615
our page, that we want

200
00:05:49,685 --> 00:05:50,650
0,90 90,330 330,480 480,720 720,965
to insert the tuple into,|
|

201
00:05:51,090 --> 00:05:53,660
0,400 870,1145 1145,1355 1355,1600 2250,2570
if, if it's not memory,|
如果这不是内存，|

202
00:05:53,660 --> 00:05:54,610
0,180 180,240 240,315 315,405 405,950
they got to go {to,disk}
他们就必须去磁盘获取它，

203
00:05:54,630 --> 00:05:55,790
0,245 245,395 395,515 515,760 900,1160
and fetch it in,| which
|我们将在下周讨论，

204
00:05:55,790 --> 00:05:56,585
0,150 150,270 270,450 450,630 630,795
we'll talk about next week,|
|

205
00:05:56,585 --> 00:05:57,400
0,120 120,225 225,345 345,510 510,815
how we do that,| but
我们如何做到，|但是想想读取一个文件，带入内存，

206
00:05:57,660 --> 00:05:58,655
0,245 245,410 410,635 635,800 800,995
think of reading a file,

207
00:05:58,655 --> 00:06:00,490
0,240 240,390 390,635 1285,1560 1560,1835
bringing the memory,| and then
|一旦我们有了那个页面，

208
00:06:00,570 --> 00:06:01,535
0,290 290,425 425,545 545,725 725,965
once we have that page,|
|

209
00:06:01,535 --> 00:06:02,240
0,195 195,330 330,465 465,570 570,705
we go look in that
我们就去查看那个 slot array ，

210
00:06:02,240 --> 00:06:03,815
0,285 285,620 1000,1245 1245,1365 1365,1575
slot array| and we say,
|我们说，可以存储这个 tuple 的下一个空闲插槽是什么，

211
00:06:03,815 --> 00:06:04,565
0,165 165,270 270,525 525,600 600,750
you know, what's the next

212
00:06:04,565 --> 00:06:05,630
0,210 210,450 450,630 630,840 840,1065
free slot, where we can

213
00:06:05,630 --> 00:06:07,340
0,150 150,285 285,740 1330,1590 1590,1710
store this tuple,| update the
|更新 slot array ，将 tuple 放入页面中，

214
00:06:07,340 --> 00:06:08,645
0,210 210,530 730,990 990,1110 1110,1305
slot array, put the tuple

215
00:06:08,645 --> 00:06:10,730
0,335 805,1080 1080,1355 1705,1965 1965,2085
inside the page,| and then
|然后我们就完成了。

216
00:06:10,730 --> 00:06:11,680
0,150 150,380
we're done.|
|

217
00:06:12,900 --> 00:06:13,895
0,350 350,575 575,710 710,920 920,995
To update a tuple in
在这个环境中更新 tuple 基本上是相同的，

218
00:06:13,895 --> 00:06:15,140
0,150 150,435 435,720 720,1005 1005,1245
this environment is basically the

219
00:06:15,140 --> 00:06:17,600
0,165 165,470 1510,1910 2080,2400 2400,2460
same thing,| where we're going
|我们将有一些方法来获得 tuple 的 record ID ，

220
00:06:17,600 --> 00:06:18,500
0,60 60,240 240,495 495,720 720,900
to have some way to

221
00:06:18,500 --> 00:06:19,445
0,135 135,300 300,510 510,765 765,945
get the record ID of

222
00:06:19,445 --> 00:06:21,095
0,120 120,545 1165,1410 1410,1515 1515,1650
a tuple,| we said this
|我们说这通常是页面 ID 和偏移量或插槽编号，

223
00:06:21,095 --> 00:06:22,240
0,180 180,465 465,705 705,855 855,1145
is typically the page ID

224
00:06:22,350 --> 00:06:23,480
0,275 275,515 515,830 830,1025 1025,1130
and the offset or the

225
00:06:23,480 --> 00:06:25,715
0,210 210,1000 1000,1770 1770,1950 1950,2070 2070,2235
slot {number\,,right},| ignoring how we got
|忽略我们如何获得它，

226
00:06:25,715 --> 00:06:27,965
0,305 895,1245 1245,1595 1735,2055 2055,2250
that,| which which what index
|索引将为我们做什么，

227
00:06:27,965 --> 00:06:28,910
0,120 120,225 225,315 315,525 525,945
will do for us,| ignoring,
|忽略它，假设我们可以做到，

228
00:06:28,910 --> 00:06:30,245
0,315 315,620 790,1050 1050,1185 1185,1335
ignoring that, assume we could

229
00:06:30,245 --> 00:06:31,595
0,135 135,395 685,930 930,1140 1140,1350
do that,| we go, go
|我们再一次去页面目录，

230
00:06:31,595 --> 00:06:32,495
0,75 75,165 165,315 315,645 645,900
in the page directory again,|
|

231
00:06:32,495 --> 00:06:33,290
0,240 240,420 420,600 600,705 705,795
find the location of this
找到这个页面的位置，

232
00:06:33,290 --> 00:06:34,610
0,260 580,840 840,990 990,1155 1155,1320
page,| if it's in, if
|如果它在内存中，我们就没问题了，

233
00:06:34,610 --> 00:06:35,690
0,120 120,210 210,470 610,900 900,1080
it's in memory, we're good,|
|

234
00:06:35,690 --> 00:06:36,395
0,240 240,420 420,555 555,630 630,705
if not, we got to
如果没有，我们就得去磁盘上拿到它，

235
00:06:36,395 --> 00:06:37,150
0,105 105,285 285,375 375,495 495,755
go disk and get it,|
|

236
00:06:37,470 --> 00:06:38,300
0,305 305,455 455,545 545,650 650,830
then look at the page
然后查看页面和 slot array ，找到偏移量，

237
00:06:38,300 --> 00:06:39,260
0,180 180,285 285,480 480,735 735,960
and the slot array, find

238
00:06:39,260 --> 00:06:40,550
0,240 240,590 730,1005 1005,1155 1155,1290
the offset| and then if
|然后如果是新的 tuple ，

239
00:06:40,550 --> 00:06:41,585
0,150 150,390 390,750 750,915 915,1035
the new tuple, we're trying

240
00:06:41,585 --> 00:06:42,545
0,210 210,435 435,630 630,795 795,960
to,| the updated tuple we're
|我们试图安装的更新 tuple ，

241
00:06:42,545 --> 00:06:44,600
0,245 415,815 1135,1535
trying to install,|
|

242
00:06:44,600 --> 00:06:45,700
0,180 180,450 450,585 585,780 780,1100
If that's the same size
如果它与原始 tuple ，存在的 tuple 大小相同，

243
00:06:45,810 --> 00:06:47,450
0,395 395,790 900,1250 1250,1460 1460,1640
of the original tuple of

244
00:06:47,450 --> 00:06:48,530
0,210 210,500 640,885 885,975 975,1080
existing tuple,| then we just
|那么我们只需覆盖它，

245
00:06:48,530 --> 00:06:50,210
0,360 360,650 850,1170 1170,1440 1440,1680
overwrite it,| if not, then
|如果没有，那么你可能需要找到另一个可以容纳它的页面，

246
00:06:50,210 --> 00:06:50,870
0,165 165,285 285,375 375,480 480,660
maybe you got to find

247
00:06:50,870 --> 00:06:52,445
0,240 240,540 540,915 915,1215 1215,1575
another page that could accommodate

248
00:06:52,445 --> 00:06:53,105
0,105 105,180 180,360 360,495 495,660
it,| if there's no space
|那么我们正在查看的页面中没有空间。

249
00:06:53,105 --> 00:06:53,720
0,105 105,180 180,300 300,480 480,615
in the page we're looking

250
00:06:53,720 --> 00:06:54,640
0,320
at,

251
00:06:54,950 --> 00:06:56,785
0,400 1080,1370 1370,1535 1535,1670 1670,1835
right.| And this is the
|这就是堆文件使用面向页面架构的核心理念，

252
00:06:56,785 --> 00:06:58,230
0,300 300,630 630,885 885,1125 1125,1445
core of idea of, of

253
00:06:58,310 --> 00:07:00,900
0,400 930,1330 1590,1895 1895,2195 2195,2590
what the heap files with

254
00:07:02,180 --> 00:07:03,850
0,290 290,545 545,820 960,1340 1340,1670
{page-oriented -} architecture,| and that's
|这是基于 tuple 的，

255
00:07:03,850 --> 00:07:05,275
0,150 150,330 330,740 940,1200 1200,1425
based on tuples,| this is
|这基本上就是任何系统的实际运作方式。

256
00:07:05,275 --> 00:07:06,505
0,360 360,630 630,825 825,1035 1035,1230
basically how any system would

257
00:07:06,505 --> 00:07:07,500
0,165 165,425
actually work.|
|

258
00:07:09,120 --> 00:07:09,815
0,230 230,305 305,380 380,485 485,695
So what are some problems
那么，这有什么问题呢，

259
00:07:09,815 --> 00:07:11,700
0,195 195,455
with this,|
|

260
00:07:12,070 --> 00:07:12,825
0,275 275,425 425,560 560,665 665,755
we touched on some of
我们在上一节课中，谈到了一些内容，

261
00:07:12,825 --> 00:07:14,200
0,135 135,315 315,605
these last class,|
|

262
00:07:18,610 --> 00:07:20,380
0,260 260,410 410,700
is it efficient,|
它是高效的吗，|

263
00:07:22,580 --> 00:07:24,480
0,245 245,500 500,710 710,1060
for reads, maybe, right,|
对于读取，可能是，|

264
00:07:24,620 --> 00:07:25,630
0,290 290,530 530,725 725,845 845,1010
right, because if I need
因为如果我需要整个 tuple ，

265
00:07:25,630 --> 00:07:26,640
0,180 180,375 375,555 555,720 720,1010
the entire {tuple -},| I
|我会去一个页面拿到它，

266
00:07:26,750 --> 00:07:27,460
0,230 230,290 290,410 410,575 575,710
go to one page and

267
00:07:27,460 --> 00:07:29,695
0,120 120,380 580,975 975,1250 1990,2235
get it,| that's okay,| but
|这是可以的，|但是如果我开始更新某些内容，

268
00:07:29,695 --> 00:07:30,775
0,75 75,225 225,525 525,900 900,1080
if I start updating things,|
|

269
00:07:30,775 --> 00:07:31,690
0,225 225,330 330,510 510,750 750,915
I've started making writes, to
我开始写入操作，做插入、更新、删除，

270
00:07:31,690 --> 00:07:33,715
0,105 105,585 585,780 780,1340 1720,2025
do inserts, updates, deletes,| I
|我的页面可能会变得支离破碎，

271
00:07:33,715 --> 00:07:34,660
0,150 150,240 240,330 330,435 435,945
could end up with fragmentation

272
00:07:34,660 --> 00:07:36,620
0,150 150,270 270,560 880,1280
in my pages, right,|
|

273
00:07:36,620 --> 00:07:37,775
0,225 225,375 375,650 670,990 990,1155
I could have pages that
我可能有一些页面没有被充分利用，

274
00:07:37,775 --> 00:07:38,950
0,90 90,225 225,435 435,855 855,1175
are not fully utilized,| meaning
|这意味着我有一点空闲空间，

275
00:07:39,270 --> 00:07:41,480
0,400 1260,1660 1770,2030 2030,2120 2120,2210
I I have a little

276
00:07:41,480 --> 00:07:42,605
0,240 240,555 555,735 735,855 855,1125
empty space,| where I can't
|无法容纳任何新的 tuple ，

277
00:07:42,605 --> 00:07:44,765
0,165 165,375 375,585 585,875 1825,2160
fit any new tuple,| it's
|它不够大放下一个新的 tuple ，

278
00:07:44,765 --> 00:07:45,245
0,105 105,225 225,330 330,405 405,480
not big enough for a

279
00:07:45,245 --> 00:07:46,415
0,120 120,395 655,885 885,975 975,1170
new tuple,| so I can't
|所以我不能用它，它就浪费了，

280
00:07:46,415 --> 00:07:47,345
0,135 135,285 285,540 540,795 795,930
use it, but it just

281
00:07:47,345 --> 00:07:48,860
0,300 300,435 435,540 540,815
wasted,| it's just there,
|它就在那里，

282
00:07:50,640 --> 00:07:52,850
0,400 930,1205 1205,1400 1400,1720 1950,2210
right,| or even before, you
|甚至在之前，如果我运行那个空间，

283
00:07:52,850 --> 00:07:53,615
0,90 90,150 150,360 360,600 600,765
know, if I run that

284
00:07:53,615 --> 00:07:54,830
0,305 385,705 705,900 900,1065 1065,1215
space,| if, if I have
|如果我必须插入一个新的 tuple ，

285
00:07:54,830 --> 00:07:56,570
0,90 90,330 330,980 1390,1635 1635,1740
to insert {a,new,tuple},| I got
|我必须分配，

286
00:07:56,570 --> 00:07:57,830
0,90 90,510 510,690 690,920 970,1260
to allocate,| you know, assuming
|假设我的 tuple 什么都没有，

287
00:07:57,830 --> 00:07:58,280
0,105 105,165 165,270 270,360 360,450
I have nothing in my

288
00:07:58,280 --> 00:07:59,300
0,225 225,510 510,705 705,945 945,1020
tuple,| I I insert it
|我把它插入到 tuple 中，

289
00:07:59,300 --> 00:08:00,370
0,315 315,405 405,690 690,810 810,1070
{into,tuple},| I allocate a page,|
|我分配一个页面，|

290
00:08:00,660 --> 00:08:01,745
0,245 245,530 530,770 770,1025 1025,1085
I insert one tuple in
我在那个页面中插入一个 tuple ，

291
00:08:01,745 --> 00:08:03,290
0,120 120,395 715,1110 1110,1335 1335,1545
that page,| there's nothing else
|那一页上没有其他东西了，

292
00:08:03,290 --> 00:08:05,060
0,135 135,270 270,560 1210,1545 1545,1770
on that page,| again, depending
|同样，根据我的页面大小，

293
00:08:05,060 --> 00:08:06,065
0,150 150,300 300,555 555,780 780,1005
on the size of my

294
00:08:06,065 --> 00:08:07,490
0,270 270,540 540,900 900,1230 1230,1425
my page pages,| which could
|每个系统的大小可能会有所不同，

295
00:08:07,490 --> 00:08:08,780
0,260 400,735 735,915 915,1125 1125,1290
be it's different for per

296
00:08:08,780 --> 00:08:10,280
0,290 880,1185 1185,1230 1230,1305 1305,1500
systems,| there's a bunch empty
|有一大堆空闲空间没有被使用。

297
00:08:10,280 --> 00:08:11,120
0,240 240,435 435,525 525,675 675,840
space that's just not being

298
00:08:11,120 --> 00:08:12,540
0,290
used.|
|

299
00:08:13,960 --> 00:08:14,925
0,290 290,470 470,635 635,800 800,965
Next challenge we face is
我们面临的下一个挑战是无用的磁盘 I/O ，

300
00:08:14,925 --> 00:08:15,900
0,135 135,285 285,630 630,795 795,975
as much useless disk {I/O

301
00:08:15,900 --> 00:08:17,205
0,380 760,975 975,1035 1035,1140 1140,1305
-},| so if I got
|所以，如果我更新一个 tuple ，

302
00:08:17,205 --> 00:08:18,195
0,195 195,405 405,750 750,825 825,990
update one tuple,| if it's
|如果它不在内存中，

303
00:08:18,195 --> 00:08:19,110
0,195 195,390 390,585 585,765 765,915
not in memory,| I gotta
|我必须去磁盘上取回它，

304
00:08:19,110 --> 00:08:20,120
0,195 195,450 450,540 540,720 720,1010
go disk and fetch it,|
|

305
00:08:20,320 --> 00:08:21,030
0,245 245,335 335,470 470,560 560,710
but if it's in that
但如果在那个页面的那一边，

306
00:08:21,030 --> 00:08:21,855
0,150 150,240 240,375 375,630 630,825
side of that page,| what
|我能得到什么，

307
00:08:21,855 --> 00:08:23,320
0,75 75,180 180,455
am I getting,

308
00:08:23,910 --> 00:08:25,085
0,350 350,605 605,695 695,950 950,1175
right,| we're not storing one
|我们不是每页存储一个 tuple ，

309
00:08:25,085 --> 00:08:26,110
0,285 285,420 420,615 615,780 780,1025
tuple per page,| I mean,
|我的意思是，你可以，但你通常不想这么做，

310
00:08:26,280 --> 00:08:30,275
0,305 305,545 545,880 2760,3160 3690,3995
you could, but you typically

311
00:08:30,275 --> 00:08:30,940
0,180 180,225 225,300 300,405 405,665
don't want to do that,|
|

312
00:08:31,230 --> 00:08:31,865
0,245 245,335 335,425 425,530 530,635
so now if I got
所以，现在如果我要去更新一个页面，抱歉，一个 tuple ，

313
00:08:31,865 --> 00:08:32,770
0,75 75,225 225,420 420,600 600,905
to go update one page,

314
00:08:32,850 --> 00:08:33,890
0,275 275,410 410,515 515,650 650,1040
{} sorry, a one tuple,|
|

315
00:08:33,890 --> 00:08:34,685
0,240 240,330 330,420 420,600 600,795
I got to fetch that
我必须获取整个页面，并带来一堆数据，

316
00:08:34,685 --> 00:08:35,615
0,240 240,510 510,720 720,855 855,930
entire page and bring in

317
00:08:35,615 --> 00:08:36,695
0,60 60,165 165,285 285,545 805,1080
a bunch of data,| that
|这可能甚至不是我需要的，

318
00:08:36,695 --> 00:08:37,730
0,165 165,330 330,495 495,780 780,1035
may not even be what

319
00:08:37,730 --> 00:08:38,765
0,135 135,410 640,885 885,1005 1005,1035
I need,| because there's a
|因为还有一堆其他的 tuple 我没有更新。

320
00:08:38,765 --> 00:08:39,380
0,75 75,165 165,285 285,540 540,615
bunch of other twoils that

321
00:08:39,380 --> 00:08:40,860
0,120 120,255 255,680
I'm not updating.|
|

322
00:08:41,670 --> 00:08:42,380
0,275 275,410 410,515 515,635 635,710
Same thing when I'm going
当我要做写入的时候也是一样的，

323
00:08:42,380 --> 00:08:44,195
0,90 90,165 165,270 270,530 1570,1815
to do a write,| if
|如果我只更新一个 tuple ，

324
00:08:44,195 --> 00:08:45,110
0,165 165,345 345,630 630,765 765,915
I'm only updating one {tuple

325
00:08:45,110 --> 00:08:45,905
0,255 255,405 405,525 525,630 630,795
-},| I had to bring
|我必须把这一页中的 20 个 tuple 带入内存中，

326
00:08:45,905 --> 00:08:47,000
0,300 300,600 600,885 885,990 990,1095
in 20 tuples in the

327
00:08:47,000 --> 00:08:48,185
0,180 180,390 390,680 880,1110 1110,1185
page into memory,| now I
|现在我要把那 20 个 tuple 写回去。

328
00:08:48,185 --> 00:08:49,055
0,90 90,210 210,390 390,750 750,870
gotta write those 20 tuples

329
00:08:49,055 --> 00:08:50,200
0,150 150,425
back out.|
|

330
00:08:52,470 --> 00:08:53,375
0,245 245,335 335,500 500,725 725,905
And the last issue is
最后一个问题是，

331
00:08:53,375 --> 00:08:54,260
0,275 415,705 705,750 750,810 810,885
that,| we're going to get
|我们可能会得到大量随机磁盘 I/O ，

332
00:08:54,260 --> 00:08:55,115
0,210 210,495 495,630 630,735 735,855
a potentially a lot of

333
00:08:55,115 --> 00:08:56,740
0,165 165,435 435,540 540,815 1225,1625
random disk {I/O -},| again
|再说一次，一种[回避的]答案，

334
00:08:56,760 --> 00:08:59,945
0,400 1050,1450 2730,2975 2975,3065 3065,3185
the the sort of the

335
00:08:59,945 --> 00:09:01,280
0,180 180,375 375,665 745,1095 1095,1335
{[cop-out] -} answer| for people
|对于人们问的，这个更有效率，或者哪种方法更好，

336
00:09:01,280 --> 00:09:02,120
0,180 180,345 345,510 510,675 675,840
ask, like is this more

337
00:09:02,120 --> 00:09:03,580
0,240 240,480 480,770 790,1125 1125,1460
efficient or which {approach,is} better,|
|

338
00:09:03,900 --> 00:09:04,640
0,245 245,380 380,500 500,590 590,740
the answer is, it always
答案是，它总是取决于数据库。

339
00:09:04,640 --> 00:09:06,700
0,240 240,570 570,810 810,1400
is depends in databases,

340
00:09:06,700 --> 00:09:07,960
0,285 285,570 570,795 795,945 945,1260
right,| so if your workload
|所以，如果你的工作负载是每次查询只更新一个 tuple ，

341
00:09:07,960 --> 00:09:08,920
0,120 120,315 315,615 615,765 765,960
is only updating a single

342
00:09:08,920 --> 00:09:10,165
0,210 210,330 330,420 420,680 970,1245
tuple at a time per

343
00:09:10,165 --> 00:09:12,145
0,305 625,1025 1315,1605 1605,1740 1740,1980
query,| then maybe this architecture
|那么这个架构可能并不是那么糟糕，

344
00:09:12,145 --> 00:09:13,630
0,315 315,435 435,695 1195,1425 1425,1485
isn't so bad,| but if
|但如果我一次更新 20 个 tuple ，

345
00:09:13,630 --> 00:09:15,250
0,255 255,630 630,1080 1080,1340 1360,1620
I'm updating 20 tuples at

346
00:09:15,250 --> 00:09:16,810
0,105 105,350 880,1140 1140,1320 1320,1560
a time| and those 20
|而这 20 个 tuple 在 20 个单独的页面中，

347
00:09:16,810 --> 00:09:17,815
0,285 285,405 405,555 555,765 765,1005
tuples are in 20 separate

348
00:09:17,815 --> 00:09:19,435
0,335 955,1230 1230,1350 1350,1455 1455,1620
pages,| I got to go
|我必须读取 20 个单独的页面，从磁盘到内存，

349
00:09:19,435 --> 00:09:20,695
0,255 255,510 510,735 735,990 990,1260
read 20 separate pages and,

350
00:09:20,695 --> 00:09:21,930
0,335 355,630 630,840 840,945 945,1235
and from disk into memory,|
|

351
00:09:22,160 --> 00:09:23,035
0,245 245,335 335,500 500,680 680,875
I got to update them|
我必须更新它们，|

352
00:09:23,035 --> 00:09:23,605
0,165 165,255 255,345 345,435 435,570
and I got to write
我必须写出 20 个不同的页面到内存中，从内存到磁盘，

353
00:09:23,605 --> 00:09:25,435
0,275 535,810 810,990 990,1295 1555,1830
out 20 different pages in

354
00:09:25,435 --> 00:09:26,695
0,275 445,705 705,840 840,1065 1065,1260
memory, sorry, from memory to

355
00:09:26,695 --> 00:09:28,105
0,425 565,840 840,1065 1065,1230 1230,1410
disk,| now that's random {I/O
|这是随机 I/O ，

356
00:09:28,105 --> 00:09:29,605
0,275 955,1200 1200,1395 1395,1455 1455,1500
-},| and that's going to
|速度会更慢。

357
00:09:29,605 --> 00:09:31,540
0,90 90,395
be slower.|
|

358
00:09:32,910 --> 00:09:34,160
0,260 260,395 395,670 690,1010 1010,1250
And then not necessarily a
然后不一定是架构本身的问题，

359
00:09:34,160 --> 00:09:35,620
0,270 270,465 465,555 555,800 1060,1460
problem with the architecture itself,|
|

360
00:09:35,880 --> 00:09:37,310
0,400 660,935 935,1115 1115,1280 1280,1430
but it may be the
但情况可能是，我们在一个环境中操作，

361
00:09:37,310 --> 00:09:38,315
0,225 225,420 420,660 660,870 870,1005
case that we're operating in

362
00:09:38,315 --> 00:09:39,890
0,165 165,485 865,1110 1110,1260 1260,1575
an environment,| where we can't
|我们不能进行就地更新，

363
00:09:39,890 --> 00:09:41,110
0,210 210,420 420,600 600,855 855,1220
do those in place updates,|
|

364
00:09:41,820 --> 00:09:42,605
0,260 260,410 410,560 560,680 680,785
that we assume we could
我们认为可以在页面架构中做的，

365
00:09:42,605 --> 00:09:43,175
0,90 90,180 180,285 285,450 450,570
do in a slot of

366
00:09:43,175 --> 00:09:44,420
0,120 120,395
page architecture,|
|

367
00:09:44,560 --> 00:09:45,525
0,260 260,425 425,695 695,830 830,965
meaning I can't fetch a
这意味着我不能获取磁盘中的页面，将其放入内存，

368
00:09:45,525 --> 00:09:46,995
0,275 445,780 780,900 900,1335 1335,1470
page that's in disk, bring

369
00:09:46,995 --> 00:09:48,560
0,75 75,180 180,455 1015,1290 1290,1565
it into memory,| update it
|进行更新，然后将其写回原来的位置，

370
00:09:48,580 --> 00:09:49,590
0,260 260,470 470,680 680,815 815,1010
and then write it back

371
00:09:49,590 --> 00:09:50,235
0,165 165,270 270,390 390,525 525,645
to where I got it

372
00:09:50,235 --> 00:09:51,600
0,245
from,|
|

373
00:09:52,585 --> 00:09:53,290
0,135 135,240 240,375 375,540 540,705
you can't do this in
你不能在某些云存储系统中这样做，

374
00:09:53,290 --> 00:09:55,440
0,195 195,435 435,770 820,1220
some cloud storage systems,

375
00:09:55,450 --> 00:09:57,105
0,400 720,1070 1070,1340 1340,1520 1520,1655
right,| {S3 -}, you can
|S3 ，你可以使用版本控制来解决这个问题，

376
00:09:57,105 --> 00:09:57,780
0,135 135,255 255,390 390,510 510,675
kind of trick it out

377
00:09:57,780 --> 00:09:58,965
0,240 240,720 720,870 870,1005 1005,1185
using versioning,| but like I
|但我不能在一些云数据库系统就地更新，

378
00:09:58,965 --> 00:10:00,195
0,315 315,450 450,615 615,870 870,1230
can't do in place updates

379
00:10:00,195 --> 00:10:02,030
0,395 865,1140 1140,1290 1290,1500 1500,1835
in some cloud database systems|
|

380
00:10:02,260 --> 00:10:04,430
0,400 1230,1460 1460,1685 1685,1865 1865,2170
and the Hadoop file system,
Hadoop 文件系统，这那么常见，

381
00:10:04,630 --> 00:10:05,775
0,290 290,395 395,560 560,830 830,1145
it's not that common anymore,|
|

382
00:10:05,775 --> 00:10:06,990
0,180 180,425 535,840 840,1035 1035,1215
but that is another good
但这是另一个很好的例子，

383
00:10:06,990 --> 00:10:08,090
0,180 180,315 315,555 555,870 870,1100
example,| of like that's a
|它是分布式文件系统，

384
00:10:08,170 --> 00:10:09,290
0,260 260,365 365,530 530,785 785,1120
distributed a file system,| where
|我同样不能进行就地更新，

385
00:10:09,580 --> 00:10:10,410
0,260 260,410 410,665 665,740 740,830
again I can't do in

386
00:10:10,410 --> 00:10:11,295
0,180 180,390 390,555 555,690 690,885
place updates,| I can only
|我只能做追加。

387
00:10:11,295 --> 00:10:13,770
0,180 180,300 300,605 1735,2135 2155,2475
do {appends -}.| So this
|所以这个面向 tuple 的页面架构在这个环境中是不起作用的，

388
00:10:13,770 --> 00:10:14,985
0,210 210,620 700,960 960,1080 1080,1215
{tuple-oriented -} [slide] of page

389
00:10:14,985 --> 00:10:16,080
0,275 385,735 735,855 855,960 960,1095
architecture wouldn't work in this

390
00:10:16,080 --> 00:10:17,360
0,290 340,615 615,765 765,1020 1020,1280
environment,| because I can't do,|
|因为我不能做，|

391
00:10:17,710 --> 00:10:18,735
0,260 260,455 455,785 785,890 890,1025
I can't modify a page
我不能修改一个页面，然后把它写回我得到的地方。

392
00:10:18,735 --> 00:10:19,305
0,120 120,210 210,315 315,450 450,570
and write it back where

393
00:10:19,305 --> 00:10:20,060
0,105 105,365
I got.|
|

394
00:10:22,130 --> 00:10:22,840
0,245 245,365 365,485 485,605 605,710
So this is why we
所以，这就是为什么我们需要研究潜在的替代方法，

395
00:10:22,840 --> 00:10:23,530
0,90 90,180 180,270 270,420 420,690
need to look at potentially

396
00:10:23,530 --> 00:10:24,690
0,300 300,570 570,750 750,870 870,1160
alternative methods| and in particular,
|特别是我刚才谈到的所有问题，

397
00:10:25,040 --> 00:10:25,870
0,275 275,395 395,530 530,695 695,830
all the problems I just

398
00:10:25,870 --> 00:10:27,850
0,180 180,500 1240,1530 1530,1650 1650,1980
talked about,| they'll be solved
|这些问题将通过日志结构存储方案来解决。

399
00:10:27,850 --> 00:10:28,950
0,105 105,210 210,420 420,810 810,1100
with a {log-structured -} storage

400
00:10:29,740 --> 00:10:31,160
0,380
scheme.|
|

401
00:10:31,160 --> 00:10:33,560
0,290 850,1185 1185,1470 1470,1820 2110,2400
{} And beyond the heap
除了堆文件页面架构，

402
00:10:33,560 --> 00:10:35,930
0,290 790,1065 1065,1340 1780,2100 2100,2370
file page architecture,| {log-structured -}
|日志结构存储可能是人们在数据库系统中采用的第二种最常见的方法，

403
00:10:35,930 --> 00:10:37,130
0,255 255,435 435,710 730,1005 1005,1200
storage is probably the second

404
00:10:37,130 --> 00:10:38,345
0,225 225,495 495,795 795,1035 1035,1215
most common approach people take

405
00:10:38,345 --> 00:10:39,845
0,135 135,345 345,695 985,1335 1335,1500
in database systems,| it's probably
|这在今天可能更加常见，

406
00:10:39,845 --> 00:10:41,260
0,180 180,330 330,540 540,875 1015,1415
even more common today,| because
|因为嵌入式存储管理器，比如 RocksDB ，

407
00:10:41,280 --> 00:10:43,700
0,400 1200,1550 1550,1805 1805,2110 2130,2420
of embedded storage managers like

408
00:10:43,700 --> 00:10:45,400
0,570 570,780 780,990 990,1230 1230,1700
RocksDB,| which are log structured.|
|它们是日志结构的。|

409
00:10:45,940 --> 00:10:46,525
0,195 195,270 270,375 375,495 495,585
So you ever seen a
你见过使用 RocksDB 的数据库系统吗，

410
00:10:46,525 --> 00:10:47,575
0,180 180,435 435,675 675,825 825,1050
database system, that's using {RocksDB

411
00:10:47,575 --> 00:10:49,570
0,425 655,1230 1230,1605 1605,1755 1755,1995
-},| they're inherently {log-structured -},|
|它们本质上是日志结构，|

412
00:10:49,570 --> 00:10:50,530
0,225 225,405 405,645 645,780 780,960
because {RocksDB -} is {log-structured
因为 Rocksdb 是日志结构的。

413
00:10:50,530 --> 00:10:51,500
0,470
-}.|
|

414
00:10:52,550 --> 00:10:53,305
0,245 245,320 320,455 455,545 545,755
And then we'll talk about
然后我们将讨论另一种方法，

415
00:10:53,305 --> 00:10:54,655
0,255 255,575 655,960 960,1155 1155,1350
another approach,| not exactly log
|不完全是日志结构，

416
00:10:54,655 --> 00:10:55,840
0,285 285,465 465,600 600,705 705,1185
structured,| it sort of amalgamation
|它是这两者的某种融合，

417
00:10:55,840 --> 00:10:56,575
0,135 135,240 240,420 420,585 585,735
of the two,| will be
|也就是面向索引的存储，

418
00:10:56,575 --> 00:10:58,585
0,285 285,570 570,875 1645,1935 1935,2010
{index-organized -} storage,| that's what
|这就是 MySQL 和 SQLite 以及其他所使用的。

419
00:10:58,585 --> 00:10:59,650
0,135 135,480 480,720 720,960 960,1065
{MySQL -} and {SQLite -}

420
00:10:59,650 --> 00:11:00,805
0,75 75,225 225,560 790,1050 1050,1155
and others use.| And then
|然后，我们将结束讨论，

421
00:11:00,805 --> 00:11:01,770
0,135 135,270 270,450 450,645 645,965
we'll finish off talking about,|
|

422
00:11:01,910 --> 00:11:03,040
0,275 275,440 440,575 575,820 840,1130
how to actually represent the
如何实际表示 tuple 中的属性数据。

423
00:11:03,040 --> 00:11:04,950
0,290 520,885 885,1260 1260,1500 1500,1910
data of attributes in tuples.|
|

424
00:11:06,280 --> 00:11:07,220
0,260 260,365 365,455 455,620 620,940
Again, we were working out
同样，我们研究文件的样子，页面的样子，

425
00:11:07,390 --> 00:11:08,420
0,260 260,380 380,560 560,755 755,1030
what a file looks like,

426
00:11:08,530 --> 00:11:09,420
0,230 230,335 335,515 515,695 695,890
what a page looks like,|
|

427
00:11:09,420 --> 00:11:10,065
0,225 225,360 360,495 495,570 570,645
we're still sort of in
我们仍然在那个世界里，

428
00:11:10,065 --> 00:11:11,190
0,135 135,425 625,885 885,975 975,1125
that world,| and then we'll
|然后我们会花更多的时间来讨论，

429
00:11:11,190 --> 00:11:11,910
0,105 105,255 255,405 405,570 570,720
spend more time talking about,|
|

430
00:11:11,910 --> 00:11:13,020
0,135 135,300 300,525 525,795 795,1110
what the actual individual tuples
实际的单个 tuple 是什么样子的，

431
00:11:13,020 --> 00:11:14,055
0,120 120,270 270,450 450,740 790,1035
look like,| the values in
|在单个 tuple 中的值。

432
00:11:14,055 --> 00:11:15,500
0,165 165,405 405,845
the individual tuples.|
|

433
00:11:15,800 --> 00:11:16,880
0,400
Okay?|
好的？|

434
00:11:17,840 --> 00:11:19,680
0,255 255,530
All right.|
好的。|

435
00:11:19,960 --> 00:11:22,650
0,350 350,700 1830,2135 2135,2390 2390,2690
{All,right}, so {log-structure -} storage
好的，所以日志结构存储是一个古老的想法，

436
00:11:22,650 --> 00:11:25,400
0,210 210,315 315,540 540,920 2200,2750
is an old idea,| it's
|它与日志结构文件系统有松散的关系，

437
00:11:25,990 --> 00:11:27,645
0,590 590,860 860,1085 1085,1310 1310,1655
loosely related to {log-structured -}

438
00:11:27,645 --> 00:11:29,325
0,210 210,545 565,965 1015,1455 1455,1680
file systems,| which predates at
|（日志文件系统）早了大约十年，

439
00:11:29,325 --> 00:11:30,315
0,270 270,465 465,645 645,840 840,990
about ten years,| {log-structure -}
|日志结构文件系统，大约在 1980 年代，

440
00:11:30,315 --> 00:11:31,485
0,165 165,405 405,615 615,855 855,1170
file systems, like in {1980s

441
00:11:31,485 --> 00:11:33,410
0,485 835,1110 1110,1305 1305,1635 1635,1925
-},| the {log-structured -} storage
|日志结构存储最早是在 90 年代中期提出的，

442
00:11:35,050 --> 00:11:36,270
0,290 290,470 470,695 695,995 995,1220
of was first proposed in

443
00:11:36,270 --> 00:11:37,280
0,135 135,270 270,360 360,495 495,1010
the in the mid 90s,|
|

444
00:11:38,260 --> 00:11:39,180
0,245 245,335 335,485 485,710 710,920
actually in the {textbook -},|
实际上，在课本中，|

445
00:11:39,180 --> 00:11:40,425
0,195 195,375 375,630 630,975 975,1245
they'll call {log-structured -} merge
他们称为日志结构合并树，

446
00:11:40,425 --> 00:11:42,210
0,275 1045,1380 1380,1500 1500,1605 1605,1785
trees,| I'm not going to
|我不打算描述日志结构合并树是什么样子的，

447
00:11:42,210 --> 00:11:43,365
0,270 270,495 495,705 705,945 945,1155
describe what what the actual

448
00:11:43,365 --> 00:11:44,115
0,150 150,300 300,450 450,600 600,750
{log-structure -} merge trees looks

449
00:11:44,115 --> 00:11:44,820
0,210 210,390 390,480 480,630 630,705
like,| because I don't think
|因为我认为你不需要知道它的树部分的细节。

450
00:11:44,820 --> 00:11:46,065
0,120 120,240 240,375 375,650 880,1245
you need to know the

451
00:11:46,065 --> 00:11:47,040
0,285 285,465 465,615 615,810 810,975
details of the tree part

452
00:11:47,040 --> 00:11:47,860
0,105 105,350
of it,

453
00:11:47,860 --> 00:11:51,280
0,350 1090,1440 1440,1790 2680,3105 3105,3420
right,| so I, I'll describe
|所以我将描述基本上相同的想法，但没有引入树，

454
00:11:51,280 --> 00:11:52,390
0,300 300,525 525,750 750,990 990,1110
basically the same idea, but

455
00:11:52,390 --> 00:11:53,500
0,180 180,480 480,705 705,885 885,1110
without bringing in the tree,|
|

456
00:11:53,500 --> 00:11:54,630
0,180 180,345 345,600 600,840 840,1130
because that makes makes things
因为这会使事情变得更加复杂。

457
00:11:54,680 --> 00:11:57,295
0,260 260,520 1890,2240 2240,2465 2465,2615
more complicated.| But the high
|但高层次的想法才是我所关心的，

458
00:11:57,295 --> 00:11:58,180
0,195 195,450 450,660 660,780 780,885
level idea is what I

459
00:11:58,180 --> 00:11:59,230
0,120 120,380 640,870 870,945 945,1050
care about,| what I want
|是我想让你们明白的。

460
00:11:59,230 --> 00:12:00,560
0,105 105,345 345,740
you guys understand.|
|

461
00:12:01,040 --> 00:12:01,870
0,245 245,320 320,515 515,725 725,830
So the basic idea of
所以，日志结构存储的基本思想是，

462
00:12:01,870 --> 00:12:03,060
0,135 135,345 345,660 660,915 915,1190
{log-structure -} storage is that,|
|

463
00:12:03,890 --> 00:12:05,260
0,275 275,440 440,785 785,1130 1130,1370
instead of storing individual {tuples
不是存储单独的 tuple ，

464
00:12:05,260 --> 00:12:06,780
0,290 880,1170 1170,1215 1215,1275 1275,1520
-},| we're going to maintain
|我们将维护对 tuple 修改的日志记录，

465
00:12:06,920 --> 00:12:09,175
0,305 305,590 590,970 1470,1865 1865,2255
a log record of the

466
00:12:09,175 --> 00:12:10,470
0,395 415,675 675,840 840,1020 1020,1295
changes to those {tuples -},|
|

467
00:12:11,560 --> 00:12:12,780
0,245 245,490 540,890 890,1040 1040,1220
I think it's a key
我认为这是一个键值存储，键值系统，

468
00:12:12,780 --> 00:12:14,115
0,290 340,690 690,900 900,1080 1080,1335
value store, key value system,|
|

469
00:12:14,115 --> 00:12:14,720
0,150 150,255 255,300 300,360 360,605
so I'm going to have
所以我要做一些操作， PUT 和 DELETE ，

470
00:12:15,580 --> 00:12:17,055
0,365 365,695 695,1010 1010,1280 1280,1475
some operation, either just PUT

471
00:12:17,055 --> 00:12:18,180
0,165 165,455
and DELETE,|
|

472
00:12:18,330 --> 00:12:19,655
0,400 630,935 935,1100 1100,1250 1250,1325
{} and then I'm going
然后我将有一个键值对，

473
00:12:19,655 --> 00:12:20,855
0,90 90,335 475,765 765,960 960,1200
to have a key value

474
00:12:20,855 --> 00:12:22,355
0,335 415,675 675,795 795,945 945,1500
pair| with the key corresponding
|其中的键对应于某个 tuple 的标识符，

475
00:12:22,355 --> 00:12:24,350
0,210 210,450 450,780 780,1265 1735,1995
to some tuple identifier,| we
|我们不能使用以前使用的 record ID ，

476
00:12:24,350 --> 00:12:25,235
0,225 225,330 330,450 450,630 630,885
can't use the record ID

477
00:12:25,235 --> 00:12:26,165
0,180 180,285 285,545 565,810 810,930
we did before,| because we're
|因为我们不会有页面，

478
00:12:26,165 --> 00:12:26,870
0,90 90,195 195,270 270,435 435,705
not going to have pages,|
|

479
00:12:26,870 --> 00:12:27,350
0,210 210,285 285,360 360,405 405,480
we not going to have
我们不会有所有的[集合]和插槽，

480
00:12:27,350 --> 00:12:28,430
0,165 165,345 345,495 495,800 850,1080
all [sets] and slots,| so
|所以它不会是那样，

481
00:12:28,430 --> 00:12:28,865
0,105 105,165 165,285 285,345 345,435
we're not, it's not going

482
00:12:28,865 --> 00:12:30,665
0,90 90,335 745,1145 1465,1695 1695,1800
be that,| {} but it'll
|但它会是一些键标识符，

483
00:12:30,665 --> 00:12:32,120
0,105 105,395 445,750 750,1230 1230,1455
be some key identifier,| and
|然后有效负载将是实际的 tuple 本身，

484
00:12:32,120 --> 00:12:33,520
0,290 310,585 585,990 990,1140 1140,1400
then the payload would be

485
00:12:33,780 --> 00:12:35,470
0,395 395,575 575,910 930,1385 1385,1690
here's the actual tuples itself,|
|

486
00:12:35,850 --> 00:12:36,935
0,245 245,455 455,590 590,845 845,1085
that I'm trying to, you
我试图在 PUT 中安装。

487
00:12:36,935 --> 00:12:38,075
0,225 225,510 510,780 780,1005 1005,1140
know, install for in the

488
00:12:38,075 --> 00:12:39,100
0,275
PUT.|
|

489
00:12:39,730 --> 00:12:41,750
0,275 275,425 425,700 780,1180 1620,2020
And so as the application
所以，当应用程序插入数据进行更改时，

490
00:12:42,190 --> 00:12:44,655
0,575 575,845 845,1175 1175,1510 2160,2465
inserts data makes changes,| we're
|我们将把新的日志条目追加到内存缓冲区中，

491
00:12:44,655 --> 00:12:45,495
0,45 45,180 180,405 405,615 615,840
going to append new log

492
00:12:45,495 --> 00:12:46,560
0,435 435,600 600,705 705,840 840,1065
entries to an {in-memory -}

493
00:12:46,560 --> 00:12:47,780
0,470
buffer,|
|

494
00:12:47,850 --> 00:12:48,995
0,380 380,650 650,815 815,950 950,1145
{} just in the order
按照它们到达的顺序，

495
00:12:48,995 --> 00:12:50,810
0,285 285,540 540,845 1405,1680 1680,1815
that they arrive| and then
|然后在某个时候缓冲区会变满，

496
00:12:50,810 --> 00:12:51,830
0,260 280,555 555,690 690,810 810,1020
at some point that buffer

497
00:12:51,830 --> 00:12:52,480
0,90 90,180 180,240 240,360 360,650
is going to get full|
|

498
00:12:52,740 --> 00:12:53,330
0,230 230,350 350,395 395,470 470,590
and we're going to write
我们要把它写到磁盘上。

499
00:12:53,330 --> 00:12:54,780
0,90 90,195 195,315 315,740
it out the disk.|
|

500
00:12:56,380 --> 00:12:58,080
0,290 290,485 485,790
Pretty simple, right?|
很简单，对吧？|

501
00:12:58,550 --> 00:12:59,230
0,275 275,410 410,500 500,620 620,680
All right, so let's see
好的，让我们来看一个例子，

502
00:12:59,230 --> 00:13:00,510
0,105 105,285 285,590 700,990 990,1280
an example here,| so again,
|我们要做的只有两个操作， PUT 和 DELETE ，

503
00:13:00,770 --> 00:13:01,825
0,230 230,365 365,605 605,860 860,1055
the only two operations we're

504
00:13:01,825 --> 00:13:02,545
0,45 45,105 105,315 315,570 570,720
going to have are PUT

505
00:13:02,545 --> 00:13:04,735
0,165 165,455 925,1325 1615,1965 1965,2190
and DELETE, right,| there's no
|这里没有插入，因为那只有一个 PUT ，

506
00:13:04,735 --> 00:13:05,695
0,450 450,600 600,765 765,840 840,960
insert, because that's just a

507
00:13:05,695 --> 00:13:07,015
0,225 225,585 585,870 870,1050 1050,1320
PUT there,| there's no update,|
|这里没有更新，|

508
00:13:07,015 --> 00:13:08,770
0,195 195,455 745,1065 1065,1380 1380,1755
because that just PUT, you
因为 PUT 只是盲目地写入在之前的任何东西上。

509
00:13:08,770 --> 00:13:09,805
0,300 300,510 510,675 675,855 855,1035
doing blind write over top

510
00:13:09,805 --> 00:13:10,590
0,150 150,285 285,405 405,525 525,785
of whatever was there before.|
|

511
00:13:12,130 --> 00:13:13,830
0,275 275,550 1050,1325 1325,1475 1475,1700
And so in our log
所以，在内存中的日志文件中，

512
00:13:13,830 --> 00:13:16,245
0,255 255,435 435,710 1180,1580 2140,2415
file in memory, right,| we're
|我们将从最旧到最新，

513
00:13:16,245 --> 00:13:18,105
0,45 45,120 120,315 315,665 1495,1860
going to go from oldest

514
00:13:18,105 --> 00:13:18,960
0,210 210,465 465,600 600,690 690,855
to newest,| so at the
|所以，在文件的开头或缓冲区的开头，

515
00:13:18,960 --> 00:13:19,995
0,240 240,405 405,540 540,780 780,1035
beginning of the file or

516
00:13:19,995 --> 00:13:21,510
0,195 195,345 345,465 465,875 1105,1515
beginning of the buffer,| that'll
|这将是最旧的条目，

517
00:13:21,510 --> 00:13:22,875
0,150 150,330 330,525 525,1005 1005,1365
be the oldest entries| and
|我们只是追加它们，当我们做出修改时。

518
00:13:22,875 --> 00:13:24,500
0,285 285,345 345,965 1105,1365 1365,1625
we're just appending to them

519
00:13:24,880 --> 00:13:26,600
0,290 290,425 425,575 575,880
as we make changes,

520
00:13:27,210 --> 00:13:28,265
0,305 305,455 455,635 635,875 875,1055
right.| So the application may
|所以应用程序可能会说，

521
00:13:28,265 --> 00:13:28,820
0,165 165,315 315,405 405,465 465,555
say,| I want to go
|我想继续，做一个 PUT 在记录 103 上，

522
00:13:28,820 --> 00:13:29,530
0,135 135,255 255,330 330,435 435,710
ahead and do a PUT

523
00:13:29,640 --> 00:13:31,570
0,400 780,1160 1160,1415 1415,1610 1610,1930
on record {103 - -},|
|

524
00:13:31,980 --> 00:13:32,750
0,290 290,425 425,515 515,620 620,770
where the {103 - -}
103 的来自哪里，我们不在乎，

525
00:13:32,750 --> 00:13:33,760
0,195 195,420 420,585 585,765 765,1010
came from, we don't care,|
|

526
00:13:33,930 --> 00:13:34,985
0,260 260,410 410,560 560,770 770,1055
assuming that some other upper
假设系统的其他上层为我们解决了这一问题，

527
00:13:34,985 --> 00:13:35,825
0,195 195,285 285,375 375,555 555,840
part of the system that

528
00:13:35,825 --> 00:13:37,070
0,255 255,545 655,945 945,1095 1095,1245
figured that, figured that out

529
00:13:37,070 --> 00:13:38,945
0,135 135,380 1180,1440 1440,1650 1650,1875
for us,| and then again,
|然后，日志记录中的有效负载是，

530
00:13:38,945 --> 00:13:39,965
0,150 150,555 555,750 750,900 900,1020
the payload in the, in

531
00:13:39,965 --> 00:13:40,900
0,105 105,255 255,480 480,675 675,935
the log record would be,|
|

532
00:13:41,040 --> 00:13:42,515
0,305 305,455 455,620 620,880 1080,1475
we're setting the value to
我们将记录 103 的值设置为 a1 。

533
00:13:42,515 --> 00:13:43,565
0,315 315,570 570,765 765,900 900,1050
whatever record {103 - -}

534
00:13:43,565 --> 00:13:45,110
0,225 225,575 745,1020 1020,1275 1275,1545
is to to 1, {a1

535
00:13:45,110 --> 00:13:46,080
0,290
-}.|
|

536
00:13:47,090 --> 00:13:48,415
0,290 290,575 575,920 920,1160 1160,1325
Same thing, next next guy
同样的事情，下一个出现了，

537
00:13:48,415 --> 00:13:49,990
0,165 165,455 1165,1410 1410,1500 1500,1575
comes along,| he wants to
|他想做一个 PUT 到 104 ，

538
00:13:49,990 --> 00:13:50,410
0,60 60,150 150,240 240,315 315,420
do a PUT a {104

539
00:13:50,410 --> 00:13:51,820
0,120 120,380 670,930 930,1140 1140,1410
- -}| and then updates
|然后更新那个记录，

540
00:13:51,820 --> 00:13:53,400
0,315 315,710
that record,

541
00:13:53,870 --> 00:13:55,210
0,400 630,905 905,1070 1070,1220 1220,1340
right.| And then if we
|然后，如果我们有一个 DELETE ，

542
00:13:55,210 --> 00:13:57,370
0,135 135,330 330,650 1420,1820 1900,2160
have a DELETE,| we, we
|我们在日志记录中有 DELETE 操作，

543
00:13:57,370 --> 00:13:58,830
0,195 195,530 730,990 990,1155 1155,1460
just delete, have a DELETE

544
00:13:59,300 --> 00:14:00,420
0,350 350,545 545,650 650,815 815,1120
operation in a log record|
|

545
00:14:00,650 --> 00:14:01,900
0,260 260,425 425,730 780,1040 1040,1250
and then with the same
然后使用相同的 tuple 标识符，

546
00:14:01,900 --> 00:14:03,730
0,270 270,770 1180,1455 1455,1590 1590,1830
tuple identifier,| keep it appending
|随着我们继续，将它追加到日志中，

547
00:14:03,730 --> 00:14:04,585
0,105 105,195 195,435 435,720 720,855
to the log as we

548
00:14:04,585 --> 00:14:05,580
0,120 120,395
go along,

549
00:14:05,680 --> 00:14:06,740
0,400
right.|
|

550
00:14:08,710 --> 00:14:10,070
0,320 320,500 500,695 695,995 995,1360
So in this example here,|
所以在这个例子中，|

551
00:14:12,260 --> 00:14:13,480
0,350 350,725 725,890 890,1025 1025,1220
we don't need to go
我们并不需要去读取原始记录是什么，

552
00:14:13,480 --> 00:14:15,120
0,240 240,530 970,1245 1245,1380 1380,1640
actually read what the original

553
00:14:15,350 --> 00:14:16,885
0,350 350,700 810,1055 1055,1235 1235,1535
record was,| the original tuple
|原始的 tuple 是什么，

554
00:14:16,885 --> 00:14:18,505
0,245 685,1230 1230,1365 1365,1470 1470,1620
was,| anytime we want to
|任何时候我们想要更新日志。

555
00:14:18,505 --> 00:14:19,720
0,180 180,315 315,575
update the log.|
|

556
00:14:21,560 --> 00:14:22,645
0,400 450,680 680,755 755,875 875,1085
Again, think of the lower
想想这个系统的下层，

557
00:14:22,645 --> 00:14:24,295
0,360 360,450 450,585 585,875 1375,1650
[] of the system,| obviously,
|显然，如果我要执行查询，

558
00:14:24,295 --> 00:14:25,045
0,120 120,285 285,390 390,525 525,750
if I'm doing a query,|
|

559
00:14:25,045 --> 00:14:27,270
0,335 355,755 1225,1530 1530,1830 1830,2225
like update, update table, set
比如更新表设置 ID ，

560
00:14:27,410 --> 00:14:29,275
0,400 570,970 990,1295 1295,1595 1595,1865
ID,| or set value equals
|或者设置值等于值加一，

561
00:14:29,275 --> 00:14:30,235
0,210 210,450 450,675 675,855 855,960
value plus one,| I got
|我必须知道原始值是什么，

562
00:14:30,235 --> 00:14:30,715
0,90 90,180 180,255 255,315 315,480
to know what the original

563
00:14:30,715 --> 00:14:32,140
0,285 285,635
value was,|
|

564
00:14:32,270 --> 00:14:33,190
0,245 245,440 440,620 620,800 800,920
and that's essentially doing a
这实质上就是先读后写，

565
00:14:33,190 --> 00:14:34,170
0,195 195,435 435,600 600,720 720,980
read followed by a write,|
|

566
00:14:34,430 --> 00:14:35,680
0,305 305,530 530,800 800,1070 1070,1250
but at this lowest level
但在这个系统的最低层，

567
00:14:35,680 --> 00:14:36,535
0,90 90,180 180,420 420,660 660,855
of the system,| we don't
|我们不需要知道，

568
00:14:36,535 --> 00:14:37,540
0,245 295,525 525,690 690,840 840,1005
know, we don't have to

569
00:14:37,540 --> 00:14:40,360
0,260 610,1010 2050,2310 2310,2505 2505,2820
know,| what the original value
|给定的键的原始值是多少。

570
00:14:40,360 --> 00:14:41,755
0,315 315,555 555,720 720,980 1060,1395
was for a given, given

571
00:14:41,755 --> 00:14:42,740
0,335
key.|
|

572
00:14:45,590 --> 00:14:47,070
0,260 260,395 395,725 725,1030 1080,1480
And again, that's different than
同样，这与面向 tuple 的架构不同，

573
00:14:48,530 --> 00:14:49,930
0,275 275,515 515,755 755,1030 1110,1400
the {tuple-oriented -} architecture,| where
|在那里，我必须获取包含原始 tuple 的页面，

574
00:14:49,930 --> 00:14:50,650
0,180 180,360 360,480 480,555 555,720
I had to go fetch

575
00:14:50,650 --> 00:14:52,495
0,165 165,440 1000,1275 1275,1550 1600,1845
the page, that had the

576
00:14:52,495 --> 00:14:53,485
0,180 180,540 540,705 705,870 870,990
original tuple| and then I
|然后才能更新它，

577
00:14:53,485 --> 00:14:54,640
0,165 165,360 360,635 655,930 930,1155
can update it,| I don't
|在这里，我不用这么做。

578
00:14:54,640 --> 00:14:55,135
0,75 75,180 180,285 285,390 390,495
have to do that with

579
00:14:55,135 --> 00:14:56,040
0,245
this,

580
00:14:56,880 --> 00:14:58,000
0,400
right.|
|

581
00:14:59,510 --> 00:15:00,630
0,320 320,500 500,635 635,815 815,1120
So again, at some point
在某个时刻，内存中页面会变满，

582
00:15:00,680 --> 00:15:01,920
0,305 305,485 485,620 620,860 860,1240
this thing will get, this

583
00:15:01,970 --> 00:15:03,030
0,335 335,545 545,665 665,785 785,1060
in-memory page will get full,|
|

584
00:15:03,470 --> 00:15:04,375
0,365 365,590 590,710 710,815 815,905
and we got to write
我们必须将其写到磁盘，

585
00:15:04,375 --> 00:15:05,700
0,90 90,210 210,330 330,785
it out the disk,|
|

586
00:15:06,230 --> 00:15:07,440
0,260 260,515 515,725 725,920 920,1210
and that's literally just taking
这就是获取内存页的全部内容，

587
00:15:07,460 --> 00:15:08,785
0,275 275,455 455,890 890,1145 1145,1325
the entire contents of the

588
00:15:08,785 --> 00:15:10,225
0,150 150,455 685,1005 1005,1335 1335,1440
memory page| and plopping it
|并将其[拖到]磁盘上的一堆页中，

589
00:15:10,225 --> 00:15:11,470
0,245 445,825 825,1050 1050,1140 1140,1245
down to a bunch of

590
00:15:11,470 --> 00:15:12,775
0,165 165,330 330,770 940,1185 1185,1305
pages on disk,| clear out
|清空我的内存缓冲区，

591
00:15:12,775 --> 00:15:14,260
0,135 135,315 315,785 1045,1305 1305,1485
my memory buffer,| and then
|然后开始用新的日志条目填充它，

592
00:15:14,260 --> 00:15:15,360
0,225 225,510 510,600 600,765 765,1100
start filling it up with

593
00:15:16,220 --> 00:15:17,740
0,290 290,455 455,910
new log entries,|
|

594
00:15:18,440 --> 00:15:19,240
0,230 230,320 320,425 425,590 590,800
and then when that gets
然后当它变满的时候，

595
00:15:19,240 --> 00:15:20,740
0,290 340,645 645,950 1120,1365 1365,1500
full,| same thing, I write
|同样的事情，我把它写出去。

596
00:15:20,740 --> 00:15:22,400
0,165 165,440
that out.|
|

597
00:15:23,710 --> 00:15:25,310
0,400 540,875 875,1115 1115,1310 1310,1600
Now, important thing about this,|
现在，关于这一点，重要的是，|

598
00:15:25,330 --> 00:15:26,115
0,245 245,320 320,410 410,530 530,785
there are just two important
有两件重要的事情需要指出，

599
00:15:26,115 --> 00:15:26,925
0,270 270,390 390,480 480,645 645,810
things to point out,| when
|当我们做这个的时候。

600
00:15:26,925 --> 00:15:28,080
0,90 90,195 195,315 315,575 895,1155
we do this, right.| First
|首先，这一切现在都是顺序 I/O ，

601
00:15:28,080 --> 00:15:29,265
0,90 90,320 640,900 900,1020 1020,1185
of all, this is all

602
00:15:29,265 --> 00:15:30,920
0,360 360,645 645,935
sequential I/O now,

603
00:15:30,960 --> 00:15:32,380
0,350 350,545 545,725 725,1040 1040,1420
right,| because my, my, my
|因为我的内存中页面可能是 1 兆字节或者 10 兆字节，

604
00:15:32,670 --> 00:15:34,300
0,260 260,455 455,790 1110,1370 1370,1630
{in-memory -} page could be

605
00:15:34,740 --> 00:15:36,010
0,245 245,545 545,635 635,770 770,1270
a megabyte or ten megabytes,|
|

606
00:15:36,450 --> 00:15:37,595
0,275 275,440 440,635 635,890 890,1145
when that gets full,| I
当它变满时，|我将这 10 兆字节按顺序写出到磁盘上的文件中。

607
00:15:37,595 --> 00:15:38,600
0,165 165,315 315,720 720,855 855,1005
write out sequentially those ten

608
00:15:38,600 --> 00:15:40,040
0,590 730,1020 1020,1155 1155,1290 1290,1440
megabytes to the file on

609
00:15:40,040 --> 00:15:41,100
0,500
disk.|
|

610
00:15:41,170 --> 00:15:42,510
0,245 245,365 365,640 870,1175 1175,1340
So no matter, again in
所以，无论是在面向 tuple 架构或面向页面架构中，

611
00:15:42,510 --> 00:15:44,025
0,120 120,270 270,585 585,890 1270,1515
the {tuple-oriented -} architecture or

612
00:15:44,025 --> 00:15:45,120
0,90 90,225 225,405 405,695 835,1095
the {page-oriented -} architecture,| where
|我都会有 20 个 tuple 分布在 20 个不同的页面上。

613
00:15:45,120 --> 00:15:46,170
0,120 120,240 240,500 670,900 900,1050
I would have, you know,

614
00:15:46,170 --> 00:15:47,600
0,240 240,645 645,900 900,1110 1110,1430
20 tuples spread across 20

615
00:15:47,710 --> 00:15:49,260
0,335 335,670
different pages,|
|

616
00:15:49,300 --> 00:15:50,625
0,305 305,605 605,860 860,1055 1055,1325
In this, in this environment,
在这种环境中，在这种设置下，

617
00:15:50,625 --> 00:15:52,335
0,180 180,330 330,755 1015,1320 1320,1710
with this setup,| those {20,tuples}
|这 20 个 tuple 总是在同一页面上，

618
00:15:52,335 --> 00:15:53,025
0,255 255,480 480,585 585,630 630,690
are always going to be

619
00:15:53,025 --> 00:15:54,600
0,90 90,195 195,455 1135,1440 1440,1575
on the same page,| when
|当我写出它们时，

620
00:15:54,600 --> 00:15:56,070
0,75 75,180 180,285 285,530 1090,1470
I write them out,| because
|因为这是追加日志记录。

621
00:15:56,070 --> 00:15:57,900
0,330 330,555 555,765 765,1040
there's appending log records.|
|

622
00:15:59,030 --> 00:15:59,995
0,230 230,395 395,635 635,830 830,965
The other important thing in
这个架构中的另一件重要事情是，

623
00:15:59,995 --> 00:16:01,480
0,90 90,335 385,660 660,935 1165,1485
this architecture is that,| once
|一旦将页面写入磁盘，它就是不可变的，

624
00:16:01,480 --> 00:16:02,410
0,210 210,405 405,585 585,750 750,930
a page is written to

625
00:16:02,410 --> 00:16:04,700
0,560 910,1200 1200,1820
disk, it's immutable,|
|

626
00:16:05,600 --> 00:16:06,610
0,290 290,440 440,575 575,785 785,1010
meaning we can never go
这意味着我们永远不能回去做原地更新，

627
00:16:06,610 --> 00:16:08,290
0,290 400,800 910,1200 1200,1395 1395,1680
back and do in place

628
00:16:08,290 --> 00:16:09,660
0,380
updates,|
|

629
00:16:10,240 --> 00:16:11,355
0,320 320,650 650,860 860,1040 1040,1115
we'll compact it,| we'll see
我们会压缩它，|我们很快就会看到，基本上就是垃圾回收，

630
00:16:11,355 --> 00:16:12,075
0,90 90,165 165,255 255,435 435,720
that in a second, basically

631
00:16:12,075 --> 00:16:13,695
0,255 255,555 555,815 1255,1500 1500,1620
do garbage collection,| but we
|但我们永远不能覆盖以前已经存在的日志记录，

632
00:16:13,695 --> 00:16:14,940
0,195 195,390 390,870 870,1050 1050,1245
never can overwrite a log

633
00:16:14,940 --> 00:16:15,825
0,225 225,405 405,555 555,720 720,885
record that was already there

634
00:16:15,825 --> 00:16:17,000
0,275
before,|
|

635
00:16:18,410 --> 00:16:19,795
0,290 290,455 455,755 755,1025 1025,1385
we're not caught distributed databases
我们现在还不了解分布式数据库，

636
00:16:19,795 --> 00:16:21,265
0,150 150,360 360,695 985,1260 1260,1470
just yet,| but there is
|但是确保你的文件是不变的是有一些好处的，

637
00:16:21,265 --> 00:16:22,420
0,255 255,555 555,780 780,960 960,1155
some advantage to making sure

638
00:16:22,420 --> 00:16:23,670
0,135 135,330 330,480 480,930 930,1250
your files are immutable| and
|忽略比如，如果我在云存储上，我不能进行就地更新，

639
00:16:24,080 --> 00:16:25,585
0,530 530,755 755,950 950,1205 1205,1505
ignoring the like, oh, well,

640
00:16:25,585 --> 00:16:26,320
0,210 210,375 375,435 435,540 540,735
if I'm on a cloud

641
00:16:26,320 --> 00:16:27,430
0,320 490,765 765,945 945,1005 1005,1110
storage, I can't do in

642
00:16:27,430 --> 00:16:29,665
0,210 210,560 1780,2025 2025,2100 2100,2235
place updates,| but it does
|但它现在确实容易了，

643
00:16:29,665 --> 00:16:30,565
0,150 150,255 255,435 435,705 705,900
make it easy now,| if
|如果它只是附加日志，

644
00:16:30,565 --> 00:16:31,680
0,135 135,240 240,705 705,855 855,1115
it's just appending the log,|
|

645
00:16:32,030 --> 00:16:33,340
0,380 380,605 605,830 830,1085 1085,1310
that's essentially what {Paxos -}
这本质上就是 Paxos 或 Raft 所做的，

646
00:16:33,340 --> 00:16:34,255
0,255 255,435 435,585 585,750 750,915
or something a Raft is

647
00:16:34,255 --> 00:16:36,360
0,705 705,990 990,1325 1525,1815 1815,2105
doing,| adding log, log records
|添加日志记录，永远不会回去和进行更改。

648
00:16:36,740 --> 00:16:37,855
0,260 260,410 410,575 575,845 845,1115
and never go back and

649
00:16:37,855 --> 00:16:39,000
0,195 195,515
making changes.|
|

650
00:16:39,510 --> 00:16:40,490
0,260 260,425 425,680 680,875 875,980
It could change in the
它可以修改日志，将是新的日志条目。

651
00:16:40,490 --> 00:16:41,255
0,165 165,360 360,525 525,645 645,765
log would be a new

652
00:16:41,255 --> 00:16:42,300
0,225 225,575
log entry,

653
00:16:42,600 --> 00:16:43,660
0,400
right.|
|

654
00:16:43,800 --> 00:16:44,600
0,245 245,350 350,500 500,620 620,800
So this makes the architecture
所以，这将使架构变得容易很多，

655
00:16:44,600 --> 00:16:45,410
0,165 165,255 255,450 450,645 645,810
a lot easier,| once it's
|一旦存储在磁盘上，并且不需要更新，

656
00:16:45,410 --> 00:16:46,550
0,120 120,570 570,795 795,885 885,1140
on disk and you don't

657
00:16:46,550 --> 00:16:47,840
0,210 210,470
update it.|
|

658
00:16:47,880 --> 00:16:49,925
0,400 1350,1625 1625,1805 1805,2000 2000,2045
Now, for now, we're going
现在，我们将忽略，

659
00:16:49,925 --> 00:16:51,080
0,120 120,425 505,780 780,975 975,1155
to ignore,| what happens if
|如果我需要写出内存缓冲区，

660
00:16:51,080 --> 00:16:52,390
0,180 180,375 375,650 700,1005 1005,1310
I need to write the

661
00:16:52,470 --> 00:16:54,125
0,335 335,665 665,845 845,1180 1380,1655
memory buffer out,| before I
|在它完全满之前，

662
00:16:54,125 --> 00:16:55,250
0,195 195,375 375,540 540,885 885,1125
want to, before it's, you

663
00:16:55,250 --> 00:16:56,990
0,260 400,750 750,1100 1360,1620 1620,1740
know, completely full,| like if
|比如，如果我运行一个查询或事务，

664
00:16:56,990 --> 00:16:58,145
0,150 150,420 420,690 690,870 870,1155
I have running a query

665
00:16:58,145 --> 00:16:59,600
0,270 270,575 655,1005 1005,1260 1260,1455
or transaction,| that, that wants
|希望确保将我的更改写入磁盘，

666
00:16:59,600 --> 00:17:00,305
0,120 120,240 240,390 390,525 525,705
to make sure that my

667
00:17:00,305 --> 00:17:01,205
0,195 195,330 330,450 450,600 600,900
changes are written to disk,|
|

668
00:17:01,205 --> 00:17:02,195
0,180 180,390 390,540 540,750 750,990
before I tell the outside
在我告诉外界，数据被安全地写入磁盘之前，

669
00:17:02,195 --> 00:17:03,785
0,305 565,915 915,1140 1140,1305 1305,1590
world, that the data is

670
00:17:03,785 --> 00:17:05,405
0,330 330,540 540,675 675,1175 1345,1620
safely written to disk,| I
|我可能会写出这个日志缓冲区，

671
00:17:05,405 --> 00:17:06,455
0,195 195,405 405,570 570,750 750,1050
may write this log buffer

672
00:17:06,455 --> 00:17:07,280
0,245
out,|
|

673
00:17:07,280 --> 00:17:09,305
0,260 280,585 585,825 825,1070 1720,2025
{} before it's finished, before
在它完成之前，在它装满之前，

674
00:17:09,305 --> 00:17:11,480
0,255 255,515 1705,1935 1935,2085 2085,2175
it's full,| but I'll write
|但我会把它写到一个单独的位置，

675
00:17:11,480 --> 00:17:12,400
0,105 105,165 165,255 255,525 525,920
it to a separate location,|
|

676
00:17:13,230 --> 00:17:14,105
0,245 245,425 425,650 650,770 770,875
a local disk, where I
一个本地磁盘，在那里我可以进行这种写操作。

677
00:17:14,105 --> 00:17:15,005
0,150 150,420 420,690 690,810 810,900
can do these kind of

678
00:17:15,005 --> 00:17:15,960
0,245
writes.|
|

679
00:17:16,480 --> 00:17:17,805
0,320 320,640 905,1025 1025,1190 1190,1325
But again, we'll ignore that
但是，我们现在将忽略这个。

680
00:17:17,805 --> 00:17:19,040
0,105 105,335
for now.|
|

681
00:17:20,200 --> 00:17:21,975
0,395 395,725 725,935 935,1210 1500,1775
{All,right}, again, so in the
好的，所以，在日志结构架构中，

682
00:17:21,975 --> 00:17:23,550
0,210 210,435 435,725 1135,1500 1500,1575
{log-structure -} architecture,| that's going
|这将使我们的写入速度非常快，

683
00:17:23,550 --> 00:17:24,435
0,75 75,195 195,375 375,630 630,885
to make our writes really

684
00:17:24,435 --> 00:17:25,845
0,270 270,540 540,810 810,1155 1155,1410
fast,| much faster than a
|比面向 tuple 的结构快得多，

685
00:17:25,845 --> 00:17:27,825
0,135 135,360 360,605 1405,1695 1695,1980
{tuple-oriented -} architecture,| because again,
|因为，我们只是追加日志记录，

686
00:17:27,825 --> 00:17:28,650
0,270 270,330 330,435 435,675 675,825
we're just {appending -} log

687
00:17:28,650 --> 00:17:29,370
0,240 240,450 450,555 555,645 645,720
records| and we write them
|并按顺序写出它们。

688
00:17:29,370 --> 00:17:30,680
0,105 105,650
out sequentially.|
|

689
00:17:31,885 --> 00:17:32,560
0,165 165,405 405,540 540,585 585,675
What's potentially going to be
现在什么可能会变得更慢？

690
00:17:32,560 --> 00:17:34,000
0,195 195,500
slower now?|
|

691
00:17:34,560 --> 00:17:36,725
0,560 560,940 1200,1600 1650,1955 1955,2165
Reads.| Again, in computer science
读取。|在计算机科学和数据库系统中，没有免费的午餐，

692
00:17:36,725 --> 00:17:38,270
0,150 150,345 345,695 1075,1410 1410,1545
and database systems, there's no

693
00:17:38,270 --> 00:17:39,770
0,165 165,440 640,1040 1120,1395 1395,1500
free lunch,| so we're making
|所以我们让写入更快，

694
00:17:39,770 --> 00:17:40,655
0,120 120,255 255,420 420,660 660,885
the writes go faster,| but
|但现在读取可能会变得更慢。

695
00:17:40,655 --> 00:17:41,615
0,105 105,225 225,525 525,765 765,960
now the reads potentially go

696
00:17:41,615 --> 00:17:42,680
0,305
slower.|
|

697
00:17:43,160 --> 00:17:44,070
0,260 260,380 380,500 500,635 635,910
So to do a read,
那么，为了读取，我们必须做些什么，

698
00:17:44,090 --> 00:17:44,665
0,245 245,320 320,380 380,470 470,575
what do we have to

699
00:17:44,665 --> 00:17:47,035
0,195 195,545 1045,1440 1440,1835 2005,2370
do,| well, again, assuming, assuming
|好的，假设我们系统中的某些东西已经计算出，

700
00:17:47,035 --> 00:17:48,145
0,345 345,570 570,705 705,915 915,1110
something in our system has

701
00:17:48,145 --> 00:17:49,705
0,180 180,485 955,1200 1200,1380 1380,1560
figured out,| you know, the
|ID 或我需要的日志记录的键，

702
00:17:49,705 --> 00:17:50,905
0,245 265,525 525,675 675,945 945,1200
ID or the key of

703
00:17:50,905 --> 00:17:51,865
0,195 195,390 390,570 570,780 780,960
the, the log record, I

704
00:17:51,865 --> 00:17:53,200
0,275 595,870 870,1005 1005,1155 1155,1335
want,| like {102 - -},
|比如 102 103 104 ，

705
00:17:53,200 --> 00:17:53,815
0,135 135,240 240,375 375,495 495,615
{103 - -}, {104 -

706
00:17:53,815 --> 00:17:55,540
0,275 1015,1275 1275,1425 1425,1575 1575,1725
-},| we can ignore that
|我们现在可以忽略它，

707
00:17:55,540 --> 00:17:56,560
0,135 135,380
for now,|
|

708
00:17:56,870 --> 00:17:57,775
0,275 275,470 470,620 620,740 740,905
in order for us to
为了我们找到给定键的日志记录，

709
00:17:57,775 --> 00:17:59,485
0,275 295,585 585,795 795,1115 1465,1710
find the log record for

710
00:17:59,485 --> 00:18:01,080
0,90 90,300 300,665
a given key,|
|

711
00:18:01,520 --> 00:18:02,395
0,305 305,500 500,635 635,740 740,875
we first want to check
我们首先要检查内存中的页面，

712
00:18:02,395 --> 00:18:03,980
0,105 105,210 210,420 420,755
the {in-memory -} page,|
|

713
00:18:04,520 --> 00:18:06,430
0,260 260,365 365,470 470,730 1650,1910
start at the end, because
从末尾开始，因为这是最新的记录，

714
00:18:06,430 --> 00:18:07,915
0,240 240,345 345,510 510,770 1180,1485
that's the newest records,| and
|然后以相反的顺序顺序扫描，

715
00:18:07,915 --> 00:18:11,620
0,305 415,815 895,1625 2035,2435 3415,3705
just scan sequentially in reverse

716
00:18:11,620 --> 00:18:12,610
0,255 255,525 525,735 735,870 870,990
order,| going back to the
|返回到开头，

717
00:18:12,610 --> 00:18:14,080
0,290 820,1050 1050,1155 1155,1320 1320,1470
beginning,| until we find the
|直到我们找到我们想要的日志条目，

718
00:18:14,080 --> 00:18:14,970
0,225 225,435 435,525 525,630 630,890
log entry that we want,|
|

719
00:18:17,050 --> 00:18:18,630
0,245 245,395 395,575 575,910 1320,1580
if it's not there,| we
如果它不在那里，|我们可能不得不去磁盘，

720
00:18:18,630 --> 00:18:19,200
0,135 135,270 270,375 375,465 465,570
may have to go to

721
00:18:19,200 --> 00:18:20,160
0,420 420,660 660,765 765,885 885,960
disk,| we'll cover that in
|我们稍后会讲到这个。

722
00:18:20,160 --> 00:18:21,380
0,90 90,350
a second.|
|

723
00:18:22,570 --> 00:18:24,500
0,230 230,305 305,470 470,790
So is this efficient?|
那么，这是高效的吗？|

724
00:18:25,090 --> 00:18:27,210
0,400 630,1030 1680,1925 1925,2015 2015,2120
No, right.| So a way
不是。|所以，绕过这个的一种方法，

725
00:18:27,210 --> 00:18:28,005
0,90 90,195 195,405 405,645 645,795
to get around this,| and
|这就是教科书中日志结构合并树的来源，

726
00:18:28,005 --> 00:18:28,695
0,120 120,240 240,345 345,495 495,690
this is where that log

727
00:18:28,695 --> 00:18:29,775
0,225 225,540 540,675 675,765 765,1080
structure {merge,tree} in the textbook

728
00:18:29,775 --> 00:18:30,870
0,165 165,455 565,855 855,1005 1005,1095
comes in,| but again, we
|但同样，我们不必担心细节，

729
00:18:30,870 --> 00:18:31,560
0,270 270,450 450,510 510,585 585,690
don't have to worry about

730
00:18:31,560 --> 00:18:34,560
0,195 195,530 820,1080 1080,1340 2680,3000
the details,| is that they're
|它们将维护某种类型的索引，

731
00:18:34,560 --> 00:18:35,160
0,45 45,90 90,300 300,525 525,600
going to maintain some kind

732
00:18:35,160 --> 00:18:36,440
0,150 150,470
of index,

733
00:18:36,530 --> 00:18:37,915
0,305 305,470 470,680 680,1030 1050,1385
right,| for every single record
|对于每个 record ID ，

734
00:18:37,915 --> 00:18:40,285
0,335 1285,1680 1680,1860 1860,2070 2070,2370
ID,| it'll tell you where
|它将告诉你内存缓冲区页面中的位置，

735
00:18:40,285 --> 00:18:41,485
0,330 330,540 540,690 690,870 870,1200
in the {in-memory -} buffer

736
00:18:41,485 --> 00:18:44,095
0,275 985,1385 1435,1835 2155,2460 2460,2610
page is located,| or if
|或者如果它不在内存中，那么它在磁盘上的哪里，

737
00:18:44,095 --> 00:18:45,400
0,135 135,255 255,420 420,695 1015,1305
it's not in memory, where

738
00:18:45,400 --> 00:18:47,040
0,135 135,270 270,495 495,1100
is it on disk,

739
00:18:48,280 --> 00:18:49,580
0,335 335,530 530,650 650,905 905,1300
right.| So to get record
|所以，要获得 record ID 104 ，

740
00:18:49,630 --> 00:18:51,150
0,350 350,560 560,695 695,970 1260,1520
ID {104 - -},| I
|我只需在这个索引中进行一些查找，

741
00:18:51,150 --> 00:18:52,080
0,105 105,240 240,420 420,600 600,930
would just do some lookup

742
00:18:52,080 --> 00:18:52,965
0,135 135,315 315,555 555,765 765,885
in this index,| I'm not
|我不会告诉你它是什么数据结构，无关紧要，

743
00:18:52,965 --> 00:18:53,685
0,150 150,225 225,315 315,495 495,720
telling you what data structure

744
00:18:53,685 --> 00:18:55,155
0,135 135,285 285,570 570,815 1075,1470
it is, doesn't matter,| it's
|它通常会是 B+ 树，

745
00:18:55,155 --> 00:18:55,845
0,300 300,495 495,555 555,615 615,690
typically going to be a

746
00:18:55,845 --> 00:18:57,060
0,135 135,330 330,635
{B+ -} tree,|
|

747
00:18:57,280 --> 00:18:58,290
0,305 305,500 500,725 725,875 875,1010
but some systems use just
但是一些系统使用 Trie ，一些系统使用跳表，

748
00:18:58,290 --> 00:18:59,580
0,320 340,615 615,840 840,1095 1095,1290
Trie, some systems use skip

749
00:18:59,580 --> 00:19:01,275
0,195 195,375 375,540 540,770 1450,1695
list,| it doesn't matter,| do
|无所谓，|做我的查找，查找 104 ，

750
00:19:01,275 --> 00:19:01,950
0,120 120,255 255,390 390,525 525,675
my look up and find

751
00:19:01,950 --> 00:19:02,985
0,135 135,255 255,530 670,930 930,1035
{104 - -}| and then
|然后我会告诉你内存页面的偏移量是多少，

752
00:19:02,985 --> 00:19:03,840
0,150 150,240 240,345 345,585 585,855
I'll tell you what offset

753
00:19:03,840 --> 00:19:05,745
0,135 135,225 225,390 390,710 1660,1905
in the memory page,| the
|内存缓冲区里有我要找的数据。

754
00:19:05,745 --> 00:19:07,380
0,150 150,575 1015,1320 1320,1485 1485,1635
memory buffer has the data

755
00:19:07,380 --> 00:19:08,640
0,120 120,225 225,360 360,680
that I'm looking for.|
|

756
00:19:09,140 --> 00:19:09,940
0,245 245,335 335,485 485,665 665,800
In the case, I want
在这种情况下，我想查看 103 ，

757
00:19:09,940 --> 00:19:10,465
0,105 105,180 180,270 270,375 375,525
to look at {103 -

758
00:19:10,465 --> 00:19:11,500
0,305 505,765 765,870 870,960 960,1035
-},| then I got to
|然后我必须去磁盘，并获得它。

759
00:19:11,500 --> 00:19:11,980
0,60 60,135 135,225 225,405 405,480
go out the disk and

760
00:19:11,980 --> 00:19:12,860
0,120 120,380
get it.|
|

761
00:19:13,100 --> 00:19:14,120
0,400
{All,right}.|
好的。|

762
00:19:19,030 --> 00:19:20,660
0,260 260,395 395,515 515,760 1230,1630
So far, so good?| Yes.|
到现在为止还好吗？|好的。|

763
00:19:21,190 --> 00:19:22,875
0,305 305,610 720,1070 1070,1415 1415,1685

764
00:19:22,875 --> 00:19:24,915
0,195 195,515 1405,1665 1665,1800 1800,2040

765
00:19:24,915 --> 00:19:27,015
0,270 270,575 865,1260 1260,1875 1875,2100

766
00:19:27,015 --> 00:19:31,920
0,335

767
00:19:33,650 --> 00:19:34,690
0,230 230,305 305,440 440,730 780,1040
So your question is,| is
所以，你的问题是，|是否可能在仅追加的文件系统中实现索引？

768
00:19:34,690 --> 00:19:35,575
0,135 135,345 345,555 555,705 705,885
it possible to implement the

769
00:19:35,575 --> 00:19:36,460
0,180 180,315 315,480 480,675 675,885
index in the append only

770
00:19:36,460 --> 00:19:39,320
0,225 225,530
file system?|
|

771
00:19:40,970 --> 00:19:42,085
0,335 335,605 605,845 845,995 995,1115
So, so, yeah.| So the
所以，是的。|所以你这样做的方式就像是，

772
00:19:42,085 --> 00:19:42,865
0,150 150,270 270,405 405,585 585,780
way you would do this

773
00:19:42,865 --> 00:19:46,285
0,180 180,455 2785,3030 3030,3225 3225,3420
is like,| you can sort
|你可以把它当作一个日志本身，

774
00:19:46,285 --> 00:19:47,005
0,105 105,270 270,465 465,615 615,720
of just treat this as

775
00:19:47,005 --> 00:19:49,180
0,120 120,395 475,875 1735,2010 2010,2175
a log itself| and then
|然后你在内存中在它上面构建一个数据结构，

776
00:19:49,180 --> 00:19:50,365
0,255 255,525 525,750 750,990 990,1185
you then in memory you

777
00:19:50,365 --> 00:19:51,160
0,135 135,255 255,435 435,645 645,795
build a data structure on

778
00:19:51,160 --> 00:19:52,290
0,135 135,270 270,530 610,870 870,1130
top of it,| so like
|比如在 B+ 树中，

779
00:19:53,310 --> 00:19:54,490
0,260 260,395 395,590 590,845 845,1180
in a {B+ -} tree|
|

780
00:19:55,110 --> 00:19:56,180
0,245 245,365 365,635 635,920 920,1070
and a typically typically is
典型的操作类似于，

781
00:19:56,180 --> 00:19:57,320
0,135 135,270 270,530 760,1005 1005,1140
done is like,| when you
|当你在磁盘上写入页面时，

782
00:19:57,320 --> 00:19:58,265
0,195 195,375 375,585 585,795 795,945
write the pages at the

783
00:19:58,265 --> 00:20:01,370
0,575 1765,2085 2085,2205 2205,2465 2725,3105
disk,| you're still maintaining the
|你仍在维护数据结构本身，

784
00:20:01,370 --> 00:20:02,945
0,240 240,420 420,705 705,1070 1300,1575
the data structure itself,| like
|比如孩子和双亲之间的指针等，

785
00:20:02,945 --> 00:20:04,085
0,165 165,540 540,735 735,870 870,1140
the pointers between the children

786
00:20:04,085 --> 00:20:05,110
0,285 285,480 480,645 645,765 765,1025
and parents and so forth,|
|

787
00:20:05,370 --> 00:20:07,210
0,400 600,890 890,1180 1230,1535 1535,1840
in, in this, this environment,|
在这种环境中，|

788
00:20:07,680 --> 00:20:09,140
0,245 245,335 335,580 660,1295 1295,1460
you would basically reconstruct the
你可以通过重放日志来重建内存中的索引，

789
00:20:09,140 --> 00:20:11,150
0,165 165,470 1000,1395 1395,1650 1650,2010
{in-memory -} index by replaying

790
00:20:11,150 --> 00:20:12,080
0,120 120,380 490,720 720,810 810,930
the log,| so you could
|这样你就可以在只读文件系统中执行此操作。

791
00:20:12,080 --> 00:20:13,205
0,90 90,285 285,525 525,800 850,1125
do it in a {readonly

792
00:20:13,205 --> 00:20:14,360
0,165 165,635
-} {file,system}.|
|

793
00:20:18,185 --> 00:20:18,590
0,105 105,195 195,255 255,315 315,405
Actually, I don't know what
事实上，我不知道 RocksDB 所做的。

794
00:20:18,590 --> 00:20:20,060
0,150 150,345 345,650
{RocksDB -} does.|
|

795
00:20:20,380 --> 00:20:22,320
0,400 840,1205 1205,1460 1460,1655 1655,1940
Yes.| { - - -}
是的。|

796
00:20:22,320 --> 00:20:24,825
0,380 670,1070 1120,1470 1470,1820 2230,2505

797
00:20:24,825 --> 00:20:25,680
0,165 165,345 345,495 495,630 630,855

798
00:20:25,680 --> 00:20:26,850
0,315 315,615 615,825 825,1005 1005,1170

799
00:20:26,850 --> 00:20:27,740
0,260

800
00:20:27,740 --> 00:20:28,955
0,90 90,240 240,530 730,990 990,1215
{So,the} question is,| is this
所以问题是，|这个索引是不是相同的索引，

801
00:20:28,955 --> 00:20:30,275
0,285 285,465 465,690 690,1055 1075,1320
index the same index,| you
|当你在 SQLite 中运行 CREATE INDEX 时得到的。

802
00:20:30,275 --> 00:20:31,445
0,90 90,335 565,810 810,930 930,1170
would get when you run

803
00:20:31,445 --> 00:20:32,860
0,330 330,600 600,840 840,1140 1140,1415
CREATE INDEX in {SQLite -}.|
|

804
00:20:33,390 --> 00:20:35,950
0,320 320,640 1050,1445 1445,1720 2160,2560
And specifically {SQLite -}, no.|
特别指 SQLite ，不是。|

805
00:20:39,970 --> 00:20:41,660
0,400 480,920 920,1055 1055,1235 1235,1690
Well, SQLite not {log-structured -},|
好的， SQLite 不是日志结构的，|

806
00:20:42,550 --> 00:20:44,145
0,365 365,730 900,1190 1190,1400 1400,1595
you basically is this the
你是说，这与主键索引相同吗，

807
00:20:44,145 --> 00:20:45,945
0,255 255,600 600,965 1225,1515 1515,1800
same index as a primary

808
00:20:45,945 --> 00:20:52,725
0,315 315,635 5425,5775 5775,6125 6535,6780
key index,| potentially, yes, but
|可能，是的，但并不总是，

809
00:20:52,725 --> 00:20:55,170
0,165 165,485 985,1385 1945,2325 2325,2445
not always, right,| SQL is
|SQL 有点复杂，

810
00:20:55,170 --> 00:20:56,175
0,105 105,195 195,440 520,840 840,1005
kind of complicated,| they index
|页面索引，

811
00:20:56,175 --> 00:20:57,330
0,120 120,285 285,605 745,1035 1035,1155
of {} pages| and you
|你可以有非表索引，

812
00:20:57,330 --> 00:20:59,840
0,105 105,380 460,860 1600,2000 2110,2510
can have the non index,

813
00:21:00,280 --> 00:21:01,970
0,350 350,700 750,1250 1250,1430 1430,1690
non table indexes| and then
|然后主键表索引，

814
00:21:01,990 --> 00:21:03,680
0,400 510,815 815,1010 1010,1220 1220,1690
the primary key table indexes,|
|

815
00:21:04,120 --> 00:21:04,725
0,245 245,305 305,365 365,470 470,605
give me a second, we'll
给我一点时间，我们会讲到这个。

816
00:21:04,725 --> 00:21:06,420
0,60 60,150 150,395
get to that.|
|

817
00:21:07,740 --> 00:21:08,620
0,245 245,335 335,455 455,605 605,880
Think of this as like,|
把这个想象成这样，|

818
00:21:10,630 --> 00:21:12,075
0,365 365,500 500,760 870,1190 1190,1445
it's almost like the internal
它几乎就像查找记录的内部记账，

819
00:21:12,075 --> 00:21:13,290
0,480 480,600 600,810 810,1020 1020,1215
bookkeeping of find, the find

820
00:21:13,290 --> 00:21:15,045
0,320 1090,1335 1335,1440 1440,1560 1560,1755
records,| almost like the page
|几乎就像页面目录，

821
00:21:15,045 --> 00:21:16,170
0,360 360,555 555,645 645,885 885,1125
directory,| it's not something you
|这不是你必须向 SQL 查询本身公开的内容，

822
00:21:16,170 --> 00:21:18,855
0,260 490,765 765,1250 1420,1820 2410,2685
would necessarily expose to the

823
00:21:18,855 --> 00:21:20,625
0,240 240,540 540,875 1345,1620 1620,1770
SQL queries themselves,| but you
|但你可以使用它们。

824
00:21:20,625 --> 00:21:21,330
0,165 165,315 315,435 435,570 570,705
could, you could use them

825
00:21:21,330 --> 00:21:22,220
0,120 120,380
for that.|
|

826
00:21:23,430 --> 00:21:24,395
0,260 260,410 410,590 590,740 740,965

827
00:21:24,395 --> 00:21:25,460
0,270 270,450 450,675 675,855 855,1065

828
00:21:25,460 --> 00:21:27,320
0,180 180,470 760,1160 1210,1530 1530,1860

829
00:21:27,320 --> 00:21:28,595
0,180 180,405 405,710 820,1065 1065,1275

830
00:21:28,595 --> 00:21:29,945
0,365 445,705 705,810 810,1095 1095,1350

831
00:21:29,945 --> 00:21:31,000
0,180 180,390 390,510 510,720 720,1055

832
00:21:31,460 --> 00:21:32,840
0,320

833
00:21:32,840 --> 00:21:34,060
0,135 135,240 240,375 375,800 820,1220

834
00:21:34,410 --> 00:21:35,860
0,275 275,550 600,905 905,1130 1130,1450

835
00:21:36,300 --> 00:21:37,940
0,430 510,770 770,995 995,1240

836
00:21:38,460 --> 00:21:39,770
0,290 290,440 440,620 620,940 1050,1310
So your question is, you
所以你的问题是，

837
00:21:39,770 --> 00:21:41,705
0,135 135,410 970,1370 1420,1725 1725,1935
statement is,| this index is
|这个索引指向的是发生在内存中的事情，

838
00:21:41,705 --> 00:21:42,695
0,255 255,555 555,765 765,870 870,990
pointing to things that happen

839
00:21:42,695 --> 00:21:44,075
0,120 120,365 865,1125 1125,1230 1230,1380
in memory,| which is not
|这不是真的，

840
00:21:44,075 --> 00:21:45,275
0,195 195,485 685,930 930,1050 1050,1200
true, right,| it could point
|它可以指向磁盘。

841
00:21:45,275 --> 00:21:47,900
0,135 135,395
to {the,disk}.|
|

842
00:21:47,900 --> 00:21:49,265
0,255 255,285 285,375 375,650 1090,1365

843
00:21:49,265 --> 00:21:52,860
0,240 240,570 570,885 885,1235

844
00:21:52,860 --> 00:21:53,580
0,225 225,300 300,390 390,555 555,720
Why do we store everything
为什么我们要存储所有东西，

845
00:21:53,580 --> 00:21:54,945
0,165 165,470 1140,1215 1215,1290 1290,1365
down here,| we'll do that
|我们马上就会做这个，

846
00:21:54,945 --> 00:21:57,020
0,75 75,150 150,395 835,1235
in a second,| but,
|但是，在这个例子中，

847
00:21:58,770 --> 00:21:59,780
0,260 260,425 425,635 635,830 830,1010
in this case here,| I
|我有 ID 等于 103 ，

848
00:21:59,780 --> 00:22:02,765
0,290 2080,2445 2445,2685 2685,2820 2820,2985
have ID equals {103 -

849
00:22:02,765 --> 00:22:04,010
0,305 355,690 690,825 825,990 990,1245
-},| it's not in memory,
|它不在内存中，它在磁盘上的某个地方，

850
00:22:04,010 --> 00:22:05,780
0,270 270,495 495,630 630,1220
it's somewhere's on disk,|
|

851
00:22:05,790 --> 00:22:08,220
0,335 335,575 575,880 1290,1690
so, but where, right,|
那么，在哪里，|

852
00:22:08,220 --> 00:22:08,940
0,120 120,270 270,405 405,585 585,720
I can't just [blow away]
我不能丢弃整个文件，

853
00:22:08,940 --> 00:22:10,230
0,255 255,555 555,860 940,1200 1200,1290
the whole file,| I would
|我得把它拿出来，

854
00:22:10,230 --> 00:22:11,270
0,75 75,195 195,470 550,795 795,1040
have to pull it out,

855
00:22:11,590 --> 00:22:12,740
0,400
right,|
|

856
00:22:12,740 --> 00:22:13,835
0,210 210,435 435,720 720,945 945,1095
and that's expensive and that's
它是昂贵的，它是压缩的，

857
00:22:13,835 --> 00:22:14,930
0,335 780,825 825,900 900,1005 1005,1095
compaction,| we'll get that in
|我们稍后会讲到这个。

858
00:22:14,930 --> 00:22:15,820
0,75 75,320
a second.|
|

859
00:22:17,210 --> 00:22:18,420
0,400
Yes.|
是的。|

860
00:22:18,500 --> 00:22:19,550
0,120 120,270 270,495 495,780 780,1050

861
00:22:19,550 --> 00:22:22,080
0,320 550,950 1180,1560 1560,1940

862
00:22:23,410 --> 00:22:25,440
0,400 780,1180 1290,1670 1670,1910 1910,2030

863
00:22:25,440 --> 00:22:27,340
0,255 255,570 570,885 885,1280

864
00:22:30,460 --> 00:22:32,640
0,260 260,425 425,730
His statement is,|
他的说法是，|

865
00:22:33,060 --> 00:22:33,755
0,275 275,380 380,455 455,545 545,695
why do we need to
为什么我们需要存储这个 DEL 记录，

866
00:22:33,755 --> 00:22:35,195
0,210 210,465 465,690 690,965 1165,1440
store this DEL record,| if
|如果它已经被删除了，为什么还要保存它。

867
00:22:35,315 --> 00:22:36,300
0,245
it's,

868
00:22:36,555 --> 00:22:37,760
0,135 135,270 270,495 495,915 915,1205
if it's been deleted, why

869
00:22:37,780 --> 00:22:41,220
0,395 395,680 680,970
even store that.|
|

870
00:22:42,690 --> 00:22:44,405
0,400 960,1325 1325,1445 1445,1550 1550,1715
Because there's gonna be a
因为这里会有 PUT ，

871
00:22:44,405 --> 00:22:46,055
0,335 445,720 720,915 915,1235 1345,1650
PUT,| for like this, say
|比如 102 ，有一个 PUT 在它前面，

872
00:22:46,055 --> 00:22:46,985
0,165 165,300 300,555 555,825 825,930
{102 - -}, there's a

873
00:22:46,985 --> 00:22:48,380
0,150 150,345 345,525 525,785 1075,1395
PUT before it, right,| but
|但是假如另一个 PUT 已经写在磁盘上，

874
00:22:48,380 --> 00:22:49,160
0,195 195,300 300,405 405,600 600,780
say there was another PUT

875
00:22:49,160 --> 00:22:49,880
0,105 105,225 225,375 375,525 525,720
that got written at the

876
00:22:49,880 --> 00:22:51,800
0,320 940,1290 1290,1590 1590,1800 1800,1920
disk,| I again, think of
|想象我回到过去，

877
00:22:51,800 --> 00:22:52,740
0,260
like,

878
00:22:52,740 --> 00:22:53,900
0,225 225,420 420,660 660,855 855,1160
I'm going back in time|
|

879
00:22:54,580 --> 00:22:55,335
0,275 275,410 410,515 515,590 590,755
and I want to make
我想确保，

880
00:22:55,335 --> 00:23:00,285
0,240 240,545 805,1205 4345,4665 4665,4950
sure that,| if I don't
|如果我没有删除，那么它确实存在，

881
00:23:00,285 --> 00:23:01,125
0,120 120,345 345,600 600,750 750,840
have that delete, then it

882
00:23:01,125 --> 00:23:02,680
0,225 225,605
does exist,

883
00:23:02,680 --> 00:23:03,895
0,320 490,735 735,885 885,1110 1110,1215
right,| because I can't go
|因为我不能回去，

884
00:23:03,895 --> 00:23:05,305
0,165 165,450 450,845 985,1275 1275,1410
back| and okay, {102 -}
|好的， 102 被删除了，

885
00:23:05,305 --> 00:23:05,965
0,135 135,375 375,435 435,525 525,660
got deleted,| let me find
|让我找一个它所在的页面，然后把它拉出来，

886
00:23:05,965 --> 00:23:06,685
0,150 150,345 345,495 495,630 630,720
a page where it's in

887
00:23:06,685 --> 00:23:07,750
0,195 195,375 375,480 480,725 805,1065
and pull it out,| I
|我不能那么做，

888
00:23:07,750 --> 00:23:08,935
0,195 195,285 285,530 880,1110 1110,1185
can't do that,| so I
|所以我追加一个日志记录，说，

889
00:23:08,935 --> 00:23:09,670
0,120 120,240 240,330 330,525 525,735
just append a {log,record} and

890
00:23:09,670 --> 00:23:10,600
0,180 180,465 465,675 675,825 825,930
say,| okay, if you're going
|好的，如果你回到过去，查看 102 ，

891
00:23:10,600 --> 00:23:11,515
0,135 135,255 255,510 510,750 750,915
back in time and you

892
00:23:11,515 --> 00:23:12,630
0,225 225,405 405,555 555,780 780,1115
see {102 - -},| no,
|它已经被删除了。

893
00:23:12,650 --> 00:23:14,020
0,290 290,425 425,850
it's been deleted.|
|

894
00:23:14,790 --> 00:23:15,890
0,320 320,575 575,830 830,995 995,1100
And we'll coalesce them in
我们将在稍后将它们合并，

895
00:23:15,890 --> 00:23:17,285
0,90 90,350 490,810 810,1130 1150,1395
a second| to remove the
|以删除这些内容的多余条目。

896
00:23:17,285 --> 00:23:18,340
0,150 150,480 480,615 615,765 765,1055
extra entries of those things.|
|

897
00:23:22,320 --> 00:23:24,935
0,400 930,1250 1250,1570 2130,2435 2435,2615
Okay, so as both these
好的，就像这两个人提到的那样，

898
00:23:24,935 --> 00:23:25,985
0,210 210,390 390,525 525,900 900,1050
guys sort of alluded to

899
00:23:25,985 --> 00:23:27,500
0,150 150,425 895,1245 1245,1440 1440,1515
is like,| well, some of
|一些日志记录，我们不需要永远维护它们，

900
00:23:27,500 --> 00:23:28,400
0,105 105,270 270,540 540,765 765,900
these log records, we don't

901
00:23:28,400 --> 00:23:29,320
0,90 90,180 180,360 360,615 615,920
need to maintain these forever,

902
00:23:30,020 --> 00:23:31,180
0,350
right,|
|

903
00:23:31,190 --> 00:23:32,905
0,400 450,755 755,1060 1260,1565 1565,1715
and DELETE was example of
DELETE 就是这样的例子，

904
00:23:32,905 --> 00:23:34,120
0,225 225,605 625,900 900,1065 1065,1215
this,| or PUTs over the
|或者 PUT 一遍又一遍地在同一个键上。

905
00:23:34,120 --> 00:23:34,870
0,180 180,390 390,540 540,630 630,750
same key over and over

906
00:23:34,870 --> 00:23:36,160
0,225 225,560
again, right.|
|

907
00:23:36,230 --> 00:23:37,960
0,305 305,610 1080,1340 1340,1490 1490,1730
And so in a {log-structured
所以，在日志结构数据库系统中，

908
00:23:37,960 --> 00:23:39,025
0,315 315,510 510,765 765,915 915,1065
-} database system,| what they're
|他们要做的是，

909
00:23:39,025 --> 00:23:39,610
0,45 45,120 120,255 255,405 405,585
going to do is,| they're
|定期运行一些后台作业，

910
00:23:39,610 --> 00:23:41,140
0,645 645,900 900,1080 1080,1290 1290,1530
periodically going to run some

911
00:23:41,140 --> 00:23:42,640
0,290 310,710
background job,|
|

912
00:23:42,640 --> 00:23:44,070
0,150 150,300 300,770 850,1140 1140,1430
that will compact the pages,|
用来压缩页面，|

913
00:23:45,070 --> 00:23:46,680
0,395 395,740 740,1160 1160,1370 1370,1610
to, to coalesce them to
把它们结合起来，减少多余的操作。

914
00:23:46,680 --> 00:23:50,260
0,320 1300,2000 2260,2660
reduce redundant operations.|
|

915
00:23:50,600 --> 00:23:51,415
0,230 230,290 290,410 410,605 605,815
So in this case here,|
在这个例子中，|

916
00:23:51,415 --> 00:23:52,765
0,165 165,345 345,570 570,875 1045,1350
I have page one, one
我有页面 #1 和页面 #2 ，

917
00:23:52,765 --> 00:23:53,935
0,150 150,330 330,665 805,1065 1065,1170
and page two,| think of
|这是从最新到最旧，抱歉，最旧到最新，

918
00:23:53,935 --> 00:23:56,395
0,120 120,360 360,725 1945,2340 2340,2460
this going as newest to

919
00:23:56,395 --> 00:23:57,910
0,245 685,960 960,1140 1140,1305 1305,1515
oldest, sorry, oldest to newest,|
|

920
00:23:57,910 --> 00:23:58,710
0,105 105,225 225,375 375,525 525,800
so this one is older
所以这个比这个旧，

921
00:23:59,000 --> 00:24:00,595
0,290 290,470 470,760 1170,1445 1445,1595
than this one| and so
|所以如果我想压缩它们，

922
00:24:00,595 --> 00:24:01,285
0,120 120,210 210,285 285,360 360,690
if I want to compact

923
00:24:01,285 --> 00:24:02,650
0,335 655,960 960,1140 1140,1260 1260,1365
them,| then all you need
|那么你需要做的就是，

924
00:24:02,650 --> 00:24:03,820
0,120 120,315 315,540 540,830 850,1170
to do is,| recognize that
|这是我关心的最新条目，

925
00:24:03,820 --> 00:24:05,005
0,240 240,435 435,570 570,780 780,1185
here are the latest entries

926
00:24:05,005 --> 00:24:06,340
0,120 120,255 255,465 465,785 1045,1335
that I care about| for
|对于这两个页面中引用的键，

927
00:24:06,340 --> 00:24:08,580
0,165 165,440 580,840 840,1100 1540,2240
the keys that are referenced

928
00:24:08,870 --> 00:24:10,440
0,260 260,410 410,575 575,850 1170,1570
in these two pages, right,|
|

929
00:24:10,640 --> 00:24:11,830
0,260 260,395 395,560 560,850 930,1190
so {103 - -}, {104
所以 103 104 ，

930
00:24:11,830 --> 00:24:13,120
0,165 165,470 820,1065 1065,1155 1155,1290
- -}| and then we
|然后我们删除 101 和 102 ，

931
00:24:13,120 --> 00:24:13,855
0,180 180,330 330,465 465,615 615,735
DELETE {101 - -} and

932
00:24:13,855 --> 00:24:14,920
0,105 105,240 240,515 715,960 960,1065
{102 - -}| and then
|然后放入 105 ，

933
00:24:14,920 --> 00:24:15,690
0,135 135,270 270,390 390,510 510,770
the PUT {105 - -},

934
00:24:16,160 --> 00:24:17,810
0,255 255,555 555,890 1210,1560 1560,1650
right,| again, so there's a
|这里有一个 PUT 105 ，

935
00:24:17,810 --> 00:24:18,730
0,135 135,255 255,375 375,585 585,920
PUT {105 - -} here,|
|

936
00:24:18,840 --> 00:24:20,290
0,275 275,500 500,755 755,965 965,1450
but because this is newer
但是因为这个比这个 105 更新，

937
00:24:20,430 --> 00:24:21,820
0,400 420,800 800,1025 1025,1130 1130,1390
than this {105 - -},|
|

938
00:24:22,140 --> 00:24:23,525
0,260 260,440 440,605 605,970 1140,1385
we know we don't,| we
我们知道我们不需要，|我们想要这个，而不是这个，

939
00:24:23,525 --> 00:24:24,575
0,210 210,495 495,705 705,885 885,1050
want this one, not this

940
00:24:24,575 --> 00:24:25,760
0,275 475,735 735,855 855,960 960,1185
one,| so instead of storing
|所以不需要存储两个 105 ，

941
00:24:25,760 --> 00:24:27,110
0,570 570,690 690,950 970,1215 1215,1350
{PUT,105 - -},| we only
|我们只需要存储一个，在我们的合并页面中。

942
00:24:27,110 --> 00:24:28,430
0,135 135,240 240,375 375,650 1060,1320
need to store one, in

943
00:24:28,430 --> 00:24:29,960
0,150 150,480 480,770
our coalesce pages.|
|

944
00:24:30,980 --> 00:24:32,485
0,260 260,520 870,1175 1175,1355 1355,1505
And as, as he brought
正如他也提到的，

945
00:24:32,485 --> 00:24:33,370
0,120 120,240 240,480 480,735 735,885
up as well,| like, it
|情况可能是，

946
00:24:33,370 --> 00:24:34,290
0,135 135,255 255,360 360,570 570,920
may be the case that,|
|

947
00:24:35,420 --> 00:24:36,265
0,335 335,500 500,620 620,710 710,845
I actually don't need to
我不需要在这一点上存储 DELETE ，

948
00:24:36,265 --> 00:24:37,390
0,150 150,330 330,635 685,960 960,1125
store the DELETEs at this

949
00:24:37,390 --> 00:24:38,900
0,150 150,285 285,560
point as well,|
|

950
00:24:38,900 --> 00:24:41,015
0,260 1240,1575 1575,1830 1830,1905 1905,2115
{} because there's some other
因为系统上的其他部分，

951
00:24:41,015 --> 00:24:41,870
0,285 285,450 450,540 540,660 660,855
upper part of the system,|
|

952
00:24:41,870 --> 00:24:42,970
0,180 180,315 315,495 495,810 810,1100
that says all I've removed
表明我已经从索引中删除了 102 101 ，

953
00:24:44,640 --> 00:24:45,515
0,260 260,395 395,530 530,665 665,875
{102 - -} {101 -}

954
00:24:45,515 --> 00:24:46,895
0,165 165,345 345,695 955,1245 1245,1380
from my index,| so anybody
|任何人查找，他们会看到键没有找到，

955
00:24:46,895 --> 00:24:47,705
0,90 90,210 210,540 540,735 735,810
does a lookup, they'll see

956
00:24:47,705 --> 00:24:48,950
0,120 120,255 255,405 405,695 925,1245
a key not found| and
|所以我不需要存储这个日志条目。

957
00:24:48,950 --> 00:24:49,805
0,285 285,510 510,660 660,735 735,855
therefore I don't need to

958
00:24:49,805 --> 00:24:50,930
0,275 385,645 645,915 915,1035 1035,1125
store the log entry for

959
00:24:50,930 --> 00:24:51,780
0,230
this.|
|

960
00:24:53,790 --> 00:24:54,850
0,245 245,350 350,485 485,650 650,1060
So this is called compaction|
这就是所谓的压缩，|

961
00:24:56,550 --> 00:24:58,385
0,245 245,490 900,1300 1350,1640 1640,1835
and this is again, no
同样，这也没有免费午餐，

962
00:24:58,385 --> 00:25:00,830
0,180 180,455 1015,1275 1275,1535 2185,2445
free lunch,| the log, the
|日志结构存储将使插入速度更快，

963
00:25:00,830 --> 00:25:01,850
0,165 165,375 375,660 660,915 915,1020
{log-structured -} storage is going

964
00:25:01,850 --> 00:25:02,705
0,45 45,165 165,315 315,720 720,855
to make the inserts much

965
00:25:02,705 --> 00:25:04,055
0,275 565,825 825,990 990,1125 1125,1350
faster,| because it's just appending
|因为它只追加日志，

966
00:25:04,055 --> 00:25:05,345
0,135 135,225 225,485 805,1110 1110,1290
to the log,| but at
|但在某个时刻，我们必须去清理东西。

967
00:25:05,345 --> 00:25:05,990
0,180 180,360 360,540 540,585 585,645
some point, we're going to

968
00:25:05,990 --> 00:25:06,680
0,90 90,195 195,330 330,510 510,690
have to go clean things

969
00:25:06,680 --> 00:25:07,480
0,290
up.|
|

970
00:25:09,110 --> 00:25:10,765
0,400 840,1100 1100,1220 1220,1430 1430,1655
{All,right}, so again, the idea
好的，所以我们的想法是，

971
00:25:10,765 --> 00:25:13,210
0,165 165,435 435,815 1075,1475 2185,2445
is that,| we we do
|我们做这种压缩，

972
00:25:13,210 --> 00:25:14,610
0,165 165,470 700,990 990,1170 1170,1400
this compaction,| now we down,
|现在我们得到日志记录的压缩形式，

973
00:25:14,870 --> 00:25:16,110
0,275 275,440 440,590 590,875 875,1240
now we're down to a,

974
00:25:16,490 --> 00:25:19,645
0,400 1860,2420 2420,2780 2780,3020 3020,3155
a compressed form of the,

975
00:25:19,645 --> 00:25:20,430
0,150 150,285 285,405 405,525 525,785
of the log of record,|
|

976
00:25:20,630 --> 00:25:21,565
0,260 260,380 380,515 515,710 710,935
and this is only on
这只是在磁盘上，

977
00:25:21,565 --> 00:25:23,185
0,605 625,915 915,1245 1245,1440 1440,1620
disk,| we can't do in
|我们无法进行就地更新，

978
00:25:23,185 --> 00:25:24,145
0,240 240,540 540,720 720,825 825,960
place updates,| so this is
|这就是取一个磁盘页，另一个磁盘页，

979
00:25:24,145 --> 00:25:25,870
0,210 210,545 985,1275 1275,1470 1470,1725
literally taking one disk page,

980
00:25:25,870 --> 00:25:26,695
0,225 225,435 435,570 570,705 705,825
another disk page| and then
|然后写出一个新的，

981
00:25:26,695 --> 00:25:27,630
0,195 195,390 390,525 525,660 660,935
writing out a new one,|
|

982
00:25:27,710 --> 00:25:29,365
0,275 275,470 470,910 1110,1415 1415,1655
we can't overwrite an existing
我们不能覆盖现有的。

983
00:25:29,365 --> 00:25:30,880
0,335
one.|
|

984
00:25:31,770 --> 00:25:32,705
0,320 320,530 530,695 695,815 815,935
Another important thing to keep
另一件需要跟踪的重要事情是，

985
00:25:32,705 --> 00:25:33,620
0,150 150,360 360,555 555,705 705,915
track of too is that,|
|

986
00:25:33,620 --> 00:25:35,330
0,195 195,360 360,495 495,1070 1390,1710
once it's on disk,| we
一旦它存储在磁盘上，|我们就知道它旧于，

987
00:25:35,330 --> 00:25:36,260
0,285 285,540 540,765 765,855 855,930
know that it's going to

988
00:25:36,260 --> 00:25:38,220
0,120 120,410 550,950
be older than,|
|

989
00:25:38,220 --> 00:25:40,425
0,320 1570,1875 1875,2010 2010,2085 2085,2205
{} once we have a
一旦我们在磁盘上有了一个页面，

990
00:25:40,425 --> 00:25:41,475
0,150 150,300 300,600 600,810 810,1050
page on disk,| and once
|并且我们已经压缩了它，

991
00:25:41,475 --> 00:25:42,825
0,150 150,255 255,720 720,900 900,1350
we've already compacted it,| removing
|删除多余的或拥有相同的键的反复操作，

992
00:25:42,825 --> 00:25:45,285
0,240 240,755 985,1260 1260,1535 2095,2460
the redundant or the operations

993
00:25:45,285 --> 00:25:46,140
0,240 240,375 375,555 555,735 735,855
own the same key over

994
00:25:46,140 --> 00:25:47,340
0,90 90,240 240,560 700,990 990,1200
and over again,| that means
|这意味着在我们压缩的磁盘页中，

995
00:25:47,340 --> 00:25:49,740
0,195 195,470 640,1040 1900,2205 2205,2400
that within a disk page

996
00:25:49,740 --> 00:25:51,500
0,195 195,740 820,1095 1095,1365 1365,1760
we've compacted,| it only contains,
|它只包含，或者每个键只被引用一次，

997
00:25:51,940 --> 00:25:52,965
0,305 305,560 560,785 785,905 905,1025
or each key is only

998
00:25:52,965 --> 00:25:53,870
0,90 90,120 120,195 195,600 600,905
going to be referenced once,|
|

999
00:25:55,890 --> 00:25:56,780
0,260 260,410 410,575 575,695 695,890
at this point, we don't
在这一点上，我们不再关心日志中的时间顺序，

1000
00:25:56,780 --> 00:25:58,040
0,210 210,405 405,680 700,975 975,1260
care about the the temporal

1001
00:25:58,040 --> 00:25:59,285
0,345 345,585 585,750 750,1005 1005,1245
ordering anymore {in,the} log,| we
|我们不关心最新到最旧。

1002
00:25:59,285 --> 00:26:00,140
0,210 210,375 375,555 555,735 735,855
don't care about newest to

1003
00:26:00,140 --> 00:26:01,240
0,230
oldest,

1004
00:26:01,600 --> 00:26:02,820
0,400
right.|
|

1005
00:26:03,410 --> 00:26:05,050
0,245 245,490 900,1175 1175,1385 1385,1640
So now if the operation
所以现在如果我们需要支持的操作是

1006
00:26:05,050 --> 00:26:06,055
0,165 165,255 255,435 435,705 705,1005
we need to support is|
|

1007
00:26:06,055 --> 00:26:07,060
0,285 285,495 495,690 690,870 870,1005
go find the key {103
在磁盘上找出键 103 104 105 ，

1008
00:26:07,060 --> 00:26:07,990
0,165 165,405 405,600 600,735 735,930
- -}, {104 - -}

1009
00:26:07,990 --> 00:26:09,000
0,165 165,285 285,480 480,705 705,1010
{105 - -} or whatever

1010
00:26:09,230 --> 00:26:10,705
0,290 290,440 440,970 1020,1295 1295,1475
in the disk,| the temporal
|时间顺序对我们没有帮助，

1011
00:26:10,705 --> 00:26:11,800
0,225 225,495 495,645 645,855 855,1095
order doesn't help us,| and
|实际上，我们要做的是，

1012
00:26:11,800 --> 00:26:12,535
0,165 165,270 270,405 405,570 570,735
actually what we want to

1013
00:26:12,535 --> 00:26:13,855
0,275 475,780 780,975 975,1110 1110,1320
do is| sort the disk
|对磁盘页进行排序，基于键进行排序，

1014
00:26:13,855 --> 00:26:15,420
0,225 225,465 465,615 615,905 1165,1565
pages, sort the keys based

1015
00:26:15,980 --> 00:26:17,275
0,290 290,455 455,695 695,1055 1055,1295
sort,| sort the records of,
|根据键对此页中的日志记录进行排序。

1016
00:26:17,275 --> 00:26:18,175
0,90 90,225 225,480 480,705 705,900
the log records in the,

1017
00:26:18,175 --> 00:26:19,585
0,180 180,390 390,645 645,935 1135,1410
in the this page based

1018
00:26:19,585 --> 00:26:20,840
0,135 135,255 255,515
on the keys,

1019
00:26:21,750 --> 00:26:23,600
0,400 1290,1520 1520,1595 1595,1700 1700,1850
right.| So we do something
|所以我们这样做，

1020
00:26:23,600 --> 00:26:26,600
0,150 150,410 2320,2595 2595,2775 2775,3000
like this,| because again, now
|因为，现在我需要知道的是，

1021
00:26:26,600 --> 00:26:27,365
0,195 195,330 330,450 450,570 570,765
all I need to know

1022
00:26:27,365 --> 00:26:28,310
0,255 255,465 465,600 600,780 780,945
now is,| if I'm looking
|如果我看着这个页面，

1023
00:26:28,310 --> 00:26:29,645
0,165 165,300 300,495 495,800 1030,1335
at this, this page,| I
|我知道这些页面比其他页面更老，

1024
00:26:29,645 --> 00:26:30,455
0,180 180,300 300,420 420,615 615,810
know that these pages are

1025
00:26:30,455 --> 00:26:33,020
0,275 385,645 645,780 780,1055 2335,2565
older than each other,| so
|所以我有一些类似的元数据，

1026
00:26:33,020 --> 00:26:33,680
0,75 75,225 225,375 375,480 480,660
I have sort of some

1027
00:26:33,680 --> 00:26:34,745
0,345 345,495 495,675 675,855 855,1065
meta like that,| but each
|但每个日志记录，我不需要知道一个比另一个更老。

1028
00:26:34,745 --> 00:26:36,170
0,285 285,635 865,1125 1125,1320 1320,1425
log record, I don't need

1029
00:26:36,170 --> 00:26:37,175
0,120 120,285 285,510 510,825 825,1005
to know whether one's older

1030
00:26:37,175 --> 00:26:38,320
0,240 240,545
than another.|
|

1031
00:26:40,210 --> 00:26:42,720
0,400 1920,2180 2180,2300 2300,2405 2405,2510
So when you do this
所以当你做压缩的时候，

1032
00:26:42,720 --> 00:26:43,440
0,120 120,330 330,525 525,600 600,720
{compaction -}| and then you
|然后你根据键值对它们进行排序，

1033
00:26:43,440 --> 00:26:44,955
0,195 195,450 450,705 705,1010 1240,1515
sort them based on the

1034
00:26:44,955 --> 00:26:47,235
0,165 165,455 1705,1965 1965,2070 2070,2280
key values,| these are sometimes
|这些有时被称为排序字符串表或 SSTables ，

1035
00:26:47,235 --> 00:26:48,390
0,300 300,510 510,690 690,900 900,1155
called {Sorted -} String Tables

1036
00:26:48,390 --> 00:26:50,310
0,195 195,480 480,770 1510,1785 1785,1920
or {SSTables - -},| I think
|我想这个术语是 Jeff Dean 和 Sandjay 创造的，

1037
00:26:50,310 --> 00:26:51,450
0,195 195,495 495,780 780,975 975,1140
this, this, this term is

1038
00:26:51,450 --> 00:26:53,060
0,270 270,530 640,945 945,1245 1245,1610
coined by Jeff Dean and

1039
00:26:53,710 --> 00:26:55,185
0,275 275,605 605,880 1140,1385 1385,1475
the Sandjay guy,| when they
|当他们在谷歌写 LevelDB 时，

1040
00:26:55,185 --> 00:26:56,150
0,120 120,315 480,585 585,705 705,965
wrote {LevelDB -} at Google,|
|

1041
00:26:56,440 --> 00:26:57,285
0,260 260,365 365,515 515,680 680,845
this is for, for {bigtable
这是为了 2000 年中期的 bigtable 。

1042
00:26:57,285 --> 00:26:58,215
0,225 225,390 390,540 540,690 690,930
-} in the, in the

1043
00:26:58,215 --> 00:27:00,580
0,270 270,420 420,695
mid {2000s -}.|
|

1044
00:27:00,930 --> 00:27:02,840
0,400 720,1120 1290,1565 1565,1715 1715,1910
And the again, the advantage
这样做的好处是，

1045
00:27:02,840 --> 00:27:04,145
0,180 180,315 315,450 450,710 970,1305
of this is that,| when
|当我要去取这一页时，

1046
00:27:04,145 --> 00:27:05,045
0,210 210,330 330,405 405,600 600,900
I have to go fetch

1047
00:27:05,045 --> 00:27:06,695
0,300 300,585 585,875 1075,1470 1470,1650
this page in,| I'm not
|我不会去找，

1048
00:27:06,695 --> 00:27:08,150
0,285 285,525 525,815 955,1230 1230,1455
looking for,| like give me,
|比如给我这个时间戳的 103 的 PUT ，

1049
00:27:08,150 --> 00:27:09,425
0,210 210,470 550,855 855,1080 1080,1275
give me the PUT for

1050
00:27:09,425 --> 00:27:10,400
0,135 135,285 285,525 525,765 765,975
{103 - -} this {timestamp

1051
00:27:10,400 --> 00:27:11,645
0,320 460,750 750,840 840,1020 1020,1245
-},| you're just looking for
|你只是查找 PUT 103 ，

1052
00:27:11,645 --> 00:27:13,240
0,180 180,315 315,480 480,785
PUT {103 - -},|
|

1053
00:27:13,240 --> 00:27:13,825
0,165 165,285 285,375 375,465 465,585
and so you want to
所以你需要尽快找到那个记录，

1054
00:27:13,825 --> 00:27:14,725
0,180 180,345 345,585 585,720 720,900
do a lookup to find

1055
00:27:14,725 --> 00:27:16,540
0,305 865,1170 1170,1395 1395,1620 1620,1815
that that record as quickly

1056
00:27:16,540 --> 00:27:18,445
0,165 165,440 1060,1335 1335,1610 1660,1905
as possible,| and so if
|如果你进行了排序，

1057
00:27:18,445 --> 00:27:19,645
0,195 195,605 685,945 945,1050 1050,1200
you're sorted,| you can then
|你可以以某种方式构建索引或过滤器，

1058
00:27:19,645 --> 00:27:20,845
0,285 285,615 615,900 900,1080 1080,1200
build an index or a

1059
00:27:20,845 --> 00:27:22,285
0,275 745,1005 1005,1110 1110,1215 1215,1440
filter some way| to quickly
|快速跳到你要查找的记录，

1060
00:27:22,285 --> 00:27:24,280
0,300 300,635 715,1115 1525,1815 1815,1995
jump to that record you're

1061
00:27:24,280 --> 00:27:25,285
0,120 120,410 460,750 750,900 900,1005
looking for,| rather than having
|而不必在整个文件中执行二分搜索。

1062
00:27:25,285 --> 00:27:26,260
0,75 75,180 180,540 540,765 765,975
to do binary search across

1063
00:27:26,260 --> 00:27:27,560
0,165 165,345 345,650
the entire file.|
|

1064
00:27:27,770 --> 00:27:28,930
0,275 275,440 440,545 545,1070 1070,1160
So there's some metadata and
所以有一些元数据和每个 SSTable 页的 header ，

1065
00:27:28,930 --> 00:27:29,755
0,135 135,465 465,615 615,720 720,825
the header for each of

1066
00:27:29,755 --> 00:27:32,065
0,105 105,375 375,665 1045,1445 2035,2310
these {SSTable -} pages,| that
|跟踪，

1067
00:27:32,065 --> 00:27:34,840
0,165 165,345 345,635 985,1385 2335,2775
keeps track of,| {sorry\,,files}, comprise
|抱歉，由多个页面组成的文件，

1068
00:27:34,840 --> 00:27:36,340
0,240 240,560 970,1230 1230,1350 1350,1500
multiple pages,| that will keep
|跟踪不同键的偏移量在哪里。

1069
00:27:36,340 --> 00:27:38,845
0,180 180,405 405,660 660,980 2200,2505
track of where the, where

1070
00:27:38,845 --> 00:27:39,670
0,165 165,480 480,630 630,750 750,825
the offsets are for the

1071
00:27:39,670 --> 00:27:40,780
0,165 165,500
different keys.|
|

1072
00:27:42,310 --> 00:27:48,885
0,400 5580,5840 5840,6005 6005,6230 6230,6575
Yes.| The question is,| wouldn't
是的。|问题是，|我们所讨论的索引不是准确地对应东西所在的位置吗，

1073
00:27:48,885 --> 00:27:49,800
0,255 255,525 525,645 645,795 795,915
the index that we're talking

1074
00:27:49,800 --> 00:27:52,820
0,290 700,1020 1020,1260 1260,1580
about to the exact,

1075
00:27:53,100 --> 00:27:54,710
0,335 335,670 690,1090 1110,1415 1415,1610
the exact location of where

1076
00:27:54,710 --> 00:27:57,905
0,290 490,890 1600,1995 1995,2390 2920,3195
something is,| not necessarily, you
|不一定，你可能想要保持，

1077
00:27:57,905 --> 00:27:59,170
0,180 180,330 330,480 480,785 865,1265
may want to keep the,|
|

1078
00:28:03,410 --> 00:28:04,045
0,245 245,365 365,470 470,545 545,635
you may want to keep
你可能想要保持一个更[]的索引，它说，

1079
00:28:04,045 --> 00:28:05,200
0,135 135,345 345,570 570,840 840,1155
a more {[] -} index

1080
00:28:05,200 --> 00:28:06,520
0,225 225,500 850,1080 1080,1170 1170,1320
that says,| you know, here's
|这里可能不是你要找的东西的确切偏移量，

1081
00:28:06,520 --> 00:28:07,525
0,90 90,210 210,360 360,650 730,1005
not maybe the exact offset

1082
00:28:07,525 --> 00:28:08,215
0,165 165,300 300,405 405,555 555,690
of the thing you're looking

1083
00:28:08,215 --> 00:28:09,450
0,285 285,540 540,765 765,930 930,1235
for,| but here's the page,
|但这是页面，这是包含它的文件，

1084
00:28:09,770 --> 00:28:10,855
0,335 335,470 470,710 710,920 920,1085
here's the file that has

1085
00:28:10,855 --> 00:28:12,040
0,305 535,810 810,960 960,1080 1080,1185
it,| and once you get
|一旦你找到那个文件，

1086
00:28:12,040 --> 00:28:13,150
0,105 105,255 255,510 510,885 885,1110
to that file,| it'll tell
|它会告诉你在哪里找到它。

1087
00:28:13,150 --> 00:28:14,730
0,320 760,1035 1035,1155 1155,1290 1290,1580
you where to find it.|
|

1088
00:28:16,150 --> 00:28:17,010
0,290 290,470 470,620 620,770 770,860
Yeah, so maybe I'm not
是的，也许我在这里没有画出一个很好的例子，

1089
00:28:17,010 --> 00:28:17,775
0,120 120,225 225,360 360,555 555,765
drawn a good example here,|
|

1090
00:28:17,775 --> 00:28:18,645
0,150 150,285 285,510 510,660 660,870
so this I'm saying this
我要说的是，这个页面，

1091
00:28:18,645 --> 00:28:20,250
0,305 925,1200 1200,1305 1305,1395 1395,1605
page,| this could be multiple
|这可以是 SSD 文件的多个页面，

1092
00:28:20,250 --> 00:28:21,615
0,330 330,585 585,1110 1110,1230 1230,1365
pages for SSD file| and
|通常是因为这些内容变大了，

1093
00:28:21,615 --> 00:28:22,740
0,240 240,555 555,795 795,960 960,1125
typically because these things get

1094
00:28:22,740 --> 00:28:23,745
0,225 225,540 540,840 840,930 930,1005
big,| so it's not going
|所以它是单个页面。

1095
00:28:23,745 --> 00:28:24,500
0,45 45,150 150,285 285,450 450,755
to be a single page.|
|

1096
00:28:26,190 --> 00:28:29,380
0,290 290,470 470,760
{In,the} back, yes.|
后面的，是的。|

1097
00:28:30,740 --> 00:28:31,705
0,245 245,320 320,560 560,785 785,965
For the {SSTable -} or
对于 SSTable 还是内存中的？

1098
00:28:31,705 --> 00:28:32,400
0,90 90,210 210,345 345,450 450,695
the one back in memory?|
|

1099
00:28:33,470 --> 00:28:36,070
0,275 275,395 395,640 1920,2320 2340,2600
Back in memory.| Yes, because
内存中的。|是的，因为你不想在重新启动时重新创建它，

1100
00:28:36,070 --> 00:28:36,805
0,135 135,390 390,495 495,585 585,735
you don't want to have

1101
00:28:36,805 --> 00:28:38,970
0,180 180,585 585,845 1405,1695 1695,2165
to recreate it upon restart,|
|

1102
00:28:39,830 --> 00:28:40,510
0,245 245,365 365,470 470,560 560,680
and as I was saying
正如我之前所说的，

1103
00:28:40,510 --> 00:28:42,100
0,255 255,650 1060,1365 1365,1515 1515,1590
it before,| either you could
|你可以只将文件和页面本身写入磁盘，

1104
00:28:42,100 --> 00:28:43,120
0,135 135,360 360,555 555,795 795,1020
just write the file, the

1105
00:28:43,120 --> 00:28:45,970
0,260 280,630 630,840 840,1310 2560,2850
pages themselves to disk,| or
|也可以只维护一个日志记录，它说，

1106
00:28:45,970 --> 00:28:47,740
0,150 150,255 255,500 1240,1560 1560,1770
you could just maintain a

1107
00:28:47,740 --> 00:28:48,760
0,225 225,480 480,645 645,795 795,1020
log record that says,| here's
|以下是如何重建索引。

1108
00:28:48,760 --> 00:28:49,650
0,60 60,135 135,390 390,570 570,890
how to rebuild the index.|
|

1109
00:28:51,590 --> 00:28:53,080
0,400 780,1025 1025,1190 1190,1295 1295,1490
Yes. Why don't we write
是的。{ - - -}

1110
00:28:53,080 --> 00:28:54,745
0,180 180,440 820,1155 1155,1500 1500,1665

1111
00:28:54,745 --> 00:28:56,035
0,180 180,300 300,450 450,755 985,1290

1112
00:28:56,035 --> 00:28:58,300
0,300 300,605 1735,1965 1965,2100 2100,2265
{ -}| {Yes\,,the} question is,|
|是的，问题是，|

1113
00:28:58,300 --> 00:28:58,825
0,120 120,270 270,330 330,420 420,525
why don't we write the
为什么我们不按某种顺序来写这些页，

1114
00:28:58,825 --> 00:28:59,580
0,135 135,285 285,405 405,510 510,755
pages in sort of order,|
|

1115
00:29:01,250 --> 00:29:02,100
0,335 335,395 395,485 485,590 590,850
that's what they do.| Yes.|
这就是他们所做的。|是的。|

1116
00:29:02,450 --> 00:29:04,525
0,400 780,1205 1205,1430 1430,1780 1800,2075

1117
00:29:04,525 --> 00:29:06,280
0,240 240,525 525,845

1118
00:29:06,730 --> 00:29:07,920
0,400 450,710 710,845 845,1010 1010,1190

1119
00:29:07,920 --> 00:29:09,900
0,135 135,285 285,480 480,1010 1660,1980
{ - - -}| Absolutely
|绝对是的，

1120
00:29:09,900 --> 00:29:10,905
0,315 315,540 540,645 645,825 825,1005
yes,| so his statement is
|所以他的陈述是正确的，

1121
00:29:10,905 --> 00:29:12,555
0,120 120,270 270,515 865,1275 1275,1650
and he's right,| isn't compaction
|压缩不会对读取的性能产生影响吗，

1122
00:29:12,555 --> 00:29:14,400
0,255 255,545 655,1055 1375,1665 1665,1845
gonna have a impact on

1123
00:29:14,400 --> 00:29:15,000
0,135 135,240 240,390 390,510 510,600
on the performance of the

1124
00:29:15,000 --> 00:29:16,845
0,315 315,590 1360,1620 1620,1725 1725,1845
reads,| because not only you're
|因为你不仅仅是拿着锁，

1125
00:29:16,845 --> 00:29:18,060
0,75 75,255 255,720 720,1080 1080,1215
just taking locks, locks,| you're
|你在做磁盘 I/O ，

1126
00:29:18,060 --> 00:29:20,745
0,120 120,360 360,720 720,1100 2410,2685
doing disk I/Os, right,| because
|因为现在你在，

1127
00:29:20,745 --> 00:29:21,945
0,180 180,405 405,555 555,825 825,1200
now you're like you're, you're,|
|

1128
00:29:21,945 --> 00:29:22,860
0,285 285,375 375,570 570,780 780,915
we'll get to different types
我们稍后会看到不同类型的压缩，

1129
00:29:22,860 --> 00:29:23,850
0,90 90,360 360,420 420,650 730,990
of compaction a second,| now,
|现在，你可能会带入吉字节的文件，

1130
00:29:23,850 --> 00:29:25,290
0,165 165,330 330,540 540,830 910,1440
you're potentially bringing in gigabytes

1131
00:29:25,290 --> 00:29:26,925
0,90 90,285 285,620 1000,1560 1560,1635
of files in,| compacting it
|压缩文件，并将其写回，

1132
00:29:26,925 --> 00:29:27,860
0,120 120,300 300,480 480,645 645,935
and writing them back out,|
|

1133
00:29:28,270 --> 00:29:29,640
0,305 305,485 485,760
so absolutely yes.|
所以绝对是的。|

1134
00:29:29,680 --> 00:29:31,200
0,275 275,425 425,560 560,820
Again, no free lunch.|
再说一次，没有免费的午餐。|

1135
00:29:35,950 --> 00:29:37,060
0,400
Okay.|
好的。|

1136
00:29:37,980 --> 00:29:39,890
0,400 720,1085 1085,1535 1535,1775 1775,1910
So there, there's sort of
有两种主要方法可以进行压缩，

1137
00:29:39,890 --> 00:29:40,880
0,180 180,390 390,675 675,885 885,990
two main ways you can

1138
00:29:40,880 --> 00:29:44,030
0,135 135,560 1990,2385 2385,2655 2655,3150
do compaction,| and this terminology
|这里我将使用的术语是 RocksDB 中使用的。

1139
00:29:44,030 --> 00:29:45,530
0,260 310,675 675,840 840,1160 1210,1500
here I'll use is what

1140
00:29:45,530 --> 00:29:48,220
0,210 210,405 405,645 645,1010
use in {RocksDB -}.|
|

1141
00:29:48,230 --> 00:29:49,600
0,400
So,
所以，最简单的形式被称为万能压缩，

1142
00:29:49,600 --> 00:29:50,665
0,120 120,350 400,690 690,840 840,1065
the {most,simplest} form is called

1143
00:29:50,665 --> 00:29:52,915
0,270 270,695 1315,1715 1765,2085 2085,2250
Universal Compaction,| where you're just
|你只需要取磁盘上相邻的日志文件，

1144
00:29:52,915 --> 00:29:54,700
0,330 330,1085
taking adjacent

1145
00:29:54,920 --> 00:29:55,840
0,275 275,410 410,575 575,785 785,920
sort of log files that

1146
00:29:55,840 --> 00:29:57,390
0,75 75,195 195,770 850,1200 1200,1550
are on disk,| again, this
|同样，多个页面，考虑兆字节、吉字节、太字节，

1147
00:29:57,620 --> 00:29:58,705
0,320 320,560 560,725 725,875 875,1085
multiple pages, think of again,

1148
00:29:58,705 --> 00:30:01,390
0,635 715,1245 1245,1775 2245,2520 2520,2685
megabytes, gigabytes, terabytes,| and then
|然后你只需要取两个相邻的日志文件，

1149
00:30:01,390 --> 00:30:02,275
0,150 150,255 255,345 345,555 555,885
you just want to take

1150
00:30:02,275 --> 00:30:04,945
0,365 1285,1665 1665,2045 2245,2520 2520,2670
two, two, two, sort of,

1151
00:30:04,945 --> 00:30:05,590
0,120 120,210 210,345 345,525 525,645
sort of log files that

1152
00:30:05,590 --> 00:30:06,955
0,75 75,590 700,960 960,1095 1095,1365
are adjacent| and then compact
|然后压缩它们，

1153
00:30:06,955 --> 00:30:08,170
0,305 475,840 840,1035 1035,1110 1110,1215
them, right,| so I would
|所以我取这两个，做一个排序合并，

1154
00:30:08,170 --> 00:30:09,570
0,150 150,345 345,510 510,770 1000,1400
take these two guys, basically

1155
00:30:09,620 --> 00:30:11,650
0,400 900,1175 1175,1340 1340,1805 1805,2030
do a sort merge,| well,
|它们已经排序了，

1156
00:30:11,650 --> 00:30:12,505
0,120 120,255 255,630 630,795 795,855
they're already sorted,| so now
|所以现在我只是做一次合并，

1157
00:30:12,505 --> 00:30:13,470
0,120 120,195 195,330 330,465 465,965
I'm just doing a merge|
|

1158
00:30:13,490 --> 00:30:16,360
0,275 275,455 455,695 695,1030
and figure out whether,
看看是否你查找的不同的键，

1159
00:30:16,400 --> 00:30:18,040
0,230 230,460 570,920 920,1270 1290,1640
you know, whether the different

1160
00:30:18,040 --> 00:30:19,060
0,240 240,450 450,585 585,780 780,1020
keys you're looking at,| whether
|是否一个包含另一个，

1161
00:30:19,060 --> 00:30:19,840
0,210 210,330 330,465 465,645 645,780
one is {subsumed -} by

1162
00:30:19,840 --> 00:30:21,450
0,290 670,975 975,1155 1155,1320 1320,1610
another,| assuming that this one
|假设这个比这个旧，

1163
00:30:21,620 --> 00:30:22,750
0,260 260,500 500,755 755,965 965,1130
I said this one's older

1164
00:30:22,750 --> 00:30:23,785
0,180 180,315 315,590 730,960 960,1035
than this one,| so if
|如果我看到更新或 PUT ，对于这里的 103 和那里的 103 ，

1165
00:30:23,785 --> 00:30:25,045
0,150 150,420 420,735 735,1020 1020,1260
I see an update or

1166
00:30:25,045 --> 00:30:26,755
0,305 595,995 1195,1470 1470,1590 1590,1710
PUT for key {103 -

1167
00:30:26,755 --> 00:30:27,385
0,165 165,330 330,435 435,525 525,630
-} here and a key

1168
00:30:27,385 --> 00:30:28,345
0,90 90,210 210,345 345,605 715,960
{103 - -} there,| then
|那么我知道我想要那个，

1169
00:30:28,345 --> 00:30:29,005
0,105 105,210 210,330 330,480 480,660
I know I want that

1170
00:30:29,005 --> 00:30:29,650
0,210 210,345 345,420 420,525 525,645
one| and I can throw
|我可以扔掉另一个。

1171
00:30:29,650 --> 00:30:30,980
0,90 90,180 180,315 315,590
the other one away,

1172
00:30:32,430 --> 00:30:33,755
0,400 780,1025 1025,1130 1130,1235 1235,1325
right.| And I can do
|我可以对这些日志文件的任何可能组合执行相同的操作，

1173
00:30:33,755 --> 00:30:34,930
0,120 120,300 300,540 540,825 825,1175
the same thing for any

1174
00:30:34,980 --> 00:30:37,265
0,400 990,1390 1500,1775 1775,1970 1970,2285
possible combination of these these

1175
00:30:37,265 --> 00:30:38,435
0,255 255,360 360,495 495,785 925,1170
sort of log files,| I
|我可以继续把它们编码成更紧凑的形式。

1176
00:30:38,435 --> 00:30:39,920
0,120 120,395 565,975 975,1170 1170,1485
can keep coding [] them

1177
00:30:39,920 --> 00:30:43,620
0,380 1900,2175 2175,2475 2475,2780
into more compact forms.|
|

1178
00:30:46,180 --> 00:30:47,250
0,350 350,620 620,815 815,965 965,1070
Another approach is do what
另一种方法是进行所谓的水平压缩，

1179
00:30:47,250 --> 00:30:49,095
0,120 120,255 255,480 480,920 1450,1845
it's called Level Compaction,| again,
|同样，这也是 LevelDB 的来源。

1180
00:30:49,095 --> 00:30:50,265
0,270 270,420 420,690 690,960 960,1170
this is what the Level

1181
00:30:50,265 --> 00:30:51,500
0,210 210,405 405,720 720,930 930,1235
and {LevelDB -} comes from.|
|

1182
00:30:53,590 --> 00:30:55,050
0,400 840,1115 1115,1250 1250,1355 1355,1460
Actually, who here has heard
实际上，在座的谁听说过 LevelDB ，

1183
00:30:55,050 --> 00:30:56,400
0,105 105,255 255,680
of {LevelDB -},|
|

1184
00:30:56,960 --> 00:30:57,880
0,275 275,440 440,590 590,725 725,920
very few here,| here has
这里没几个人，|谁听说过 RocksDB ，

1185
00:30:57,880 --> 00:30:59,300
0,165 165,270 270,450 450,890
heard of {RocksDB -},|
|

1186
00:30:59,930 --> 00:31:01,045
0,365 365,710 710,920 920,995 995,1115
more, okay, about not much
更多，好的，不会太多。

1187
00:31:01,045 --> 00:31:03,715
0,275 535,945 945,1335 1335,1685 2335,2670
more.| {RocksDB -} is, is
|RocksDB 是 Facebook 对 LevelDB 的 fork ，

1188
00:31:03,715 --> 00:31:05,590
0,585 585,930 930,1155 1155,1560 1560,1875
Facebook's fork {LevelDB -},| Google
|谷歌写了 LevelDB ， RocksDB fork 了它，

1189
00:31:05,590 --> 00:31:07,375
0,240 240,435 435,860 1150,1455 1455,1785
wrote {LevelDB -}, {RocksDB -}

1190
00:31:07,375 --> 00:31:08,755
0,300 300,545 805,1035 1035,1185 1185,1380
forked it,| the very first
|他们做的第一件事就是删除了 mmap ，

1191
00:31:08,755 --> 00:31:10,800
0,135 135,270 270,545 1315,1605 1605,2045
thing they did remove mmap,

1192
00:31:11,510 --> 00:31:13,435
0,400 1110,1370 1370,1490 1490,1700 1700,1925
right,| and then they expanded
|然后他们扩展了它，

1193
00:31:13,435 --> 00:31:14,140
0,120 120,225 225,435 435,630 630,705
it| and did did a
|做了一系列其他的事情，

1194
00:31:14,140 --> 00:31:14,830
0,90 90,180 180,300 300,510 510,690
bunch of other stuff,| and
|所以这个水平压缩来自 LevelDB 。

1195
00:31:14,830 --> 00:31:16,375
0,210 210,540 540,825 825,1245 1245,1545
so this Level Compaction comes

1196
00:31:16,375 --> 00:31:17,400
0,255 255,480 480,660 660,795 795,1025
from, from {LevelDB - -}.|
|

1197
00:31:18,260 --> 00:31:18,985
0,290 290,395 395,455 455,575 575,725
{All,right}, so you have your
好的，所以你有文件在磁盘上，

1198
00:31:18,985 --> 00:31:19,950
0,120 120,225 225,360 360,495 495,965
sort of file in disk|
|

1199
00:31:20,990 --> 00:31:22,405
0,380 380,665 665,920 920,1190 1190,1415
and at level zero, they're
在零级，它们将是一定的大小，

1200
00:31:22,405 --> 00:31:22,885
0,45 45,105 105,165 165,270 270,480
going to be a certain

1201
00:31:22,885 --> 00:31:24,475
0,335 775,1050 1050,1200 1200,1365 1365,1590
size| and you keep adding
|你一直在添加更多的文件，

1202
00:31:24,475 --> 00:31:25,590
0,255 255,540 540,750 750,855 855,1115
more sort, sort of files|
|

1203
00:31:25,790 --> 00:31:26,860
0,290 290,485 485,725 725,920 920,1070
until some point you run
直到某一点，你运行压缩，

1204
00:31:26,860 --> 00:31:28,735
0,380 910,1170 1170,1305 1305,1560 1560,1875
compaction| and then you'll combine
|然后你将它们组合成一个更大的文件，在下一个级别，

1205
00:31:28,735 --> 00:31:30,730
0,180 180,405 405,755 1525,1785 1785,1995
them down into a larger

1206
00:31:30,730 --> 00:31:31,920
0,350 400,660 660,765 765,900 900,1190
file at the next level,

1207
00:31:32,680 --> 00:31:34,390
0,350 700,1035 1035,1305 1305,1515 1515,1710
right,| make, make, keep, make
|在顶层制造更多的它们，

1208
00:31:34,390 --> 00:31:34,975
0,180 180,285 285,360 360,450 450,585
more of them at the

1209
00:31:34,975 --> 00:31:36,190
0,180 180,485 715,960 960,1065 1065,1215
top level| and at some
|并在某个时候合并在一起，

1210
00:31:36,190 --> 00:31:37,270
0,195 195,465 465,585 585,870 870,1080
point that get merged together,|
|

1211
00:31:37,270 --> 00:31:38,230
0,180 180,315 315,450 450,645 645,960
and once I have enough
一旦我在下一级足够多，

1212
00:31:38,230 --> 00:31:39,700
0,300 300,480 480,660 660,980 1210,1470
at the next level,| then
|然后我会对那个进行压缩，

1213
00:31:39,700 --> 00:31:41,200
0,180 180,315 315,740 820,1215 1215,1500
I'll run compaction for that

1214
00:31:41,200 --> 00:31:41,905
0,135 135,255 255,405 405,570 570,705
one| and produce something at
|并在较低的级别产生一些东西，

1215
00:31:41,905 --> 00:31:42,865
0,90 90,225 225,515 565,840 840,960
the lower level,| so sort
|所以在某种程度上是层级式下降的，

1216
00:31:42,865 --> 00:31:43,930
0,105 105,540 540,750 750,930 930,1065
of cascading down,| I'm getting
|随着我的下降，文件越来越大。

1217
00:31:43,930 --> 00:31:45,685
0,225 225,375 375,570 570,920 1360,1755
larger and larger files as

1218
00:31:45,685 --> 00:31:46,900
0,255 255,390 390,665
I go down.|
|

1219
00:31:51,140 --> 00:31:52,440
0,400 570,800 800,875 875,1010 1010,1300
{All,right}, so as I said,|
所以正如我所说的，|

1220
00:31:53,180 --> 00:31:54,460
0,320 320,560 740,890 890,1115 1115,1280
because {RocksDB -} has sort
因为 RocksDB 已经成为许多数据库供应商的默认选择，

1221
00:31:54,460 --> 00:31:55,750
0,135 135,375 375,645 645,945 945,1290
of become the default choice

1222
00:31:55,750 --> 00:31:56,850
0,285 285,480 480,660 660,825 825,1100
for a lot of database

1223
00:31:57,080 --> 00:31:58,720
0,470 470,760 930,1235 1235,1445 1445,1640
vendors,| database, people building database
|人们构建数据库系统，

1224
00:31:58,720 --> 00:32:01,270
0,290 580,840 840,1100 1120,1520 2260,2550
systems,| as like the, like
|作为要使用的底层存储管理器，

1225
00:32:01,270 --> 00:32:02,305
0,135 135,270 270,420 420,680 730,1035
of like the underlying storage

1226
00:32:02,305 --> 00:32:04,300
0,270 270,615 615,855 855,1115
manager to, to use,|
|

1227
00:32:04,340 --> 00:32:07,540
0,400 1770,2120 2120,2380 2430,2750 2750,3200
{} they're essentially {log-structured -},|
它们本质上是日志结构的，|

1228
00:32:07,540 --> 00:32:08,545
0,195 195,375 375,600 600,810 810,1005
but then what they're building
但他们在 RocksDB 上构建的是，

1229
00:32:08,545 --> 00:32:09,475
0,180 180,255 255,390 390,720 720,930
top of {RocksDB -} is|
|

1230
00:32:09,475 --> 00:32:10,750
0,210 210,420 420,720 720,1050 1050,1275
all the SQL parsing layer,
所有的 SQL 解析层， SQL 执行，索引，

1231
00:32:10,750 --> 00:32:12,925
0,350 460,900 900,1220 1510,1815 1815,2175
the SQL execution, the indexes,|
|

1232
00:32:12,925 --> 00:32:13,885
0,165 165,360 360,585 585,780 780,960
all the additional things we'll
所有我们将在整个学期讨论的其他内容。

1233
00:32:13,885 --> 00:32:14,760
0,75 75,225 225,405 405,555 555,875
talk about throughout the semester.|
|

1234
00:32:15,450 --> 00:32:16,610
0,260 260,455 455,695 860,965 965,1160
And like {RocksDB -} is
RocksDB 本质上只提供键值 API ，

1235
00:32:16,610 --> 00:32:18,965
0,240 240,435 1540,1890 1890,2145 2145,2355
essentially just providing a key

1236
00:32:18,965 --> 00:32:21,320
0,285 720,965 1705,1980 1980,2100 2100,2355
value API,| like you don't,|
|你不需要，|

1237
00:32:21,320 --> 00:32:22,560
0,225 225,560
in, in,
在我的例子中，

1238
00:32:22,780 --> 00:32:24,090
0,275 275,470 470,755 755,1085 1085,1310
in my examples here,| I
|我只说这是值，

1239
00:32:24,090 --> 00:32:24,920
0,120 120,255 255,480 480,570 570,830
just said here's the value,|
|

1240
00:32:24,940 --> 00:32:25,830
0,290 290,380 380,635 635,770 770,890
here's the payload I'm putting
这是我要存储在日志中的有效负载，

1241
00:32:25,830 --> 00:32:27,165
0,195 195,500 670,990 990,1170 1170,1335
out to storing in, in

1242
00:32:27,165 --> 00:32:28,890
0,195 195,375 375,480 480,725 1465,1725
the, in the log,| it
|它没有属性或列的概念，

1243
00:32:28,890 --> 00:32:30,195
0,180 180,420 420,690 690,1005 1005,1305
has no notion of attributes

1244
00:32:30,195 --> 00:32:31,950
0,150 150,605 1165,1470 1470,1620 1620,1755
or columns, right,| so even
|即使我说我的表中有 10 列，

1245
00:32:31,950 --> 00:32:33,075
0,195 195,435 435,690 690,915 915,1125
though I say I ten

1246
00:32:33,075 --> 00:32:34,050
0,315 315,405 405,525 525,780 780,975
columns in my table,| but
|但我只更新了其中的一列，

1247
00:32:34,050 --> 00:32:34,755
0,75 75,240 240,435 435,585 585,705
I only update one of

1248
00:32:34,755 --> 00:32:36,030
0,245 385,690 690,870 870,1080 1080,1275
them,| my PUT record has
|我的 PUT 记录必须包含所有 10 列。

1249
00:32:36,030 --> 00:32:37,880
0,180 180,465 465,830 1090,1380 1380,1850
to contain all ten columns.|
|

1250
00:32:39,060 --> 00:32:40,480
0,335 335,470 470,695 695,1145 1145,1420
We'll see multi versioning how
我们将在期中考试后看到多版本控制，

1251
00:32:41,430 --> 00:32:42,440
0,260 260,350 350,410 410,695 695,1010
later in the semester after

1252
00:32:42,440 --> 00:32:43,355
0,165 165,525 525,735 735,810 810,915
the midterm,| we can be
|我们可以更聪明地使用它，

1253
00:32:43,355 --> 00:32:44,795
0,195 195,345 345,605 865,1155 1155,1440
smarter with this,| which essentially
|它看起来很像日志结构存储，

1254
00:32:44,795 --> 00:32:46,340
0,300 300,480 480,720 720,1085 1255,1545
looks a lot like {log-structure

1255
00:32:46,340 --> 00:32:47,975
0,255 255,620 910,1245 1245,1425 1425,1635
-} storage,| but for now
|但现在我们可以忽略它。

1256
00:32:47,975 --> 00:32:49,460
0,210 210,345 345,525 525,815
we can ignore that.|
|

1257
00:32:50,090 --> 00:32:51,340
0,260 260,470 470,665 665,800 800,1250
This is almost how Postgres,|
这几乎就是 Postgres ，|

1258
00:32:51,340 --> 00:32:52,825
0,210 210,330 330,590 760,1260 1260,1485
this is how Postres was
这就是 Postgres 在 1980 年代最初设想的，

1259
00:32:52,825 --> 00:32:53,920
0,180 180,660 660,855 855,945 945,1095
originally envisioned in the {1980s

1260
00:32:53,920 --> 00:32:57,070
0,440 2050,2450 2710,2970 2970,3060 3060,3150
-},| it looked a lot
|它看起来很像这样。

1261
00:32:57,070 --> 00:32:58,200
0,135 135,410
like this.|
|

1262
00:32:58,200 --> 00:32:59,280
0,195 195,315 315,480 480,705 705,1080
So they said {RocksDB -}
所以他们说 RocksDB 是非常流行的，

1263
00:32:59,280 --> 00:33:01,130
0,270 270,510 510,720 720,1040 1450,1850
is is super popular, {}|
|

1264
00:33:01,630 --> 00:33:02,775
0,305 305,670 720,950 950,1085 1085,1145
{LevelDB -} and it's a
LevelDB ，它是 LevelDB 的 fork ，

1265
00:33:02,775 --> 00:33:03,960
0,180 180,315 315,695 805,1065 1065,1185
{fork,of} {LevelDB -}| and this
|这只是部分不同公司，

1266
00:33:03,960 --> 00:33:05,000
0,120 120,240 240,405 405,780 780,1040
is just a sampling of

1267
00:33:05,200 --> 00:33:06,225
0,260 260,425 425,710 710,920 920,1025
of different companies,| that are
|使用了日志结构存储，

1268
00:33:06,225 --> 00:33:09,075
0,275 1975,2295 2295,2460 2460,2625 2625,2850
using using a {log-structure -}

1269
00:33:09,075 --> 00:33:10,065
0,335 415,675 675,780 780,870 870,990
storage,| again, some are based
|有些是以 RocksDB 为基础的，

1270
00:33:10,065 --> 00:33:11,775
0,135 135,300 300,695 1015,1485 1485,1710
on {RocksDB -},| {CockroachDB -}
|CockroachDB 最初是使用 RocksDB ，

1271
00:33:11,775 --> 00:33:12,765
0,225 225,450 450,585 585,765 765,990
originally started off using {RocksDB

1272
00:33:12,765 --> 00:33:13,950
0,425 445,735 735,870 870,990 990,1185
-},| they threw it away
|他们把它扔掉，使用 Go 写了自己的东西，叫做 Pebble ，

1273
00:33:13,950 --> 00:33:14,670
0,165 165,285 285,405 405,555 555,720
and wrote their own thing

1274
00:33:14,670 --> 00:33:16,620
0,150 150,375 375,615 615,1040 1360,1950
in Go called Pebble,| Cassandra
|Cassandra 有自己的日志结构存储，

1275
00:33:16,620 --> 00:33:18,405
0,135 135,255 255,500 1300,1575 1575,1785
has their own {log-structure -}

1276
00:33:18,405 --> 00:33:21,825
0,335 745,1320 1320,1455 1455,1890 3175,3420
storage,| {TiDB -} {has,TiKV -},|
|TiDB 有 TiKV ，|

1277
00:33:21,825 --> 00:33:22,830
0,120 120,285 285,465 465,660 660,1005
{I,think} {Dgraph -} uses {BadgerDB
我想 Dgraph 使用 BadgerDB ，

1278
00:33:22,830 --> 00:33:23,805
0,300 300,540 540,690 690,840 840,975
-},| but a bunch of
|但是很多这些都使用日志结构系统。

1279
00:33:23,805 --> 00:33:25,995
0,195 195,545 685,1085 1765,2040 2040,2190
these [in], these these {log-structure

1280
00:33:25,995 --> 00:33:27,160
0,210 210,545
-} systems.|
|

1281
00:33:28,280 --> 00:33:29,050
0,245 245,350 350,500 500,650 650,770
So we already said the
我们已经说过读取速度较慢，

1282
00:33:29,050 --> 00:33:30,475
0,195 195,315 315,650 1090,1335 1335,1425
reads are slower,| but what
|但是还有哪些其他问题，

1283
00:33:30,475 --> 00:33:31,525
0,90 90,165 165,300 300,605 805,1050
are some other problems,| we
|我们使用日志结构存储，

1284
00:33:31,525 --> 00:33:33,280
0,105 105,315 315,665 1345,1620 1620,1755
would have with {log-structure -}

1285
00:33:33,280 --> 00:33:34,015
0,105 105,255 255,420 420,570 570,735
{} storage,| we said read
|我们说过读取速度较慢，压缩昂贵，

1286
00:33:34,015 --> 00:33:34,960
0,135 135,345 345,510 510,600 600,945
was slower and the compactionum

1287
00:33:34,960 --> 00:33:36,960
0,150 150,470 880,1545 1545,1695 1695,2000
is expensive,| there's one more
|这种方法还有一个核心问题。

1288
00:33:37,760 --> 00:33:39,000
0,305 305,560 560,770 770,935 935,1240
core issue with this approach.|
|

1289
00:33:40,150 --> 00:33:42,090
0,400 630,890 890,1055 1055,1360 1530,1940
Yes.| it seems less disk
是的。|它的磁盘效率似乎较低。

1290
00:33:42,090 --> 00:33:43,470
0,320 970,1200 1200,1245 1245,1290 1290,1380
efficient.| What do you mean,
|你说的磁盘效率是什么意思？

1291
00:33:43,470 --> 00:33:43,920
0,75 75,120 120,180 180,315 315,450
what do you mean, what

1292
00:33:43,920 --> 00:33:44,660
0,45 45,90 90,195 195,465 465,740
do you mean disk efficient?|
|

1293
00:33:44,920 --> 00:33:45,765
0,260 260,365 365,455 455,590 590,845
Like you have to store
比如你必须存储每个 tuple 的额外副本，

1294
00:33:45,765 --> 00:33:47,130
0,365 415,885 885,990 990,1170 1170,1365
extra copies of every {tuple

1295
00:33:47,130 --> 00:33:49,260
0,260 460,780 780,990 990,1280 1630,2130
-}| and when you compact,
|当你压缩时，你必须新建，

1296
00:33:49,260 --> 00:33:50,580
0,165 165,255 255,420 420,740
you have to create,|
|

1297
00:33:50,580 --> 00:33:51,195
0,195 195,285 285,360 360,450 450,615
like you have to use
你必须使用磁盘的其他部分，所以。

1298
00:33:51,195 --> 00:33:52,940
0,225 225,420 420,555 555,1025 1345,1745
other parts of disk, so.|
|

1299
00:33:54,430 --> 00:33:55,350
0,215 215,290 290,455 455,650 650,920
So the statement is that,|
所以他的说法是，|

1300
00:33:55,350 --> 00:33:57,945
0,380 1180,1650 1650,1905 1905,2385 2385,2595
{} it's less deficient,| because
它的效率不高，|因为你必须存储一个 tuple 的多个副本，

1301
00:33:57,945 --> 00:33:59,355
0,165 165,315 315,495 495,785 985,1410
you have to store, [pitching]

1302
00:33:59,355 --> 00:34:00,645
0,210 210,695 715,1035 1035,1200 1200,1290
multiple copies of, of a

1303
00:34:00,645 --> 00:34:01,410
0,165 165,345 345,540 540,660 660,765
tuple,| because there's a bunch
|因为有一堆 PUT ，

1304
00:34:01,410 --> 00:34:02,820
0,120 120,270 270,420 420,680 1150,1410
of PUT for them,| and
|然后当你进行压缩时，

1305
00:34:02,820 --> 00:34:03,620
0,105 105,195 195,285 285,390 390,800
then when you do compaction,|
|

1306
00:34:03,820 --> 00:34:04,590
0,260 260,455 455,635 635,710 710,770
you basically have to have
你必须有一个临时区域，

1307
00:34:04,590 --> 00:34:06,135
0,120 120,435 435,680 1210,1455 1455,1545
a staging area,| more or
|或多或少你有两个原始文件，

1308
00:34:06,135 --> 00:34:07,485
0,135 135,285 285,510 510,875 1045,1350
less where you you have

1309
00:34:07,485 --> 00:34:08,700
0,180 180,300 300,480 480,815 895,1215
the two original files,| you're
|你试图压缩两个或更多，

1310
00:34:08,700 --> 00:34:09,765
0,60 60,135 135,500 760,990 990,1065
trying to compact two or

1311
00:34:09,765 --> 00:34:10,845
0,245 445,705 705,810 810,945 945,1080
more,| and then you're writing
|然后你写出一个新的，是的。

1312
00:34:10,845 --> 00:34:12,470
0,285 285,525 525,630 630,875 1225,1625
out a new one, yes.|
|

1313
00:34:14,450 --> 00:34:15,580
0,245 245,490 510,830 980,1055 1055,1130
We say yes, that's an
我们说是，这是一个问题，是的。

1314
00:34:15,580 --> 00:34:18,620
0,135 135,440
issue, yes.|
|

1315
00:34:18,930 --> 00:34:20,900
0,275 275,455 455,695 695,1030
But what about the,
但是与这个压缩相关，我在做什么，

1316
00:34:21,090 --> 00:34:21,695
0,260 260,350 350,425 425,515 515,605
related to this point of

1317
00:34:21,695 --> 00:34:22,780
0,360 360,585 585,675 675,795 795,1085
compaction, what am I doing,|
|

1318
00:34:23,160 --> 00:34:25,060
0,400 840,1145 1145,1340 1340,1565 1565,1900
well, at some point earlier,|
在早些时候的某个时候，|

1319
00:34:25,170 --> 00:34:26,900
0,400 660,980 980,1220 1220,1460 1460,1730
I had these log records
我在内存中保存了这些日志记录，

1320
00:34:26,900 --> 00:34:28,370
0,210 210,470 940,1200 1200,1335 1335,1470
in memory,| I wrote out
|我写出到磁盘中，

1321
00:34:28,370 --> 00:34:30,035
0,120 120,590 910,1200 1200,1335 1335,1665
the disk,| now for compaction,
|现在对于压缩，我在做什么。

1322
00:34:30,035 --> 00:34:31,460
0,180 180,255 255,345 345,605
what am I doing?|
|

1323
00:34:31,910 --> 00:34:33,090
0,320 320,500 500,665 665,875 875,1180
Reading it back into memory,
将其读回内存，再写回磁盘。

1324
00:34:33,770 --> 00:34:35,520
0,400 690,965 965,1115 1115,1250 1250,1750
writing back out the disk.|
|

1325
00:34:36,730 --> 00:34:37,470
0,245 245,320 320,395 395,545 545,740
So this is called {Write-Amplification
所以，这称为写入放大。

1326
00:34:37,470 --> 00:34:39,080
0,500
-}.|
|

1327
00:34:39,200 --> 00:34:40,260
0,245 245,410 410,605 605,770 770,1060
And the idea is that,
这里的问题是，

1328
00:34:40,550 --> 00:34:41,830
0,260 260,425 425,590 590,850 1050,1280
the issue is that,| for
|对于每一种逻辑写入，我的应用程序所做的，

1329
00:34:41,830 --> 00:34:43,315
0,230 400,645 645,780 780,1305 1305,1485
every sort of logical write,

1330
00:34:43,315 --> 00:34:44,920
0,165 165,270 270,480 480,845 1075,1605
I do my application,| insert
|插入一个 tuple ，更新一个 tuple ，

1331
00:34:44,920 --> 00:34:45,970
0,120 120,525 525,765 765,870 870,1050
a tuple, update a single

1332
00:34:45,970 --> 00:34:47,800
0,470 880,1170 1170,1380 1380,1650 1650,1830
tuple,| how many times am
|我要读取和写回磁盘多少次，

1333
00:34:47,800 --> 00:34:48,325
0,90 90,195 195,285 285,405 405,525
I going to read and

1334
00:34:48,325 --> 00:34:49,380
0,120 120,270 270,435 435,585 585,1055
write it back to disk,|
|

1335
00:34:50,670 --> 00:34:52,295
0,400 420,785 785,1100 1100,1370 1370,1625
and in a {log-structure -}
以一种日志结构方法，可能是无限的，

1336
00:34:52,295 --> 00:34:53,540
0,335
approach,

1337
00:34:54,150 --> 00:34:56,280
0,400 690,1330
potentially infinite,

1338
00:34:56,670 --> 00:34:57,500
0,275 275,380 380,485 485,650 650,830
right,| If I just keep
|如果我继续压缩，一遍又一遍地压缩，

1339
00:34:57,500 --> 00:34:58,640
0,450 450,810 810,930 930,1005 1005,1140
compacting, compacting over and over

1340
00:34:58,640 --> 00:35:00,770
0,320 1150,1455 1455,1620 1620,1875 1875,2130
again,| obviously that doesn't, doesn't
|显然这不会发生，

1341
00:35:00,770 --> 00:35:04,000
0,260 490,890
happen,| but,
|但是，我可能会做，

1342
00:35:04,100 --> 00:35:05,785
0,395 395,695 695,995 995,1390 1440,1685
I could potentially do,| for
|对于一个逻辑写入，我可能会做几十次物理写入，

1343
00:35:05,785 --> 00:35:06,955
0,150 150,360 360,765 765,960 960,1170
a single logical write, I

1344
00:35:06,955 --> 00:35:08,160
0,135 135,395
could do

1345
00:35:08,170 --> 00:35:11,325
0,610 990,1390 1950,2315 2315,2680 2910,3155
dozens of physical writes,| because
|因为我要带回到内存，然后把它写回出去。

1346
00:35:11,325 --> 00:35:12,030
0,150 150,300 300,480 480,585 585,705
I'm bringing back a memory

1347
00:35:12,030 --> 00:35:12,860
0,135 135,270 270,405 405,540 540,830
and writing it back out.|
|

1348
00:35:14,560 --> 00:35:16,580
0,290 290,580 960,1250 1250,1540 1620,2020
And in the page architecture
在使用插槽页面的页面架构中，

1349
00:35:16,720 --> 00:35:18,105
0,275 275,530 530,790 930,1175 1175,1385
with slotted pages,| we don't
|我们没有这个问题，

1350
00:35:18,105 --> 00:35:19,600
0,135 135,300 300,575
have this problem,|
|

1351
00:35:19,640 --> 00:35:20,575
0,245 245,335 335,580 600,845 845,935
when I do update a
当我更新一个单独的 tuple 时，

1352
00:35:20,575 --> 00:35:22,050
0,180 180,390 390,665 895,1185 1185,1475
single {tuple -},| I bring
|我会引入内存，更新它，然后写回它，

1353
00:35:22,310 --> 00:35:23,875
0,230 230,305 305,550 1020,1355 1355,1565
in a memory, I update

1354
00:35:23,875 --> 00:35:24,730
0,240 240,480 480,615 615,720 720,855
it, I write it back

1355
00:35:24,730 --> 00:35:26,180
0,290
out,|
|

1356
00:35:26,290 --> 00:35:27,090
0,260 260,380 380,485 485,590 590,800
and then if I never
如果我不再更新它，也不再把它写出去，

1357
00:35:27,090 --> 00:35:28,185
0,210 210,345 345,600 600,885 885,1095
update it again, I never

1358
00:35:28,185 --> 00:35:29,740
0,165 165,285 285,465 465,785
write it out again,|
|

1359
00:35:30,030 --> 00:35:31,715
0,350 350,590 590,995 995,1330 1440,1685
we ignore backup, we ignore
我们忽略了备份，我们忽略了预先日志，

1360
00:35:31,715 --> 00:35:32,615
0,90 90,210 210,360 360,630 630,900
the write ahead log,| we'll
|我们将在本学期晚些时候讨论这个问题，

1361
00:35:32,615 --> 00:35:33,500
0,45 45,120 120,365 535,795 795,885
get to that later in

1362
00:35:33,500 --> 00:35:35,580
0,60 60,320 760,1160
the semester,| but
|但是，如果我没有读取，我没有使用它，

1363
00:35:35,580 --> 00:35:36,285
0,165 165,255 255,465 465,570 570,705
if I don't, if I'm

1364
00:35:36,285 --> 00:35:37,245
0,195 195,480 480,600 600,795 795,960
not, I'm not reading, I'm

1365
00:35:37,245 --> 00:35:38,190
0,105 105,330 330,600 600,840 840,945
not using it,| I'm not
|我不会把它带入内存再带回，

1366
00:35:38,190 --> 00:35:39,945
0,180 180,315 315,560 1180,1530 1530,1755
bringing the memory and and

1367
00:35:39,945 --> 00:35:40,680
0,165 165,330 330,495 495,630 630,735
writing back out,| in a
|在日志结构存储中，你必须这样做。

1368
00:35:40,680 --> 00:35:41,550
0,165 165,390 390,600 600,735 735,870
{log-structure -} storage, you have

1369
00:35:41,550 --> 00:35:43,100
0,290
to.|
|

1370
00:35:43,200 --> 00:35:44,340
0,400
Okay?|
好的？|

1371
00:35:45,710 --> 00:35:46,450
0,260 260,410 410,545 545,635 635,740
So again, if you want
所以，如果你想超越这一点，

1372
00:35:46,450 --> 00:35:47,635
0,90 90,240 240,480 480,795 795,1185
to go beyond this,| there's
|教科书中的日志结构合并树部分，

1373
00:35:47,635 --> 00:35:49,015
0,150 150,330 330,525 525,815 1075,1380
the log structure {merge,tree} part

1374
00:35:49,015 --> 00:35:49,960
0,180 180,300 300,630 630,810 810,945
of the textbook,| I think
|我认为这有点过于复杂，

1375
00:35:49,960 --> 00:35:52,180
0,135 135,225 225,500 1630,1920 1920,2220
it's a bit, it's overly

1376
00:35:52,180 --> 00:35:53,755
0,260 820,1080 1080,1230 1230,1365 1365,1575
complicated,| because it's really about
|因为它实际上是，

1377
00:35:53,755 --> 00:35:55,510
0,305 925,1185 1185,1275 1275,1410 1410,1755
like,| how do you merge
|如何合并这些树为基础的，

1378
00:35:55,510 --> 00:35:57,040
0,210 210,560 580,980 1060,1365 1365,1530
these trees based,| it almost
|它看起来像是水平压缩，

1379
00:35:57,040 --> 00:35:57,870
0,120 120,225 225,315 315,450 450,830
looks like the level compaction,|
|

1380
00:35:58,100 --> 00:35:59,140
0,245 245,410 410,680 680,905 905,1040
but I understand that the
但我理解的是低级别的数据结构，

1381
00:35:59,140 --> 00:35:59,905
0,150 150,330 330,510 510,660 660,765
like the low level of

1382
00:35:59,905 --> 00:36:01,360
0,165 165,485 895,1170 1170,1335 1335,1455
data structure,| the key thing
|我想让你们明白的关键一点是，

1383
00:36:01,360 --> 00:36:01,915
0,120 120,255 255,345 345,420 420,555
I I want you to

1384
00:36:01,915 --> 00:36:02,725
0,165 165,270 270,435 435,675 675,810
understand is like,| here's a
|这是一种不同的存储 tuple 的方法，

1385
00:36:02,725 --> 00:36:05,400
0,305 355,755 1045,1320 1320,1625 2125,2675
different approach to storing tuples,|
|

1386
00:36:06,180 --> 00:36:07,910
0,320 320,640 870,1160 1160,1450 1470,1730
through these log records,| and
通过这些日志记录，|我们会看到这个想法再次出现，

1387
00:36:07,910 --> 00:36:09,215
0,195 195,360 360,630 630,1010 1030,1305
we'll see this idea pop

1388
00:36:09,215 --> 00:36:10,520
0,195 195,515 805,1065 1065,1185 1185,1305
up again,| when we talk
|当我们讨论多版本控制，

1389
00:36:10,520 --> 00:36:12,095
0,135 135,345 345,680 760,1160 1300,1575
about multi version control| and
|当我们讨论分布式事务、分布式数据库时。

1390
00:36:12,095 --> 00:36:13,430
0,135 135,255 255,450 450,785 1015,1335
when we talk about distributed

1391
00:36:13,430 --> 00:36:16,040
0,320 490,795 795,1400
transactions, distributed databases.|
|

1392
00:36:19,350 --> 00:36:20,225
0,260 260,410 410,575 575,725 725,875
This question is,| why is
这个问题是，|为什么水平压缩比普遍压实更受欢迎，

1393
00:36:20,225 --> 00:36:21,560
0,180 180,575 625,900 900,1110 1110,1335
level compaction preferred over universal

1394
00:36:21,560 --> 00:36:22,850
0,350 550,810 810,990 990,1140 1140,1290
compaction,| I don't know, I
|我不知道是不是真的，

1395
00:36:22,850 --> 00:36:23,555
0,150 150,195 195,315 315,495 495,705
don't know if, if it

1396
00:36:23,555 --> 00:36:26,105
0,180 180,425 1885,2130 2130,2370 2370,2550
actually is,| I don't, I
|我不认为这有什么不同，

1397
00:36:26,105 --> 00:36:26,585
0,135 135,195 195,270 270,375 375,480
don't think it makes a

1398
00:36:26,585 --> 00:36:28,205
0,180 180,360 360,605 1045,1350 1350,1620
difference,| and I actually, yeah,
|事实上，是的，我不知道它们之间的权衡是什么，

1399
00:36:28,205 --> 00:36:28,910
0,225 225,345 345,495 495,585 585,705
and I don't know what

1400
00:36:28,910 --> 00:36:30,185
0,135 135,420 420,570 570,890 970,1275
the tradeoffs are between the

1401
00:36:30,185 --> 00:36:32,080
0,150 150,255 255,515
two of them,|
|

1402
00:36:33,000 --> 00:36:34,090
0,335 335,530 620,695 695,815 815,1090
other than it's like a,|
除了它像是，|

1403
00:36:36,170 --> 00:36:37,120
0,335 335,545 545,755 755,875 875,950
I think it sort of
我想它是一种更干净的架构，

1404
00:36:37,120 --> 00:36:38,380
0,75 75,270 270,690 690,980 1000,1260
like a cleaner architecture in

1405
00:36:38,380 --> 00:36:39,680
0,150 150,285 285,530
terms of like,|
|

1406
00:36:40,040 --> 00:36:40,855
0,260 260,350 350,425 425,575 575,815
I know at this level
我知道在这个级别，我将压缩，

1407
00:36:40,855 --> 00:36:41,725
0,225 225,285 285,360 360,645 645,870
I'm going to compact| and
|它将达到这个尺寸，并进入下一级别，

1408
00:36:41,725 --> 00:36:42,160
0,135 135,195 195,255 255,330 330,435
it's going to go to

1409
00:36:42,160 --> 00:36:42,775
0,150 150,345 345,480 480,540 540,615
this size and go to

1410
00:36:42,775 --> 00:36:44,230
0,90 90,225 225,515 775,1155 1155,1455
the next level,| whereas in
|然而，在普遍模式中，

1411
00:36:44,230 --> 00:36:45,745
0,225 225,465 465,800 1180,1425 1425,1515
the universal pattern,| you have
|你必须有一些额外的逻辑方面，

1412
00:36:45,745 --> 00:36:46,500
0,60 60,135 135,255 255,435 435,755
to have some additional logic

1413
00:36:46,520 --> 00:36:47,800
0,380 380,740 740,980 980,1115 1115,1280
side,| okay, if I could
|如果我可以合并这个和这个，

1414
00:36:47,800 --> 00:36:48,685
0,240 240,390 390,585 585,750 750,885
merge this guy and this

1415
00:36:48,685 --> 00:36:49,405
0,180 180,360 360,510 510,630 630,720
guy| or this guy and
|或者这个和这个，

1416
00:36:49,405 --> 00:36:50,155
0,120 120,300 300,480 480,630 630,750
this guy,| which one should
|我应该做哪一个，

1417
00:36:50,155 --> 00:36:51,360
0,120 120,395
I do,|
|

1418
00:36:51,710 --> 00:36:52,675
0,245 245,410 410,620 620,755 755,965
but I I I don't
但是我不认为，

1419
00:36:52,675 --> 00:36:55,540
0,275 985,1385 1555,1955 1975,2550 2550,2865
think,| the the RocksDB manual
|RocksDB 手册中有很多关于[]的信息，

1420
00:36:55,540 --> 00:36:56,160
0,90 90,180 180,285 285,390 390,620
has a lot of good

1421
00:36:56,180 --> 00:36:57,300
0,275 275,470 470,635 635,755 755,1120
information on the {[] -},|
|

1422
00:36:57,380 --> 00:36:58,270
0,260 260,365 365,470 470,590 590,890
I can post on Piazza
如果你想看的话，我可以在之后贴在 Piazza 上。

1423
00:36:58,270 --> 00:37:00,900
0,75 75,165 165,300 300,590
if you want afterwards.|
|

1424
00:37:00,910 --> 00:37:04,940
0,400 780,1180 2070,2300 2300,2530 3630,4030
Yes.| { - - -}
是的。|

1425
00:37:06,370 --> 00:37:09,740
0,275 275,440 440,730 1800,2200 2970,3370

1426
00:37:10,060 --> 00:37:10,830
0,290 290,395 395,470 470,605 605,770
Yeah, so his question is,|
所以他的问题是，|

1427
00:37:10,830 --> 00:37:11,325
0,135 135,210 210,285 285,375 375,495
what do I mean by
我所说的压缩期是什么意思，

1428
00:37:11,325 --> 00:37:14,025
0,150 150,285 285,665 955,1355 2455,2700
period that compaction,| {} you
|你会有某种触发阈值，

1429
00:37:14,025 --> 00:37:14,910
0,105 105,315 315,540 540,675 675,885
would have some kind of

1430
00:37:14,910 --> 00:37:16,860
0,500 850,1335 1335,1515 1515,1755 1755,1950
trigger threshold| or something that
|或者是说是时候压缩了，

1431
00:37:16,860 --> 00:37:17,960
0,180 180,450 450,600 600,735 735,1100
says it's time to compact,

1432
00:37:18,370 --> 00:37:19,665
0,260 260,380 380,515 515,790 1050,1295
right,| it could be, if
|如果是水平压缩，它可能是，

1433
00:37:19,665 --> 00:37:20,535
0,135 135,195 195,330 330,690 690,870
it's a level compaction, it

1434
00:37:20,535 --> 00:37:22,275
0,90 90,335 355,645 645,1115 1375,1740
could be,| okay, I've, I've
|我有三个这样的，运行压缩，

1435
00:37:22,275 --> 00:37:24,380
0,245 1345,1590 1590,1680 1680,1815 1815,2105
got three of these guys

1436
00:37:24,670 --> 00:37:25,610
0,275 275,380 380,470 470,605 605,940
go ahead and run compaction,

1437
00:37:25,840 --> 00:37:27,045
0,400 660,890 890,950 950,1040 1040,1205
right,| or it could be
|也可能是我做了这么多写入，开始压缩。

1438
00:37:27,045 --> 00:37:27,855
0,225 225,345 345,510 510,675 675,810
I've done this many of

1439
00:37:27,855 --> 00:37:28,790
0,165 165,360 360,480 480,585 585,935
writes, go ahead and compact.|
|

1440
00:37:29,660 --> 00:37:31,315
0,245 245,350 350,610 810,1210 1410,1655
And this is so it
这就是说，它可以在任何时候完成，

1441
00:37:31,315 --> 00:37:32,640
0,105 105,210 210,435 435,815 925,1325
can be done basically whenever,|
|

1442
00:37:33,460 --> 00:37:34,395
0,275 275,470 470,650 650,785 785,935
does not, doesn't it have
它不需要由读取触发吗？

1443
00:37:34,395 --> 00:37:35,160
0,120 120,240 240,495 495,615 615,765
to be triggered by a

1444
00:37:35,160 --> 00:37:35,940
0,290
read?|
|

1445
00:37:35,940 --> 00:37:37,440
0,210 210,470 910,1170 1170,1395 1395,1500
Correct, it, it doesn't have
对的，它不需要要由读取触发，

1446
00:37:37,440 --> 00:37:38,910
0,90 90,165 165,345 345,590 1150,1470
to be triggered {by,read},| whenever,
|任何时候，是的。

1447
00:37:38,910 --> 00:37:40,760
0,320 550,950 1240,1485 1485,1620 1620,1850
Yes, yeah.| But it's like,
|但这就像是，这是怎么做的。

1448
00:37:42,070 --> 00:37:44,380
0,215 215,305 305,580
how do this.|
|

1449
00:37:45,160 --> 00:37:46,220
0,400

1450
00:37:46,290 --> 00:37:48,695
0,290 290,515 515,740 740,970 2130,2405
It's like, you know, you
这就像，你需要给你的车换机油，

1451
00:37:48,695 --> 00:37:49,310
0,135 135,255 255,390 390,495 495,615
need to change the oil

1452
00:37:49,310 --> 00:37:50,270
0,135 135,270 270,510 510,765 765,960
in your car,| you can
|你可以在你应该走的里程之外走很长一段时间，

1453
00:37:50,270 --> 00:37:51,290
0,135 135,240 240,420 420,705 705,1020
go a long time beyond

1454
00:37:51,290 --> 00:37:53,345
0,350 940,1340 1600,1845 1845,1950 1950,2055
the, the, you know, the

1455
00:37:53,345 --> 00:37:54,340
0,285 285,375 375,525 525,675 675,995
mileage when you're supposed to,|
|

1456
00:37:54,510 --> 00:37:55,235
0,215 215,350 350,440 440,575 575,725
but it's kind of you
但这是你不应该的，

1457
00:37:55,235 --> 00:37:56,270
0,420 420,690 690,855 855,975 975,1035
shouldn't, right,| so it's sort
|所以这有点像是最佳实践，

1458
00:37:56,270 --> 00:37:57,280
0,60 60,285 285,540 540,705 705,1010
of like the best practices,|
|

1459
00:37:57,960 --> 00:37:58,820
0,245 245,380 380,605 605,785 785,860
you want to, you know,
你想确保你准备好了，

1460
00:37:58,820 --> 00:37:59,210
0,75 75,165 165,240 240,315 315,390
you want to make sure

1461
00:37:59,210 --> 00:38:00,260
0,180 180,360 360,590
you set up,|
|

1462
00:38:00,510 --> 00:38:01,625
0,275 275,380 380,800 800,1010 1010,1115
do the upkeep that you
做你需要做的维护，

1463
00:38:01,625 --> 00:38:02,600
0,105 105,195 195,425 625,870 870,975
need to do,| but of
|但当然，如果你每秒都在运行它，

1464
00:38:02,600 --> 00:38:03,440
0,210 210,405 405,540 540,660 660,840
course, if you're running it

1465
00:38:03,440 --> 00:38:04,805
0,240 240,540 540,890 970,1305 1305,1365
every second,| then that's going
|那么这会使你的读取速度变慢，

1466
00:38:04,805 --> 00:38:05,360
0,30 30,105 105,225 225,420 420,555
to make your reads go

1467
00:38:05,360 --> 00:38:06,455
0,320 460,690 690,795 795,885 885,1095
slower,| so it's to balance,
|所以，它是如何平衡，|

1468
00:38:06,455 --> 00:38:07,190
0,180 180,285 285,435 435,600 600,735
how to figure out, how
如何弄清楚在什么时候做这件事。

1469
00:38:07,190 --> 00:38:08,240
0,260 430,675 675,780 780,915 915,1050
to, how to, when to

1470
00:38:08,240 --> 00:38:09,590
0,105 105,350 610,885 885,1065 1065,1350
do it.| And again, we'll
|同样，我们将看到这一点，

1471
00:38:09,590 --> 00:38:10,295
0,180 180,360 360,510 510,615 615,705
see this,| when we talk
|当我们讨论 Postgres 和多版本控制时，

1472
00:38:10,295 --> 00:38:11,285
0,105 105,420 420,555 555,720 720,990
about Postgres and multi version

1473
00:38:11,285 --> 00:38:12,365
0,365 385,705 705,795 795,930 930,1080
control,| there's this thing called
|有一种叫自动 vacuum 的东西，

1474
00:38:12,365 --> 00:38:14,135
0,120 120,270 270,725 1255,1575 1575,1770
the auto vacuum,| when, when
|它应该什么时候运行，它应该如何运行，

1475
00:38:14,135 --> 00:38:15,065
0,120 120,225 225,420 420,720 720,930
should it run, how should

1476
00:38:15,065 --> 00:38:16,000
0,90 90,195 195,390 390,630 630,935
it run,| it depends on
|这取决于工作量和硬件。

1477
00:38:16,140 --> 00:38:17,520
0,260 260,365 365,440 440,820
depends on the workload

1478
00:38:17,520 --> 00:38:18,940
0,150 150,240 240,470
and the hardware.|
|

1479
00:38:22,480 --> 00:38:23,580
0,400
Okay.|
好的。|

1480
00:38:25,840 --> 00:38:27,060
0,400
So,
所以，我们到目前为止谈到的两种方法，

1481
00:38:27,830 --> 00:38:28,855
0,290 290,455 455,665 665,860 860,1025
the two approaches we talked

1482
00:38:28,855 --> 00:38:30,265
0,165 165,285 285,540 540,935 1105,1410
about so far,| again, the
|日志结构存储和面向页面存储，

1483
00:38:30,265 --> 00:38:31,590
0,210 210,450 450,780 780,1050 1050,1325
{log-structure -} storage and the,

1484
00:38:33,500 --> 00:38:34,750
0,365 365,590 590,845 845,1100 1100,1250
the sort of the {page-oriented

1485
00:38:34,750 --> 00:38:36,865
0,270 270,650 1480,1815 1815,2010 2010,2115
-} storage,| these are {tuple-oriented
|这是面向 tuple 的存储，

1486
00:38:36,865 --> 00:38:38,635
0,195 195,480 480,705 705,995 1435,1770
-} storage,| these are, these
|这是方法，

1487
00:38:38,635 --> 00:38:39,980
0,335
approaches,|
|

1488
00:38:39,990 --> 00:38:40,835
0,260 260,470 470,635 635,695 695,845
the all going to lie
这一切都依赖索引查找独立的 tuple ，

1489
00:38:40,835 --> 00:38:42,005
0,240 240,585 585,705 705,900 900,1170
on indexes to find individual

1490
00:38:42,005 --> 00:38:44,170
0,485 715,975 975,1215 1215,1595 1765,2165
tuples,| that are separate from
|tuple 本身独立于表的核心存储，

1491
00:38:44,370 --> 00:38:46,775
0,400 1080,1325 1325,1535 1535,1900 2010,2405
the sort of core storage

1492
00:38:46,775 --> 00:38:48,005
0,285 285,555 555,810 810,975 975,1230
of the of the tables,

1493
00:38:48,005 --> 00:38:50,420
0,225 225,510 510,845 1405,1805 2035,2415
the tuple themselves, right,| in
|在面向 tuple 的存储中，

1494
00:38:50,420 --> 00:38:52,265
0,375 375,735 735,885 885,1190 1540,1845
the {tuple-oriented -} storage,| there's
|有这些页面，它们是无序的，

1495
00:38:52,265 --> 00:38:54,335
0,180 180,515 535,825 825,1415 1735,2070
these pages, they're unordered,| and
|并获取 record ID ，

1496
00:38:54,335 --> 00:38:55,540
0,210 210,390 390,630 630,885 885,1205
to get that record ID,|
|

1497
00:38:55,980 --> 00:38:56,765
0,260 260,365 365,485 485,635 635,785
that gives us the page
给我们页面编号和 slot 编号，

1498
00:38:56,765 --> 00:38:57,520
0,120 120,210 210,300 300,465 465,755
number and the slot number,|
|

1499
00:38:57,870 --> 00:38:59,405
0,380 380,590 590,845 845,1325 1325,1535
there's some other magical data
还有一些其他神奇的数据结构或索引，

1500
00:38:59,405 --> 00:39:00,610
0,270 270,525 525,735 735,915 915,1205
structure or index, I said,|
|

1501
00:39:00,720 --> 00:39:01,475
0,335 335,425 425,515 515,620 620,755
that's going to get us
会把我们带到那里，

1502
00:39:01,475 --> 00:39:02,900
0,275 625,960 960,1200 1200,1350 1350,1425
there,| same thing for the
|日志结构存储也是如此，

1503
00:39:02,900 --> 00:39:04,385
0,135 135,375 375,710 970,1230 1230,1485
{log-structure -} storage,| we need,
|我们需要一个索引告诉我们，

1504
00:39:04,385 --> 00:39:05,300
0,240 240,360 360,555 555,765 765,915
we need an index that

1505
00:39:05,300 --> 00:39:06,245
0,165 165,465 465,675 675,750 750,945
tells us,| for a given
|对于给定的 record ID ，

1506
00:39:06,245 --> 00:39:07,580
0,255 255,575 865,1140 1140,1245 1245,1335
record ID,| where to go
|到哪里去查找我们寻找的数据。

1507
00:39:07,580 --> 00:39:08,225
0,135 135,255 255,390 390,525 525,645
find the data that we're

1508
00:39:08,225 --> 00:39:09,100
0,150 150,485
looking for,

1509
00:39:09,910 --> 00:39:11,140
0,400
right.|
|

1510
00:39:11,180 --> 00:39:13,930
0,400 1080,1480 1740,2105 2105,2450 2450,2750
And so an alternative approach
所以，另一种方法是，

1511
00:39:13,930 --> 00:39:14,995
0,180 180,440 550,810 810,930 930,1065
is that,| what if we
|如果我们只保持 tuple 自动排序，会怎么样，

1512
00:39:14,995 --> 00:39:16,350
0,195 195,390 390,540 540,935 955,1355
just keep the tuples automatically

1513
00:39:16,400 --> 00:39:17,580
0,580
sorted,|
|

1514
00:39:18,610 --> 00:39:20,175
0,305 305,610 900,1205 1205,1400 1400,1565
by just putting it inside
只需将其放入索引本身，

1515
00:39:20,175 --> 00:39:21,880
0,180 180,450 450,815
the index itself,|
|

1516
00:39:22,280 --> 00:39:23,170
0,245 245,350 350,530 530,680 680,890
and then now you don't
现在，你没有单独的区别，

1517
00:39:23,170 --> 00:39:24,250
0,150 150,300 300,525 525,825 825,1080
have a separate distinct between|
|

1518
00:39:24,250 --> 00:39:25,315
0,255 255,360 360,525 525,840 840,1065
here's the {log-structure -} storage
这里是日志结构存储和索引，

1519
00:39:25,315 --> 00:39:26,400
0,225 225,420 420,600 600,735 735,1085
and the index,| or here's,
|这是是页面插槽和索引，

1520
00:39:26,510 --> 00:39:27,835
0,490 510,785 785,950 950,1085 1085,1325
here's the slot of pages,

1521
00:39:27,835 --> 00:39:29,560
0,225 225,420 420,555 555,845 1405,1725
and here's the index,| it's
|这些都只是索引。

1522
00:39:29,560 --> 00:39:31,220
0,135 135,360 360,860
all just indexes.|
|

1523
00:39:31,910 --> 00:39:32,635
0,275 275,395 395,500 500,620 620,725
And so this is what
这就是所谓的索引组织存储或索引组织表，

1524
00:39:32,635 --> 00:39:34,165
0,120 120,395 415,815 895,1230 1230,1530
is called {index-organized -} storage

1525
00:39:34,165 --> 00:39:36,310
0,255 255,510 510,780 780,1085 1885,2145
or {index-organized -} tables,| and
|这里的想法是，

1526
00:39:36,310 --> 00:39:37,830
0,180 180,435 435,720 720,1070 1120,1520
the idea here is that,|
|

1527
00:39:38,870 --> 00:39:39,865
0,320 320,485 485,620 620,815 815,995
assuming we have some tree
假设我们有一些树数据结构，

1528
00:39:39,865 --> 00:39:41,500
0,225 225,575 1165,1440 1440,1560 1560,1635
data structure| or could be
|或者可以是哈希表，现在我们假设是树，

1529
00:39:41,500 --> 00:39:42,760
0,60 60,240 240,500 910,1155 1155,1260
a hash table, for now

1530
00:39:42,760 --> 00:39:44,300
0,195 195,360 360,680
we'll assume trees,|
|

1531
00:39:44,630 --> 00:39:46,000
0,260 260,395 395,670 720,1100 1100,1370
instead of having the the
不是让树中的叶节点带有值，

1532
00:39:46,000 --> 00:39:48,640
0,240 240,860 1930,2250 2250,2460 2460,2640
leaf nodes in in the

1533
00:39:48,640 --> 00:39:50,605
0,290 520,825 825,1130 1270,1665 1665,1965
tree with values,| values that
|值为我们提供 record ID ，

1534
00:39:50,605 --> 00:39:51,660
0,180 180,315 315,435 435,600 780,1055
provide us the record Id,|
|

1535
00:39:52,130 --> 00:39:52,825
0,260 260,365 365,470 470,590 590,695
that tells us where to
告诉我们应该去哪里，找到包含我们要查找的数据的页面，

1536
00:39:52,825 --> 00:39:53,545
0,135 135,315 315,465 465,600 600,720
go, find the page that

1537
00:39:53,545 --> 00:39:54,160
0,105 105,210 210,315 315,465 465,615
has a data we're looking

1538
00:39:54,160 --> 00:39:55,525
0,320 730,975 975,1080 1080,1200 1200,1365
for,| what if the leaf
|如果叶子它们自己只是包含 tuple 的数据页面，

1539
00:39:55,525 --> 00:39:56,590
0,255 255,555 555,780 780,930 930,1065
nodes themselves were just the

1540
00:39:56,590 --> 00:39:57,720
0,180 180,435 435,615 615,720 720,1130
data pages with the tuples,|
|

1541
00:39:59,300 --> 00:40:00,235
0,245 245,395 395,545 545,740 740,935
so now when I want
所以现在当我想要做一个查找，

1542
00:40:00,235 --> 00:40:00,745
0,75 75,150 150,255 255,390 390,510
to do a look up|
|

1543
00:40:00,745 --> 00:40:01,960
0,105 105,345 345,645 645,930 930,1215
and say find me key
并且说帮我找到键 102 ，

1544
00:40:01,960 --> 00:40:03,520
0,180 180,330 330,620 1030,1350 1350,1560
{102 - -},| I follow
|我跟随这个索引，然后到达底部，

1545
00:40:03,520 --> 00:40:04,765
0,240 240,585 585,840 840,1020 1020,1245
this index and then []

1546
00:40:04,765 --> 00:40:06,240
0,150 150,225 225,330 330,575
{} at the bottom,|
|

1547
00:40:06,250 --> 00:40:08,280
0,400 750,1040 1040,1220 1220,1540 1770,2030
{} [] not [], []
达到底部，

1548
00:40:08,280 --> 00:40:10,185
0,105 105,195 195,440 1270,1590 1590,1905
at the bottom| and there's
|这是我要找的索引，

1549
00:40:10,185 --> 00:40:11,240
0,225 225,450 450,600 600,735 735,1055
the index I'm looking for,|
|

1550
00:40:12,365 --> 00:40:13,010
0,120 120,210 210,315 315,495 495,645
sorry, there's the data that
抱歉，这是我要找的数据。

1551
00:40:13,070 --> 00:40:14,500
0,60 60,195 195,500
I'm looking for.|
|

1552
00:40:15,590 --> 00:40:16,360
0,305 305,455 455,545 545,635 635,770
Right?| So this sort of
是吧？|所以这个想法看起来就像，

1553
00:40:16,360 --> 00:40:17,365
0,150 150,285 285,495 495,750 750,1005
idea looks like,| again, this
|这是一个粗略的图 B 树，

1554
00:40:17,365 --> 00:40:18,520
0,300 300,540 540,765 765,990 990,1155
what this is a rough

1555
00:40:18,520 --> 00:40:19,690
0,360 360,495 495,630 630,885 885,1170
diagram a B tree,| which
|它很快就会讲到，

1556
00:40:19,690 --> 00:40:21,865
0,240 240,560 910,1310 1510,1920 1920,2175
cover soon, right,| there's essentially
|这里有内部节点，然后是叶子节点，

1557
00:40:21,865 --> 00:40:22,960
0,195 195,345 345,780 780,960 960,1095
the inner nodes and then

1558
00:40:22,960 --> 00:40:23,755
0,105 105,255 255,465 465,630 630,795
the leaf nodes,| the inner
|内部节点基本上是告诉你，

1559
00:40:23,755 --> 00:40:25,105
0,300 300,390 390,635 685,1020 1020,1350
nodes are basically guys [posts]

1560
00:40:25,105 --> 00:40:25,675
0,105 105,240 240,390 390,495 495,570
that tell you,| for a
|对于给定的键，我应该向左还是向右，

1561
00:40:25,675 --> 00:40:26,875
0,180 180,515 715,960 960,1065 1065,1200
given key, should I go

1562
00:40:26,875 --> 00:40:28,040
0,165 165,300 300,545
left or right,|
|

1563
00:40:29,040 --> 00:40:29,915
0,260 260,380 380,485 485,620 620,875
and in the leaf nodes
而在叶子节点本身，

1564
00:40:29,915 --> 00:40:31,580
0,365 985,1275 1275,1440 1440,1575 1575,1665
themselves,| these will look a
|这些会看起来像插槽页面，

1565
00:40:31,580 --> 00:40:33,250
0,230 280,585 585,890 970,1395 1395,1670
lot just like slotted pages,|
|

1566
00:40:34,710 --> 00:40:35,770
0,245 245,365 365,575 575,785 785,1060
but the difference is that,|
但不同的是，|

1567
00:40:35,850 --> 00:40:36,910
0,290 290,365 365,515 515,740 740,1060
we're going to sort them
我们将对页面本身基于键进行排序，

1568
00:40:37,260 --> 00:40:39,245
0,365 365,620 620,845 845,1180 1740,1985
in, in the actual in

1569
00:40:39,245 --> 00:40:40,780
0,120 120,330 330,665 865,1200 1200,1535
the page itself based on

1570
00:40:40,800 --> 00:40:42,530
0,290 290,580 1080,1355 1355,1550 1550,1730
the key,| and not just
|而不仅是随机位置，

1571
00:40:42,530 --> 00:40:44,170
0,120 120,380 430,830 970,1305 1305,1640
a random location in the,|
|

1572
00:40:45,440 --> 00:40:47,125
0,275 275,550 840,1240 1320,1580 1580,1685
based on where we had
基于我们在 slot array 中的空闲空间。

1573
00:40:47,125 --> 00:40:47,740
0,90 90,240 240,420 420,525 525,615
a free space in the

1574
00:40:47,740 --> 00:40:48,900
0,210 210,530
slot array.|
|

1575
00:40:49,500 --> 00:40:50,810
0,230 230,455 455,740 740,1030 1050,1310
So now again, when I
所以，现在，当我想要查找，

1576
00:40:50,810 --> 00:40:51,245
0,105 105,195 195,270 270,330 330,435
want to do a look

1577
00:40:51,245 --> 00:40:52,040
0,165 165,345 345,510 510,660 660,795
up,| find me key {102
|帮我查找键 102 ，

1578
00:40:52,040 --> 00:40:53,525
0,150 150,440 700,1005 1005,1290 1290,1485
- -},| I traverse the
|我遍历索引，

1579
00:40:53,525 --> 00:40:54,755
0,305 505,855 855,1065 1065,1155 1155,1230
index,| I get to a
|我到达一个叶节点，在这里弹出，

1580
00:40:54,755 --> 00:40:55,925
0,150 150,540 540,780 780,960 960,1170
leaf node, I pop over

1581
00:40:55,925 --> 00:40:57,035
0,335 535,780 780,870 870,975 975,1110
here,| and then I do
|然后我对键列表进行二分搜索，

1582
00:40:57,035 --> 00:40:59,615
0,405 405,755 1315,1695 1695,2075 2305,2580
binary search on the list

1583
00:40:59,615 --> 00:41:01,040
0,135 135,395 805,1050 1050,1170 1170,1425
of keys,| and then that'll
|然后这将给我一个偏移量，

1584
00:41:01,040 --> 00:41:01,625
0,75 75,135 135,285 285,480 480,585
give me an offset| to
|查找我要查找的数据。

1585
00:41:01,625 --> 00:41:02,255
0,120 120,285 285,420 420,510 510,630
go find with the data

1586
00:41:02,255 --> 00:41:03,620
0,165 165,315 315,635
I'm looking for.|
|

1587
00:41:05,590 --> 00:41:06,615
0,260 260,395 395,545 545,785 785,1025
So this is what is,
这就是， MySQL ，当你使用 InnoDB 引擎时，

1588
00:41:06,615 --> 00:41:07,440
0,180 180,390 390,660 660,750 750,825
how, MySQL, when you

1589
00:41:07,440 --> 00:41:08,300
0,105 105,225 225,360 360,600 600,860
use the {InnoDB -} engine,|
|

1590
00:41:08,320 --> 00:41:09,105
0,275 275,380 380,500 500,650 650,785
this is, what this what
这就是你在 SQLite 中得到的，

1591
00:41:09,105 --> 00:41:10,410
0,135 135,395 625,900 900,1155 1155,1305
you get for {SQLite -},|
|

1592
00:41:10,410 --> 00:41:10,965
0,150 150,270 270,375 375,465 465,555
this is what you get
这也是你得到的，

1593
00:41:10,965 --> 00:41:12,225
0,120 120,395 835,1080 1080,1155 1155,1260
as well,| I think I
|我想我在上一节课上讲过，

1594
00:41:12,225 --> 00:41:13,710
0,150 150,375 375,725 745,1110 1110,1485
said last class,| in {SQLite
|在 SQLite 中，他们有一个称为 rowid 的内部主键，

1595
00:41:13,710 --> 00:41:15,645
0,260 1090,1350 1350,1470 1470,1665 1665,1935
-}, they had this internal

1596
00:41:15,645 --> 00:41:16,560
0,300 300,540 540,675 675,795 795,915
primary key called the {rowid

1597
00:41:16,560 --> 00:41:17,640
0,260
-},

1598
00:41:17,750 --> 00:41:19,045
0,395 395,790 810,1055 1055,1175 1175,1295
right,| and we can see
|我们可以通过 SQL 看到它，

1599
00:41:19,045 --> 00:41:20,530
0,90 90,240 240,695 895,1215 1215,1485
it through SQL,| but it's
|但它与你在表本身中定义的主键略有不同，

1600
00:41:20,530 --> 00:41:21,775
0,210 210,495 495,675 675,975 975,1245
slightly, it's different than the

1601
00:41:21,775 --> 00:41:22,720
0,285 285,390 390,465 465,630 630,945
primary key you may define

1602
00:41:22,720 --> 00:41:24,190
0,285 285,590 910,1155 1155,1260 1260,1470
in your in your table

1603
00:41:24,190 --> 00:41:27,115
0,350 1060,1460 1900,2265 2265,2510 2530,2925
itself,| because they're using {index-oriented
|因为它们使用的是索引组织存储，

1604
00:41:27,115 --> 00:41:28,495
0,300 300,605 865,1140 1140,1260 1260,1380
-} storage,| and then the
|然后 rowid 是键，

1605
00:41:28,495 --> 00:41:29,710
0,150 150,420 420,750 750,1005 1005,1215
{rowid -} is is the

1606
00:41:29,710 --> 00:41:30,400
0,180 180,330 330,435 435,555 555,690
key,| that you do look
|你在索引里查找一些东西。

1607
00:41:30,400 --> 00:41:31,630
0,135 135,345 345,680 820,1095 1095,1230
up something in inside of

1608
00:41:31,630 --> 00:41:32,580
0,260
the,

1609
00:41:33,240 --> 00:41:34,840
0,245 245,335 335,485 485,790
inside of this index.|
|

1610
00:41:35,260 --> 00:41:36,320
0,260 260,365 365,485 485,710 710,1060
So for the real primary,
所以，对于逻辑主键，

1611
00:41:36,970 --> 00:41:39,345
0,260 260,650 650,875 875,1240 2070,2375
the logical primary key,| a
|客户、学生电子邮件地址，

1612
00:41:39,345 --> 00:41:41,835
0,305 1195,1545 1545,1785 1785,2075 2245,2490
customer student email address,| we
|我们将有一个单独的索引，

1613
00:41:41,835 --> 00:41:42,860
0,90 90,180 180,315 315,605 625,1025
would have a separate index,|
|

1614
00:41:43,540 --> 00:41:45,525
0,260 260,425 425,730 750,1150 1680,1985
that then maps the the
然后将电子邮件地址映射到 rowid ，

1615
00:41:45,525 --> 00:41:46,365
0,195 195,435 435,630 630,720 720,840
email address to the {rowid

1616
00:41:46,365 --> 00:41:47,580
0,275 625,885 885,1005 1005,1110 1110,1215
-},| then you do a
|然后在主键索引中进行查找，

1617
00:41:47,580 --> 00:41:48,390
0,120 120,300 300,480 480,600 600,810
look up in the primary

1618
00:41:48,390 --> 00:41:50,870
0,255 255,560 1600,1980 1980,2220 2220,2480
key index| to get the
|以获得你查找的 tuple 。

1619
00:41:51,750 --> 00:41:52,720
0,245 245,365 455,500 500,650 650,970
{tuple -} you're looking for.|
|

1620
00:41:55,180 --> 00:41:56,490
0,245 245,580 660,950 950,1130 1130,1310

1621
00:41:56,490 --> 00:41:57,465
0,180 180,390 390,555 555,750 750,975

1622
00:41:57,465 --> 00:41:58,380
0,135 135,225 225,405 405,660 660,915

1623
00:41:58,380 --> 00:41:59,120
0,320

1624
00:41:59,790 --> 00:42:00,770
0,245 245,395 395,575 575,815 815,980
The question is,| it's two
问题是，|它是两个键，

1625
00:42:00,770 --> 00:42:02,375
0,180 180,345 345,540 540,860 1360,1605
key,| one key for to
|一个键用于进入页面，另一个键在页面内，

1626
00:42:02,375 --> 00:42:02,945
0,120 120,225 225,315 315,450 450,570
get to the page and

1627
00:42:02,945 --> 00:42:03,760
0,105 105,270 270,450 450,570 570,815
one key inside the page,|
|

1628
00:42:05,130 --> 00:42:06,005
0,320 320,485 485,590 590,695 695,875
no, so like if I,|
不，如果我，|

1629
00:42:06,005 --> 00:42:06,965
0,210 210,330 330,630 630,825 825,960
again, if I'm, if a
如果是 SQLite ，帮我找到 rowid 等于 1 ，

1630
00:42:06,965 --> 00:42:08,675
0,240 240,485 805,1170 1170,1395 1530,1710
SQLite, {} {find,me} {rowid -}

1631
00:42:08,675 --> 00:42:09,960
0,210 210,515
equals 1,|
|

1632
00:42:10,060 --> 00:42:11,220
0,290 290,455 455,710 710,935 935,1160
I just traverse this index,
我只是遍历这个索引，键基于 rowid ，

1633
00:42:11,220 --> 00:42:11,910
0,165 165,315 315,435 435,555 555,690
the keys are based on

1634
00:42:11,910 --> 00:42:13,100
0,135 135,410
{rowid -},|
|

1635
00:42:13,100 --> 00:42:14,165
0,255 255,480 480,660 660,795 795,1065
I land in the page,|
我登上了这页，|

1636
00:42:14,165 --> 00:42:14,900
0,240 240,330 330,420 420,540 540,735
now I need to find
现在，我需要在页面中查找，

1637
00:42:14,900 --> 00:42:15,965
0,225 225,405 405,645 645,915 915,1065
within the page,| where {rowid
|rowid 1 在哪里，

1638
00:42:15,965 --> 00:42:17,600
0,180 180,405 405,695 1045,1410 1410,1635
-} 1 is| and I
|我需要这样查找。

1639
00:42:17,600 --> 00:42:20,795
0,120 120,240 240,465 465,710 2920,3195
do my lookup on this.|
|

1640
00:42:20,795 --> 00:42:22,680
0,180 180,330 330,435 435,815
Entire tree is sorted,|
整个树都是排序的，|

1641
00:42:22,950 --> 00:42:23,920
0,245 245,365 365,470 470,635 635,970
it has to be,| because
它必须是，|因为它是一棵平衡树。

1642
00:42:25,055 --> 00:42:26,240
0,45 45,120 120,360 360,635
it's a balanced tree.|
|

1643
00:42:28,530 --> 00:42:29,600
0,275 275,455 455,650 650,860 860,1070
So you get this in
你可以在 SQL Server 和 Oracle 中获得这个，

1644
00:42:29,600 --> 00:42:32,560
0,270 270,495 495,860 910,1310 2320,2960
SQL Server and, and Oracle,|
|

1645
00:42:32,760 --> 00:42:33,800
0,260 260,395 395,620 620,890 890,1040
but not by default,| you
但不是在默认情况下，|你得告诉它，我想要这个，

1646
00:42:33,800 --> 00:42:34,355
0,75 75,195 195,330 330,435 435,555
have to tell it, I

1647
00:42:34,355 --> 00:42:36,500
0,165 165,455 1675,1920 1920,2010 2010,2145
want this,| if you use
|如果你使用 MySQL SQLite ，默认情况下会得到这个，

1648
00:42:36,500 --> 00:42:37,535
0,165 165,450 450,690 690,870 870,1035
{MySQL -} SQLite, you get

1649
00:42:37,535 --> 00:42:38,860
0,135 135,330 330,665
this by default,|
|

1650
00:42:40,050 --> 00:42:40,470
0,60 60,105 105,195 195,315 315,420
I don't think you can
我不认为你能关掉它们。

1651
00:42:40,470 --> 00:42:42,520
0,120 120,210 210,440 820,1220
turn them off.| Yes.|
|是的。|

1652
00:42:42,680 --> 00:42:43,835
0,270 270,495 495,825 825,1035 1035,1155

1653
00:42:43,835 --> 00:42:45,610
0,270 270,600 600,945 945,1455 1455,1775

1654
00:42:45,660 --> 00:42:47,420
0,380 380,760 840,1240

1655
00:42:48,180 --> 00:42:49,210
0,305 305,455 455,560 560,725 725,1030
Yeah, so his question is,|
是的，所以他的问题是，|

1656
00:42:49,920 --> 00:42:51,425
0,590 590,650 650,755 755,1030 1200,1505
it's a good point,| does
这是一个很好的观点，|这种方法是否仍然受到我们之前讨论过的事情的影响，

1657
00:42:51,425 --> 00:42:52,730
0,270 270,600 600,885 885,1125 1125,1305
this approach still suffer from

1658
00:42:52,730 --> 00:42:53,345
0,105 105,225 225,360 360,495 495,615
the things we talked about

1659
00:42:53,345 --> 00:42:57,370
0,245 265,665 865,1565 1855,2255 3625,4025
before,| like fragmentation and and
|比如碎片化和随机 I/O ，

1660
00:42:58,860 --> 00:43:01,780
0,305 305,485 485,760 1230,1630
random {I/O -},| well,
|对于碎片化，是的，这是不可避免的，

1661
00:43:02,340 --> 00:43:05,750
0,400 930,1630 1650,2050 2640,2945 2945,3410
{so\,,for} fragmentation, yes, it's unavoidable,|
|

1662
00:43:05,750 --> 00:43:06,335
0,105 105,180 180,255 255,390 390,585
because in a {B+ -}
因为在 B+ 树中，它需要至少半满，

1663
00:43:06,335 --> 00:43:08,705
0,305 1855,2115 2115,2235 2235,2310 2310,2370
tree, it needs to be

1664
00:43:08,705 --> 00:43:09,755
0,90 90,225 225,450 450,750 750,1050
at least half full,| so
|所以你会有一堆叶节点是空的，

1665
00:43:09,755 --> 00:43:10,205
0,240 240,270 270,300 300,360 360,450
you're going to have a

1666
00:43:10,205 --> 00:43:11,350
0,105 105,345 345,630 630,900 900,1145
bunch of leaf nodes that

1667
00:43:11,610 --> 00:43:12,220
0,245 245,305 305,335 335,380 380,610
are going to be empty,|
|

1668
00:43:12,240 --> 00:43:14,330
0,320 320,970 1140,1460 1460,1745 1745,2090
that's unavoidable,| in terms of
这是不可避免的，|就随机 I/O 而言，

1669
00:43:14,330 --> 00:43:17,140
0,380 940,1320 1320,1880
the random I/O,|
|

1670
00:43:17,210 --> 00:43:18,570
0,275 275,590 590,875 875,1085 1085,1360
if it's updates to random
如果是更新到叶节点中的随机位置，

1671
00:43:18,590 --> 00:43:20,110
0,365 365,730 750,1010 1010,1175 1175,1520
locations in the leaf nodes,|
|

1672
00:43:20,110 --> 00:43:21,670
0,285 285,555 555,1160 1240,1485 1485,1560
yes, that's unavoidable,| but if
是的，这是不可避免的，|但如果只是插入，

1673
00:43:21,670 --> 00:43:23,220
0,120 120,225 225,1010
you're just inserting,

1674
00:43:23,430 --> 00:43:27,300
0,400 1050,1415 1415,1715 1715,2050
right,| then again, using,
|然后，使用 SQLite rowid 是一个例子，

1675
00:43:27,340 --> 00:43:28,845
0,400 600,965 965,1145 1145,1340 1340,1505
using {SQLite -} {rowid -}

1676
00:43:28,845 --> 00:43:29,985
0,150 150,285 285,575 715,990 990,1140
is an example,| the {rowid
|rowid 只是一个内部计数器，

1677
00:43:29,985 --> 00:43:31,020
0,255 255,495 495,630 630,750 750,1035
-} is just an eternal

1678
00:43:31,020 --> 00:43:32,280
0,320 460,705 705,885 885,1110 1110,1260
counter,| for every new tuple,
|对于每新的 tuple ，它将递增 1 ，

1679
00:43:32,280 --> 00:43:33,495
0,260 460,765 765,885 885,1050 1050,1215
will increment that counter by

1680
00:43:33,495 --> 00:43:34,605
0,275 505,780 780,900 900,1005 1005,1110
one,| one, two, three, four,
|1 2 3 4 5 6 7 ，

1681
00:43:34,605 --> 00:43:35,925
0,120 120,255 255,435 435,675 675,1320
five, six, seven,| it's monotonically
|它是单调递增的，

1682
00:43:35,925 --> 00:43:37,200
0,305 745,960 960,1020 1020,1125 1125,1275
increasing,| so if I just
|所以如果我继续插入到 SQLite ，

1683
00:43:37,200 --> 00:43:38,450
0,150 150,630 630,750 750,990 990,1250
keep inserting to {SQLite -},|
|

1684
00:43:38,890 --> 00:43:39,660
0,380 380,470 470,560 560,650 650,770
I'm just going to keep
我只是继续追加到树的这一边，

1685
00:43:39,660 --> 00:43:40,940
0,590
appending

1686
00:43:40,940 --> 00:43:41,720
0,180 180,375 375,540 540,645 645,780
to this side of the

1687
00:43:41,720 --> 00:43:42,740
0,290 340,600 600,750 750,915 915,1020
tree| and not touch the
|不会碰树的另一边，

1688
00:43:42,740 --> 00:43:43,570
0,150 150,330 330,420 420,540 540,830
other side of the tree,|
|

1689
00:43:44,160 --> 00:43:45,305
0,350 350,635 635,740 740,905 905,1145
so it's not as bad
所以它不会做大量的随机 I/O 那么糟糕，

1690
00:43:45,305 --> 00:43:45,995
0,210 210,360 360,465 465,570 570,690
as doing a much of

1691
00:43:45,995 --> 00:43:47,255
0,135 135,285 285,435 435,785 1015,1260
random {I/O -},| it's not
|它不如做顺序 I/O 那么好，

1692
00:43:47,255 --> 00:43:48,080
0,150 150,315 315,435 435,630 630,825
as good as doing the

1693
00:43:48,080 --> 00:43:49,060
0,300 300,405 405,570 570,720 720,980
sequential {I/O -},| you get
|你从日志结构得到的，

1694
00:43:49,230 --> 00:43:50,900
0,320 320,820 960,1205 1205,1400 1400,1670
{log-structured -},| but it's better
|但它比在面向 tuple 存储中的更好，

1695
00:43:50,900 --> 00:43:52,280
0,380 550,810 810,945 945,1170 1170,1380
than it may have in

1696
00:43:52,280 --> 00:43:53,950
0,260 340,630 630,885 885,1250 1270,1670
a {tuple-oriented -} storage,| because
|因为至少现在树[引导]

1697
00:43:54,390 --> 00:43:55,475
0,230 230,365 365,620 620,890 890,1085
at least now the tree

1698
00:43:55,475 --> 00:43:56,620
0,180 180,585 585,735 735,885 885,1145
is guiding {} to| only
|只更新这边的页面，

1699
00:43:56,640 --> 00:43:57,905
0,305 305,610 690,980 980,1130 1130,1265
update pages on the side

1700
00:43:57,905 --> 00:43:58,980
0,165 165,455
over here,|
|

1701
00:43:59,130 --> 00:44:00,050
0,275 275,395 395,515 515,665 665,920
so there is some benefit
所以，这是有好处的。

1702
00:44:00,050 --> 00:44:01,220
0,225 225,470
to it.|
|

1703
00:44:02,720 --> 00:44:03,850
0,400 450,725 725,830 830,935 935,1130
Yes.| { - - -}
是的。|

1704
00:44:03,850 --> 00:44:05,365
0,195 195,375 375,680 1000,1320 1320,1515

1705
00:44:05,365 --> 00:44:07,260
0,195 195,515 1135,1455 1455,1635 1635,1895

1706
00:44:07,670 --> 00:44:08,710
0,260 260,425 425,680 680,905 905,1040
The question is,| the {rowid
问题是，|rowid 是查找页面， key ID 是查找 tuple 吗，

1707
00:44:08,710 --> 00:44:10,770
0,210 210,560 1420,1665 1665,1785 1785,2060
-} is, the {rowid -}

1708
00:44:10,790 --> 00:44:11,950
0,395 395,665 665,800 800,980 980,1160
is finding a page and

1709
00:44:11,950 --> 00:44:12,880
0,90 90,180 180,345 345,645 645,930
key ID is {finding,a,tuple},| no,
|不，所以我想说的是，

1710
00:44:12,880 --> 00:44:14,395
0,290 1030,1260 1260,1335 1335,1425 1425,1515
so what I was trying

1711
00:44:14,395 --> 00:44:17,720
0,90 90,225 225,450 450,1055
to say,| in SQLite,
|在 SQLite 中，是主键、索引，

1712
00:44:18,260 --> 00:44:20,140
0,120 120,285 285,590 670,1070
there's the primary key,

1713
00:44:20,240 --> 00:44:22,060
0,400 780,1070 1070,1310 1310,1580 1580,1820
index,| that, that, that stores
|存储 tuple 在叶节点中，

1714
00:44:22,060 --> 00:44:23,230
0,320 460,735 735,990 990,1080 1080,1170
the the tuples in the

1715
00:44:23,230 --> 00:44:24,660
0,150 150,590 760,1050 1050,1185 1185,1430
leaf nodes,| but instead of
|但是，与你在 CREATE TABLE 语句中告诉它的主键不同，

1716
00:44:24,800 --> 00:44:25,840
0,260 260,395 395,620 620,860 860,1040
whatever the primary key you

1717
00:44:25,840 --> 00:44:26,830
0,165 165,435 435,675 675,810 810,990
tell it in your CREATE

1718
00:44:26,830 --> 00:44:28,540
0,210 210,530 1090,1380 1380,1530 1530,1710
TABLE statement,| they have an
|它们有一个内部 rowid 是主键，

1719
00:44:28,540 --> 00:44:29,890
0,315 315,570 570,765 765,1080 1080,1350
internal {rowid -} is is

1720
00:44:29,890 --> 00:44:31,240
0,150 150,375 375,740
the primary key,|
|

1721
00:44:31,340 --> 00:44:32,875
0,400 930,1220 1220,1355 1355,1445 1445,1535
so if you do a
所以，如果查看电子邮件地址等于 Andy ，

1722
00:44:32,875 --> 00:44:34,240
0,120 120,395 565,900 900,1125 1125,1365
look at where email address

1723
00:44:34,240 --> 00:44:37,375
0,330 330,710 2470,2805 2805,2910 2910,3135
equals Andy,| there's some other
|还有一些其他索引将为你提供 rowid ，

1724
00:44:37,375 --> 00:44:38,170
0,255 255,495 495,570 570,675 675,795
index that's going to give

1725
00:44:38,170 --> 00:44:39,520
0,105 105,210 210,345 345,620 1090,1350
you the {rowid -},| and
|然后你使用它来遍历主键索引。

1726
00:44:39,520 --> 00:44:40,765
0,260 400,645 645,795 795,1020 1020,1245
then you use that to

1727
00:44:40,765 --> 00:44:42,000
0,285 285,435 435,630 630,900 900,1235
traverse the primary key index.|
|

1728
00:44:42,750 --> 00:44:44,855
0,400 1200,1460 1460,1625 1625,1970 1970,2105
In in {MySQL, -} {Innodb
在 MySQL innodb 中，

1729
00:44:44,855 --> 00:44:45,755
0,120 120,390 390,555 555,765 765,900
- -},| they don't do
|他们不使用 rowid ，

1730
00:44:45,755 --> 00:44:46,510
0,165 165,300 300,390 390,495 495,755
that with a {rowid -},|
|

1731
00:44:47,520 --> 00:44:48,845
0,320 320,550 690,950 950,1100 1100,1325
it'll be the real primary
它将是 CREATE TABLE 语句中声明的真正主键，

1732
00:44:48,845 --> 00:44:49,565
0,210 210,315 315,525 525,630 630,720
key to declare in the

1733
00:44:49,565 --> 00:44:50,920
0,135 135,330 330,635 745,1125 1125,1355
CREATE TABLE statement,| that'll be
|这将是你在这里使用的键，

1734
00:44:50,940 --> 00:44:51,910
0,275 275,395 395,530 530,665 665,970
the key you're using here|
|

1735
00:44:52,350 --> 00:44:53,630
0,275 275,515 515,935 935,1175 1175,1280
and that that's, that's the
这就是你在这里的查找。

1736
00:44:53,630 --> 00:44:54,380
0,285 285,435 435,510 510,600 600,750
lookup that you have over

1737
00:44:54,380 --> 00:44:55,280
0,290
here.|
|

1738
00:45:01,020 --> 00:45:01,960
0,305 305,470 470,575 575,680 680,940
Again, and then the pages
同样，页面插槽架构，

1739
00:45:01,980 --> 00:45:04,390
0,290 290,580 990,1295 1295,1570 2010,2410
look like slot architecture,| where
|其中键和偏移量在一个方向上增长，

1740
00:45:05,010 --> 00:45:06,110
0,275 275,500 500,710 710,800 800,1100
the key and the offsets

1741
00:45:06,110 --> 00:45:06,910
0,120 120,270 270,390 390,510 510,800
are growing in one direction,|
|

1742
00:45:06,930 --> 00:45:08,570
0,245 245,365 365,640 1260,1520 1520,1640
and then the {tuple,ID\,,tuples} are
然后 tuple 在另一个方向上增长。

1743
00:45:08,570 --> 00:45:10,200
0,165 165,375 375,585 585,890
grown in another direction.|
|

1744
00:45:12,280 --> 00:45:13,620
0,400
{All,right},
好的，在文件中存储 tuple 的三种主要方法是，

1745
00:45:15,920 --> 00:45:17,230
0,320 320,545 545,830 830,1100 1100,1310
again, so the three major

1746
00:45:17,230 --> 00:45:20,280
0,320 520,920 1180,1610 2170,2550 2550,3050
approaches for storing, storing, tuples,

1747
00:45:20,330 --> 00:45:23,485
0,230 230,460 1770,2120 2120,2470 2910,3155
sort of within files are

1748
00:45:23,485 --> 00:45:24,250
0,75 75,135 135,330 330,555 555,765
going to be| the heap
|堆存储，具有插槽页面，

1749
00:45:24,250 --> 00:45:25,360
0,290 400,675 675,840 840,990 990,1110
storage with the {slotted -}

1750
00:45:25,360 --> 00:45:27,085
0,260 670,930 930,1095 1095,1365 1365,1725
pages,| the {log-structure -} storage
|日志结构存储，带有追加和 SSTables ，[避免磁盘]，

1751
00:45:27,085 --> 00:45:28,345
0,395 415,645 645,960 960,1185 1185,1260
with the append and the

1752
00:45:28,345 --> 00:45:29,140
0,210 210,405 405,585 585,690 690,795
{SSTables -}, getting rid of

1753
00:45:29,140 --> 00:45:30,595
0,500 580,840 840,975 975,1170 1170,1455
disk,| and then this {index-organized
|然后这个索引组织存储。

1754
00:45:30,595 --> 00:45:32,725
0,365 385,785 1495,1770 1770,1965 1965,2130
-} storage.| And there's other
|还有其他的，比如 ISAM ，

1755
00:45:32,725 --> 00:45:34,080
0,255 255,605 685,915 915,1050 1050,1355
one like the ISAMs,|
|

1756
00:45:35,150 --> 00:45:36,930
0,365 365,620 620,860 860,1475 1475,1780
but these are archaic or
但这些是古老的或它们是遗产，

1757
00:45:37,040 --> 00:45:38,460
0,290 290,580
they're legacy,|
|

1758
00:45:39,365 --> 00:45:39,710
0,75 75,120 120,180 180,255 255,345
we don't need to worry
我们不需要担心这个。

1759
00:45:39,710 --> 00:45:40,840
0,120 120,380
about it.|
|

1760
00:45:41,560 --> 00:45:42,540
0,400
{All,right},
好的，那么我们现在谈谈，

1761
00:45:44,650 --> 00:45:45,470
0,230 230,380 380,455 455,560 560,820
so let's talk about now,|
|

1762
00:45:46,890 --> 00:45:47,840
0,290 290,425 425,590 590,800 800,950
once we got, once we
一旦我们有，我们有了 tuple ，

1763
00:45:47,840 --> 00:45:50,630
0,240 240,620 2170,2445 2445,2595 2595,2790
have a, once we got

1764
00:45:50,630 --> 00:45:52,150
0,210 210,500 820,1065 1065,1215 1215,1520
to this, we got tuple,|
|

1765
00:45:53,430 --> 00:45:54,315
0,75 75,180 180,405 600,735 735,885
let's talk about what's actually
现在让我们来谈谈它里面有什么。

1766
00:45:54,315 --> 00:45:55,680
0,90 90,195 195,455
in it now.|
|

1767
00:45:56,920 --> 00:45:58,620
0,400 900,1175 1175,1400 1400,1595 1595,1700
So a tuple is just
所以 tuple 是一个字节序列，

1768
00:45:58,620 --> 00:46:00,200
0,120 120,285 285,435 435,830
a sequence of bytes,|
|

1769
00:46:00,590 --> 00:46:02,095
0,400 420,800 800,1130 1130,1280 1280,1505
and it, it's the job
这是数据库管理系统的工作，

1770
00:46:02,095 --> 00:46:03,210
0,180 180,285 285,480 480,765 765,1115
of the database management system,|
|

1771
00:46:03,740 --> 00:46:04,960
0,350 350,560 560,755 755,1085 1085,1220
based on the schema that
基于存储在目录中的模式，

1772
00:46:04,960 --> 00:46:05,740
0,135 135,300 300,510 510,645 645,780
that it's storing in its

1773
00:46:05,740 --> 00:46:07,165
0,525 525,825 825,990 990,1170 1170,1425
catalog,| like when you call
|比如当你调用 CREATE TABLE 时，

1774
00:46:07,165 --> 00:46:08,520
0,255 255,545
CREATE TABLE,|
|

1775
00:46:08,520 --> 00:46:09,930
0,320 400,675 675,825 825,1065 1065,1410
I I have these attributes
我有这些类型的属性，

1776
00:46:09,930 --> 00:46:11,715
0,150 150,330 330,650 1330,1665 1665,1785
of these types,| it's the
|这是数据库系统的工作，

1777
00:46:11,715 --> 00:46:12,555
0,210 210,375 375,450 450,600 600,840
job of the database system|
|

1778
00:46:12,555 --> 00:46:14,100
0,270 270,605 685,975 975,1170 1170,1545
to interpret what those bytes
解释这些字节实际是什么，

1779
00:46:14,100 --> 00:46:15,795
0,210 210,500 1060,1335 1335,1470 1470,1695
actually are| and how to,
|以及如何执行你想要对其执行的任何操作，

1780
00:46:15,795 --> 00:46:16,785
0,210 210,315 315,495 495,735 735,990
how to do whatever the

1781
00:46:16,785 --> 00:46:17,610
0,270 270,435 435,495 495,630 630,825
operation that it is want

1782
00:46:17,610 --> 00:46:18,930
0,150 150,255 255,375 375,650 1000,1320
you want on it, right,|
|

1783
00:46:18,930 --> 00:46:19,820
0,180 180,300 300,435 435,600 600,890
if I have two {column
如果我有两列， A 列加上 B 列，

1784
00:46:19,930 --> 00:46:21,465
0,400 600,905 905,1115 1115,1310 1310,1535
-}, column A plus column

1785
00:46:21,465 --> 00:46:23,220
0,335 895,1155 1155,1380 1380,1620 1620,1755
B,| the database system is
|数据库系统就会知道，

1786
00:46:23,220 --> 00:46:24,360
0,150 150,440 460,750 750,930 930,1140
gonna know,| okay, well column
|好的， A 列是一个 32 位整数，

1787
00:46:24,360 --> 00:46:25,515
0,270 270,510 510,735 735,1080 1080,1155
A is a 32 bit

1788
00:46:25,515 --> 00:46:26,880
0,485 655,975 975,1140 1140,1245 1245,1365
integer,| column B is a
|B 列是一个 64 位整数，

1789
00:46:26,880 --> 00:46:28,080
0,300 300,375 375,795 795,1065 1065,1200
64 bit integer,| therefore I
|因此，我需要做，

1790
00:46:28,080 --> 00:46:29,520
0,120 120,240 240,500 1030,1275 1275,1440
need to do| you know
|基于这两种类型的加法运算符。

1791
00:46:29,520 --> 00:46:31,470
0,285 285,570 570,890 1240,1635 1635,1950
the the the addition operator

1792
00:46:31,470 --> 00:46:32,540
0,195 195,420 420,645 645,795 795,1070
based on those two types,

1793
00:46:33,400 --> 00:46:34,520
0,400
right.|
|

1794
00:46:35,390 --> 00:46:36,370
0,275 275,515 515,740 740,860 860,980
And so you can sort
所以你可以再想一想，

1795
00:46:36,370 --> 00:46:37,300
0,120 120,300 300,555 555,780 780,930
of think again,| just think
|只要把它想象成一个字节缓冲区，一个字符数组，

1796
00:46:37,300 --> 00:46:39,040
0,90 90,150 150,380 730,1130 1450,1740
of it as just a

1797
00:46:39,040 --> 00:46:40,830
0,225 225,650 940,1230 1230,1455 1455,1790
byte buffer, a char array,|
|

1798
00:46:42,170 --> 00:46:43,180
0,275 275,350 350,530 530,845 845,1010
there'll be some header,| that
有一些 header ，|来跟踪它的大小，空值，

1799
00:46:43,180 --> 00:46:45,910
0,290 850,1140 1140,1305 1305,1580 2440,2730
says keeps track of maybe

1800
00:46:45,910 --> 00:46:47,230
0,150 150,345 345,525 525,770 1030,1320
the size of it, the

1801
00:46:47,230 --> 00:46:50,035
0,350 910,1310 1840,2130 2130,2420 2470,2805
null,| {we'll,cover,in,a,second},| and then after
|我们稍后会讲到，|然后在 header 完成后，

1802
00:46:50,035 --> 00:46:50,890
0,180 180,330 330,420 420,645 645,855
the header is done,| at
|在第一个偏移量，你会有第一个列， id 列，

1803
00:46:50,890 --> 00:46:52,000
0,120 120,380 490,825 825,1005 1005,1110
the first offset, you would

1804
00:46:52,000 --> 00:46:56,120
0,260 1030,1290 1290,1550 1750,2150
have the {first,column}, {id,column},

1805
00:46:56,120 --> 00:46:58,235
0,320 850,1110 1110,1275 1275,1580 1870,2115
here| and then follow, we
|接下来，我们知道 id 是一个整数，

1806
00:46:58,235 --> 00:46:59,435
0,150 150,285 285,515 595,975 975,1200
know the id is an

1807
00:46:59,435 --> 00:47:00,365
0,450 450,690 690,855 855,900 900,930
integer,| so that's going to
|所以这将是 32 位，

1808
00:47:00,365 --> 00:47:01,910
0,90 90,435 435,695 1105,1350 1350,1545
be 32 bits,| then after
|然后，在 32 位之后，我们有 value ，它将是 64 位。

1809
00:47:01,910 --> 00:47:02,990
0,405 405,600 600,825 825,945 945,1080
32 bits, we have the

1810
00:47:02,990 --> 00:47:04,310
0,260 550,795 795,870 870,975 975,1320
value, which would be 64

1811
00:47:04,310 --> 00:47:05,240
0,260
bits.|
|

1812
00:47:05,240 --> 00:47:07,265
0,120 120,380 1060,1605 1605,1845 1845,2025
And so internally basically the
所以在数据库系统内部，

1813
00:47:07,265 --> 00:47:08,015
0,135 135,390 390,600 600,675 675,750
database system,| if you want
|如果你想做 C++ ，

1814
00:47:08,015 --> 00:47:08,945
0,245 355,615 615,720 720,810 810,930
to do a {C++ -

1815
00:47:08,945 --> 00:47:12,310
0,275 775,1175 2005,2405 2725,3045 3045,3365
-},| is looking gets the
|是寻找 tuple 的起始位置，

1816
00:47:12,510 --> 00:47:14,630
0,395 395,790 810,1145 1145,1480 1860,2120
starting location of the of

1817
00:47:14,630 --> 00:47:16,265
0,135 135,590 820,1125 1125,1395 1395,1635
the tuple, right,| using whatever
|使用 slot array 方法，

1818
00:47:16,265 --> 00:47:17,405
0,210 210,495 495,690 690,885 885,1140
the slot array method| or
|或者我们如何跳到页面中的那个偏移量，

1819
00:47:17,405 --> 00:47:18,290
0,210 210,330 330,450 450,675 675,885
how we get to jump

1820
00:47:18,290 --> 00:47:19,505
0,90 90,270 270,620 850,1095 1095,1215
to that offset in a

1821
00:47:19,505 --> 00:47:21,500
0,275 1105,1410 1410,1710 1710,1845 1845,1995
page,| the header is always
|header 总是与每个 tuple 相同的大小，

1822
00:47:21,500 --> 00:47:21,950
0,75 75,105 105,165 165,270 270,450
going to be the same

1823
00:47:21,950 --> 00:47:22,985
0,255 255,420 420,540 540,720 720,1035
size for every single tuples,|
|

1824
00:47:22,985 --> 00:47:23,540
0,150 150,240 240,315 315,405 405,555
we know how to jump
我们知道如何跳过（的 tuple），

1825
00:47:23,540 --> 00:47:25,100
0,210 210,530 940,1200 1200,1365 1365,1560
past that,| and then now
|现在我们只做一个简单的算术运算，

1826
00:47:25,100 --> 00:47:25,655
0,150 150,270 270,360 360,435 435,555
we just do a simple

1827
00:47:25,655 --> 00:47:26,945
0,495 495,615 615,780 780,1005 1005,1290
arithmetic to say,| I know
|我知道我要寻找的第一列的偏移量是，

1828
00:47:26,945 --> 00:47:29,300
0,270 270,575 1105,1505 1675,2070 2070,2355
that the, the, the offset

1829
00:47:29,300 --> 00:47:30,230
0,165 165,345 345,555 555,780 780,930
of this first column that

1830
00:47:30,230 --> 00:47:32,180
0,120 120,255 255,560 850,1250 1660,1950
I'm looking for is| this
|这个 header 后面的很多位或字节，

1831
00:47:32,180 --> 00:47:33,305
0,120 120,270 270,540 540,780 780,1125
so many bits or bytes

1832
00:47:33,305 --> 00:47:34,600
0,305 385,645 645,1025
after the header,|
|

1833
00:47:34,670 --> 00:47:35,230
0,215 215,260 260,335 335,440 440,560
or if I want the
或者，如果我想要第二列，如何到达那里。

1834
00:47:35,230 --> 00:47:36,310
0,180 180,500 610,870 870,960 960,1080
second column, how to get

1835
00:47:36,310 --> 00:47:37,380
0,290
there,|
|

1836
00:47:37,770 --> 00:47:38,435
0,320 320,485 485,560 560,605 605,665
{varchar -} is a little
varchar 有点复杂，

1837
00:47:38,435 --> 00:47:39,305
0,120 120,395 505,735 735,795 795,870
bit complicated,| {} you have
|你必须存储字段的长度，

1838
00:47:39,305 --> 00:47:40,790
0,135 135,425 655,945 945,1230 1230,1485
to store the length of

1839
00:47:40,790 --> 00:47:42,440
0,135 135,410 730,975 975,1220 1390,1650
the field| and that could
|该长度可以在 header 中或者在列中，

1840
00:47:42,440 --> 00:47:43,660
0,105 105,195 195,285 285,680
be in the header,

1841
00:47:44,050 --> 00:47:45,770
0,400 660,980 980,1220 1220,1430 1430,1720
right, or or in line,|
|

1842
00:47:46,570 --> 00:47:47,420
0,260 260,365 365,440 440,620 620,850
for now it doesn't matter,|
现在并不重要，|

1843
00:47:47,920 --> 00:47:48,765
0,275 275,470 470,635 635,770 770,845
but essentially what you're just
但本质上你说做的，

1844
00:47:48,765 --> 00:47:49,725
0,135 135,315 315,435 435,675 675,960
doing,| you're just taking some
|你只是在做一些地址，

1845
00:47:49,725 --> 00:47:52,695
0,335 1015,1415 1435,1740 1740,1955 2365,2970
address| and you're doing reinterpret
|你做重新解释转换，

1846
00:47:52,695 --> 00:47:54,770
0,275 475,735 735,995 1135,1535 1675,2075
cast| to say the, the
|系统本身应该处理那个地址，

1847
00:47:55,090 --> 00:47:56,390
0,380 380,650 650,830 830,1010 1010,1300
system itself should treat that

1848
00:47:56,710 --> 00:47:59,010
0,400 1470,1835 1835,1985 1985,2105 2105,2300
address,| that by that address
|通过地址将其作为 32 位整数或 64 位整数或任何类型。

1849
00:47:59,010 --> 00:48:00,015
0,225 225,390 390,555 555,705 705,1005
as a 32 bit integer

1850
00:48:00,015 --> 00:48:00,945
0,150 150,450 450,510 510,765 765,930
or 64 bit integer or

1851
00:48:00,945 --> 00:48:02,240
0,165 165,285 285,420 420,695
whatever the type is.|
|

1852
00:48:03,700 --> 00:48:05,040
0,395 395,530 530,785 785,1130 1130,1340
It's the database engine which
那是数据库引擎做的解释吗？

1853
00:48:05,040 --> 00:48:06,700
0,135 135,330 330,645 645,1040
is doing the interpret?|
|

1854
00:48:06,700 --> 00:48:08,245
0,350 970,1200 1200,1305 1305,1440 1440,1545
Yes, who else would be
是的，还会有谁来做这件事，

1855
00:48:08,245 --> 00:48:09,160
0,135 135,425
doing it,|
|

1856
00:48:11,350 --> 00:48:12,615
0,335 335,560 560,740 740,1100 1100,1265
we, we're writing SQL, right,|
我们编写 SQL ，|

1857
00:48:12,615 --> 00:48:13,620
0,195 195,360 360,675 675,930 930,1005
like so SQL, there's no
SQL ，这里没有解释 SQL 解释，

1858
00:48:13,620 --> 00:48:14,760
0,120 120,345 345,510 510,915 915,1140
{} interpret as SQL,| this
|这就是实现。

1859
00:48:14,760 --> 00:48:17,000
0,105 105,225 225,390 390,680
is like the implementation.|
|

1860
00:48:18,470 --> 00:48:19,420
0,245 245,380 380,575 575,755 755,950
Again, this class is like
这门课就是我们在做这件事，

1861
00:48:19,420 --> 00:48:21,235
0,240 240,375 375,585 585,890 1570,1815
we're doing this,| not the
|而不是 JavaScript 程序员。

1862
00:48:21,235 --> 00:48:24,480
0,315 315,845
JavaScript programmer.|
|

1863
00:48:24,790 --> 00:48:26,850
0,275 275,500 500,850 1590,1895 1895,2060
All right, so someone brought
好的，上节课有人提出了这个问题，

1864
00:48:26,850 --> 00:48:28,530
0,105 105,225 225,390 390,680 1420,1680
this up last class,| which
|这是一个很好的话题，

1865
00:48:28,530 --> 00:48:29,505
0,195 195,390 390,525 525,705 705,975
is a good topic,| and
|我想把它包括进去，

1866
00:48:29,505 --> 00:48:30,440
0,240 240,360 360,495 495,660 660,935
I want to include it,|
|

1867
00:48:30,520 --> 00:48:31,820
0,400
is,
它是，我们现在需要注意的一件事，

1868
00:48:31,820 --> 00:48:32,405
0,240 240,330 330,375 375,465 465,585
one of the things we

1869
00:48:32,405 --> 00:48:33,280
0,90 90,165 165,270 270,510 510,875
need to be careful now,|
|

1870
00:48:35,180 --> 00:48:36,190
0,275 275,425 425,590 590,830 830,1010
as we start storing these
当我们开始存储这些比特时，处理对齐，

1871
00:48:36,190 --> 00:48:38,130
0,290 580,960 960,1230 1230,1410 1410,1940
bits is dealing with alignment,|
|

1872
00:48:39,430 --> 00:48:40,695
0,245 245,425 425,725 725,1040 1040,1265
to make sure that the
以确保我们存储的数据对齐，

1873
00:48:40,695 --> 00:48:42,170
0,180 180,390 390,660 660,1170 1170,1475
data we're storing aligns to

1874
00:48:42,280 --> 00:48:44,800
0,400
the,|
|

1875
00:48:44,800 --> 00:48:46,180
0,255 255,510 510,675 675,1125 1125,1380
to how the CPU actually
与 CPU 实际想要如何操作数据。

1876
00:48:46,180 --> 00:48:47,250
0,210 210,450 450,630 630,780 780,1070
wants to operate on data.|
|

1877
00:48:49,150 --> 00:48:49,970
0,245 245,320 320,440 440,575 575,820
So what I mean this?|
那么我说的是什么意思？|

1878
00:48:51,350 --> 00:48:52,165
0,245 245,380 380,515 515,620 620,815
The reason I put {AndySux
我使用 AndySux 原因是，

1879
00:48:52,165 --> 00:48:53,590
0,255 255,390 390,695 955,1260 1260,1425
-} is,| like people take
|人们拿了我的幻灯片，

1880
00:48:53,590 --> 00:48:54,655
0,165 165,470 640,870 870,945 945,1065
my slides| and they don't
|他们不知道 AndySux 是什么意思，

1881
00:48:54,655 --> 00:48:55,590
0,60 60,150 150,360 360,675 675,935
know what {AndySux -} means,|
|

1882
00:48:55,670 --> 00:48:56,640
0,400
so,
所以，在 Google 上搜索，你就能找到是谁复制了它。

1883
00:48:57,220 --> 00:48:58,050
0,320 320,500 500,590 590,680 680,830
Google that and you find

1884
00:48:58,050 --> 00:49:01,140
0,210 210,390 390,645 645,890 2800,3090
who who copies it, right.|
|

1885
00:49:01,140 --> 00:49:02,500
0,290
So,
所以，我们需要确保，

1886
00:49:03,730 --> 00:49:04,530
0,275 275,410 410,515 515,650 650,800
we need to make sure

1887
00:49:04,530 --> 00:49:05,625
0,135 135,345 345,645 645,960 960,1095
that,| all our attributes are
|我们的所有属性都基于 CPU 的单词边界，

1888
00:49:05,625 --> 00:49:08,025
0,335 415,815 1915,2190 2190,2295 2295,2400
aligned to based on the

1889
00:49:08,025 --> 00:49:09,590
0,210 210,735 735,915 915,1050 1050,1565
word boundaries of the CPU|
|

1890
00:49:09,880 --> 00:49:10,980
0,305 305,470 470,560 560,790 810,1100
or whatever the architecture we're
或我们运行的任何体系结构来对齐，

1891
00:49:10,980 --> 00:49:13,040
0,150 150,470 1000,1395 1395,1725 1725,2060
running on,| to ensure that
|以确保我们不会出现意外的行为，

1892
00:49:13,720 --> 00:49:14,670
0,290 290,575 575,680 680,815 815,950
we don't end up with

1893
00:49:14,670 --> 00:49:16,125
0,260 430,825 825,1095 1095,1230 1230,1455
unexpected behavior,| when we do
|在对这些数据进行操作时，

1894
00:49:16,125 --> 00:49:17,900
0,345 345,585 585,735 735,1025
operations on this data,|
|

1895
00:49:19,020 --> 00:49:20,060
0,260 260,395 395,545 545,815 815,1040
and that the CPU doesn't
而且 CPU 不需要做额外的工作。

1896
00:49:20,060 --> 00:49:20,980
0,120 120,210 210,315 315,555 555,920
have to do extra work.|
|

1897
00:49:22,450 --> 00:49:23,955
0,400 870,1145 1145,1325 1325,1415 1415,1505
{} So let's say I
假设我有一张表，

1898
00:49:23,955 --> 00:49:24,615
0,75 75,165 165,360 360,540 540,660
have a table,| I have
|我这里有四个列，

1899
00:49:24,615 --> 00:49:26,070
0,180 180,465 465,725 1015,1260 1260,1455
four columns here,| I have
|我有 32 位整数， 64 位时间戳，

1900
00:49:26,070 --> 00:49:29,775
0,390 390,465 465,920 1150,1550 3220,3705
32 bit integer, a 64

1901
00:49:29,775 --> 00:49:31,725
0,210 210,515 775,1175 1465,1740 1740,1950
{timestamp -},| a 4 byte
|一个 4 字节字符，然后是一个 zipcode 。

1902
00:49:31,725 --> 00:49:33,300
0,255 255,495 495,755 1135,1395 1395,1575
char and then a {zipcode

1903
00:49:33,300 --> 00:49:35,790
0,290 310,710 1390,1650 1650,1910 2140,2490
-}, right.| And so assume
|假设我们要分解我们的 char array ，

1904
00:49:35,790 --> 00:49:36,780
0,240 240,555 555,825 825,870 870,990
that we're, we're going to

1905
00:49:36,780 --> 00:49:38,310
0,195 195,450 450,800 1000,1335 1335,1530
break up our char array,|
|

1906
00:49:38,310 --> 00:49:40,035
0,330 330,435 435,830 880,1260 1260,1725
representing this tuple into 64
把这个 tuple 表示成 64 位字，

1907
00:49:40,035 --> 00:49:41,415
0,120 120,395 685,1020 1020,1215 1215,1380
bit words,| cache lines are
|高速缓存行是 64 字节的，

1908
00:49:41,415 --> 00:49:44,055
0,390 390,845 1765,2070 2070,2445 2445,2640
64 bytes,| but Postgres lines
|但是 Postgres 行是基于 64 位的，

1909
00:49:44,055 --> 00:49:45,350
0,285 285,540 540,690 690,1035 1035,1295
are based on 64 bits,|
|

1910
00:49:45,610 --> 00:49:46,560
0,400 420,665 665,815 815,860 860,950
or I don't know what
我不知道 SQLite 做的，

1911
00:49:46,560 --> 00:49:48,380
0,345 345,620
SQLite does,|
|

1912
00:49:48,380 --> 00:49:49,850
0,350 490,810 810,930 930,1200 1200,1470
but they're all doing some
但他们都在做一些这个的变体。

1913
00:49:49,850 --> 00:49:52,030
0,345 345,510 510,770 1480,1830 1830,2180
variation of this, right.| So
|所以我要做的第一件事是，

1914
00:49:52,410 --> 00:49:53,015
0,260 260,395 395,485 485,575 575,605
the first thing I'm going

1915
00:49:53,015 --> 00:49:53,765
0,45 45,105 105,300 300,510 510,750
to do is,| we have,
|我们有，对于 id 列，那是 32 位，

1916
00:49:53,765 --> 00:49:55,145
0,315 315,600 600,870 870,1110 1110,1380
for id columm, that's 32

1917
00:49:55,145 --> 00:49:56,440
0,245 475,765 765,915 915,1035 1035,1295
bits,| we store that there,|
|我们把它存储在那里，|

1918
00:49:56,790 --> 00:49:58,625
0,260 260,380 380,640 750,1150 1440,1835
then we have this date
然后我们有这个 date 时间戳，创建日期，它是 64 位，

1919
00:49:58,625 --> 00:50:00,310
0,315 315,635 865,1125 1125,1335 1335,1685
{timestamp -}, the creation date,

1920
00:50:00,420 --> 00:50:01,850
0,320 320,755 755,1025 1025,1265 1265,1430
that 64 bits,| so we
|所以我们在那之后存储它，

1921
00:50:01,850 --> 00:50:03,130
0,195 195,470 550,810 810,975 975,1280
store that right after that|
|

1922
00:50:03,270 --> 00:50:04,700
0,290 290,470 470,740 740,1120 1200,1430
and so forth, with the
以此类推，还有其他的。

1923
00:50:04,700 --> 00:50:05,720
0,135 135,440
other ones,

1924
00:50:05,790 --> 00:50:06,900
0,400
right.|
|

1925
00:50:07,480 --> 00:50:08,475
0,275 275,410 410,560 560,800 800,995
And so again, now when
所以，现在当我想在系统中进行查找时，

1926
00:50:08,475 --> 00:50:09,285
0,105 105,210 210,330 330,570 570,810
I want to do a

1927
00:50:09,285 --> 00:50:11,000
0,455 775,1110 1110,1290 1290,1425 1425,1715
lookup in, in my system|
|

1928
00:50:11,110 --> 00:50:12,470
0,245 245,440 440,665 665,940 960,1360
to do, do some operation
对我为这个 tuple 获得的数组进行一些操作，

1929
00:50:12,490 --> 00:50:14,130
0,305 305,610 1080,1385 1385,1550 1550,1640
on this byte array that

1930
00:50:14,130 --> 00:50:14,835
0,120 120,255 255,420 420,555 555,705
I've gotten for this {tuple

1931
00:50:14,835 --> 00:50:16,170
0,275 445,750 750,930 930,1080 1080,1335
-},| say on the customer
|比如客户日期，创建日期，

1932
00:50:16,170 --> 00:50:18,100
0,360 360,660 660,915 915,1250
date, the creation date,|
|

1933
00:50:18,230 --> 00:50:19,150
0,275 275,440 440,605 605,770 770,920
the problem with this is
这样做的问题在于，

1934
00:50:19,150 --> 00:50:20,500
0,210 210,560
that,| that
|那个属性将跨越两个字，

1935
00:50:20,630 --> 00:50:22,020
0,520 570,830 830,935 935,1085 1085,1390
attribute is going to span

1936
00:50:22,190 --> 00:50:23,720
0,275 275,550
two words,

1937
00:50:24,380 --> 00:50:26,035
0,305 305,500 500,790 1200,1490 1490,1655
right,| because this each word
|因为每个字都是 64 位，

1938
00:50:26,035 --> 00:50:27,480
0,105 105,390 390,665 925,1185 1185,1445
is 64 bits,| the first
|第一个 id 字段为 32 位，

1939
00:50:27,530 --> 00:50:28,860
0,365 365,605 605,755 755,1070 1070,1330
id field was 32 bits,|
|

1940
00:50:29,060 --> 00:50:30,540
0,275 275,425 425,770 770,1030 1050,1480
so this 64 bits spans
所以这个 64 位跨越两个连续的字。

1941
00:50:30,650 --> 00:50:32,440
0,290 290,815 815,1060
two consecutive words.|
|

1942
00:50:33,770 --> 00:50:34,615
0,260 260,365 365,470 470,665 665,845
Anybody know what happens when
有人知道当你在 CPU 中这样做的时候，会发生什么吗，

1943
00:50:34,615 --> 00:50:35,200
0,120 120,255 255,375 375,480 480,585
you do this in a

1944
00:50:35,200 --> 00:50:36,940
0,500 1090,1335 1335,1455 1455,1590 1590,1740
CPU,| when you try to
|当你试图跳到一个内存地址，

1945
00:50:36,940 --> 00:50:37,780
0,180 180,285 285,360 360,570 570,840
jump to a memory address|
|

1946
00:50:37,780 --> 00:50:38,680
0,180 180,300 300,495 495,735 735,900
and do some operational on
并对一些跨越字边界的东西进行操作时，

1947
00:50:38,680 --> 00:50:40,405
0,165 165,375 375,710 1330,1590 1590,1725
something that spans the word

1948
00:50:40,405 --> 00:50:43,300
0,455
boundaries,|
|

1949
00:50:45,340 --> 00:50:46,490
0,245 245,335 335,455 455,860 860,1150
what does {x86 -} do?|
x86 是怎么做的？|

1950
00:50:50,140 --> 00:50:52,070
0,245 245,365 365,880 1050,1610 1610,1930
So {x86 -}, Intel likes
所以 x86 ， Intel 喜欢让你的生活变得轻松，

1951
00:50:52,240 --> 00:50:53,340
0,275 275,425 425,605 605,815 815,1100
to make your life easy|
|

1952
00:50:53,340 --> 00:50:54,135
0,255 255,420 420,570 570,675 675,795
and not have to worry
而不必担心这些事情，

1953
00:50:54,135 --> 00:50:55,815
0,150 150,285 285,545 1075,1365 1365,1680
about these things,| so they'll
|所以他们会为你做额外的读取，

1954
00:50:55,815 --> 00:50:56,820
0,180 180,330 330,510 510,840 840,1005
do the extra reads for

1955
00:50:56,820 --> 00:50:57,700
0,290
you,

1956
00:50:58,090 --> 00:50:59,745
0,400 1050,1295 1295,1385 1385,1490 1490,1655
right,| they want to hide
|他们想把它隐藏起来，

1957
00:50:59,745 --> 00:51:00,435
0,210 210,375 375,465 465,555 555,690
it,| they want to hide
|他们想要隐藏架构的所有的复杂性，

1958
00:51:00,435 --> 00:51:02,655
0,240 240,570 570,935 1435,1770 1770,2220
all, all the the complexities

1959
00:51:02,655 --> 00:51:04,725
0,135 135,225 225,455 1315,1590 1590,2070
of the architecture,| so they'll
|所以他们会做额外的工作，

1960
00:51:04,725 --> 00:51:05,505
0,105 105,285 285,510 510,660 660,780
do extra work,| but now
|但现在这会使你的数据库系统运行较慢，

1961
00:51:05,505 --> 00:51:05,940
0,105 105,195 195,285 285,345 345,435
this is going to make

1962
00:51:05,940 --> 00:51:07,010
0,120 120,255 255,450 450,690 690,1070
your database system run slower,|
|

1963
00:51:07,030 --> 00:51:08,450
0,400 660,950 950,1085 1085,1175 1175,1420
because what should have been,|
因为这本来应该是，|

1964
00:51:08,560 --> 00:51:10,200
0,230 230,365 365,670 1110,1385 1385,1640
you know, one one register
一个寄存器读取或一个高速缓存行读取，

1965
00:51:10,200 --> 00:51:11,520
0,285 285,495 495,800 820,1140 1140,1320
read or one cache line

1966
00:51:11,520 --> 00:51:12,350
0,165 165,270 270,360 360,540 540,830
read| to go fetch something
|去获取一些东西到 CPU 寄存器中，

1967
00:51:13,240 --> 00:51:15,210
0,400 450,710 710,905 905,1150 1710,1970
into a CPU register,| now
|现在会是两个高速缓存行读取，

1968
00:51:15,210 --> 00:51:16,020
0,120 120,270 270,435 435,630 630,810
is {going,to,be} two cache line

1969
00:51:16,020 --> 00:51:17,000
0,410
reads,|
|

1970
00:51:19,030 --> 00:51:20,145
0,260 260,470 470,725 725,845 845,1115
but again, there's no error,|
但是，这是没有错误的，|

1971
00:51:20,145 --> 00:51:21,525
0,255 255,515 565,1035 1035,1230 1230,1380
it just Intel takes care
这只是 Intel 帮你处理的。

1972
00:51:21,525 --> 00:51:22,800
0,75 75,180 180,330 330,605
of it for you.|
|

1973
00:51:23,010 --> 00:51:24,500
0,400 420,710 710,890 890,1180 1200,1490
But not every system, not
但并不是每个系统、每个架构都会这样做，

1974
00:51:24,500 --> 00:51:25,510
0,180 180,435 435,645 645,750 750,1010
every architecture would do that,|
|

1975
00:51:25,890 --> 00:51:28,480
0,400 1290,1670 1670,2030 2030,2300 2300,2590
{} previously before in ARM,|
以前，在 ARM 之中，|

1976
00:51:29,580 --> 00:51:31,115
0,275 275,425 425,575 575,850 1290,1535
they would give you, they
他们会拒绝它，

1977
00:51:31,115 --> 00:51:32,270
0,165 165,375 375,665 775,1035 1035,1155
would reject it,| they would
|它们会识别出你正在尝试执行未对齐的操作，

1978
00:51:32,270 --> 00:51:33,550
0,240 240,480 480,690 690,915 915,1280
recognize that you're trying to

1979
00:51:33,960 --> 00:51:36,500
0,400 570,860 860,1370 1370,1750 2280,2540
do a misalign operation| and
|然后抛出一个错误，希望您能捕捉到，

1980
00:51:36,500 --> 00:51:37,310
0,165 165,345 345,450 450,600 600,810
then throw an error, hoping

1981
00:51:37,310 --> 00:51:38,380
0,120 120,210 210,345 345,620 670,1070
you would catch it,| now,
|现在，在较新的版本中，我认为是 ARM 7 ，

1982
00:51:38,580 --> 00:51:39,605
0,245 245,350 350,590 590,815 815,1025
in the newer versions, I

1983
00:51:39,605 --> 00:51:41,720
0,120 120,395 625,1025 1225,1625 1825,2115
think ARM 7,| they, they
|他们现在处理像 Intel 一样，

1984
00:51:41,720 --> 00:51:42,605
0,180 180,315 315,450 450,600 600,885
handle it now like Intel

1985
00:51:42,605 --> 00:51:44,620
0,275
does,|
|

1986
00:51:45,240 --> 00:51:47,420
0,260 1360,1590 1590,1680 1680,1845 1845,2180
but there's, it's just slower.|
但是，它只是慢了一点。|

1987
00:51:49,000 --> 00:51:49,965
0,290 290,470 470,680 680,845 845,965
This is rare, but what
这很罕见，但可能发生的情况是，

1988
00:51:49,965 --> 00:51:51,620
0,165 165,390 390,585 585,845 1255,1655
could happen is that,| it
|它将为你进行读取，

1989
00:51:52,570 --> 00:51:53,985
0,440 440,650 650,845 845,1205 1205,1415
it'll do the reads for

1990
00:51:53,985 --> 00:51:56,010
0,305 1435,1695 1695,1785 1785,1875 1875,2025
you,| but it is no
|但不能保证位将以正确的顺序到达。

1991
00:51:56,010 --> 00:51:57,765
0,290 430,705 705,980 1360,1635 1635,1755
guarantee that the bits are

1992
00:51:57,765 --> 00:51:58,335
0,75 75,195 195,360 360,480 480,570
going to land in the

1993
00:51:58,335 --> 00:52:00,120
0,120 120,395 1225,1470 1470,1605 1605,1785
right order.| So going back
|所以回到这里，

1994
00:52:00,120 --> 00:52:01,410
0,290 730,975 975,1065 1065,1155 1155,1290
here,| I have to do
|我必须进行两次读取，才能得到这个字和这个字，

1995
00:52:01,410 --> 00:52:02,160
0,165 165,375 375,450 450,570 570,750
two reads to get this

1996
00:52:02,160 --> 00:52:04,250
0,195 195,375 375,555 555,860 1690,2090
word and this word| to
|从而将 date 属性组合在一起，

1997
00:52:04,480 --> 00:52:06,950
0,290 290,580 1560,1820 1820,2045 2045,2470
put together the date attribute,|
|

1998
00:52:06,970 --> 00:52:08,600
0,275 275,485 485,710 710,1000 1230,1630
it may put the last
它可能会把后面的位放在另一个的前面，

1999
00:52:08,740 --> 00:52:09,480
0,305 305,470 470,575 575,665 665,740
bits in front of the

2000
00:52:09,480 --> 00:52:10,780
0,135 135,440
other ones,|
|

2001
00:52:10,990 --> 00:52:11,940
0,260 260,350 350,440 440,665 665,950
seems like a terrible idea,|
这似乎是个糟糕的主意，|

2002
00:52:11,940 --> 00:52:13,695
0,320 760,1005 1005,1215 1215,1620 1620,1755
but the older CPUs would
但老式的 CPU 会这么做。

2003
00:52:13,695 --> 00:52:14,760
0,150 150,425
do that.|
|

2004
00:52:14,770 --> 00:52:15,630
0,245 245,350 350,500 500,695 695,860
Of course, that means now
当然，这意味着现在你的程序出现一种随机错误，

2005
00:52:15,630 --> 00:52:16,425
0,135 135,360 360,540 540,630 630,795
your program kind of random

2006
00:52:16,425 --> 00:52:18,150
0,420 420,645 645,915 915,1265 1405,1725
errors| and, and, and messed
|而且搞砸了数据，

2007
00:52:18,150 --> 00:52:19,545
0,105 105,380 850,1140 1140,1290 1290,1395
up data| and people are
|人们会注意到并抱怨，

2008
00:52:19,545 --> 00:52:20,310
0,75 75,150 150,300 300,525 525,765
going to notice and complain,|
|

2009
00:52:20,310 --> 00:52:21,675
0,180 180,375 375,620 910,1170 1170,1365
and that's bad.| Again, that's
这是不好的。|这也是 Intel 试图对你隐瞒这一点的部分原因，

2010
00:52:21,675 --> 00:52:22,185
0,90 90,165 165,225 225,345 345,510
part of the reason why

2011
00:52:22,185 --> 00:52:23,295
0,450 450,705 705,810 810,945 945,1110
Intel tries to hide that

2012
00:52:23,295 --> 00:52:24,165
0,135 135,345 345,570 570,735 735,870
from you,| even though it
|尽管它会让你的东西运行得更慢。

2013
00:52:24,165 --> 00:52:25,010
0,120 120,240 240,360 360,525 525,845
makes your thing run slower.|
|

2014
00:52:27,170 --> 00:52:27,820
0,230 230,305 305,410 410,500 500,650
So we need to make
所以我们需要确保，

2015
00:52:27,820 --> 00:52:29,680
0,255 255,590 1360,1605 1605,1680 1680,1860
sure that,| none of the
|我们的 tuple 没有任何属性，

2016
00:52:29,680 --> 00:52:30,565
0,270 270,375 375,525 525,720 720,885
attributes in our {tuple -},|
|

2017
00:52:30,565 --> 00:52:31,705
0,120 120,365 415,795 795,1020 1020,1140
in our, essentially in our
在我们的字节数组中，

2018
00:52:31,705 --> 00:52:33,055
0,240 240,545 715,975 975,1155 1155,1350
byte array,| because again, now
|因为现在，我们讨论的是带入内存的东西，

2019
00:52:33,055 --> 00:52:34,045
0,165 165,270 270,545 565,840 840,990
we're talking about things, we

2020
00:52:34,045 --> 00:52:36,010
0,135 135,270 270,545 1345,1725 1725,1965
brought into memory,| that none
|它们中没有一个会跨越这些界限。

2021
00:52:36,010 --> 00:52:36,550
0,90 90,180 180,300 300,405 405,540
of them are going to

2022
00:52:36,550 --> 00:52:38,720
0,210 210,530 580,1190
span these boundaries.|
|

2023
00:52:39,750 --> 00:52:40,895
0,365 365,605 605,770 770,980 980,1145
So the two approaches to
所以，处理这个问题的两种方法是填充或重新排序。

2024
00:52:40,895 --> 00:52:42,260
0,165 165,345 345,525 525,1080 1080,1365
handle this are padding or

2025
00:52:42,260 --> 00:52:43,540
0,620
reordering.|
|

2026
00:52:43,670 --> 00:52:46,470
0,380 380,760 840,1240 1980,2285 2285,2800
So with, {} with padding,
所以，对于填充，基本的想法是，

2027
00:52:46,700 --> 00:52:47,605
0,245 245,455 455,665 665,785 785,905
the basic idea is,| to
|意识到，

2028
00:52:47,605 --> 00:52:49,375
0,245 325,725 1195,1440 1440,1605 1605,1770
recognize that,| if I'm breaking
|如果我要拆分 64 位字，

2029
00:52:49,375 --> 00:52:51,210
0,225 225,375 375,1425 1425,1560 1560,1835
up to 64 bit words|
|

2030
00:52:51,590 --> 00:52:52,885
0,335 335,545 545,740 740,1025 1025,1295
as I add my attributes
当我添加属性跨越时，

2031
00:52:52,885 --> 00:52:54,520
0,135 135,375 375,755 1255,1500 1500,1635
as going across,| if I
|如果我意识到下一个属性不适合我的单个字，

2032
00:52:54,520 --> 00:52:56,200
0,290 370,770 850,1140 1140,1410 1410,1680
recognize that the next attribute

2033
00:52:56,200 --> 00:52:57,535
0,300 300,540 540,810 810,1080 1080,1335
doesn't fit within my single

2034
00:52:57,535 --> 00:52:58,660
0,335
word,|
|

2035
00:52:58,810 --> 00:52:59,485
0,90 90,150 150,255 255,480 480,675
then I'll just put a
然后我只需要在那里放一堆零，把它填满，

2036
00:52:59,485 --> 00:53:00,265
0,120 120,255 255,495 495,630 630,780
bunch of zeros there and

2037
00:53:00,265 --> 00:53:01,320
0,165 165,455
pad that,|
|

2038
00:53:01,580 --> 00:53:03,040
0,260 260,470 470,1010 1010,1145 1145,1460
and then internally, the bookkeeping
然后在内部，系统的[记录]，

2039
00:53:03,040 --> 00:53:04,105
0,135 135,240 240,420 420,740 820,1065
of the system| as when
|当它解释这些字节时，

2040
00:53:04,105 --> 00:53:05,245
0,195 195,375 375,645 645,1005 1005,1140
it, when it's interpreting these

2041
00:53:05,245 --> 00:53:06,810
0,360 360,630 630,855 855,1170 1170,1565
bytes,| it knows that, okay,
|它知道，好的，我需要这个 id ，

2042
00:53:07,100 --> 00:53:08,910
0,275 275,470 470,790 1050,1430 1430,1810
I need this id here,|
|

2043
00:53:09,230 --> 00:53:11,880
0,245 245,490 870,1145 1145,1420 2190,2650
and then the date attribute,
然后是 date 属性，这将是下一个字，

2044
00:53:11,900 --> 00:53:12,505
0,335 335,395 395,425 425,500 500,605
that's going to be the

2045
00:53:12,505 --> 00:53:13,590
0,135 135,330 330,480 480,705 705,1085
next word,| so just ignore
|所以忽略这 32 位就行了。

2046
00:53:13,880 --> 00:53:15,560
0,290 290,650 650,800 800,1090
these 32 bits there.|
|

2047
00:53:20,050 --> 00:53:21,090
0,230 230,365 365,590 590,785 785,1040
The other approach is do
另一种方法是重新排序。

2048
00:53:21,090 --> 00:53:24,080
0,680
reordering.|
|

2049
00:53:24,080 --> 00:53:25,430
0,120 120,345 345,495 495,770 1060,1350
I don't think any, most
我不认为，大多数系统不会自动完成这项工作，

2050
00:53:25,430 --> 00:53:26,560
0,240 240,510 510,585 585,780 780,1130
systems don't do this automatically,|
|

2051
00:53:27,270 --> 00:53:28,480
0,245 245,335 335,545 545,860 860,1210
Some of the academic systems
我们建立的一些学术系统，会自动完成这个，

2052
00:53:28,530 --> 00:53:29,315
0,275 275,410 410,530 530,650 650,785
we built, one that did

2053
00:53:29,315 --> 00:53:31,415
0,275 1285,1500 1500,1650 1650,1920 1920,2100
this, do this automatically,| but
|但大多数系统会准确地列出你说的内容，

2054
00:53:31,415 --> 00:53:32,165
0,150 150,360 360,525 525,630 630,750
most systems will lay out

2055
00:53:32,165 --> 00:53:33,320
0,150 150,425 445,795 795,1005 1005,1155
the bits exactly where you

2056
00:53:33,320 --> 00:53:34,310
0,195 195,495 495,735 735,840 840,990
tell it| and then put
|然后添加填充物，以使其更好。

2057
00:53:34,310 --> 00:53:35,960
0,300 300,560 760,1160 1270,1530 1530,1650
padding in to make it

2058
00:53:35,960 --> 00:53:36,740
0,260
better.|
|

2059
00:53:37,140 --> 00:53:37,925
0,245 245,380 380,545 545,680 680,785
So the idea here is
所以这里的想法是，

2060
00:53:37,925 --> 00:53:41,840
0,245 925,1200 1200,1475 2815,3215 3295,3915
that,| if I the logical
|如果我看到表的逻辑视图，

2061
00:53:41,840 --> 00:53:43,430
0,255 255,555 555,890 1210,1455 1455,1590
view of the, of the

2062
00:53:43,430 --> 00:53:44,645
0,290 370,705 705,930 930,1080 1080,1215
table,| whatever defined {in,the} CREATE
|不管 CREATE TABLE 语句定义了什么，

2063
00:53:44,645 --> 00:53:46,145
0,195 195,515 715,1140 1140,1350 1350,1500
TABLE statement,| I'll tell you
|我会告诉你东西按这个顺序排序，

2064
00:53:46,145 --> 00:53:46,865
0,105 105,240 240,390 390,645 645,720
if things are sorted in

2065
00:53:46,865 --> 00:53:48,455
0,120 120,395 835,1110 1110,1350 1350,1590
this order,| but underneath the
|但在幕后，我会移动东西，

2066
00:53:48,455 --> 00:53:49,865
0,275 415,780 780,915 915,1140 1140,1410
covers, I'll just move things

2067
00:53:49,865 --> 00:53:52,565
0,335 2065,2295 2295,2385 2385,2520 2520,2700
around,| so I can pack
|这样我就可以更好地打包东西，

2068
00:53:52,565 --> 00:53:54,160
0,180 180,345 345,635 1075,1335 1335,1595
things in better| and then,
|然后，如果需要，我会在末尾添加一些像这样的位。

2069
00:53:54,180 --> 00:53:55,685
0,400 420,820 840,1190 1190,1340 1340,1505
if necessary, I'll add bits

2070
00:53:55,685 --> 00:53:56,470
0,135 135,240 240,360 360,510 510,785
at the end like that.|
|

2071
00:53:57,350 --> 00:54:03,520
0,400 5370,5660 5660,5855 5855,6035 6035,6170
Yes.| This question is, how
是的。|这个问题是， varchar 如何处理这种情况的？

2072
00:54:03,520 --> 00:54:06,740
0,260 430,765 765,1020 1020,1340
{do,varchar} handle this case?|
|

2073
00:54:07,470 --> 00:54:10,320
0,290 290,440 440,850
Yeah, for padding.|
是的，对于填充。|

2074
00:54:12,050 --> 00:54:12,700
0,75 75,135 165,210 210,345 345,650
That's what I'm saying,| so,
这就是我说的，|所以，在执行自动重新排序的系统中，

2075
00:54:15,060 --> 00:54:16,265
0,290 290,455 455,650 650,890 890,1205
in the systems that do

2076
00:54:16,265 --> 00:54:18,155
0,300 300,965 1225,1485 1485,1725 1725,1890
automatic reordering,| you don't store
|你不会将 varchar 存储在一行，

2077
00:54:18,155 --> 00:54:19,240
0,135 135,315 315,555 555,780 780,1085
the {varchar -} in line,|
|

2078
00:54:19,650 --> 00:54:21,260
0,500 500,740 740,1010 1010,1250 1250,1610
unless less, unless they're 64
除非它们是 64 位或更少，

2079
00:54:21,260 --> 00:54:22,520
0,120 120,240 240,500
bits or less,|
|

2080
00:54:22,520 --> 00:54:23,375
0,255 255,450 450,585 585,720 720,855
and instead, you store a
取而代之的是，你存储一个指向其他位置的指针，

2081
00:54:23,375 --> 00:54:24,550
0,360 360,480 480,570 570,795 795,1175
pointer to some other location,|
|

2082
00:54:25,290 --> 00:54:27,770
0,400 400,1530 1530,1760 1760,1820 1820,2050 2130,2480
that {we'll,see} in a second,| these
我们稍后会看到，|这些外部的，这些超大的属性表或页面是分开的，

2083
00:54:27,770 --> 00:54:30,970
0,350 910,1310 1990,2640 2640,2940 2940,3200
external, these oversized attribute tables

2084
00:54:31,770 --> 00:54:33,125
0,365 365,730 930,1175 1175,1265 1265,1355
or pages that are sort

2085
00:54:33,125 --> 00:54:33,935
0,90 90,405 405,525 525,645 645,810
of separately,| so you can
|所以，你可以进行这种重新排序，

2086
00:54:33,935 --> 00:54:34,880
0,135 135,270 270,675 675,795 795,945
do this reordering| and not
|而不必担心可变长度的事情。

2087
00:54:34,880 --> 00:54:36,790
0,195 195,500 1120,1425 1425,1620 1620,1910
worry about variable length things.|
|

2088
00:54:38,750 --> 00:54:40,350
0,275 275,440 440,710 710,1090 1200,1600

2089
00:54:42,250 --> 00:54:43,155
0,350 350,530 530,620 620,740 740,905
Question, do I need this
问题是，我需要最后这个东西吗，

2090
00:54:43,155 --> 00:54:44,715
0,305 655,945 945,1110 1110,1365 1365,1560
last this thing here,| do
|我需要这个吗，

2091
00:54:44,715 --> 00:54:47,120
0,75 75,195 195,420 420,785
I need this,| no.|
|不。|

2092
00:54:51,000 --> 00:54:52,235
0,400 690,935 935,1040 1040,1145 1145,1235
So we can see this
所以，我们可以在 Postgres 中看到这个，

2093
00:54:52,235 --> 00:54:53,420
0,90 90,575
in Postgres,|
|

2094
00:54:53,860 --> 00:54:55,250
0,320 320,695 695,845 845,1055 1055,1390
so Postgres will not do
Postgres 不会进行自动重新排序，

2095
00:54:55,360 --> 00:54:56,850
0,290 290,820 930,1175 1175,1295 1295,1490
automatic reordering,| but it will
|但会进行填充，

2096
00:54:56,850 --> 00:54:59,400
0,320 880,1430
do padding,|
|

2097
00:55:00,130 --> 00:55:01,140
0,275 275,455 455,590 590,800 800,1010
and there some simple things
我们可以看到一些简单的事情，

2098
00:55:01,140 --> 00:55:02,250
0,135 135,255 255,495 495,840 840,1110
we can see about,| if
|如果我们重新排序，

2099
00:55:02,250 --> 00:55:03,500
0,290
we,

2100
00:55:03,600 --> 00:55:06,260
0,260 260,520 810,1355 1355,1630
when we reorder the,|
|

2101
00:55:07,420 --> 00:55:08,870
0,320 320,485 485,605 605,905 905,1450
when, when we reorder, reorder
当我们重新排序 CREATE TABLE 保存的东西或重新排序 tuple 时，

2102
00:55:09,430 --> 00:55:10,410
0,260 260,425 425,635 635,800 800,980
the CREATE TABLE savings or

2103
00:55:10,410 --> 00:55:12,825
0,330 330,450 450,710 1330,1730 2170,2415
reorder tuples,| that we
|我们可以在更小的空间内存储东西。

2104
00:55:12,825 --> 00:55:13,875
0,105 105,255 255,545 595,870 870,1050
can store things in less

2105
00:55:13,875 --> 00:55:15,780
0,305
space.|
|

2106
00:55:17,180 --> 00:55:19,200
0,400
So.|
所以。|

2107
00:55:19,980 --> 00:55:21,365
0,260 260,485 485,755 755,1085 1085,1385
So just more Postgres syntax
所以这里是更多的 Postgres 语法，

2108
00:55:21,365 --> 00:55:23,180
0,210 210,515 1105,1530 1530,1665 1665,1815
here,| but Postgres has this
|Postgres 有一个很好的小函数，叫做 row ，

2109
00:55:23,180 --> 00:55:24,370
0,165 165,345 345,630 630,900 900,1190
nice little function called row,|
|

2110
00:55:24,990 --> 00:55:26,440
0,305 305,610 720,965 965,1130 1130,1450
and essentially it just takes
本质上它只接受你给它的逗号分隔的值列表，

2111
00:55:26,790 --> 00:55:28,025
0,305 305,575 575,770 770,1010 1010,1235
the comma separated list of

2112
00:55:28,025 --> 00:55:29,500
0,255 255,435 435,555 555,815
values you give it,|
|

2113
00:55:29,610 --> 00:55:30,820
0,260 260,380 380,485 485,730 810,1210
it makes a row, right,|
它会做一个行，|

2114
00:55:32,190 --> 00:55:33,440
0,275 275,530 530,770 770,965 965,1250
and then we can cast
然后我们可以对它转码，

2115
00:55:33,440 --> 00:55:35,345
0,240 240,530 1390,1635 1635,1725 1725,1905
it,| now we can add
|现在我们可以在所有值的末尾加上 :: 的东西，

2116
00:55:35,345 --> 00:55:36,875
0,335 655,1005 1005,1275 1275,1440 1440,1530
this {:: -} thing at

2117
00:55:36,875 --> 00:55:38,450
0,90 90,335 355,755 775,1175 1315,1575
the end of all our

2118
00:55:38,450 --> 00:55:41,340
0,260 1060,1440 1440,1820
values| and that,
|这基本上是将值转换为给定的类型，

2119
00:55:41,350 --> 00:55:43,220
0,400 510,910 930,1475 1475,1610 1610,1870
that basically casting the value

2120
00:55:43,420 --> 00:55:45,075
0,400 480,710 710,845 845,1150 1410,1655
to a given type,| so
|所以我可以做一个小整数，一个常规整数和一个大整数，

2121
00:55:45,075 --> 00:55:46,800
0,105 105,225 225,485 1195,1515 1515,1725
I can do a small

2122
00:55:46,800 --> 00:55:48,170
0,210 210,390 390,600 600,950 970,1370
int, a regular int and

2123
00:55:48,280 --> 00:55:49,770
0,275 275,410 410,620 620,970 1200,1490
a big int,| so a
|所以是两个字节的整型，四个字节的整型，或者八个字节的整型。

2124
00:55:49,770 --> 00:55:50,940
0,150 150,315 315,560 700,975 975,1170
two byte int, four byte

2125
00:55:50,940 --> 00:55:53,300
0,230 880,1280 1660,1950 1950,2130 2130,2360
int or eight byte int,

2126
00:55:53,350 --> 00:55:54,560
0,400
right.|
|

2127
00:55:54,760 --> 00:55:55,965
0,245 245,485 485,935 935,1085 1085,1205
So now Postgres has a
现在 Postgres 有一个很好的小函数，名为 pg_column_size ，

2128
00:55:55,965 --> 00:55:58,020
0,105 105,240 240,515 625,1025
nice little function called

2129
00:55:58,590 --> 00:56:01,730
0,400 1080,1460 1460,1655 1655,1990 2760,3140
{} {pg_column_size - -},| that'll
|它会告诉你这个记录、这个 tuple 的大小，以字节为单位。

2130
00:56:01,730 --> 00:56:03,050
0,165 165,450 450,720 720,1005 1005,1320
tell you the size of

2131
00:56:03,050 --> 00:56:06,310
0,320 1360,1760 1990,2535 2535,2805 2805,3260
this record, {this,tuple} in bytes.|
|

2132
00:56:06,870 --> 00:56:07,780
0,215 215,275 275,410 410,605 605,910
So in this case here,|
所以在这个例子中，|

2133
00:56:08,490 --> 00:56:09,305
0,305 305,410 410,530 530,650 650,815
it's tell me the size
它告诉我创建的行的大小，以字节为单位，

2134
00:56:09,305 --> 00:56:10,040
0,135 135,240 240,405 405,555 555,735
of this row I created,

2135
00:56:10,040 --> 00:56:11,420
0,195 195,650 910,1155 1155,1260 1260,1380
for bytes,| if I go
|如果我返回到前一个，

2136
00:56:11,420 --> 00:56:12,460
0,150 150,270 270,435 435,705 705,1040
back to my previous one,|
|

2137
00:56:14,930 --> 00:56:16,720
0,260 260,395 395,670
and run that.|
并运行。|

2138
00:56:17,020 --> 00:56:18,340
0,400

2139
00:56:21,370 --> 00:56:22,700
0,400
Yeah.|
是的。|

2140
00:56:23,490 --> 00:56:24,880
0,400
Sorry.|
抱歉。|

2141
00:56:29,760 --> 00:56:30,785
0,245 245,365 365,605 605,845 845,1025
Go back to the row
回到以前的那个行，

2142
00:56:30,785 --> 00:56:32,650
0,180 180,455 805,1155 1155,1590 1590,1865
had before,| without casting to
|没有进行类型转换，

2143
00:56:33,900 --> 00:56:36,600
0,400 1020,1310 1310,1475 1475,1960
types,| {told,me} it's 36,
|告诉我是 36 ，

2144
00:56:36,670 --> 00:56:37,970
0,290 290,455 455,620 620,905 905,1300
right,| which makes sense,| because,
|这说得通，|因为，这里最后一个，

2145
00:56:39,020 --> 00:56:40,240
0,230
{}

2146
00:56:40,560 --> 00:56:41,525
0,290 290,485 485,680 680,845 845,965
this last one here,| I
|我把它转换成 64 位整数，

2147
00:56:41,525 --> 00:56:43,990
0,120 120,300 300,605 1075,2115 2115,2465
was making that 64 bit

2148
00:56:44,370 --> 00:56:46,505
0,610 990,1310 1310,1775 1775,2015 2015,2135
integer,| or Postgres in this
|或者在这里是 Postgres ，

2149
00:56:46,505 --> 00:56:47,240
0,150 150,255 255,405 405,585 585,735
case here,| it's storing it
|它将其存储为 8 字节，

2150
00:56:47,240 --> 00:56:50,615
0,260 1660,1965 1965,2175 2175,2690 3070,3375
as all eight bytes,| four
|4 字节的整数和 32 位的整数，

2151
00:56:50,615 --> 00:56:52,205
0,255 255,495 495,705 705,1145 1165,1590
bit, four byte integers, 32

2152
00:56:52,205 --> 00:56:53,375
0,90 90,515 745,990 990,1080 1080,1170
bit integers,| and then a
|然后有一些额外的空间用于填充。

2153
00:56:53,375 --> 00:56:55,270
0,90 90,285 285,630 630,1025 1345,1895
little extra space for padding.|
|

2154
00:56:56,800 --> 00:56:57,920
0,400

2155
00:56:57,920 --> 00:56:58,775
0,285 285,480 480,600 600,720 720,855
So we can see this
所以我们现在可以看到，

2156
00:56:58,775 --> 00:57:00,250
0,195 195,420 420,675 675,1025 1075,1475
now,| if we take a,|
|如果我们取一个，|

2157
00:57:04,730 --> 00:57:05,380
0,245 245,335 335,410 410,500 500,650
let me do it first
让我先做一下，不要大小，

2158
00:57:05,380 --> 00:57:07,195
0,290 400,690 690,980 1695,1755 1755,1815
without the size,| so let's
|所以，让我们来创建一个行，

2159
00:57:07,195 --> 00:57:08,640
0,105 105,210 210,455
make a row,|
|

2160
00:57:10,020 --> 00:57:12,890
0,290 290,580 1320,1610 1610,1930 2610,2870
that has some chars, and
它有一些字符，然后是两个字节、四个字节和八个字节的整数，

2161
00:57:12,890 --> 00:57:15,725
0,260 1720,1995 1995,2325 2325,2520 2520,2835
then two byte, four byte

2162
00:57:15,725 --> 00:57:18,200
0,305 805,1095 1095,1305 1305,1745 2245,2475
and eight byte integers,| but
|但我把字符和整数混在一起了，

2163
00:57:18,200 --> 00:57:19,730
0,120 120,660 660,825 825,1160 1240,1530
I'm intermixing the chars with

2164
00:57:19,730 --> 00:57:24,120
0,290 340,740 2560,3165 3165,3560
the the integers, right,|
|

2165
00:57:24,280 --> 00:57:25,275
0,305 305,515 515,650 650,770 770,995
so now if I say,|
所以现在如果我说，|

2166
00:57:25,275 --> 00:57:27,195
0,180 180,300 300,755 1555,1800 1800,1920
I guess, Postgres, what is
我想， Postgres ，这个有多大，我得到 48 字节，

2167
00:57:27,195 --> 00:57:28,515
0,120 120,270 270,420 420,665 1075,1320
the size of this, I

2168
00:57:28,515 --> 00:57:30,160
0,120 120,435 435,905
get 48 bytes,|
|

2169
00:57:30,570 --> 00:57:31,580
0,230 230,290 290,410 410,815 815,1010
but if I redo it,
但如果我把所有的整数放在第一位，

2170
00:57:31,580 --> 00:57:32,390
0,165 165,300 300,480 480,660 660,810
where I put all the

2171
00:57:32,390 --> 00:57:34,280
0,405 405,720 720,1095 1095,1710 1710,1890
integers first,| basically reordering as
|重新排序，就像我之前展示的那样，

2172
00:57:34,280 --> 00:57:35,760
0,105 105,210 210,345 345,620
I was shown before,|
|

2173
00:57:35,800 --> 00:57:36,780
0,260 260,395 395,530 530,680 680,980
and then put the chars
然后把所有的字符都放在最后，

2174
00:57:36,780 --> 00:57:38,085
0,240 240,360 360,450 450,680 1060,1305
all at the end,| now
|现在我只剩下 44 字节，

2175
00:57:38,085 --> 00:57:38,805
0,90 90,180 180,285 285,405 405,720
I get down to 44

2176
00:57:38,805 --> 00:57:39,880
0,395
bytes,|
|

2177
00:57:40,490 --> 00:57:41,665
0,290 290,695 695,845 845,995 995,1175
because Postgres has to pad
因为 Postgres 必须填充内容，

2178
00:57:41,665 --> 00:57:42,775
0,180 180,455 565,810 810,945 945,1110
things out| to make sure
|以确保所有内容都是 64 位对齐的。

2179
00:57:42,775 --> 00:57:43,750
0,225 225,405 405,525 525,885 885,975
that everything is 64 bit

2180
00:57:43,750 --> 00:57:44,740
0,320
aligned.|
|

2181
00:57:45,400 --> 00:57:46,500
0,230 230,320 320,575 575,860 860,1100
But it doesn't do do
但它不会自动为你做到这一点，

2182
00:57:46,500 --> 00:57:47,580
0,135 135,255 255,435 435,770 790,1080
this for you automatically,| you
|你必须这么做，

2183
00:57:47,580 --> 00:57:48,195
0,150 150,255 255,345 345,480 480,615
have to do it,| you
|你必须告诉 Postgres 我想要这个，

2184
00:57:48,195 --> 00:57:49,095
0,105 105,240 240,405 405,750 750,900
have to tell Postgres I

2185
00:57:49,095 --> 00:57:50,775
0,150 150,425 1075,1350 1350,1485 1485,1680
want this,| again, where there's
|再说一次，有一些系统可以自动为你做这件事。

2186
00:57:50,775 --> 00:57:51,900
0,135 135,360 360,695 775,1035 1035,1125
some systems that can do

2187
00:57:51,900 --> 00:57:53,260
0,105 105,210 210,375 375,710
this for you automatically.|
|

2188
00:57:55,710 --> 00:57:57,680
0,260 260,520 1410,1715 1715,1865 1865,1970
Makes sense. Again, I like
合乎道理。同样，我喜欢这一点，因为我们可以只执行SQL命令。我们可以得到一个，我们可以稍微了解一下数据库系统存储管理器的内部结构，以了解它是如何实际放置的。

2189
00:57:57,680 --> 00:57:58,655
0,180 180,345 345,495 495,735 735,975
this because we can just

2190
00:57:58,655 --> 00:58:00,125
0,255 255,630 630,1110 1110,1320 1320,1470
do sql commands. We can

2191
00:58:00,125 --> 00:58:02,165
0,275 625,1025 1645,1875 1875,1950 1950,2040
get a, we can get

2192
00:58:02,165 --> 00:58:03,965
0,150 150,455 595,960 960,1325 1525,1800
a view to slightly to

2193
00:58:03,965 --> 00:58:05,090
0,195 195,630 630,810 810,960 960,1125
the internals of the storage

2194
00:58:05,090 --> 00:58:06,035
0,240 240,435 435,510 510,675 675,945
manager of a database system

2195
00:58:06,035 --> 00:58:07,190
0,195 195,455 535,885 885,1005 1005,1155
to say how it actually

2196
00:58:07,190 --> 00:58:08,320
0,165 165,345 345,620
laying things up.|
|

2197
00:58:09,110 --> 00:58:10,180
0,400
Okay.|
好吧。|

2198
00:58:14,440 --> 00:58:15,745
0,225 225,500 550,795 795,1005 1005,1305
All right, so now let's
好了，现在让我们来讨论一下，我们来讨论一下整数。我们稍微谈了一下。让我们讨论另一个，核心的SQL数据类型，以及数据SIM实际上是如何进行的，将如何表示它们。

2199
00:58:15,745 --> 00:58:17,260
0,90 90,335 1045,1305 1305,1410 1410,1515
talk about, we talk about

2200
00:58:17,260 --> 00:58:20,095
0,330 330,465 465,570 570,830 2440,2835
integers. We talk about the

2201
00:58:20,095 --> 00:58:21,295
0,210 210,285 285,545 835,1140 1140,1200
a little bit. Let's talk

2202
00:58:21,295 --> 00:58:22,990
0,245 445,705 705,965 1075,1410 1410,1695
about the other, the core

2203
00:58:22,990 --> 00:58:24,385
0,330 330,510 510,830 970,1245 1245,1395
sql data types and how

2204
00:58:24,385 --> 00:58:25,075
0,120 120,240 240,360 360,525 525,690
the data SIM is actually

2205
00:58:25,075 --> 00:58:26,040
0,150 150,285 285,345 345,570 570,965
going, going to represent them.|
|

2206
00:58:27,500 --> 00:58:28,675
0,260 260,365 365,575 575,980 980,1175
So for all integer data
所以对于所有的整型数据类型，当你给一个整型变量分配一个大整型的变量时，它们本质上是相同的，不管在c+中是什么，它将是相同的表示，因为这是港口所支持的。

2207
00:58:28,675 --> 00:58:30,250
0,335 775,1050 1050,1215 1215,1425 1425,1575
types, these are essentially going

2208
00:58:30,250 --> 00:58:30,880
0,45 45,105 105,225 225,420 420,630
to be the same thing

2209
00:58:30,880 --> 00:58:31,810
0,150 150,285 285,555 555,810 810,930
as you get when you

2210
00:58:31,810 --> 00:58:35,680
0,590 670,945 945,1220 1810,2210 3400,3870
allocate a variable of integer

2211
00:58:35,680 --> 00:58:38,650
0,260 2050,2310 2310,2475 2475,2715 2715,2970
type a large int whatever

2212
00:58:38,650 --> 00:58:39,750
0,285 285,555 555,705 705,825 825,1100
in in c plus plus

2213
00:58:40,280 --> 00:58:41,140
0,320 320,410 410,530 530,665 665,860
it's gonna be the same

2214
00:58:41,140 --> 00:58:43,495
0,680 850,1250 1750,2160 2160,2235 2235,2355
representation because that's what the

2215
00:58:43,495 --> 00:58:44,920
0,405 405,755
harbor supports.|
|

2216
00:58:45,050 --> 00:58:45,895
0,260 260,440 440,620 620,725 725,845
The hardware is going to
硬件将会有，呃，那里，有一个标准，表示任何2的补码整数是有符号的还是无符号的。无论你在c plus中得到什么，都遵循标准，这就是硬件支持的，这就是你在SQL中得到的。

2217
00:58:45,895 --> 00:58:48,625
0,275 415,815 1585,2325 2325,2595 2595,2730
have, uh, there, there's a

2218
00:58:48,625 --> 00:58:51,865
0,300 300,695 1285,2045 2545,2940 2940,3240
standard that representation for whatever

2219
00:58:51,865 --> 00:58:52,945
0,240 240,540 540,810 810,915 915,1080
two's complement integer is either

2220
00:58:52,945 --> 00:58:54,610
0,210 210,360 360,875 1255,1530 1530,1665
signed or unsigned. Whatever you

2221
00:58:54,610 --> 00:58:55,320
0,90 90,180 180,285 285,420 420,710
get in c plus plus,

2222
00:58:55,340 --> 00:58:56,545
0,290 290,515 515,725 725,965 965,1205
that follows the standard and

2223
00:58:56,545 --> 00:58:57,460
0,225 225,285 285,360 360,585 585,915
that's what the hardware supports

2224
00:58:57,460 --> 00:58:58,260
0,195 195,390 390,450 450,540 540,800
and that's what you get

2225
00:58:58,400 --> 00:58:59,620
0,305 305,760
in sql.|
|

2226
00:59:00,230 --> 00:59:01,620
0,400
Right.|
正确的。|

2227
00:59:02,190 --> 00:59:04,510
0,400 480,905 905,1180 1380,1780 1920,2320
For floating points or or
对于浮点数或浮点数或定点数，会有浮点数或实数。这也是在IE754标准中定义的。它规定了硬件应该如何表示这些，这些十进制数字，但每个数据中心也将有所谓的定点小数，即数字或小数。

2228
00:59:04,830 --> 00:59:05,810
0,335 335,440 440,650 650,845 845,980
floating point numbers or fixed

2229
00:59:05,810 --> 00:59:07,730
0,150 150,410 1210,1530 1530,1650 1650,1920
point numbers, there'll be floating

2230
00:59:07,730 --> 00:59:09,455
0,260 370,645 645,825 825,1130 1450,1725
point or real numbers. And

2231
00:59:09,455 --> 00:59:10,595
0,150 150,450 450,720 720,945 945,1140
again that's defined in the

2232
00:59:10,595 --> 00:59:11,870
0,335 385,720 720,930 930,1095 1095,1275
I E seven fifty four

2233
00:59:11,870 --> 00:59:14,045
0,225 225,465 465,900 900,1220 1810,2175
standard. It specifies how hardware

2234
00:59:14,045 --> 00:59:16,295
0,210 210,455 985,1385 1615,1905 1905,2250
should represent these, these decimal

2235
00:59:16,295 --> 00:59:18,020
0,275 955,1200 1200,1350 1350,1560 1560,1725
numbers, but every data centers

2236
00:59:18,020 --> 00:59:18,575
0,165 165,315 315,390 390,450 450,555
is also going to have

2237
00:59:18,575 --> 00:59:19,325
0,105 105,180 180,330 330,540 540,750
what are called fixed point

2238
00:59:19,325 --> 00:59:21,940
0,515 1045,1350 1350,1800 1800,2070 2070,2615
decimals, so numeric or decimal.|
|

2239
00:59:22,520 --> 00:59:23,945
0,135 135,330 330,540 540,855 855,1425
Where each of those implementations
这些实现在每个系统中都是不同的，我们可以在一秒钟内看到这两种方法对于char、VAR、二进制文本和BLOB的性能差异，这些通常将存储为具有告诉您其长度的头部的东西，后跟实际值的字节，或者如果它太大而无法存储在页面内的这两个元素本身中，则会有一个指针指向。

2240
00:59:23,945 --> 00:59:24,670
0,225 225,315 315,360 360,450 450,725
are going to be different

2241
00:59:24,870 --> 00:59:27,335
0,305 305,610 1950,2225 2225,2345 2345,2465
per system and we can

2242
00:59:27,335 --> 00:59:28,330
0,135 135,270 270,450 450,675 675,995
see the performance difference of

2243
00:59:29,040 --> 00:59:29,945
0,260 260,380 380,605 605,815 815,905
the two approaches in a

2244
00:59:29,945 --> 00:59:33,245
0,245 1405,1805 2455,2760 2760,2955 2955,3300
second for char, VAR, binary

2245
00:59:33,245 --> 00:59:34,730
0,150 150,300 300,845 1075,1335 1335,1485
text and blobs, these are

2246
00:59:34,730 --> 00:59:36,280
0,290 400,660 660,810 810,1155 1155,1550
typically gonna be stored as

2247
00:59:37,530 --> 00:59:38,510
0,305 305,455 455,590 590,860 860,980
something with a header that

2248
00:59:38,510 --> 00:59:39,200
0,120 120,225 225,330 330,510 510,690
tells you the length of

2249
00:59:39,200 --> 00:59:41,260
0,260 580,930 930,1275 1275,1560 1560,2060
it, followed by the bytes

2250
00:59:41,580 --> 00:59:43,400
0,380 380,760 960,1340 1340,1625 1625,1820
of the of the actual

2251
00:59:43,400 --> 00:59:45,410
0,290 970,1350 1350,1590 1590,1815 1815,2010
value, or if it's too

2252
00:59:45,410 --> 00:59:46,340
0,240 240,390 390,480 480,720 720,930
big to be stored in

2253
00:59:46,340 --> 00:59:47,620
0,290 310,585 585,720 720,930 930,1280
line in the two itself,

2254
00:59:47,640 --> 00:59:49,610
0,400 510,755 755,890 890,1180 1680,1970
within within a page, there'll

2255
00:59:49,610 --> 00:59:51,840
0,75 75,240 240,770 1150,1550
be a pointer to.|
|

2256
00:59:51,910 --> 00:59:53,060
0,260 260,455 455,695 695,875 875,1150
Some other page that has
包含此属性所需数据的其他页面。

2257
00:59:53,260 --> 00:59:54,150
0,260 260,455 455,635 635,740 740,890
the data that you need

2258
00:59:54,150 --> 00:59:55,780
0,255 255,555 555,980
for this attribute.|
|

2259
00:59:55,780 --> 00:59:56,740
0,225 225,330 330,525 525,765 765,960
So I said for for
所以我说For in Memory System，呃，如果它少于64位，他们会将其存储在行中。如果不是，则在基于Dis的数据库系统中的不同in中存储一个指针。这将取决于实施情况。

2260
00:59:56,740 --> 00:59:59,845
0,150 150,330 330,650 850,1250 2860,3105
in memory system, eh, if

2261
00:59:59,845 --> 01:00:00,840
0,135 135,240 240,375 375,720 720,995
it's less than 64 bits,

2262
01:00:01,070 --> 01:00:03,025
0,395 395,590 590,880 1440,1730 1730,1955
they'll store it in line.

2263
01:00:03,025 --> 01:00:03,895
0,180 180,360 360,540 540,735 735,870
If it's not, then they

2264
01:00:03,895 --> 01:00:07,045
0,120 120,210 210,605 1285,1685 2905,3150
store a pointer in the

2265
01:00:07,045 --> 01:00:07,945
0,165 165,405 405,585 585,735 735,900
different in in a Dis

2266
01:00:07,945 --> 01:00:09,220
0,165 165,390 390,725 895,1200 1200,1275
based database system. It's going

2267
01:00:09,220 --> 01:00:10,020
0,120 120,270 270,390 390,525 525,800
to depend on the implementation.|
|

2268
01:00:10,980 --> 01:00:11,795
0,245 245,365 365,515 515,680 680,815
And we see again, we
我们再次看到，我们在一秒钟内看到这一点。

2269
01:00:11,795 --> 01:00:12,310
0,90 90,165 165,210 210,270 270,515
see that in a second.|
|

2270
01:00:12,920 --> 01:00:14,740
0,300 300,555 555,1020 1020,1310 1420,1820
For time stamps, dates, eh,
对于时间戳、日期和间隔等，这些通常是32位或64位整数。这只是自1970年1月1日Unix时代以来的毫秒数或微秒数。

2271
01:00:14,910 --> 01:00:16,000
0,260 260,575 575,695 695,815 815,1090
and intervals and so forth,

2272
01:00:16,290 --> 01:00:17,080
0,260 260,365 365,440 440,530 530,790
these are going to be

2273
01:00:17,310 --> 01:00:18,815
0,395 395,905 905,1025 1025,1400 1400,1505
typically 32 or 64 bit

2274
01:00:18,815 --> 01:00:20,705
0,485 685,1425 1425,1575 1575,1725 1725,1890
integers. That's just the number

2275
01:00:20,705 --> 01:00:22,595
0,255 255,915 915,1005 1005,1680 1680,1890
of milliseconds or microseconds since

2276
01:00:22,595 --> 01:00:24,640
0,180 180,420 420,875 1285,1665 1665,2045
the unix epoch, january first

2277
01:00:24,750 --> 01:00:26,260
0,730
1970.|
|

2278
01:00:27,240 --> 01:00:28,295
0,260 260,520 630,875 875,950 950,1055
And if you want to
如果您想要使用、使用时间戳信息来存储它，通常他们会将其存储为基于UTC时间戳。

2279
01:00:28,295 --> 01:00:30,230
0,135 135,285 285,465 465,755 1645,1935
store this with, with with

2280
01:00:30,230 --> 01:00:32,690
0,480 480,830 1360,1755 1755,2310 2310,2460
timestamp information, typically they store

2281
01:00:32,690 --> 01:00:33,815
0,90 90,225 225,530 670,960 960,1125
it as the based on

2282
01:00:33,815 --> 01:00:35,600
0,465 465,995
utc timeamp.|
|

2283
01:00:35,600 --> 01:00:38,510
0,290 1060,1545 1545,1820 2500,2760 2760,2910
Right, GMT zero. And then
对，格林尼治标准时间为零。然后他们存储额外的元数据，比如你所在的时间戳，他们可以根据需要进行转换。系统会为你处理这一点。

2284
01:00:38,510 --> 01:00:39,740
0,195 195,420 420,645 645,1110 1110,1230
they store additional metadata, say

2285
01:00:39,740 --> 01:00:40,505
0,150 150,345 345,510 510,630 630,765
what time stamp are you

2286
01:00:40,505 --> 01:00:42,080
0,275 415,815 925,1185 1185,1380 1380,1575
in, and they can convert

2287
01:00:42,080 --> 01:00:43,295
0,105 105,255 255,560 910,1140 1140,1215
it as needed. And the

2288
01:00:43,295 --> 01:00:44,410
0,165 165,525 525,705 705,855 855,1115
system handles that for you.|
|

2289
01:00:47,040 --> 01:00:50,600
0,400 840,1240 1920,2210 2210,2500 3270,3560
So because for these these
因为对于上面这些类型，整数类型，因为我们依赖硬件来存储存储数据的任何东西，硬件想要如何表示它。

2290
01:00:50,600 --> 01:00:52,490
0,195 195,390 390,680 1360,1605 1605,1890
types up here, the integer

2291
01:00:52,490 --> 01:00:53,945
0,260 520,840 840,1065 1065,1320 1320,1455
types, because we're relying on

2292
01:00:53,945 --> 01:00:55,120
0,135 135,360 360,600 600,840 840,1175
the hardware to store whatever

2293
01:00:56,250 --> 01:00:57,395
0,275 275,395 395,640 780,1040 1040,1145
store the data, how the

2294
01:00:57,395 --> 01:00:58,420
0,150 150,315 315,405 405,630 630,1025
hardware wants to represent it.|
|

2295
01:00:58,980 --> 01:01:00,570
0,320 370,770 820,1170 1170,1395 1395,1590
That typically means you just
这通常意味着您不能复制文件，比如从一个架构到另一个架构生成的原始数据库文件。例如，如果它是大印度人或小印度人，如X86，就是小印度人的力量和手臂或大印度人。就像你不能从数据中提取二进制文件并将其放到另一个数据中，因为他们会知道位会被翻转，它会被搞砸。

2296
01:01:00,570 --> 01:01:02,235
0,375 375,600 600,855 855,1160 1390,1665
can't copy the files, like

2297
01:01:02,235 --> 01:01:03,615
0,165 165,405 405,720 720,1085 1105,1380
the raw database files that

2298
01:01:03,615 --> 01:01:05,840
0,120 120,365 1015,1415 1645,1935 1935,2225
you generate from one architecture

2299
01:01:06,010 --> 01:01:07,500
0,290 290,560 560,940 1080,1325 1325,1490
to another. Like if it's

2300
01:01:07,500 --> 01:01:09,480
0,135 135,410 1000,1400 1480,1785 1785,1980
big Indian or or little

2301
01:01:09,480 --> 01:01:11,160
0,270 270,650 820,1110 1110,1500 1500,1680
Indian like X 86 is

2302
01:01:11,160 --> 01:01:13,200
0,180 180,470 1030,1430 1510,1800 1800,2040
little Indian power and arm

2303
01:01:13,200 --> 01:01:14,490
0,240 240,390 390,650 880,1140 1140,1290
or big Indian. Like you

2304
01:01:14,490 --> 01:01:15,660
0,285 285,420 420,555 555,900 900,1170
can't take the binary files

2305
01:01:15,660 --> 01:01:16,605
0,210 210,470 490,750 750,855 855,945
from data and put it

2306
01:01:16,605 --> 01:01:17,925
0,120 120,315 315,635 775,1095 1095,1320
to another one because they're

2307
01:01:17,925 --> 01:01:18,885
0,215 235,570 570,735 735,840 840,960
gonna know the bits are

2308
01:01:18,885 --> 01:01:19,605
0,90 90,210 210,450 450,615 615,720
gonna be flipped and it'll

2309
01:01:19,605 --> 01:01:20,720
0,75 75,270 270,515
get messed up.|
|

2310
01:01:21,710 --> 01:01:22,980
0,365 365,485 485,620 620,875 875,1270
Sql light of voice problem
SQL的轻声问题在哪里？因为他们把所有东西都存储为实际的VaR。

2311
01:01:23,090 --> 01:01:24,565
0,400 540,800 800,965 965,1235 1235,1475
where? Because they store everything

2312
01:01:24,565 --> 01:01:26,920
0,275 295,695 1015,1595
as actually vars.|
|

2313
01:01:27,190 --> 01:01:28,695
0,275 275,455 455,995 995,1265 1265,1505
And at runtime, they cast
在运行时，它们根据属性中的类型进行强制转换。

2314
01:01:28,695 --> 01:01:29,720
0,285 285,510 510,645 645,765 765,1025
things based on the type

2315
01:01:30,490 --> 01:01:31,820
0,260 260,440 440,820
in the attribute.|
|

2316
01:01:31,950 --> 01:01:32,840
0,260 260,440 440,635 635,755 755,890
Because then they get that
因为这样他们就能得到可移植性的保证，无论你知道什么，无论你把文件放在哪里，他们总是会以正确的顺序把文件放进去。

2317
01:01:32,840 --> 01:01:35,510
0,500 1450,1850 1990,2295 2295,2445 2445,2670
portability guarantee that no matter

2318
01:01:35,510 --> 01:01:36,920
0,345 345,540 540,645 645,920 1150,1410
where you know what, where

2319
01:01:36,920 --> 01:01:37,810
0,120 120,270 270,420 420,585 585,890
you pop the file in,

2320
01:01:38,520 --> 01:01:39,515
0,380 380,530 530,650 650,815 815,995
they'll always have it in

2321
01:01:39,515 --> 01:01:40,385
0,135 135,390 390,645 645,750 750,870
in the, in the right

2322
01:01:40,385 --> 01:01:41,620
0,275
order.|
|

2323
01:01:43,010 --> 01:01:43,960
0,380 380,605 605,695 695,815 815,950
So spend a little time
花一点时间讨论一下浮标和卷轴，再一次，这将是一个。

2324
01:01:43,960 --> 01:01:44,875
0,135 135,315 315,540 540,630 630,915
talking about floats and reels

2325
01:01:44,875 --> 01:01:46,645
0,150 150,485 925,1260 1260,1545 1545,1770
and numeric and again, this

2326
01:01:46,645 --> 01:01:48,440
0,135 135,390 390,785
will be a.|
|

2327
01:01:48,550 --> 01:01:49,800
0,320 320,590 590,845 845,1070 1070,1250
Good example of where the
这是一个很好的例子，说明数据库系统将在哪里做一些不同的事情。

2328
01:01:49,800 --> 01:01:50,745
0,180 180,500 520,780 780,870 870,945
database systems are going to

2329
01:01:50,745 --> 01:01:53,540
0,120 120,315 315,635 2005,2400 2400,2795
do something different and the.|
|

2330
01:01:54,870 --> 01:01:55,820
0,305 305,530 530,680 680,860 860,950
You can't just rely on
你不能仅仅依靠硬件来为你做某些事情，因为我们关心数据的正确性，而硬件不能为我们保证这一点。

2331
01:01:55,820 --> 01:01:57,350
0,90 90,270 270,480 480,770 1270,1530
the hardware to do do

2332
01:01:57,350 --> 01:01:58,270
0,150 150,345 345,495 495,630 630,920
certain things for you because

2333
01:01:58,920 --> 01:02:00,095
0,320 320,515 515,725 725,1055 1055,1175
we care about correctness of

2334
01:02:00,095 --> 01:02:01,580
0,275 655,915 915,1020 1020,1200 1200,1485
data and the hardware can't

2335
01:02:01,580 --> 01:02:03,340
0,225 225,495 495,660 660,920
guarantee that for us.|
|

2336
01:02:05,410 --> 01:02:07,440
0,380 380,760 810,1210 1320,1655 1655,2030
Right. So for variable precision
正确的。所以对于变精度的数字，就像以前的整数一样，我们将依赖于c++实现，对吗？所以如果你在SQL中调用浮点实数或双精度数，你会得到和c++一样的浮点数或双精度数。

2337
01:02:07,440 --> 01:02:09,345
0,320 760,1160 1270,1545 1545,1680 1680,1905
numbers, right, just like before

2338
01:02:09,345 --> 01:02:10,545
0,345 345,855 855,1050 1050,1095 1095,1200
in integers, we're going to

2339
01:02:10,545 --> 01:02:12,170
0,210 210,545 1015,1245 1245,1350 1350,1625
rely on c plus plus

2340
01:02:12,700 --> 01:02:15,030
0,395 395,635 635,880 1410,1810 2100,2330
implementation for this, right? So

2341
01:02:15,030 --> 01:02:16,110
0,75 75,165 165,360 360,795 795,1080
if you call float real

2342
01:02:16,110 --> 01:02:18,150
0,225 225,500 550,870 870,1340 1660,2040
or double in sql you'll,

2343
01:02:18,150 --> 01:02:20,100
0,270 270,560 700,990 990,1280 1480,1950
you'll get the same float

2344
01:02:20,100 --> 01:02:21,020
0,225 225,420 420,585 585,675 675,920
or double you would get

2345
01:02:21,040 --> 01:02:22,480
0,275 275,410 410,545 545,820
in c plus plus.|
|

2346
01:02:23,460 --> 01:02:24,545
0,335 335,670 690,950 950,1040 1040,1085
So typically these are going
所以通常情况下，这些会比定点数快。我们一会儿就会看到，因为大厅本身就能支持这一点。

2347
01:02:24,545 --> 01:02:25,715
0,30 30,135 135,425 685,990 990,1170
to be faster than the

2348
01:02:25,715 --> 01:02:27,380
0,275 715,1005 1005,1290 1290,1605 1605,1665
fixed point numbers. We'll see

2349
01:02:27,380 --> 01:02:28,745
0,45 45,120 120,380 790,1140 1140,1365
in a second, because the

2350
01:02:28,745 --> 01:02:30,040
0,210 210,405 405,795 795,1005 1005,1295
hall can natively support this.|
|

2351
01:02:30,870 --> 01:02:32,140
0,400
Um.|
恩。|

2352
01:02:33,770 --> 01:02:35,130
0,400 450,740 740,920 920,1085 1085,1360
But the problem is, though,
但问题是，他们不会有。

2353
01:02:35,500 --> 01:02:36,180
0,75 75,210 210,330 330,420 420,680
they're not going to have.|
|

2354
01:02:38,160 --> 01:02:40,055
0,290 290,515 515,760 1080,1475 1475,1895
They can't guarantee the correctness
当你开始进行更大的计算时，它们不能保证数值的正确性，因为四舍五入问题，因为你不能在硬件中存储准确的小数。

2355
01:02:40,055 --> 01:02:41,015
0,135 135,395 475,720 720,825 825,960
of values when you start

2356
01:02:41,015 --> 01:02:42,680
0,180 180,405 405,935 1315,1560 1560,1665
doing larger calculations because a

2357
01:02:42,680 --> 01:02:43,955
0,300 300,540 540,765 765,900 900,1275
rounding issues because you can't

2358
01:02:43,955 --> 01:02:47,320
0,270 270,605 2185,2765 2785,3075 3075,3365
store exactly decimals in hardware.|
|

2359
01:02:48,740 --> 01:02:49,900
0,290 290,530 530,695 695,965 965,1160
So everyone's probably seen, you
所以每个人都可能见过，你知道，像这样一个简单的测试程序。当你第一次学习csc+时，我有两个浮点数，两个三十，两位浮点数。我想对0.1和0.2进行排序，然后我只想将它们相加，看看输出是什么。所以在第一个版本中，我只需要调用print f来计算X加y。

2360
01:02:49,900 --> 01:02:52,075
0,260 760,1035 1035,1245 1245,1580 1870,2175
know, a simple test program

2361
01:02:52,075 --> 01:02:52,885
0,180 180,345 345,465 465,555 555,810
like this. When you first

2362
01:02:52,885 --> 01:02:54,000
0,315 315,585 585,705 705,840 840,1115
learn CS c plus plus,

2363
01:02:54,710 --> 01:02:55,675
0,230 230,335 335,530 530,830 830,965
I have two floating point

2364
01:02:55,675 --> 01:02:56,590
0,225 225,450 450,630 630,780 780,915
numbers, two thirty, two bit

2365
01:02:56,590 --> 01:02:57,850
0,240 240,360 360,620 910,1170 1170,1260
floating point numbers. I want

2366
01:02:57,850 --> 01:02:59,550
0,75 75,225 225,825 825,1005 1005,1700
to sort 0.1 and 0.2

2367
01:02:59,840 --> 01:03:00,415
0,245 245,335 335,410 410,485 485,575
and then I just want

2368
01:03:00,415 --> 01:03:01,885
0,75 75,165 165,330 330,635 1105,1470
to add them together and

2369
01:03:01,885 --> 01:03:02,760
0,210 210,300 300,465 465,630 630,875
see what the output is.

2370
01:03:03,710 --> 01:03:04,450
0,230 230,290 290,380 380,545 545,740
So in the first version,

2371
01:03:04,450 --> 01:03:05,640
0,195 195,270 270,530 640,915 915,1190
I'll just call print f

2372
01:03:05,990 --> 01:03:07,720
0,230 230,380 380,605 605,940 1440,1730
to dump out the X

2373
01:03:07,720 --> 01:03:08,900
0,195 195,500
plus y.|
|

2374
01:03:08,900 --> 01:03:10,150
0,255 255,530 580,840 840,975 975,1250
Like that. And I would,
就像那样。我会，我会得到一个应该是0.3的值，对吗？

2375
01:03:10,200 --> 01:03:11,200
0,245 245,350 350,500 500,695 695,1000
I would get something that

2376
01:03:11,220 --> 01:03:13,600
0,260 260,365 365,610 780,1540 1980,2380
should look at 0.3 right?|
|

2377
01:03:14,690 --> 01:03:16,560
0,400 1140,1400 1400,1505 1505,1610 1610,1870
And when I run that,
当我运行它的时候，我实际上得到了它看起来，它看起来很好。但实际上，如果我增加Eh位数，我会在我的打印报表中写出来。现在我得到的东西看起来像这样。

2378
01:03:16,700 --> 01:03:17,695
0,290 290,425 425,545 545,785 785,995
I actually get that that

2379
01:03:17,695 --> 01:03:19,420
0,135 135,285 285,465 465,785 1495,1725
looks, that looks okay. But

2380
01:03:19,420 --> 01:03:21,430
0,150 150,855 855,1050 1050,1310 1660,2010
in actuality, if I increase

2381
01:03:21,430 --> 01:03:24,870
0,225 225,480 480,860 1450,1850 2890,3440
the number of eh digits,

2382
01:03:25,220 --> 01:03:26,340
0,575 575,650 650,725 725,845 845,1120
I'm going to write out

2383
01:03:26,750 --> 01:03:28,465
0,230 230,335 335,560 560,910 1440,1715
in my print statement. Now

2384
01:03:28,465 --> 01:03:29,035
0,120 120,225 225,330 330,435 435,570
I end up with something

2385
01:03:29,035 --> 01:03:30,420
0,105 105,210 210,360 360,635
that looks like this.|
|

2386
01:03:30,930 --> 01:03:32,080
0,400
Right.|
正确的。|

2387
01:03:33,190 --> 01:03:34,425
0,305 305,530 530,725 725,950 950,1235
Because again, the horror can't
因为再说一次，恐怖并不能准确地代表0.3。在此基础上会有一些近似值。

2388
01:03:34,425 --> 01:03:36,585
0,245 325,1080 1080,1385 1705,2070 2070,2160
represent 0.3 exactly. It's going

2389
01:03:36,585 --> 01:03:37,770
0,75 75,195 195,420 420,945 945,1185
to be some approximation based

2390
01:03:37,770 --> 01:03:38,760
0,150 150,410
on that.|
|

2391
01:03:39,130 --> 01:03:40,190
0,290 290,455 455,590 590,800 800,1060
So, OK, if I'm doing,
所以，好的，如果我做一个简单的程序，你知道，像以前一样，我只做X加y，然后我把它打印出来给一个人，是的，当然，也许这没什么大不了的，对吧？但如果我在做复杂的计算，因为我想在月球上着陆，或者，你知道，把卫星放到太空，或者如果这是你的银行账户，你在计算利息。

2392
01:03:40,480 --> 01:03:41,850
0,260 260,520 720,980 980,1145 1145,1370
you know, a simple program

2393
01:03:41,850 --> 01:03:43,065
0,320 550,900 900,1080 1080,1140 1140,1215
like before where I was

2394
01:03:43,065 --> 01:03:44,000
0,90 90,255 255,465 465,645 645,935
just doing X plus y

2395
01:03:44,110 --> 01:03:44,925
0,230 230,335 335,470 470,575 575,815
and I print that out

2396
01:03:44,925 --> 01:03:46,395
0,240 240,345 345,605 895,1230 1230,1470
to a human, yeah, sure,

2397
01:03:46,395 --> 01:03:47,145
0,210 210,435 435,525 525,630 630,750
maybe that's not a big

2398
01:03:47,145 --> 01:03:48,555
0,255 255,635 955,1185 1185,1245 1245,1410
deal, right? But if I'm

2399
01:03:48,555 --> 01:03:50,325
0,245 505,735 735,960 960,1245 1245,1770
doing, you know, complex calculations

2400
01:03:50,325 --> 01:03:51,045
0,240 240,390 390,480 480,570 570,720
because I'm trying to land

2401
01:03:51,045 --> 01:03:52,550
0,195 195,315 315,405 405,665 1105,1505
something on the moon or,

2402
01:03:52,810 --> 01:03:53,640
0,245 245,350 350,455 455,545 545,830
you know, put a satellite

2403
01:03:53,640 --> 01:03:54,375
0,225 225,420 420,510 510,645 645,735
space or if it's your

2404
01:03:54,375 --> 01:03:55,305
0,225 225,495 495,645 645,780 780,930
bank account and you're doing

2405
01:03:55,305 --> 01:03:56,740
0,210 210,695
interest calculations.|
|

2406
01:03:56,740 --> 01:03:58,540
0,255 255,480 480,780 780,1040 1450,1800
Then this rounding arrow is
那么这个圆型箭头实际上很重要，人们会注意到的。

2407
01:03:58,540 --> 01:03:59,965
0,195 195,270 270,345 345,590 1180,1425
actually going to matter and

2408
01:03:59,965 --> 01:04:00,570
0,105 105,210 210,285 285,360 360,605
people are going to notice.|
|

2409
01:04:02,940 --> 01:04:04,190
0,275 275,410 410,590 590,905 905,1250
So for this reason, database
因此，数据库系统也将提供这些固定精度的定点小数，数据库系统将做太多额外的工作，以确保您不会有这些舍入误差。您可以在Java中获得这个带有大小数的代码。我想，你可以在十进制类型的python中得到它，对吧。

2410
01:04:04,190 --> 01:04:05,225
0,350 370,705 705,885 885,945 945,1035
systems are also going to

2411
01:04:05,225 --> 01:04:06,410
0,210 210,435 435,630 630,960 960,1185
provide these fixed precision numbers

2412
01:04:06,410 --> 01:04:08,110
0,180 180,315 315,480 480,950 1300,1700
of fixed point decimals, where

2413
01:04:08,970 --> 01:04:10,220
0,400 450,770 770,965 965,1130 1130,1250
the database systems is going

2414
01:04:10,220 --> 01:04:11,045
0,75 75,315 315,555 555,660 660,825
to do too much extra

2415
01:04:11,045 --> 01:04:12,230
0,225 225,435 435,660 660,915 915,1185
work to make sure that

2416
01:04:12,230 --> 01:04:13,475
0,240 240,540 540,675 675,825 825,1245
you don't have these rounding

2417
01:04:13,475 --> 01:04:15,140
0,575 925,1170 1170,1275 1275,1440 1440,1665
errors. You can get this

2418
01:04:15,140 --> 01:04:16,930
0,320 400,900 900,1080 1080,1260 1260,1790
in Java with big decimal.

2419
01:04:17,070 --> 01:04:17,915
0,245 245,350 350,500 500,665 665,845
You can get this in

2420
01:04:17,915 --> 01:04:19,360
0,390 390,570 570,750 750,930 930,1445
python, I think, with decimal

2421
01:04:19,560 --> 01:04:21,740
0,275 275,425 425,700 1170,1570
type as well, right.|
|

2422
01:04:21,810 --> 01:04:23,300
0,290 290,425 425,730 1050,1355 1355,1490
They're all, basically all the
他们都，基本上所有不同的系统都会做一些略有不同的事情，但在更高的水平上。从本质上讲，他们将存储一个。

2423
01:04:23,300 --> 01:04:23,870
0,135 135,345 345,480 480,525 525,570
different systems are going to

2424
01:04:23,870 --> 01:04:24,995
0,165 165,500 520,810 810,990 990,1125
do something slightly different, but

2425
01:04:24,995 --> 01:04:25,865
0,90 90,210 210,405 405,645 645,870
at a high level. Essentially,

2426
01:04:25,865 --> 01:04:27,610
0,180 180,240 240,390 390,695 1345,1745
they're going to store a.|
|

2427
01:04:28,580 --> 01:04:30,685
0,400 810,1130 1130,1310 1310,1865 1865,2105
A very like representation of
一种非常类似于你试图表示的数字的表示。然后，附加元数据会告诉您小数点的位置，小数点是有符号的还是无符号的，或者是负数还是不是数字等等。再说一次，我们必须做这项额外的工作，因为恐怖不能保证我们做到这一点。

2428
01:04:30,685 --> 01:04:31,360
0,120 120,255 255,435 435,510 510,675
the number you're trying to

2429
01:04:31,360 --> 01:04:33,055
0,180 180,285 285,530 1240,1515 1515,1695
trying to represent. And then

2430
01:04:33,055 --> 01:04:34,405
0,270 270,945 945,1095 1095,1215 1215,1350
additional metadata tell you where

2431
01:04:34,405 --> 01:04:35,365
0,120 120,420 420,570 570,765 765,960
the decimal point is or

2432
01:04:35,365 --> 01:04:36,610
0,150 150,390 390,615 615,810 810,1245
whether it's signed or unsigned

2433
01:04:36,610 --> 01:04:37,510
0,165 165,255 255,375 375,615 615,900
or is it negative and

2434
01:04:37,510 --> 01:04:38,410
0,255 255,450 450,570 570,735 735,900
or not a number and

2435
01:04:38,410 --> 01:04:40,795
0,150 150,440 1960,2220 2220,2310 2310,2385
so forth. Again, we have

2436
01:04:40,795 --> 01:04:41,680
0,120 120,270 270,405 405,600 600,885
to do this extra work

2437
01:04:41,680 --> 01:04:42,670
0,210 210,330 330,510 510,765 765,990
because the horror can't guarantee

2438
01:04:42,670 --> 01:04:44,240
0,255 255,390 390,650
this for us.|
|

2439
01:04:45,320 --> 01:04:46,410
0,260 260,440 440,530 530,815 815,1090
So here's what postgres does.
这就是波斯格雷斯所做的。这是postgres中的数字类型。这实际上来自源代码本身。您可以看到，它们将把数字的类型表示为某种结构，带有一堆关于数字实际是什么的附加元数据。但他们内部存储的核心内容与元数据一起，这里是如何存储实际数字本身的。这个数字数组在这里吗？嗯，这只是上面一个无符号字符的类型转换。所以他们真的在存储你的小数。

2440
01:04:46,610 --> 01:04:47,545
0,245 245,350 350,485 485,635 635,935
So this is the numeric

2441
01:04:47,545 --> 01:04:48,430
0,195 195,300 300,600 600,720 720,885
type in postgres. This is

2442
01:04:48,430 --> 01:04:49,195
0,180 180,300 300,420 420,555 555,765
actually from the source code

2443
01:04:49,195 --> 01:04:50,875
0,335 775,1125 1125,1320 1320,1470 1470,1680
itself. And you can see

2444
01:04:50,875 --> 01:04:51,660
0,240 240,450 450,495 495,555 555,785
that they're going to represent

2445
01:04:51,680 --> 01:04:53,400
0,275 275,440 440,620 620,1000 1320,1720
the type of numeric as

2446
01:04:53,480 --> 01:04:55,060
0,275 275,395 395,530 530,820 1290,1580
some kind of struct with

2447
01:04:55,060 --> 01:04:56,430
0,180 180,345 345,480 480,660 660,1370
a bunch of additional metadata

2448
01:04:56,540 --> 01:04:57,955
0,380 380,665 665,830 830,1090 1170,1415
about what the number actually

2449
01:04:57,955 --> 01:04:59,980
0,245 955,1215 1215,1410 1410,1725 1725,2025
is. But the core thing

2450
01:04:59,980 --> 01:05:02,650
0,255 255,590 1180,1760 2320,2580 2580,2670
they're storing internally along with

2451
01:05:02,650 --> 01:05:03,835
0,90 90,650 670,1020 1020,1080 1080,1185
this metadata, here's how to

2452
01:05:03,835 --> 01:05:04,890
0,135 135,300 300,465 465,690 690,1055
store the actual number itself.

2453
01:05:05,240 --> 01:05:07,840
0,365 365,620 620,950 950,1420 2310,2600
Is this numeric digit array

2454
01:05:07,840 --> 01:05:09,175
0,290 580,840 840,1035 1035,1170 1170,1335
here? Well, that's just a

2455
01:05:09,175 --> 01:05:10,180
0,195 195,435 435,585 585,660 660,1005
type cast to an unsigned

2456
01:05:10,180 --> 01:05:11,170
0,195 195,375 375,630 630,825 825,990
char up above. So they're

2457
01:05:11,170 --> 01:05:13,080
0,240 240,645 645,915 915,1430
literally storing your decimal.|
|

2458
01:05:13,080 --> 01:05:15,940
0,290 1090,1395 1395,1605 1605,1910
As a string value.|
作为字符串值。|

2459
01:05:15,940 --> 01:05:16,810
0,120 120,255 255,435 435,660 660,870
And then they use this
然后他们使用这些元数据来找出。

2460
01:05:16,810 --> 01:05:18,740
0,480 480,570 570,735 735,1040
metadata to figure out.|
|

2461
01:05:18,810 --> 01:05:19,820
0,230 230,335 335,500 500,755 755,1010
You know how to interpret
您知道如何将该字符串解释为正确的形式。

2462
01:05:19,820 --> 01:05:21,140
0,225 225,560 880,1155 1155,1260 1260,1320
that string to put it

2463
01:05:21,140 --> 01:05:21,850
0,60 60,150 150,270 270,420 420,710
to be the correct form.|
|

2464
01:05:24,320 --> 01:05:25,630
0,260 260,520 570,845 845,1055 1055,1310
So again, the Harvard doesn't
再说一次，哈佛对此一无所知。这是数据系统SIMPLE嵌入的，所以我们不能只做X+Y，我们可以在C++中做更复杂的算术，你想要开始计算，或者你知道，在查询中使用这些数字类型。这只是两个数字和postgres的加法函数的一个简短片段。正如你所看到的，对于这个结构，有一堆检查，看它是零还是负的，或者是有符号的，或者别的什么。这只是将两个数字相加。

2465
01:05:25,630 --> 01:05:26,365
0,135 135,285 285,420 420,600 600,735
know anything about this. This

2466
01:05:26,365 --> 01:05:27,120
0,90 90,180 180,270 270,435 435,755
is what the data system

2467
01:05:27,170 --> 01:05:28,600
0,260 260,425 425,590 590,850 1200,1430
has simple embedded in, so

2468
01:05:28,600 --> 01:05:29,665
0,105 105,300 300,420 420,710 730,1065
we can't just do X

2469
01:05:29,665 --> 01:05:30,925
0,255 255,575 595,870 870,1065 1065,1260
plus y, we can in

2470
01:05:30,925 --> 01:05:32,185
0,120 120,225 225,485 925,1170 1170,1260
c plus plus we got

2471
01:05:32,185 --> 01:05:34,050
0,75 75,150 150,300 300,605 1135,1865
to do more complicated arithmetic

2472
01:05:34,160 --> 01:05:34,825
0,245 245,350 350,455 455,545 545,665
where you want to start

2473
01:05:34,825 --> 01:05:36,475
0,480 480,875 1105,1335 1335,1440 1440,1650
calculating or you know, using

2474
01:05:36,475 --> 01:05:37,960
0,210 210,450 450,720 720,1085 1135,1485
these numeric types in, in,

2475
01:05:37,960 --> 01:05:39,760
0,225 225,680 1210,1440 1440,1545 1545,1800
in queries. So this is

2476
01:05:39,760 --> 01:05:41,080
0,240 240,450 450,690 690,945 945,1320
just A A brief snippet

2477
01:05:41,080 --> 01:05:42,940
0,195 195,530 940,1245 1245,1515 1515,1860
of the the addition function

2478
01:05:42,940 --> 01:05:44,340
0,270 270,405 405,705 705,915 915,1400
for two numeric and postgres.

2479
01:05:44,810 --> 01:05:45,625
0,245 245,365 365,470 470,590 590,815
And as you can see

2480
01:05:45,625 --> 01:05:46,630
0,225 225,345 345,525 525,705 705,1005
there's a bunch of checks

2481
01:05:46,630 --> 01:05:48,760
0,165 165,360 360,710 1570,1920 1920,2130
for that struct or to

2482
01:05:48,760 --> 01:05:49,945
0,90 90,180 180,390 390,650 820,1185
see whether it's zero or

2483
01:05:49,945 --> 01:05:51,300
0,360 360,675 675,855 855,1065 1065,1355
negative or signed or whatever.

2484
01:05:51,680 --> 01:05:52,915
0,290 290,500 500,890 890,1010 1010,1235
This just adds two numbers

2485
01:05:52,915 --> 01:05:53,800
0,365
together.|
|

2486
01:05:54,210 --> 01:05:55,460
0,230 230,380 380,680 680,980 980,1250
This is obviously way more
这显然比在C-P-U-X+y中调用单个结构要昂贵得多。

2487
01:05:55,460 --> 01:05:57,845
0,350 370,770 1690,2010 2010,2190 2190,2385
expensive than calling a single

2488
01:05:57,845 --> 01:05:58,505
0,225 225,345 345,435 435,570 570,660
structure in the C P

2489
01:05:58,505 --> 01:06:00,620
0,215 535,840 840,1035 1035,1325
U X plus y.|
|

2490
01:06:02,330 --> 01:06:02,815
0,230 230,335 335,365 365,410 410,485
I don't want to get
我不想让人觉得我，我，我在羞辱Postgres我的SQL也有同样的问题，对吗？他们在做同样的事情，他们会把他们的。

2491
01:06:02,815 --> 01:06:06,150
0,105 105,365 505,915 915,1355 2755,3335
the impression I'm, I'm, I'm

2492
01:06:06,890 --> 01:06:08,980
0,580 600,1180 1530,1805 1805,2000 2000,2090
shaming postgres my sql has

2493
01:06:08,980 --> 01:06:10,870
0,120 120,240 240,500 850,1250 1570,1890
the same issue, right? They're

2494
01:06:10,870 --> 01:06:11,680
0,90 90,210 210,360 360,570 570,810
doing the same thing, they're

2495
01:06:11,680 --> 01:06:14,000
0,60 60,180 180,405 405,740
going to store their.|
|

2496
01:06:14,000 --> 01:06:14,705
0,195 195,330 330,510 510,600 600,705
Set their digit as a
将他们的数字设置为VAR图表，可以将其存储为32位整数，但同样，他们有额外的元数据来跟踪实际的数字类型，就像他们将拥有的Postgres一样。

2497
01:06:14,705 --> 01:06:15,470
0,165 165,390 390,540 540,645 645,765
VAR chart that can store

2498
01:06:15,470 --> 01:06:16,355
0,105 105,315 315,555 555,795 795,885
it as a 32 bit

2499
01:06:16,355 --> 01:06:17,540
0,455 475,750 750,885 885,1020 1020,1185
integer, but again, they have

2500
01:06:17,540 --> 01:06:19,160
0,225 225,950 1060,1305 1305,1440 1440,1620
additional metadata to keep track

2501
01:06:19,160 --> 01:06:21,620
0,290 340,630 630,920 1810,2205 2205,2460
of what the numeric type

2502
01:06:21,620 --> 01:06:22,960
0,195 195,440 640,900 900,1050 1050,1340
actually is and just like

2503
01:06:22,980 --> 01:06:24,130
0,530 530,755 755,815 815,905 905,1150
postgres they're going to have.|
|

2504
01:06:25,020 --> 01:06:27,720
0,350 1450,1710 1710,1965 1965,2505 2505,2700
Eh their own implementations of
呃他们自己实现了做额外的检查。

2505
01:06:27,720 --> 01:06:30,980
0,260 1750,2100 2100,2600
doing additional checks.|
|

2506
01:06:32,900 --> 01:06:34,255
0,320 320,470 470,860 860,1115 1115,1355
It's not sexy but you
这并不性感，但你知道你确实需要它。因此，为了节省时间，如果我们有时间，最后我们可以做一个演示，向你展示不同之处。但这是大约两个X的权利，那。

2507
01:06:34,255 --> 01:06:35,340
0,245 265,540 540,690 690,825 825,1085
know you do need it.

2508
01:06:37,610 --> 01:06:38,275
0,230 230,290 290,395 395,530 530,665
So in the sake of

2509
01:06:38,275 --> 01:06:39,130
0,275 325,570 570,645 645,750 750,855
time, if we have time,

2510
01:06:39,130 --> 01:06:39,595
0,75 75,150 150,255 255,375 375,465
in the end we can

2511
01:06:39,595 --> 01:06:40,645
0,75 75,165 165,420 420,810 810,1050
do a demo to show

2512
01:06:40,645 --> 01:06:42,610
0,225 225,605 895,1295 1555,1800 1800,1965
you the difference. But it's

2513
01:06:42,610 --> 01:06:45,060
0,225 225,435 435,680 1390,1790 2050,2450
about two X right, the.|
|

2514
01:06:46,490 --> 01:06:47,970
0,260 260,560 560,910 960,1220 1220,1480
The numeric versions or the
数字版本或数据实现的这些小数的版本，它将大约比。

2515
01:06:48,680 --> 01:06:49,990
0,400 420,770 770,1040 1040,1205 1205,1310
data implemented versions of these

2516
01:06:49,990 --> 01:06:50,875
0,420 420,615 615,660 660,735 735,885
decimals, it would be about

2517
01:06:50,875 --> 01:06:51,900
0,135 135,270 270,510 510,735 735,1025
two X lower than the.|
|

2518
01:06:52,680 --> 01:06:54,480
0,240 240,450 450,690 690,950
Than the harbor versions.|
而不是港湾的版本。|

2519
01:06:57,690 --> 01:06:59,380
0,230 230,335 335,500 500,1030 1290,1690
All right, for nulls the
好的，对于空值，最常见的方法是，对于标头中的每一个两个值，都会有一个位图，跟踪哪些属性被设置为给定的两个值的空值。

2520
01:06:59,550 --> 01:07:00,635
0,260 260,440 440,665 665,845 845,1085
the most common way to

2521
01:07:00,635 --> 01:07:01,565
0,255 255,420 420,570 570,765 765,930
do this is that for

2522
01:07:01,565 --> 01:07:03,560
0,180 180,495 495,1055 1525,1800 1800,1995
every single twople in that

2523
01:07:03,560 --> 01:07:05,240
0,470 670,960 960,1095 1095,1230 1230,1680
header will be a bitmap

2524
01:07:05,240 --> 01:07:06,970
0,180 180,375 375,615 615,920 1330,1730
that keeps track of which

2525
01:07:07,020 --> 01:07:08,300
0,500 500,770 770,965 965,1145 1145,1280
attributes that are set the

2526
01:07:08,300 --> 01:07:09,460
0,195 195,315 315,480 480,720 720,1160
null for that given twople.|
|

2527
01:07:10,320 --> 01:07:11,520
0,400
Right.|
正确的。|

2528
01:07:11,520 --> 01:07:13,275
0,240 240,530 820,1095 1095,1500 1500,1755
And again, the header the
同样，标题这个位图的大小将根据您拥有的属性的数量而变化，我们知道它是否可能为空，因为它在CREATE TABLE语句中。

2529
01:07:13,275 --> 01:07:15,680
0,275 325,585 585,845 985,1535 2005,2405
size of this bitmap will

2530
01:07:16,270 --> 01:07:17,220
0,380 380,650 650,785 785,860 860,950
vary based on the number

2531
01:07:17,220 --> 01:07:18,600
0,180 180,435 435,600 600,860 1120,1380
of attributes you have, which

2532
01:07:18,600 --> 01:07:20,310
0,165 165,470 1240,1515 1515,1635 1635,1710
we know whether it could

2533
01:07:20,310 --> 01:07:21,060
0,90 90,225 225,330 330,540 540,750
be null or not because

2534
01:07:21,060 --> 01:07:21,780
0,165 165,240 240,360 360,510 510,720
it's in the create table

2535
01:07:21,780 --> 01:07:22,880
0,320
statement.|
|

2536
01:07:23,330 --> 01:07:24,745
0,400 540,860 860,1040 1040,1220 1220,1415
Right. Again, the advantage of
正确的。再一次说明了使用模式而不是销毁json的优点。在那里，我们有一个模式。我们知道一个列是否被定义为非空，因此如果它，如果它被声明为非空，我们不需要存储这个位图，或者你不存储它的条目。

2537
01:07:24,745 --> 01:07:26,380
0,195 195,420 420,905 1255,1485 1485,1635
using a schema instead of

2538
01:07:26,380 --> 01:07:27,690
0,285 285,660 660,885 885,1050 1050,1310
destroying json whatever. In there,

2539
01:07:27,920 --> 01:07:28,870
0,245 245,335 335,470 470,770 770,950
we have a schema. We

2540
01:07:28,870 --> 01:07:29,890
0,210 210,435 435,675 675,855 855,1020
we know whether a column

2541
01:07:29,890 --> 01:07:30,985
0,150 150,375 375,690 690,930 930,1095
has been been defined as

2542
01:07:30,985 --> 01:07:32,350
0,180 180,405 405,525 525,785 1015,1365
not null or not, and

2543
01:07:32,350 --> 01:07:33,480
0,240 240,450 450,630 630,810 810,1130
therefore if if it, if

2544
01:07:33,680 --> 01:07:35,980
0,400 840,1205 1205,1570 1920,2180 2180,2300
it has been declared as

2545
01:07:35,980 --> 01:07:37,000
0,150 150,510 510,750 750,930 930,1020
not null, we don't need

2546
01:07:37,000 --> 01:07:38,760
0,120 120,240 240,360 360,770 1360,1760
to store this bitmap or

2547
01:07:38,810 --> 01:07:39,850
0,230 230,440 440,695 695,905 905,1040
you don't store entry for

2548
01:07:39,850 --> 01:07:40,500
0,260
it.|
|

2549
01:07:40,710 --> 01:07:41,420
0,245 245,365 365,470 470,545 545,710
So this is the most
所以这是现在最常见的方法，这确实意味着有一些开销。对于标题中的每一个二进制数，我们都必须有这个位图。

2550
01:07:41,420 --> 01:07:43,325
0,255 255,590 910,1310 1450,1740 1740,1905
common approach now, does mean

2551
01:07:43,325 --> 01:07:44,435
0,180 180,300 300,660 660,900 900,1110
there's some overhead here. For

2552
01:07:44,435 --> 01:07:45,845
0,165 165,485 685,1095 1095,1260 1260,1410
every single tple now in

2553
01:07:45,845 --> 01:07:46,895
0,105 105,485 565,810 810,930 930,1050
the header, we got to

2554
01:07:46,895 --> 01:07:49,920
0,150 150,455 1645,2195
have this bitmap.|
|

2555
01:07:51,240 --> 01:07:52,595
0,350 350,665 665,905 905,1115 1115,1355
Less common, but another approach
不太常见，但另一种方法是设置特殊的值，你基本上可以说在每种类型的值范围内有一些值，如果我有那个值，那么我会假设它是，它是，它是空的。

2556
01:07:52,595 --> 01:07:53,440
0,165 165,285 285,420 420,570 570,845
to do this would be

2557
01:07:54,540 --> 01:07:56,585
0,245 245,395 395,620 620,940 1650,2045
to have special values where

2558
01:07:56,585 --> 01:07:58,060
0,255 255,515 535,870 870,1185 1185,1475
you basically say there's some

2559
01:07:58,350 --> 01:07:59,435
0,335 335,560 560,725 725,920 920,1085
value within the range of

2560
01:07:59,435 --> 01:08:00,335
0,165 165,345 345,465 465,690 690,900
values I could have for

2561
01:08:00,335 --> 01:08:01,805
0,180 180,515 985,1245 1245,1335 1335,1470
each type, that if I

2562
01:08:01,805 --> 01:08:03,425
0,240 240,480 480,780 780,1005 1005,1620
had that value, then I'll

2563
01:08:03,425 --> 01:08:04,715
0,180 180,390 390,555 555,855 855,1290
assume that that it's, it's,

2564
01:08:04,715 --> 01:08:05,960
0,225 225,345 345,695
it's a null.|
|

2565
01:08:06,430 --> 01:08:07,275
0,335 335,515 515,635 635,755 755,845
So if I want to
所以如果我想知道一个30位的整数是不是空的，那么我会说30位的最小值。不管是什么我都有可能是阴性的。如果我的值是那个，那么我会认为它是空的。

2566
01:08:07,275 --> 01:08:08,865
0,150 150,390 390,725 1135,1440 1440,1590
know whether a thirty cub

2567
01:08:08,865 --> 01:08:10,250
0,90 90,450 450,735 735,1020 1020,1385
bit integer is, is null,

2568
01:08:10,540 --> 01:08:12,135
0,245 245,455 455,730 1080,1370 1370,1595
then I'll say the thirty

2569
01:08:12,135 --> 01:08:13,230
0,255 255,510 510,780 780,975 975,1095
bit min number. I could

2570
01:08:13,230 --> 01:08:14,810
0,260 610,990 990,1245 1245,1350 1350,1580
have negative whatever it is.

2571
01:08:15,700 --> 01:08:16,995
0,335 335,575 575,800 800,1010 1010,1295
If my value is that,

2572
01:08:16,995 --> 01:08:17,805
0,240 240,420 420,540 540,660 660,810
then I'll treat that as

2573
01:08:17,805 --> 01:08:18,820
0,365
null.|
|

2574
01:08:19,120 --> 01:08:20,090
0,230 230,365 365,500 500,680 680,970
So it's one less value
所以它少了一个我可以潜在存储的价值，现在我必须在我的系统的其余部分中做一堆额外的事情来跟踪。好的，如果我看的是第三个肘位整数，如果它是最小值，我知道它是空的，不让人们随意插入它。

2575
01:08:20,110 --> 01:08:21,480
0,245 245,350 350,575 575,940 1110,1370
I could potentially store, and

2576
01:08:21,480 --> 01:08:22,140
0,150 150,330 330,390 390,480 480,660
now there's a bunch of

2577
01:08:22,140 --> 01:08:23,145
0,320 370,630 630,750 750,870 870,1005
extra stuff I have to

2578
01:08:23,145 --> 01:08:24,300
0,275 565,825 825,930 930,1050 1050,1155
do in the rest of

2579
01:08:24,300 --> 01:08:25,560
0,120 120,410 700,960 960,1095 1095,1260
my system to keep track

2580
01:08:25,560 --> 01:08:26,430
0,270 270,480 480,540 540,705 705,870
of. Okay, if I'm looking

2581
01:08:26,430 --> 01:08:28,820
0,320 1300,1575 1575,1725 1725,1935 1935,2390
at a third cubit integer,

2582
01:08:28,930 --> 01:08:29,805
0,245 245,335 335,455 455,650 650,875
if it is that min

2583
01:08:29,805 --> 01:08:31,020
0,305 535,780 780,900 900,1035 1035,1215
value that I know it's

2584
01:08:31,020 --> 01:08:32,685
0,320 370,770 1120,1395 1395,1530 1530,1665
null and not let people

2585
01:08:32,685 --> 01:08:34,720
0,315 315,525 525,1085
insert it arbitrarily.|
|

2586
01:08:35,960 --> 01:08:37,840
0,275 275,550 570,970 1440,1685 1685,1880
The worst choice, and I
最糟糕的选择，我没有，我没有截图。我所见过的只有一个系统真正做到的最糟糕的选择是每两个人自己。抱歉，两个池中的每个属性前面都有一个小标志，它会告诉您它是否为空。

2587
01:08:37,840 --> 01:08:39,025
0,240 240,470 790,1020 1020,1125 1125,1185
don't have, I don't have

2588
01:08:39,025 --> 01:08:42,120
0,245 385,935 2305,2550 2550,2745 2745,3095
a screenshot. The worst choice

2589
01:08:42,230 --> 01:08:43,345
0,305 305,425 425,635 635,890 890,1115
I've only seen one system

2590
01:08:43,345 --> 01:08:46,195
0,305 445,720 720,995 1405,1805 2575,2850
ever actually do is for

2591
01:08:46,195 --> 01:08:48,025
0,270 270,665 715,1200 1200,1535 1555,1830
every single twople itself. Sorry,

2592
01:08:48,025 --> 01:08:49,060
0,165 165,455 505,810 810,915 915,1035
every single attribute in the

2593
01:08:49,060 --> 01:08:49,975
0,120 120,380 460,720 720,825 825,915
two pool you have a

2594
01:08:49,975 --> 01:08:50,950
0,210 210,510 510,735 735,885 885,975
little flag in front of

2595
01:08:50,950 --> 01:08:51,610
0,120 120,270 270,375 375,480 480,660
it tells you whether it's

2596
01:08:51,610 --> 01:08:52,820
0,150 150,270 270,530
null or not.|
|

2597
01:08:54,770 --> 01:08:55,600
0,230 230,305 305,470 470,680 680,830
And the reason why this
这很糟糕的原因是，当我们谈到对齐时，我不能有。

2598
01:08:55,600 --> 01:08:58,770
0,165 165,470 670,1035 1035,1400 2770,3170
is terrible is because when

2599
01:08:59,390 --> 01:09:01,105
0,245 245,365 365,530 530,1060 1410,1715
we talk about alignment, right,

2600
01:09:01,105 --> 01:09:03,580
0,240 240,765 765,1140 1140,1535
I can't have a.|
|

2601
01:09:03,580 --> 01:09:05,800
0,260 1300,1545 1545,1785 1785,2055 2055,2220
Uh, you know, I can't
呃，你知道，我不能有一个32位的整数，然后在它前面放一位来表示，嘿，这个东西是不是空的，我必须存储另一位。

2602
01:09:05,800 --> 01:09:06,730
0,75 75,165 165,465 465,555 555,930
have a 32 bit integer

2603
01:09:06,730 --> 01:09:07,810
0,210 210,420 420,690 690,915 915,1080
and put one bit in

2604
01:09:07,810 --> 01:09:08,425
0,165 165,270 270,360 360,480 480,615
front of it to say,

2605
01:09:08,425 --> 01:09:09,250
0,180 180,345 345,570 570,705 705,825
hey, this thing's null or

2606
01:09:09,250 --> 01:09:10,510
0,260 430,690 690,855 855,1050 1050,1260
not, I gotta store another

2607
01:09:10,510 --> 01:09:11,640
0,320
bite.|
|

2608
01:09:11,710 --> 01:09:12,510
0,245 245,380 380,515 515,635 635,800
So now all my thirty
所以现在我所有的30位整数，如果我想成为64位行，可能必须存储双倍大小，所以存储30位整数来跟踪这个空值，如果我把这个标志放在它前面，他们必须存储另外30位，只需要有一位来判断它是否正常。

2609
01:09:12,510 --> 01:09:13,920
0,135 135,560 820,1140 1140,1305 1305,1410
bit integers and if I

2610
01:09:13,920 --> 01:09:14,580
0,90 90,150 150,255 255,540 540,660
want to be 64 bit

2611
01:09:14,580 --> 01:09:15,465
0,240 240,480 480,615 615,735 735,885
line, maybe got to store

2612
01:09:15,465 --> 01:09:17,595
0,105 105,255 255,495 495,815 1855,2130
the double size, so to

2613
01:09:17,595 --> 01:09:18,465
0,195 195,390 390,510 510,780 780,870
store thirty bit integer to

2614
01:09:18,465 --> 01:09:19,170
0,120 120,270 270,390 390,525 525,705
keep track with this null,

2615
01:09:19,170 --> 01:09:19,875
0,105 105,255 255,375 375,540 540,705
if I'm putting this flag

2616
01:09:19,875 --> 01:09:20,655
0,135 135,240 240,315 315,540 540,780
in front of it and

2617
01:09:20,655 --> 01:09:21,255
0,90 90,180 180,285 285,420 420,600
they have to store another

2618
01:09:21,255 --> 01:09:22,245
0,225 225,525 525,780 780,885 885,990
thirty bits, just to have

2619
01:09:22,245 --> 01:09:22,995
0,180 180,360 360,495 495,630 630,750
one bit to say that

2620
01:09:22,995 --> 01:09:24,040
0,135 135,225 225,345 345,605
it's normal or not.|
|

2621
01:09:26,060 --> 01:09:26,770
0,230 230,290 290,350 350,455 455,710
Do I have a screenshot
我在C上有截图吗？我所知道的唯一真正做到这一点的系统是mem SQL，它是的早期名称。

2622
01:09:26,770 --> 01:09:27,610
0,105 105,195 195,285 285,530 550,840
here on the c? The

2623
01:09:27,610 --> 01:09:29,140
0,290 430,830 1000,1245 1245,1365 1365,1530
only system that I know

2624
01:09:29,140 --> 01:09:30,840
0,195 195,375 375,525 525,800 1300,1700
that actually did this was

2625
01:09:31,280 --> 01:09:33,145
0,335 335,850 1320,1595 1595,1730 1730,1865
mem sql, which is the

2626
01:09:33,145 --> 01:09:35,660
0,255 255,615 615,995
earlier name of.|
|

2627
01:09:35,730 --> 01:09:38,330
0,400 990,1310 1310,1580 1580,1930 2280,2600
Of, of single store. So
单店的，单店的。所以尽管他们，你知道，在班上吐唾沫，我没有，我没有截图在这里。我会穿上宽松的衣服。这是最阴暗的想法。这是我见过的最烂的主意之一。

2628
01:09:38,330 --> 01:09:40,010
0,225 225,530 970,1215 1215,1410 1410,1680
despite them, you know, spon

2629
01:09:40,010 --> 01:09:41,720
0,105 105,180 180,440 1270,1515 1515,1710
in the class, I don't,

2630
01:09:41,720 --> 01:09:42,410
0,90 90,240 240,315 315,435 435,690
I don't have the screenshot

2631
01:09:42,410 --> 01:09:43,270
0,165 165,360 360,450 450,570 570,860
here. I'll put on slack.

2632
01:09:44,490 --> 01:09:45,610
0,260 260,365 365,485 485,785 785,1120
That was the shadittiest idea.

2633
01:09:45,780 --> 01:09:46,730
0,365 365,515 515,605 605,680 680,950
It's one of the shittiest

2634
01:09:46,730 --> 01:09:49,140
0,195 195,375 375,465 465,740
ideas I've ever seen.|
|

2635
01:09:49,370 --> 01:09:49,960
0,245 245,335 335,425 425,515 515,590
But they got rid of
但他们去掉了它，因为它非常浪费，而且他们现在做列标题。

2636
01:09:49,960 --> 01:09:51,505
0,230 640,885 885,1065 1065,1200 1200,1545
it because it's super wasteful

2637
01:09:51,505 --> 01:09:52,705
0,120 120,255 255,465 465,785 895,1200
and they do the column

2638
01:09:52,705 --> 01:09:54,540
0,240 240,485
header now.|
|

2639
01:09:57,370 --> 01:09:59,370
0,290 290,560 560,940 1500,1790 1790,2000
For large values like really
对于像非常大的值、可变长度的值这样的大值，这些数据系统不会让您直接将它们存储在页面本身中。

2640
01:09:59,370 --> 01:10:00,650
0,195 195,470 550,840 840,1005 1005,1280
large values, variable length values,

2641
01:10:01,780 --> 01:10:02,895
0,305 305,530 530,740 740,890 890,1115
those data systems are not

2642
01:10:02,895 --> 01:10:03,660
0,210 210,285 285,390 390,570 570,765
going to let you store

2643
01:10:03,660 --> 01:10:05,715
0,290 1210,1545 1545,1725 1725,1830 1830,2055
them directly in the page

2644
01:10:05,715 --> 01:10:06,800
0,365
itself.|
|

2645
01:10:06,990 --> 01:10:08,585
0,335 335,670 750,1040 1040,1265 1265,1595
Right. Again, a page size
正确的。同样，页面大小是由数据系统和其中的每一页定义的。该表必须具有相同的页面大小，对吗？在德国有一个实验系统，他们可以支持可变长度的页面。我们可以忽略这一点。其他人都不会这么做。

2646
01:10:08,585 --> 01:10:10,640
0,360 360,725 1225,1590 1590,1875 1875,2055
is the is defined by

2647
01:10:10,640 --> 01:10:12,050
0,105 105,255 255,560 850,1155 1155,1410
the data system and every

2648
01:10:12,050 --> 01:10:14,140
0,300 300,570 570,890 1090,1490 1690,2090
single page within that. That

2649
01:10:14,610 --> 01:10:16,100
0,400 660,980 980,1160 1160,1325 1325,1490
table has to have the

2650
01:10:16,100 --> 01:10:18,575
0,180 180,390 390,680 1000,1400 1900,2475
same page size, right? There's

2651
01:10:18,575 --> 01:10:20,030
0,135 135,405 405,755 865,1170 1170,1455
an experiment system at Germany

2652
01:10:20,030 --> 01:10:21,275
0,380 430,705 705,885 885,1080 1080,1245
that they can support variable

2653
01:10:21,275 --> 01:10:22,520
0,150 150,425 685,945 945,1095 1095,1245
length pages. We can ignore

2654
01:10:22,520 --> 01:10:23,800
0,260 370,660 660,825 825,990 990,1280
that. Nobody else does that.|
|

2655
01:10:25,380 --> 01:10:26,160
0,165 165,285 285,405 405,585 585,780
But so that means that
但这意味着，就像我在某个时刻需要决定的那样，我是否应该在我的t页面中存储这个很大的VAR字符大字符串？

2656
01:10:26,160 --> 01:10:26,985
0,180 180,360 360,540 540,690 690,825
like at some point I

2657
01:10:26,985 --> 01:10:28,215
0,180 180,485 505,765 765,960 960,1230
to decide, should I store

2658
01:10:28,215 --> 01:10:30,165
0,335 625,1020 1020,1350 1350,1620 1620,1950
this large VAR char large

2659
01:10:30,165 --> 01:10:31,860
0,395 625,975 975,1200 1200,1440 1440,1695
string in in my my

2660
01:10:31,860 --> 01:10:33,380
0,180 180,345 345,465 465,710
t page or not?|
|

2661
01:10:33,790 --> 01:10:34,935
0,290 290,515 515,725 725,950 950,1145
And so for this, if
因此，对于这一点，如果它超过了所有东西，他们将有不同的门槛。什么时候不能存放呢？我们需要把它放到所谓的溢出页面中。因此，在postgresq中，他们称之为祝酒词。我忘了它实际上代表的是什么。但任何大于2千字节的属性，它们都会将其存储为单独的页面。然后在实际的tple本身中，它们将只有一个指针或一个记录ID和一个偏移量，然后指向要查找的实际值的位置。

2662
01:10:34,935 --> 01:10:37,095
0,195 195,695 1165,1530 1530,1890 1890,2160
it exceeds for everything, they're

2663
01:10:37,095 --> 01:10:38,010
0,45 45,120 120,270 270,495 495,915
going to have different thresholds

2664
01:10:38,010 --> 01:10:39,165
0,90 90,350 520,840 840,1020 1020,1155
to say. When can you

2665
01:10:39,165 --> 01:10:40,020
0,240 240,480 480,615 615,750 750,855
not store it? And we

2666
01:10:40,020 --> 01:10:40,620
0,90 90,210 210,315 315,390 390,600
need to put it into

2667
01:10:40,620 --> 01:10:41,580
0,225 225,330 330,450 450,570 570,960
what is called an overflow

2668
01:10:41,580 --> 01:10:43,575
0,290 910,1140 1140,1290 1290,1815 1815,1995
page. So in postgresq they

2669
01:10:43,575 --> 01:10:44,460
0,135 135,240 240,375 375,705 705,885
call it the toast. I

2670
01:10:44,460 --> 01:10:45,210
0,135 135,225 225,375 375,555 555,750
forget what it actually stands

2671
01:10:45,210 --> 01:10:46,725
0,320 460,705 705,950 1030,1335 1335,1515
for. But any attribute that's

2672
01:10:46,725 --> 01:10:48,210
0,150 150,330 330,465 465,1055 1165,1485
larger than two kilobytes, they'll

2673
01:10:48,210 --> 01:10:48,705
0,105 105,165 165,225 225,315 315,495
store it as a separate

2674
01:10:48,705 --> 01:10:50,070
0,335 715,960 960,1065 1065,1200 1200,1365
page. And then in the

2675
01:10:50,070 --> 01:10:51,780
0,165 165,495 495,830 1300,1620 1620,1710
actual tple itself, they'll just

2676
01:10:51,780 --> 01:10:52,890
0,105 105,240 240,710 760,1005 1005,1110
have a pointer or a

2677
01:10:52,890 --> 01:10:54,110
0,165 165,420 420,630 630,855 855,1220
record ID and an offset

2678
01:10:54,220 --> 01:10:55,140
0,290 290,485 485,695 695,830 830,920
that then points to where

2679
01:10:55,140 --> 01:10:55,890
0,90 90,195 195,375 375,585 585,750
to go find the actual

2680
01:10:55,890 --> 01:10:56,960
0,180 180,345 345,525 525,720 720,1070
value that you're looking for.|
|

2681
01:10:57,630 --> 01:10:59,255
0,400 720,995 995,1190 1190,1415 1415,1625
Right. And again, you as
正确的。同样，作为SQL程序员，您不知道这一点，也不关心这一点。您在查询上调用SELECT星号，数据系统负责读取基数二进制数，识别出它指向溢出页面。去获取数据，然后将其复制到缓冲区中。然后为您生成输出。

2682
01:10:59,255 --> 01:11:00,350
0,165 165,420 420,795 795,915 915,1095
the sql programmer, you don't

2683
01:11:00,350 --> 01:11:01,270
0,165 165,345 345,465 465,645 645,920
know this, you don't care.

2684
01:11:01,410 --> 01:11:02,375
0,290 290,440 440,590 590,785 785,965
You call a select star

2685
01:11:02,375 --> 01:11:03,425
0,120 120,225 225,515 715,960 960,1050
on the query and the

2686
01:11:03,425 --> 01:11:04,685
0,150 150,345 345,525 525,815 985,1260
data system is responsible for

2687
01:11:04,685 --> 01:11:07,910
0,275 715,1115 1135,1535 1885,2285 2905,3225
going reading the the base

2688
01:11:07,910 --> 01:11:10,010
0,470 700,1305 1305,1650 1650,1965 1965,2100
twople, recognizing that it's pointing

2689
01:11:10,010 --> 01:11:11,390
0,120 120,180 180,480 480,740 1060,1380
to an overflow page. Go

2690
01:11:11,390 --> 01:11:12,545
0,195 195,375 375,660 660,900 900,1155
get that data and then

2691
01:11:12,545 --> 01:11:14,090
0,255 255,375 375,635 1045,1290 1290,1545
copy it into the buffer.

2692
01:11:14,090 --> 01:11:15,110
0,150 150,315 315,570 570,825 825,1020
That then produces the output

2693
01:11:15,110 --> 01:11:15,940
0,165 165,440
for you.|
|

2694
01:11:15,940 --> 01:11:16,810
0,150 150,255 255,525 525,690 690,870
So it hides underneath the
所以它隐藏在被子下面，实际上是为你做的。

2695
01:11:16,810 --> 01:11:17,770
0,260 280,525 525,720 720,855 855,960
covers that it actually done

2696
01:11:17,770 --> 01:11:18,920
0,150 150,300 300,560
this for you.|
|

2697
01:11:19,650 --> 01:11:21,095
0,305 305,485 485,920 920,1205 1205,1445
Right, so postgres is, is
对，那么Postgres是，是2千字节吗？它们的容量高达8千字节。我认为你可以调整这个，但很明显，在我的se目标中，你不能超过8千字节。溢出大小是当前页面大小的一半，然后在SQL Server中，您可以意外地设置默认大小：如果它超过页面大小，则它将溢出。因此，尝试存储在这个超大属性中的数据大小加上常规数据的大小超过了一页的大小。然后将超大的数据放到另一页上。

2698
01:11:21,095 --> 01:11:22,640
0,195 195,845 925,1275 1275,1455 1455,1545
two kilobytes eh? They have

2699
01:11:22,640 --> 01:11:24,095
0,120 120,210 210,330 330,920 1210,1455
up to eight kilobytes. I

2700
01:11:24,095 --> 01:11:24,695
0,90 90,195 195,315 315,465 465,600
think you can tune this

2701
01:11:24,695 --> 01:11:25,420
0,105 105,195 195,330 330,465 465,725
but it goes up to

2702
01:11:25,800 --> 01:11:26,705
0,260 260,380 380,605 605,755 755,905
obviously you can't exceed eight

2703
01:11:26,705 --> 01:11:28,505
0,575 865,1155 1155,1350 1350,1530 1530,1800
kilobytes in my se goal.

2704
01:11:28,505 --> 01:11:30,155
0,240 240,600 600,905 1015,1395 1395,1650
The overflow size is one

2705
01:11:30,155 --> 01:11:31,120
0,165 165,315 315,465 465,660 660,965
half the current page size

2706
01:11:31,650 --> 01:11:33,010
0,260 260,470 470,755 755,1085 1085,1360
and then in sql server,

2707
01:11:33,690 --> 01:11:35,020
0,485 485,635 635,815 815,1025 1025,1330
surprisingly you can set the

2708
01:11:35,100 --> 01:11:37,180
0,400 1140,1415 1415,1640 1640,1835 1835,2080
the default is if it

2709
01:11:37,320 --> 01:11:38,315
0,350 350,485 485,710 710,890 890,995
exceeds the size of the

2710
01:11:38,315 --> 01:11:40,310
0,275 505,765 765,870 870,1385 1675,1995
page, then it overflows. So

2711
01:11:40,310 --> 01:11:41,675
0,320 550,840 840,1095 1095,1290 1290,1365
the the size of the

2712
01:11:41,675 --> 01:11:42,740
0,165 165,330 330,480 480,785 805,1065
data trying to store in

2713
01:11:42,740 --> 01:11:44,900
0,260 280,855 855,1280 1390,1790 1870,2160
this oversized attribute plus the

2714
01:11:44,900 --> 01:11:46,670
0,240 240,590 1000,1275 1275,1530 1530,1770
regular data, the combination of

2715
01:11:46,670 --> 01:11:47,630
0,255 255,570 570,690 690,840 840,960
that exceeds the size of

2716
01:11:47,630 --> 01:11:49,240
0,90 90,350 580,1230 1230,1350 1350,1610
a page. Then put the

2717
01:11:49,620 --> 01:11:51,310
0,575 575,860 860,1160 1160,1400 1400,1690
oversized data to another page.|
|

2718
01:11:52,240 --> 01:11:53,340
0,400
Right.|
正确的。|

2719
01:11:53,380 --> 01:11:54,345
0,260 260,365 365,515 515,740 740,965
And you can chain these
你可以把这些东西链在一起。因此，假设您出于任何原因想要存储1G或10G的视频，您的数据系统不允许您这样做。然后这个溢出页面，因为它们都必须是相同的固定长度大小，它可以有一个指针来说，好的，这是这个属性的数据范围的数据。但是，顺便说一句，这里有一个指向下一页的指针，您必须沿着该链表进行操作。去拿所有的数据，然后把它们放在一起。

2720
01:11:54,345 --> 01:11:55,605
0,255 255,570 570,915 915,1155 1155,1260
things together. So say you

2721
01:11:55,605 --> 01:11:56,835
0,90 90,210 210,485 715,1020 1020,1230
want to store for whatever

2722
01:11:56,835 --> 01:11:58,160
0,255 255,465 465,630 630,1080 1080,1325
reason, a one gigabyte video

2723
01:11:58,300 --> 01:12:00,075
0,260 260,395 395,785 785,1030 1500,1775
or ten gigabyte video, your

2724
01:12:00,075 --> 01:12:01,830
0,180 180,485 1165,1530 1530,1635 1635,1755
data system couldn't let you

2725
01:12:01,830 --> 01:12:03,585
0,135 135,410 850,1155 1155,1460 1480,1755
do that. And then this

2726
01:12:03,585 --> 01:12:04,635
0,405 405,600 600,780 780,915 915,1050
overflow page, since they all

2727
01:12:04,635 --> 01:12:05,205
0,120 120,180 180,240 240,345 345,570
have to be the same

2728
01:12:05,205 --> 01:12:06,290
0,270 270,480 480,675 675,825 825,1085
fixed length size as well,

2729
01:12:06,820 --> 01:12:07,860
0,260 260,365 365,530 530,800 800,1040
it could just have a

2730
01:12:07,860 --> 01:12:08,910
0,300 300,390 390,615 615,840 840,1050
pointer to say, okay, here's

2731
01:12:08,910 --> 01:12:09,855
0,120 120,315 315,510 510,660 660,945
the data for this range

2732
01:12:09,855 --> 01:12:11,030
0,255 255,360 360,605 655,915 915,1175
of the data for this

2733
01:12:11,170 --> 01:12:12,210
0,455 455,695 695,800 800,935 935,1040
attribute. But oh by the

2734
01:12:12,210 --> 01:12:13,275
0,135 135,330 330,450 450,840 840,1065
way, here's a pointer to

2735
01:12:13,275 --> 01:12:14,325
0,90 90,240 240,545 745,975 975,1050
the next page and you

2736
01:12:14,325 --> 01:12:15,270
0,75 75,180 180,435 435,735 735,945
got to follow along that

2737
01:12:15,270 --> 01:12:16,425
0,180 180,470 610,900 900,1035 1035,1155
linked list. Go get all

2738
01:12:16,425 --> 01:12:17,010
0,120 120,255 255,405 405,510 510,585
the data and put it

2739
01:12:17,010 --> 01:12:18,500
0,150 150,470
back together.|
|

2740
01:12:22,430 --> 01:12:23,425
0,230 230,305 305,470 470,770 770,995
So the last thing you
因此，您可以做的最后一件事就是调用外部文件存储。只是价值储存的转折点。这就是数据库系统不会存储大数据的地方，也就是它管理的页面中的大属性。它会将其写出到您的本地文件系统，然后在内部存储该数据所在位置的uri或url。

2741
01:12:23,425 --> 01:12:24,400
0,105 105,255 255,435 435,690 690,975
can do is call external

2742
01:12:24,400 --> 01:12:25,285
0,255 255,510 510,690 690,795 795,885
file storage. Just turn of

2743
01:12:25,285 --> 01:12:27,100
0,195 195,545 1225,1500 1500,1650 1650,1815
value storage. And this is

2744
01:12:27,100 --> 01:12:29,290
0,290 1150,1440 1440,1725 1725,2025 2025,2190
where the database system is

2745
01:12:29,290 --> 01:12:30,630
0,120 120,210 210,390 390,740 940,1340
not going to store the

2746
01:12:31,730 --> 01:12:33,100
0,275 275,530 530,890 890,1130 1130,1370
the large data, the large

2747
01:12:33,100 --> 01:12:35,650
0,470 790,1190 1840,2175 2175,2370 2370,2550
attribute in pages that it

2748
01:12:35,650 --> 01:12:37,405
0,710 1090,1410 1410,1485 1485,1605 1605,1755
manages. It's going to write

2749
01:12:37,405 --> 01:12:38,275
0,120 120,300 300,495 495,630 630,870
it out to your local

2750
01:12:38,275 --> 01:12:40,720
0,345 345,725 1345,1620 1620,1890 1890,2445
file system and then internally

2751
01:12:40,720 --> 01:12:41,755
0,225 225,390 390,795 795,930 930,1035
store the uri or the

2752
01:12:41,755 --> 01:12:43,225
0,515 685,960 960,1140 1140,1320 1320,1470
url of where that data

2753
01:12:43,225 --> 01:12:44,540
0,270 270,665
is located.|
|

2754
01:12:44,540 --> 01:12:45,605
0,210 210,375 375,540 540,720 720,1065
So that when you query
因此，当您对表进行查询并获取该属性时，它会转到操作系统并获取该属性，这样数据就会将其复制到其缓冲区中，然后将其交回给您。

2755
01:12:45,605 --> 01:12:47,800
0,345 345,585 585,875 1525,1860 1860,2195
against the table and you

2756
01:12:47,850 --> 01:12:49,220
0,260 260,380 380,590 590,1030 1080,1370
go get that attribute, it

2757
01:12:49,220 --> 01:12:50,270
0,225 225,405 405,570 570,780 780,1050
goes to the OS and

2758
01:12:50,270 --> 01:12:51,550
0,285 285,525 525,780 780,990 990,1280
get that, that that data

2759
01:12:51,810 --> 01:12:53,050
0,395 395,485 485,635 635,815 815,1240
copies it into its buffer

2760
01:12:53,070 --> 01:12:53,945
0,245 245,410 410,605 605,725 725,875
and then hands it back

2761
01:12:53,945 --> 01:12:55,300
0,135 135,365
to you.|
|

2762
01:12:55,560 --> 01:12:56,900
0,350 350,680 680,935 935,1100 1100,1340
So in I think only
因此，我认为只有POST Oracle和我的Oracle和SQL服务器才能做到这一点。EM在Oracle中被称为b文件，在Microsoft中被称为文件流。同样，它只是磁盘上一些数据的uri，它执行sys调用，从操作系统和postgres中获取它，您可以为conf外部数据包装执行此操作。

2763
01:12:56,900 --> 01:12:59,825
0,350 670,1230 1230,1520 1930,2330 2410,2925
post Oracle and my Oracle

2764
01:12:59,825 --> 01:13:00,680
0,180 180,450 450,600 600,750 750,855
and sql server can do

2765
01:13:00,680 --> 01:13:02,765
0,260 700,1100 1420,1680 1680,1965 1965,2085
this. EM in Oracle they

2766
01:13:02,765 --> 01:13:04,070
0,135 135,315 315,605 625,975 975,1305
called b files in Microsoft

2767
01:13:04,070 --> 01:13:05,810
0,225 225,375 375,645 645,1190 1450,1740
are called file streams. And

2768
01:13:05,810 --> 01:13:06,845
0,210 210,435 435,555 555,675 675,1035
again it's just a uri

2769
01:13:06,845 --> 01:13:08,060
0,210 210,390 390,645 645,945 945,1215
to some data on on

2770
01:13:08,060 --> 01:13:09,410
0,390 390,675 675,960 960,1170 1170,1350
disk and it does the

2771
01:13:09,410 --> 01:13:10,295
0,195 195,435 435,615 615,750 750,885
sys call to go get

2772
01:13:10,295 --> 01:13:12,440
0,105 105,270 270,575 1705,1980 1980,2145
it from the, from the

2773
01:13:12,440 --> 01:13:14,255
0,180 180,470 940,1245 1245,1665 1665,1815
operating system and postgres you

2774
01:13:14,255 --> 01:13:16,445
0,135 135,330 330,630 630,1025 1945,2190
can do this for the

2775
01:13:16,445 --> 01:13:18,240
0,165 165,390 390,615 615,1115
conf foreign data wrappers.|
|

2776
01:13:18,240 --> 01:13:21,150
0,290 940,1320 1320,1700 1840,2240 2350,2910
EM, there's, there's additional mechanisms
EM，有，有额外的机制来存储数据和云存储。然后，现在在单个SQL界面中，我可以获取数据，并使其看起来就像在表本身中一样。

2777
01:13:21,150 --> 01:13:22,515
0,290 340,615 615,870 870,1140 1140,1365
to store data and cloud

2778
01:13:22,515 --> 01:13:24,105
0,335 355,600 600,845 1105,1395 1395,1590
storage. And then again, now

2779
01:13:24,105 --> 01:13:25,485
0,195 195,360 360,635 715,1080 1080,1380
within a single sql interface,

2780
01:13:25,485 --> 01:13:26,190
0,150 150,255 255,375 375,555 555,705
I can go fetch the

2781
01:13:26,190 --> 01:13:27,555
0,260 460,750 750,990 990,1215 1215,1365
data and have appear as

2782
01:13:27,555 --> 01:13:29,360
0,135 135,255 255,375 375,635 1405,1805
if it was in the

2783
01:13:29,410 --> 01:13:30,820
0,260 260,470 470,820
the table itself.|
|

2784
01:13:31,590 --> 01:13:33,050
0,400 630,920 920,1085 1085,1265 1265,1460
So when we write things
因此，当我们将内容写入这些外部文件时，数据系统不能、不能对其进行任何更改。

2785
01:13:33,050 --> 01:13:34,120
0,195 195,345 345,525 525,765 765,1070
out to these external files,

2786
01:13:34,470 --> 01:13:36,700
0,275 275,500 500,815 815,1180 1830,2230
the data system cannot, cannot

2787
01:13:36,840 --> 01:13:38,020
0,245 245,410 410,710 710,935 935,1180
make any changes to it.|
|

2788
01:13:38,730 --> 01:13:40,145
0,400 630,980 980,1145 1145,1235 1235,1415
Right. It's, it's like you've
正确的。就像，就像你写到了文件系统一样。我不会去做适当的更新。我无法更新它。我只能读入它，如果我删除，如果我删除指向这个文件的那两个东西，有机制决定。我是否也想删除该文件？

2789
01:13:40,145 --> 01:13:41,180
0,120 120,405 405,705 705,885 885,1035
written out to the file

2790
01:13:41,180 --> 01:13:42,035
0,285 285,570 570,675 675,780 780,855
system. I'm not going to

2791
01:13:42,035 --> 01:13:42,905
0,150 150,315 315,465 465,630 630,870
go and make in place

2792
01:13:42,905 --> 01:13:43,745
0,270 270,405 405,480 480,585 585,840
updates to it. I can't

2793
01:13:43,745 --> 01:13:44,690
0,180 180,420 420,645 645,765 765,945
update it. I can only

2794
01:13:44,690 --> 01:13:45,515
0,195 195,315 315,525 525,735 735,825
read it in and then

2795
01:13:45,515 --> 01:13:47,075
0,75 75,270 270,570 570,905 1315,1560
if I delete the, if

2796
01:13:47,075 --> 01:13:48,155
0,180 180,405 405,570 570,855 855,1080
I delete the twople that

2797
01:13:48,155 --> 01:13:49,415
0,315 315,825 825,990 990,1140 1140,1260
thing that's pointing to this

2798
01:13:49,415 --> 01:13:51,320
0,275 685,1035 1035,1545 1545,1770 1770,1905
file, there's mechanisms decide. Do

2799
01:13:51,320 --> 01:13:51,875
0,120 120,255 255,330 330,420 420,555
I also want to delete

2800
01:13:51,875 --> 01:13:53,120
0,135 135,300 300,480 480,755
the file as well?|
|

2801
01:13:54,400 --> 01:13:55,400
0,260 260,395 395,515 515,680 680,1000
And so the reason why,
因此，您可能想要这样做的原因是，正如我所说的，您不想在数据库系统中存储10 GB的文件。

2802
01:13:55,420 --> 01:13:56,535
0,275 275,545 545,815 815,980 980,1115
why this you may want

2803
01:13:56,535 --> 01:13:57,410
0,120 120,270 270,405 405,570 570,875
to do this is because,

2804
01:13:57,910 --> 01:13:58,800
0,245 245,350 350,515 515,680 680,890
as I said, you don't

2805
01:13:58,800 --> 01:13:59,565
0,75 75,210 210,435 435,630 630,765
want to store like a

2806
01:13:59,565 --> 01:14:00,585
0,180 180,585 585,750 750,900 900,1020
ten gigabyte file in your

2807
01:14:00,585 --> 01:14:02,500
0,240 240,605
database system.|
|

2808
01:14:02,770 --> 01:14:05,430
0,400 1410,1670 1670,1910 1910,2290 2310,2660
For for management reasons, because
出于管理原因，因为日志记录变得昂贵，但通常情况下，数据库管理系统存储在更高端的硬件上。

2809
01:14:05,430 --> 01:14:06,320
0,210 210,345 345,420 420,585 585,890
then it's a log record

2810
01:14:07,570 --> 01:14:09,030
0,275 275,500 500,850 960,1265 1265,1460
that becomes expensive, but also

2811
01:14:09,030 --> 01:14:11,130
0,290 670,1070 1180,1545 1545,1830 1830,2100
too typically, database management systems

2812
01:14:11,130 --> 01:14:13,155
0,240 240,480 480,770 1510,1815 1815,2025
are stored on higher end

2813
01:14:13,155 --> 01:14:14,260
0,305
hardware.|
|

2814
01:14:14,370 --> 01:14:16,060
0,400 600,875 875,1055 1055,1325 1325,1690
And that makes storage expensive
如果你使用亚马逊RDS，这会使存储空间变得昂贵。

2815
01:14:16,290 --> 01:14:18,430
0,245 245,380 380,670 1440,1700 1700,2140
if you use Amazon rds.|
|

2816
01:14:19,360 --> 01:14:20,230
0,195 195,300 300,435 435,660 660,870
I think they charge four
我想他们会多收4倍的存储费用，然后你会从E B S那里得到，如果你有一个本地连接的磁盘，E B S当然会更高。因此，您不希望存储这些大文件，也不希望将您自己的文件直接只读存储在由数据系统管理的文件所管理的数据中。让一些更便宜的存储设备上的操作系统为您处理这一问题。

2817
01:14:20,230 --> 01:14:21,630
0,195 195,495 495,765 765,1035 1035,1400
X more for storage and

2818
01:14:21,650 --> 01:14:22,330
0,245 245,335 335,440 440,560 560,680
then you get from E

2819
01:14:22,330 --> 01:14:23,740
0,105 105,350 790,1065 1065,1245 1245,1410
B S and certainly E

2820
01:14:23,740 --> 01:14:24,340
0,90 90,180 180,300 300,450 450,600
B S is even more

2821
01:14:24,340 --> 01:14:24,985
0,105 105,180 180,255 255,345 345,645
if you have a locally

2822
01:14:24,985 --> 01:14:27,835
0,305 385,735 735,1295 2485,2745 2745,2850
attached attached disk. So you

2823
01:14:27,835 --> 01:14:28,375
0,135 135,180 180,225 225,315 315,540
don't want to be storing

2824
01:14:28,375 --> 01:14:29,380
0,195 195,435 435,720 720,900 900,1005
these large files and maybe

2825
01:14:29,380 --> 01:14:31,675
0,105 105,240 240,405 405,680 1960,2295
your own read only directly

2826
01:14:31,675 --> 01:14:32,425
0,180 180,330 330,480 480,585 585,750
in the in the data

2827
01:14:32,425 --> 01:14:33,450
0,240 240,390 390,555 555,720 720,1025
that's managed by the the

2828
01:14:33,950 --> 01:14:35,155
0,400 540,875 875,1025 1025,1085 1085,1205
the files that are managed

2829
01:14:35,155 --> 01:14:36,400
0,120 120,210 210,345 345,635 985,1245
by the data system. Let

2830
01:14:36,400 --> 01:14:37,270
0,150 150,345 345,525 525,675 675,870
the OS on some cheaper

2831
01:14:37,270 --> 01:14:38,790
0,320 610,915 915,1110 1110,1260 1260,1520
storage handle that for you.|
|

2832
01:14:41,080 --> 01:14:42,410
0,245 245,410 410,590 590,935 935,1330
So there's a paper from
有一篇来自吉姆·格雷15岁的论文，他是90年代数据库巡回奖的获得者之一。他发明了很多我们这学期讨论的东西。嗯，他有一篇几年前在微软写的论文，讨论了是否应该在、在、在几天内存储大量数据。我认为对于他们的建议，他们说的是任何大于200千字节的内容。

2833
01:14:43,510 --> 01:14:44,880
0,335 335,545 545,710 710,1000 1080,1370
fifteen years old now from

2834
01:14:44,880 --> 01:14:46,380
0,210 210,450 450,615 615,860 1270,1500
Jim gray, which is one

2835
01:14:46,380 --> 01:14:47,490
0,60 60,120 120,225 225,500 850,1110
of the guys that the

2836
01:14:47,490 --> 01:14:48,345
0,195 195,285 285,375 375,765 765,855
toururing award for databases in

2837
01:14:48,345 --> 01:14:49,515
0,105 105,515 655,900 900,1005 1005,1170
the nineties. And he invented

2838
01:14:49,515 --> 01:14:50,040
0,135 135,240 240,330 330,405 405,525
a lot of the stuff

2839
01:14:50,040 --> 01:14:51,050
0,150 150,300 300,525 525,690 690,1010
we're talking about this semester.

2840
01:14:51,280 --> 01:14:52,515
0,400 720,950 950,1010 1010,1085 1085,1235
Um, he had a paper

2841
01:14:52,515 --> 01:14:54,230
0,180 180,455 985,1275 1275,1440 1440,1715
he wrote for at Microsoft

2842
01:14:54,400 --> 01:14:55,290
0,245 245,350 350,530 530,740 740,890
a few years ago that

2843
01:14:55,290 --> 01:14:56,960
0,135 135,285 285,560 1150,1410 1410,1670
talks about whether should you

2844
01:14:56,980 --> 01:14:58,650
0,400 420,785 785,1150 1170,1445 1445,1670
store large data in, in,

2845
01:14:58,650 --> 01:15:00,195
0,225 225,465 465,705 705,980 1300,1545
in days or not. And

2846
01:15:00,195 --> 01:15:01,485
0,105 105,330 330,555 555,705 705,1290
I think for their recommendation,

2847
01:15:01,485 --> 01:15:02,655
0,210 210,450 450,690 690,900 900,1170
they said anything larger than

2848
01:15:02,655 --> 01:15:04,460
0,395 475,1205
200 kilobytes.|
|

2849
01:15:04,530 --> 01:15:07,685
0,335 335,1000 2580,2885 2885,3050 3050,3155
Stored externally. Again, this is
储存在外部。再说一次，这是不久前的事了。我不再建议这样做了，实际上我们有一个发明了SQL Light的人。他来到了CMU，做了一次演讲。

2850
01:15:07,685 --> 01:15:09,935
0,105 105,285 285,510 510,815 1945,2250
a while ago. I I

2851
01:15:09,935 --> 01:15:11,050
0,150 150,330 330,480 480,750 750,1115
I wouldn't recommend that anymore

2852
01:15:11,730 --> 01:15:12,455
0,290 290,410 410,485 485,605 605,725
and actually we had the

2853
01:15:12,455 --> 01:15:13,490
0,120 120,270 270,465 465,780 780,1035
guy that invented sql light.

2854
01:15:13,490 --> 01:15:14,570
0,285 285,480 480,630 630,945 945,1080
He came to cmu, gave

2855
01:15:14,570 --> 01:15:15,660
0,120 120,380
a talk.|
|

2856
01:15:15,790 --> 01:15:17,310
0,320 320,545 545,740 740,1030 1260,1520
Five years ago, so, and
五年前，所以，他提到了。

2857
01:15:17,310 --> 01:15:18,700
0,120 120,345 345,710
he mentioned that.|
|

2858
01:15:19,100 --> 01:15:20,515
0,290 290,560 560,905 905,1235 1235,1415
In his experience, it's actually
根据他的经验，实际上最好将东西存储在SQL Light中，就像你像手机应用程序一样运行一样。因此，如果您的应用程序有一堆缩略图图像，最好将其存储在数据库系统中，因为现在当您检索它们时，您的应用程序已经必须处理数据库系统的打开，因为文件已经打开。因此，直接从数据系统获取这些缩略图要比对磁盘上的一堆文件进行一系列f打开和f读取要快得多。

2859
01:15:20,515 --> 01:15:21,580
0,165 165,330 330,480 480,720 720,1065
better to store things in

2860
01:15:21,580 --> 01:15:23,335
0,285 285,585 585,830 1150,1530 1530,1755
in sql light, like if

2861
01:15:23,335 --> 01:15:24,310
0,135 135,365 505,735 735,825 825,975
you're running like a phone

2862
01:15:24,310 --> 01:15:25,240
0,290 430,660 660,735 735,825 825,930
APP. So if you have

2863
01:15:25,240 --> 01:15:25,930
0,105 105,270 270,495 495,630 630,690
like your application has a

2864
01:15:25,930 --> 01:15:27,655
0,90 90,225 225,660 660,920 1420,1725
bunch of thumbnails images, you're

2865
01:15:27,655 --> 01:15:28,450
0,120 120,285 285,525 525,705 705,795
better off storing that in

2866
01:15:28,450 --> 01:15:30,175
0,75 75,255 255,590 610,1010 1420,1725
the database system because now

2867
01:15:30,175 --> 01:15:30,910
0,150 150,300 300,465 465,585 585,735
when you, when you go

2868
01:15:30,910 --> 01:15:33,025
0,375 375,620 1180,1530 1530,1845 1845,2115
retrieve them, your your application

2869
01:15:33,025 --> 01:15:33,925
0,225 225,435 435,570 570,735 735,900
already has to handle to

2870
01:15:33,925 --> 01:15:35,220
0,90 90,270 270,600 600,945 945,1295
the database system open as

2871
01:15:35,240 --> 01:15:36,300
0,245 245,365 365,500 500,710 710,1060
the file is already open.

2872
01:15:36,380 --> 01:15:37,435
0,215 215,335 335,485 485,755 755,1055
So it's much faster to

2873
01:15:37,435 --> 01:15:38,680
0,180 180,315 315,480 480,755 955,1245
to go get those those

2874
01:15:38,680 --> 01:15:39,835
0,495 495,720 720,900 900,1005 1005,1155
thumbnails directly from the data

2875
01:15:39,835 --> 01:15:41,155
0,305 565,900 900,1110 1110,1230 1230,1320
system versus having to do

2876
01:15:41,155 --> 01:15:41,890
0,75 75,165 165,270 270,480 480,735
a bunch of f opens

2877
01:15:41,890 --> 01:15:43,180
0,135 135,270 270,770 1030,1245 1245,1290
and f reads to a

2878
01:15:43,180 --> 01:15:44,220
0,90 90,195 195,345 345,525 525,1040
bunch of files on disk.|
|

2879
01:15:45,810 --> 01:15:46,640
0,245 245,335 335,455 455,650 650,830
So I would say, I
所以我会说，我的意思是，这纯粹是猜测。

2880
01:15:46,640 --> 01:15:48,280
0,260 520,780 780,915 915,1065 1065,1640
mean, this is pure conjecture.|
|

2881
01:15:49,180 --> 01:15:50,160
0,320 320,560 560,650 650,800 800,980
Fifty megs or less is
50兆或更少可能就可以了。除此之外，您都希望使用外部存储。

2882
01:15:50,160 --> 01:15:51,555
0,255 255,600 600,900 900,1125 1125,1395
probably okay. Anything beyond that,

2883
01:15:51,555 --> 01:15:52,410
0,210 210,300 300,375 375,570 570,855
you want to use external

2884
01:15:52,410 --> 01:15:53,460
0,320
storage.|
|

2885
01:15:53,700 --> 01:15:55,415
0,395 395,995 995,1220 1220,1595 1595,1715
And orm like django and
而像Django和其他应用程序框架这样的ORM，他们有为您处理这一问题的机制。

2886
01:15:55,415 --> 01:15:57,035
0,195 195,545 775,1095 1095,1440 1440,1620
other other application frameworks, they

2887
01:15:57,035 --> 01:15:58,460
0,195 195,705 705,990 990,1260 1260,1425
have mechanisms to handle that

2888
01:15:58,460 --> 01:15:59,440
0,150 150,410
for you.|
|

2889
01:15:59,880 --> 01:16:00,880
0,400
Then.|
然后。|

2890
01:16:03,240 --> 01:16:05,270
0,400 510,770 770,920 920,1210 1740,2030
Uh so next class next
嗯，所以下一节课，我们将继续讨论存储，谈论存储模型，然后是柱子和烘烤存储，这将再次向你们解释为什么Ducteeb比顺序灯快，在那个笔记上，Ducteeb会寄给我贴纸，如果你想要一个，我有别针，它也有罂粟花，每克28克，这取决于它是不是做饭，你还没有打到暴徒，还是让你闭嘴，我用夹子的底部打你，告诉你向上看，展示它是什么，打你的脸，我得用黑板轻拍一下F不能追踪那个词，就像大便，你不能在多米尼加系花边，或者你得叫我多米尼加。

2891
01:16:05,270 --> 01:16:06,670
0,210 210,450 450,765 765,1080 1080,1400
class will then continue on

2892
01:16:06,870 --> 01:16:08,405
0,400 660,905 905,1055 1055,1265 1265,1535
storage talk about storage models

2893
01:16:08,405 --> 01:16:10,450
0,210 210,360 360,750 750,1025 1645,2045
and then columns versus uh

2894
01:16:11,070 --> 01:16:13,355
0,400 630,1205 1205,1600 1890,2150 2150,2285
ro roast storage and this

2895
01:16:13,355 --> 01:16:14,345
0,135 135,285 285,575 595,870 870,990
will be again explain to

2896
01:16:14,345 --> 01:16:16,070
0,150 150,455 625,1305 1305,1485 1485,1725
you why ducteeb is faster

2897
01:16:16,070 --> 01:16:17,510
0,240 240,510 510,770 1000,1275 1275,1440
than sequqel light and on

2898
01:16:17,510 --> 01:16:19,190
0,195 195,500 880,1110 1110,1425 1425,1680
that note the ductee bb

2899
01:16:19,190 --> 01:16:20,915
0,135 135,270 270,435 435,890 1450,1725
will sent me stickers if

2900
01:16:20,915 --> 01:16:22,400
0,135 135,300 300,605 1015,1305 1305,1485
you want one come get

2901
01:16:22,400 --> 01:16:24,040
0,290 670,930 930,1065 1065,1305 1305,1640
one I have pins too

2902
01:16:24,480 --> 01:16:44,345
0,400 18480,18965 18965,19115 19115,19265 19265,19865
it poppy with the motherfuck

2903
01:16:44,345 --> 01:16:46,090
0,270 270,575 655,1200 1200,1395 1395,1745
hook up 28 a gram

2904
01:16:46,170 --> 01:16:47,270
0,335 335,560 560,725 725,950 950,1100
depending on if it's cook

2905
01:16:47,270 --> 01:16:48,410
0,290 400,660 660,885 885,1005 1005,1140
up you ain't hit the

2906
01:16:48,410 --> 01:16:49,775
0,195 195,530 670,975 975,1170 1170,1365
mob yet still got your

2907
01:16:49,775 --> 01:16:50,855
0,180 180,405 405,690 690,945 945,1080
shut up I smack you

2908
01:16:50,855 --> 01:16:52,055
0,120 120,270 270,510 510,840 840,1200
with the bottom of clip

2909
01:16:52,055 --> 01:16:53,360
0,225 225,390 390,585 585,875 1015,1305
tell you look up show

2910
01:16:53,360 --> 01:16:54,245
0,150 150,255 255,390 390,600 600,885
me what it sa at

2911
01:16:54,245 --> 01:16:55,265
0,225 225,375 375,555 555,765 765,1020
for a blow your face

2912
01:16:55,265 --> 01:16:56,885
0,300 300,540 540,780 780,1320 1320,1620
back I gotta blockboard taps

2913
01:16:56,885 --> 01:16:58,670
0,240 240,510 510,885 885,1110 1110,1785
the f can't trace thatyl

2914
01:16:58,670 --> 01:16:59,900
0,165 165,405 405,705 705,945 945,1230
is like t for poop

2915
01:16:59,900 --> 01:17:00,965
0,225 225,540 540,735 735,915 915,1065
you can't lace that at

2916
01:17:00,965 --> 01:17:02,555
0,150 150,915 915,1170 1170,1335 1335,1590
the Dominican or you got

2917
01:17:02,555 --> 01:17:03,620
0,255 255,420 420,1035
call me Dominican.|
|

2918
01:17:03,690 --> 01:17:05,420
0,350 350,785 785,1040 1040,1460 1460,1730
Black sclly black leather, black
黑色的黑色皮革，黑色的松木装饰着我整个黑色肮脏的大门，把你送到珍珠般的大门。你让中国去滑冰，这是你的第一个错误。我排队要的那块蛋糕，你们家的份量，我的份量是活的。

2919
01:17:05,420 --> 01:17:07,055
0,345 345,855 855,1050 1050,1305 1305,1635
sued timberlands my whole black

2920
01:17:07,055 --> 01:17:08,150
0,300 300,525 525,735 735,930 930,1095
dirty gate to send you

2921
01:17:08,150 --> 01:17:09,485
0,135 135,285 285,645 645,920 1060,1335
to the pearly gates. You

2922
01:17:09,485 --> 01:17:10,640
0,135 135,630 630,780 780,945 945,1155
get youravat China to skate

2923
01:17:10,640 --> 01:17:11,770
0,150 150,345 345,465 465,735 735,1130
and that's your first mistake.

2924
01:17:12,000 --> 01:17:13,085
0,290 290,470 470,725 725,935 935,1085
I in line for that

2925
01:17:13,085 --> 01:17:14,890
0,195 195,375 375,665 925,1325 1405,1805
cake, your family weight, my

2926
01:17:15,270 --> 01:17:24,548
0,335 335,665 665,1060 3360,3760
weight the the living.|
|
