1
00:00:32,530 --> 00:00:34,935
0,275 275,410 410,650 650,1150 2130,2405
I heard a rumor,| I
我听到谣言，|我听说你曾经和 Larry Ellison 的女朋友约会。

2
00:00:34,935 --> 00:00:36,320
0,225 225,420 420,570 570,840 840,1385
heard {you,used,to} date Larry Ellison's

3
00:00:36,580 --> 00:00:40,040
0,400
girlfriend.|
|

4
00:00:44,640 --> 00:00:45,500
0,245 245,425 425,620 620,755 755,860
What happened, he stole it
发生了什么，他从你那里偷走的。

5
00:00:45,500 --> 00:00:49,780
0,105 105,350
from you.|
|

6
00:00:53,880 --> 00:00:54,635
0,320 320,395 395,515 515,635 635,755
We'll come back to that
我们稍后再来讨论这一点，

7
00:00:54,635 --> 00:00:57,920
0,275 2095,2505 2505,2850 2850,2970 2970,3285
later,| Larry Ellison, the founder
|Larry Ellison ， Oracle 的创始人，

8
00:00:57,920 --> 00:00:59,630
0,480 480,690 690,840 840,1130 1420,1710
Oracle,| he is the fifth
|他是世界第五大富豪，

9
00:00:59,630 --> 00:01:00,820
0,390 390,675 675,840 840,930 930,1190
richest person in the world,|
|

10
00:01:01,230 --> 00:01:02,530
0,260 260,575 575,680 680,1055 1055,1300
he owns a Hawaiian island,|
他拥有一座夏威夷小岛，|

11
00:01:03,120 --> 00:01:04,630
0,365 365,620 620,755 755,875 875,1510
all pay for by databases,|
所有费用都由数据库支付，|

12
00:01:05,070 --> 00:01:06,185
0,335 335,440 440,560 560,770 770,1115
that's why this class exists,
这就是这个班级存在的原因。

13
00:01:06,185 --> 00:01:11,320
0,395 3385,3885 3885,4205 4345,4740 4740,5135
{all,right}.| Administrative stuff,| so the
|行政方面的事，|家庭作业 #1 ，

14
00:01:11,520 --> 00:01:13,955
0,365 365,730 1500,1790 1790,2075 2075,2435
homework #1,| we do this
|我们在星期天， 10 号做，

15
00:01:13,955 --> 00:01:15,740
0,270 270,555 555,825 825,1115 1435,1785
coming Sunday, the 10th,| project
|项目 #0 也是在 10 号截止，

16
00:01:15,740 --> 00:01:16,625
0,270 270,510 510,675 675,780 780,885
#0 is also due the

17
00:01:16,625 --> 00:01:17,960
0,245 475,795 795,975 975,1125 1125,1335
10th,| who here has not
|在这里谁还没有开始项目 #0 ？

18
00:01:17,960 --> 00:01:19,440
0,240 240,525 525,890
started project #0?|
|

19
00:01:20,150 --> 00:01:21,940
0,400 420,680 680,940
One, why not,
一个，为什么不（开始），两个。

20
00:01:21,940 --> 00:01:23,200
0,380
two.|
|

21
00:01:24,030 --> 00:01:24,910
0,215 215,275 275,380 380,620 620,880
Do you know {C++ -}?|
你知道 C++ 吗？|

22
00:01:26,480 --> 00:01:27,655
0,290 290,380 380,640 900,1115 1115,1175
That a no, do you
那就是不，你知道 C++ 吗？

23
00:01:27,655 --> 00:01:29,120
0,245 265,665
know C++?|
|

24
00:01:29,670 --> 00:01:30,965
0,400 450,770 770,935 935,1055 1055,1295
Now, okay, you should really
好的，你真的应该开始了，

25
00:01:30,965 --> 00:01:33,845
0,270 270,575 1855,2255 2515,2775 2775,2880
start,| because if if you
|因为如果你的 C++ 为零，

26
00:01:33,845 --> 00:01:34,840
0,195 195,450 450,600 600,720 720,995
know zero {C++ - -},|
|

27
00:01:35,160 --> 00:01:35,945
0,260 260,380 380,470 470,590 590,785
it will be a struggle,|
这将是一个[斗争]，|

28
00:01:35,945 --> 00:01:37,310
0,180 180,455 535,825 825,1055 1105,1365
and again we're not trying
我们这么做不是为了折磨你，

29
00:01:37,310 --> 00:01:38,030
0,105 105,210 210,345 345,480 480,720
to do this to torture

30
00:01:38,030 --> 00:01:39,020
0,230 280,600 600,720 720,885 885,990
you,| it's really meant to
|这真的意味着，

31
00:01:39,020 --> 00:01:40,580
0,90 90,350 1030,1305 1305,1440 1440,1560
be like,| this is what
|这就是课程的其他部分，

32
00:01:40,580 --> 00:01:41,105
0,90 90,195 195,300 300,390 390,525
the rest of the course

33
00:01:41,105 --> 00:01:41,645
0,135 135,225 225,285 285,390 390,540
is going to be,| like
|就项目而言，

34
00:01:41,645 --> 00:01:42,370
0,135 135,270 270,375 375,465 465,725
in terms of the projects,|
|

35
00:01:42,780 --> 00:01:43,775
0,290 290,455 455,710 710,845 845,995
if you don't know how
如果你不知道如何编写 C++ ，

36
00:01:43,775 --> 00:01:44,720
0,120 120,375 375,600 600,735 735,945
to write {C++ - -}|
|

37
00:01:44,720 --> 00:01:45,470
0,165 165,315 315,375 375,480 480,750
and don't how to debug
也不知道如何调试它，

38
00:01:45,470 --> 00:01:46,655
0,290 700,990 990,1035 1035,1080 1080,1185
it,| you're going to have
|你就会有问题，

39
00:01:46,655 --> 00:01:49,250
0,275 1255,1575 1575,1830 1830,2165 2215,2595
problems,| {printf -} or standard
|printf 或标准 cout 不是调试方法，

40
00:01:49,250 --> 00:01:50,300
0,240 240,435 435,660 660,870 870,1050
{cout -} is not a

41
00:01:50,300 --> 00:01:53,720
0,315 315,650 3070,3300 3300,3360 3360,3420
debug method,| you want to
|你希望使用调试器，

42
00:01:53,720 --> 00:01:54,815
0,75 75,165 165,615 615,870 870,1095
use a debugger| and then
|然后项目 #1 将发布，

43
00:01:54,815 --> 00:01:55,990
0,315 315,570 570,720 720,870 870,1175
project #1 will be released,|
|

44
00:01:57,030 --> 00:01:57,635
0,260 260,350 350,440 440,500 500,605
we supposed to go out
我们今天应该放出，

45
00:01:57,635 --> 00:01:58,730
0,275 445,735 735,870 870,945 945,1095
today,| probably will come out
|可能会在星期五出来，

46
00:01:58,730 --> 00:02:01,010
0,320 1480,1755 1755,2040 2040,2145 2145,2280
Friday| and that'll be on
|这将在缓冲池上，

47
00:02:01,010 --> 00:02:01,865
0,105 105,345 345,510 510,675 675,855
the buffer pool,| which will
|一周半之后开始教学。

48
00:02:01,865 --> 00:02:03,050
0,195 195,465 465,845 865,1110 1110,1185
start teaching in in a

49
00:02:03,050 --> 00:02:05,240
0,90 90,210 210,470 1600,1935 1935,2190
week and half.| Any questions
|关于家庭作业 #1 或项目 #0 有什么问题吗？

50
00:02:05,240 --> 00:02:06,230
0,195 195,405 405,615 615,765 765,990
about homework #1 or project

51
00:02:06,230 --> 00:02:07,360
0,350
#0?|
|

52
00:02:09,860 --> 00:02:12,370
0,400 1200,1600 1890,2180 2180,2330 2330,2510
Okay, {all,right}, {jump,to} the material.|
好的，跳到材料。|

53
00:02:12,370 --> 00:02:13,570
0,255 255,540 540,825 825,1035 1035,1200
So last class we spent
上一节课，我们讨论了 SQL ，

54
00:02:13,570 --> 00:02:16,530
0,210 210,510 510,890 1240,1790 2560,2960
time talking about SQL| and
|以及所有现代的东西，

55
00:02:16,730 --> 00:02:18,010
0,400 480,725 725,905 905,1145 1145,1280
all the modern things,| you
|你可以做 CTE ，横向连接，嵌套查询，窗口函数等。

56
00:02:18,010 --> 00:02:18,840
0,75 75,165 165,255 255,390 390,830
can do with the CTE,

57
00:02:18,860 --> 00:02:20,560
0,470 470,860 860,1190 1190,1505 1505,1700
LATERAL JOINs, nested queries, window

58
00:02:20,560 --> 00:02:22,885
0,285 285,525 525,690 690,980 2020,2325
functions and so forth.| Prior
|在此之前，我们讨论了关系模型和关系代数，

59
00:02:22,885 --> 00:02:23,635
0,150 150,270 270,405 405,585 585,750
to that we talked about

60
00:02:23,635 --> 00:02:25,470
0,285 285,635 685,990 990,1275 1275,1835
{the,relational} model and relational algebra,|
|

61
00:02:25,850 --> 00:02:27,780
0,400 840,1085 1085,1250 1250,1550 1550,1930
And so at this point,|
在这一点上，|

62
00:02:27,920 --> 00:02:30,625
0,640 1530,1805 1805,2345 2345,2540 2540,2705
that's the logical view of
这就是我们将要看到的数据库系统的逻辑视图，

63
00:02:30,625 --> 00:02:31,615
0,165 165,315 315,555 555,840 840,990
what the database system is

64
00:02:31,615 --> 00:02:32,305
0,90 90,195 195,345 345,540 540,690
going to look like,| that
|在这学期剩下的时间里，我们在某种程度上是在构思，

65
00:02:32,305 --> 00:02:33,025
0,120 120,165 165,330 330,600 600,720
we're going to, we're sort

66
00:02:33,025 --> 00:02:34,480
0,240 240,840 840,1110 1110,1320 1320,1455
of mentally construct throughout the

67
00:02:34,480 --> 00:02:36,040
0,90 90,195 195,300 300,620 1210,1560
rest of the semester,| so
|所以我们不会回到这些，讨论这些事情，

68
00:02:36,040 --> 00:02:36,700
0,255 255,360 360,480 480,540 540,660
we're not going to go

69
00:02:36,700 --> 00:02:37,660
0,225 225,405 405,585 585,795 795,960
back to these, discuss these

70
00:02:37,660 --> 00:02:38,665
0,210 210,390 390,585 585,765 765,1005
things,| but we'll see how
|但我们将看到，我们需要知道 SQL 是什么样子的关系模型，

71
00:02:38,665 --> 00:02:39,370
0,180 180,285 285,405 405,540 540,705
we need to know what

72
00:02:39,370 --> 00:02:40,540
0,240 240,390 390,615 615,930 930,1170
SQL looks like relational model

73
00:02:40,540 --> 00:02:41,710
0,320 430,675 675,795 795,960 960,1170
is,| in order to build
|为了构建系统的各个部分，

74
00:02:41,710 --> 00:02:42,595
0,165 165,360 360,615 615,765 765,885
the various parts of the

75
00:02:42,595 --> 00:02:44,230
0,275 745,1020 1020,1125 1125,1365 1365,1635
system,| we'll be discussing going
|我们将继续讨论。

76
00:02:44,230 --> 00:02:45,400
0,320 610,840 840,915 915,1035 1035,1170
forward.| So as I said
|就像我在上节课结束时说的，

77
00:02:45,400 --> 00:02:45,970
0,120 120,210 210,315 315,465 465,570
at the end end of

78
00:02:45,970 --> 00:02:47,200
0,135 135,420 420,750 750,1020 1020,1230
last class,| this point forward
|在感恩节之前，这学期的重点将是，

79
00:02:47,200 --> 00:02:48,270
0,135 135,240 240,495 495,750 750,1070
in the semester going forward

80
00:02:49,040 --> 00:02:50,305
0,305 305,455 455,590 590,880 990,1265
up to around Thanksgiving is

81
00:02:50,305 --> 00:02:51,100
0,275 295,570 570,675 675,720 720,795
going, is going to be|
|

82
00:02:51,100 --> 00:02:52,540
0,105 105,225 225,465 465,830 1210,1440
how to build a, sort
如何构建一种经典的或规范的关系数据库管理系统。

83
00:02:52,540 --> 00:02:54,330
0,105 105,345 345,710 760,1050 1050,1790
of a classic or canonical

84
00:02:54,530 --> 00:02:56,850
0,400 840,1325 1325,1655 1655,1955 1955,2320
database, relational database management system.|
|

85
00:02:58,730 --> 00:03:00,355
0,335 335,665 665,1060 1110,1355 1355,1625
So the {}, the outline
所以，前进的概述，

86
00:03:00,355 --> 00:03:02,050
0,275 295,600 600,855 855,1205 1345,1695
for going forward,| we, we've
|我们已经讨论了什么是关系数据库，

87
00:03:02,050 --> 00:03:03,130
0,165 165,375 375,510 510,690 690,1080
already discussed what relational databases

88
00:03:03,130 --> 00:03:06,550
0,260 1540,1830 1830,2120 2920,3210 3210,3420
are,| but the, the first
|但这里的前四个主题是，

89
00:03:06,550 --> 00:03:07,650
0,225 225,480 480,675 675,810 810,1100
four topics here is,| Storage,
|存储、执行、并发控制、恢复，

90
00:03:07,790 --> 00:03:09,820
0,350 350,755 755,950 950,1270 1710,2030
Execution, Concurrency Control, Recovery,| these
|这些都是你需要的方面，

91
00:03:09,820 --> 00:03:12,340
0,210 210,500 880,1280 1780,2180 2290,2520
are the the aspects you

92
00:03:12,340 --> 00:03:13,135
0,75 75,180 180,300 300,555 555,795
would need to have| to
|为了构建一个功能齐全、安全、可靠的数据库管理系统。

93
00:03:13,135 --> 00:03:15,420
0,180 180,515
build a,

94
00:03:15,420 --> 00:03:17,750
0,285 285,540 540,860 1420,1820 1930,2330
a full featured, safe, reliable

95
00:03:17,860 --> 00:03:19,700
0,380 380,740 740,1120
database management system.|
|

96
00:03:19,700 --> 00:03:21,410
0,260 940,1320 1320,1470 1470,1620 1620,1710
And we'll assume it's going
我们假设它会在一个节点上运行，

97
00:03:21,410 --> 00:03:22,810
0,260 340,600 600,750 750,960 960,1400
running on a single node,|
|

98
00:03:23,310 --> 00:03:24,110
0,245 245,380 380,545 545,665 665,800
because it makes our life
因为它让我们的生活变得更容易，

99
00:03:24,110 --> 00:03:25,325
0,290 310,630 630,765 765,1050 1050,1215
easier,| don't go distribute until
|不在必须的情况下不要去分布式。

100
00:03:25,325 --> 00:03:26,750
0,120 120,255 255,545 1015,1275 1275,1425
you have to.| And then
|然后一旦我们了解了单节点数据库系统是什么样子，

101
00:03:26,750 --> 00:03:28,550
0,290 340,705 705,1070 1450,1695 1695,1800
once we understand what a

102
00:03:28,550 --> 00:03:29,555
0,180 180,435 435,600 600,810 810,1005
single node database system looks

103
00:03:29,555 --> 00:03:31,100
0,305 505,900 900,1125 1125,1320 1320,1545
like,| we'll, we'll then discuss
|然后我们将讨论如何扩展它，做分布式数据库。

104
00:03:31,100 --> 00:03:32,150
0,150 150,330 330,570 570,825 825,1050
how to expand this and

105
00:03:32,150 --> 00:03:33,965
0,290 430,720 720,1310 1450,1695 1695,1815
do distributed databases.| And at
|在学期结束时，

106
00:03:33,965 --> 00:03:34,595
0,120 120,210 210,285 285,375 375,630
the end of the semester,|
|

107
00:03:34,595 --> 00:03:35,270
0,240 240,345 345,420 420,480 480,675
we'll talk a little bit
我们还将讨论，

108
00:03:35,270 --> 00:03:36,950
0,225 225,500 610,945 945,1280 1420,1680
also to about,| how, what
|什么其他功能和优化可以应用，

109
00:03:36,950 --> 00:03:38,380
0,180 180,450 450,735 735,975 975,1430
other additional features and optimizations

110
00:03:38,580 --> 00:03:40,055
0,245 245,410 410,730 1080,1340 1340,1475
we can apply,| which then
|这将是高级课程的一部分，

111
00:03:40,055 --> 00:03:41,110
0,135 135,225 225,330 330,735 735,1055
will be a segue into

112
00:03:41,310 --> 00:03:42,395
0,290 290,515 515,800 800,995 995,1085
the advanced class,| if you
|如果你想在春季学习的话。

113
00:03:42,395 --> 00:03:43,205
0,90 90,195 195,330 330,570 570,810
want to take that in

114
00:03:43,205 --> 00:03:45,050
0,180 180,485 1375,1620 1620,1710 1710,1845
the Spring.| So the way
|所以，思考数据库管理系统的方式

115
00:03:45,050 --> 00:03:45,890
0,135 135,240 240,420 420,600 600,840
to think about a database

116
00:03:45,890 --> 00:03:47,675
0,315 315,650 730,1130 1420,1665 1665,1785
management system| and the way
|和（思考）课程布局的方式是有一些层，

117
00:03:47,675 --> 00:03:48,550
0,135 135,270 270,420 420,585 585,875
the course is laid out

118
00:03:48,720 --> 00:03:50,290
0,400 540,800 800,950 950,1115 1115,1570
is a bunch of layers,|
|

119
00:03:50,880 --> 00:03:52,160
0,380 380,620 620,815 815,1190 1190,1280
and the different layers are
不同的层将为数据库系统的功能提供不同的功能，

120
00:03:52,160 --> 00:03:53,330
0,60 60,180 180,360 360,555 555,1170
going to provide different functionality

121
00:03:53,330 --> 00:03:54,515
0,105 105,350 580,825 825,930 930,1185
to capabilities for the database

122
00:03:54,515 --> 00:03:56,450
0,395 985,1385 1525,1815 1815,1875 1875,1935
system,| and they're going to
|它们将把 API 暴露给它上面的层。

123
00:03:56,450 --> 00:03:58,280
0,405 405,585 585,1160 1210,1575 1575,1830
expose an API to whatever

124
00:03:58,280 --> 00:03:59,285
0,150 150,300 300,525 525,795 795,1005
the layer is is above

125
00:03:59,285 --> 00:03:59,900
0,275
it.|
|

126
00:04:00,130 --> 00:04:01,710
0,260 260,485 485,850 1080,1370 1370,1580
And it the, the topics
我们要讨论的主题，

127
00:04:01,710 --> 00:04:03,210
0,300 300,555 555,890 970,1305 1305,1500
we discuss,| again basically how
|是如何构建这些层，

128
00:04:03,210 --> 00:04:04,485
0,180 180,375 375,540 540,980 1030,1275
to construct those layers,| put
|将它们放在一起，

129
00:04:04,485 --> 00:04:05,520
0,90 90,255 255,540 540,810 810,1035
it all together| and have
|并拥有一个功能齐全的数据库管理系统。

130
00:04:05,520 --> 00:04:06,900
0,300 300,570 570,810 810,1110 1110,1380
a full featured database management

131
00:04:06,900 --> 00:04:08,520
0,320 850,1200 1200,1380 1380,1485 1485,1620
system.| So the way to
|所以，考虑这个的方法是，

132
00:04:08,520 --> 00:04:09,165
0,135 135,255 255,315 315,405 405,645
think about it is that,|
|

133
00:04:09,165 --> 00:04:11,280
0,210 210,345 345,965 1405,1950 1950,2115
the most simplistic viewpoint would
最简单的观点是，

134
00:04:11,280 --> 00:04:13,190
0,260 670,1035 1035,1335 1335,1590 1590,1910
be,| the application comes along|
|应用程序出现，|

135
00:04:13,960 --> 00:04:14,775
0,320 320,500 500,590 590,665 665,815
and you going to issue
你将发出一个 SQL 查询，

136
00:04:14,775 --> 00:04:16,110
0,165 165,390 390,665 835,1110 1110,1335
a SQL query| and that's
|这个查询将首先显示并被解析，

137
00:04:16,110 --> 00:04:16,770
0,75 75,195 195,375 375,540 540,660
going to first show up

138
00:04:16,770 --> 00:04:18,690
0,105 105,255 255,800 1330,1635 1635,1920
and get parsed,| the string
|SQL 查询的文本字符串被解析，

139
00:04:18,690 --> 00:04:19,680
0,300 300,540 540,720 720,825 825,990
of text of the SQL

140
00:04:19,680 --> 00:04:21,090
0,105 105,240 240,680 1030,1290 1290,1410
query gets parsed,| run through
|然后运行下面的查询优化器，

141
00:04:21,090 --> 00:04:23,685
0,105 105,345 345,950 1990,2340 2340,2595
the query optimizer below that,|
|

142
00:04:23,685 --> 00:04:24,720
0,180 180,345 345,555 555,900 900,1035
then we'll start executing whatever
然后，我们将开始执行查询计划，

143
00:04:24,720 --> 00:04:25,905
0,90 90,255 255,435 435,710 910,1185
the Query Plan is,| there'll
|将有一些访问方法，

144
00:04:25,905 --> 00:04:27,135
0,180 180,435 435,660 660,945 945,1230
be Access Methods,| that to
|可以与表或索引或我们试图访问的任何内容进行交互，

145
00:04:27,135 --> 00:04:28,910
0,210 210,420 420,735 735,1115 1375,1775
actually talk to the the

146
00:04:28,930 --> 00:04:30,480
0,400 480,815 815,1175 1175,1295 1295,1550
tables or indexes or whatever

147
00:04:30,480 --> 00:04:32,025
0,255 255,315 315,480 480,800 1270,1545
we're trying to access,| that'll
|这将是一个缓冲池管理器，

148
00:04:32,025 --> 00:04:32,780
0,60 60,150 150,375 375,480 480,755
be a Buffer Pool Manager|
|

149
00:04:32,830 --> 00:04:34,245
0,260 260,455 455,650 650,910 1080,1415
to manage the memory for
用于管理我们数据库系统的内存，

150
00:04:34,245 --> 00:04:35,775
0,195 195,390 390,725 1135,1410 1410,1530
our database system,| and then
|然后在最低级别将是一个磁盘管理器，

151
00:04:35,775 --> 00:04:36,480
0,105 105,225 225,405 405,585 585,705
at the lowest level will

152
00:04:36,480 --> 00:04:38,115
0,90 90,195 195,435 435,680 1270,1635
be a Disk Manager,| that'll
|负责将数据读写到磁盘。

153
00:04:38,115 --> 00:04:39,780
0,210 210,570 570,935 1045,1380 1380,1665
be responsible for reading writing

154
00:04:39,780 --> 00:04:41,780
0,350 640,885 885,1370
data to disk.|
|

155
00:04:42,090 --> 00:04:43,865
0,275 275,550 960,1430 1430,1595 1595,1775
And so today's class,| we're
所以今天的课程，|我们将，

156
00:04:43,865 --> 00:04:45,350
0,30 30,90 90,335 1105,1380 1380,1485
going to start,| getting the
|这一学期从下面开始，然后努力向上，

157
00:04:45,350 --> 00:04:47,285
0,290 670,900 900,1005 1005,1280 1660,1935
semester at the bottom and

158
00:04:47,285 --> 00:04:48,400
0,195 195,435 435,645 645,825 825,1115
then work our way up,|
|

159
00:04:49,000 --> 00:04:49,630
0,120 120,240 240,360 360,465 465,630
when we get to something
当我们达到比如并发控制、恢复的时候，

160
00:04:49,630 --> 00:04:51,640
0,180 180,315 315,810 810,1160 1600,2010
like a {Concurrency,Control}, Recovery,| that's
|这将[渗透]到整个系统，

161
00:04:51,640 --> 00:04:52,585
0,75 75,195 195,525 525,720 720,945
going to permeate throughout the

162
00:04:52,585 --> 00:04:53,875
0,270 270,635 895,1125 1125,1200 1200,1290
entire system,| so we have
|所以，我们必须回来，重新审视所有这些事情，

163
00:04:53,875 --> 00:04:54,715
0,90 90,210 210,360 360,480 480,840
to come back and revisit

164
00:04:54,715 --> 00:04:56,560
0,150 150,345 345,635 1435,1695 1695,1845
all these things,| when we're
|当我们运行事务时，我们需要知道磁盘上有什么，

165
00:04:56,560 --> 00:04:57,700
0,165 165,500 640,900 900,1020 1020,1140
running transactions, we need to

166
00:04:57,700 --> 00:04:59,965
0,260 730,1065 1065,1185 1185,1730 2020,2265
know what's on disk,| we
|我们需要知道我们正在访问什么，我们如何访问它，

167
00:04:59,965 --> 00:05:01,230
0,135 135,330 330,555 555,810 810,1265
{need,to} know what we're accessing,

168
00:05:01,400 --> 00:05:03,355
0,275 275,530 530,830 830,1090 1620,1955
how we're accessing it,| what,
|我们正在执行什么查询，

169
00:05:03,355 --> 00:05:05,000
0,225 225,465 465,705 705,1115
what queries we're executing,

170
00:05:05,000 --> 00:05:06,640
0,255 255,525 525,840 840,1220 1240,1640
right.| So the Storage, Execution
|所以，存储、执行将帮助我们完成整个[堆栈]，

171
00:05:07,050 --> 00:05:07,775
0,260 260,365 365,470 470,590 590,725
will get us through the

172
00:05:07,775 --> 00:05:09,380
0,225 225,575 1105,1365 1365,1470 1470,1605
entire stack| and then we'll
|然后我们将返回并再次触摸它，

173
00:05:09,380 --> 00:05:10,130
0,105 105,270 270,465 465,645 645,750
come back and touch it

174
00:05:10,130 --> 00:05:12,095
0,120 120,330 330,650 1540,1800 1800,1965
all over again,| that sounds
|这听起来很奇怪，

175
00:05:12,095 --> 00:05:13,160
0,255 255,585 585,855 855,945 945,1065
weird,| but we'll look at
|但我们将重新审视它。

176
00:05:13,160 --> 00:05:18,460
0,120 120,270 270,480 480,800 4900,5300
it all over again.| {The,same,thing,for,Distributed,Databases},|
|对于分布式数据库，也有相同的事情，|

177
00:05:18,690 --> 00:05:19,625
0,305 305,470 470,605 605,755 755,935
we {have,to} know about all
我们需要知道所有这些信息在一个可靠、安全、分布式的数据库中。

178
00:05:19,625 --> 00:05:23,080
0,180 180,345 345,635 2815,3135 3135,3455
these things in a reliable,

179
00:05:23,190 --> 00:05:24,960
0,380 380,665 665,970
safe, distributed database.|
|

180
00:05:24,960 --> 00:05:25,920
0,320
Okay?|
好的？|

181
00:05:27,090 --> 00:05:28,620
0,400
{All,right},
好的，对于我们要讨论的系统，

182
00:05:28,690 --> 00:05:30,765
0,400 840,1130 1130,1420 1530,1865 1865,2075
so for the system, we're

183
00:05:30,765 --> 00:05:32,385
0,30 30,135 135,425 805,1205 1285,1620
going to discuss,| the methods
|我们在本学期要讨论的方法。

184
00:05:32,385 --> 00:05:33,060
0,180 180,210 210,315 315,510 510,675
we going to discuss this

185
00:05:33,060 --> 00:05:34,670
0,320 850,1155 1155,1215 1215,1335 1335,1610
semester.| We're going to assume
|我们假设我们尝试构建的体系结构，

186
00:05:35,020 --> 00:05:36,375
0,365 365,590 590,850 1020,1265 1265,1355
that the architecture of what

187
00:05:36,375 --> 00:05:37,545
0,135 135,225 225,345 345,605 895,1170
we're trying to build,| again,
|在概念上出现在我们的脑海中，

188
00:05:37,545 --> 00:05:38,655
0,180 180,675 675,780 780,810 810,1110
think conceptually we're {construct -}

189
00:05:38,655 --> 00:05:39,750
0,105 105,195 195,455 655,915 915,1095
in our minds,| a database
|一个数据库管理系统，

190
00:05:39,750 --> 00:05:40,980
0,210 210,500 610,885 885,1065 1065,1230
management system| and {Bustub -}
|Bustub 是这个的一种实现。

191
00:05:40,980 --> 00:05:42,320
0,135 135,330 330,650 760,1050 1050,1340
is one implementation of this.|
|

192
00:05:42,950 --> 00:05:43,690
0,320 320,365 365,440 440,575 575,740
We're going to say we're
我们将会说，我们正在构建的是，

193
00:05:43,690 --> 00:05:44,515
0,135 135,300 300,435 435,600 600,825
building what is called| a
|基于磁盘的数据库系统或面向磁盘的体系结构。

194
00:05:44,515 --> 00:05:45,955
0,345 345,540 540,840 840,1200 1200,1440
{disk-based -} database system or

195
00:05:45,955 --> 00:05:48,160
0,120 120,375 375,780 780,1115
a {disk-oriented -} architecture.|
|

196
00:05:48,410 --> 00:05:49,300
0,260 260,395 395,545 545,725 725,890
And this is where the
这就是数据库管理系统本身将假设，

197
00:05:49,300 --> 00:05:50,740
0,225 225,525 525,860 910,1245 1245,1440
database management system itself is

198
00:05:50,740 --> 00:05:51,900
0,105 105,285 285,615 615,885 885,1160
going to assume that,| the
|数据库的主存储位置将位于某个非易失性磁盘上，

199
00:05:52,190 --> 00:05:53,710
0,400 480,845 845,1175 1175,1400 1400,1520
primary storage location of the

200
00:05:53,710 --> 00:05:55,315
0,260 880,1200 1200,1365 1365,1455 1455,1605
database is going to be

201
00:05:55,315 --> 00:05:57,180
0,270 270,615 615,930 930,1380 1380,1865
on some {non-volatile -} disk,|
|

202
00:05:57,560 --> 00:05:58,930
0,260 260,365 365,455 455,1060 1080,1370
could be an SSD, a
可以是固态硬盘，可能是旋转磁盘硬盘，

203
00:05:58,930 --> 00:06:00,325
0,240 240,375 375,555 555,860 1150,1395
spinning disk hard drive,| if
|如果你运行在云上，则可能是 S3 ，

204
00:06:00,325 --> 00:06:01,300
0,135 135,285 285,495 495,765 765,975
you're running the cloud, could

205
00:06:01,300 --> 00:06:03,610
0,75 75,255 255,590 1690,2010 2010,2310
be {S3 -},| assuming that
|假设它是基于磁盘的。

206
00:06:03,610 --> 00:06:04,300
0,270 270,330 330,390 390,495 495,690
it's going to be {disk-based

207
00:06:04,300 --> 00:06:05,280
0,320
-}.|
|

208
00:06:05,770 --> 00:06:06,915
0,305 305,575 575,800 800,965 965,1145
And all the things we're
我们要在我们的数据库系统中构建的所有东西

209
00:06:06,915 --> 00:06:07,635
0,30 30,105 105,345 345,585 585,720
going to build in our

210
00:06:07,635 --> 00:06:09,765
0,275 475,875 1135,1440 1440,1745 1765,2130
database system| are really designed
|都已经设计好，

211
00:06:09,765 --> 00:06:11,140
0,210 210,455
to now,|
|

212
00:06:11,360 --> 00:06:13,390
0,485 485,680 680,1330 1440,1760 1760,2030
coordinate or orchestrate the movement
协调数据在磁盘和内存之间的来回移动。

213
00:06:13,390 --> 00:06:14,965
0,240 240,530 820,1125 1125,1320 1320,1575
of data back and forth

214
00:06:14,965 --> 00:06:17,260
0,365 415,945 945,1200 1200,1535
from disk into memory.|
|

215
00:06:17,720 --> 00:06:19,570
0,275 275,395 395,515 515,790 1560,1850
This should not be news
这对任何人来说都不应该是新闻，

216
00:06:19,570 --> 00:06:20,230
0,180 180,330 330,435 435,525 525,660
for anyone,| this is the
|这是经典的[]架构，

217
00:06:20,230 --> 00:06:22,440
0,270 270,810 810,1070 1630,1920 1920,2210
classic [] architecture,| where the
|其中数据位于磁盘上，

218
00:06:22,640 --> 00:06:23,830
0,365 365,590 590,770 770,995 995,1190
data is at rest on

219
00:06:23,830 --> 00:06:25,560
0,530 580,855 855,1215 1215,1455 1455,1730
disk,| we can't operate it,|
|我们不能操作它，|

220
00:06:25,610 --> 00:06:26,335
0,275 275,410 410,515 515,590 590,725
unless we bring it into
除非我们把它放入内存，

221
00:06:26,335 --> 00:06:27,460
0,305 325,570 570,675 675,810 810,1125
memory,| and then the CPU
|然后 CPU 可以对它做任何它需要的事情。

222
00:06:27,460 --> 00:06:28,240
0,105 105,240 240,450 450,615 615,780
can do whatever it needs

223
00:06:28,240 --> 00:06:29,080
0,180 180,440
to it.|
|

224
00:06:29,370 --> 00:06:30,170
0,245 245,365 365,515 515,665 665,800
So this is, this is
所以这是我们试图建立的总体主题，

225
00:06:30,170 --> 00:06:32,015
0,120 120,380 1240,1560 1560,1725 1725,1845
the overall theme of what

226
00:06:32,015 --> 00:06:33,185
0,195 195,330 330,465 465,725 925,1170
we're trying to build,| and
|显然这将是非常困难的，

227
00:06:33,185 --> 00:06:33,875
0,105 105,285 285,495 495,615 615,690
this is obviously going to

228
00:06:33,875 --> 00:06:35,615
0,135 135,345 345,665 985,1385 1405,1740
be super hard,| and again,
|同样，如果你是一名应用程序开发人员，

229
00:06:35,615 --> 00:06:37,000
0,210 210,510 510,765 765,1050 1050,1385
if you're an application developer,|
|

230
00:06:37,170 --> 00:06:37,955
0,290 290,530 530,605 605,680 680,785
you don't want to be
你不会希望自己在应用程序代码中执行此操作，

231
00:06:37,955 --> 00:06:38,990
0,165 165,405 405,675 675,840 840,1035
doing this yourself in your

232
00:06:38,990 --> 00:06:40,850
0,285 285,620 1360,1620 1620,1740 1740,1860
application code,| you want a
|你想要一个数据库系统，

233
00:06:40,850 --> 00:06:41,915
0,255 255,540 540,735 735,930 930,1065
database system,| that knows how
|知道如何可靠、安全、正确、高效地做到这个，

234
00:06:41,915 --> 00:06:43,145
0,105 105,225 225,450 450,975 975,1230
to do this reliably and

235
00:06:43,145 --> 00:06:45,130
0,255 255,480 480,785 1075,1395 1395,1985
safely and correctly and efficiently,|
|

236
00:06:46,560 --> 00:06:47,440
0,260 260,350 350,455 455,605 605,880
to do it for you.|
为你做到这个。|

237
00:06:49,240 --> 00:06:50,055
0,245 245,335 335,470 470,620 620,815
So the way to think
所以，考虑存储是什么样子的，

238
00:06:50,055 --> 00:06:52,010
0,335 715,1050 1050,1335 1335,1620 1620,1955
about what storage looks like|
|

239
00:06:52,360 --> 00:06:53,505
0,245 245,425 425,665 665,935 935,1145
from our perspective as from
从我们作为数据库系统的角度是，

240
00:06:53,505 --> 00:06:55,230
0,90 90,330 330,725 985,1385 1435,1725
a database system is,| in
|从这个层次结构的角度，

241
00:06:55,230 --> 00:06:56,205
0,180 180,330 330,465 465,900 900,975
terms of this hierarchy,| and
|你可能在其他课程或其他教科书中看到过这个，

242
00:06:56,205 --> 00:06:56,790
0,90 90,180 180,285 285,390 390,585
you might have seen this

243
00:06:56,790 --> 00:06:58,530
0,195 195,360 360,680 1060,1440 1440,1740
in other classes or other

244
00:06:58,530 --> 00:07:00,990
0,300 300,1010 2020,2265 2265,2355 2355,2460
other textbooks,| and the way
|思考这一点的方法是，

245
00:07:00,990 --> 00:07:01,620
0,120 120,240 240,375 375,510 510,630
to think about this is

246
00:07:01,620 --> 00:07:03,225
0,260 640,990 990,1215 1215,1350 1350,1605
that,| going from the bottom
|从下到上，

247
00:07:03,225 --> 00:07:05,280
0,240 240,375 375,665 1045,1445 1735,2055
to the top,| the, the
|存储设备将变得更快，但更小，更贵，

248
00:07:05,280 --> 00:07:06,390
0,315 315,690 690,930 930,1020 1020,1110
storage devices are going to

249
00:07:06,390 --> 00:07:09,150
0,260 460,860 1780,2145 2145,2490 2490,2760
get faster, but smaller and

250
00:07:09,150 --> 00:07:10,420
0,240 240,590
more expensive,|
|

251
00:07:10,490 --> 00:07:11,650
0,305 305,470 470,620 620,875 875,1160
so at the bottom layer
所以，在最底层，

252
00:07:11,650 --> 00:07:12,625
0,255 255,450 450,600 600,780 780,975
here,| you have something like
|你可以使用类似网络存储的东西，

253
00:07:12,625 --> 00:07:14,650
0,270 270,635 1435,1710 1710,1830 1830,2025
network storage,| this would be
|这应该是 EBS 或 S3 ，

254
00:07:14,650 --> 00:07:15,960
0,285 285,570 570,780 780,975 975,1310
{EBS -} or {S3 -},|
|

255
00:07:16,640 --> 00:07:18,040
0,260 260,520 690,1055 1055,1265 1265,1400
I think in in the
我想在教科书中，

256
00:07:18,040 --> 00:07:19,090
0,405 405,570 570,645 645,795 795,1050
textbook,| there's a layer below
|这下面有一层，

257
00:07:19,090 --> 00:07:20,305
0,300 300,495 495,675 675,915 915,1215
this,| they have tape drives,|
|他们有磁带机，|

258
00:07:20,305 --> 00:07:22,285
0,395 1015,1335 1335,1560 1560,1770 1770,1980
but nobody runs database systems
但现在没有人再使用它来运行数据库系统。

259
00:07:22,285 --> 00:07:24,630
0,180 180,420 420,785 1825,2085 2085,2345
off those anymore.| But like
|随着你向上，

260
00:07:24,950 --> 00:07:26,005
0,320 320,500 500,620 620,800 800,1055
as you go up,| after
|在网络存储之后，

261
00:07:26,005 --> 00:07:26,875
0,270 270,540 540,720 720,795 795,870
network storage| and you have
|你有一个本地连接的旋转磁盘硬盘，

262
00:07:26,875 --> 00:07:28,150
0,90 90,195 195,525 525,815 955,1275
like a locally attached spinning

263
00:07:28,150 --> 00:07:29,380
0,135 135,315 315,620 880,1140 1140,1230
disk hard drive,| and then
|然后你可能有 SSD ，

264
00:07:29,380 --> 00:07:29,920
0,75 75,180 180,330 330,465 465,540
you have maybe like an

265
00:07:29,920 --> 00:07:31,150
0,105 105,255 255,530 880,1125 1125,1230
{SSD - -}| and then
|然后你有 DRAM ，

266
00:07:31,150 --> 00:07:31,870
0,165 165,330 330,435 435,555 555,720
after that you have {DRAM

267
00:07:31,870 --> 00:07:32,650
0,225 225,465 465,630 630,705 705,780
-},| then {CPU - -}
|然后 CPU 缓存，

268
00:07:32,650 --> 00:07:34,165
0,450 450,800 940,1245 1245,1395 1395,1515
caches| and now {CPU -}
|然后 CPU 寄存器，

269
00:07:34,165 --> 00:07:35,100
0,515
registers,

270
00:07:35,140 --> 00:07:37,430
0,350 350,820 1410,1715 1715,1955 1955,2290
right.| {CPU,registers} are super fast,|
|CPU 寄存器速度超级快，|

271
00:07:38,320 --> 00:07:39,120
0,290 290,365 365,605 605,695 695,800
it's the fastest kind of
这是你能拥有的最快的[]，

272
00:07:39,120 --> 00:07:39,780
0,135 135,240 240,315 315,480 480,660
[] you can have,| but
|但就像我们谈论的那样，

273
00:07:39,780 --> 00:07:40,950
0,260 310,615 615,810 810,1020 1020,1170
like we're talking,| you have
|你可能有，我不知道，

274
00:07:40,950 --> 00:07:42,210
0,290 310,525 525,645 645,750 750,1260
maybe, I don't know,| 32
|CPU 上有 32 个寄存器，

275
00:07:42,210 --> 00:07:43,995
0,525 525,675 675,795 795,1250 1540,1785
registers on your CPU| and
|每个寄存器是 64 位，

276
00:07:43,995 --> 00:07:44,460
0,105 105,300 300,345 345,390 390,465
each one's going to be

277
00:07:44,460 --> 00:07:46,260
0,150 150,540 540,800 1360,1650 1650,1800
about 64 bits, right,| you
|你不能在那里储存很多空间，

278
00:07:46,260 --> 00:07:46,830
0,210 210,315 315,390 390,465 465,570
can't store a lot of

279
00:07:46,830 --> 00:07:47,745
0,150 150,285 285,530 610,855 855,915
space in there,| store a
|在那里储存很多东西，

280
00:07:47,745 --> 00:07:48,530
0,75 75,240 240,435 435,555 555,785
lot of things in there,|
|

281
00:07:50,750 --> 00:07:51,160
0,215 215,260 260,305 305,335 335,410
but they're going to be
但它们的速度会非常快。

282
00:07:51,160 --> 00:07:52,600
0,180 180,500
super fast.|
|

283
00:07:52,780 --> 00:07:54,375
0,400 510,800 800,1085 1085,1415 1415,1595
So from our perspective in
所以，从我们这学期的角度来看，

284
00:07:54,375 --> 00:07:56,070
0,135 135,515 1015,1290 1290,1500 1500,1695
this semester,| the only thing
|我们真正关心的是这里的分界线，

285
00:07:56,070 --> 00:07:56,895
0,105 105,270 270,480 480,645 645,825
we really care about is

286
00:07:56,895 --> 00:07:58,700
0,270 270,555 555,795 795,1115
this division line here,|
|

287
00:07:59,105 --> 00:08:00,125
0,75 75,210 210,405 405,870 870,1020
and that's between volatile and
这介于易失性存储和非易失性存储之间，

288
00:08:00,125 --> 00:08:01,680
0,195 195,570 570,845
{non-volatile -} storage,|
|

289
00:08:02,020 --> 00:08:03,140
0,275 275,395 395,500 500,860 860,1120
obviously, what does volatile mean,|
显然，易失性是什么意思，|

290
00:08:03,280 --> 00:08:04,900
0,245 245,335 335,635 635,910
we have volatile storage.|
我们有易失性存储器。|

291
00:08:06,610 --> 00:08:07,720
0,60 60,290
What's that?|
那是什么？|

292
00:08:09,190 --> 00:08:10,215
0,260 260,455 455,665 665,935 935,1025
Yeah, it says data gone,
是的，它说当你断电时，数据就会消失，

293
00:08:10,215 --> 00:08:10,785
0,75 75,195 195,345 345,465 465,570
when you when you when

294
00:08:10,785 --> 00:08:11,625
0,150 150,360 360,555 555,705 705,840
you power {is,gone},| you pull
|你拔下你的 DRAM 或 CPU 寄存器的插头，

295
00:08:11,625 --> 00:08:12,675
0,135 135,345 345,555 555,750 750,1050
the plug on your DRAM

296
00:08:12,675 --> 00:08:14,400
0,240 240,375 375,750 750,1295 1345,1725
or your CPU registers,| like
|所有的东西都被抹去了，

297
00:08:14,400 --> 00:08:15,585
0,225 225,330 330,525 525,770 940,1185
everything gets wiped out,| when
|当你重新启动系统时，

298
00:08:15,585 --> 00:08:16,185
0,90 90,210 210,300 300,480 480,600
you boot the systemt back

299
00:08:16,185 --> 00:08:18,150
0,270 270,720 720,840 840,1115 1645,1965
up,| nothing's still there.| {Non-volatile
|什么都没有了。|非易失性意味着你将数据写入设备，

300
00:08:18,150 --> 00:08:19,530
0,360 360,600 600,870 870,1125 1125,1380
-} basically means that you

301
00:08:19,530 --> 00:08:21,170
0,240 240,590 610,1010 1060,1350 1350,1640
write data to the device,|
|

302
00:08:21,940 --> 00:08:23,350
0,290 430,795 795,1080 1080,1260 1260,1410
and assuming that you make
假设你进行调用告诉他们，

303
00:08:23,350 --> 00:08:25,150
0,290 550,950 1030,1395 1395,1650 1650,1800
the calls to tell them,|
|

304
00:08:25,150 --> 00:08:26,755
0,180 180,600 600,920 1210,1470 1470,1605
get flushed, or you get
被刷新或得到确认，

305
00:08:26,755 --> 00:08:28,345
0,135 135,285 285,815 985,1395 1395,1590
back an acknowledgement,| we'll cover
|我们将在稍后讨论这一点，

306
00:08:28,345 --> 00:08:30,055
0,150 150,425 745,1145 1165,1500 1500,1710
that later,| then we assume
|然后我们假设数据将是持久的，

307
00:08:30,055 --> 00:08:30,700
0,165 165,345 345,495 495,585 585,645
that data is going to

308
00:08:30,700 --> 00:08:32,220
0,230 310,1010
be persistent,|
|

309
00:08:32,290 --> 00:08:33,525
0,260 260,500 500,725 725,965 965,1235
and that no matter if
不管我们重新启动系统，拔下电源，

310
00:08:33,525 --> 00:08:35,325
0,275 715,1140 1140,1275 1275,1530 1530,1800
we restart the system, pull

311
00:08:35,325 --> 00:08:36,720
0,135 135,395 805,1065 1065,1230 1230,1395
the power,| take the machine
|取出机器，把它放到另一个位置，不管是什么，

312
00:08:36,720 --> 00:08:37,470
0,165 165,300 300,360 360,495 495,750
out, put it into another

313
00:08:37,470 --> 00:08:38,985
0,350 430,830 1000,1260 1260,1380 1380,1515
location, whatever,| when we come
|当我们回来的时候，我们的数据都会在那里。

314
00:08:38,985 --> 00:08:39,855
0,210 210,420 420,570 570,735 735,870
back, that our data will

315
00:08:39,855 --> 00:08:40,880
0,105 105,365
be there.|
|

316
00:08:41,060 --> 00:08:42,310
0,245 245,380 380,635 635,995 995,1250
Of course, database systems, we
当然，数据库系统，我们不信任硬件，

317
00:08:42,310 --> 00:08:43,630
0,180 180,345 345,495 495,740 1090,1320
don't trust the hardware,| we
|我们也不信任操作系统，

318
00:08:43,630 --> 00:08:44,290
0,105 105,195 195,360 360,540 540,660
don't trust the OS too,|
|

319
00:08:44,290 --> 00:08:44,710
0,105 105,165 165,270 270,345 345,420
we'll get that in a
我们很快就会讲到，

320
00:08:44,710 --> 00:08:45,880
0,260 610,840 840,960 960,1050 1050,1170
second,| we don't trust any
|我们对任何一个都不信任，

321
00:08:45,880 --> 00:08:46,900
0,260 310,660 660,930 930,975 975,1020
of,| so we're going to
|所以我们要做一堆额外的工作，

322
00:08:46,900 --> 00:08:47,290
0,45 45,90 90,150 150,210 210,390
do a bunch of extra

323
00:08:47,290 --> 00:08:48,400
0,270 270,435 435,585 585,810 810,1110
stuff| to make sure that
|以确保如果我们写东西，

324
00:08:48,400 --> 00:08:49,855
0,225 225,330 330,495 495,800 1060,1455
if we write stuff,| maybe
|也许我们会写到多个位置，

325
00:08:49,855 --> 00:08:50,970
0,255 255,390 390,525 525,750 750,1115
we write to multiple locations,|
|

326
00:08:51,110 --> 00:08:51,955
0,245 245,335 335,440 440,545 545,845
where we write a backup
我们为它写备份，

327
00:08:51,955 --> 00:08:52,915
0,135 135,240 240,485 625,855 855,960
for it, right,| a bunch
|我们将做一系列的事情，

328
00:08:52,915 --> 00:08:53,755
0,120 120,240 240,405 405,600 600,840
of things we'll do| to
|来确保我们得到真正的非易失性存储。

329
00:08:53,755 --> 00:08:55,210
0,150 150,270 270,390 390,665 1165,1455
make sure that we we

330
00:08:55,210 --> 00:08:56,910
0,180 180,345 345,810 810,1100 1300,1700
truly get non-volatile storage.| But
|但是从架构本身的设计来看，

331
00:08:57,020 --> 00:08:58,615
0,290 290,515 515,850 900,1250 1250,1595
from the design of the,

332
00:08:58,615 --> 00:09:00,400
0,240 240,485 625,1025 1225,1590 1590,1785
the architecture itself,| we'll assume
|我们会假设它是易失性的，而不是非易失性的。

333
00:09:00,400 --> 00:09:02,845
0,320 1600,1845 1845,1920 1920,2085 2085,2445
that you know, it's volatile

334
00:09:02,845 --> 00:09:04,160
0,90 90,225 225,390 390,905
versus it {non-volatile -}.|
|

335
00:09:05,010 --> 00:09:05,975
0,350 350,575 575,755 755,935 935,965
Another key difference we're going
我们将看到易失性和非易失性之间的另一个关键区别是，

336
00:09:05,975 --> 00:09:06,785
0,75 75,225 225,405 405,735 735,810
to see between volatile and

337
00:09:06,785 --> 00:09:08,990
0,135 135,605 745,1145 1765,2070 2070,2205
{non-volatile -} is| how we
|我们如何访问数据，

338
00:09:08,990 --> 00:09:10,680
0,225 225,510 510,645 645,890
can access the data,|
|

339
00:09:10,690 --> 00:09:12,075
0,275 275,500 500,965 965,1205 1205,1385
so {non-volatile -} storage will
非易失性存储被认为是字节可寻址的，

340
00:09:12,075 --> 00:09:13,230
0,245 325,600 600,705 705,855 855,1155
be considered to be byte

341
00:09:13,230 --> 00:09:14,380
0,560
addressable,|
|

342
00:09:14,690 --> 00:09:16,080
0,245 245,320 320,440 440,730
what does that mean?|
那是什么意思？|

343
00:09:19,830 --> 00:09:21,560
0,400 1140,1385 1385,1490 1490,1595 1595,1730
Each, he says, you can
他说，你可以询问每个单独的字节，正确。

344
00:09:21,560 --> 00:09:23,075
0,225 225,450 450,915 915,1220 1240,1515
query each {individual,byte}, correct.| So
|假设我有一兆字节的文件，

345
00:09:23,075 --> 00:09:24,200
0,225 225,420 420,660 660,900 900,1125
let's say I have one

346
00:09:24,200 --> 00:09:27,770
0,435 435,710 3040,3315 3315,3450 3450,3570
megabyte file,| I want to
|我想在某个随机偏移量上获得 64 位，

347
00:09:27,770 --> 00:09:29,210
0,255 255,795 795,1005 1005,1215 1215,1440
get 64 bits at some

348
00:09:29,210 --> 00:09:30,830
0,320 340,740 1060,1335 1335,1485 1485,1620
random offset,| I can do
|我可以在内存中做到这个，

349
00:09:30,830 --> 00:09:32,060
0,165 165,330 330,590
that in memory,|
|

350
00:09:32,640 --> 00:09:33,845
0,305 305,500 500,785 785,1025 1025,1205
there's cache lines, is not
有高速缓存行，并不完全正确，

351
00:09:33,845 --> 00:09:34,895
0,255 255,495 495,720 720,915 915,1050
exactly true,| but for now
|但现在我们可以忽略这个，

352
00:09:34,895 --> 00:09:36,700
0,270 270,555 555,720 720,995 1405,1805
we can ignore that,| in
|在非易失性存储中，

353
00:09:36,750 --> 00:09:38,270
0,400 450,785 785,1130 1130,1325 1325,1520
a {non-volatile -} storage,| like,
|比如，想象一下 SSD ，

354
00:09:38,270 --> 00:09:39,160
0,120 120,210 210,270 270,345 345,890
think of it an SSD,|
|

355
00:09:39,510 --> 00:09:41,015
0,320 320,665 665,860 860,1160 1160,1505
you can't go get exactly
你不能在一个 1 兆字节的文件中获得准确的 64 位，

356
00:09:41,015 --> 00:09:41,945
0,465 465,615 615,735 735,810 810,930
64 bits in a one

357
00:09:41,945 --> 00:09:43,280
0,345 345,605
megabyte file,|
|

358
00:09:43,280 --> 00:09:43,790
0,75 75,180 180,285 285,390 390,510
you got to go get
你必须去获取 64 位所在的块，

359
00:09:43,790 --> 00:09:45,620
0,180 180,500 700,960 960,1220 1360,1830
the block that that 64

360
00:09:45,620 --> 00:09:46,895
0,120 120,255 255,530 850,1125 1125,1275
bits is in,| bring that
|把它放到内存中，

361
00:09:46,895 --> 00:09:47,735
0,150 150,390 390,600 600,705 705,840
into memory| and then do
|然后在它上做任何你需要的事情，

362
00:09:47,735 --> 00:09:48,700
0,225 225,435 435,555 555,690 690,965
whatever you need on it,|
|

363
00:09:49,420 --> 00:09:50,445
0,290 290,425 425,515 515,710 710,1025
so you can only address
所以，你只能寻址块，而不能寻址单个字节。

364
00:09:50,445 --> 00:09:54,180
0,365 775,1175 1225,1625 2545,3095
blocks, not individual bytes.|
|

365
00:09:54,710 --> 00:09:55,645
0,275 275,455 455,590 590,740 740,935
And so the reason why
这个很重要的原因是，

366
00:09:55,645 --> 00:09:57,565
0,180 180,465 465,720 720,995 1555,1920
this matters is that,| there'll
|在我们的系统设计中，我们会选择某些算法，

367
00:09:57,565 --> 00:09:59,800
0,245 865,1265 1285,1680 1680,1935 1935,2235
be certain algorithms we choose

368
00:09:59,800 --> 00:10:00,730
0,225 225,390 390,630 630,780 780,930
in the design of our

369
00:10:00,730 --> 00:10:02,440
0,320 340,740 940,1245 1245,1485 1485,1710
system,| where we know we're
|我们知道我们读取的是块，而不是单个字节或字节偏移量，

370
00:10:02,440 --> 00:10:04,105
0,300 300,590 1120,1365 1365,1485 1485,1665
fetching blocks instead of single

371
00:10:04,105 --> 00:10:06,265
0,485 715,990 990,1170 1170,1595 1825,2160
bytes or byte offsets,| and
|所以我们将选择一种更适合于块可调整数据的算法，

372
00:10:06,265 --> 00:10:07,240
0,195 195,405 405,600 600,765 765,975
therefore we'll choose maybe an

373
00:10:07,240 --> 00:10:08,335
0,270 270,360 360,525 525,810 810,1095
algorithm that is better for

374
00:10:08,335 --> 00:10:09,800
0,225 225,555 555,815
block adjustable data,|
|

375
00:10:10,160 --> 00:10:11,170
0,320 320,485 485,635 635,890 890,1010
related to this, we're also
与此相关，我们还将选择潜在的算法，

376
00:10:11,170 --> 00:10:12,325
0,75 75,180 180,405 405,770 790,1155
going to choose potentially algorithms,|
|

377
00:10:12,325 --> 00:10:16,450
0,275 3265,3840 3840,3945 3945,4020 4020,4125
that maximize the amount of
以最大化对数据的顺序访问量。

378
00:10:16,450 --> 00:10:17,700
0,435 435,690 690,840 840,975 975,1250
sequential access of our data.|
|

379
00:10:18,870 --> 00:10:19,580
0,335 335,500 500,545 545,605 605,710
So what do I mean
那么我这么说是什么意思？

380
00:10:19,580 --> 00:10:20,800
0,120 120,380
by this?|
|

381
00:10:24,950 --> 00:10:27,205
0,400 900,1325 1325,1760 1760,1970 1970,2255

382
00:10:27,205 --> 00:10:28,090
0,360 360,585 585,660 660,765 765,885

383
00:10:28,090 --> 00:10:29,640
0,150 150,770 880,1125 1125,1260 1260,1550
{ -} So he said
|他说，访问相邻块的成本更低，

384
00:10:29,810 --> 00:10:31,765
0,395 395,800 800,1090 1200,1600 1620,1955
accessing adjacent blocks are are

385
00:10:31,765 --> 00:10:32,725
0,335 535,765 765,840 840,915 915,960
cheaper,| so we want to
|所以，我们希望尽可能地做到这个，

386
00:10:32,725 --> 00:10:33,400
0,75 75,240 240,420 420,555 555,675
do that as much as

387
00:10:33,400 --> 00:10:34,450
0,225 225,480 480,690 690,900 900,1050
possible,| so again, say I
|所以，比如，我想要获取 10 兆字节，

388
00:10:34,450 --> 00:10:36,620
0,105 105,210 210,470
want to get,

389
00:10:36,620 --> 00:10:37,400
0,150 150,255 255,345 345,540 540,780
I want to get 10

390
00:10:37,400 --> 00:10:39,370
0,620 730,975 975,1095 1095,1370 1570,1970
megabytes| and I have in
|我有[程序]到 1 兆字节，

391
00:10:40,260 --> 00:10:41,590
0,365 365,605 605,740 740,1055 1055,1330
[program] to 1 megabyte blocks,|
|

392
00:10:41,880 --> 00:10:43,025
0,260 260,425 425,620 620,965 965,1145
if those 1 megabyte blocks
如果这些 1 兆字节的数据块分散在不同的位置，

393
00:10:43,025 --> 00:10:44,170
0,210 210,405 405,540 540,765 765,1145
are scattered in different locations,|
|

394
00:10:44,520 --> 00:10:46,085
0,260 260,515 515,845 845,965 965,1565
then {} it's called {random,access},|
那么它被称为随机访问，|

395
00:10:46,085 --> 00:10:46,985
0,210 210,435 435,585 585,675 675,900
go jump to those different
去那些不同的地方去获取数据，

396
00:10:46,985 --> 00:10:48,010
0,300 300,480 480,585 585,735 735,1025
locations to get that data,|
|

397
00:10:48,660 --> 00:10:50,270
0,320 460,1035 1035,1200 1200,1380 1380,1610
or alternatively, if it's all
或者，如果它们都连续排列在一起，

398
00:10:50,560 --> 00:10:52,635
0,470 470,770 770,1450 1650,1910 1910,2075
aligned together, contiguous,| then in
|那么理论上，我可以执行一个 FETCH 命令，

399
00:10:52,635 --> 00:10:53,505
0,255 255,450 450,540 540,660 660,870
theory, I can do one

400
00:10:53,505 --> 00:10:55,140
0,330 330,695 1135,1425 1425,1515 1515,1635
fetch command,| I'm not saying
|我不是说这个设备是什么，

401
00:10:55,140 --> 00:10:55,980
0,120 120,270 270,465 465,690 690,840
what the device is,| but
|但只需一个 fetch 命令就可以获取 10 个 1 兆字节块，

402
00:10:55,980 --> 00:10:57,285
0,150 150,315 315,650 730,1080 1080,1305
it's one fetch command to

403
00:10:57,285 --> 00:10:58,875
0,210 210,465 465,705 705,1025 1315,1590
go get those 10 1

404
00:10:58,875 --> 00:11:00,480
0,285 285,545 1015,1275 1275,1545 1545,1605
megabyte blocks| and that's gonna
|这样效率会高得多。

405
00:11:00,480 --> 00:11:01,920
0,90 90,240 240,420 420,710
be way more efficient,

406
00:11:02,150 --> 00:11:03,400
0,400
right.|
|

407
00:11:03,500 --> 00:11:04,150
0,230 230,305 305,410 410,530 530,650
If you just think of
如果你只是，想像在一个网站上或下载一些关于互联网的东西，

408
00:11:04,150 --> 00:11:05,160
0,150 150,285 285,375 375,615 615,1010
like on a website or

409
00:11:05,390 --> 00:11:06,295
0,320 320,485 485,575 575,740 740,905
download something about the Internet,|
|

410
00:11:06,295 --> 00:11:08,020
0,90 90,180 180,285 285,545 1495,1725
if I can go open
如果我可以打开一个单一的连接，并获得我需要的所有数据，

411
00:11:08,020 --> 00:11:08,830
0,75 75,180 180,375 375,630 630,810
up a single connection and

412
00:11:08,830 --> 00:11:09,430
0,105 105,225 225,345 345,465 465,600
get all the data,| I
|而不是打开不同的连接，

413
00:11:09,430 --> 00:11:10,300
0,180 180,390 390,600 600,765 765,870
need rather than opening up

414
00:11:10,300 --> 00:11:12,400
0,180 180,500 1390,1695 1695,1890 1890,2100
different connections,| the the one
|一次 fetch ，这将是更快的。

415
00:11:12,400 --> 00:11:13,000
0,270 270,450 450,495 495,525 525,600
fetch, it's going to be

416
00:11:13,000 --> 00:11:14,020
0,260
faster.|
|

417
00:11:14,510 --> 00:11:15,550
0,260 260,395 395,605 605,860 860,1040
At the hardware level,| think
在硬件层面，|可以把它想像成一个旋转磁盘硬盘，

418
00:11:15,550 --> 00:11:16,285
0,105 105,210 210,360 360,600 600,735
of like a spinning disk

419
00:11:16,285 --> 00:11:17,500
0,180 180,360 360,600 600,1020 1020,1215
hard drive| and laptops don't
|笔记本电脑不再附带这些，

420
00:11:17,500 --> 00:11:18,460
0,75 75,150 150,330 330,675 675,960
come with these anymore,| they
|它们仍然存在于企业界，

421
00:11:18,460 --> 00:11:19,495
0,225 225,480 480,660 660,825 825,1035
still exist in the enterprise

422
00:11:19,495 --> 00:11:20,875
0,305 595,840 840,1050 1050,1245 1245,1380
world,| but there's, there's a
|有一只有形的手臂在盘上旋转，

423
00:11:20,875 --> 00:11:22,915
0,305 325,725 1075,1605 1605,1905 1905,2040
physical arm that's spinning around

424
00:11:22,915 --> 00:11:23,560
0,105 105,195 195,375 375,540 540,645
on a platter,| like a
|就像一张黑胶唱片，

425
00:11:23,560 --> 00:11:25,270
0,300 300,560 970,1290 1290,1530 1530,1710
vinyl record, right,| like that
|就像老人所有的，

426
00:11:25,270 --> 00:11:26,670
0,150 150,330 330,620 850,1125 1125,1400
old people have,| and so
|所以，如果你必须通过移动手臂来获得数据，

427
00:11:26,750 --> 00:11:28,030
0,335 335,545 545,710 710,980 980,1280
if you had to plot

428
00:11:28,030 --> 00:11:28,840
0,225 225,375 375,525 525,675 675,810
move the arm to get

429
00:11:28,840 --> 00:11:30,750
0,290 760,1065 1065,1245 1245,1515 1515,1910
data,| moving that arm is
|移动手臂是一件物理上的事情，

430
00:11:30,890 --> 00:11:32,170
0,290 290,395 395,665 665,965 965,1280
it's a physical thing,| it's
|它很昂贵，

431
00:11:32,170 --> 00:11:33,475
0,225 225,645 645,885 885,1050 1050,1305
expensive,| it's you're actually moving
|你实际上是在通过[氦]移动一些东西，

432
00:11:33,475 --> 00:11:36,325
0,365 745,1145 1195,1595 2155,2625 2625,2850
something through through [helium],| but
|但你移动一些东西，在盘上移动手臂。

433
00:11:36,325 --> 00:11:38,455
0,285 285,465 465,815 1705,1995 1995,2130
you're moving something, moving the

434
00:11:38,455 --> 00:11:40,440
0,135 135,270 270,375 375,665
arm on the platter.|
|

435
00:11:40,730 --> 00:11:41,815
0,305 305,485 485,650 650,890 890,1085
If I have to, if
如果我只需移动手臂一次，

436
00:11:41,815 --> 00:11:42,325
0,105 105,195 195,285 285,405 405,510
I can just move the

437
00:11:42,325 --> 00:11:43,240
0,150 150,435 435,660 660,780 780,915
arm once| and then read
|然后不再移动一次就可以读取一大堆数据，

438
00:11:43,240 --> 00:11:44,245
0,90 90,165 165,285 285,560 700,1005
a bunch of data without

439
00:11:44,245 --> 00:11:45,760
0,180 180,345 345,635 775,1140 1140,1515
moving it again,| that's sequential
|这就是顺序访问，

440
00:11:45,760 --> 00:11:46,620
0,195 195,420 420,465 465,570 570,860
access,| that's to be faster,|
|这会更快，|

441
00:11:46,880 --> 00:11:47,560
0,245 245,335 335,425 425,545 545,680
if I had to pick
如果我必须拿起手臂，一遍又一遍地移动它，

442
00:11:47,560 --> 00:11:48,160
0,105 105,240 240,390 390,495 495,600
the arm up and move

443
00:11:48,160 --> 00:11:49,020
0,120 120,270 270,390 390,540 540,860
it over and over again,|
|

444
00:11:49,100 --> 00:11:50,160
0,260 260,455 455,560 560,710 710,1060
then that's going much slower.|
那么速度会慢得多。|

445
00:11:50,330 --> 00:11:51,600
0,305 305,515 515,770 770,965 965,1270
And again, we'll see this,|
我们将看到这一点，|

446
00:11:51,620 --> 00:11:53,880
0,400 660,965 965,1115 1115,1360 1860,2260
when this come up in
当执行算法出现时，

447
00:11:54,050 --> 00:11:56,760
0,320 320,605 605,1060 1440,1840 2310,2710
the execution algorithms,| that certain
|某些算法将被选择以最大化顺序访问。

448
00:11:57,320 --> 00:11:58,255
0,290 290,395 395,590 590,770 770,935
algorithms will choose that will

449
00:11:58,255 --> 00:12:00,160
0,480 480,840 840,1175
maximize sequential access.|
|

450
00:12:00,160 --> 00:12:01,180
0,210 210,390 390,555 555,780 780,1020
And we'll choose those over
我们会选择那些，而不是更随机访问的东西，

451
00:12:01,180 --> 00:12:02,110
0,195 195,390 390,495 495,720 720,930
something that's more random access,|
|

452
00:12:02,110 --> 00:12:02,920
0,105 105,225 225,390 390,615 615,810
and this is different than
这可能不同于你在入门课程中对算法的看法，

453
00:12:02,920 --> 00:12:03,880
0,180 180,360 360,495 495,675 675,960
maybe how you think about

454
00:12:03,880 --> 00:12:06,240
0,345 345,620 1210,1635 1635,1910 1960,2360
algorithms in intro classes,| because
|因为在那个世界里，

455
00:12:06,500 --> 00:12:07,800
0,290 290,500 500,725 725,965 965,1300
in that world,| they assume
|他们假设一切都是内存，访问总是相同的，

456
00:12:07,820 --> 00:12:08,880
0,470 470,620 620,725 725,815 815,1060
everything's always going to be

457
00:12:09,350 --> 00:12:10,420
0,245 245,470 470,710 710,890 890,1070
the memory, access is always

458
00:12:10,420 --> 00:12:11,440
0,135 135,410
the same,|
|

459
00:12:11,960 --> 00:12:12,880
0,260 260,440 440,635 725,785 785,920
in our world, we're dealing
在我们的世界里，我们处理的是真正的硬件，

460
00:12:12,880 --> 00:12:13,870
0,120 120,255 255,555 555,825 825,990
with real hardware,| so we
|所以我们不能做出这样的假设。

461
00:12:13,870 --> 00:12:15,740
0,210 210,315 315,480 480,950
can't make that assumption.|
|

462
00:12:16,960 --> 00:12:18,360
0,320 320,640
{All,right}, so,
好的，所以，让我讨论，

463
00:12:18,420 --> 00:12:19,970
0,305 305,455 455,700 960,1340 1340,1550
{let,me} talk about,| so the
|所以我们思考这个问题的方式是，

464
00:12:19,970 --> 00:12:20,570
0,105 105,270 270,360 360,480 480,600
way we'll think about this

465
00:12:20,570 --> 00:12:22,010
0,135 135,410 820,1185 1185,1305 1305,1440
is that,| I'll use the
|我会在这节课上使用术语内存，

466
00:12:22,010 --> 00:12:23,165
0,150 150,440 490,735 735,870 870,1155
term memory in this class|
|

467
00:12:23,165 --> 00:12:23,975
0,240 240,405 405,495 495,630 630,810
and I'll just mean here.
我的意思只是 DRAM ，

468
00:12:23,975 --> 00:12:25,630
0,195 195,285 285,545 895,1275 1275,1655
I'll just mean, mean DRAM,|
|

469
00:12:26,610 --> 00:12:27,710
0,245 245,335 335,455 455,650 650,1100
and when I say disk,|
当我说磁盘的时候，|

470
00:12:27,710 --> 00:12:28,400
0,135 135,165 165,210 210,420 420,690
I'm going to mean anything
我的意思是这下面的所有，

471
00:12:28,400 --> 00:12:30,140
0,270 270,650 730,1130 1420,1665 1665,1740
below that, right,| so an
|SSD ，旋转磁盘硬盘或网络云存储。

472
00:12:30,140 --> 00:12:32,140
0,560 1150,1425 1425,1560 1560,1710 1710,2000
SSD, spinning disk hard drive

473
00:12:32,820 --> 00:12:34,090
0,305 305,485 485,710 710,965 965,1270
or a network cloud storage.|
|

474
00:12:35,080 --> 00:12:36,435
0,400 540,890 890,1085 1085,1205 1205,1355
The, the, the ones up
上面的 CPU 寄存器，

475
00:12:36,435 --> 00:12:38,055
0,180 180,330 330,570 570,1025 1345,1620
here, the CPU registers,| we
|我们不会在这门课上讨论这些，

476
00:12:38,055 --> 00:12:39,000
0,255 255,465 465,630 630,780 780,945
won't discuss these in this

477
00:12:39,000 --> 00:12:40,665
0,290 580,980 1060,1320 1320,1455 1455,1665
class,| {} in the advanced
|在高级课程中，

478
00:12:40,665 --> 00:12:41,610
0,255 255,480 480,600 600,720 720,945
class,| we'll talk about different
|我们将讨论不同算法的方法，

479
00:12:41,610 --> 00:12:42,800
0,315 315,420 420,540 540,795 795,1190
algorithms of the methods to|
|

480
00:12:42,910 --> 00:12:44,145
0,230 230,365 365,935 935,1100 1100,1235
try to maximize the amount
试图最大限度地处理 CPU 寄存器或 L3 L2 缓存中的数据，

481
00:12:44,145 --> 00:12:45,135
0,135 135,395 415,720 720,870 870,990
of processing being do of

482
00:12:45,135 --> 00:12:47,090
0,275 655,990 990,1290 1290,1680 1680,1955
data in CPU registers or

483
00:12:47,110 --> 00:12:48,920
0,350 350,700 840,1145 1145,1310 1310,1810
{L3 -} {L2 -} caches,|
|

484
00:12:49,420 --> 00:12:50,215
0,105 105,210 210,360 360,600 600,795
and in that world, you
在那个世界里，你可以做出巨大的改变。

485
00:12:50,215 --> 00:12:50,880
0,75 75,165 165,270 270,390 390,665
can make a huge difference.|
|

486
00:12:52,860 --> 00:12:53,915
0,365 365,545 545,695 695,950 950,1055
It's also worth noting,| there
还值得注意的是，|现在有一些新兴的硬件设备或硬件，

487
00:12:53,915 --> 00:12:56,110
0,195 195,545 1255,1590 1590,1860 1860,2195
are some emerging hardware devices

488
00:12:56,130 --> 00:12:57,245
0,275 275,440 440,650 650,815 815,1115
or hardware,| that's available today
|可以跨不同的层使用，

489
00:12:57,245 --> 00:13:00,420
0,315 315,665 1735,2040 2040,2495
that spans different layers,|
|

490
00:13:00,890 --> 00:13:01,975
0,275 275,395 395,515 515,790 840,1085
so you can get sort
你可以获得某种快速网络存储或分散存储或分散内存，

491
00:13:01,975 --> 00:13:03,610
0,120 120,375 375,720 720,1085 1375,1635
of fast network storage or

492
00:13:03,610 --> 00:13:05,280
0,540 540,810 810,1020 1020,1395 1395,1670
disaggregated storage or disaggregated memory,|
|

493
00:13:05,600 --> 00:13:08,280
0,260 260,485 485,845 845,1240
where this looks like,|
就像这样，|

494
00:13:08,480 --> 00:13:09,775
0,305 305,515 515,800 800,1055 1055,1295
it could potentially could be
它可能是可寻址的，

495
00:13:09,775 --> 00:13:11,365
0,315 315,870 870,1080 1080,1335 1335,1590
by addressable,| but you're going
|但你是通过物理网络进行的，

496
00:13:11,365 --> 00:13:13,225
0,335 355,755 1045,1380 1380,1680 1680,1860
over a physical network,| so
|所以速度会稍微慢一些，

497
00:13:13,225 --> 00:13:13,890
0,120 120,165 165,240 240,360 360,665
it's a little bit slower,|
|

498
00:13:15,110 --> 00:13:16,375
0,400 480,770 770,905 905,1025 1025,1265
so it sort of straddles
所以它横跨在这之间。

499
00:13:16,375 --> 00:13:18,610
0,165 165,405 405,725 1855,2115 2115,2235
in between here.| And then
|然后有一种叫做持久内存的东西，

500
00:13:18,610 --> 00:13:19,720
0,105 105,210 210,420 420,660 660,1110
there was something called persistent

501
00:13:19,720 --> 00:13:22,345
0,260 820,1220 1900,2220 2220,2385 2385,2625
memory,| that people have been
|人们梦想了很长时间，

502
00:13:22,345 --> 00:13:23,290
0,405 405,570 570,675 675,765 765,945
dreaming about for a long

503
00:13:23,290 --> 00:13:25,710
0,320 610,1010 1480,1770 1770,2040 2040,2420
time,| that would have the
|这将具有 DRAM 的可寻址能力，

504
00:13:25,760 --> 00:13:28,240
0,400 1500,1790 1790,1925 1925,2060 2060,2480
benefits, have the by addressability

505
00:13:28,240 --> 00:13:29,485
0,165 165,315 315,590 760,1080 1080,1245
of {DRAM -},| but also
|以及 SSD 的持久性，

506
00:13:29,485 --> 00:13:32,230
0,105 105,660 660,995 1495,1895 2485,2745
the persistence of of an

507
00:13:32,230 --> 00:13:33,850
0,560 970,1215 1215,1290 1290,1425 1425,1620
SSD| and it would actually
|并且它实际上将位于[暗槽]中，

508
00:13:33,850 --> 00:13:34,675
0,150 150,240 240,345 345,555 555,825
sit in the [dim slot],|
|

509
00:13:34,675 --> 00:13:35,515
0,165 165,285 285,435 435,660 660,840
so you could write to
所以你可以把它当做内存来写，

510
00:13:35,515 --> 00:13:36,750
0,245 385,675 675,840 840,975 975,1235
it as if it was

511
00:13:37,700 --> 00:13:38,560
0,365 365,560 560,620 620,725 725,860
memory,| but if you pull
|但如果你拔下插头，一切都会保留下来。

512
00:13:38,560 --> 00:13:40,230
0,135 135,410 880,1140 1140,1260 1260,1670
the plug, everything gets retained.|
|

513
00:13:41,250 --> 00:13:42,020
0,260 260,380 380,500 500,650 650,770
And this is something when
这是 10 年前，我刚在 CMU 的时候，

514
00:13:42,020 --> 00:13:43,235
0,165 165,345 345,590 760,1035 1035,1215
I, when I first started

515
00:13:43,235 --> 00:13:46,000
0,480 480,875 2005,2265 2265,2445 2445,2765
CMU, {} 10 years ago,|
|

516
00:13:46,950 --> 00:13:47,735
0,275 275,455 455,635 635,725 725,785
we were spending a lot
我们花了很多时间研究的东西，

517
00:13:47,735 --> 00:13:48,815
0,105 105,255 255,645 645,855 855,1080
of time researching this,| this
|这是一件非常有趣的事情，

518
00:13:48,815 --> 00:13:49,550
0,120 120,270 270,405 405,495 495,735
is something that was very

519
00:13:49,550 --> 00:13:51,020
0,225 225,470 550,950 1060,1320 1320,1470
interesting about,| because if we
|因为如果我们有这种持久内存，

520
00:13:51,020 --> 00:13:53,230
0,225 225,450 450,855 855,1100 1810,2210
had this persistent memory,| basically
|基本上我两周时间要谈论的所有东西，

521
00:13:53,280 --> 00:13:54,140
0,290 290,470 470,620 620,725 725,860
all the stuff that I'm

522
00:13:54,140 --> 00:13:55,340
0,45 45,105 105,270 270,590
going to talk about

523
00:13:55,590 --> 00:13:56,900
0,290 290,425 425,635 635,965 965,1310
in two weeks,| actually, project
|实际上，这门课的项目 #1 就基本结束了，

524
00:13:56,900 --> 00:13:58,175
0,380 430,675 675,795 795,990 990,1275
one in this class basically

525
00:13:58,175 --> 00:13:59,520
0,300 300,635
goes away,

526
00:13:59,630 --> 00:14:00,415
0,320 320,470 470,545 545,695 695,785
right,| because I don't need
|因为我不需要担心将东西移入和移出磁盘，

527
00:14:00,415 --> 00:14:01,150
0,90 90,210 210,360 360,540 540,735
to worry about moving things

528
00:14:01,150 --> 00:14:02,010
0,120 120,180 180,270 270,390 390,860
in and out of disk,|
|

529
00:14:02,810 --> 00:14:04,440
0,305 305,470 470,1000
{everything,in,memory} is persistent.|
内存中的任何东西是持久的。|

530
00:14:05,250 --> 00:14:06,635
0,260 260,395 395,575 575,880 1110,1385
They might know if anybody
他们可能知道有没有人实现这个，

531
00:14:06,635 --> 00:14:07,910
0,195 195,375 375,525 525,815 985,1275
actually to make this,| this
|这个持久的非易失性内存。

532
00:14:07,910 --> 00:14:09,680
0,420 420,795 795,1040
persistent non-volatile memory.|
|

533
00:14:09,830 --> 00:14:15,450
0,400 4800,5105 5105,5270 5270,5375 5375,5620
Yes, boom, there you go.|
是的，砰，这就对了。|

534
00:14:18,140 --> 00:14:19,345
0,290 290,440 440,605 605,910 960,1205
Yes, so he said you
是的，他说，你可以用 SSD 来尝试，

535
00:14:19,345 --> 00:14:19,975
0,105 105,270 270,435 435,540 540,630
could try this with an

536
00:14:19,975 --> 00:14:21,025
0,510 510,780 780,915 915,990 990,1050
SSD,| asked people to do
|要求人们这样做，

537
00:14:21,025 --> 00:14:21,865
0,120 120,240 240,420 420,630 630,840
that,| but that's not true
|但那不是真正的持久内存。

538
00:14:21,865 --> 00:14:23,620
0,330 330,575 1045,1395 1395,1620 1620,1755
persistent memory.| Or then you
|或者你说的 Intel OPTANE ，

539
00:14:23,620 --> 00:14:25,285
0,120 120,375 375,800 940,1320 1320,1665
said Intel OPTANE,| Intel OPTANE
|Intel OPTANE 实际上是一种 SSD ，

540
00:14:25,285 --> 00:14:26,440
0,195 195,315 315,435 435,960 960,1155
actually was an SSD,| it
|这实际上是相变内存，

541
00:14:26,440 --> 00:14:27,730
0,180 180,530 580,900 900,1110 1110,1290
was actually phase change memory,|
|

542
00:14:27,730 --> 00:14:28,765
0,210 210,420 420,600 600,765 765,1035
it actually was a physical
它实际上是一个物理设备，

543
00:14:28,765 --> 00:14:30,325
0,345 345,570 570,735 735,1025 1255,1560
device,| that could do was
|可以做的是持久内存，

544
00:14:30,325 --> 00:14:31,440
0,405 405,665
persistent memory,

545
00:14:31,440 --> 00:14:33,615
0,290 700,1215 1215,1365 1365,1965 1965,2175
right,| HP had {[memory,registers]},| there
|HP 有内存寄存器，|有传闻 IBM 有一些东西，

546
00:14:33,615 --> 00:14:35,090
0,245 265,780 780,1050 1050,1185 1185,1475
was IBM rumored has something,|
|

547
00:14:35,440 --> 00:14:36,390
0,425 425,515 515,605 605,770 770,950
Intel is the only one
Intel 是唯一一家真正做到这个的公司。

548
00:14:36,390 --> 00:14:37,940
0,210 210,405 405,540 540,830
that actually made this.|
|

549
00:14:38,420 --> 00:14:39,340
0,275 275,410 410,620 620,830 830,920
Who here has heard of
在座的谁听说过 Intel OPTANE？

550
00:14:39,340 --> 00:14:41,005
0,225 225,650 1030,1290 1290,1455 1455,1665
Intel OPTANE?| Well, he obviously
|嗯，他显然是，非常非常少。

551
00:14:41,005 --> 00:14:43,060
0,305 475,810 810,1050 1050,1355
yes, very, very few.|
|

552
00:14:44,030 --> 00:14:45,835
0,425 425,680 680,815 815,1120 1560,1805
It's, it's already dead,| so
它已经死了，|Intel 去年杀死了它，

553
00:14:45,835 --> 00:14:46,890
0,270 270,450 450,585 585,750 750,1055
Intel killed it last year,|
|

554
00:14:48,080 --> 00:14:49,765
0,400 870,1295 1295,1445 1445,1565 1565,1685
basically, Intel hired a new
Intel 聘请了一位新的 CEO ，

555
00:14:49,765 --> 00:14:51,130
0,390 390,755 865,1155 1155,1290 1290,1365
CEO| and they cut a
|他们削减了一大批部门，

556
00:14:51,130 --> 00:14:52,170
0,90 90,180 180,450 450,720 720,1040
bunch of divisions| and unfortunately,
|不幸的是，他们削减了这个，

557
00:14:52,670 --> 00:14:53,665
0,260 260,395 395,650 650,875 875,995
they cut this,| and this
|这很糟糕，

558
00:14:53,665 --> 00:14:54,505
0,255 255,375 375,540 540,690 690,840
sucks,| because like, to me,|
|因为对我来说，|

559
00:14:54,505 --> 00:14:56,035
0,180 180,345 345,635 1135,1410 1410,1530
this is like, this would
这就像是，这本来可以改变游戏规则，

560
00:14:56,035 --> 00:14:56,815
0,75 75,150 150,240 240,405 405,780
have been a game changer,|
|

561
00:14:56,815 --> 00:14:58,525
0,305 445,1055 1165,1485 1485,1575 1575,1710
but Intel couldn't make any
但 Intel 无法从中获利，

562
00:14:58,525 --> 00:14:59,515
0,150 150,285 285,390 390,635 745,990
money off of it,| and
|同样糟糕的是，

563
00:14:59,515 --> 00:15:00,370
0,105 105,375 375,585 585,735 735,855
what sucks also too is

564
00:15:00,370 --> 00:15:01,270
0,195 195,480 480,690 690,840 840,900
like,| now no one's going
|现在没有人会在下一个十年里尝试这一技术，

565
00:15:01,270 --> 00:15:01,975
0,105 105,255 255,390 390,510 510,705
to try this for another

566
00:15:01,975 --> 00:15:04,300
0,335 895,1295 1615,1875 1875,2190 2190,2325
decade,| because if Intel couldn't
|因为如果 Intel 不能从中获利，

567
00:15:04,300 --> 00:15:05,130
0,150 150,330 330,480 480,585 585,830
make money off of it,|
|

568
00:15:05,480 --> 00:15:07,400
0,255 255,530 820,1220
who will, right.|
谁又能呢。|

569
00:15:07,650 --> 00:15:08,960
0,260 260,395 395,575 575,880 960,1310
But there was a various
但是不同的数据库公司有不同的项目，

570
00:15:08,960 --> 00:15:10,550
0,350 580,855 855,1050 1050,1305 1305,1590
projects at different database companies,|
|

571
00:15:10,550 --> 00:15:11,470
0,195 195,345 345,495 495,630 630,920
they were trying to build
他们试图围绕持久内存构建数据库系统，

572
00:15:11,760 --> 00:15:14,465
0,335 335,670 810,1210 1440,1840 2220,2705
database systems just around persistent

573
00:15:14,465 --> 00:15:15,950
0,245 505,795 795,1020 1020,1275 1275,1485
memory,| because again, a bunch
|因为同样，我们必须做的一大堆事情，

574
00:15:15,950 --> 00:15:16,490
0,135 135,225 225,330 330,450 450,540
of the stuff we had

575
00:15:16,490 --> 00:15:17,195
0,60 60,165 165,285 285,465 465,705
to do| with moving data
|在磁盘和内存之间来回移动数据会随之消失。

576
00:15:17,195 --> 00:15:18,755
0,165 165,300 300,495 495,815 1225,1560
back and forth between disk

577
00:15:18,755 --> 00:15:20,150
0,75 75,335 565,900 900,1170 1170,1395
and memory goes away with

578
00:15:20,150 --> 00:15:21,880
0,290 910,1200 1200,1410 1410,1485 1485,1730
this.| So that's a shame.|
|所以这是一种遗憾。|

579
00:15:23,340 --> 00:15:24,300
0,400
Okay,
好的，我们必须了解，

580
00:15:24,930 --> 00:15:26,195
0,380 380,620 620,830 830,1100 1100,1265
so the reason why we

581
00:15:26,195 --> 00:15:27,155
0,105 105,195 195,330 330,810 810,960
have to be cognizant| of
|存储是什么样子的原因是，

582
00:15:27,155 --> 00:15:27,845
0,165 165,330 330,480 480,615 615,690
what the storage are going

583
00:15:27,845 --> 00:15:28,835
0,75 75,225 225,435 435,705 705,990
to look like is,| because
|因为性能特征，

584
00:15:28,835 --> 00:15:31,265
0,315 315,630 630,1385 2005,2280 2280,2430
the performance characteristics,| as I
|正如我所说的，这些不同设备之间截然不同，

585
00:15:31,265 --> 00:15:32,225
0,225 225,420 420,525 525,690 690,960
said, between these different devices

586
00:15:32,225 --> 00:15:33,650
0,225 225,300 300,360 360,605 925,1425
are going to be dramatically

587
00:15:33,650 --> 00:15:34,780
0,380
different,|
|

588
00:15:35,140 --> 00:15:36,165
0,365 365,620 620,680 680,815 815,1025
and we're going to try
我们将尝试最大限度地提高数据的工作量，

589
00:15:36,165 --> 00:15:38,295
0,225 225,965 1495,1770 1770,1950 1950,2130
to maximize the amount of

590
00:15:38,295 --> 00:15:39,210
0,180 180,345 345,480 480,690 690,915
work we can do| for
|当数据存储在内存中时，

591
00:15:39,210 --> 00:15:40,650
0,290 610,885 885,1065 1065,1185 1185,1440
data when it's in memory,|
|

592
00:15:40,650 --> 00:15:41,895
0,225 225,330 330,480 480,770 970,1245
when we bring something off
当我们将数据从磁盘移入内存时，

593
00:15:41,895 --> 00:15:43,095
0,135 135,345 345,450 450,725 955,1200
a disk into memory,| we
|我们希望尽可能多地处理这些数据，

594
00:15:43,095 --> 00:15:43,620
0,75 75,135 135,225 225,360 360,525
want to do as much

595
00:15:43,620 --> 00:15:44,450
0,150 150,270 270,405 405,555 555,830
work as we can on

596
00:15:44,470 --> 00:15:46,155
0,400 420,680 680,815 815,1090 1350,1685
that, on that data,| before
|在丢弃数据并将其他数据放入内存之前，

597
00:15:46,155 --> 00:15:47,130
0,270 270,465 465,600 600,795 795,975
we throw it away and

598
00:15:47,130 --> 00:15:48,050
0,150 150,330 330,495 495,645 645,920
bring something else into memory,

599
00:15:48,700 --> 00:15:49,915
0,240 240,375 375,585 585,885 885,1215
right.| In an ideal world,
|在理想情况下，我们的数据库应该完全存储在内存中，

600
00:15:49,915 --> 00:15:51,070
0,285 285,540 540,765 765,930 930,1155
our database would fit entirely

601
00:15:51,070 --> 00:15:52,615
0,165 165,410 970,1260 1260,1410 1410,1545
in memory,| even then you
|即使这样，你也必须写出磁盘，

602
00:15:52,615 --> 00:15:53,170
0,120 120,210 210,315 315,435 435,555
have to write out the

603
00:15:53,170 --> 00:15:54,025
0,300 300,405 405,510 510,645 645,855
disk,| but in some cases
|但在某些情况下，这并不总是可能的。

604
00:15:54,025 --> 00:15:56,970
0,615 615,735 735,900 900,1175 2545,2945
that's not always possible.| So
|实现这个的方法是，

605
00:15:57,140 --> 00:15:58,110
0,245 245,335 335,485 485,680 680,970
the way to this,| at
|在 CPU 级别，缓存未命中基本上是一纳秒，

606
00:15:58,160 --> 00:16:00,625
0,290 290,605 605,880 960,1360 2190,2465
the CPU level, right, a

607
00:16:00,625 --> 00:16:01,390
0,240 240,465 465,615 615,705 705,765
cache miss is going to

608
00:16:01,390 --> 00:16:03,000
0,230 340,615 615,840 840,1080 1080,1610
basically is going one nanosecond,|
|

609
00:16:03,410 --> 00:16:04,255
0,290 290,440 440,560 560,695 695,845
getting out of {DRAM -}
走出 DRAM 是数百纳秒，

610
00:16:04,255 --> 00:16:06,205
0,165 165,455 505,810 810,1565 1705,1950
is hundred hundred nanoseconds| and
|而 SSD 大约是 16 微秒或 16000 纳秒，

611
00:16:06,205 --> 00:16:08,695
0,495 495,645 645,905 1015,1415 1855,2490
ssd is about 16 microconds

612
00:16:08,695 --> 00:16:10,330
0,120 120,525 525,1140 1140,1500 1500,1635
or 16,000 nanoseconds,| that's actually
|这真的很不错，

613
00:16:10,330 --> 00:16:11,785
0,150 150,440 790,1140 1140,1275 1275,1455
pretty good,| spinning disk hard
|旋转磁盘硬盘是两百万纳秒，

614
00:16:11,785 --> 00:16:13,770
0,305 625,960 960,1155 1155,1305 1305,1985
drive two, two million nanoseconds|
|

615
00:16:13,790 --> 00:16:15,685
0,245 245,490 540,1175 1175,1415 1415,1895
and then EBS can fluctuate,|
然后 EBS 可能会波动，|

616
00:16:15,685 --> 00:16:16,810
0,195 195,315 315,420 420,585 585,1125
sometimes you get 50 milliseconds,
有时是 50 毫秒，有时是 500 毫秒，

617
00:16:16,810 --> 00:16:18,300
0,150 150,300 300,525 525,930 930,1490
sometimes you get 500 milliseconds,|
|

618
00:16:18,350 --> 00:16:19,570
0,275 275,545 545,890 890,1100 1100,1220
depends on how hot the
这取决于数据的热度，

619
00:16:19,570 --> 00:16:20,845
0,150 150,440 550,795 795,1020 1020,1275
data is| and then tape
|然后是磁带存档，再说一次，这是[冰冷的]，

620
00:16:20,845 --> 00:16:22,440
0,390 390,645 645,810 810,1085
archives, again this is,

621
00:16:22,450 --> 00:16:24,015
0,260 260,520 720,1130 1130,1310 1310,1565
this is [glacial],| you don't,
|你不想在它上面构建任何系统。

622
00:16:24,015 --> 00:16:24,630
0,75 75,180 180,225 225,405 405,615
you don't want to build

623
00:16:24,630 --> 00:16:26,115
0,135 135,300 300,480 480,770 1240,1485
any system off this.| So
|所以这个数据来自，

624
00:16:26,115 --> 00:16:27,735
0,225 225,585 585,965 985,1320 1320,1620
this, this data comes from,|
|

625
00:16:27,735 --> 00:16:29,460
0,365 1015,1305 1305,1485 1485,1620 1620,1725
{} this particular data here
这个特殊数据来自，

626
00:16:29,460 --> 00:16:30,495
0,225 225,495 495,585 585,855 855,1035
{comes,out},| there's a Berkeley website
|这里有一个伯克利的网站和一个链接，

627
00:16:30,495 --> 00:16:31,635
0,165 165,240 240,390 390,695 865,1140
and a link there,| he
|他向你展示了硬件性能的趋势

628
00:16:31,635 --> 00:16:32,205
0,120 120,210 210,330 330,450 450,570
sort of shows you the

629
00:16:32,205 --> 00:16:33,260
0,180 180,315 315,405 405,660 660,1055
trends of the hardware performance|
|

630
00:16:33,400 --> 00:16:34,500
0,275 275,455 455,680 680,950 950,1100
or the the speeds of
或这些设备随着时间的推移的速度，

631
00:16:34,500 --> 00:16:36,420
0,225 225,450 450,675 675,980 1390,1920
these devices over time,| it's
|这张表被认为是 Jeff Dean 在 2000 年早期的贡献，

632
00:16:36,420 --> 00:16:37,770
0,360 360,735 735,1020 1020,1170 1170,1350
this, this table has been

633
00:16:37,770 --> 00:16:39,105
0,300 300,465 465,645 645,980 1090,1335
attributed to Jeff Dean from

634
00:16:39,105 --> 00:16:40,860
0,75 75,210 210,375 375,635 1435,1755
the early {2000s -}, {}|
|

635
00:16:40,860 --> 00:16:41,865
0,320 340,600 600,720 720,840 840,1005
actually I think it might
我认为它可能早于他之前。

636
00:16:41,865 --> 00:16:43,970
0,330 330,635 805,1125 1125,1445 1705,2105
predate him before that. {}|
|

637
00:16:44,350 --> 00:16:45,615
0,260 260,365 365,500 500,790 870,1265
And so as humans, it's
所以作为人类，我们很难推理纳秒，

638
00:16:45,615 --> 00:16:46,335
0,165 165,285 285,375 375,495 495,720
hard for us to reason

639
00:16:46,335 --> 00:16:48,285
0,285 285,930 930,1205 1525,1800 1800,1950
about nanoseconds, right,| like one
|比如一纳秒，这是什么意思，

640
00:16:48,285 --> 00:16:49,365
0,450 450,630 630,720 720,885 885,1080
nanosecond, what does that actually

641
00:16:49,365 --> 00:16:50,220
0,165 165,345 345,525 525,660 660,855
mean| or, or, you {know,2
|或者你知道 200 万纳秒，那是很长的时间吗？

642
00:16:50,220 --> 00:16:51,420
0,225 225,390 390,945 945,1095 1095,1200
-} million nanoseconds. Is that

643
00:16:51,420 --> 00:16:52,280
0,105 105,225 225,500
a long time?|
|

644
00:16:52,320 --> 00:16:53,645
0,400 660,935 935,1055 1055,1220 1220,1325
{} And so there's a
所以有一个简单的技巧可以让你意识到，

645
00:16:53,645 --> 00:16:55,355
0,275 925,1215 1215,1350 1350,1500 1500,1710
simple trick you can do

646
00:16:55,355 --> 00:16:57,200
0,300 300,600 600,905 985,1385 1555,1845
to realize| how much, how
|这到底有多大，有多糟糕，

647
00:16:57,200 --> 00:16:58,190
0,180 180,420 420,615 615,795 795,990
bad this actually is,| or
|或者事情实际上会变慢多少，

648
00:16:58,190 --> 00:16:59,045
0,105 105,225 225,435 435,660 660,855
how much slower things actually

649
00:16:59,045 --> 00:17:00,580
0,275 595,870 870,990 990,1185 1185,1535
get,| if you just change
|如果你把一纳秒改为一秒，

650
00:17:00,840 --> 00:17:02,380
0,290 290,770 770,965 965,1190 1190,1540
one nanosecond to one second,

651
00:17:03,120 --> 00:17:04,745
0,400 1050,1295 1295,1400 1400,1505 1505,1625
right.| So this is a
|这是一个小把戏，

652
00:17:04,745 --> 00:17:06,830
0,165 165,455 655,915 915,1175 1795,2085
trick,| that this is something
|Jim Gray 在上世纪 90 年代经常做的，

653
00:17:06,830 --> 00:17:07,550
0,165 165,330 330,480 480,600 600,720
that Jim Gray used to

654
00:17:07,550 --> 00:17:08,530
0,210 210,420 420,525 525,675 675,980
do in the {90s -},|
|

655
00:17:09,000 --> 00:17:10,625
0,245 245,335 335,485 485,790 1350,1625
if you just change one
如果你把一纳秒改为一秒，

656
00:17:10,625 --> 00:17:11,990
0,330 330,450 450,585 585,875 1045,1365
nanosecond to one second,| now
|现在你可以看到其他设备的速度慢了很多，

657
00:17:11,990 --> 00:17:14,105
0,225 225,530 640,960 960,1640 1720,2115
you see how massively slower

658
00:17:14,105 --> 00:17:15,425
0,195 195,390 390,645 645,965 1045,1320
these other devices are,| you
|你知道为什么要尽可能地将所有内容都保存在内存中了，

659
00:17:15,425 --> 00:17:16,115
0,180 180,390 390,525 525,600 600,690
see why you want to

660
00:17:16,115 --> 00:17:17,060
0,195 195,435 435,600 600,780 780,945
keep everything in memory as

661
00:17:17,060 --> 00:17:18,260
0,120 120,270 270,560
much as possible,

662
00:17:18,270 --> 00:17:20,240
0,400 870,1130 1130,1390 1500,1775 1775,1970
right.| And so you think,|
|所以你可以想，|

663
00:17:20,240 --> 00:17:21,035
0,255 255,435 435,555 555,675 675,795
like if I have to
如果我必须从一本书上读一页，

664
00:17:21,035 --> 00:17:21,815
0,180 180,360 360,540 540,675 675,780
read a page from a

665
00:17:21,815 --> 00:17:23,890
0,275 1075,1365 1365,1635 1635,1845 1845,2075
book| and say, you know,
|然后说， L1 缓存未命中就像走到桌边，查着书，

666
00:17:23,940 --> 00:17:25,055
0,320 320,515 515,665 665,905 905,1115
doing {L1 -} cache miss

667
00:17:25,055 --> 00:17:25,760
0,105 105,195 195,360 360,540 540,705
would be like me walking

668
00:17:25,760 --> 00:17:26,570
0,135 135,255 255,465 465,660 660,810
at this table and looking

669
00:17:26,570 --> 00:17:28,160
0,135 135,240 240,500 820,1220 1360,1590
in the book, right,| or
|或者，如果我必须从 SSD 或 DRAM 中读取，

670
00:17:28,160 --> 00:17:28,595
0,75 75,150 150,210 210,300 300,435
if I have to read

671
00:17:28,595 --> 00:17:30,365
0,120 120,180 180,725 925,1325 1495,1770
from an SSD or DRAM,|
|

672
00:17:30,365 --> 00:17:31,130
0,135 135,300 300,480 480,675 675,765
maybe it's walking over to
可能它会走到图书馆，然后找到那本书，

673
00:17:31,130 --> 00:17:31,910
0,75 75,285 285,495 495,600 600,780
the library and then finding

674
00:17:31,910 --> 00:17:33,905
0,180 180,440 1510,1785 1785,1905 1905,1995
the book,| but if I
|但如果我必须从磁带档案中读取，

675
00:17:33,905 --> 00:17:34,400
0,75 75,150 150,270 270,390 390,495
have to read from a

676
00:17:34,400 --> 00:17:35,645
0,135 135,510 510,735 735,1050 1050,1245
tape archive,| it's 31 years.
|那就是 31 年，这相当于飞到冥王星，

677
00:17:35,645 --> 00:17:37,070
0,330 330,495 495,785 865,1200 1200,1425
That's equivalent to flying to

678
00:17:37,070 --> 00:17:38,960
0,470 760,1035 1035,1310 1540,1785 1785,1890
Pluto, the planet,| and then
|然后读一本书。

679
00:17:38,960 --> 00:17:40,145
0,165 165,360 360,650 880,1110 1110,1185
reading one book.| So we
|所以，我们希望尽可能地避免这一切。

680
00:17:40,145 --> 00:17:41,075
0,90 90,240 240,525 525,780 780,930
want to avoid all of

681
00:17:41,075 --> 00:17:41,890
0,150 150,285 285,405 405,540 540,815
this as much as possible.|
|

682
00:17:43,170 --> 00:17:44,260
0,400
Okay?|
好的？|

683
00:17:45,300 --> 00:17:46,400
0,275 275,395 395,710 710,875 875,1100
So the sequential versus random,
所以顺序访问和随机访问，我们已经讨论过了，但在整个学期中，这将是一个反复出现的主题，数据库系统将再次倾向于顺序访问，而不是随机访问，无论是读还是写。当Spin得到硬盘时，这又一次产生了巨大的不同。但即使是在固态硬盘上，因为它们实际上是在ASX的幕后工作，然后进行压缩等，您也会尽可能地按顺序进行批处理区域写入。

684
00:17:46,400 --> 00:17:47,735
0,435 435,585 585,780 780,1080 1080,1335
we've occurred this, we, we

685
00:17:47,735 --> 00:17:48,680
0,135 135,285 285,570 570,825 825,945
discussed this already but again

686
00:17:48,680 --> 00:17:49,070
0,105 105,210 210,285 285,330 330,390
this is going to be

687
00:17:49,070 --> 00:17:51,350
0,75 75,570 570,890 1270,1670 1990,2280
a reoccurring theme, eh, throughout

688
00:17:51,350 --> 00:17:52,430
0,150 150,300 300,615 615,840 840,1080
the entire semester where again

689
00:17:52,430 --> 00:17:54,335
0,380 820,1080 1080,1305 1305,1650 1650,1905
the the database system is

690
00:17:54,335 --> 00:17:55,550
0,105 105,165 165,395 445,960 960,1215
going to prefer sequential access

691
00:17:55,550 --> 00:17:56,705
0,255 255,555 555,825 825,990 990,1155
over random access for both

692
00:17:56,705 --> 00:17:59,120
0,195 195,285 285,545 1885,2190 2190,2415
reads and writes. When spinning

693
00:17:59,120 --> 00:17:59,915
0,105 105,255 255,465 465,675 675,795
gets hard drives, again it

694
00:17:59,915 --> 00:18:00,905
0,120 120,255 255,405 405,695 745,990
makes a huge difference. But

695
00:18:00,905 --> 00:18:02,615
0,135 135,285 285,875 1375,1620 1620,1710
even on ssd because of

696
00:18:02,615 --> 00:18:03,560
0,75 75,210 210,465 465,750 750,945
the way they they actually

697
00:18:03,560 --> 00:18:04,505
0,150 150,360 360,525 525,735 735,945
work underneath the covers with

698
00:18:04,505 --> 00:18:05,285
0,75 75,405 405,525 525,600 600,780
the asx and then doing

699
00:18:05,285 --> 00:18:06,890
0,375 375,570 570,690 690,965 1225,1605
compaction and so forth, you're

700
00:18:06,890 --> 00:18:09,245
0,210 210,345 345,510 510,800 2020,2355
you're better off doing batch

701
00:18:09,245 --> 00:18:10,640
0,240 240,510 510,1080 1080,1275 1275,1395
region writes sequentially as much

702
00:18:10,640 --> 00:18:11,580
0,120 120,380
as possible.|
|

703
00:18:11,870 --> 00:18:13,040
0,400
Right.|
正确的。|

704
00:18:15,720 --> 00:18:16,700
0,320 320,485 485,575 575,725 725,980
Right. So the other system
正确的。因此，我们将拥有的其他系统设计目标以及我们如何选择如何构建我们的系统是，我们想要给人一种错觉，即我们完全在记忆中与戴维斯一起运作。

705
00:18:16,700 --> 00:18:17,390
0,255 255,435 435,585 585,630 630,690
design goals we're going to

706
00:18:17,390 --> 00:18:19,010
0,230 490,765 765,900 900,1160 1330,1620
have and how we choose

707
00:18:19,010 --> 00:18:19,520
0,135 135,225 225,315 315,405 405,510
how we want to build

708
00:18:19,520 --> 00:18:22,145
0,135 135,410 1660,1935 1935,2210 2350,2625
our system is that we

709
00:18:22,145 --> 00:18:23,020
0,120 120,225 225,360 360,480 480,875
want to give the illusion

710
00:18:23,250 --> 00:18:25,550
0,400 720,1120 1500,1865 1865,2135 2135,2300
that we are operating with

711
00:18:25,550 --> 00:18:26,800
0,105 105,350 400,765 765,990 990,1250
the Davis entirely in memory.|
|

712
00:18:27,820 --> 00:18:29,910
0,395 395,790 1260,1550 1550,1955 1955,2090
Again, for most databases aren't
再说一次，因为大多数数据库都没有那么大。大多数数据库的容量都不到10 GB。

713
00:18:29,910 --> 00:18:30,870
0,135 135,345 345,525 525,825 825,960
that big. Most databases are

714
00:18:30,870 --> 00:18:32,520
0,165 165,315 315,480 480,1040
less than ten gigabytes.|
|

715
00:18:32,520 --> 00:18:34,485
0,350 550,950 1150,1470 1470,1695 1695,1965
Right. Uh, but really massive
正确的。嗯，但是非常庞大的数据库，比如TB、GB和TB，PB EM，理想情况下你想要给人一种。

716
00:18:34,485 --> 00:18:36,600
0,630 630,935 1045,1320 1320,1770 1770,2115
databases like the terabytes, gigabytes

717
00:18:36,600 --> 00:18:39,210
0,90 90,495 495,1100 1150,1550 1960,2610
and terabytes, petabytes EM, ideally

718
00:18:39,210 --> 00:18:40,200
0,135 135,330 330,585 585,780 780,990
you want to give the

719
00:18:40,200 --> 00:18:41,740
0,350 430,830
appearance that.|
|

720
00:18:41,870 --> 00:18:42,670
0,230 230,305 305,440 440,575 575,800
Everything is already in memory,
一切都已经在内存中了，尽管它实际上并不是。

721
00:18:42,670 --> 00:18:43,980
0,285 285,525 525,780 780,945 1050,1310
even though it actually isn't.|
|

722
00:18:44,890 --> 00:18:45,445
0,75 75,150 150,360 360,465 465,555
And there's tricks we can
我们还可以做一些小把戏来隐藏远端等等。

723
00:18:45,445 --> 00:18:46,495
0,105 105,225 225,405 405,585 585,1050
do to hide the distalss

724
00:18:46,495 --> 00:18:47,740
0,180 180,315 315,575
and so forth.|
|

725
00:18:48,160 --> 00:18:50,010
0,260 260,520 540,940 1320,1625 1625,1850
And then, as since reading
然后，由于读写磁盘是如此昂贵，我们想在我们的系统设计中做一些其他的技巧来避免。

726
00:18:50,010 --> 00:18:51,170
0,270 270,540 540,630 630,825 825,1160
writing disk is so expensive,

727
00:18:52,750 --> 00:18:53,985
0,395 395,650 650,905 905,1145 1145,1235
we want to do a

728
00:18:53,985 --> 00:18:54,735
0,105 105,195 195,375 375,660 660,750
bunch of other tricks in

729
00:18:54,735 --> 00:18:55,550
0,165 165,345 345,435 435,540 540,815
our design of our system

730
00:18:55,630 --> 00:18:57,260
0,400 420,820
to avoid.|
|

731
00:18:57,390 --> 00:18:59,090
0,530 530,1060 1080,1340 1340,1520 1520,1700
Prolonged stalls or having the
长时间停顿或使系统显示为无响应。

732
00:18:59,090 --> 00:19:00,980
0,240 240,525 525,1310
system appear unresponsive.|
|

733
00:19:01,170 --> 00:19:02,690
0,350 350,650 650,905 905,1220 1220,1520
Right, because one that'll frustrate
是的，因为这会使应用程序或用户感到沮丧，因为他们认为系统卡住了，但您实际上是在从磁盘获取数据。但这也会导致其他问题，因为如果我们像锁住某个东西一样，因为我们必须从磁盘获取东西或从磁盘写入东西而停滞不前，这将减慢我们后面的其他人的速度。

734
00:19:02,690 --> 00:19:03,725
0,255 255,495 495,630 630,915 915,1035
the application or frustrate the

735
00:19:03,725 --> 00:19:04,850
0,180 180,360 360,605 745,1005 1005,1125
user because they think the

736
00:19:04,850 --> 00:19:07,010
0,465 465,860 1690,1935 1935,2055 2055,2160
system's stuck, but you're really

737
00:19:07,010 --> 00:19:08,615
0,315 315,435 435,570 570,1040 1360,1605
fetching things from disk. But

738
00:19:08,615 --> 00:19:09,290
0,225 225,435 435,525 525,615 615,675
this also is going to

739
00:19:09,290 --> 00:19:10,805
0,120 120,315 315,615 615,1010 1240,1515
cause other problems because if

740
00:19:10,805 --> 00:19:11,750
0,210 210,405 405,615 615,750 750,945
we're holding like a lock

741
00:19:11,750 --> 00:19:12,785
0,225 225,465 465,645 645,780 780,1035
on something and we stall

742
00:19:12,785 --> 00:19:13,415
0,255 255,390 390,465 465,525 525,630
because we have to get

743
00:19:13,415 --> 00:19:14,195
0,165 165,330 330,555 555,645 645,780
something from disk or write

744
00:19:14,195 --> 00:19:16,000
0,180 180,375 375,905 1165,1560 1560,1805
something from disk, that's gonna

745
00:19:16,230 --> 00:19:17,285
0,275 275,470 470,650 650,845 845,1055
slow down everybody else behind

746
00:19:17,285 --> 00:19:18,120
0,275
us.|
|

747
00:19:18,480 --> 00:19:19,475
0,260 260,365 365,470 470,785 785,995
And have a convoy effect.
并产生护航效应。所以有一堆，你知道，出于这个原因，我们想要尽可能地避免这种情况。

748
00:19:19,475 --> 00:19:20,315
0,210 210,450 450,525 525,660 660,840
So there's a bunch of,

749
00:19:20,315 --> 00:19:21,740
0,150 150,395 895,1140 1140,1260 1260,1425
you know, for this reason

750
00:19:21,740 --> 00:19:22,430
0,150 150,285 285,375 375,540 540,690
we want to avoid this

751
00:19:22,430 --> 00:19:23,840
0,105 105,210 210,345 345,620
as much as possible.|
|

752
00:19:23,990 --> 00:19:25,675
0,275 275,545 545,940 1020,1400 1400,1685
And again, because random access
再说一次，因为随机访问比顺序访问慢，所以我们希望最大化顺序访问。

753
00:19:25,675 --> 00:19:27,070
0,305 505,855 855,1005 1005,1080 1080,1395
is slower than its sequential

754
00:19:27,070 --> 00:19:28,480
0,320 670,915 915,1005 1005,1080 1080,1410
access, we want to maximize

755
00:19:28,480 --> 00:19:29,760
0,375 375,710
sequential access.|
|

756
00:19:31,580 --> 00:19:32,260
0,230 230,305 305,395 395,500 500,680
So what does this all
那么，这一切听起来像什么？

757
00:19:32,260 --> 00:19:33,540
0,225 225,530
sound like?|
|

758
00:19:35,180 --> 00:19:36,445
0,320 320,515 515,790 930,1160 1160,1265
Having the appearance, we have
有了外表，我们比实际拥有更多的记忆。

759
00:19:36,445 --> 00:19:37,375
0,180 180,405 405,570 570,735 735,930
more memory than we actually

760
00:19:37,375 --> 00:19:38,320
0,275
do.|
|

761
00:19:39,380 --> 00:19:41,215
0,305 305,610 1470,1685 1685,1775 1775,1835
Virtual memory, so we'll get
虚拟内存，所以我们稍后会讲到这一点。我将解释为什么我们不想从操作系统获得虚拟内存，以及为什么作为数据库系统开发人员和构建实际系统的工程师，我们总是想自己做尽可能多的事情，而不是依赖操作系统来做任何事情。

762
00:19:41,215 --> 00:19:42,565
0,90 90,180 180,285 285,545 1015,1350
this in a second. I'll

763
00:19:42,565 --> 00:19:43,360
0,180 180,390 390,555 555,735 735,795
explain why we don't want

764
00:19:43,360 --> 00:19:44,185
0,75 75,180 180,330 330,600 600,825
to do virtual memory from

765
00:19:44,185 --> 00:19:46,090
0,135 135,425 625,885 885,1145 1645,1905
the OS and why, as

766
00:19:46,090 --> 00:19:48,040
0,120 120,315 315,650 1000,1400 1660,1950
a database system developer, engineer

767
00:19:48,040 --> 00:19:49,690
0,195 195,405 405,570 570,830 1300,1650
building the actual system, we

768
00:19:49,690 --> 00:19:50,545
0,240 240,375 375,480 480,660 660,855
always want to do as

769
00:19:50,545 --> 00:19:51,895
0,135 135,270 270,450 450,755 1045,1350
much as we can ourselves

770
00:19:51,895 --> 00:19:52,915
0,300 300,600 600,780 780,900 900,1020
and not rely on the

771
00:19:52,915 --> 00:19:54,120
0,135 135,240 240,450 450,815
OS to do anything.|
|

772
00:19:55,070 --> 00:19:56,695
0,400 510,890 890,1265 1265,1505 1505,1625
So hi, this is our
嗨，这是我们的图表。这就是我们正在建造的。所以我们有一些数据库文件，复数。无所谓。我们可以讨论不同之处。我们在磁盘上有一些数据库文件，我们将把它拆分成几页。

773
00:19:56,695 --> 00:19:57,385
0,345 345,435 435,495 495,570 570,690
diagram. This is what we're

774
00:19:57,385 --> 00:19:59,410
0,215 685,975 975,1125 1125,1385 1735,2025
building. So we have some

775
00:19:59,410 --> 00:20:01,350
0,290 340,705 705,975 975,1280 1390,1940
database file or files, plural.

776
00:20:02,000 --> 00:20:03,670
0,260 260,470 470,700 1290,1535 1535,1670
It doesn't matter. We can

777
00:20:03,670 --> 00:20:05,245
0,285 285,525 525,770 1210,1455 1455,1575
discuss the differences. We have

778
00:20:05,245 --> 00:20:06,655
0,135 135,395 415,815 985,1290 1290,1410
some database file that's on

779
00:20:06,655 --> 00:20:08,170
0,545 805,1155 1155,1380 1380,1425 1425,1515
disk and we're going to

780
00:20:08,170 --> 00:20:08,940
0,120 120,210 210,285 285,450 450,770
break it up into pages.|
|

781
00:20:09,730 --> 00:20:10,635
0,245 245,530 530,740 740,830 830,905
And I'll describe what a
我会在一秒钟内描述一个页面，然后会有一些目录显示，这是我拥有的页面，这是找到它们的位置。一切都安排好了，以此类推。

782
00:20:10,635 --> 00:20:12,435
0,240 240,635 655,915 915,1175 1525,1800
page in a second, and

783
00:20:12,435 --> 00:20:13,530
0,165 165,255 255,465 465,900 900,1095
there'll be some directory that's

784
00:20:13,530 --> 00:20:14,130
0,60 60,150 150,300 300,510 510,600
going to say, here's what

785
00:20:14,130 --> 00:20:15,195
0,195 195,405 405,660 660,975 975,1065
pages I have, here's where

786
00:20:15,195 --> 00:20:16,035
0,105 105,240 240,465 465,705 705,840
to find them. That's all

787
00:20:16,035 --> 00:20:17,280
0,165 165,270 270,405 405,695
set and so forth.|
|

788
00:20:17,670 --> 00:20:18,790
0,275 275,470 470,680 680,815 815,1120
And then there'll be some
然后会有一些缓冲池，在那里分配内存，数据系统被分配，基本上是对操作系统调用Malloc，获得一些内存。然后，我们将把它用作从磁盘调入页面的中转区。

789
00:20:19,140 --> 00:20:21,730
0,425 425,700 1110,1510 2010,2300 2300,2590
buffer pool where of memory,

790
00:20:22,080 --> 00:20:23,140
0,230 230,335 335,485 485,605 605,1060
the data system is allocated,

791
00:20:23,310 --> 00:20:24,560
0,365 365,620 620,935 935,1085 1085,1250
basically called malloc against the

792
00:20:24,560 --> 00:20:26,645
0,290 520,825 825,990 990,1250 1810,2085
OS, got some memory. And

793
00:20:26,645 --> 00:20:27,230
0,135 135,270 270,315 315,405 405,585
then we're going to use

794
00:20:27,230 --> 00:20:28,480
0,270 270,510 510,675 675,1005 1005,1250
that as the staging area

795
00:20:28,530 --> 00:20:29,705
0,260 260,410 410,620 620,875 875,1175
where we bring pages in

796
00:20:29,705 --> 00:20:31,060
0,345 345,875
from disk.|
|

797
00:20:31,540 --> 00:20:32,520
0,245 245,365 365,500 500,710 710,980
So now if the execution
所以现在，如果执行引擎，即将运行的东西，我们的查询出现，它想要获得第二页。

798
00:20:32,520 --> 00:20:33,585
0,300 300,525 525,630 630,900 900,1065
engine, the thing that's going

799
00:20:33,585 --> 00:20:34,440
0,105 105,225 225,360 360,600 600,855
to run, our query comes

800
00:20:34,440 --> 00:20:36,795
0,320 670,1070 1660,1995 1995,2220 2220,2355
along and it wants to

801
00:20:36,795 --> 00:20:38,360
0,135 135,330 330,570 570,905
get page number two.|
|

802
00:20:38,360 --> 00:20:39,950
0,225 225,390 390,660 660,1010 1300,1590
We can ignore how it
我们可以忽略它是如何知道的。它现在想要第二页，但假设这就是它想要的，一页第二页。

803
00:20:39,950 --> 00:20:40,895
0,225 225,405 405,555 555,750 750,945
knows. It wants page number

804
00:20:40,895 --> 00:20:43,175
0,305 1165,1410 1410,1655 1795,2085 2085,2280
two for now, but assumes

805
00:20:43,175 --> 00:20:43,880
0,195 195,255 255,330 330,495 495,705
that's what it wants, one

806
00:20:43,880 --> 00:20:45,160
0,150 150,330 330,650
page number two.|
|

807
00:20:45,160 --> 00:20:45,940
0,225 225,315 315,465 465,645 645,780
So the very first thing
所以我们要做的第一件事是引入页面目录，因为这将告诉我们页面在哪里，然后它会调用操作系统或存储数据库文件的任何设备。我会把那一页记在记忆里。

808
00:20:45,940 --> 00:20:46,480
0,105 105,180 180,255 255,375 375,540
we got to do is

809
00:20:46,480 --> 00:20:47,515
0,150 150,270 270,375 375,570 570,1035
bring in the page directory,

810
00:20:47,515 --> 00:20:48,130
0,180 180,345 345,405 405,495 495,615
because that's going to tell

811
00:20:48,130 --> 00:20:50,950
0,260 640,1040 1240,1515 1515,1790 2560,2820
us where, where on the

812
00:20:50,950 --> 00:20:52,750
0,195 195,530 1000,1275 1275,1500 1500,1800
pages are, and then it'll

813
00:20:52,750 --> 00:20:53,800
0,90 90,225 225,500 550,840 840,1050
make a call to the

814
00:20:53,800 --> 00:20:55,465
0,320 760,1095 1095,1320 1320,1500 1500,1665
OS or whatever the device

815
00:20:55,465 --> 00:20:57,055
0,120 120,330 330,705 705,1025 1345,1590
it is that's storing the

816
00:20:57,055 --> 00:20:58,375
0,210 210,575 745,990 990,1170 1170,1320
database file. And I'll bring

817
00:20:58,375 --> 00:21:00,200
0,305 325,690 690,960 960,1265
that page into memory.|
|

818
00:21:00,200 --> 00:21:02,000
0,225 225,375 375,680 880,1280 1390,1800
And then now the buffer
现在，缓冲区拉回将返回执行引擎，内存中的一个指针，内存中该页所在位置的64位指针。

819
00:21:02,000 --> 00:21:02,990
0,120 120,270 270,450 450,690 690,990
pull will give back the

820
00:21:02,990 --> 00:21:05,690
0,270 270,590 1120,1455 1455,2000 2410,2700
execution engine, a pointer in

821
00:21:05,690 --> 00:21:06,965
0,225 225,420 420,780 780,930 930,1275
memory, a 64 bit pointer

822
00:21:06,965 --> 00:21:08,590
0,165 165,425 655,945 945,1230 1230,1625
in memory of where this

823
00:21:09,600 --> 00:21:10,940
0,350 350,700
page exists.|
|

824
00:21:11,410 --> 00:21:12,165
0,275 275,425 425,575 575,650 650,755
And now it's up to
现在，这取决于执行引擎或访问方法，即操作员，然后解释页面中的内容。

825
00:21:12,165 --> 00:21:13,140
0,165 165,420 420,660 660,810 810,975
the execution engine or the

826
00:21:13,140 --> 00:21:14,505
0,180 180,360 360,525 525,920 1120,1365
access method, the operators to

827
00:21:14,505 --> 00:21:15,660
0,195 195,495 495,825 825,990 990,1155
then interpret what's inside that

828
00:21:15,660 --> 00:21:16,740
0,290
page.|
|

829
00:21:16,740 --> 00:21:18,450
0,165 165,315 315,740 880,1425 1425,1710
Because all that's opaque to
因为所有这些对系统的其他部分来说都是不透明的，他们不会。

830
00:21:18,450 --> 00:21:19,680
0,380 550,855 855,1005 1005,1125 1125,1230
the, to the rest of

831
00:21:19,680 --> 00:21:21,160
0,90 90,315 315,510 510,800
the system, they don't.|
|

832
00:21:21,205 --> 00:21:21,985
0,60 60,195 195,390 390,555 555,780
It's not entirely true, but
这并不完全是真的，但在这一点上，他们并不真正需要知道。

833
00:21:21,985 --> 00:21:22,660
0,225 225,345 345,465 465,555 615,675
at this point they don't

834
00:21:22,660 --> 00:21:23,980
0,120 120,285 285,560
really need know.|
|

835
00:21:23,980 --> 00:21:24,910
0,195 195,315 315,585 585,750 750,930
And then let's say once
然后假设一旦你做了一系列更新，它就会对第二页中的任何内容进行更改，我不是说它是否是一个工具。我不是说它在哪里是一个索引，这并不重要。

836
00:21:24,910 --> 00:21:25,330
0,90 90,135 135,180 180,255 255,420
you do a bunch of

837
00:21:25,330 --> 00:21:26,845
0,315 315,645 645,930 930,1215 1215,1515
updates, it makes makes changes

838
00:21:26,845 --> 00:21:27,895
0,240 240,465 465,630 630,855 855,1050
to whatever's in page number

839
00:21:27,895 --> 00:21:29,110
0,305 445,750 750,870 870,1065 1065,1215
two, I'm not saying whether

840
00:21:29,110 --> 00:21:29,770
0,150 150,240 240,390 390,570 570,660
it's a tool. I'm not

841
00:21:29,770 --> 00:21:30,400
0,135 135,255 255,375 375,465 465,630
saying where it's an index,

842
00:21:30,400 --> 00:21:31,680
0,135 135,345 345,590
it doesn't matter.|
|

843
00:21:31,950 --> 00:21:32,840
0,260 260,395 395,590 590,755 755,890
And then now the data
然后，数据系统负责将其写回磁盘，以确保任何更改都是持久的。

844
00:21:32,840 --> 00:21:34,325
0,165 165,390 390,705 705,1070 1180,1485
system is responsible for writing

845
00:21:34,325 --> 00:21:35,645
0,195 195,375 375,615 615,915 915,1320
this back out to disk

846
00:21:35,645 --> 00:21:36,380
0,105 105,210 210,330 330,495 495,735
to make sure that any

847
00:21:36,380 --> 00:21:37,820
0,225 225,390 390,950
changes are persistent.|
|

848
00:21:38,990 --> 00:21:39,895
0,245 245,365 365,545 545,725 725,905
So this is, this is
这就是我们接下来三四节课要讲的内容。这就是我们要建造的建筑。在接下来的三节课中，我们将讨论页面是什么样子的，我们将讨论如何在六节课中写出DIS，以及在六节课中如何管理内存，然后我们将讨论如何在12节和13节课中执行查询。

849
00:21:39,895 --> 00:21:40,885
0,285 285,510 510,660 660,810 810,990
effectively where we're going for

850
00:21:40,885 --> 00:21:41,830
0,75 75,305 475,720 720,825 825,945
the next three or four

851
00:21:41,830 --> 00:21:43,770
0,440 1180,1455 1455,1575 1575,1680 1680,1940
lectures. This is the architecture

852
00:21:44,000 --> 00:21:44,790
0,290 290,335 335,395 395,515 515,790
we're going to be building.

853
00:21:45,380 --> 00:21:47,080
0,400 690,1055 1055,1265 1265,1460 1460,1700
So we'll discuss what pages

854
00:21:47,080 --> 00:21:49,000
0,240 240,530 1030,1430 1480,1740 1740,1920
look like in the next

855
00:21:49,000 --> 00:21:49,930
0,195 195,495 495,690 690,825 825,930
three lectures, three, four and

856
00:21:49,930 --> 00:21:52,270
0,260 700,1095 1095,1430 1900,2190 2190,2340
five, we'll discuss how to

857
00:21:52,270 --> 00:21:53,095
0,165 165,345 345,510 510,660 660,825
write things out the Dis

858
00:21:53,095 --> 00:21:55,795
0,225 225,545 1645,1980 1980,2315 2455,2700
in six and what, how

859
00:21:55,795 --> 00:21:56,730
0,75 75,225 225,450 450,645 645,935
to manage memory in six,

860
00:21:57,200 --> 00:21:58,300
0,260 260,365 365,590 590,875 875,1100
and then we'll discuss how

861
00:21:58,300 --> 00:21:59,920
0,180 180,375 375,495 495,920 1330,1620
to execute the queries here

862
00:21:59,920 --> 00:22:01,100
0,180 180,330 330,465 465,740
in twelve and thirteen.|
|

863
00:22:03,590 --> 00:22:04,720
0,230 230,335 335,560 560,830 830,1130
So our focus really today
所以我们今天真正关注的是。

864
00:22:04,720 --> 00:22:05,860
0,380
is.|
|

865
00:22:06,450 --> 00:22:07,520
0,260 260,380 380,560 560,830 830,1070
What are these things on
磁盘上的这些东西是什么？

866
00:22:07,520 --> 00:22:08,560
0,500
disk?|
|

867
00:22:09,030 --> 00:22:10,020
0,400
Okay.|
好吧。|

868
00:22:10,670 --> 00:22:11,695
0,230 230,320 320,440 440,700 780,1025
So I said before, what
所以我之前说过，这听起来像什么？

869
00:22:11,695 --> 00:22:13,060
0,90 90,210 210,390 390,695
does this sound like?|
|

870
00:22:13,160 --> 00:22:14,845
0,260 260,395 395,575 575,880 1470,1685
Everyone said virtual memory and
每个人都说虚拟记忆，你说，好的，为什么，为什么接下来的三节课，谈论你需要这节课？为什么要接下来的两节课呢？当操作系统可以为我们做这件事时，谈谈如何在磁盘之间来回管理内存。

871
00:22:14,845 --> 00:22:16,555
0,75 75,270 270,495 495,785 1375,1710
you say, OK, well why

872
00:22:16,555 --> 00:22:18,190
0,335 835,1170 1170,1380 1380,1500 1500,1635
do, why take the next

873
00:22:18,190 --> 00:22:20,965
0,165 165,495 495,705 705,1010 2530,2775
three lectures talking about you

874
00:22:20,965 --> 00:22:21,985
0,120 120,285 285,540 540,825 825,1020
need this lecture? Why take

875
00:22:21,985 --> 00:22:23,290
0,120 120,365 655,915 915,1155 1155,1305
the next two lectures after

876
00:22:23,290 --> 00:22:24,280
0,290 430,675 675,780 780,885 885,990
that? Talk about how to

877
00:22:24,280 --> 00:22:25,195
0,210 210,465 465,645 645,780 780,915
manage memory back and forth

878
00:22:25,195 --> 00:22:26,425
0,135 135,635 655,900 900,1050 1050,1230
from disk when the OS

879
00:22:26,425 --> 00:22:27,150
0,105 105,195 195,315 315,450 450,725
can do that for us.|
|

880
00:22:28,250 --> 00:22:29,215
0,215 215,395 395,635 635,860 860,965
Do you know what's the
您知道以这种方式使用虚拟内存的sysc调用是什么吗？

881
00:22:29,215 --> 00:22:30,030
0,240 240,330 330,450 450,555 555,815
sysc call you would use

882
00:22:30,110 --> 00:22:31,390
0,400 540,815 815,980 980,1160 1160,1280
to use virtual memory in

883
00:22:31,390 --> 00:22:32,300
0,105 105,380
this way?|
|

884
00:22:33,510 --> 00:22:35,930
0,290 290,580 780,1175 1175,1570 2100,2420
And map. Beautiful, excellent memory
和地图。漂亮的，优秀的内存映射文件。因此，这是在POS中。标准Windows有自己的版本，但这允许您获取磁盘上文件的内容，并将其映射到进程中的虚拟内存中，在您的进程的地址中。现在，该进程可以跳转到内存中该地址空间中的任何偏移量。

885
00:22:35,930 --> 00:22:37,310
0,225 225,530 910,1155 1155,1260 1260,1380
map file. So this is

886
00:22:37,310 --> 00:22:38,960
0,90 90,195 195,450 450,830 1330,1650
in the POS. Standard Windows

887
00:22:38,960 --> 00:22:39,785
0,195 195,315 315,450 450,660 660,825
has their own version of

888
00:22:39,785 --> 00:22:41,225
0,245 505,765 765,960 960,1245 1245,1440
it, but this allows you

889
00:22:41,225 --> 00:22:42,680
0,105 105,365 505,900 900,1365 1365,1455
to take the contents of

890
00:22:42,680 --> 00:22:43,840
0,105 105,285 285,480 480,600 600,1160
a file that's on disk

891
00:22:44,070 --> 00:22:45,335
0,320 320,590 590,860 860,1040 1040,1265
and you map it into

892
00:22:45,335 --> 00:22:47,710
0,315 315,665 1705,1965 1965,2100 2100,2375
virtual memory in your process,

893
00:22:47,940 --> 00:22:48,950
0,245 245,365 365,635 635,890 890,1010
in the address of your

894
00:22:48,950 --> 00:22:50,780
0,260 910,1185 1185,1350 1350,1590 1590,1830
process. And then now that

895
00:22:50,780 --> 00:22:52,630
0,290 310,710 1150,1440 1440,1590 1590,1850
process can jump to any

896
00:22:52,920 --> 00:22:54,670
0,305 305,500 500,790 1110,1430 1430,1750
offset in that address space

897
00:22:54,870 --> 00:22:56,100
0,260 260,520
in memory.|
|

898
00:22:56,100 --> 00:22:57,470
0,285 285,585 585,810 810,1035 1035,1370
And the OS is responsible
操作系统负责决定，哦，你需要的东西是否在内存中？如果不是，那么它会获取您需要的页面，并将其放入内存。

899
00:22:57,490 --> 00:22:58,740
0,245 245,575 575,890 890,1115 1115,1250
for deciding, oh, is the

900
00:22:58,740 --> 00:22:59,505
0,135 135,270 270,435 435,600 600,765
thing you need in memory

901
00:22:59,505 --> 00:23:00,825
0,165 165,425 655,960 960,1170 1170,1320
or not? If not, then

902
00:23:00,825 --> 00:23:01,700
0,105 105,240 240,345 345,615 615,875
it goes and fetches the

903
00:23:01,810 --> 00:23:02,730
0,305 305,455 455,620 620,800 800,920
page you need and brings

904
00:23:02,730 --> 00:23:03,840
0,105 105,195 195,440
it in memory.|
|

905
00:23:04,350 --> 00:23:05,460
0,400
Right.|
正确的。|

906
00:23:05,530 --> 00:23:06,600
0,245 245,350 350,575 575,845 845,1070
So the database system doesn
所以数据库系统没有做任何事情的原因。它只是一张地图，打开文件，操作系统完成所有数据的管理，将数据来回移动。

907
00:23:06,600 --> 00:23:07,425
0,180 180,330 330,495 495,645 645,825
is not doing any of

908
00:23:07,425 --> 00:23:08,970
0,180 180,455 775,1020 1020,1265 1285,1545
the reason. It just m

909
00:23:08,970 --> 00:23:10,545
0,150 150,390 390,585 585,830 1300,1575
map opens the file and

910
00:23:10,545 --> 00:23:11,910
0,195 195,405 405,585 585,875 1105,1365
the OS does all the

911
00:23:11,910 --> 00:23:13,095
0,225 225,450 450,570 570,830 880,1185
management of the data, moving

912
00:23:13,095 --> 00:23:13,740
0,135 135,255 255,405 405,510 510,645
the data back and forth

913
00:23:13,740 --> 00:23:14,800
0,150 150,410
forth us.|
|

914
00:23:15,460 --> 00:23:16,020
0,230 230,305 305,380 380,455 455,560
So it sort of look
所以它看起来有点像这样。我们有一个磁盘上的文件。我们有一大堆页面。

915
00:23:16,020 --> 00:23:16,605
0,135 135,300 300,435 435,510 510,585
like this. We have an

916
00:23:16,605 --> 00:23:17,385
0,135 135,375 375,570 570,735 735,780
on disk file. We have

917
00:23:17,385 --> 00:23:19,700
0,30 30,105 105,210 210,455
a bunch of pages.|
|

918
00:23:19,700 --> 00:23:20,570
0,90 90,240 240,420 420,645 645,870
We call m map to
我们调用m map来打开它，然后我们就有了虚拟内存和物理内存的概念。因此，虚拟内存将是我在进程地址空间中看到的。同样，在某个起始位置，我会得到，我会得到地图文件。

919
00:23:20,570 --> 00:23:21,815
0,135 135,225 225,470 850,1110 1110,1245
open it up and then

920
00:23:21,815 --> 00:23:22,535
0,165 165,240 240,360 360,540 540,720
we'll have a concept of

921
00:23:22,535 --> 00:23:24,335
0,195 195,495 495,875 925,1325 1465,1800
virtual memory and and physical

922
00:23:24,335 --> 00:23:25,745
0,335 475,750 750,975 975,1245 1245,1410
memory. So virtual memory would

923
00:23:25,745 --> 00:23:26,600
0,150 150,315 315,465 465,675 675,855
be what I see in

924
00:23:26,600 --> 00:23:29,170
0,150 150,435 435,735 735,1040 2170,2570
my process address space. Again,

925
00:23:29,340 --> 00:23:30,575
0,290 290,470 470,710 710,995 995,1235
at some starting location, I'll

926
00:23:30,575 --> 00:23:31,895
0,150 150,455 835,1140 1140,1215 1215,1320
get the, I'll get the

927
00:23:31,895 --> 00:23:33,200
0,270 270,575
map file.|
|

928
00:23:33,460 --> 00:23:34,725
0,260 260,520 570,845 845,1040 1040,1265
And then these virtual memory
然后，这些虚拟内存必须由物理页面支持。因此，当我触摸页面时，操作系统必须离开，然后将其放入物理内存中的某个空间，然后更新虚拟内存表的连接。

929
00:23:34,725 --> 00:23:35,310
0,135 135,195 195,285 285,480 480,585
has to be backed by

930
00:23:35,310 --> 00:23:36,405
0,210 210,555 555,810 810,930 930,1095
physical pages. So as I

931
00:23:36,405 --> 00:23:38,010
0,180 180,345 345,635 1195,1455 1455,1605
touch a page, the OS

932
00:23:38,010 --> 00:23:38,925
0,165 165,300 300,495 495,750 750,915
has to go, then put

933
00:23:38,925 --> 00:23:40,080
0,60 60,275 385,765 765,1020 1020,1155
it into some space in

934
00:23:40,080 --> 00:23:41,475
0,180 180,500 760,1005 1005,1185 1185,1395
physical memory, and then update

935
00:23:41,475 --> 00:23:42,645
0,135 135,660 660,915 915,1020 1020,1170
the wiring for the virtual

936
00:23:42,645 --> 00:23:44,000
0,225 225,545
memory table.|
|

937
00:23:44,040 --> 00:23:46,270
0,400 960,1480 1500,1775 1775,1940 1940,2230
Right, so that my process
对，所以我的进程想要接触第一页，这样我们就会出现页面错误，因为操作系统会识别出我的物理内存中没有第一页。

938
00:23:46,590 --> 00:23:47,620
0,260 260,380 380,530 530,725 725,1030
wants to touch page one

939
00:23:48,120 --> 00:23:49,160
0,350 350,560 560,665 665,830 830,1040
so we would have a

940
00:23:49,160 --> 00:23:50,825
0,210 210,510 510,890 1150,1470 1470,1665
page fault because the OS

941
00:23:50,825 --> 00:23:51,875
0,135 135,395 445,750 750,945 945,1050
would recognize I don't have

942
00:23:51,875 --> 00:23:52,900
0,195 195,390 390,510 510,690 690,1025
page one in physical memory.|
|

943
00:23:53,640 --> 00:23:54,405
0,210 210,270 270,375 375,510 510,765
It'll go out the disk,
它会取出磁盘，为我取出，放入，更新虚拟内存到现在，指向它，然后我的进程可以触摸它或对它做任何想做的事情。

944
00:23:54,405 --> 00:23:55,155
0,165 165,315 315,435 435,600 600,750
fetch it for me, put

945
00:23:55,155 --> 00:23:56,775
0,105 105,365 865,1155 1155,1365 1365,1620
it in, update virtual memory

946
00:23:56,775 --> 00:23:57,540
0,195 195,360 360,555 555,675 675,765
to now, point to it,

947
00:23:57,540 --> 00:23:59,150
0,90 90,195 195,470 850,1230 1230,1610
and then my process can

948
00:23:59,260 --> 00:24:00,210
0,260 260,440 440,635 635,800 800,950
touch it or do whatever

949
00:24:00,210 --> 00:24:01,580
0,150 150,285 285,530
wants with it.|
|

950
00:24:01,650 --> 00:24:02,555
0,290 290,485 485,635 635,710 710,905
Same thing. Now if I
一样的东西。现在，如果我想要第三页，它不在那里。我收到了一个页面错误。操作系统会阻止我的进程。当我这样做时，当我访问它时，它会从磁盘更新、连接和然后我的进程可以再次开始运行来获取我需要的页面。我的线程可以重新开始运行。

951
00:24:02,555 --> 00:24:03,995
0,240 240,450 450,785 1015,1320 1320,1440
want page three, it's not

952
00:24:03,995 --> 00:24:04,595
0,135 135,270 270,405 405,495 495,600
in there. I get a

953
00:24:04,595 --> 00:24:05,825
0,195 195,515 565,825 825,1005 1005,1230
page fault. The OS blocks

954
00:24:05,825 --> 00:24:07,595
0,195 195,485 1225,1470 1470,1575 1575,1770
my process. When I do,

955
00:24:07,595 --> 00:24:09,035
0,195 195,420 420,645 645,905 1195,1440
when I access it, it

956
00:24:09,035 --> 00:24:09,725
0,135 135,330 330,450 450,555 555,690
goes fetch to the page

957
00:24:09,725 --> 00:24:11,285
0,120 120,225 225,345 345,845 1285,1560
I need from disk updates,

958
00:24:11,285 --> 00:24:13,060
0,135 135,540 540,845 1225,1500 1500,1775
the wiring and and then

959
00:24:13,410 --> 00:24:14,990
0,260 260,470 470,820 960,1340 1340,1580
then my process can start

960
00:24:14,990 --> 00:24:15,830
0,195 195,405 405,555 555,705 705,840
running again. My thread can

961
00:24:15,830 --> 00:24:16,980
0,120 120,300 300,620
start running again.|
|

962
00:24:17,660 --> 00:24:18,955
0,260 260,520 870,1115 1115,1220 1220,1295
What happens if I want
如果我想触摸第二页怎么办？

963
00:24:18,955 --> 00:24:20,380
0,60 60,210 210,435 435,755
to touch page two?|
|

964
00:24:22,550 --> 00:24:23,820
0,290 290,520
What's that?|
那是什么？|

965
00:24:24,060 --> 00:24:24,695
0,260 260,365 365,470 470,560 560,635
Is to get rid of
就是摆脱它。但是当我处理掉它的时候会发生什么呢？

966
00:24:24,695 --> 00:24:26,195
0,245 685,945 945,1050 1050,1230 1230,1500
it. But what happens while

967
00:24:26,195 --> 00:24:27,040
0,255 255,375 375,525 525,615 615,845
I'm getting rid of it?|
|

968
00:24:28,710 --> 00:24:30,650
0,275 275,545 545,1055 1055,1390 1680,1940
My process stalls, right, I
我的进程停止了，对，我去操作系统会阻止我，而它会说，好的，我没有更多的物理内存，让我出去找出应该分页第一页还是第三页，我应该扔掉哪一个？

969
00:24:30,650 --> 00:24:31,415
0,105 105,285 285,465 465,615 615,765
go to the OS is

970
00:24:31,415 --> 00:24:32,900
0,75 75,180 180,375 375,695 1105,1485
going to block me while

971
00:24:32,900 --> 00:24:34,010
0,255 255,510 510,780 780,960 960,1110
it says, okay, well I

972
00:24:34,010 --> 00:24:34,685
0,180 180,255 255,360 360,480 480,675
don't have any more physical

973
00:24:34,685 --> 00:24:35,885
0,335 565,810 810,915 915,1050 1050,1200
memory, let me go out

974
00:24:35,885 --> 00:24:36,700
0,120 120,240 240,405 405,555 555,815
and figure out what to

975
00:24:37,260 --> 00:24:38,180
0,320 320,500 500,635 635,785 785,920
page one or three, which

976
00:24:38,180 --> 00:24:39,100
0,180 180,345 345,465 465,630 630,920
one should I throw away?|
|

977
00:24:40,090 --> 00:24:42,255
0,400 1260,1520 1520,1730 1730,1985 1985,2165
Right, but the OS is
是的，但操作系统会有自己的内部统计数据，关于这些页面是如何被访问的，它将决定驱逐哪个页面。

978
00:24:42,255 --> 00:24:43,035
0,105 105,195 195,315 315,480 480,780
going to have its own

979
00:24:43,035 --> 00:24:45,735
0,390 390,785 925,1325 2245,2535 2535,2700
internal statistics about how these

980
00:24:45,735 --> 00:24:47,450
0,180 180,330 330,555 555,1115 1315,1715
pages are being accessed, and

981
00:24:47,470 --> 00:24:48,285
0,410 410,485 485,560 560,650 650,815
it's going to make a

982
00:24:48,285 --> 00:24:49,965
0,305 805,1140 1140,1380 1380,1575 1575,1680
decision about what page to

983
00:24:49,965 --> 00:24:50,880
0,335
evict.|
|

984
00:24:51,430 --> 00:24:52,530
0,260 260,365 365,620 620,845 845,1100
But it doesn't know anything
但它不知道我们在数据库系统中做了什么，因为它只播种读、写，它没有课程屏幕，不知道什么是查询，不知道这些数据页面中有什么，这些文件中有什么。因此，操作系统将尝试就如何将东西换出做出决定。

985
00:24:52,530 --> 00:24:53,445
0,195 195,360 360,555 555,720 720,915
about what we're doing inside

986
00:24:53,445 --> 00:24:54,540
0,120 120,330 330,695 745,990 990,1095
the database system because it

987
00:24:54,540 --> 00:24:55,755
0,180 180,540 540,795 795,1035 1035,1215
just seeds reads, writes, it

988
00:24:55,755 --> 00:24:58,005
0,335 1165,1425 1425,1575 1575,1865 1915,2250
doesn't a course screen, doesn't

989
00:24:58,005 --> 00:24:59,220
0,105 105,240 240,540 540,815 925,1215
know what queries are, doesn't

990
00:24:59,220 --> 00:24:59,880
0,75 75,225 225,285 285,420 420,660
know what's in these data

991
00:24:59,880 --> 00:25:02,150
0,350 1480,1785 1785,1845 1845,1980 1980,2270
pages, what's in these files.

992
00:25:02,770 --> 00:25:03,645
0,245 245,410 410,620 620,770 770,875
So the OS is going

993
00:25:03,645 --> 00:25:04,170
0,105 105,225 225,315 315,390 390,525
to try to make a

994
00:25:04,170 --> 00:25:05,010
0,180 180,315 315,420 420,600 600,840
decision on how to swap

995
00:25:05,010 --> 00:25:06,020
0,165 165,440
things out.|
|

996
00:25:06,850 --> 00:25:08,265
0,260 260,515 515,760 870,1115 1115,1415
And that's just for eviction.
这只是为了驱逐。如果我们依赖操作系统来为我们做这件事，我们将面临一大堆其他问题。

997
00:25:08,265 --> 00:25:08,895
0,240 240,300 300,405 405,525 525,630
There's a whole bunch of

998
00:25:08,895 --> 00:25:10,695
0,195 195,545 1225,1545 1545,1770 1770,1800
other problems that we're going

999
00:25:10,695 --> 00:25:11,670
0,75 75,300 300,555 555,750 750,975
to face if we rely

1000
00:25:11,670 --> 00:25:12,345
0,180 180,315 315,465 465,585 585,675
on the OS to do

1001
00:25:12,345 --> 00:25:13,500
0,120 120,270 270,545
this for us.|
|

1002
00:25:15,170 --> 00:25:16,660
0,400 660,920 920,1070 1070,1280 1280,1490
So in my first example
因此，在我的第一个示例中，我共享了一个线程或一个进程来访问它。

1003
00:25:16,660 --> 00:25:17,850
0,225 225,450 450,630 630,855 855,1190
here, I shared one thread

1004
00:25:18,050 --> 00:25:19,825
0,275 275,550 780,1145 1145,1445 1445,1775
or one process with accessing

1005
00:25:19,825 --> 00:25:20,560
0,245
it.|
|

1006
00:25:20,560 --> 00:25:21,310
0,240 240,420 420,630 630,675 675,750
But again, we're going to
但同样，我们将尝试建立一个数据库，一个可以利用多核或多CPU的监控系统。因此，我们需要让多个线程访问它们。

1007
00:25:21,310 --> 00:25:21,940
0,105 105,195 195,300 300,405 405,630
try to build a database,

1008
00:25:21,940 --> 00:25:23,260
0,225 225,470 700,1020 1020,1200 1200,1320
a monitoring system that can

1009
00:25:23,260 --> 00:25:25,120
0,165 165,390 390,710 1090,1455 1455,1860
take advantage of multiple cores

1010
00:25:25,120 --> 00:25:27,295
0,120 120,315 315,860 1720,2010 2010,2175
or multiple cpus. And so

1011
00:25:27,295 --> 00:25:27,865
0,135 135,210 210,270 270,375 375,570
we need to have multiple

1012
00:25:27,865 --> 00:25:29,260
0,345 345,540 540,815
threads access them.|
|

1013
00:25:29,440 --> 00:25:30,300
0,260 260,425 425,575 575,710 710,860
But now, what if one
但现在，如果他们中的一个呢？

1014
00:25:30,300 --> 00:25:32,280
0,120 120,380
of them?|
|

1015
00:25:32,280 --> 00:25:32,870
0,75 75,150 150,270 270,360 360,590
You know, one of them
你知道，其中一个人触摸了一些东西，写下了它，然后另一个人试图阅读它，但它被搁置了，因为它被驱逐了。订单可能会变得有点古怪。同样，操作系统不知道正在发生的任何事情，也不知道同时在系统内运行的是什么。

1016
00:25:33,460 --> 00:25:34,635
0,380 380,590 590,845 845,1040 1040,1175
touches something, writes it, and

1017
00:25:34,635 --> 00:25:35,535
0,210 210,465 465,630 630,765 765,900
then another guy tries to

1018
00:25:35,535 --> 00:25:36,150
0,135 135,255 255,360 360,450 450,615
read it, but it gets

1019
00:25:36,150 --> 00:25:37,640
0,360 360,450 450,680 880,1140 1140,1490
stalled because it gets evicted.

1020
00:25:38,350 --> 00:25:39,570
0,260 260,605 605,755 755,995 995,1220
The ordering can get kind

1021
00:25:39,570 --> 00:25:40,740
0,165 165,570 570,795 795,975 975,1170
of screwy. And again, the

1022
00:25:40,740 --> 00:25:42,200
0,180 180,345 345,645 645,920 1060,1460
operating system doesn't know anything

1023
00:25:42,370 --> 00:25:43,665
0,335 335,470 470,760 780,1115 1115,1295
that's going on, what's running

1024
00:25:43,665 --> 00:25:44,385
0,195 195,315 315,480 480,630 630,720
inside the system at the

1025
00:25:44,385 --> 00:25:45,440
0,150 150,455
same time.|
|

1026
00:25:46,130 --> 00:25:47,190
0,365 365,560 560,650 650,785 785,1060
So everything is read, only
所以一切都是可读的，只是没问题。

1027
00:25:47,455 --> 00:25:48,620
0,135 135,455
it's OK.|
|

1028
00:25:48,880 --> 00:25:49,800
0,245 245,365 365,455 455,665 665,920
Because we're not dirty any
因为我们没有弄脏任何页面，所以操作系统可以把东西换出来。这已经足够好了。而且也有一些案例。有一些数据系统确实只将m map用于系统的只读部分。

1029
00:25:49,800 --> 00:25:51,150
0,320 550,825 825,990 990,1155 1155,1350
pages, the OS can swap

1030
00:25:51,150 --> 00:25:52,920
0,165 165,440 1210,1515 1515,1605 1605,1770
things out. It'll be good

1031
00:25:52,920 --> 00:25:54,030
0,290 490,735 735,810 810,915 915,1110
enough. And there are some

1032
00:25:54,030 --> 00:25:54,855
0,270 270,450 450,525 525,645 645,825
cases. There are some data

1033
00:25:54,855 --> 00:25:56,565
0,240 240,480 480,705 705,1025 1405,1710
systems that do use m

1034
00:25:56,565 --> 00:25:58,425
0,305 685,975 975,1265 1375,1650 1650,1860
map just for read only

1035
00:25:58,425 --> 00:25:59,880
0,225 225,360 360,480 480,755
parts of the system.|
|

1036
00:26:00,740 --> 00:26:01,510
0,245 245,350 350,455 455,605 605,770
But if you now need
但如果您现在需要多个编写器，同样，在真实系统中，我们将需要这样的编写器。

1037
00:26:01,510 --> 00:26:03,565
0,105 105,255 255,510 510,860 1720,2055
to have multiple writers, which

1038
00:26:03,565 --> 00:26:04,420
0,225 225,375 375,480 480,645 645,855
again, in a real system,

1039
00:26:04,420 --> 00:26:05,130
0,165 165,210 210,285 285,420 420,710
we're going to want this.|
|

1040
00:26:06,430 --> 00:26:06,990
0,230 230,290 290,365 365,470 470,560
Then there's a bunch of
然后还有一堆其他的问题。

1041
00:26:06,990 --> 00:26:08,260
0,120 120,410
other problems.|
|

1042
00:26:09,120 --> 00:26:10,085
0,260 260,380 380,545 545,740 740,965
So the first one is
因此，第一个问题是交易安全。如果我有一个更新多个页面的事务，这就是我提到的问题。

1043
00:26:10,085 --> 00:26:11,165
0,335 385,720 720,915 915,1005 1005,1080
transaction safety. This is the

1044
00:26:11,165 --> 00:26:12,130
0,240 240,525 525,645 645,720 720,965
one I sort of mentioned

1045
00:26:13,050 --> 00:26:14,920
0,395 395,695 695,860 860,1120 1470,1870
if I have a transaction

1046
00:26:14,940 --> 00:26:17,080
0,335 335,575 575,845 845,1210
that updates multiple pages.|
|

1047
00:26:17,080 --> 00:26:18,295
0,195 195,375 375,585 585,900 900,1215
ID to make sure that
ID以确保这些页面实际上是以正确的顺序写出的，并且操作系统不知道这一点，因为这会看到它不知道的脏页面。

1048
00:26:18,295 --> 00:26:19,390
0,270 270,495 495,720 720,915 915,1095
these pages are actually written

1049
00:26:19,390 --> 00:26:20,250
0,195 195,345 345,450 450,585 585,860
out in the right order

1050
00:26:20,630 --> 00:26:21,730
0,260 260,455 455,650 650,890 890,1100
and the OS doesn't know

1051
00:26:21,730 --> 00:26:23,185
0,240 240,435 435,710 970,1260 1260,1455
that because this sees dirty

1052
00:26:23,185 --> 00:26:24,700
0,305 595,840 840,1050 1050,1260 1260,1515
pages it doesn't know anything

1053
00:26:24,700 --> 00:26:25,740
0,290
about.|
|

1054
00:26:25,750 --> 00:26:26,670
0,260 260,440 440,680 680,845 845,920
Does this page need to
这一页需要写在另一页之前吗？

1055
00:26:26,670 --> 00:26:27,405
0,105 105,270 270,450 450,585 585,735
be written before this other

1056
00:26:27,405 --> 00:26:28,440
0,305
page?|
|

1057
00:26:29,710 --> 00:26:30,660
0,260 260,395 395,575 575,755 755,950
You can do some things
你可以做一些事情，比如你可以使用mlock锁定页面，但这只会阻止操作系统将其换出，而不会阻止它写出。因此，现在它可能会写出一个它不应该写出的肮脏页面。我崩溃了，然后又回来了，现在我有了一些不应该写在桌子上的更改。

1058
00:26:30,660 --> 00:26:31,515
0,195 195,330 330,465 465,660 660,855
like you can lock the

1059
00:26:31,515 --> 00:26:33,285
0,195 195,420 420,905 1375,1620 1620,1770
page using mlock, but that

1060
00:26:33,285 --> 00:26:34,320
0,225 225,495 495,675 675,840 840,1035
only prevents the OS from

1061
00:26:34,320 --> 00:26:35,715
0,375 375,465 465,710 910,1245 1245,1395
swapping it out, doesn't prevent

1062
00:26:35,715 --> 00:26:37,155
0,150 150,285 285,510 510,845 1195,1440
it from writing out. So

1063
00:26:37,155 --> 00:26:37,905
0,150 150,300 300,435 435,600 600,750
now it may write out

1064
00:26:37,905 --> 00:26:38,745
0,120 120,300 300,570 570,735 735,840
a dirty page that it

1065
00:26:38,745 --> 00:26:40,020
0,210 210,455 565,900 900,1125 1125,1275
shouldn't have. I crash and

1066
00:26:40,020 --> 00:26:40,860
0,135 135,360 360,570 570,705 705,840
come back, and now I

1067
00:26:40,860 --> 00:26:42,225
0,165 165,470 670,1005 1005,1260 1260,1365
have changes that shouldn't have

1068
00:26:42,225 --> 00:26:43,600
0,150 150,300 300,435 435,695
been written a desk.|
|

1069
00:26:43,640 --> 00:26:44,320
0,260 260,365 365,455 455,545 545,680
And I had to go
我不得不想办法扭转这一局面，或者处理坏数据、不一致的数据。

1070
00:26:44,320 --> 00:26:45,460
0,150 150,410 520,780 780,945 945,1140
figure out how to reverse

1071
00:26:45,460 --> 00:26:47,670
0,290 790,1080 1080,1370 1390,1790 1810,2210
that or deal with the

1072
00:26:49,130 --> 00:26:51,320
0,305 305,605 605,1250 1250,1510
bad data, inconsistent data.|
|

1073
00:26:52,180 --> 00:26:53,115
0,320 320,440 440,605 605,740 740,935
We've already talked about doing
我们已经谈过做摊位的事了。同样，如果您尝试访问不在内存中的内容，则会出现严重的页面错误。它阻塞你的线程，他调度你，磁盘调度器去获取你的页面，把它带进来，当它可用时，你重新调度你的线程，再次重新调度。

1074
00:26:53,115 --> 00:26:55,470
0,605 1705,1980 1980,2115 2115,2235 2235,2355
stalls. Again, if you try

1075
00:26:55,470 --> 00:26:56,355
0,180 180,360 360,525 525,795 795,885
to access something that's not

1076
00:26:56,355 --> 00:26:57,045
0,90 90,300 300,510 510,600 600,690
in memory, you get a

1077
00:26:57,045 --> 00:26:58,290
0,210 210,480 480,750 750,1020 1020,1245
major page fault. It blocks

1078
00:26:58,290 --> 00:26:59,480
0,210 210,420 420,615 615,915 915,1190
your thread, he schedules you,

1079
00:26:59,980 --> 00:27:01,890
0,400 480,845 845,1240 1410,1730 1730,1910
the disk scheduler goes get

1080
00:27:01,890 --> 00:27:02,715
0,135 135,330 330,540 540,675 675,825
your page brings it in,

1081
00:27:02,715 --> 00:27:03,525
0,165 165,255 255,405 405,615 615,810
and when it's available, then

1082
00:27:03,525 --> 00:27:04,425
0,90 90,195 195,540 540,750 750,900
you get resched your thread

1083
00:27:04,425 --> 00:27:05,800
0,150 150,600 600,875
gets rescheduled again.|
|

1084
00:27:05,970 --> 00:27:06,755
0,245 245,365 365,515 515,635 635,785
But now your thread is
但现在您的线程被阻塞，无法执行任何操作。

1085
00:27:06,755 --> 00:27:08,500
0,225 225,405 405,600 600,935
blocked in doing nothing.|
|

1086
00:27:09,010 --> 00:27:10,725
0,400 780,1040 1040,1145 1145,1390 1500,1715
Right. And it maybe there
正确的。在等待那个东西获取的过程中，可能还可以运行其他查询。从磁盘获取数据。

1087
00:27:10,725 --> 00:27:11,400
0,45 45,195 195,495 495,585 585,675
are other queries you could

1088
00:27:11,400 --> 00:27:14,025
0,225 225,590 2020,2325 2325,2520 2520,2625
possibly run while you're waiting

1089
00:27:14,025 --> 00:27:14,700
0,120 120,225 225,360 360,480 480,675
for that thing to fetch.

1090
00:27:14,700 --> 00:27:16,220
0,180 180,345 345,480 480,950
Get fetch from disk.|
|

1091
00:27:16,440 --> 00:27:17,255
0,245 245,335 335,440 440,605 605,815
So then you say, okay,
然后你会说，好的，也许我会做一个调度器或者调度器，这样只有一个线程去处理和获取东西，并且有一个页面错误。他被阻挡了，然后我就可以再运行一次线程。

1092
00:27:17,255 --> 00:27:18,550
0,135 135,285 285,495 495,725 895,1295
well, maybe I'll make a

1093
00:27:18,690 --> 00:27:19,940
0,620 620,665 665,755 755,1115 1115,1250
dispatcher or a scheduler so

1094
00:27:19,940 --> 00:27:21,050
0,180 180,450 450,600 600,870 870,1110
that there's only one thread

1095
00:27:21,050 --> 00:27:21,770
0,135 135,255 255,360 360,495 495,720
that goes and gets things

1096
00:27:21,770 --> 00:27:22,580
0,180 180,330 330,420 420,585 585,810
and there's a page fault.

1097
00:27:22,580 --> 00:27:23,360
0,180 180,345 345,570 570,720 720,780
He gets blocked and then

1098
00:27:23,360 --> 00:27:24,305
0,75 75,180 180,300 300,560 700,945
I can run another run

1099
00:27:24,305 --> 00:27:25,620
0,75 75,150 150,255 255,725
out of the threads.|
|

1100
00:27:25,720 --> 00:27:26,570
0,245 245,365 365,515 515,620 620,850
But now you kind of,
但现在，你正在围绕地图的局限性建立更多的基础设施。

1101
00:27:26,620 --> 00:27:28,095
0,320 320,515 515,815 815,1130 1130,1475
you're building more infrastructure around

1102
00:27:28,095 --> 00:27:30,920
0,240 240,725 925,1325 1525,2075
the limitations of map.|
|

1103
00:27:32,030 --> 00:27:32,875
0,305 305,470 470,590 590,710 710,845
Next problem you have is
您遇到的下一个问题是如何处理错误？

1104
00:27:32,875 --> 00:27:33,780
0,120 120,195 195,255 255,405 405,905
how do you handle errors?|
|

1105
00:27:36,300 --> 00:27:38,735
0,365 365,730 1530,1820 1820,2110 2130,2435
Right. If I'm map, if
正确的。如果我被映射了，如果我试图访问一个页面，不管是什么原因，它被损坏或不可用，那么就会出现一些硬件问题。

1106
00:27:38,735 --> 00:27:40,040
0,305 355,615 615,825 825,1095 1095,1305
I try to access a

1107
00:27:40,040 --> 00:27:42,515
0,290 850,1250 1870,2160 2160,2310 2310,2475
page that for whatever reason

1108
00:27:42,515 --> 00:27:43,720
0,210 210,585 585,690 690,870 870,1205
it's corrupted or not available,

1109
00:27:43,950 --> 00:27:46,000
0,440 440,725 725,965 965,1300
there's some hardware problem.|
|

1110
00:27:46,210 --> 00:27:47,160
0,245 245,395 395,470 470,650 650,950
You don't get an exception
您不会像在用户空间代码中编写的那样得到异常，您会得到一个符号和中断。

1111
00:27:47,160 --> 00:27:48,435
0,210 210,345 345,570 570,920 1030,1275
as you would if you

1112
00:27:48,435 --> 00:27:49,155
0,105 105,195 195,285 285,480 480,720
write it in user space

1113
00:27:49,155 --> 00:27:50,760
0,305 775,1035 1035,1140 1140,1260 1260,1605
code, you get a sigus

1114
00:27:50,760 --> 00:27:52,120
0,270 270,650
and interrupt.|
|

1115
00:27:52,420 --> 00:27:53,235
0,275 275,395 395,485 485,605 605,815
Now you need a signal
现在，您需要一个贯穿整个系统其余部分的信号处理程序，因为您可能正在执行一些您不希望被中断或中断的临界区中的操作。因此，您必须有一个中断处理程序，以确保您可以返回到之前正在做的事情。

1116
00:27:53,235 --> 00:27:54,540
0,525 525,855 855,1095 1095,1215 1215,1305
handler all throughout the rest

1117
00:27:54,540 --> 00:27:55,725
0,90 90,195 195,470 820,1065 1065,1185
of your system because you

1118
00:27:55,725 --> 00:27:56,990
0,165 165,315 315,510 510,845 865,1265
may be doing something that

1119
00:27:57,310 --> 00:27:58,580
0,320 320,500 500,635 635,890 890,1270
is in a critical section

1120
00:27:58,960 --> 00:27:59,820
0,305 305,485 485,710 710,785 785,860
that you don't want to

1121
00:27:59,820 --> 00:28:01,995
0,230 340,765 765,1010 1570,1920 1920,2175
get interrupted or break. So

1122
00:28:01,995 --> 00:28:02,415
0,135 135,195 195,270 270,345 345,420
therefore you have to have

1123
00:28:02,415 --> 00:28:03,870
0,195 195,420 420,875 1075,1320 1320,1455
an interrupt handler to make

1124
00:28:03,870 --> 00:28:04,815
0,150 150,345 345,570 570,750 750,945
sure you can go back

1125
00:28:04,815 --> 00:28:05,355
0,150 150,255 255,375 375,465 465,540
to the thing you were

1126
00:28:05,355 --> 00:28:06,580
0,105 105,365
doing before.|
|

1127
00:28:06,580 --> 00:28:07,900
0,320
Ah.|
阿。|

1128
00:28:07,900 --> 00:28:10,360
0,210 210,560 580,980 1090,1490 2200,2460
To handle this interrupt because
为了处理这个中断，因为这是唯一的中断，这是操作系统告诉您的。事情正在变得糟糕。您不能返回错误代码，您可以返回并中断。

1129
00:28:10,360 --> 00:28:13,000
0,260 280,540 540,645 645,890 2380,2640
this is the only, this

1130
00:28:13,000 --> 00:28:14,310
0,150 150,360 360,630 630,945 945,1310
is how the operating system

1131
00:28:14,450 --> 00:28:15,520
0,335 335,575 575,770 770,905 905,1070
tells you. Things are going

1132
00:28:15,520 --> 00:28:17,050
0,320 910,1170 1170,1350 1350,1425 1425,1530
bad. You can't get back

1133
00:28:17,050 --> 00:28:17,890
0,120 120,285 285,525 525,720 720,840
in error code, you get

1134
00:28:17,890 --> 00:28:20,100
0,255 255,630 630,1010
back and interrupt.|
|

1135
00:28:22,240 --> 00:28:22,920
0,245 245,365 365,530 530,590 590,680
To say that's a lot
要说这需要大量的工程技术来处理，你不会想要这样做的。然后，显然会出现性能问题。这是因为操作系统将有自己的内部数据结构，关于内存中的内容而不是内存中的内容，正在调度的内容或未调度的内容。它还必须保护自己数据结构中的那些关键部分。

1136
00:28:22,920 --> 00:28:24,500
0,195 195,530 640,1020 1020,1290 1290,1580
of engineering to handle this,

1137
00:28:24,520 --> 00:28:25,140
0,245 245,410 410,470 470,530 530,620
you don't want to do

1138
00:28:25,140 --> 00:28:27,285
0,260 730,990 990,1250 1570,1965 1965,2145
this. And then there's obviously

1139
00:28:27,285 --> 00:28:28,100
0,105 105,150 150,270 270,495 495,815
going to be performance issues.

1140
00:28:29,410 --> 00:28:31,245
0,260 260,395 395,590 590,910 1500,1835
And this is because the

1141
00:28:31,245 --> 00:28:31,905
0,225 225,390 390,510 510,585 585,660
operating system is going to

1142
00:28:31,905 --> 00:28:32,895
0,90 90,225 225,495 495,780 780,990
have its own internal data

1143
00:28:32,895 --> 00:28:33,900
0,270 270,525 525,750 750,840 840,1005
structures about what's in memory

1144
00:28:33,900 --> 00:28:35,790
0,150 150,300 300,590 1420,1740 1740,1890
and not memory, what's getting

1145
00:28:35,790 --> 00:28:36,770
0,225 225,375 375,480 480,660 660,980
scheduled or not getting scheduled.

1146
00:28:37,090 --> 00:28:38,025
0,275 275,425 425,575 575,740 740,935
And it has to protect

1147
00:28:38,025 --> 00:28:39,420
0,255 255,555 555,905 955,1245 1245,1395
those critical sections inside its

1148
00:28:39,420 --> 00:28:40,820
0,150 150,360 360,680
own data structures.|
|

1149
00:28:40,920 --> 00:28:42,130
0,260 260,410 410,650 650,905 905,1210
With new taxes or whatever,
新的税收或其他什么，现在这将是一个争议点。

1150
00:28:43,560 --> 00:28:44,870
0,400 570,890 890,1205 1205,1265 1265,1310
and now that's going to

1151
00:28:44,870 --> 00:28:46,400
0,60 60,135 135,435 435,770
be a contention point.|
|

1152
00:28:46,500 --> 00:28:48,065
0,400 450,785 785,1025 1025,1280 1280,1565
Whereas in a database system,
而在数据库系统中，因为我们知道查询要做什么，因为SQL同样是声明性的，所以我们知道查询要做什么，因为我们有物理计划，我们知道数据试图访问什么，因此我们可以更好地决定如何安排事情。

1153
00:28:48,065 --> 00:28:49,115
0,195 195,345 345,570 570,795 795,1050
since we know what queries

1154
00:28:49,115 --> 00:28:49,955
0,120 120,255 255,375 375,585 585,840
are trying to do because

1155
00:28:49,955 --> 00:28:51,455
0,225 225,480 480,540 540,1145 1225,1500
again, sql is declarative, we

1156
00:28:51,455 --> 00:28:52,370
0,150 150,255 255,345 345,690 690,915
know what the queries want

1157
00:28:52,370 --> 00:28:52,985
0,120 120,285 285,435 435,525 525,615
to do because we have

1158
00:28:52,985 --> 00:28:54,275
0,90 90,300 300,665 925,1185 1185,1290
the physical plan, we know

1159
00:28:54,275 --> 00:28:55,115
0,150 150,375 375,585 585,735 735,840
what the data are trying

1160
00:28:55,115 --> 00:28:56,510
0,165 165,485 745,1065 1065,1260 1260,1395
to access and therefore we

1161
00:28:56,510 --> 00:28:57,275
0,165 165,375 375,420 420,510 510,765
can we're in a better

1162
00:28:57,275 --> 00:28:58,625
0,300 300,495 495,785 955,1215 1215,1350
decision to decide how to

1163
00:28:58,625 --> 00:28:59,820
0,195 195,515
schedule things.|
|

1164
00:29:00,420 --> 00:29:02,240
0,400
Yes.|
是。|

1165
00:29:06,170 --> 00:29:07,165
0,275 275,455 455,635 635,785 785,995
His question is the database
他的问题是，数据库系统有权直接与硬件一起工作。在可能的情况下，有一些称为内核绕过的方法。

1166
00:29:07,165 --> 00:29:08,185
0,255 255,435 435,585 585,825 825,1020
systems have the privilege to

1167
00:29:08,185 --> 00:29:09,595
0,90 90,180 180,375 375,725 1165,1410
work with hardware directly. There

1168
00:29:09,595 --> 00:29:11,070
0,150 150,420 420,720 720,1005 1005,1475
are methods called kernel bypass

1169
00:29:11,510 --> 00:29:14,080
0,380 380,725 725,1090
where you can.|
|

1170
00:29:14,080 --> 00:29:14,875
0,165 165,375 375,525 525,705 705,795
Or mv m is sort
或者mv m是这样的。有一些方法可以在不依赖操作系统的情况下调用硬件。

1171
00:29:14,875 --> 00:29:15,840
0,75 75,165 165,390 390,690 690,965
of like this. There's ways

1172
00:29:16,070 --> 00:29:17,220
0,245 245,410 410,695 695,905 905,1150
to make calls to hardware

1173
00:29:17,600 --> 00:29:18,835
0,350 350,575 575,850 870,1130 1130,1235
without having to rely on

1174
00:29:18,835 --> 00:29:20,100
0,135 135,425
the OS.|
|

1175
00:29:20,420 --> 00:29:21,530
0,285 285,495 495,675 675,885 885,1110
The problem with those things
这些东西的问题是，你基本上必须在数据库系统中实现一系列操作系统备份。这就是所谓的切线。如果你不想使用操作系统的tcp协议栈进行联网，有一种方法叫做。

1176
00:29:21,530 --> 00:29:22,990
0,285 285,585 585,890 910,1185 1185,1460
are you basically have to

1177
00:29:23,130 --> 00:29:23,915
0,305 305,455 455,560 560,650 650,785
implement a bunch of the

1178
00:29:23,915 --> 00:29:25,265
0,255 255,570 570,915 915,1200 1200,1350
OS back up inside the

1179
00:29:25,265 --> 00:29:27,770
0,195 195,545 1075,1475 1975,2310 2310,2505
database system. So there's something

1180
00:29:27,770 --> 00:29:29,830
0,350 1240,1485 1485,1560 1560,1665 1665,2060
called this is a tangent.

1181
00:29:30,120 --> 00:29:30,905
0,260 260,395 395,635 635,725 725,785
If you don't want to

1182
00:29:30,905 --> 00:29:32,165
0,75 75,195 195,455 565,900 900,1260
have to use the os'

1183
00:29:32,165 --> 00:29:34,385
0,450 450,755 985,1245 1245,1745 1915,2220
tcp stack for networking, there's

1184
00:29:34,385 --> 00:29:35,940
0,165 165,485
something called.|
|

1185
00:29:36,260 --> 00:29:39,460
0,400 420,820 1110,1510 2430,2960 2960,3200
Ah, the the DVD k
啊，英特尔的DVD k，数据播放数据包或开发包。基本上，这是一种直接连接到硬件中的方法，您可以获得原始数据包，但同样，它是原始数据包。如果它是一个TCP连接，那么现在您必须跟踪TCP头，对吗？很少有数据库系统能做到这一点。我只知道两个。

1186
00:29:39,460 --> 00:29:40,555
0,210 210,555 555,705 705,870 870,1095
from Intel, the data playing

1187
00:29:40,555 --> 00:29:41,790
0,225 225,480 480,675 675,885 885,1235
data kit or development kit.

1188
00:29:41,900 --> 00:29:42,940
0,395 395,695 695,770 770,905 905,1040
Basically, it's a way to

1189
00:29:42,940 --> 00:29:43,830
0,195 195,420 420,540 540,630 630,890
hook directly in the hardware

1190
00:29:44,000 --> 00:29:45,220
0,245 245,365 365,545 545,815 815,1220
and you get raw packets

1191
00:29:45,220 --> 00:29:46,570
0,260 520,780 780,915 915,1140 1140,1350
out, but again, it's raw

1192
00:29:46,570 --> 00:29:47,890
0,450 450,600 600,750 750,855 855,1320
packets. If it's a tcp

1193
00:29:47,890 --> 00:29:50,050
0,320 640,930 930,1080 1080,1340 1870,2160
connection, now you gotta keep

1194
00:29:50,050 --> 00:29:51,340
0,180 180,375 375,540 540,1005 1005,1290
track of the tcp headers

1195
00:29:51,340 --> 00:29:54,610
0,260 490,890 2500,2850 2850,3075 3075,3270
and right? Very few database

1196
00:29:54,610 --> 00:29:55,465
0,255 255,450 450,585 585,705 705,855
systems do this. I only

1197
00:29:55,465 --> 00:29:56,500
0,225 225,545
know two.|
|

1198
00:29:56,500 --> 00:29:58,390
0,225 225,560 580,980 1300,1620 1620,1890
One was, eh, one yellow
一个是，呃，一块黄砖。我们在整个教授中都在讨论这些问题。他们有很多令人惊叹的东西。他们基本上重写了自己的内容。他们基本上只使用操作系统来打开它，并且永远不会再调用Malloc。他们分配所有的内存，一切都开始了。他们编写了自己的TC PC i驱动程序。他们做了一堆令人惊叹的工程。很少有人会这么做。另一家是Scalia DB。但DBDK太难处理了，这是巨大的痛苦。他们不会这么做的。所以这个问题的答案是。

1199
00:29:58,390 --> 00:30:00,340
0,350 610,975 975,1215 1215,1490 1660,1950
brick. We discuss them throughout

1200
00:30:00,340 --> 00:30:00,940
0,135 135,300 300,465 465,525 525,600
the professor. They a bunch

1201
00:30:00,940 --> 00:30:02,280
0,225 225,540 540,765 765,990 990,1340
of amazing stuff. They basically

1202
00:30:02,540 --> 00:30:04,740
0,455 455,575 575,820 1590,1895 1895,2200
rewrite their own. They basically

1203
00:30:04,850 --> 00:30:05,950
0,320 320,515 515,665 665,860 860,1100
only use the OS to

1204
00:30:05,950 --> 00:30:07,015
0,180 180,300 300,420 420,680 820,1065
turn the thing on and

1205
00:30:07,015 --> 00:30:08,215
0,165 165,405 405,615 615,975 975,1200
they never call malloc again.

1206
00:30:08,215 --> 00:30:09,120
0,165 165,435 435,555 555,660 660,905
They allocate all the memory,

1207
00:30:09,410 --> 00:30:10,765
0,305 305,610 870,1130 1130,1250 1250,1355
everything beginning. They wrote their

1208
00:30:10,765 --> 00:30:12,300
0,135 135,575 595,975 975,1170 1170,1535
own tc PC I drivers.

1209
00:30:12,530 --> 00:30:13,230
0,245 245,320 320,365 365,440 440,700
They do a bunch of

1210
00:30:13,280 --> 00:30:15,040
0,400 480,880 1110,1400 1400,1595 1595,1760
amazing engineering. Few people do

1211
00:30:15,040 --> 00:30:16,270
0,260 550,780 780,885 885,1050 1050,1230
that. The other was was

1212
00:30:16,270 --> 00:30:18,505
0,300 300,740 850,1250 1540,1800 1800,2235
scalia DB. But the dbdk

1213
00:30:18,505 --> 00:30:19,420
0,165 165,405 405,615 615,720 720,915
was so difficult to handle

1214
00:30:19,420 --> 00:30:21,370
0,350 1030,1395 1395,1650 1650,1830 1830,1950
that was huge pain. They

1215
00:30:21,370 --> 00:30:22,990
0,150 150,225 225,470 550,950 1390,1620
don't do it. So the

1216
00:30:22,990 --> 00:30:23,730
0,105 105,210 210,285 285,435 435,740
answer to the question is.|
|

1217
00:30:25,560 --> 00:30:26,540
0,290 290,470 470,650 650,815 815,980
For some things, you have
对于某些事情，你必须通过操作系统。

1218
00:30:26,540 --> 00:30:27,310
0,135 135,240 240,360 360,495 495,770
to go through the OS.|
|

1219
00:30:30,460 --> 00:30:31,605
0,260 260,395 395,845 845,1025 1025,1145
In the eighties they got
在80年代，他们变得非常疯狂，他们不再使用文件系统，而是在原始数据块设备上编写自己的存储层。从工程学的角度来看，人们每年都会尝试这种方法。

1220
00:30:31,605 --> 00:30:33,320
0,210 210,545 595,870 870,1145 1315,1715
really crazy and like they,

1221
00:30:34,120 --> 00:30:34,875
0,230 230,305 305,425 425,560 560,755
instead of using a file

1222
00:30:34,875 --> 00:30:35,930
0,285 285,510 510,675 675,810 810,1055
system, they wrote their own

1223
00:30:36,130 --> 00:30:37,170
0,335 335,560 560,710 710,830 830,1040
storage layer on top of

1224
00:30:37,170 --> 00:30:39,195
0,315 315,630 630,980 1210,1610 1750,2025
raw block devices. Like people

1225
00:30:39,195 --> 00:30:40,100
0,150 150,315 315,450 450,600 600,905
have tried this every years

1226
00:30:40,390 --> 00:30:43,040
0,260 260,485 485,815 815,1180
from an engineering perspective.|
|

1227
00:30:43,110 --> 00:30:44,495
0,335 335,710 710,1000 1050,1295 1295,1385
It's oftentimes you do have
通常情况下，你确实必须依赖操作系统，但你想尽量减少与它的接触。

1228
00:30:44,495 --> 00:30:45,215
0,105 105,225 225,330 330,480 480,720
to rely on the OS,

1229
00:30:45,215 --> 00:30:46,190
0,180 180,255 255,330 330,465 465,975
but you want to minimize

1230
00:30:46,190 --> 00:30:47,640
0,240 240,450 450,675 675,950
your contact with it.|
|

1231
00:30:47,640 --> 00:30:48,270
0,105 105,195 195,345 345,525 525,630
Because the OS is going
因为操作系统将成为你的敌人。

1232
00:30:48,270 --> 00:30:49,480
0,45 45,90 90,180 180,440
to be your enemy.|
|

1233
00:30:51,550 --> 00:30:52,920
0,275 275,550
Other questions?|
还有其他问题吗？|

1234
00:30:54,660 --> 00:30:55,310
0,230 230,365 365,470 470,560 560,650
I don't spend too much
我没有在MF上花太多时间，只要说这是个坏主意，就不要做了。如果我死了，你知道你可以把我的墓碑放在我的墓碑上，永远不要把MF用于你的数据库。我之所以想提出这一点是因为，你知道，我们邀请了很多数据库公司和初创公司来CM U演讲，令人惊讶的是，在过去的几年里，他们中的许多人提到他们正在使用MAP，我们问他们为什么要使用MAP，他们说，哦，因为它又快又容易使用，然后当我们几年后与他们交谈时，他们说，哦，是的，这是一个巨大的错误。我们不应该做地图。我们应该做第六课要教你们的，对吗？下面是我所知道的一些使用MAP的系统的列表。我肯定还有其他几个我错过了。有一堆业余爱好项目。

1235
00:30:55,310 --> 00:30:57,050
0,120 120,210 210,560 1150,1545 1545,1740
time on mf suffice say

1236
00:30:57,050 --> 00:30:58,145
0,180 180,255 255,450 450,765 765,1095
it's a bad idea, don't

1237
00:30:58,145 --> 00:31:00,310
0,105 105,365 1495,1740 1740,1875 1875,2165
do it. If I die,

1238
00:31:01,020 --> 00:31:01,850
0,245 245,455 455,650 650,740 740,830
you know you can put

1239
00:31:01,850 --> 00:31:03,245
0,60 60,180 180,680 940,1230 1230,1395
on my tombstone never use

1240
00:31:03,245 --> 00:31:05,530
0,225 225,315 315,390 390,635 1885,2285
mf for your database. And

1241
00:31:05,790 --> 00:31:06,890
0,260 260,425 425,635 635,830 830,1100
the reason why I I

1242
00:31:06,890 --> 00:31:07,550
0,240 240,345 345,420 420,525 525,660
was want to bring this

1243
00:31:07,550 --> 00:31:08,945
0,135 135,330 330,650 1090,1320 1320,1395
up is because, you know

1244
00:31:08,945 --> 00:31:09,620
0,165 165,360 360,480 480,585 585,675
we invite a lot of

1245
00:31:09,620 --> 00:31:11,000
0,230 310,660 660,930 930,1125 1125,1380
these database companies and startups

1246
00:31:11,000 --> 00:31:11,645
0,75 75,195 195,345 345,495 495,645
to come give talks at

1247
00:31:11,645 --> 00:31:13,535
0,105 105,210 210,485 715,1115 1315,1890
C M U and surprisingly

1248
00:31:13,535 --> 00:31:14,075
0,135 135,225 225,330 330,450 450,540
over the last couple of

1249
00:31:14,075 --> 00:31:14,900
0,195 195,420 420,585 585,690 690,825
years a lot of them

1250
00:31:14,900 --> 00:31:16,490
0,240 240,465 465,585 585,1070 1330,1590
mentioned they're using map and

1251
00:31:16,490 --> 00:31:17,510
0,105 105,240 240,420 420,710 760,1020
we ask them why and

1252
00:31:17,510 --> 00:31:18,485
0,135 135,300 300,495 495,660 660,975
they say oh because it's

1253
00:31:18,485 --> 00:31:19,360
0,225 225,315 315,465 465,630 630,875
quick and easy to use

1254
00:31:19,680 --> 00:31:20,450
0,275 275,410 410,530 530,635 635,770
and then when we go

1255
00:31:20,450 --> 00:31:21,035
0,180 180,300 300,375 375,480 480,585
talk to them a few

1256
00:31:21,035 --> 00:31:21,710
0,120 120,300 300,450 450,555 555,675
years later like oh yeah,

1257
00:31:21,710 --> 00:31:22,415
0,105 105,195 195,285 285,480 480,705
that was a huge mistake.

1258
00:31:22,415 --> 00:31:22,970
0,135 135,240 240,345 345,450 450,555
We should not have done

1259
00:31:22,970 --> 00:31:23,870
0,315 315,495 495,585 585,690 690,900
map. We should have done

1260
00:31:23,870 --> 00:31:25,115
0,330 330,690 690,975 975,1140 1140,1245
what lecture six is going

1261
00:31:25,115 --> 00:31:26,915
0,90 90,210 210,485 625,1025 1555,1800
to teach you, right? So

1262
00:31:26,915 --> 00:31:27,815
0,180 180,255 255,555 555,720 720,900
here's a listing of some

1263
00:31:27,815 --> 00:31:28,685
0,195 195,360 360,480 480,660 660,870
systems that I know using

1264
00:31:28,685 --> 00:31:29,530
0,255 255,390 390,435 435,555 555,845
map. There's a couple others

1265
00:31:29,580 --> 00:31:30,650
0,335 335,500 500,725 725,860 860,1070
I'm sure I'm missing. There's

1266
00:31:30,650 --> 00:31:31,300
0,60 60,135 135,210 210,405 405,650
a bunch of hobby projects.|
|

1267
00:31:32,620 --> 00:31:33,340
0,210 210,345 345,495 495,615 615,720
So the one at the
因此，在顶部的那个，这些是完全用户。在这些系统中，它们完全使用MAP来处理磁盘和内存中来回的所有数据。

1268
00:31:33,340 --> 00:31:34,165
0,150 150,300 300,420 420,570 570,825
top, these are full users.

1269
00:31:34,165 --> 00:31:35,250
0,225 225,360 360,600 600,825 825,1085
These are systems where they

1270
00:31:35,810 --> 00:31:37,170
0,350 350,605 605,935 935,1100 1100,1360
entirely use map for all

1271
00:31:37,490 --> 00:31:38,755
0,260 260,520 660,935 935,1070 1070,1265
of data back and forth

1272
00:31:38,755 --> 00:31:41,300
0,225 225,465 465,555 555,815
from disk and memory.|
|

1273
00:31:41,300 --> 00:31:42,110
0,210 210,375 375,600 600,750 750,810
The most famous one of
其中最著名的大概就是弹性钼了。80b是……的代名词。

1274
00:31:42,110 --> 00:31:44,285
0,105 105,255 255,405 405,800 1900,2175
these is probably elastic Mo.

1275
00:31:44,285 --> 00:31:45,710
0,180 180,390 390,555 555,815 925,1425
Eighty b was a commore

1276
00:31:45,710 --> 00:31:47,200
0,105 105,350
out of.|
|

1277
00:31:47,210 --> 00:31:48,640
0,400
Right.|
正确的。|

1278
00:31:49,130 --> 00:31:50,005
0,245 245,380 380,590 590,755 755,875
C W I the same
也就是构建数据库的地方，lmdb做的可能与我相反，我的意思是永远不要使用map。他喜欢一直使用地图，他在一堆不同的数据库邮件列表上被禁止，因为他会给他们发电子邮件，说你们应该使用，你应该使用L M.D.B应该使用m地图，对吗？他错了。

1279
00:31:50,005 --> 00:31:51,670
0,135 135,255 255,465 465,935 1435,1665
place that build DB the

1280
00:31:51,670 --> 00:31:53,250
0,525 525,750 750,1050 1050,1290 1290,1580
lmdb do probably the exact

1281
00:31:53,300 --> 00:31:54,280
0,245 245,350 350,560 560,770 770,980
opposite of me where I'm

1282
00:31:54,280 --> 00:31:55,390
0,180 180,405 405,585 585,885 885,1110
saying never use map. He's

1283
00:31:55,390 --> 00:31:56,790
0,225 225,620 640,900 900,1020 1020,1400
like always always use map

1284
00:31:57,020 --> 00:31:58,030
0,305 305,500 500,635 635,935 935,1010
and he been banned on

1285
00:31:58,030 --> 00:31:59,095
0,75 75,180 180,360 360,585 585,1065
a bunch of different databases

1286
00:31:59,095 --> 00:31:59,965
0,270 270,435 435,585 585,690 690,870
mailing list because he would

1287
00:31:59,965 --> 00:32:00,790
0,210 210,375 375,510 510,645 645,825
email them and say like

1288
00:32:00,790 --> 00:32:01,500
0,165 165,300 300,390 390,465 465,710
you guys should be using,

1289
00:32:01,700 --> 00:32:02,380
0,230 230,305 305,380 380,515 515,680
you should be using L

1290
00:32:02,380 --> 00:32:03,240
0,135 135,255 255,420 420,600 600,860
M D B should using

1291
00:32:03,440 --> 00:32:05,010
0,260 260,520 540,940 990,1325 1325,1570
m map, right? He's wrong.|
|

1292
00:32:06,700 --> 00:32:10,095
0,400 2790,3065 3065,3245 3245,3290 3290,3395
He but here's the ones
他，但这是部分使用它的人。实际上，我把漫画设为完全用户。他们真的应该在顶端，但这里底部的人，他们都摆脱了它。

1293
00:32:10,095 --> 00:32:13,500
0,275 1285,1650 1650,1965 1965,2315 3175,3405
the partially using it. Actually,

1294
00:32:13,500 --> 00:32:14,400
0,120 120,300 300,630 630,735 735,900
I put manga as full

1295
00:32:14,400 --> 00:32:15,135
0,225 225,420 420,525 525,645 645,735
user. They should really be

1296
00:32:15,135 --> 00:32:16,335
0,60 60,165 165,425 745,1050 1050,1200
at the top, but the

1297
00:32:16,335 --> 00:32:17,120
0,120 120,210 210,270 270,450 450,785
ones at the bottom here,

1298
00:32:17,380 --> 00:32:18,165
0,275 275,425 425,575 575,695 695,785
they all got rid of

1299
00:32:18,165 --> 00:32:18,860
0,245
it.|
|

1300
00:32:18,950 --> 00:32:20,110
0,395 395,680 680,830 830,1010 1010,1160
Right, because of all the
是的，由于我前面提到的所有问题，如果你使用MAP，你可以很快启动和运行一些东西，因为你不必构建自己的缓冲池管理器，但因为你躺在操作系统上来回移动数据，它将做出可怕的决定，对吗？

1301
00:32:20,110 --> 00:32:21,090
0,230 250,495 495,570 570,690 690,980
issues that I mentioned before,

1302
00:32:21,290 --> 00:32:22,345
0,245 245,350 350,610 690,935 935,1055
you can get, you can

1303
00:32:22,345 --> 00:32:23,190
0,180 180,360 360,480 480,585 585,845
get something up and running

1304
00:32:23,360 --> 00:32:24,415
0,290 290,580 630,875 875,950 950,1055
pretty quickly if you use

1305
00:32:24,415 --> 00:32:25,285
0,300 300,555 555,720 720,840 840,870
map, because you don't have

1306
00:32:25,285 --> 00:32:25,855
0,60 60,180 180,285 285,360 360,570
to build your own buffer

1307
00:32:25,855 --> 00:32:27,535
0,90 90,335 835,1200 1200,1455 1455,1680
pool manager, but because you're

1308
00:32:27,535 --> 00:32:28,465
0,135 135,270 270,420 420,660 660,930
lying on the OS to

1309
00:32:28,465 --> 00:32:29,370
0,225 225,405 405,540 540,645 645,905
move data back and forth,

1310
00:32:29,510 --> 00:32:30,325
0,335 335,410 410,470 470,575 575,815
it's going to make horrible

1311
00:32:30,325 --> 00:32:32,380
0,365 955,1355
decisions, right?|
|

1312
00:32:32,420 --> 00:32:33,745
0,395 395,530 530,820 990,1220 1220,1325
I'm not going, I don't
我不去，我不想摘一只芒果，但芒果就是最好的例子。Mongo从一个基于m图的存储引擎存储管理器开始，他们是2000年代的热门数据库。他们筹集了大量的投资者资金，而且他们有非常优秀的工程师，所以他们和他们是基于时间和地图，如果地图是正确的选择。

1313
00:32:33,745 --> 00:32:34,390
0,30 30,90 90,180 180,300 300,645
want to pick a mongo

1314
00:32:34,390 --> 00:32:35,095
0,135 135,405 405,450 450,525 525,705
but mongo is the best

1315
00:32:35,095 --> 00:32:36,625
0,240 240,390 390,600 600,1175 1225,1530
example of this. Mongo started

1316
00:32:36,625 --> 00:32:37,375
0,180 180,285 285,375 375,510 510,750
off with an m map

1317
00:32:37,375 --> 00:32:39,060
0,365 475,780 780,1080 1080,1380 1380,1685
based storage engine storage manager

1318
00:32:39,590 --> 00:32:40,675
0,275 275,550 630,890 890,995 995,1085
and they, they were the

1319
00:32:40,675 --> 00:32:41,635
0,135 135,375 375,570 570,660 660,960
hot database in the 2000

1320
00:32:41,635 --> 00:32:43,150
0,335 595,885 885,1065 1065,1290 1290,1515
tens. They raised a ton

1321
00:32:43,150 --> 00:32:44,250
0,180 180,300 300,495 495,780 780,1100
of, you know, investor money

1322
00:32:44,630 --> 00:32:45,565
0,245 245,320 320,440 440,650 650,935
and they had really good

1323
00:32:45,565 --> 00:32:46,990
0,285 285,450 450,695 1075,1320 1320,1425
engineers, so they and they

1324
00:32:46,990 --> 00:32:47,605
0,120 120,240 240,375 375,510 510,615
were based on time and

1325
00:32:47,605 --> 00:32:49,060
0,365 565,855 855,1185 1185,1335 1335,1455
map if map was the

1326
00:32:49,060 --> 00:32:50,360
0,195 195,530
right choice.|
|

1327
00:32:50,460 --> 00:32:52,070
0,305 305,530 530,680 680,910 1320,1610
Then they could have, they
那么他们就可以，他们就可以做到这一点。

1328
00:32:52,070 --> 00:32:52,840
0,120 120,195 195,315 315,480 480,770
could have made that work.|
|

1329
00:32:53,600 --> 00:32:54,570
0,305 305,455 455,545 545,680 680,970
But what do they do?
但他们会做什么呢？他们把所有的东西都扔掉了，他们用一名不使用这张地图的仓储经理买下了铁丝虎。

1330
00:32:54,620 --> 00:32:55,570
0,305 305,455 455,545 545,710 710,950
They threw it all away

1331
00:32:55,570 --> 00:32:56,485
0,165 165,270 270,420 420,645 645,915
and they bought wire tiger

1332
00:32:56,485 --> 00:32:57,520
0,180 180,390 390,645 645,855 855,1035
with a storage manager that

1333
00:32:57,520 --> 00:32:58,900
0,240 240,330 330,450 450,710
doesn't use that map.|
|

1334
00:32:59,030 --> 00:33:01,495
0,400 1260,1625 1625,1865 1865,2140 2220,2465
Right. So again, just to
正确的。因此，再次重申，永远不要使用，我们不想使用操作系统来管理内存，因为数据系统总是更适合这样做。

1335
00:33:01,495 --> 00:33:03,220
0,425 535,870 870,1185 1185,1500 1500,1725
reiterate, never use, we don't

1336
00:33:03,220 --> 00:33:04,210
0,60 60,290 370,645 645,780 780,990
want to use the OS

1337
00:33:04,210 --> 00:33:05,695
0,195 195,345 345,650 910,1260 1260,1485
to manage memory because the

1338
00:33:05,695 --> 00:33:06,565
0,195 195,375 375,585 585,795 795,870
data system is always going

1339
00:33:06,565 --> 00:33:07,330
0,45 45,180 180,330 330,510 510,765
to be a better position

1340
00:33:07,330 --> 00:33:08,460
0,165 165,270 270,530
to do this.|
|

1341
00:33:08,460 --> 00:33:09,300
0,180 180,405 405,585 585,735 735,840
And it's not just for
而且它不仅仅用于管理内存，它基本上适用于所有事情。我们不需要我们来调度，我们不想让我们来缓存权限，我们不需要我们来使用。

1342
00:33:09,300 --> 00:33:10,710
0,210 210,480 480,780 780,1065 1065,1410
managing memory, it's basically for

1343
00:33:10,710 --> 00:33:11,850
0,350 460,705 705,900 900,1035 1035,1140
everything. We don't need the

1344
00:33:11,850 --> 00:33:12,825
0,165 165,375 375,735 735,855 855,975
us for scheduling, we don't

1345
00:33:12,825 --> 00:33:14,745
0,30 30,245 565,945 945,1325 1375,1920
want to us for caching

1346
00:33:14,745 --> 00:33:16,670
0,335 1195,1425 1425,1590 1590,1695 1695,1925
rights, we don't the us

1347
00:33:17,080 --> 00:33:19,500
0,290 290,580 630,1030
use the for.|
|

1348
00:33:19,740 --> 00:33:20,735
0,260 260,365 365,545 545,755 755,995
And the network stuff you
以及你在某些情况下需要的网络东西，但这是有诀窍的，但操作系统总是会是一个问题。

1349
00:33:20,735 --> 00:33:21,605
0,255 255,435 435,585 585,705 705,870
need to in some cases,

1350
00:33:21,605 --> 00:33:23,165
0,305 865,1215 1215,1380 1380,1470 1470,1560
but there's tricks for that,

1351
00:33:23,165 --> 00:33:24,740
0,245 625,960 960,1170 1170,1380 1380,1575
but the OS is always

1352
00:33:24,740 --> 00:33:25,240
0,90 90,135 135,180 180,255 255,500
going to be a problem.|
|

1353
00:33:26,040 --> 00:33:28,725
0,380 1030,1320 1320,1560 1560,1910 2410,2685
Ah, and again for m
啊，再来一次我的地图。再次声明，我将在Piazza上发送此链接。我们写了一篇关于这个的论文，那么为什么你不想用这个呢？然后有一段10分钟的YouTube视频卡通片，讲述了所有的问题。

1354
00:33:28,725 --> 00:33:29,775
0,240 240,555 555,840 840,930 930,1050
map. Again, I'll send this

1355
00:33:29,775 --> 00:33:31,020
0,135 135,300 300,845 895,1140 1140,1245
link on piazza. We wrote

1356
00:33:31,020 --> 00:33:31,575
0,105 105,225 225,360 360,465 465,555
a paper about this, so

1357
00:33:31,575 --> 00:33:32,010
0,105 105,195 195,300 300,345 345,435
why you don't want to

1358
00:33:32,010 --> 00:33:32,900
0,150 150,330 330,480 480,585 585,890
use this? And then there's

1359
00:33:33,130 --> 00:33:33,975
0,275 275,365 365,500 500,635 635,845
there's a ten minute Youtube

1360
00:33:33,975 --> 00:33:35,955
0,270 270,720 720,1055 1585,1860 1860,1980
video cartoon about all the

1361
00:33:35,955 --> 00:33:37,480
0,245
problems.|
|

1362
00:33:37,920 --> 00:33:39,245
0,245 245,425 425,695 695,1030 1050,1325
So again, the OS is
因此，操作系统将再次成为我们的问题，我们必须设计我们的系统来处理它。

1363
00:33:39,245 --> 00:33:40,010
0,120 120,210 210,375 375,570 570,765
going to be a problem

1364
00:33:40,010 --> 00:33:40,655
0,150 150,300 300,480 480,570 570,645
for us, and we have

1365
00:33:40,655 --> 00:33:41,750
0,135 135,315 315,465 465,725 835,1095
to design our system to

1366
00:33:41,750 --> 00:33:42,980
0,135 135,240 240,470
deal with it.|
|

1367
00:33:45,300 --> 00:33:46,505
0,260 260,455 455,785 785,1025 1025,1205
All right, so for database
好的，对于数据库存储，我有两个问题要处理。

1368
00:33:46,505 --> 00:33:48,140
0,335 1080,1230 1230,1380 1380,1530 1530,1635
storage, there's two problems I

1369
00:33:48,140 --> 00:33:49,500
0,60 60,135 135,240 240,500
got to deal with.|
|

1370
00:33:50,060 --> 00:33:50,620
0,245 245,305 305,365 365,425 425,560
How are we going to
我们将如何表示磁盘上这些文件上的数据库？然后，一旦我们有了这些，我们如何在磁盘和内存之间来回移动数据？所以今天的课程将讨论第一个问题，然后我们将在接下来的课程中讨论第二个问题。

1371
00:33:50,620 --> 00:33:52,705
0,320 820,1220 1480,1725 1725,1905 1905,2085
represent the the database on

1372
00:33:52,705 --> 00:33:54,220
0,135 135,330 330,510 510,995 1255,1515
these files on disk? And

1373
00:33:54,220 --> 00:33:55,770
0,260 670,945 945,1080 1080,1245 1245,1550
then once we have those,

1374
00:33:55,940 --> 00:33:56,905
0,275 275,395 395,515 515,710 710,965
how do we move data

1375
00:33:56,905 --> 00:33:58,030
0,210 210,345 345,495 495,675 675,1125
back and forth from disk

1376
00:33:58,030 --> 00:34:00,295
0,300 300,620 1270,1650 1650,2100 2100,2265
into memory? So today's lecture

1377
00:34:00,295 --> 00:34:01,120
0,300 300,495 495,555 555,675 675,825
is going to be on

1378
00:34:01,120 --> 00:34:02,620
0,225 225,495 495,705 705,1010 1240,1500
the first problem here, and

1379
00:34:02,620 --> 00:34:04,900
0,105 105,255 255,435 435,770 1960,2280
then we'll cover the second

1380
00:34:04,900 --> 00:34:06,900
0,320 850,1125 1125,1320 1320,1545 1545,2000
problem in the upcoming lectures.|
|

1381
00:34:10,140 --> 00:34:11,180
0,400
Right.|
正确的。|

1382
00:34:11,190 --> 00:34:12,305
0,400 630,950 950,995 995,1025 1025,1115
So there's going to be
因此，这些磁盘页上的数据将分为三层。所以第一个问题是，这些文件实际上是什么样子的？

1383
00:34:12,305 --> 00:34:13,720
0,120 120,300 300,600 600,1110 1110,1415
sort of three layers of

1384
00:34:14,160 --> 00:34:14,945
0,290 290,470 470,605 605,680 680,785
what data is going to

1385
00:34:14,945 --> 00:34:15,980
0,150 150,390 390,615 615,750 750,1035
look like on these disk

1386
00:34:15,980 --> 00:34:18,665
0,290 2050,2265 2265,2340 2340,2490 2490,2685
pages. So the first question

1387
00:34:18,665 --> 00:34:20,170
0,305 655,915 915,1005 1005,1170 1170,1505
is, what do these files

1388
00:34:20,250 --> 00:34:22,620
0,260 260,410 410,700
actually look like?|
|

1389
00:34:22,620 --> 00:34:24,170
0,255 255,530 700,1035 1035,1260 1260,1550
And then within a file,
然后在一个文件中，有几页，因为我们需要将它分成不同的块.然后我们将讨论这些页面的外观。然后在该页面中，我们将拥有两个数据本身，即表。我们现在可以忽略索引，并且您必须确定两个Poll实际上是什么样子。所以从顶部开始，然后深入到这些文件的内部，以了解它们实际包含的内容。

1390
00:34:24,190 --> 00:34:25,335
0,305 305,455 455,760 810,1040 1040,1145
there's be pages, because we

1391
00:34:25,335 --> 00:34:26,210
0,195 195,405 405,495 495,600 600,875
to break it up into

1392
00:34:26,410 --> 00:34:28,245
0,320 320,820 960,1205 1205,1450 1590,1835
different chunks. And then then

1393
00:34:28,245 --> 00:34:29,130
0,180 180,330 330,465 465,630 630,885
we'll discuss what these pages

1394
00:34:29,130 --> 00:34:30,675
0,225 225,500 970,1230 1230,1350 1350,1545
look like. And then within

1395
00:34:30,675 --> 00:34:31,530
0,255 255,525 525,750 750,795 795,855
that page, we're going to

1396
00:34:31,530 --> 00:34:33,230
0,135 135,590 760,1035 1035,1305 1305,1700
have twoples the data itself,

1397
00:34:33,490 --> 00:34:35,655
0,275 275,550 1530,1775 1775,1925 1925,2165
the tables. We can ignore

1398
00:34:35,655 --> 00:34:37,110
0,345 345,450 450,695 1135,1380 1380,1455
indexes for now, and you

1399
00:34:37,110 --> 00:34:38,805
0,60 60,180 180,405 405,740 1420,1695
have to decide what actually

1400
00:34:38,805 --> 00:34:40,190
0,120 120,240 240,375 375,635 985,1385
two pol look like. So

1401
00:34:40,210 --> 00:34:41,070
0,275 275,380 380,485 485,695 695,860
start at the top and

1402
00:34:41,070 --> 00:34:42,350
0,165 165,405 405,630 630,915 915,1280
then go deeper, deeper inside

1403
00:34:42,730 --> 00:34:44,490
0,400 510,785 785,1060 1260,1580 1580,1760
of these files to understand

1404
00:34:44,490 --> 00:34:46,040
0,150 150,285 285,450 450,770 1150,1550
what, what they actually contain.|
|

1405
00:34:48,790 --> 00:34:49,545
0,230 230,305 305,410 410,530 530,755
So as I said before,
正如我前面所说的，数据库系统将数据库作为磁盘上的一个或多个文件进行维护，SQL、light d、DB，这些都是单文件数据库，所有企业数据库或Postgres、我的SQL，每个其他系统，您知道，功能更全的系统将运行，您知道，为您的表和数据库维护多个文件。

1406
00:34:49,545 --> 00:34:50,490
0,210 210,405 405,675 675,855 855,945
the database system is going

1407
00:34:50,490 --> 00:34:51,915
0,60 60,290 490,765 765,1040 1090,1425
to maintain a database as

1408
00:34:51,915 --> 00:34:52,635
0,165 165,240 240,360 360,540 540,720
one or more files on

1409
00:34:52,635 --> 00:34:54,270
0,485 625,1005 1005,1155 1155,1335 1335,1635
disk, sql, light d, DB,

1410
00:34:54,270 --> 00:34:55,290
0,195 195,315 315,480 480,750 750,1020
those are all single file

1411
00:34:55,290 --> 00:34:57,720
0,680 970,1335 1335,1650 1650,1920 1920,2430
databases, all the enterprise databases

1412
00:34:57,720 --> 00:34:58,815
0,165 165,540 540,675 675,930 930,1095
or postgres, my sql, every

1413
00:34:58,815 --> 00:35:00,405
0,285 285,665 1045,1275 1275,1395 1395,1590
other system, you know, more

1414
00:35:00,405 --> 00:35:02,160
0,180 180,390 390,725 1225,1575 1575,1755
full featured system is going

1415
00:35:02,160 --> 00:35:03,890
0,60 60,290 520,920 1240,1485 1485,1730
to be running, you know,

1416
00:35:04,180 --> 00:35:05,835
0,400 420,770 770,1115 1115,1445 1445,1655
maintaining multiple files for your

1417
00:35:05,835 --> 00:35:07,180
0,195 195,360 360,905
tables and databases.|
|

1418
00:35:07,810 --> 00:35:10,180
0,290 290,560 560,940
And so the.|
所以。|

1419
00:35:10,190 --> 00:35:12,025
0,400 540,935 935,1295 1295,1595 1595,1835
The format that these files
这些文件将基于的格式通常将是数据库系统的专有或定制格式。

1420
00:35:12,025 --> 00:35:12,895
0,285 285,480 480,525 525,660 660,870
are going to be based

1421
00:35:12,895 --> 00:35:14,380
0,210 210,515 835,1215 1215,1425 1425,1485
on is typically going to

1422
00:35:14,380 --> 00:35:16,270
0,60 60,740 910,1230 1230,1550 1570,1890
be proprietary or custom to

1423
00:35:16,270 --> 00:35:17,305
0,225 225,375 375,555 555,840 840,1035
whatever the database system actually

1424
00:35:17,305 --> 00:35:18,220
0,245
is.|
|

1425
00:35:18,670 --> 00:35:19,755
0,320 320,500 500,680 680,890 890,1085
Right, that meaning like you
对，这意味着您不能获取Postgres数据库文件并在我的SQL中打开它们，也不能在SQL Light中打开它们。现在是Duct DB，因为他们想要可移植并与SQL Lite兼容。他们有连接器，你知道的，你可以读取SQLite文件和其他东西。但总的来说，所有主要的数据库系统都将拥有自己的专有格式。

1426
00:35:19,755 --> 00:35:21,450
0,360 360,615 615,825 825,1320 1320,1695
can't take the postgres database

1427
00:35:21,450 --> 00:35:22,995
0,380 760,1110 1110,1290 1290,1380 1380,1545
files and open them up

1428
00:35:22,995 --> 00:35:24,660
0,285 285,540 540,705 705,1145 1345,1665
in in my sql or

1429
00:35:24,660 --> 00:35:25,380
0,150 150,225 225,330 330,465 465,720
open them up in sql

1430
00:35:25,380 --> 00:35:27,120
0,260 520,795 795,1020 1020,1460 1480,1740
light. Now duct DB because

1431
00:35:27,120 --> 00:35:27,945
0,120 120,210 210,285 285,450 450,825
they want to be portable

1432
00:35:27,945 --> 00:35:29,805
0,180 180,705 705,995 1345,1620 1620,1860
and compatible with with sql

1433
00:35:29,805 --> 00:35:31,170
0,225 225,450 450,690 690,1140 1140,1365
lite. They have connectors allow

1434
00:35:31,170 --> 00:35:32,130
0,195 195,390 390,630 630,825 825,960
you to read, you know,

1435
00:35:32,130 --> 00:35:33,320
0,360 360,585 585,750 750,885 885,1190
sqlite files and other things.

1436
00:35:33,760 --> 00:35:35,115
0,230 230,350 350,640 660,1040 1040,1355
But in general, all the

1437
00:35:35,115 --> 00:35:35,940
0,240 240,450 450,630 630,750 750,825
major database systems are going

1438
00:35:35,940 --> 00:35:36,945
0,60 60,180 180,315 315,465 465,1005
to have their own proprietary

1439
00:35:36,945 --> 00:35:37,780
0,305
format.|
|

1440
00:35:38,070 --> 00:35:39,095
0,260 260,440 440,620 620,830 830,1025
And the OS doesn't know
操作系统不知道这些文件中有什么，不知道页面中有什么，也不知道索引和表在哪里。它什么都不知道，只看到一堆文件。

1441
00:35:39,095 --> 00:35:39,965
0,225 225,345 345,615 615,765 765,870
anything about what's inside of

1442
00:35:39,965 --> 00:35:41,405
0,120 120,395 775,1110 1110,1215 1215,1440
these files, doesn't know what's

1443
00:35:41,405 --> 00:35:42,170
0,120 120,195 195,285 285,480 480,765
inside of a page, doesn't

1444
00:35:42,170 --> 00:35:43,205
0,135 135,345 345,675 675,810 810,1035
know where indexes are versus

1445
00:35:43,205 --> 00:35:44,000
0,240 240,420 420,540 540,645 645,795
tables are. It just knows

1446
00:35:44,000 --> 00:35:44,660
0,210 210,390 390,510 510,585 585,660
nothing just sees a bunch

1447
00:35:44,660 --> 00:35:45,760
0,120 120,380
of files.|
|

1448
00:35:46,330 --> 00:35:47,400
0,275 275,470 470,725 725,950 950,1070
So next class we'll talk
因此，下一节课我们将讨论门户文件格式。像是镶木地板，阿罗，兽人，箭。这些将是数据库文件的开放源码规范。然后有一堆广告识别系统知道如何读取、访问和写入它们。

1449
00:35:47,400 --> 00:35:49,110
0,180 180,465 465,690 690,1160 1420,1710
about portal file formats. Things

1450
00:35:49,110 --> 00:35:51,380
0,180 180,705 705,1320 1320,1850 1870,2270
like parquet, aro, orc, arrow.

1451
00:35:51,790 --> 00:35:52,610
0,290 290,410 410,485 485,575 575,820
These are going to be

1452
00:35:53,380 --> 00:35:55,740
0,290 290,580 990,1660 1710,2105 2105,2360
open source specifications for what

1453
00:35:55,740 --> 00:35:57,195
0,260 490,825 825,1095 1095,1305 1305,1455
a database file could look

1454
00:35:57,195 --> 00:35:58,440
0,275 715,990 990,1095 1095,1200 1200,1245
like. And then there's a

1455
00:35:58,440 --> 00:35:59,115
0,90 90,180 180,240 240,405 405,675
bunch of ad identity systems

1456
00:35:59,115 --> 00:36:00,180
0,210 210,375 375,585 585,855 855,1065
that know how to to

1457
00:36:00,180 --> 00:36:01,065
0,135 135,255 255,420 420,630 630,885
read them and access them

1458
00:36:01,065 --> 00:36:02,140
0,225 225,375 375,665
and write them.|
|

1459
00:36:03,050 --> 00:36:03,930
0,215 215,335 335,485 485,605 605,880
But we'll about those later.|
但我们以后会讨论这些的。|

1460
00:36:04,950 --> 00:36:05,830
0,245 245,350 350,485 485,620 620,880
And as I said before,
就像我之前说的，在20世纪80年代，有很多早期的数据库系统决定，他们不仅会有定制的文件格式，他们还会有定制的文件系统，他们不会使用E X T，三个不，不存在。你知道，b，当时还不存在三个文件系统，但他们，无论80年代的设备是什么，他们甚至不依赖于操作系统所说的，文件系统是什么。他们想要自己做所有的事情。

1461
00:36:06,240 --> 00:36:07,820
0,275 275,395 395,575 575,1090 1320,1580
in the nineteen eighties there

1462
00:36:07,820 --> 00:36:09,200
0,120 120,330 330,525 525,770 1090,1380
was a sort of a

1463
00:36:09,200 --> 00:36:10,115
0,180 180,300 300,390 390,615 615,915
lot of the earlier database

1464
00:36:10,115 --> 00:36:11,830
0,335 655,960 960,1125 1125,1350 1350,1715
systems decided that they they

1465
00:36:12,390 --> 00:36:13,325
0,275 275,500 500,710 710,815 815,935
not only were they gonna

1466
00:36:13,325 --> 00:36:15,470
0,195 195,645 645,870 870,1265 1885,2145
have customized file formats, they

1467
00:36:15,470 --> 00:36:16,415
0,165 165,315 315,405 405,540 540,945
were also gonna have customized

1468
00:36:16,415 --> 00:36:18,140
0,270 270,605 1135,1380 1380,1515 1515,1725
file systems and they weren't

1469
00:36:18,140 --> 00:36:19,265
0,75 75,165 165,410 760,990 990,1125
going to use E X

1470
00:36:19,265 --> 00:36:20,860
0,210 210,515 595,1005 1005,1305 1305,1595
T, three didn't, didn't exist.

1471
00:36:20,880 --> 00:36:22,010
0,245 245,485 485,770 770,905 905,1130
You know, b, three fs

1472
00:36:22,010 --> 00:36:22,955
0,225 225,360 360,495 495,735 735,945
didn't exist back then, but

1473
00:36:22,955 --> 00:36:23,930
0,195 195,435 435,600 600,795 795,975
they, whatever the equipment was

1474
00:36:23,930 --> 00:36:24,995
0,105 105,180 180,560 640,900 900,1065
in the eighties, they didn't

1475
00:36:24,995 --> 00:36:25,670
0,120 120,300 300,420 420,525 525,675
even rely on what the

1476
00:36:25,670 --> 00:36:26,885
0,290 340,675 675,900 900,1050 1050,1215
OS said, what the file

1477
00:36:26,885 --> 00:36:28,355
0,210 210,515 955,1215 1215,1350 1350,1470
system was. They wanted to

1478
00:36:28,355 --> 00:36:29,720
0,180 180,480 480,845
do everything themselves.|
|

1479
00:36:29,760 --> 00:36:30,560
0,245 245,410 410,485 485,590 590,800
But that's a lot of
但这是大量的工程工作，而且今天没有人这样做。而且这通常是一种边际收益。唯一仍能做到这一点的系统应该是我称之为企业系统的系统。所以这将是一个先知，DB两个，Teradatas。这些是数百万美元的数据库系统，它们正试图获得尽可能多的性能。除了运行通用操作系统文件系统外，这些系统还将支持此功能。

1480
00:36:30,560 --> 00:36:32,015
0,350 400,735 735,1005 1005,1230 1230,1455
engineering work and, and nobody

1481
00:36:32,015 --> 00:36:33,230
0,210 210,375 375,600 600,885 885,1215
does that today. And it

1482
00:36:33,230 --> 00:36:36,125
0,380 490,765 765,1140 1140,1400 2650,2895
usually a marginal benefit. The

1483
00:36:36,125 --> 00:36:37,070
0,165 165,405 405,630 630,810 810,945
only system that still do

1484
00:36:37,070 --> 00:36:37,970
0,135 135,255 255,405 405,690 690,900
this would be like what

1485
00:36:37,970 --> 00:36:39,395
0,120 120,315 315,570 570,860 1180,1425
I'll call enterprise systems. So

1486
00:36:39,395 --> 00:36:40,115
0,75 75,135 135,210 210,315 315,720
this will be an Oracle,

1487
00:36:40,115 --> 00:36:42,100
0,150 150,405 405,695 865,1245 1245,1985
the DB two, the teradatas.

1488
00:36:42,360 --> 00:36:43,625
0,245 245,455 455,755 755,1010 1010,1265
These are million Dollar database

1489
00:36:43,625 --> 00:36:44,360
0,285 285,465 465,555 555,660 660,735
systems that are trying to

1490
00:36:44,360 --> 00:36:45,770
0,90 90,210 210,470 850,1185 1185,1410
get as much, much performance

1491
00:36:45,770 --> 00:36:47,990
0,150 150,270 270,530 1660,1950 1950,2220
as you can. These systems

1492
00:36:47,990 --> 00:36:49,520
0,330 330,555 555,830 1000,1320 1320,1530
will support this in addition

1493
00:36:49,520 --> 00:36:51,395
0,135 135,270 270,560 1090,1410 1410,1875
to running off the generic

1494
00:36:51,395 --> 00:36:53,160
0,305 535,825 825,1115
OS file systems.|
|

1495
00:36:57,740 --> 00:36:59,725
0,260 260,380 380,640 1500,1805 1805,1985
So then the, the part
然后，数据库系统中负责维护和协调这些不同文件的部分，我们通常称为存储管理器。

1496
00:36:59,725 --> 00:37:00,715
0,105 105,195 195,375 375,660 660,990
of the database system that's

1497
00:37:00,715 --> 00:37:01,690
0,75 75,135 135,285 285,605 715,975
going to be responsible for

1498
00:37:01,690 --> 00:37:03,625
0,260 520,810 810,1250 1480,1740 1740,1935
maintaining and coordinating these different

1499
00:37:03,625 --> 00:37:05,605
0,335 535,870 870,1115 1285,1860 1860,1980
files, we'll call generically as

1500
00:37:05,605 --> 00:37:06,900
0,165 165,360 360,665
the storage manager.|
|

1501
00:37:08,135 --> 00:37:08,765
0,135 135,210 210,330 330,465 465,630
Sometimes it's called the storage
有时它被称为存储引擎。这是同样的想法。

1502
00:37:08,765 --> 00:37:10,840
0,305 1410,1470 1470,1590 1590,1770 1770,2075
engine. It's the same idea.|
|

1503
00:37:11,650 --> 00:37:13,110
0,400 840,1235 1235,1295 1295,1340 1340,1460
And it's going to be
它将成为系统的一部分，与硬件通信或与硬件或任何存储设备通信，通过操作系统或使用直接访问来检索数据并将其带入数据库数据库系统的内存。

1504
00:37:13,110 --> 00:37:14,060
0,135 135,225 225,345 345,585 585,950
part of the system that

1505
00:37:14,200 --> 00:37:16,560
0,695 695,1090 1620,1970 1970,2210 2210,2360
communicates with the either the

1506
00:37:16,560 --> 00:37:19,005
0,260 850,1250 1720,2160 2160,2325 2325,2445
hardware or communicates with the

1507
00:37:19,005 --> 00:37:20,580
0,245 775,1080 1080,1245 1245,1380 1380,1575
hardware or whatever the storage

1508
00:37:20,580 --> 00:37:21,645
0,210 210,435 435,690 690,870 870,1065
device is, either through the

1509
00:37:21,645 --> 00:37:23,475
0,315 315,585 585,875 1075,1455 1455,1830
OS or using direct direct

1510
00:37:23,475 --> 00:37:26,790
0,395 985,1385 2275,2865 2865,3075 3075,3315
access to retrieve data and

1511
00:37:26,790 --> 00:37:29,030
0,165 165,285 285,530 1390,1790 1840,2240
bring it into the database

1512
00:37:29,380 --> 00:37:30,880
0,335 335,725 725,970
database system's memory.|
|

1513
00:37:31,430 --> 00:37:32,335
0,260 260,380 380,575 575,725 725,905
And so we'll discuss this
所以我们将在下一节课讨论这个。我一直这么说，但有太多的事情要讨论。许多这样的系统将维护它们自己的磁盘调度器或分派器，以决定何时读取哪些页面以及读取的顺序。否则，如果你只是去做更多的f读取，然后说OS，OS就会找到如何排序的方法。但是，再说一次，戴维斯系统更好地了解它实际需要什么，以及以什么顺序。

1514
00:37:32,335 --> 00:37:33,325
0,210 210,480 480,690 690,825 825,990
next class. I keep saying

1515
00:37:33,325 --> 00:37:34,315
0,150 150,240 240,840 840,900 900,990
this, but there's so many

1516
00:37:34,315 --> 00:37:36,520
0,105 105,270 270,575 1765,2040 2040,2205
things to discuss. A bunch

1517
00:37:36,520 --> 00:37:37,470
0,135 135,270 270,495 495,690 690,950
of these systems will maintain

1518
00:37:37,580 --> 00:37:39,790
0,275 275,550 1410,1805 1805,2120 2120,2210
their own disk scheduler or

1519
00:37:39,790 --> 00:37:42,370
0,620 850,1155 1155,1610 1780,2180 2290,2580
dispatcher that decides when what

1520
00:37:42,370 --> 00:37:43,210
0,210 210,390 390,540 540,690 690,840
pages to read and what

1521
00:37:43,210 --> 00:37:45,025
0,290 1090,1350 1350,1530 1530,1725 1725,1815
order coz. Otherwise, if you

1522
00:37:45,025 --> 00:37:45,805
0,90 90,335 355,615 615,720 720,780
just go do more of

1523
00:37:45,805 --> 00:37:46,435
0,135 135,330 330,435 435,525 525,630
f read and gonna say

1524
00:37:46,525 --> 00:37:47,290
0,165 165,330 330,465 465,615 615,765
OS, the OS is gonna

1525
00:37:47,290 --> 00:37:47,995
0,180 180,345 345,465 465,555 555,705
figure out how to order

1526
00:37:47,995 --> 00:37:49,525
0,305 625,915 915,1095 1095,1305 1305,1530
things. But again, the, the,

1527
00:37:49,525 --> 00:37:50,260
0,165 165,345 345,525 525,645 645,735
the Davis system is in

1528
00:37:50,260 --> 00:37:51,025
0,60 60,210 210,450 450,630 630,765
a better position to know

1529
00:37:51,025 --> 00:37:52,750
0,120 120,270 270,450 450,725 1465,1725
what it actually needs and

1530
00:37:52,750 --> 00:37:54,580
0,120 120,255 255,530
in what order.|
|

1531
00:37:54,710 --> 00:37:56,230
0,335 335,605 605,875 875,1190 1190,1520
Various systems can can, can
各种系统可以，可以让它们自己的线程决定如何调度它们自己的磁盘读取。

1532
00:37:56,230 --> 00:37:57,460
0,255 255,420 420,660 660,990 990,1230
have their own thread decide

1533
00:37:57,460 --> 00:37:58,285
0,150 150,270 270,450 450,615 615,825
how to schedule their own

1534
00:37:58,285 --> 00:37:59,560
0,300 300,695
disk reads.|
|

1535
00:37:59,600 --> 00:38:00,220
0,260 260,365 365,440 440,515 515,620
And you want to do
你想这样做是因为你想要最大限度地减少颠簸的次数，把事情带入记忆，如何扔掉它，立刻扔掉它。因此，如果您知道两个查询需要相同的页面，您可能会先将其放在其他页面之前，然后在知道这两个查询完成后丢弃第一个页面。

1536
00:38:00,220 --> 00:38:01,260
0,180 180,465 465,675 675,780 780,1040
this because you want to

1537
00:38:01,400 --> 00:38:02,770
0,560 560,755 755,845 845,980 980,1370
minimize the amount of thrashing,

1538
00:38:02,770 --> 00:38:03,520
0,165 165,390 390,585 585,690 690,750
of bringing things into a

1539
00:38:03,520 --> 00:38:04,180
0,135 135,285 285,390 390,495 495,660
memory, how to throw it,

1540
00:38:04,180 --> 00:38:05,010
0,165 165,255 255,360 360,525 525,830
throw it out right away.

1541
00:38:05,300 --> 00:38:06,130
0,230 230,290 290,380 380,590 590,830
So if you know two

1542
00:38:06,130 --> 00:38:07,170
0,300 300,420 420,540 540,720 720,1040
queries need the same page,

1543
00:38:07,640 --> 00:38:08,545
0,290 290,440 440,575 575,725 725,905
maybe you bring that in

1544
00:38:08,545 --> 00:38:10,050
0,305 625,930 930,1080 1080,1215 1215,1505
first before some other pages

1545
00:38:10,580 --> 00:38:11,410
0,260 260,380 380,530 530,695 695,830
and then you you throw

1546
00:38:11,410 --> 00:38:12,655
0,135 135,410 520,825 825,1050 1050,1245
away the first page once

1547
00:38:12,655 --> 00:38:13,540
0,120 120,255 255,435 435,630 630,885
you know those two queries

1548
00:38:13,540 --> 00:38:14,540
0,75 75,180 180,285 285,530
are done with it.|
|

1549
00:38:15,870 --> 00:38:16,940
0,245 245,350 350,575 575,890 890,1070
So the database files are
所以数据库文件将被分解成我所说的页面。

1550
00:38:16,940 --> 00:38:17,435
0,45 45,75 75,150 150,315 315,495
going to be broken up

1551
00:38:17,435 --> 00:38:18,610
0,275 355,600 600,705 705,870 870,1175
into what I call pages.|
|

1552
00:38:19,580 --> 00:38:21,125
0,290 370,690 690,945 945,1230 1230,1545
And the data system is
数据系统负责响应，跟踪哪些数据已被读取和写入这些不同的页面，然后跟踪每个页面中有多少可用空间。

1553
00:38:21,125 --> 00:38:23,290
0,420 420,645 645,870 870,1175 1765,2165
responseor, keeping track of what

1554
00:38:23,400 --> 00:38:24,485
0,305 305,470 470,620 620,845 845,1085
data has been read and

1555
00:38:24,485 --> 00:38:26,110
0,305 535,885 885,1110 1110,1305 1305,1625
written to these various pages,

1556
00:38:27,690 --> 00:38:28,625
0,260 260,395 395,575 575,770 770,935
and then keeps track of

1557
00:38:28,625 --> 00:38:29,480
0,135 135,300 300,480 480,645 645,855
how much space is available

1558
00:38:29,480 --> 00:38:30,680
0,150 150,240 240,345 345,590
in each of them.|
|

1559
00:38:30,830 --> 00:38:31,720
0,290 290,440 440,545 545,710 710,890
Because again, if I, if
因为再一次，如果我，如果我插入一个新的，我需要插入一个新的，我需要找到一个有我空间的页面。因此，我将跟踪某个目录，该目录显示此页面有此空间，然后将其放入其中。

1560
00:38:31,720 --> 00:38:32,635
0,180 180,570 570,675 675,795 795,915
I insert a new, I

1561
00:38:32,635 --> 00:38:33,660
0,90 90,165 165,375 375,450 450,1025
need to insert a newuil,

1562
00:38:33,860 --> 00:38:34,675
0,245 245,350 350,485 485,650 650,815
I need to find a

1563
00:38:34,675 --> 00:38:35,455
0,165 165,300 300,435 435,630 630,780
page that has space for

1564
00:38:35,455 --> 00:38:36,670
0,245 505,735 735,885 885,1020 1020,1215
me. So I'll keep track

1565
00:38:36,670 --> 00:38:37,840
0,195 195,435 435,795 795,930 930,1170
of some directory that says

1566
00:38:37,840 --> 00:38:38,695
0,255 255,450 450,600 600,735 735,855
this page has this amount

1567
00:38:38,695 --> 00:38:39,535
0,105 105,360 360,615 615,735 735,840
of space and go put

1568
00:38:39,535 --> 00:38:40,520
0,90 90,195 195,455
it in there.|
|

1569
00:38:41,590 --> 00:38:43,100
0,275 275,395 395,575 575,910 1110,1510
Now, the data system itself,
现在，数据系统本身、存储管理器层，也就是我们在这里讨论的部分，不会出于冗余复制的目的维护这些页面的多个副本。我们假设这将在堆栈中系统的这一部分的上方和下方发生。因此，上面就像是某种东西，它知道查询是否出现并想要进行写入，将其发送到另一个、另一个物理盒或另一个节点，并让这两台机器都正确地执行操作。

1570
00:38:43,720 --> 00:38:45,375
0,290 290,485 485,755 755,1120 1380,1655
the storage manager layer, the

1571
00:38:45,375 --> 00:38:46,160
0,120 120,255 255,360 360,510 510,785
part we're talking about here,

1572
00:38:46,390 --> 00:38:47,420
0,395 395,590 590,740 740,800 800,1030
it's not going to maintain

1573
00:38:47,530 --> 00:38:49,910
0,380 380,950 950,1300 1770,2075 2075,2380
multiple copies of these pages

1574
00:38:50,110 --> 00:38:52,455
0,260 260,725 725,1160 1160,1480 2010,2345
for redundancy replication purposes. We

1575
00:38:52,455 --> 00:38:53,295
0,225 225,450 450,525 525,600 600,840
assume that's going to happen

1576
00:38:53,295 --> 00:38:54,680
0,315 315,600 600,915 915,1125 1125,1385
either both above and below

1577
00:38:55,630 --> 00:38:56,520
0,290 290,440 440,530 530,635 635,890
this part of the system

1578
00:38:56,520 --> 00:38:58,185
0,225 225,375 375,680 1150,1455 1455,1665
in the stack. So above

1579
00:38:58,185 --> 00:39:00,645
0,180 180,345 345,635 685,1085 2155,2460
would be like something, something

1580
00:39:00,645 --> 00:39:01,845
0,180 180,455 565,825 825,975 975,1200
that knows if a query

1581
00:39:01,845 --> 00:39:02,400
0,195 195,345 345,435 435,495 495,555
shows up and wants to

1582
00:39:02,400 --> 00:39:03,390
0,60 60,150 150,410 640,885 885,990
do a write, send it

1583
00:39:03,390 --> 00:39:04,740
0,135 135,410 460,765 765,1035 1035,1350
to another, another physical box

1584
00:39:04,740 --> 00:39:06,000
0,195 195,375 375,870 870,1110 1110,1260
or another node and have

1585
00:39:06,000 --> 00:39:07,035
0,195 195,465 465,750 750,930 930,1035
both those machines do the

1586
00:39:07,035 --> 00:39:07,800
0,245
right.|
|

1587
00:39:07,800 --> 00:39:08,565
0,180 180,300 300,495 495,675 675,765
And then below it would
然后在下面，它就像，如果您运行的是RAID或某种知道如何复制页面的存储设备，然后在下面，它也会这样做。

1588
00:39:08,565 --> 00:39:09,360
0,150 150,345 345,480 480,630 630,795
be like, if you're running

1589
00:39:09,360 --> 00:39:10,245
0,345 345,555 555,690 690,780 780,885
raid or some kind of

1590
00:39:10,245 --> 00:39:11,205
0,165 165,585 585,690 690,825 825,960
storage appliance that knows how

1591
00:39:11,205 --> 00:39:13,170
0,245 475,1005 1005,1295 1585,1830 1830,1965
to replicate pages, and then

1592
00:39:13,170 --> 00:39:14,250
0,195 195,480 480,855 855,975 975,1080
down below, it'll do that

1593
00:39:14,250 --> 00:39:15,240
0,135 135,410
as well.|
|

1594
00:39:15,250 --> 00:39:16,755
0,395 395,790 840,1160 1160,1340 1340,1505
Typically, database systems will not
通常，数据库系统本身不会维护多个副本，因为这是一大堆额外的工作。

1595
00:39:16,755 --> 00:39:18,390
0,285 285,585 585,960 960,1290 1290,1635
maintain multiple copies themselves because

1596
00:39:18,390 --> 00:39:19,035
0,270 270,315 315,405 405,495 495,645
it's a bunch of extra

1597
00:39:19,035 --> 00:39:20,000
0,335
work.|
|

1598
00:39:20,490 --> 00:39:21,920
0,400 450,1055 1055,1205 1205,1370 1370,1430
That ideally, you don't want
理想情况下，你不会想这么做的。

1599
00:39:21,920 --> 00:39:22,920
0,60 60,150 150,255 255,500
to have to do.|
|

1600
00:39:25,300 --> 00:39:26,060
0,230 230,305 305,395 395,500 500,760
So, what is a page?
那么，什么是页面呢？因此，在我们看来，从数据的角度来看，页面将是一个固定大小的数据块，它可以包含来自数据库本身任何部分的数据。对于这堂课，我们假设它只有两个或两个记录，但它可以包含索引，日志信息，附加元数据，目录统计，对吗？这无关紧要，但它仍然会被分解成这些。

1601
00:39:26,590 --> 00:39:27,735
0,230 230,305 305,500 500,850 900,1145
So in our view, from

1602
00:39:27,735 --> 00:39:28,785
0,90 90,330 330,645 645,855 855,1050
a data perspective, a page

1603
00:39:28,785 --> 00:39:29,250
0,165 165,240 240,270 270,330 330,465
is going to be a

1604
00:39:29,250 --> 00:39:30,590
0,210 210,530 610,900 900,1065 1065,1340
fixed size block of data

1605
00:39:32,080 --> 00:39:33,540
0,350 350,575 575,785 785,1115 1115,1460
and it can contain data

1606
00:39:33,540 --> 00:39:34,830
0,350 520,870 870,1095 1095,1200 1200,1290
from any part of the

1607
00:39:34,830 --> 00:39:37,305
0,260 340,740 1150,1550 1840,2235 2235,2475
database itself. And for, for

1608
00:39:37,305 --> 00:39:38,160
0,135 135,345 345,555 555,705 705,855
this lecture, we assume it's

1609
00:39:38,160 --> 00:39:39,990
0,210 210,615 615,765 765,1040 1600,1830
just twoples or records, but

1610
00:39:39,990 --> 00:39:41,750
0,90 90,225 225,495 495,1100 1360,1760
it can contain indexes, log

1611
00:39:41,800 --> 00:39:44,060
0,400 600,950 950,1550 1550,1715 1715,2260
information, additional metadata, the catalog

1612
00:39:44,590 --> 00:39:46,700
0,400 900,1300 1350,1625 1625,1865 1865,2110
statistics, right? It doesn't matter,

1613
00:39:47,590 --> 00:39:48,150
0,230 230,350 350,440 440,515 515,560
but it's still going to

1614
00:39:48,150 --> 00:39:49,190
0,75 75,210 210,360 360,620 640,1040
be broken up into these.|
|

1615
00:39:49,960 --> 00:39:51,800
0,315 315,525 525,720 720,1040
These fixed size blocks.|
这些固定大小的块。|

1616
00:39:52,150 --> 00:39:53,280
0,350 350,620 620,815 815,995 995,1130
Most systems are not going
大多数系统不会混合页面类型，这意味着您不需要从这个表、这个表和索引等内容中获取1兆字节的页面并放入数据。为简单起见，您将假设一个页面属于数据库中的某个对象、表或索引等，并且它将只包含该特定对象的数据。

1617
00:39:53,280 --> 00:39:54,980
0,90 90,285 285,540 540,860 1300,1700
to mix page types, meaning

1618
00:39:55,090 --> 00:39:56,415
0,245 245,425 425,670 930,1190 1190,1325
you don't take a one

1619
00:39:56,415 --> 00:39:57,620
0,420 420,615 615,810 810,945 945,1205
megabyte page and put in

1620
00:39:57,910 --> 00:39:59,220
0,320 320,530 530,755 755,1055 1055,1310
data from this table and

1621
00:39:59,220 --> 00:40:00,930
0,195 195,495 495,890 1150,1470 1470,1710
this table and index and

1622
00:40:00,930 --> 00:40:03,480
0,180 180,315 315,590 1510,1890 1890,2550
stuff like that. For simplicity,

1623
00:40:03,480 --> 00:40:04,125
0,195 195,240 240,345 345,495 495,645
you're going to assume that

1624
00:40:04,125 --> 00:40:05,600
0,210 210,525 525,960 960,1155 1155,1475
one page belongs to some

1625
00:40:06,340 --> 00:40:07,830
0,260 260,380 380,485 485,730 1200,1490
object in the database, a

1626
00:40:07,830 --> 00:40:08,790
0,210 210,450 450,660 660,810 810,960
table or index and so

1627
00:40:08,790 --> 00:40:09,990
0,290 490,750 750,840 840,945 945,1200
forth, and it would only

1628
00:40:09,990 --> 00:40:11,210
0,270 270,480 480,660 660,870 870,1220
contain data for that particular

1629
00:40:11,230 --> 00:40:12,040
0,400
object.|
|

1630
00:40:13,540 --> 00:40:14,595
0,320 320,560 560,725 725,860 860,1055
Some systems are gonna require
一些系统将要求每个页面都是自包含的，这意味着所有信息、所有元数据都必须包含在页面中，以便理解页面内部的内容。

1631
00:40:14,595 --> 00:40:15,645
0,255 255,525 525,675 675,795 795,1050
every page to be self

1632
00:40:15,645 --> 00:40:17,835
0,365 715,1110 1110,1505 1555,1905 1905,2190
contained, meaning all the information,

1633
00:40:17,835 --> 00:40:19,020
0,210 210,360 360,915 915,1035 1035,1185
all the metadata you need

1634
00:40:19,020 --> 00:40:20,010
0,165 165,390 390,585 585,720 720,990
to have in order to

1635
00:40:20,010 --> 00:40:21,440
0,330 330,720 720,945 945,1140 1140,1430
understand what's inside that page

1636
00:40:21,730 --> 00:40:22,545
0,260 260,350 350,500 500,695 695,815
has to be included in

1637
00:40:22,545 --> 00:40:23,920
0,105 105,330 330,695
the page itself.|
|

1638
00:40:24,250 --> 00:40:25,200
0,260 260,620 620,710 710,845 845,950
So Oracle is probably the
因此，甲骨文可能是做这项工作的最著名的公司，对吗？因此，在一个页面中，您必须跟踪它是否属于该表，以及是否具有这些类型的列等等。

1639
00:40:25,200 --> 00:40:25,980
0,105 105,315 315,510 510,630 630,780
most famous one that does

1640
00:40:25,980 --> 00:40:27,615
0,290 820,1125 1125,1275 1275,1440 1440,1635
this, right? So within a

1641
00:40:27,615 --> 00:40:28,770
0,275 355,615 615,735 735,930 930,1155
page you have to keep

1642
00:40:28,770 --> 00:40:29,835
0,165 165,300 300,555 555,825 825,1065
track of like it belongs

1643
00:40:29,835 --> 00:40:31,110
0,105 105,300 300,635 865,1110 1110,1275
to this table and has

1644
00:40:31,110 --> 00:40:32,640
0,240 240,675 675,975 975,1290 1290,1530
these columns with these types

1645
00:40:32,640 --> 00:40:33,880
0,195 195,375 375,680
and so forth.|
|

1646
00:40:34,320 --> 00:40:35,210
0,245 245,410 410,620 620,770 770,890
The reason why they want
他们这样做的原因是，如果数据库文件中有一些损坏，您不希望包含有关表的元数据的某个页面被吹走，然后现在您无法了解任何其他页面中的内容。

1647
00:40:35,210 --> 00:40:36,130
0,120 120,270 270,420 420,600 600,920
to do this is because

1648
00:40:36,600 --> 00:40:38,600
0,395 395,725 725,950 950,1330 1710,2000
if there's some corruption in,

1649
00:40:38,600 --> 00:40:39,550
0,135 135,270 270,495 495,690 690,950
you know, in the database

1650
00:40:39,780 --> 00:40:41,690
0,400 1260,1505 1505,1700 1700,1790 1790,1910
files, you don't want to

1651
00:40:41,690 --> 00:40:43,130
0,195 195,450 450,765 765,1140 1140,1440
have some page that contains

1652
00:40:43,130 --> 00:40:44,590
0,320 340,930 930,1065 1065,1200 1200,1460
the metadata about the table

1653
00:40:44,910 --> 00:40:46,085
0,305 305,560 560,845 845,1070 1070,1175
get blown away and then

1654
00:40:46,085 --> 00:40:47,345
0,135 135,300 300,725 775,1035 1035,1260
now you can't understand what's

1655
00:40:47,345 --> 00:40:48,980
0,180 180,390 390,615 615,935
in any other page.|
|

1656
00:40:49,730 --> 00:40:50,880
0,400
Right.|
正确的。|

1657
00:40:51,020 --> 00:40:52,705
0,275 275,845 845,1175 1175,1460 1460,1685
Again, replication can can can
同样，复制可以解决这个问题。硬件在现代肯定比以前可靠得多，就像硬盘驱动器一样，以前超级脆弱。嗯，他们仍然不理想，但他们比过去好多了。因此，让每个页面都自包含在今天可能不是什么问题，但甲骨文很早就做出了设计选择。

1658
00:40:52,705 --> 00:40:53,845
0,150 150,285 285,545 685,990 990,1140
solve this problem. Hardware has

1659
00:40:53,845 --> 00:40:54,745
0,150 150,420 420,615 615,720 720,900
certainly got a lot more

1660
00:40:54,745 --> 00:40:56,935
0,305 1195,1515 1515,1710 1710,1920 1920,2190
reliable in in modern times

1661
00:40:56,935 --> 00:40:58,270
0,165 165,255 255,375 375,635 1015,1335
than it did before, like

1662
00:40:58,270 --> 00:41:00,210
0,210 210,500 910,1245 1245,1635 1635,1940
hard drives, super flaky before.

1663
00:41:00,590 --> 00:41:02,320
0,400 840,1145 1145,1250 1250,1460 1460,1730
EM, they're still not ideal,

1664
00:41:02,320 --> 00:41:03,460
0,320 400,705 705,810 810,990 990,1140
but they're much better than

1665
00:41:03,460 --> 00:41:04,795
0,105 105,225 225,345 345,590 970,1335
they used to be. So

1666
00:41:04,795 --> 00:41:06,565
0,365 865,1155 1155,1365 1365,1590 1590,1770
maybe having every page be

1667
00:41:06,565 --> 00:41:07,960
0,195 195,420 420,725 955,1260 1260,1395
self contained is less of

1668
00:41:07,960 --> 00:41:10,680
0,60 60,240 240,590 1840,2240 2320,2720
an issue today, but the

1669
00:41:10,700 --> 00:41:12,150
0,380 380,665 665,860 860,1205 1205,1450
design choice that Oracle made

1670
00:41:12,230 --> 00:41:13,520
0,290 290,500 500,820
very early on.|
|

1671
00:41:14,940 --> 00:41:15,995
0,260 260,470 470,770 770,965 965,1055
Now, every page in our
现在，我们的数据库文件中的每一页都将被赋予一个唯一的标识符。

1672
00:41:15,995 --> 00:41:16,745
0,180 180,420 420,585 585,675 675,750
database file is going to

1673
00:41:16,745 --> 00:41:17,950
0,90 90,225 225,390 390,630 630,1205
be given a unique identifier.|
|

1674
00:41:18,720 --> 00:41:20,240
0,350 430,705 705,855 855,1125 1125,1520
Like a page ID, like
就像页面ID，就像你知道的，一些数字64位整数32位整数。

1675
00:41:20,440 --> 00:41:21,855
0,245 245,380 380,670 690,1040 1040,1415
you know, some number 64

1676
00:41:21,855 --> 00:41:23,030
0,90 90,405 405,660 660,750 750,1175
bit {integer32 -} bit integer.|
|

1677
00:41:23,830 --> 00:41:25,095
0,290 290,515 515,755 755,935 935,1265
And then there'll be some
然后，数据集将使用某种方法或某种机制来将页面ID映射到存储设备上的某个物理位置。同样，这可能类似于一个文件名和某个偏移量处的目录的一侧。如果我们像云存储一样运行，它可能是一个S三桶在某个偏移量等等。

1678
00:41:25,095 --> 00:41:26,490
0,375 375,615 615,780 780,1085 1165,1395
method or some mechanism that

1679
00:41:26,490 --> 00:41:27,150
0,75 75,345 345,450 450,555 555,660
the dataset is going to

1680
00:41:27,150 --> 00:41:28,665
0,260 670,945 945,1125 1125,1320 1320,1515
use that allow it to

1681
00:41:28,665 --> 00:41:30,510
0,285 285,570 570,780 780,1085 1525,1845
map a page ID to

1682
00:41:30,510 --> 00:41:32,490
0,320 610,1010 1180,1575 1575,1830 1830,1980
some physical location on our

1683
00:41:32,490 --> 00:41:34,140
0,240 240,590 1000,1290 1290,1485 1485,1650
storage device. And again, that

1684
00:41:34,140 --> 00:41:34,935
0,120 120,285 285,435 435,570 570,795
could be like a file

1685
00:41:34,935 --> 00:41:35,550
0,240 240,375 375,450 450,540 540,615
name and a side of

1686
00:41:35,550 --> 00:41:37,130
0,120 120,630 630,885 885,1160 1180,1580
a directory at some offset.

1687
00:41:37,480 --> 00:41:38,325
0,275 275,440 440,560 560,725 725,845
If we're running on like

1688
00:41:38,325 --> 00:41:39,225
0,135 135,375 375,645 645,810 810,900
a cloud storage, it could

1689
00:41:39,225 --> 00:41:40,310
0,210 210,420 420,570 570,780 780,1085
be an s three bucket

1690
00:41:40,810 --> 00:41:41,895
0,290 290,560 560,815 815,950 950,1085
at some offset and so

1691
00:41:41,895 --> 00:41:42,680
0,275
forth.|
|

1692
00:41:42,680 --> 00:41:43,940
0,290 610,855 855,975 975,1140 1140,1260
Right. For that purpose, it
正确的。出于这个目的，这并不重要。我们只是有一种方法可以说，如果我们看第一页、第二页、第三页，有一些方法可以说，这是找到它的地方。

1693
00:41:43,940 --> 00:41:44,900
0,195 195,435 435,675 675,765 765,960
doesn't matter. We just have

1694
00:41:44,900 --> 00:41:45,815
0,210 210,345 345,465 465,645 645,915
a way to say if

1695
00:41:45,815 --> 00:41:46,685
0,180 180,285 285,435 435,660 660,870
we look at page one,

1696
00:41:46,685 --> 00:41:48,275
0,180 180,485 805,1170 1170,1365 1365,1590
two, three, there's some method

1697
00:41:48,275 --> 00:41:48,950
0,150 150,285 285,510 510,600 600,675
to say, here's where to

1698
00:41:48,950 --> 00:41:50,020
0,105 105,270 270,560
go find it.|
|

1699
00:41:52,830 --> 00:41:54,020
0,230 230,460 600,980 980,1115 1115,1190
So now what's sort of
所以现在常量数据库中令人困惑的是，对于页面的实际是什么，有三种不同的概念。

1700
00:41:54,020 --> 00:41:55,610
0,410 520,855 855,1050 1050,1260 1260,1590
confusing in the constant database

1701
00:41:55,610 --> 00:41:56,990
0,330 330,680 760,1095 1095,1215 1215,1380
is that there's three different

1702
00:41:56,990 --> 00:41:57,950
0,405 405,495 495,585 585,705 705,960
notions of what a page

1703
00:41:57,950 --> 00:41:59,220
0,240 240,500
actually is.|
|

1704
00:42:00,120 --> 00:42:00,905
0,260 260,350 350,425 425,545 545,785
And so at the lowest
所以在最低层，你有一个所谓的哈佛页面。

1705
00:42:00,905 --> 00:42:01,640
0,255 255,405 405,540 540,645 645,735
level, you have what is

1706
00:42:01,640 --> 00:42:03,340
0,120 120,240 240,450 450,800
called a Harvard page.|
|

1707
00:42:04,220 --> 00:42:05,790
0,260 260,395 395,670 690,980 980,1570
This is typically four kilobytes.|
这通常是4千字节。|

1708
00:42:06,870 --> 00:42:07,760
0,275 275,455 455,650 650,785 785,890
And this is going to
而这将是。

1709
00:42:07,760 --> 00:42:09,280
0,255 255,650
be the.|
|

1710
00:42:10,490 --> 00:42:12,990
0,400 990,1390 1440,1840 1980,2240 2240,2500
The largest size or the
硬件可以保证其具有原子权限的页或数据块的最大或最小大小。

1711
00:42:13,850 --> 00:42:15,400
0,365 365,730 870,1145 1145,1310 1310,1550
small size of a page

1712
00:42:15,400 --> 00:42:16,740
0,350 490,765 765,930 930,1080 1080,1340
or a block of data

1713
00:42:17,180 --> 00:42:18,360
0,275 275,440 440,680 680,905 905,1180
that the hardware can guarantee

1714
00:42:18,380 --> 00:42:19,570
0,365 365,590 590,710 710,815 815,1190
that it can do atomic

1715
00:42:19,570 --> 00:42:20,700
0,290
rights.|
|

1716
00:42:21,660 --> 00:42:22,235
0,245 245,335 335,395 395,470 470,575
So what do I mean
那么我这么说是什么意思呢？我所说的原子权是什么意思？

1717
00:42:22,235 --> 00:42:22,640
0,90 90,210 210,315 315,360 360,405
by that? What do I

1718
00:42:22,640 --> 00:42:24,220
0,75 75,150 150,465 465,740
mean by atomic rights?|
|

1719
00:42:27,360 --> 00:42:28,240
0,245 245,365 365,500 500,620 620,880
He says all or nothing,
他要么全说要么什么都不说，对吗？这意味着，如果我告诉硬件我要写入4千字节，然后我得到确认，是的，我写入了4千字节，那么如果我需要写入8千字节，我就可以假设它成功了。

1720
00:42:28,380 --> 00:42:29,500
0,335 335,530 530,635 635,800 800,1120
right? So it means that

1721
00:42:29,970 --> 00:42:31,490
0,395 395,785 785,1115 1115,1310 1310,1520
if I tell the hardware

1722
00:42:31,490 --> 00:42:32,210
0,210 210,300 300,375 375,525 525,720
I want to write four

1723
00:42:32,210 --> 00:42:33,890
0,590 1030,1275 1275,1380 1380,1515 1515,1680
kilobytes and I get back

1724
00:42:33,890 --> 00:42:35,405
0,225 225,890 910,1200 1200,1365 1365,1515
an acknowledgment, yes, I wrote

1725
00:42:35,405 --> 00:42:37,385
0,165 165,785 1015,1415 1555,1815 1815,1980
four kilobytes, then I can

1726
00:42:37,385 --> 00:42:38,230
0,180 180,300 300,405 405,555 555,845
assume that it made it

1727
00:42:38,610 --> 00:42:39,410
0,275 275,410 410,530 530,635 635,800
if I need to write

1728
00:42:39,410 --> 00:42:41,040
0,255 255,980
eight kilobytes.|
|

1729
00:42:41,580 --> 00:42:42,635
0,245 245,485 485,755 755,875 875,1055
And I send that as
然后我将其作为2、4、千字节块向下发送到操作系统和硬件。我可能会写入前4千字节，然后崩溃，然后再回来。然后，二楼的夜总会终于成功了。

1730
00:42:42,635 --> 00:42:44,135
0,270 270,495 495,855 855,1115 1165,1500
two, four, kilobyte blocks down

1731
00:42:44,135 --> 00:42:45,575
0,165 165,285 285,575 1105,1350 1350,1440
to the OS to the

1732
00:42:45,575 --> 00:42:47,375
0,245 1015,1290 1290,1455 1455,1635 1635,1800
hardware. I may write the

1733
00:42:47,375 --> 00:42:48,755
0,210 210,435 435,975 975,1155 1155,1380
first four kilobytes and then

1734
00:42:48,755 --> 00:42:50,600
0,365 1015,1275 1275,1425 1425,1605 1605,1845
crash and then come back.

1735
00:42:50,600 --> 00:42:52,640
0,210 210,470 610,1010 1120,1520 1720,2040
And then the, the second

1736
00:42:52,640 --> 00:42:53,450
0,195 195,315 315,450 450,630 630,810
floor club by did make

1737
00:42:53,450 --> 00:42:54,200
0,290
it.|
|

1738
00:42:54,430 --> 00:42:55,890
0,320 320,455 455,760 1020,1265 1265,1460
There's no guarantee the harbor
不能保证港口不能保证我能在那里以原子方式做到这一点。没什么。

1739
00:42:55,890 --> 00:42:56,715
0,180 180,405 405,615 615,675 675,825
can't guarantee that I can

1740
00:42:56,715 --> 00:42:58,275
0,180 180,330 330,495 495,1145 1285,1560
do that all atomically all

1741
00:42:58,275 --> 00:42:59,360
0,135 135,395
there. Nothing.|
|

1742
00:42:59,430 --> 00:43:00,515
0,260 260,485 485,755 755,905 905,1085
And so because of this,
正因为如此，我们不得不在数据库系统中做很多其他额外的工作来处理这一问题。

1743
00:43:00,515 --> 00:43:01,205
0,195 195,270 270,405 405,555 555,690
we have to do much

1744
00:43:01,205 --> 00:43:02,360
0,195 195,480 480,795 795,1020 1020,1155
other extra stuff inside our

1745
00:43:02,360 --> 00:43:03,980
0,195 195,530 790,1190 1210,1485 1485,1620
database system to deal with

1746
00:43:03,980 --> 00:43:05,060
0,260
that.|
|

1747
00:43:05,895 --> 00:43:06,500
0,60 60,150 150,240 240,345 345,605
We'll get to that later.|
我们稍后再谈这个。|

1748
00:43:07,430 --> 00:43:08,740
0,260 260,515 515,830 830,1100 1100,1310
And then above that, above
然后在这上面，在哈佛大学上面。现在，操作系统将拥有自己的页面概念。

1749
00:43:08,740 --> 00:43:09,520
0,120 120,300 300,510 510,720 720,780
the Harvard. Now that's going

1750
00:43:09,520 --> 00:43:10,855
0,60 60,290 640,960 960,1170 1170,1335
to be the operating system

1751
00:43:10,855 --> 00:43:11,455
0,120 120,195 195,240 240,390 390,600
is going to have its

1752
00:43:11,455 --> 00:43:12,330
0,150 150,345 345,510 510,615 615,875
own notion of a page.|
|

1753
00:43:13,170 --> 00:43:14,240
0,245 245,365 365,620 620,830 830,1070
And in Linux, by default,
而在Linux中，默认情况下，这是4千字节。同样，这就像是将硬件上的东西映射到虚拟内存中的东西。

1754
00:43:14,240 --> 00:43:16,925
0,150 150,285 285,450 450,1100 2380,2685
this is four kilobytes. And

1755
00:43:16,925 --> 00:43:18,110
0,180 180,315 315,450 450,660 660,1185
again, this is like mapping

1756
00:43:18,110 --> 00:43:19,000
0,240 240,465 465,525 525,630 630,890
something that's on the hardware

1757
00:43:19,200 --> 00:43:20,810
0,400 600,905 905,1220 1220,1415 1415,1610
to something that's in virtual

1758
00:43:20,810 --> 00:43:21,800
0,320
memory.|
|

1759
00:43:22,200 --> 00:43:25,055
0,400 420,820 1320,1720 2100,2390 2390,2855
Now, in in X 64
现在，在X64中，它们也支持两种不同的模式，也就是所谓的大页面，所以你可以得到页面大小，实际上是2MB和1G。再一次，硬件不能保证它能做到。它可以写出来。

1760
00:43:25,055 --> 00:43:26,165
0,210 210,405 405,695 715,960 960,1110
they also support two different

1761
00:43:26,165 --> 00:43:28,385
0,495 495,815 1225,1530 1530,1835 1945,2220
modes, or huge pages as

1762
00:43:28,385 --> 00:43:29,570
0,210 210,455 805,1035 1035,1095 1095,1185
they're called, so you can

1763
00:43:29,570 --> 00:43:30,575
0,180 180,360 360,630 630,870 870,1005
get page sizes, actually two

1764
00:43:30,575 --> 00:43:32,120
0,405 405,510 510,660 660,1235 1255,1545
megabytes and one gigabyte. And

1765
00:43:32,120 --> 00:43:33,250
0,195 195,375 375,585 585,885 885,1130
again, the hardware can't guarantee

1766
00:43:33,300 --> 00:43:34,040
0,245 245,350 350,485 485,620 620,740
that it can. It can

1767
00:43:34,040 --> 00:43:34,980
0,135 135,410
write out.|
|

1768
00:43:34,990 --> 00:43:36,915
0,290 290,620 620,1210 1290,1610 1610,1925
Four kilobytes atomically is just
4千字节的原子性只是为了减少操作系统对其放入内存的页面所做的簿记量。

1769
00:43:36,915 --> 00:43:37,770
0,300 300,495 495,630 630,720 720,855
to reduce the amount of

1770
00:43:37,770 --> 00:43:39,110
0,510 510,705 705,870 870,1050 1050,1340
bookkeeping that the OS does

1771
00:43:39,700 --> 00:43:40,935
0,350 350,560 560,820 870,1130 1130,1235
for the pages that it

1772
00:43:40,935 --> 00:43:42,240
0,135 135,315 315,605
brings into memory.|
|

1773
00:43:43,160 --> 00:43:44,290
0,245 245,350 350,575 575,860 860,1130
And then with inside that
然后，在它的内部和上面，数据库系统也将拥有自己的页面概念。

1774
00:43:44,290 --> 00:43:46,075
0,330 330,600 600,890 1300,1560 1560,1785
now above that, the database

1775
00:43:46,075 --> 00:43:46,645
0,255 255,390 390,450 450,495 495,570
system is going to have

1776
00:43:46,645 --> 00:43:47,305
0,105 105,240 240,420 420,555 555,660
its own notion of a

1777
00:43:47,305 --> 00:43:48,500
0,150 150,300 300,575
page as well.|
|

1778
00:43:49,070 --> 00:43:50,260
0,400
Right.|
正确的。|

1779
00:43:50,540 --> 00:43:51,655
0,335 335,650 650,890 890,1010 1010,1115
And typically, this is going
通常，这将是512,500，12字节范围内的任何地方。这就是Lightte所做的，我想是32千字节。有些内存最高可达64千字节。

1780
00:43:51,655 --> 00:43:52,675
0,105 105,365 625,855 855,930 930,1020
to be anywhere in the

1781
00:43:52,675 --> 00:43:53,640
0,165 165,375 375,525 525,675 675,965
range of five hundred twelve,

1782
00:43:54,200 --> 00:43:55,690
0,275 275,425 425,605 605,1090 1260,1490
five hundred, twelve bytes. This

1783
00:43:55,690 --> 00:43:57,145
0,75 75,285 285,570 570,830 1120,1455
is what lightte does up

1784
00:43:57,145 --> 00:43:58,570
0,315 315,540 540,675 675,1035 1035,1425
to, I {think32 -} kilobytes.

1785
00:43:58,570 --> 00:43:59,485
0,290 430,690 690,780 780,840 840,915
Some let you go up

1786
00:43:59,485 --> 00:44:01,120
0,180 180,615 615,1115
to 64 kilobytes.|
|

1787
00:44:01,250 --> 00:44:03,805
0,400 1380,1670 1670,1880 1880,2195 2195,2555
Right. And so the page
正确的。因此页面大小将是我们将表示的方式。在哪里找到页面ID是一种表示方式。

1788
00:44:03,805 --> 00:44:05,155
0,365 415,810 810,1050 1050,1140 1140,1350
size is going to be

1789
00:44:05,155 --> 00:44:06,655
0,240 240,465 465,750 750,995 1225,1500
the way we'll represent. Where

1790
00:44:06,655 --> 00:44:09,360
0,165 165,455 1975,2265 2265,2430 2430,2705
to find the page ID

1791
00:44:09,680 --> 00:44:10,650
0,245 245,350 350,545 545,725 725,970
is a way to represent.|
|

1792
00:44:12,030 --> 00:44:13,730
0,365 365,730 870,1175 1175,1400 1400,1700
At what offset in some
对于给定的页面大小，在某个文件中的什么偏移量处，我们可以找到我们要查找的数据吗？

1793
00:44:13,730 --> 00:44:15,740
0,380 1210,1440 1440,1515 1515,1710 1710,2010
file for a given page

1794
00:44:15,740 --> 00:44:17,420
0,350 700,960 960,1110 1110,1400 1420,1680
size, can we find the

1795
00:44:17,420 --> 00:44:18,580
0,255 255,510 510,660 660,825 825,1160
data that we're looking for?|
|

1796
00:44:19,780 --> 00:44:20,745
0,275 275,395 395,485 485,680 680,965
So, okay, this said, most
所以，好的，这就是说，大多数系统在SQL服务器中的默认大小是4千字节，而Postgres的页面大小是8千字节。然后在我的SQL中，对于DB 2之类的内容，它们会上升到16千字节，而企业实际上对于每个表的DB 2，您可以更改页面大小。

1797
00:44:20,745 --> 00:44:21,930
0,255 255,570 570,900 900,1095 1095,1185
systems are the default is

1798
00:44:21,930 --> 00:44:24,090
0,75 75,195 195,345 345,980 1840,2160
going be four kilobytes in

1799
00:44:24,090 --> 00:44:25,740
0,300 300,435 435,600 600,1100 1330,1650
sql server and postgres the

1800
00:44:25,740 --> 00:44:26,625
0,195 195,375 375,600 600,795 795,885
the page size is going

1801
00:44:26,625 --> 00:44:28,050
0,30 30,105 105,255 255,845 1165,1425
to be eight kilobytes. And

1802
00:44:28,050 --> 00:44:29,235
0,195 195,420 420,600 600,960 960,1185
then in my sql they

1803
00:44:29,235 --> 00:44:31,070
0,120 120,255 255,545 925,1260 1260,1835
go up to sixteen kilobytes

1804
00:44:31,270 --> 00:44:32,580
0,400 420,695 695,860 860,1160 1160,1310
for something like DB two

1805
00:44:32,580 --> 00:44:33,735
0,105 105,560 580,840 840,990 990,1155
and enterprises actually for for

1806
00:44:33,735 --> 00:44:35,175
0,270 270,545 745,1020 1020,1185 1185,1440
DB two on a per

1807
00:44:35,175 --> 00:44:36,500
0,300 300,615 615,855 855,1020 1020,1325
table basis, you can change

1808
00:44:36,520 --> 00:44:38,140
0,320 320,500 500,665 665,970
the, the page size.|
|

1809
00:44:39,700 --> 00:44:40,520
0,230 230,350 350,485 485,575 575,820
And I take a guess,
我猜一猜，有没有人猜一猜，为什么一个页面尺寸，一个更大的页面尺寸，可能是一个更好的主意？

1810
00:44:40,810 --> 00:44:41,670
0,305 305,485 485,605 605,680 680,860
would anybody take a guess

1811
00:44:41,670 --> 00:44:43,005
0,345 345,645 645,885 885,1155 1155,1335
why one page size, a

1812
00:44:43,005 --> 00:44:43,830
0,165 165,375 375,585 585,750 750,825
larger page size, might be

1813
00:44:43,830 --> 00:44:45,240
0,75 75,300 300,680
a better idea?|
|

1814
00:44:48,700 --> 00:44:49,260
0,245 245,320 320,410 410,500 500,560
What did I say in
我一开始是怎么说的？我们想要最大化的是什么？

1815
00:44:49,260 --> 00:44:50,025
0,105 105,380 400,630 630,690 690,765
the beginning? What do we

1816
00:44:50,025 --> 00:44:50,810
0,75 75,150 150,225 225,300 300,785
want to try to maximize?|
|

1817
00:44:51,580 --> 00:44:53,590
0,615 615,825 825,1080 1080,1430 1690,2010
Sequentialis correct, yes. So if
顺序法是正确的，是的。所以，如果我现在有，如果我在磁盘上组织，16kil字节的块。

1818
00:44:53,590 --> 00:44:56,170
0,225 225,480 480,830 2080,2325 2325,2580
I now have, if I'm

1819
00:44:56,170 --> 00:44:58,045
0,300 300,525 525,1100 1210,1605 1605,1875
organizing on disk, sixteen kil

1820
00:44:58,045 --> 00:44:59,480
0,210 210,485
byte blocks.|
|

1821
00:44:59,480 --> 00:45:00,665
0,320 400,675 675,825 825,960 960,1185
And I need to read
我需要读取16千字节的数据。然后在数据库系统中对我们的调度程序进行一次调用，该调用对操作系统进行一次调用以获取连续的16千字节。

1822
00:45:00,665 --> 00:45:02,840
0,345 345,795 795,885 885,1145 1825,2175
sixteen kilobytes of data. Then

1823
00:45:02,840 --> 00:45:05,120
0,315 315,590 820,1220 1570,1950 1950,2280
it's one one call to

1824
00:45:05,120 --> 00:45:07,600
0,300 300,650 1210,1815 1815,2030 2080,2480
to our dispatcher in in

1825
00:45:08,070 --> 00:45:09,470
0,260 260,455 455,790 990,1250 1250,1400
the database system that makes

1826
00:45:09,470 --> 00:45:10,300
0,180 180,315 315,405 405,540 540,830
one call into the OS

1827
00:45:10,470 --> 00:45:12,755
0,260 260,455 455,790 900,1690 1950,2285
to go grab contiguous sixteen

1828
00:45:12,755 --> 00:45:13,940
0,665
kilobytes.|
|

1829
00:45:14,320 --> 00:45:15,480
0,275 275,455 455,605 605,845 845,1160
If I'm using four kilobyte
如果我使用4千字节的页面，那么我必须进行单独的调用或进行单独的查找，以便在可能随机的位置获取数据。

1830
00:45:15,480 --> 00:45:16,170
0,210 210,405 405,510 510,600 600,690
pages, then I got to

1831
00:45:16,170 --> 00:45:18,975
0,210 210,525 525,890 2200,2565 2565,2805
make separate calls or do

1832
00:45:18,975 --> 00:45:19,815
0,180 180,525 525,600 600,720 720,840
separate lookups to go get

1833
00:45:19,815 --> 00:45:21,240
0,105 105,285 285,605 805,1125 1125,1425
the data in potentially random

1834
00:45:21,240 --> 00:45:22,440
0,380
locations.|
|

1835
00:45:23,170 --> 00:45:24,525
0,245 245,455 455,850 870,1175 1175,1355
And there's, there's sis calls
还有，你可以对操作系统和设备本身进行一些SIS调用，当你分配你想要的数据时，你可以像预分配一个数据区，比如给我分配一个10兆字节的数据块，然后数据系统可以把这10兆字节的数据块分成，你知道的，8千字节块或任何它想要的块大小。是?

1836
00:45:24,525 --> 00:45:25,260
0,150 150,255 255,435 435,600 600,735
you can make to the

1837
00:45:25,260 --> 00:45:27,030
0,290 820,1185 1185,1455 1455,1620 1620,1770
OS are to, to the

1838
00:45:27,030 --> 00:45:28,320
0,270 270,650 790,1065 1065,1185 1185,1290
device itself that when you

1839
00:45:28,320 --> 00:45:29,535
0,435 435,705 705,930 930,1050 1050,1215
allocate data that you want

1840
00:45:29,535 --> 00:45:31,545
0,225 225,390 390,635 715,1410 1410,2010
things to be ideally contigously

1841
00:45:31,545 --> 00:45:32,490
0,315 315,525 525,615 615,780 780,945
aligned, you can like pre

1842
00:45:32,490 --> 00:45:33,800
0,330 330,540 540,825 825,1035 1035,1310
allocate an extent to say

1843
00:45:34,300 --> 00:45:36,225
0,575 575,880 900,1205 1205,1415 1415,1925
allocate me a ten megabyte

1844
00:45:36,225 --> 00:45:37,580
0,150 150,285 285,545 835,1095 1095,1355
block of data and then

1845
00:45:38,470 --> 00:45:39,435
0,260 260,380 380,545 545,740 740,965
then the data system can

1846
00:45:39,435 --> 00:45:40,440
0,255 255,465 465,600 600,840 840,1005
divide that ten megyte block

1847
00:45:40,440 --> 00:45:42,420
0,290 850,1095 1095,1335 1335,1620 1620,1980
into, you know, eight kilobyte

1848
00:45:42,420 --> 00:45:43,950
0,225 225,375 375,680 1090,1380 1380,1530
chunks or whatever block size

1849
00:45:43,950 --> 00:45:47,840
0,105 105,350 370,770
it wants. Yes?|
|

1850
00:45:47,840 --> 00:45:49,240
0,680
Don't.|
别。|

1851
00:45:49,240 --> 00:45:49,975
0,180 180,315 315,405 405,525 525,735
Right, so then he says,
是的，然后他说，他是对的。这难道不意味着高额薪酬会让权利变得更昂贵吗？因为现在，如果我只需要写入1千字节，但我存储为16千字节页，我就必须全部写入。一万六千英尺绝对是。所以这是一个很好的观点。这是我整个学期都会说的话。啊，它，我的意思是那是数据库，一般的计算机科学。天下没有免费的午餐。每一种情况和不同的情况都有利弊。一种方法可能比另一种更好。

1852
00:45:49,975 --> 00:45:51,805
0,195 195,405 405,665 1345,1725 1725,1830
and he's correct. Doesn't this

1853
00:45:51,805 --> 00:45:52,855
0,135 135,270 270,495 495,735 735,1050
mean that large pay sizes

1854
00:45:52,855 --> 00:45:54,430
0,375 375,690 690,945 945,1265 1285,1575
make rights more expensive? Because

1855
00:45:54,430 --> 00:45:55,180
0,210 210,375 375,480 480,615 615,750
now if I only have

1856
00:45:55,180 --> 00:45:56,695
0,120 120,360 360,630 630,1250 1270,1515
to write one kilobyte but

1857
00:45:56,695 --> 00:45:57,895
0,135 135,285 285,495 495,780 780,1200
I'm storing as sixteen kilobyte

1858
00:45:57,895 --> 00:45:58,570
0,195 195,405 405,510 510,585 585,675
page, I got to write

1859
00:45:58,570 --> 00:46:00,115
0,105 105,240 240,465 465,920 1240,1545
it all. Sixteen kiloby absolutely

1860
00:46:00,115 --> 00:46:01,195
0,305 505,795 795,915 915,990 990,1080
yes. So this is a

1861
00:46:01,195 --> 00:46:02,440
0,135 135,425 685,945 945,1065 1065,1245
good point. This is something

1862
00:46:02,440 --> 00:46:03,370
0,195 195,345 345,540 540,765 765,930
I would say throughout the

1863
00:46:03,370 --> 00:46:05,905
0,165 165,500 1000,1400 2020,2400 2400,2535
entire semester. Ah, its, I

1864
00:46:05,905 --> 00:46:07,270
0,105 105,360 360,525 525,1080 1080,1365
mean that's for databases, computer

1865
00:46:07,270 --> 00:46:08,410
0,165 165,285 285,530 640,990 990,1140
science in general. There's no

1866
00:46:08,410 --> 00:46:10,015
0,165 165,440 730,1170 1170,1425 1425,1605
free lunch. There's pros and

1867
00:46:10,015 --> 00:46:11,320
0,275 685,930 930,1035 1035,1140 1140,1305
cons to each of these

1868
00:46:11,320 --> 00:46:13,690
0,270 270,620 640,1040 1660,2060 2080,2370
and different situations. One approach

1869
00:46:13,690 --> 00:46:14,430
0,135 135,225 225,360 360,495 495,740
might be better than another.|
|

1870
00:46:14,940 --> 00:46:16,185
0,225 225,465 465,795 795,960 960,1245
If my workload is entirely
如果我的工作负载完全是读的，只要我从来不写任何东西，那么是的，我想要大的页面大小，假设我正在进行大的顺序扫描。如果我写了很多东西，也许我想要更小的东西，但合适的数量是多少？

1871
00:46:16,185 --> 00:46:17,190
0,240 240,465 465,660 660,795 795,1005
read, only if I never

1872
00:46:17,190 --> 00:46:18,435
0,315 315,710 730,990 990,1125 1125,1245
write anything, then yeah, I

1873
00:46:18,435 --> 00:46:19,680
0,120 120,315 315,510 510,815 955,1245
want large page sizes, assuming

1874
00:46:19,680 --> 00:46:20,990
0,180 180,405 405,690 690,1020 1020,1310
I'm doing large sequential scans.

1875
00:46:21,310 --> 00:46:22,080
0,245 245,440 440,545 545,650 650,770
If I'm doing much of

1876
00:46:22,080 --> 00:46:23,010
0,255 255,540 540,690 690,795 795,930
writes, then maybe I want

1877
00:46:23,010 --> 00:46:24,360
0,240 240,590 850,1110 1110,1245 1245,1350
something smaller, but what the

1878
00:46:24,360 --> 00:46:25,640
0,120 120,285 285,560
right amount is?|
|

1879
00:46:26,060 --> 00:46:27,655
0,400 930,1220 1220,1385 1385,1505 1505,1595
Depends, of course, you would
当然，这取决于你是否会有某种读过的酷，如果你有一个小的页面大小，类似的。因此，如果你在千字节中查找多个字节，那么它的效率是如此之高。

1880
00:46:27,655 --> 00:46:28,525
0,120 120,255 255,360 360,540 540,870
have some kind of readed

1881
00:46:28,525 --> 00:46:29,470
0,240 240,570 570,810 810,885 885,945
cool, similar if you had

1882
00:46:29,470 --> 00:46:30,505
0,120 120,315 315,540 540,795 795,1035
a small page size. So

1883
00:46:30,505 --> 00:46:31,645
0,305 355,615 615,780 780,915 915,1140
effectively if you look many

1884
00:46:31,645 --> 00:46:32,940
0,180 180,285 285,875
for a kilobyte.|
|

1885
00:46:33,960 --> 00:46:35,405
0,305 305,470 470,620 620,875 875,1445
Seven to say sixteen kilobytes
7，相当于16千字节的芦苇。

1886
00:46:35,405 --> 00:46:36,300
0,150 150,575
of reed.|
|

1887
00:46:36,800 --> 00:46:38,120
0,270 270,465 465,720 720,1070
Head food system call.|
食品系统召唤负责人。|

1888
00:46:38,120 --> 00:46:38,945
0,120 120,255 360,480 480,645 645,825
And then you'll still have
然后你仍将拥有权利。

1889
00:46:38,945 --> 00:46:40,000
0,195 195,485
the right.|
|

1890
00:46:40,380 --> 00:46:41,570
0,290 290,440 440,710 710,965 965,1190
So if you're writing, you
所以，如果你在写作，你仍然有原子声明。

1891
00:46:41,570 --> 00:46:47,480
0,180 180,465 465,1160 4540,4940
still have atomic statement.|
|

1892
00:46:47,900 --> 00:46:49,225
0,290 290,485 485,665 665,905 905,1325
If I do, sixteen kilobyte
如果我这样做了，16千字节的读取，我仍然使用4千字节的数据，假设16千字节是连续的。

1893
00:46:49,225 --> 00:46:50,530
0,395 565,810 810,960 960,1080 1080,1305
reads and I'm still using

1894
00:46:50,530 --> 00:46:52,990
0,255 255,870 870,1155 1155,1460 2140,2460
four kilobytes of data, assuming

1895
00:46:52,990 --> 00:46:54,630
0,210 210,450 450,885 885,1005 1005,1640
that sixteen kilobytes is contiguous.|
|

1896
00:46:55,300 --> 00:46:56,380
0,165 165,450 450,585 585,810 810,1080
Then can't I go make
那么我不能去打一个，你知道的，去打一个电话来获得连续的16K字节吗？然后，如果我在四个字节内找到了合适的人，我还可以把它们写出来吗？绝对是的。这就是我之前所说的。然后，我们将选择尝试写出该数据的算法或方法。

1897
00:46:56,380 --> 00:46:58,705
0,350 1330,1560 1560,1740 1740,2010 2010,2325
a, you know, go make

1898
00:46:58,705 --> 00:46:59,665
0,285 285,510 510,720 720,825 825,960
a single call to get

1899
00:46:59,665 --> 00:47:00,870
0,240 240,585 585,645 645,705 705,1205
sixteen kilobytes that are contiguous.

1900
00:47:01,250 --> 00:47:01,855
0,260 260,365 365,455 455,530 530,605
And then if I had

1901
00:47:01,855 --> 00:47:04,510
0,135 135,425 505,905 1495,1895 2065,2655
the right individual within fourbytes,

1902
00:47:04,510 --> 00:47:05,035
0,105 105,195 195,300 300,420 420,525
I can still write those

1903
00:47:05,035 --> 00:47:06,670
0,245 535,840 840,1145 1315,1560 1560,1635
out? Absolutely yes. And this

1904
00:47:06,670 --> 00:47:07,000
0,45 45,90 90,150 150,225 225,330
is what I was saying

1905
00:47:07,000 --> 00:47:08,190
0,240 240,480 480,600 600,825 825,1190
before. We will then choose

1906
00:47:08,210 --> 00:47:09,670
0,380 380,545 545,815 815,1175 1175,1460
algorithms or methods that that

1907
00:47:09,670 --> 00:47:10,585
0,180 180,330 330,525 525,705 705,915
try to write that data

1908
00:47:10,585 --> 00:47:11,680
0,335
out.|
|

1909
00:47:12,140 --> 00:47:13,210
0,260 260,365 365,470 470,605 605,1070
So that it is contiguous
因此它是连续的，这样我们就可以进行这些提取。

1910
00:47:13,210 --> 00:47:14,155
0,165 165,315 315,465 465,645 645,945
so that we can do

1911
00:47:14,155 --> 00:47:15,500
0,285 285,755
those fetches.|
|

1912
00:47:15,500 --> 00:47:17,600
0,320 1210,1500 1500,1755 1755,1980 1980,2100
Right. And again, this is
正确的。同样，这是数据系统可以为我们做的事情，因为我们知道查询是什么。我们知道您可能要阅读的数据，因此我们可以为您提前阅读，并尝试在您实际需要之前获取它们。现在，操作系统也可以使用预取来实现这一点，但它只能预取在两个方向上连续的内容。我认为在Linux中是可以的，但如果我必须优先获取不连续的东西，那么它就不能这样做。它不能为我做到这一点。

1913
00:47:17,600 --> 00:47:18,500
0,165 165,315 315,480 480,720 720,900
something a data system can

1914
00:47:18,500 --> 00:47:19,310
0,150 150,285 285,450 450,645 645,810
do for us because we

1915
00:47:19,310 --> 00:47:20,240
0,210 210,390 390,510 510,720 720,930
know what the query is.

1916
00:47:20,240 --> 00:47:21,215
0,165 165,345 345,540 540,765 765,975
We know what data you're

1917
00:47:21,215 --> 00:47:22,340
0,30 30,105 105,315 315,665 865,1125
going to potentially read, and

1918
00:47:22,340 --> 00:47:23,015
0,90 90,150 150,255 255,450 450,675
so we can read ahead

1919
00:47:23,015 --> 00:47:23,660
0,195 195,330 330,435 435,555 555,645
for you and try to

1920
00:47:23,660 --> 00:47:26,135
0,165 165,390 390,710 970,1370 2140,2475
fetch things that are before

1921
00:47:26,135 --> 00:47:27,605
0,240 240,405 405,540 540,815 1195,1470
you actually need them. Now

1922
00:47:27,605 --> 00:47:28,475
0,195 195,420 420,570 570,675 675,870
the OS can do that

1923
00:47:28,475 --> 00:47:29,680
0,300 300,525 525,810 810,930 930,1205
with pref fetching as well,

1924
00:47:30,060 --> 00:47:31,025
0,245 245,350 350,455 455,605 605,965
but it can only prefetch

1925
00:47:31,025 --> 00:47:33,470
0,180 180,285 285,360 360,965 2185,2445
things that are contiguous in

1926
00:47:33,470 --> 00:47:34,430
0,165 165,420 420,615 615,780 780,960
both directions. I think in

1927
00:47:34,430 --> 00:47:35,795
0,270 270,560 670,900 900,1035 1035,1365
Linux, yes, but it can't

1928
00:47:35,795 --> 00:47:36,995
0,305 715,960 960,1035 1035,1095 1095,1200
do if I have to

1929
00:47:36,995 --> 00:47:37,955
0,150 150,390 390,600 600,735 735,960
pref fetch things that aren't

1930
00:47:37,955 --> 00:47:38,930
0,435 435,585 585,765 765,840 840,975
contiguous. It can't do that

1931
00:47:38,930 --> 00:47:39,620
0,150 150,410
for me.|
|

1932
00:47:42,580 --> 00:47:43,305
0,215 215,275 275,410 410,590 590,725
So this is clear. So
因此，这一点很清楚。这里还有一些页面ID，我们马上就会看到。它是如何被使用的，这将允许我们在第一页，第三页，这里是找到它的地方。

1933
00:47:43,305 --> 00:47:44,085
0,135 135,300 300,405 405,570 570,780
again there be some page

1934
00:47:44,085 --> 00:47:45,285
0,305 655,900 900,1035 1035,1110 1110,1200
ID and we'll see this

1935
00:47:45,285 --> 00:47:45,915
0,90 90,180 180,330 330,510 510,630
in a second. How this

1936
00:47:45,915 --> 00:47:47,055
0,105 105,255 255,545 775,1095 1095,1140
is being used that's going

1937
00:47:47,055 --> 00:47:49,260
0,60 60,150 150,395 685,1085 1915,2205
to allow us page page

1938
00:47:49,260 --> 00:47:50,355
0,150 150,285 285,560 670,1020 1020,1095
one, o three, here's where

1939
00:47:50,355 --> 00:47:51,440
0,75 75,165 165,300 300,575
to go find it.|
|

1940
00:47:54,630 --> 00:47:56,040
0,335 335,670
Right, so.|
对，所以。|

1941
00:47:56,350 --> 00:47:56,970
0,260 260,425 425,455 455,515 515,620
Now we've got to talk
现在，我们必须讨论如何实际跟踪页面ID到位置的映射，EM，这将是数据中心如何组织及其页面的最大区别之一。再说一次，没有，我不是说一种方式比另一种方式更好。我将描述热文件方法是最常见的方法，但当然还有许多其他系统正在做不同的事情。

1942
00:47:56,970 --> 00:47:57,720
0,150 150,330 330,450 450,585 585,750
about how do we actually

1943
00:47:57,720 --> 00:47:59,730
0,150 150,360 360,680 1270,1590 1590,2010
keep track of that mapping

1944
00:47:59,730 --> 00:48:01,400
0,150 150,330 330,810 810,1130 1270,1670
of page IDs to locations,

1945
00:48:02,170 --> 00:48:04,845
0,400 990,1385 1385,1870 2310,2570 2570,2675
EM and there this would

1946
00:48:04,845 --> 00:48:05,325
0,120 120,225 225,285 285,360 360,480
be one of the big

1947
00:48:05,325 --> 00:48:06,450
0,275 295,585 585,810 810,990 990,1125
differences of how the data

1948
00:48:06,450 --> 00:48:07,700
0,165 165,270 270,450 450,855 855,1250
centers are going organize the

1949
00:48:08,020 --> 00:48:10,650
0,245 245,365 365,640 2100,2390 2390,2630
and their pages. And again,

1950
00:48:10,650 --> 00:48:11,490
0,285 285,405 405,555 555,660 660,840
there's not, I'm not saying

1951
00:48:11,490 --> 00:48:12,330
0,195 195,360 360,480 480,645 645,840
one way is better than

1952
00:48:12,330 --> 00:48:14,250
0,290 550,930 930,1250 1510,1770 1770,1920
another. I'll describe the heat

1953
00:48:14,250 --> 00:48:15,135
0,240 240,480 480,645 645,750 750,885
file approach is the most

1954
00:48:15,135 --> 00:48:17,670
0,255 255,605 1825,2130 2130,2355 2355,2535
common one, but certainly a

1955
00:48:17,670 --> 00:48:18,540
0,120 120,210 210,345 345,630 630,870
bunch of other systems are

1956
00:48:18,540 --> 00:48:20,080
0,225 225,510 510,830
doing different things.|
|

1957
00:48:20,630 --> 00:48:21,355
0,245 245,305 305,395 395,650 650,725
And there are tradeoffs for
所有这些都需要权衡取舍。

1958
00:48:21,355 --> 00:48:22,640
0,120 120,270 270,545
all these ones.|
|

1959
00:48:23,190 --> 00:48:25,010
0,400 900,1190 1190,1430 1430,1685 1685,1820
So at this point, where
因此，在这一点上，我们正在讨论的地方，我们不需要知道任何关于我们的页面内部的内容。就像，再说一次，我们不关心它是指数还是TWOLS。我们只需要知道对于给定的页面，我如何找到它，以及如何跟踪我实际拥有的页面。

1960
00:48:25,010 --> 00:48:26,360
0,165 165,255 255,450 450,800 1090,1350
we're in our discussion, we

1961
00:48:26,360 --> 00:48:27,110
0,150 150,240 240,360 360,555 555,750
don't need to know anything

1962
00:48:27,110 --> 00:48:27,740
0,120 120,315 315,450 450,540 540,630
about what's inside of our

1963
00:48:27,740 --> 00:48:29,015
0,260 460,780 780,990 990,1125 1125,1275
pages. Like, again, we don't

1964
00:48:29,015 --> 00:48:30,230
0,90 90,335 445,795 795,1095 1095,1215
care whether it's indexes or

1965
00:48:30,230 --> 00:48:31,400
0,380 580,825 825,915 915,1035 1035,1170
twoils. We just need to

1966
00:48:31,400 --> 00:48:32,320
0,210 210,375 375,435 435,600 600,920
know for a given page,

1967
00:48:33,090 --> 00:48:33,800
0,245 245,320 320,395 395,530 530,710
how do I go find

1968
00:48:33,800 --> 00:48:34,595
0,270 270,495 495,585 585,675 675,795
it and how to keep

1969
00:48:34,595 --> 00:48:35,480
0,150 150,270 270,390 390,615 615,885
track of what pages I

1970
00:48:35,480 --> 00:48:36,520
0,180 180,440
actually have.|
|

1971
00:48:37,430 --> 00:48:38,970
0,400 570,860 860,1085 1085,1280 1280,1540
So tree falls is basically
所以树的倒下基本上就是你储存的。

1972
00:48:39,020 --> 00:48:41,180
0,305 305,610
you store.|
|

1973
00:48:41,380 --> 00:48:43,275
0,260 260,410 410,605 605,910 1620,1895
You can store the sort
您可以将排序存储在叶节点中。您可以对实际页面本身进行排序，也可以使用哈希表。I是一个按顺序排序的文件。这是类似于七十S的东西，我的SQL默认为这样做。这不再那么常见了，但这也是另一种跟踪事物的方式，然后使用哈希表对文件进行哈希处理。他归档的Bunch查找将是最常见的一种。

1974
00:48:43,275 --> 00:48:44,115
0,120 120,225 225,405 405,765 765,840
in the leaf nodes. You

1975
00:48:44,115 --> 00:48:44,840
0,75 75,195 195,345 345,480 480,725
can sort the actual pages

1976
00:48:44,860 --> 00:48:46,425
0,400 840,1190 1190,1385 1385,1475 1475,1565
themselves or you can have

1977
00:48:46,425 --> 00:48:48,225
0,90 90,300 300,575 955,1355 1465,1800
a hash table. I is

1978
00:48:48,225 --> 00:48:50,130
0,225 225,515 1075,1350 1350,1665 1665,1905
a am or sequential sorted

1979
00:48:50,130 --> 00:48:51,600
0,260 640,915 915,1050 1050,1245 1245,1470
files. This is something from

1980
00:48:51,600 --> 00:48:53,025
0,180 180,360 360,585 585,920 1120,1425
like the seventy s, my

1981
00:48:53,025 --> 00:48:53,970
0,285 285,405 405,645 645,855 855,945
sql used to do this

1982
00:48:53,970 --> 00:48:55,290
0,180 180,500 640,975 975,1110 1110,1320
by default. It's not that

1983
00:48:55,290 --> 00:48:56,895
0,320 370,770 1000,1305 1305,1455 1455,1605
common anymore, but again it's

1984
00:48:56,895 --> 00:48:57,600
0,150 150,315 315,435 435,540 540,705
another way to sort of

1985
00:48:57,600 --> 00:48:58,545
0,195 195,330 330,435 435,680 700,945
keep track of things and

1986
00:48:58,545 --> 00:48:59,715
0,105 105,420 420,615 615,855 855,1170
then hashing file is going

1987
00:48:59,715 --> 00:49:00,495
0,300 300,450 450,600 600,675 675,780
use the hash table. Bunch

1988
00:49:00,495 --> 00:49:01,695
0,455 505,810 810,990 990,1125 1125,1200
lookups he files is going

1989
00:49:01,695 --> 00:49:02,385
0,30 30,105 105,270 270,465 465,690
to be the most common

1990
00:49:02,385 --> 00:49:03,120
0,335
one.|
|

1991
00:49:03,910 --> 00:49:05,570
0,335 335,530 530,695 695,1000 1260,1660
But these other methods exist,
但是这些其他方法是存在的，对于日志结构的内容，我们将看到下一个类。

1992
00:49:06,010 --> 00:49:06,855
0,260 260,395 395,500 500,605 605,845
and then for the log

1993
00:49:06,855 --> 00:49:07,755
0,300 300,510 510,690 690,780 780,900
structure stuff, we'll see that

1994
00:49:07,755 --> 00:49:10,140
0,195 195,515
next class.|
|

1995
00:49:12,700 --> 00:49:14,340
0,400 660,1115 1115,1235 1235,1415 1415,1640
The directory is really keeping
这个名录真的在跟踪。你仍然想要跟踪东西在哪里，因为你不在乎。我们不在乎书页里有什么。

1996
00:49:14,340 --> 00:49:15,440
0,320 370,645 645,765 765,855 855,1100
track. You still want to

1997
00:49:15,940 --> 00:49:16,875
0,275 275,425 425,620 620,800 800,935
keep track of where things

1998
00:49:16,875 --> 00:49:19,200
0,275 1195,1485 1485,1710 1710,1985 2065,2325
are because don't care. We

1999
00:49:19,200 --> 00:49:20,310
0,165 165,410 490,855 855,990 990,1110
don't care what's inside the

2000
00:49:20,310 --> 00:49:22,120
0,260
pages.|
|

2001
00:49:22,840 --> 00:49:24,015
0,320 320,530 530,710 710,965 965,1175
Right. So he file is
正确的。因此，文件将是一个无序页面的集合，我们的工具将以随机顺序存储在其中。同样，关系模型允许我们这样做，因为关系模型没有定义，也没有说数据不必以确切的顺序指定。

2002
00:49:24,015 --> 00:49:25,710
0,75 75,135 135,365 1135,1455 1455,1695
going to be a collection

2003
00:49:25,710 --> 00:49:27,990
0,240 240,690 690,950 1870,2130 2130,2280
of unordered pages where our

2004
00:49:27,990 --> 00:49:28,650
0,180 180,315 315,405 405,540 540,660
tools will be stored in

2005
00:49:28,650 --> 00:49:29,760
0,165 165,470 640,900 900,1020 1020,1110
random order. And again, the

2006
00:49:29,760 --> 00:49:30,810
0,255 255,525 525,765 765,930 930,1050
relational model allows us to

2007
00:49:30,810 --> 00:49:32,055
0,135 135,410 430,825 825,1050 1050,1245
do that because the relational

2008
00:49:32,055 --> 00:49:34,020
0,195 195,510 510,815 955,1445 1645,1965
model doesn't define, doesn't says,

2009
00:49:34,020 --> 00:49:34,860
0,165 165,270 270,450 450,735 735,840
that the data doesn't have

2010
00:49:34,860 --> 00:49:36,660
0,120 120,380 670,1185 1185,1485 1485,1800
to be specified in exact

2011
00:49:36,660 --> 00:49:37,660
0,320
order.|
|

2012
00:49:37,700 --> 00:49:39,240
0,305 305,590 590,875 875,1235 1235,1540
Some systems might presort them
一些系统可能会为其他效果预置它们以使操作更快，但关系模型不要求您这样做。

2013
00:49:39,950 --> 00:49:41,215
0,245 245,365 365,640 690,1055 1055,1265
to make things faster for

2014
00:49:41,215 --> 00:49:43,825
0,245 745,1065 1065,1385 2125,2385 2385,2610
other effects, but the relational

2015
00:49:43,825 --> 00:49:44,950
0,255 255,690 690,900 900,1020 1020,1125
model doesn't require you to

2016
00:49:44,950 --> 00:49:46,000
0,120 120,380
do that.|
|

2017
00:49:46,250 --> 00:49:47,470
0,260 260,395 395,515 515,695 695,1220
And so the only API
因此，我们的存储管理器中支持堆文件的唯一API基本上是创建页面、获取页面、写入页面、删除页面，然后是迭代器API，它允许按顺序读取页面，以获得我们拥有的所有页面ID的列表，并对其进行读取。

2018
00:49:47,470 --> 00:49:48,760
0,210 210,450 450,660 660,920 970,1290
we need in our storage

2019
00:49:48,760 --> 00:49:50,110
0,320 580,900 900,1095 1095,1200 1200,1350
manager to support a heap

2020
00:49:50,110 --> 00:49:51,805
0,260 580,930 930,1245 1245,1500 1500,1695
file is basically to create

2021
00:49:51,805 --> 00:49:53,725
0,305 535,795 795,915 915,1175 1615,1920
pages, get a page, write

2022
00:49:53,725 --> 00:49:55,420
0,120 120,210 210,485 1285,1560 1560,1695
to a page, delete a

2023
00:49:55,420 --> 00:49:57,745
0,260 640,930 930,1220 1570,1875 1875,2325
page, and then an iterator

2024
00:49:57,745 --> 00:49:59,815
0,450 450,600 600,875 1045,1445 1705,2070
API that allows to to

2025
00:49:59,815 --> 00:50:01,930
0,540 540,810 810,1175 1765,2010 2010,2115
sequentially read pages to get

2026
00:50:01,930 --> 00:50:02,545
0,90 90,195 195,315 315,465 465,615
the list of all the

2027
00:50:02,545 --> 00:50:03,415
0,120 120,330 330,525 525,630 630,870
page ID that we have

2028
00:50:03,415 --> 00:50:04,700
0,255 255,375 375,525 525,815
and read over them.|
|

2029
00:50:05,410 --> 00:50:07,080
0,400
So.|
所以。|

2030
00:50:07,120 --> 00:50:08,235
0,395 395,650 650,785 785,950 950,1115
Managing this heat file is
如果您的数据库是单个文件(如senteeb或在SQL lite中)，则管理此热点文件真的很容易。

2031
00:50:08,235 --> 00:50:09,600
0,165 165,375 375,555 555,815 1075,1365
really easy to do if

2032
00:50:09,600 --> 00:50:10,545
0,150 150,375 375,600 600,735 735,945
your database is a single

2033
00:50:10,545 --> 00:50:12,135
0,330 330,600 600,1230 1230,1410 1410,1590
file, like inducteeb or like

2034
00:50:12,135 --> 00:50:14,380
0,305 325,725 835,1170 1170,1445
in in sql lite.|
|

2035
00:50:14,420 --> 00:50:15,355
0,335 335,530 530,680 680,815 815,935
Right, because all you need
对，因为要找到给定的页面，您只需知道页码是多少。你知道页面的大小，因为它们都必须是相同的大小。现在你只需要做一个简单的算术运算，比如取我要找的任何ID，乘以页面的大小，然后我就可以跳到文件中的任何偏移量。

2036
00:50:15,355 --> 00:50:16,225
0,120 120,300 300,525 525,720 720,870
to do to find a

2037
00:50:16,225 --> 00:50:18,010
0,165 165,485 985,1320 1320,1575 1575,1785
given page is just know

2038
00:50:18,010 --> 00:50:18,835
0,165 165,315 315,450 450,615 615,825
what pa the page number

2039
00:50:18,835 --> 00:50:20,095
0,305 685,945 945,1035 1035,1110 1110,1260
is. You know what the

2040
00:50:20,095 --> 00:50:21,085
0,270 270,465 465,555 555,735 735,990
size of the page is

2041
00:50:21,085 --> 00:50:21,640
0,195 195,315 315,405 405,480 480,555
because they all have to

2042
00:50:21,640 --> 00:50:23,110
0,90 90,210 210,390 390,710 1210,1470
be the same size. And

2043
00:50:23,110 --> 00:50:23,635
0,135 135,255 255,360 360,450 450,525
now you just do a

2044
00:50:23,635 --> 00:50:25,510
0,120 120,675 675,995 1225,1560 1560,1875
simple arithmetic like take whatever

2045
00:50:25,510 --> 00:50:26,730
0,270 270,495 495,720 720,885 885,1220
the ID I'm looking for,

2046
00:50:27,080 --> 00:50:28,975
0,620 620,815 815,1070 1070,1450 1620,1895
multiply it by the the

2047
00:50:28,975 --> 00:50:30,145
0,165 165,285 285,375 375,635 925,1170
size of the page and

2048
00:50:30,145 --> 00:50:30,820
0,90 90,195 195,330 330,510 510,675
then I can jump to

2049
00:50:30,820 --> 00:50:31,705
0,120 120,345 345,585 585,750 750,885
whatever that offset is in

2050
00:50:31,705 --> 00:50:32,580
0,105 105,365
the file.|
|

2051
00:50:32,830 --> 00:50:33,600
0,230 230,305 305,440 440,635 635,770
And I know exactly what
我很清楚我在找什么。

2052
00:50:33,645 --> 00:50:34,680
0,45 45,195 195,515
I'm looking for.|
|

2053
00:50:36,470 --> 00:50:37,390
0,230 230,290 290,380 380,640 660,920
And if you go look
如果你去看看SQL文档，他们，他们谈到，在他们的数据文件的标题中，他们跟踪的所有类型的元数据在这里基本上是如何做到这一点的。

2054
00:50:37,390 --> 00:50:38,590
0,105 105,255 255,510 510,690 690,1200
in the sql like documentation,

2055
00:50:38,590 --> 00:50:39,870
0,330 330,585 585,810 810,1005 1005,1280
they, they talk about how

2056
00:50:40,520 --> 00:50:41,440
0,290 290,440 440,560 560,815 815,920
in, in the header of

2057
00:50:41,440 --> 00:50:42,900
0,150 150,315 315,590 850,1155 1155,1460
their of their data file,

2058
00:50:43,010 --> 00:50:44,530
0,335 335,515 515,725 725,965 965,1520
all sort of the metadata

2059
00:50:44,530 --> 00:50:45,595
0,210 210,330 330,465 465,720 720,1065
they keep track of basically

2060
00:50:45,595 --> 00:50:47,180
0,345 345,615 615,780 780,1055
do this trick here.|
|

2061
00:50:48,570 --> 00:50:49,730
0,320 320,530 530,710 710,995 995,1160
Where things get tricky is
问题变得棘手的是，如果你有多个文件，同样，大多数系统都有多个文件，我的SQL和Oracle都有。

2062
00:50:49,730 --> 00:50:50,585
0,180 180,270 270,345 345,555 555,855
if you have multiple files,

2063
00:50:50,585 --> 00:50:52,010
0,225 225,515 565,870 870,1140 1140,1425
which again, most systems do,

2064
00:50:52,010 --> 00:50:53,090
0,375 375,540 540,690 690,900 900,1080
presres does, my sql does,

2065
00:50:53,090 --> 00:50:54,360
0,330 330,590
Oracle does.|
|

2066
00:50:54,360 --> 00:50:55,110
0,120 120,255 255,465 465,645 645,750
And then now we need
然后现在我们需要一种方法来说明给定的第二页，什么文件，什么文件，什么偏移量有我需要的页。

2067
00:50:55,110 --> 00:50:56,370
0,120 120,300 300,480 480,740 1000,1260
a way to say for

2068
00:50:56,370 --> 00:50:58,245
0,210 210,450 450,660 660,980 1540,1875
given page number two, what

2069
00:50:58,245 --> 00:51:01,290
0,330 330,660 660,2580 2580,2775 2775,3045
file and whatory what file,

2070
00:51:01,290 --> 00:51:02,900
0,330 330,680 910,1200 1200,1350 1350,1610
what offset has the page

2071
00:51:03,610 --> 00:51:05,100
0,365 365,605 605,880
that I need.|
|

2072
00:51:07,240 --> 00:51:08,535
0,400 720,965 965,1085 1085,1205 1205,1295
Right. And this is what
正确的。这就是堆文件页目录可以为我们获得的内容。再说一次，把它想象成一个哈希表，您只是在跟踪它。它是从页面ID到数据文件中的页面的映射。

2073
00:51:08,535 --> 00:51:09,510
0,90 90,255 255,450 450,675 675,975
a heap file page directory

2074
00:51:09,510 --> 00:51:10,400
0,120 120,315 315,525 525,645 645,890
can get get for us.

2075
00:51:10,510 --> 00:51:11,490
0,290 290,440 440,665 665,935 935,980
Again, think of it's like

2076
00:51:11,490 --> 00:51:13,155
0,90 90,330 330,590 1210,1485 1485,1665
a hash table where you're

2077
00:51:13,155 --> 00:51:14,070
0,90 90,270 270,465 465,660 660,915
just keeping track of. It's

2078
00:51:14,070 --> 00:51:15,050
0,330 330,450 450,570 570,705 705,980
mapping from the page ID

2079
00:51:15,160 --> 00:51:17,385
0,400 1050,1450 1560,1820 1820,2030 2030,2225
to to the pages in

2080
00:51:17,385 --> 00:51:18,700
0,105 105,285 285,605
the data file.|
|

2081
00:51:18,850 --> 00:51:20,625
0,275 275,455 455,760 780,1180 1530,1775
And this typically be sort
这通常是一种特殊的文件，或者位于单个数据库文件的头部，或者位于数据库系统和目录内的某个特殊位置。你可以把它想象成一个数据库。当使用数据库时，它是跟踪数据库中的内容的数据库。目录也是其中的一部分。但这就像跟踪物理位置的东西一样。

2082
00:51:20,625 --> 00:51:21,750
0,150 150,420 420,765 765,1005 1005,1125
of special file, either at

2083
00:51:21,750 --> 00:51:23,460
0,135 135,420 420,615 615,920 1450,1710
the header of, of the

2084
00:51:23,460 --> 00:51:24,705
0,150 150,345 345,650 790,1065 1065,1245
single database file or at

2085
00:51:24,705 --> 00:51:26,390
0,300 300,690 690,1085 1135,1410 1410,1685
some special location inside of

2086
00:51:26,770 --> 00:51:27,795
0,245 245,440 440,725 725,905 905,1025
the database system and a

2087
00:51:27,795 --> 00:51:29,355
0,455 985,1230 1230,1335 1335,1455 1455,1560
directory. And you can sort

2088
00:51:29,355 --> 00:51:30,195
0,90 90,240 240,465 465,570 570,840
of think it's a database.

2089
00:51:30,195 --> 00:51:31,515
0,315 315,510 510,785 895,1200 1200,1320
When the database, it's the

2090
00:51:31,515 --> 00:51:32,490
0,270 270,525 525,675 675,840 840,975
database that keeps track of

2091
00:51:32,490 --> 00:51:35,355
0,225 225,360 360,525 525,800 2590,2865
what's in your database. The

2092
00:51:35,355 --> 00:51:36,090
0,315 315,450 450,570 570,645 645,735
catalog is part of that

2093
00:51:36,090 --> 00:51:36,705
0,135 135,285 285,405 405,510 510,615
is too. But this is

2094
00:51:36,705 --> 00:51:37,620
0,240 240,525 525,690 690,810 810,915
like keeping track where the

2095
00:51:37,620 --> 00:51:39,240
0,255 255,585 585,810 810,1100
physical location things are.|
|

2096
00:51:39,690 --> 00:51:40,670
0,260 260,440 440,665 665,860 860,980
And so this has to
因此，这必须与磁盘上的实际文件保持同步，因为我不想创建一堆页面，也不想更新我的页面目录。我崩溃了，然后又回来了。现在我的页面目录不知道这些其他页面，我也无法访问它们。

2097
00:51:40,670 --> 00:51:42,280
0,105 105,270 270,495 495,950 1210,1610
be kept in sync with

2098
00:51:42,570 --> 00:51:44,060
0,320 320,530 530,755 755,995 995,1490
the actual files on disk

2099
00:51:44,060 --> 00:51:45,485
0,320 730,1020 1020,1230 1230,1320 1320,1425
because I don't want to

2100
00:51:45,485 --> 00:51:46,150
0,105 105,195 195,285 285,405 405,665
create a bunch of page,

2101
00:51:46,590 --> 00:51:48,100
0,380 380,620 620,755 755,965 965,1510
not update my page directory.

2102
00:51:48,300 --> 00:51:49,340
0,320 320,545 545,710 710,845 845,1040
I crash and come back.

2103
00:51:49,340 --> 00:51:50,440
0,165 165,270 270,405 405,600 600,1100
And now my page directory

2104
00:51:50,460 --> 00:51:51,440
0,380 380,560 560,740 740,845 845,980
doesn't know about these other

2105
00:51:51,440 --> 00:51:53,285
0,290 820,1125 1125,1410 1410,1725 1725,1845
pages and I can't get

2106
00:51:53,285 --> 00:51:54,160
0,120 120,365
to them.|
|

2107
00:51:54,320 --> 00:51:55,540
0,320 320,485 485,725 725,1070 1070,1220
Right. So there's, there's a
正确的。因此，为了确保这些东西保持同步，我们必须采取一系列额外的技巧。

2108
00:51:55,540 --> 00:51:56,275
0,120 120,210 210,375 375,645 645,735
bunch of extra tricks we

2109
00:51:56,275 --> 00:51:56,770
0,90 90,180 180,285 285,375 375,495
have to do to make

2110
00:51:56,770 --> 00:51:57,750
0,150 150,285 285,450 450,660 660,980
sure that these things are

2111
00:51:58,610 --> 00:52:00,100
0,260 260,410 410,760
kept in sync.|
|

2112
00:52:00,200 --> 00:52:00,985
0,275 275,410 410,530 530,665 665,785
Okay, so just thinking like
好的，就像我有一大堆纸一样。它们是一些，它们在某个位置，一堆文件，在哪里并不重要，然后它只是一张地图，告诉我去哪里找它。

2113
00:52:00,985 --> 00:52:01,830
0,195 195,390 390,480 480,585 585,845
I have a bunch of

2114
00:52:01,910 --> 00:52:03,340
0,400 480,845 845,1070 1070,1280 1280,1430
pages. They're some, they're on

2115
00:52:03,340 --> 00:52:04,450
0,320 460,765 765,915 915,1005 1005,1110
some location, a bunch of

2116
00:52:04,450 --> 00:52:06,130
0,210 210,495 495,645 645,950 1420,1680
files, doesn't matter where, and

2117
00:52:06,130 --> 00:52:07,450
0,260 430,750 750,840 840,975 975,1320
then it's just a mapping

2118
00:52:07,450 --> 00:52:08,005
0,105 105,210 210,345 345,465 465,555
to tell me where to

2119
00:52:08,005 --> 00:52:09,040
0,105 105,255 255,545
go find it.|
|

2120
00:52:09,640 --> 00:52:10,935
0,335 335,755 755,905 905,1085 1085,1295
Additional metada we keep track
我们跟踪的其他元数据，比如每一个页面，我们可以跟踪一个重要的位置，他们实际拥有的空闲空间的数量，或者他们拥有的空闲空间。现在，如果我想要插入两个池，并且我必须找到一页来放入它，我不想必须扫描所有的页面并计算出谁有空闲空间。我的页面目录会告诉我这一点。

2121
00:52:10,935 --> 00:52:12,105
0,210 210,515 535,780 780,930 930,1170
of like for every single

2122
00:52:12,105 --> 00:52:13,230
0,300 300,525 525,720 720,945 945,1125
page, we can keep track

2123
00:52:13,230 --> 00:52:14,745
0,180 180,360 360,615 615,980 1270,1515
of an essential location, the

2124
00:52:14,745 --> 00:52:15,540
0,105 105,225 225,390 390,630 630,795
number of free slots that

2125
00:52:15,540 --> 00:52:17,145
0,165 165,345 345,620 850,1250 1300,1605
they actually have, or free

2126
00:52:17,145 --> 00:52:18,630
0,210 210,375 375,635 985,1245 1245,1485
space they have. So now

2127
00:52:18,630 --> 00:52:19,380
0,225 225,345 345,465 465,540 540,750
if I want to insert

2128
00:52:19,380 --> 00:52:20,610
0,135 135,300 300,590 850,1110 1110,1230
a two pool and I

2129
00:52:20,610 --> 00:52:21,135
0,90 90,165 165,270 270,390 390,525
got to find a page

2130
00:52:21,135 --> 00:52:22,110
0,135 135,255 255,360 360,605 715,975
to put it in, I

2131
00:52:22,110 --> 00:52:22,575
0,165 165,195 195,240 240,315 315,465
don't want to have to

2132
00:52:22,575 --> 00:52:23,235
0,195 195,315 315,405 405,540 540,660
scan them all and figure

2133
00:52:23,235 --> 00:52:24,230
0,105 105,315 315,465 465,690 690,995
out who's got free space.

2134
00:52:24,730 --> 00:52:25,965
0,305 305,545 545,920 920,1100 1100,1235
My page directory would tell

2135
00:52:25,965 --> 00:52:26,820
0,120 120,365
me that.|
|

2136
00:52:27,120 --> 00:52:28,160
0,400
Right.|
正确的。|

2137
00:52:28,810 --> 00:52:29,670
0,275 275,425 425,545 545,695 695,860
And then if I run
然后，如果我用完了页面，我知道如何分配它们，然后更新我的页面目录以指出这一点。

2138
00:52:29,670 --> 00:52:30,795
0,120 120,285 285,590 730,990 990,1125
out of pages, I know

2139
00:52:30,795 --> 00:52:31,530
0,105 105,165 165,495 495,630 630,735
how to allocate them and

2140
00:52:31,530 --> 00:52:32,535
0,150 150,315 315,435 435,615 615,1005
then update my page directory

2141
00:52:32,535 --> 00:52:33,440
0,195 195,330 330,480 480,630 630,905
to point this as well.|
|

2142
00:52:35,820 --> 00:52:36,740
0,320 320,500 500,680 680,845 845,920
Again, just think, think of
再想一次，想想一个写入磁盘的哈希表，它跟踪我拥有的页面，但我也可以迭代或扫描，然后说这是第一页，这是第二页，这是第三页，因为如果我们有一种访问方法，比如顺序扫描操作符，我们将需要这个。

2143
00:52:36,740 --> 00:52:37,910
0,90 90,315 315,590 700,1035 1035,1170
a hash table that get

2144
00:52:37,910 --> 00:52:38,855
0,180 180,330 330,660 660,810 810,945
written to disk that keeps

2145
00:52:38,855 --> 00:52:39,470
0,135 135,240 240,330 330,480 480,615
track of the pages that

2146
00:52:39,470 --> 00:52:40,310
0,75 75,320 400,645 645,735 735,840
I have, but then I

2147
00:52:40,310 --> 00:52:41,810
0,225 225,570 570,1065 1065,1275 1275,1500
can also iterate or scan

2148
00:52:41,810 --> 00:52:43,040
0,195 195,330 330,590 760,1095 1095,1230
through and say here's page

2149
00:52:43,040 --> 00:52:44,105
0,210 210,480 480,615 615,810 810,1065
one, here's page two, here's

2150
00:52:44,105 --> 00:52:44,825
0,165 165,405 405,555 555,690 690,720
page three because we're going

2151
00:52:44,825 --> 00:52:45,965
0,60 60,210 210,515 745,1005 1005,1140
to need this if we

2152
00:52:45,965 --> 00:52:46,985
0,135 135,345 345,570 570,810 810,1020
have an access method like

2153
00:52:46,985 --> 00:52:48,760
0,105 105,435 435,705 705,1085
a sequential scan operator.|
|

2154
00:52:48,770 --> 00:52:49,450
0,245 245,335 335,485 485,545 545,680
If we don't have an
如果我们没有索引，我们需要能够迭代桌面上的每一根管子。所以页面目录需要公开为那个，那个API。是的，是的。所以你提到了万一发生撞车事故。这意味着目录也是易失性存储器的一部分。我也必须这么做。

2155
00:52:49,450 --> 00:52:50,140
0,180 180,315 315,420 420,570 570,690
index, we need to be

2156
00:52:50,140 --> 00:52:51,490
0,75 75,165 165,435 435,710 1000,1350
able to iterate over every

2157
00:52:51,490 --> 00:52:52,410
0,255 255,450 450,555 555,660 660,920
single tube on the table.

2158
00:52:52,940 --> 00:52:54,010
0,245 245,365 365,590 590,950 950,1070
So the page directory needs

2159
00:52:54,010 --> 00:52:55,225
0,90 90,255 255,495 495,800 910,1215
to be exposed as that,

2160
00:52:55,225 --> 00:52:56,710
0,165 165,630 630,1020 1020,1320 1320,1485
that API. Yes, yes. So

2161
00:52:56,710 --> 00:52:57,760
0,120 120,380 400,690 690,885 885,1050
you mentioned in case of

2162
00:52:57,760 --> 00:52:58,980
0,195 195,480 480,705 705,900 900,1220
foot crash. So that means

2163
00:52:59,090 --> 00:53:00,400
0,275 275,470 470,845 845,1055 1055,1310
because the directory is part

2164
00:53:00,400 --> 00:53:01,945
0,240 240,525 525,990 990,1275 1275,1545
of the volatile memory too.

2165
00:53:01,945 --> 00:53:03,380
0,225 225,450 450,660 660,995
I also have to.|
|

2166
00:53:05,140 --> 00:53:06,110
0,290 290,410 410,500 500,665 665,970
Yeah, so his question is
是啊，所以他的问题是因为目录。

2167
00:53:06,430 --> 00:53:08,280
0,350 350,590 590,1090
because the directory.|
|

2168
00:53:08,280 --> 00:53:08,775
0,135 135,225 225,285 285,360 360,495
It has to be brought
它必须被带入内存才能读取。它是，它是一个非易失性存储器。所以现在如果我崩溃了，我不想失去它。这是否意味着我对它所做的任何更改都必须写入磁盘？是。

2169
00:53:08,775 --> 00:53:09,300
0,90 90,135 135,270 270,420 420,525
in a memory in order

2170
00:53:09,300 --> 00:53:11,340
0,120 120,255 255,530 1390,1815 1815,2040
to read it. It's, it's

2171
00:53:11,340 --> 00:53:12,120
0,90 90,255 255,375 375,585 585,780
a non v volatile memory.

2172
00:53:12,120 --> 00:53:13,010
0,210 210,315 315,405 405,570 570,890
So now if I crash,

2173
00:53:14,110 --> 00:53:14,730
0,245 245,365 365,410 410,485 485,620
I don't want to lose

2174
00:53:14,730 --> 00:53:15,765
0,270 270,510 510,660 660,825 825,1035
it. Does that mean any

2175
00:53:15,765 --> 00:53:16,545
0,270 270,465 465,600 600,705 705,780
changes I make to it

2176
00:53:16,545 --> 00:53:17,025
0,105 105,180 180,255 255,375 375,480
have to be written a

2177
00:53:17,025 --> 00:53:18,360
0,285 285,575
disk? Yes.|
|

2178
00:53:18,540 --> 00:53:20,855
0,400 1050,1450 1530,1850 1850,2165 2165,2315
But like, but it's not
但是，这并不像你没有一直更新这个东西那么糟糕，对吗？所以你不会，你知道，如果你的，你的数据库文件中的空间用完了，并分配了更多的页面，你不会只分配一个页面，对吗？因为这样您就可以潜在地对您分配的每个查询执行此操作。就像你知道一千兆字节的数据。在确保被持久保存且安全之后，更新写入磁盘的页面目录。

2179
00:53:20,855 --> 00:53:23,075
0,180 180,465 465,845 1015,1415 1945,2220
as bad as like you're

2180
00:53:23,075 --> 00:53:24,005
0,210 210,555 555,675 675,795 795,930
not updating this thing all

2181
00:53:24,005 --> 00:53:26,570
0,150 150,425 865,1260 1260,1655 2245,2565
the time, right? So you're

2182
00:53:26,570 --> 00:53:27,455
0,135 135,285 285,495 495,705 705,885
not going to, you know,

2183
00:53:27,455 --> 00:53:28,070
0,180 180,285 285,390 390,480 480,615
if you run out of

2184
00:53:28,070 --> 00:53:28,670
0,180 180,300 300,390 390,495 495,600
space in your, in your

2185
00:53:28,670 --> 00:53:29,855
0,195 195,465 465,720 720,1050 1050,1185
database file and allocate more

2186
00:53:29,855 --> 00:53:31,025
0,275 655,945 945,1035 1035,1125 1125,1170
pages, you're not going to

2187
00:53:31,025 --> 00:53:32,920
0,285 285,435 435,660 660,995 1495,1895
allocate just one page, right?

2188
00:53:33,240 --> 00:53:33,980
0,260 260,365 365,455 455,590 590,740
Because then you can potentially

2189
00:53:33,980 --> 00:53:34,445
0,105 105,195 195,285 285,360 360,465
you do that for every

2190
00:53:34,445 --> 00:53:36,080
0,165 165,485 655,930 930,1395 1395,1635
single query you allocate. Like

2191
00:53:36,080 --> 00:53:37,085
0,180 180,360 360,585 585,930 930,1005
you know a gigabyte of

2192
00:53:37,085 --> 00:53:38,870
0,245 775,1050 1050,1185 1185,1365 1365,1785
data. Update your page directory

2193
00:53:38,870 --> 00:53:39,845
0,225 225,405 405,555 555,675 675,975
that gets written to disk

2194
00:53:39,845 --> 00:53:40,955
0,275 445,705 705,840 840,960 960,1110
once you make sure that's

2195
00:53:40,955 --> 00:53:42,340
0,315 315,450 450,600 600,845
persisted and it's safe.|
|

2196
00:53:42,760 --> 00:53:43,695
0,275 275,410 410,590 590,770 770,935
Then you proceed with running
然后继续运行查询。所以这意味着任何事情都必须是肯定的。所以声明，对页面的任何更新都必须写入。一张光盘？当然是，否则你就不知道是什么了。你不知道你拥有什么。

2197
00:53:43,695 --> 00:53:44,910
0,135 135,395 595,840 840,990 990,1215
the query. So that means

2198
00:53:44,910 --> 00:53:47,820
0,1335 1335,1590 1590,1800 1800,2060 2620,2910
anyory has to be yes.

2199
00:53:47,820 --> 00:53:49,455
0,165 165,440 790,1170 1170,1470 1470,1635
So statement, any update to

2200
00:53:49,455 --> 00:53:50,235
0,105 105,510 510,645 645,720 720,780
the pageotory has to be

2201
00:53:50,235 --> 00:53:51,260
0,105 105,210 210,455 475,750 750,1025
written. A disc? Absolutely yes,

2202
00:53:51,610 --> 00:53:52,515
0,245 245,425 425,620 620,830 830,905
because otherwise you don't know

2203
00:53:52,515 --> 00:53:53,115
0,180 180,360 360,480 480,525 525,600
what. You don't know what

2204
00:53:53,115 --> 00:53:54,000
0,90 90,335
you have.|
|

2205
00:53:54,070 --> 00:53:55,220
0,400
Yes.|
是。|

2206
00:53:55,830 --> 00:53:59,495
0,365 365,695 695,1060 1380,1780 3270,3665
This direct store, especially database
这种直接存储，尤其是数据库文件或存储，以及其他页面。

2207
00:53:59,495 --> 00:54:00,815
0,315 315,510 510,690 690,995 1015,1320
file or a store, along

2208
00:54:00,815 --> 00:54:01,780
0,180 180,375 375,695
with other pages.|
|

2209
00:54:01,940 --> 00:54:02,785
0,260 260,425 425,590 590,710 710,845
This question is, is this
问题是，这种排序是在特殊的数据库文件中还是与其他页面一起排序？你有什么特别的吗？

2210
00:54:02,785 --> 00:54:03,895
0,255 255,480 480,585 585,795 795,1110
sort in a special database

2211
00:54:03,895 --> 00:54:04,690
0,300 300,480 480,540 540,630 630,795
file or does it sort

2212
00:54:04,690 --> 00:54:06,085
0,150 150,270 270,420 420,710 1180,1395
along with other pages? What

2213
00:54:06,085 --> 00:54:07,500
0,45 45,105 105,315 315,695
do you might special?|
|

2214
00:54:07,540 --> 00:54:09,080
0,260 260,520 810,1070 1070,1235 1235,1540
Just like a separate file,
就像一个单独的文件，是的，所以在某种意义上会作为一个单独的文件，SQL Light会将其存储在文件的头中。

2215
00:54:09,730 --> 00:54:10,545
0,305 305,440 440,515 515,635 635,815
yeah, so in some sense

2216
00:54:10,545 --> 00:54:11,450
0,195 195,345 345,450 450,600 600,905
will as a separate file,

2217
00:54:12,220 --> 00:54:13,095
0,365 365,485 485,635 635,770 770,875
sql light will store this

2218
00:54:13,095 --> 00:54:14,385
0,105 105,195 195,545 925,1185 1185,1290
in the header of the

2219
00:54:14,385 --> 00:54:16,320
0,245
file.|
|

2220
00:54:16,320 --> 00:54:18,460
0,380 730,1065 1065,1550
Typically stored separately.|
通常单独存储。|

2221
00:54:20,010 --> 00:54:21,580
0,400 720,965 965,1100 1100,1280 1280,1570
Yes, when you say that
是的，当你说数据库使用多个文件时，你的意思是一个表使用多个文件吗？

2222
00:54:21,690 --> 00:54:23,350
0,275 275,550 600,935 935,1265 1265,1660
the database uses multiple files,

2223
00:54:23,490 --> 00:54:24,275
0,230 230,305 305,440 440,620 620,785
do you mean that a

2224
00:54:24,275 --> 00:54:25,730
0,240 240,555 555,840 840,1140 1140,1455
single table uses multiple files?|
|

2225
00:54:27,170 --> 00:54:28,480
0,400 450,740 740,950 950,1270
Uses like maybe one.|
用途可能只有一种。|

2226
00:54:29,110 --> 00:54:30,075
0,230 230,335 335,515 515,770 770,965
So his question is, when
所以他的问题是，当我说一个数据系统可以使用多个文件时，我是指在一个表中，它是包含多个文件，还是在数据库中包含多个文件？

2227
00:54:30,075 --> 00:54:30,990
0,135 135,345 345,525 525,690 690,915
I say a data system

2228
00:54:30,990 --> 00:54:32,040
0,165 165,300 300,510 510,810 810,1050
could use multiple files, I

2229
00:54:32,040 --> 00:54:34,065
0,260 610,930 930,1170 1170,1490 1750,2025
mean within one table, does

2230
00:54:34,065 --> 00:54:35,355
0,180 180,360 360,555 555,875 955,1290
it contain multiple files or

2231
00:54:35,355 --> 00:54:36,675
0,240 240,420 420,930 930,1125 1125,1320
within the databases, contain multiple

2232
00:54:36,675 --> 00:54:37,820
0,335
files?|
|

2233
00:54:38,760 --> 00:54:41,495
0,400 1440,1925 1925,2255 2255,2525 2525,2735
Anyone DB uses one file
任何数据库都为所有数据库使用一个文件。

2234
00:54:41,495 --> 00:54:42,020
0,165 165,425
for all.|
|

2235
00:54:42,340 --> 00:54:43,620
0,275 275,395 395,545 545,910 960,1280
Yeah. So duct DB uses
嗯。因此，风管数据库使用一个文件，即所有表格，与单个光源相同。但我的意思是，我们可以弹出和Postgres并查看数据目录。里面有一堆文件，里面有数字。

2236
00:54:43,620 --> 00:54:44,400
0,195 195,360 360,495 495,585 585,780
one file, all the table,

2237
00:54:44,400 --> 00:54:45,780
0,195 195,285 285,420 420,710 1090,1380
same as single light. But

2238
00:54:45,780 --> 00:54:46,665
0,135 135,345 345,570 570,720 720,885
I mean we can pop

2239
00:54:46,665 --> 00:54:47,850
0,120 120,240 240,615 615,905 925,1185
up and postgres and look

2240
00:54:47,850 --> 00:54:48,555
0,105 105,195 195,330 330,570 570,705
in the data directory. There's

2241
00:54:48,555 --> 00:54:49,095
0,45 45,135 135,240 240,390 390,540
a bunch of files in

2242
00:54:49,095 --> 00:54:50,565
0,245 325,585 585,845 985,1305 1305,1470
there that have numbers in

2243
00:54:50,565 --> 00:54:51,300
0,245
them.|
|

2244
00:54:51,300 --> 00:54:52,425
0,105 105,350 430,720 720,915 915,1125
And there, various data files
在那里，有各种各样的数据文件，有时还需要索引。有时会有四张桌子。

2245
00:54:52,425 --> 00:54:53,325
0,165 165,420 420,660 660,735 735,900
and sometimes therell be for

2246
00:54:53,325 --> 00:54:54,360
0,360 360,555 555,765 765,870 870,1035
indexes. Sometimes there'll be four

2247
00:54:54,360 --> 00:54:56,100
0,290
tables.|
|

2248
00:54:56,540 --> 00:54:58,300
0,400 900,1190 1190,1400 1400,1580 1580,1760
And various systems do different
不同的系统做不同的事情，而不是不断地重复我自己。这就是SQL的美妙之处，我不知道，在我的SQL查询中不在乎，我是有一个文件还是一千个文件，数据可以决定如何做到这一点。它只知道如何为您运行查询。

2249
00:54:58,300 --> 00:55:00,030
0,320 460,780 780,1050 1050,1365 1365,1730
things and again, not to

2250
00:55:00,320 --> 00:55:01,780
0,305 305,575 575,880 1050,1325 1325,1460
keep repeating myself. This is

2251
00:55:01,780 --> 00:55:03,670
0,135 135,410 430,720 720,1190 1630,1890
the beauty of sql, I

2252
00:55:03,670 --> 00:55:04,765
0,195 195,330 330,615 615,885 885,1095
don't know, don't care in

2253
00:55:04,765 --> 00:55:05,815
0,120 120,330 330,705 705,930 930,1050
my sql queries, whether I

2254
00:55:05,815 --> 00:55:06,640
0,105 105,270 270,540 540,735 735,825
have one file or a

2255
00:55:06,640 --> 00:55:09,280
0,225 225,590 1390,1650 1650,1910 2320,2640
thousand files, the data can

2256
00:55:09,280 --> 00:55:10,140
0,225 225,375 375,480 480,600 600,860
decide how to do that.

2257
00:55:10,430 --> 00:55:11,230
0,260 260,395 395,560 560,695 695,800
It just knows how to

2258
00:55:11,230 --> 00:55:12,120
0,120 120,255 255,450 450,615 615,890
run your query for you.|
|

2259
00:55:12,910 --> 00:55:14,190
0,350 350,620 620,845 845,1055 1055,1280
So again, different data systems
因此，不同的数据系统做不同的事情。

2260
00:55:14,190 --> 00:55:15,420
0,165 165,300 300,590
do different things.|
|

2261
00:55:16,520 --> 00:55:17,225
0,165 165,270 270,375 375,540 540,705
How do you know when
你怎么知道你什么时候想要呢？

2262
00:55:17,225 --> 00:55:17,820
0,150 150,330 330,555
you want to?|
|

2263
00:55:20,000 --> 00:55:20,860
0,260 260,425 425,620 620,770 770,860
His question is, how do
他的问题是，如何知道是否要为一个表使用多个文件？同样，这要视情况而定。所以如果我们还不讨论大柱子，但就像你说你有一个。

2264
00:55:20,860 --> 00:55:21,580
0,75 75,300 300,555 555,660 660,720
you know whether you want

2265
00:55:21,580 --> 00:55:22,705
0,45 45,135 135,330 330,650 760,1125
to use multiple files for

2266
00:55:22,705 --> 00:55:25,615
0,225 225,390 390,695 2305,2625 2625,2910
for one table? Again, it

2267
00:55:25,615 --> 00:55:27,790
0,360 360,630 630,905 955,1355 1915,2175
depends. So like if we

2268
00:55:27,790 --> 00:55:29,070
0,210 210,345 345,495 495,770 880,1280
won't talk about large large

2269
00:55:29,510 --> 00:55:31,920
0,440 440,620 620,740 740,970 2010,2410
columns yet, but like see

2270
00:55:31,940 --> 00:55:33,540
0,245 245,335 335,425 425,670
say you have a.|
|

2271
00:55:33,540 --> 00:55:34,185
0,120 120,180 180,300 300,495 495,645
You have a table that
您有一个表，它有一个BLOB字段或一个文本字段，大约有10兆字节。

2272
00:55:34,185 --> 00:55:36,170
0,245 775,1080 1080,1365 1365,1650 1650,1985
has a blob field or

2273
00:55:36,250 --> 00:55:37,980
0,290 290,485 485,790 1050,1385 1385,1730
a text field, and that's

2274
00:55:37,980 --> 00:55:39,820
0,260 340,630 630,1220
like ten megabytes.|
|

2275
00:55:39,820 --> 00:55:41,010
0,255 255,375 375,570 570,840 840,1190
You'd want to store that
您可能希望将其存储在单独的页面中，但可能需要将其压缩存储，因为它是一堆文本数据。所以你有常规的整型和浮点型列，不管它存储在一个文件中。然后你的大件东西被分类到另一个文件中，对吗？所以这是一种方法。但是你也可以想象，也许你只是，你只是。

2276
00:55:41,030 --> 00:55:42,820
0,290 290,515 515,850 1380,1640 1640,1790
in separate pages, but maybe

2277
00:55:42,820 --> 00:55:43,375
0,135 135,210 210,300 300,420 420,555
you want to store that

2278
00:55:43,375 --> 00:55:44,710
0,485 505,1050 1050,1200 1200,1245 1245,1335
compressed because it's a bunch

2279
00:55:44,710 --> 00:55:45,730
0,120 120,285 285,590 700,930 930,1020
of text data. So you

2280
00:55:45,730 --> 00:55:47,095
0,105 105,225 225,500 730,1215 1215,1365
have the regular columns of

2281
00:55:47,095 --> 00:55:48,390
0,75 75,405 405,630 630,975 975,1295
the integers and floats, whatever

2282
00:55:48,650 --> 00:55:49,645
0,290 290,470 470,590 590,755 755,995
that stored in one file.

2283
00:55:49,645 --> 00:55:51,040
0,180 180,420 420,780 780,1140 1140,1395
And then your large stuff

2284
00:55:51,040 --> 00:55:51,990
0,135 135,330 330,435 435,630 630,950
is sorted in another file,

2285
00:55:52,370 --> 00:55:54,265
0,400 750,1115 1115,1475 1475,1640 1640,1895
right? So that's one approach.

2286
00:55:54,265 --> 00:55:55,090
0,165 165,240 240,360 360,600 600,825
But you can imagine also

2287
00:55:55,090 --> 00:55:56,155
0,150 150,360 360,525 525,770 790,1065
too, maybe you just, you

2288
00:55:56,155 --> 00:55:56,900
0,275
just.|
|

2289
00:55:56,940 --> 00:55:57,875
0,305 305,470 470,635 635,815 815,935
You have some space in
你在一个单独的文件中有一些空间，在固定材料的顶部，Verrel长度的底部。

2290
00:55:57,875 --> 00:55:58,580
0,90 90,240 240,450 450,600 600,705
a single file at the

2291
00:55:58,580 --> 00:55:59,240
0,150 150,300 300,390 390,480 480,660
top parts of the fixed

2292
00:55:59,240 --> 00:55:59,885
0,210 210,345 345,465 465,570 570,645
stuff, the bottom of the

2293
00:55:59,885 --> 00:56:01,020
0,240 240,485
verrel length.|
|

2294
00:56:01,020 --> 00:56:02,340
0,270 270,560
It depends.|
那得看情况。|

2295
00:56:04,370 --> 00:56:05,455
0,230 230,335 335,530 530,920 920,1085
I think my sequel up
我想我的续集最高可达5.6部。

2296
00:56:05,455 --> 00:56:06,990
0,165 165,870 870,1080 1080,1245 1245,1535
to 5.6 used to store.|
|

2297
00:56:08,470 --> 00:56:09,450
0,275 275,395 395,470 470,650 650,980
I think it was one
我想这是所有桌子的一个文件。

2298
00:56:09,450 --> 00:56:11,380
0,345 345,555 555,690 690,980
file for all tables.|
|

2299
00:56:11,510 --> 00:56:13,375
0,290 290,485 485,965 965,1240 1620,1865
Or all databases. And they
或所有数据库。他们没有。不，每个数据库一个文件，他们把它分成一个文件，而不是每个表。

2300
00:56:13,375 --> 00:56:14,590
0,255 255,605 625,870 870,1005 1005,1215
don't. No, it was one

2301
00:56:14,590 --> 00:56:16,255
0,285 285,555 555,860 1240,1500 1500,1665
file per database and they

2302
00:56:16,255 --> 00:56:16,750
0,150 150,210 210,285 285,390 390,495
split it up to be

2303
00:56:16,750 --> 00:56:17,760
0,180 180,405 405,585 585,735 735,1010
one file, not per table.|
|

2304
00:56:19,130 --> 00:56:20,430
0,275 275,470 470,680 680,860 860,1300
And separate files or indexes.|
以及单独的文件或索引。|

2305
00:56:24,160 --> 00:56:25,380
0,400
Okay.|
好吧。|

2306
00:56:26,060 --> 00:56:27,160
0,245 245,365 365,485 485,730 780,1100
So now we know roughly
因此，现在我们大致了解了文件的外观、文件的布局以及我们如何跟踪它们的存在位置。所以，讨论一下页面本身的实际内容。

2307
00:56:27,160 --> 00:56:28,885
0,320 430,830 1060,1320 1320,1515 1515,1725
at what the files look

2308
00:56:28,885 --> 00:56:29,950
0,180 180,485 505,780 780,915 915,1065
like, or how the files

2309
00:56:29,950 --> 00:56:30,625
0,165 165,315 315,465 465,585 585,675
are laid out and how

2310
00:56:30,625 --> 00:56:31,285
0,90 90,225 225,375 375,510 510,660
we keep track of where

2311
00:56:31,285 --> 00:56:33,805
0,195 195,515 1765,2220 2220,2400 2400,2520
they exist. So talk about

2312
00:56:33,805 --> 00:56:35,430
0,870 870,1080 1080,1245 1245,1365 1365,1625
what's's actually inside the pages

2313
00:56:35,510 --> 00:56:36,620
0,400
themselves.|
|

2314
00:56:37,610 --> 00:56:38,560
0,230 230,380 380,635 635,845 845,950
So every page is going
所以每个页面都会有一个页眉。

2315
00:56:38,560 --> 00:56:40,120
0,75 75,240 240,420 420,800
to have a header.|
|

2316
00:56:40,315 --> 00:56:41,305
0,165 165,255 255,480 480,750 750,990
That's going to tell you
这将告诉你一些关于数据实际是什么的信息。

2317
00:56:41,305 --> 00:56:43,630
0,315 315,665 715,1115 1825,2085 2085,2325
something about what the data

2318
00:56:43,630 --> 00:56:44,840
0,240 240,500
actually is.|
|

2319
00:56:45,060 --> 00:56:46,445
0,400 600,890 890,1100 1100,1280 1280,1385
So a common thing would
因此，常见的东西应该是页面大小或校验和，对吗？因此，如果您崩溃并回来或重新启动系统，或者实际上任何时候您从磁盘获取东西，您都会计算快速检查以确保数据没有损坏。

2320
00:56:46,445 --> 00:56:47,410
0,120 120,270 270,420 420,630 630,965
be like the page size

2321
00:56:47,970 --> 00:56:49,210
0,305 305,470 470,635 635,890 890,1240
or like a check sum,

2322
00:56:49,890 --> 00:56:50,920
0,335 335,500 500,575 575,725 725,1030
right? So if you crash

2323
00:56:51,210 --> 00:56:52,330
0,305 305,485 485,680 680,860 860,1120
and come back or you

2324
00:56:52,410 --> 00:56:54,005
0,410 410,530 530,740 740,1090 1350,1595
restart the system, or actually

2325
00:56:54,005 --> 00:56:54,905
0,285 285,390 390,555 555,735 735,900
anytime you fetch something from

2326
00:56:54,905 --> 00:56:56,480
0,515 655,990 990,1275 1275,1395 1395,1575
disk, you compute a fast

2327
00:56:56,480 --> 00:56:57,395
0,270 270,525 525,675 675,795 795,915
check some to make sure

2328
00:56:57,395 --> 00:56:58,630
0,105 105,225 225,420 420,705 705,1235
that the data isn't corrupted.|
|

2329
00:56:59,140 --> 00:57:00,240
0,260
Um.|
恩。|

2330
00:57:00,280 --> 00:57:01,350
0,335 335,545 545,680 680,860 860,1070
Maybe keep track of the
也许可以跟踪实际创建页面的数据库系统的版本。这样一来，你就推出了一个破坏兼容性的新版本。您可以拥有一些知道如何读取旧数据的代码。

2331
00:57:01,350 --> 00:57:02,355
0,240 240,435 435,555 555,765 765,1005
version of the database system

2332
00:57:02,355 --> 00:57:03,735
0,240 240,450 450,675 675,1025 1105,1380
that actually created the the

2333
00:57:03,735 --> 00:57:05,295
0,275 295,555 555,815 1195,1455 1455,1560
page. That way you put

2334
00:57:05,295 --> 00:57:06,015
0,105 105,225 225,345 345,525 525,720
out a new version that

2335
00:57:06,015 --> 00:57:07,650
0,165 165,785 1135,1380 1380,1485 1485,1635
breaks compatibility. You can have

2336
00:57:07,650 --> 00:57:08,805
0,165 165,330 330,620 760,1035 1035,1155
some code that knows how

2337
00:57:08,805 --> 00:57:09,710
0,180 180,405 405,525 525,630 630,905
to read the old data.|
|

2338
00:57:10,610 --> 00:57:11,580
0,260 260,410 410,560 560,695 695,970
We all talk about transactions
我们都在谈论事务，直到期中考试之后，但就像，你可以跟踪什么线程或什么事务写到这个文件中的什么数据，以及它是否对任何东西都是可见的，无论你正在运行什么查询。

2339
00:57:12,020 --> 00:57:13,270
0,320 320,560 560,725 725,1070 1070,1250
until after the midterm, but

2340
00:57:13,270 --> 00:57:14,440
0,225 225,450 450,705 705,990 990,1170
like, you can keep track

2341
00:57:14,440 --> 00:57:16,075
0,150 150,410 820,1200 1200,1485 1485,1635
of like what thread or

2342
00:57:16,075 --> 00:57:17,335
0,135 135,425 625,930 930,1095 1095,1260
what transaction wrote to what

2343
00:57:17,335 --> 00:57:18,385
0,240 240,450 450,630 630,795 795,1050
data in this and whether

2344
00:57:18,385 --> 00:57:19,620
0,375 375,525 525,735 735,960 960,1235
it's actually visible to whatever,

2345
00:57:19,670 --> 00:57:21,400
0,275 275,485 485,725 725,970
whatever query you're running.|
|

2346
00:57:21,700 --> 00:57:23,060
0,305 305,470 470,665 665,890 890,1360
If the data is compressed.|
如果数据被压缩。|

2347
00:57:24,090 --> 00:57:25,100
0,335 335,770 770,845 845,920 920,1010
Or encode it in a
或者以某种方式进行编码，我们将在下周讨论。将会有关于压缩方案的实际情况的元数据。

2348
00:57:25,100 --> 00:57:26,495
0,150 150,360 360,680 910,1245 1245,1395
certain way, which we'll discuss

2349
00:57:26,495 --> 00:57:28,085
0,180 180,485 715,1005 1005,1110 1110,1590
next week. There'll be metadata

2350
00:57:28,085 --> 00:57:29,420
0,240 240,635 715,975 975,1065 1065,1335
about how what the compression

2351
00:57:29,420 --> 00:57:30,860
0,285 285,465 465,710
scheme actually is.|
|

2352
00:57:31,590 --> 00:57:32,615
0,230 230,395 395,650 650,860 860,1025
To be information about what
在我们讨论Oracle时，为了提供关于模式是什么或表模式是什么的信息，有时还会有关于数据本身的附加统计信息。比如，对于给定列，最小值、最小值和最大值是多少？因为也许我只需要阅读它，而不是真正地阅读数据来找出是否有我需要的东西。

2353
00:57:32,615 --> 00:57:33,605
0,255 255,525 525,780 780,885 885,990
the the schema is or

2354
00:57:33,605 --> 00:57:35,225
0,90 90,195 195,455 1045,1410 1410,1620
what the table schema is,

2355
00:57:35,225 --> 00:57:36,095
0,240 240,360 360,465 465,585 585,870
as we talk about Oracle

2356
00:57:36,095 --> 00:57:38,380
0,245 805,1205 1345,1710 1710,1935 1935,2285
does, sometimes there's additional statistics

2357
00:57:38,820 --> 00:57:40,180
0,350 350,740 740,935 935,1100 1100,1360
about what's in the data

2358
00:57:40,200 --> 00:57:42,140
0,400 900,1160 1160,1420 1650,1880 1880,1940
itself. So like for a

2359
00:57:42,140 --> 00:57:43,420
0,180 180,525 525,855 855,990 990,1280
given column, what's the min,

2360
00:57:43,470 --> 00:57:44,375
0,260 260,410 410,635 635,815 815,905
the min value and the

2361
00:57:44,375 --> 00:57:45,770
0,180 180,515 835,1110 1110,1260 1260,1395
Max value? Because maybe I

2362
00:57:45,770 --> 00:57:47,050
0,135 135,285 285,435 435,710 880,1280
just need to read that

2363
00:57:47,190 --> 00:57:47,975
0,245 245,380 380,515 515,650 650,785
instead of actually reading the

2364
00:57:47,975 --> 00:57:48,820
0,180 180,360 360,465 465,585 585,845
data to figure out whether

2365
00:57:49,020 --> 00:57:50,110
0,350 350,590 590,710 710,845 845,1090
and there's something I need.|
|

2366
00:57:51,490 --> 00:57:52,425
0,350 350,575 575,710 710,830 830,935
Right. And again, as we
正确的。同样，正如我们已经讨论过的，Oracle以自包含而闻名，但并不是所有的系统都能做到这一点。

2367
00:57:52,425 --> 00:57:54,525
0,150 150,360 360,825 825,1175 1585,2100
already discussed, Oracle is famously

2368
00:57:54,525 --> 00:57:56,070
0,225 225,575 685,975 975,1260 1260,1545
self contained, but not all

2369
00:57:56,070 --> 00:57:57,640
0,225 225,420 420,680
systems do that.|
|

2370
00:57:59,990 --> 00:58:00,955
0,245 245,350 350,545 545,740 740,965
So now, within the page
因此，现在，在页面本身内，我们需要决定我们实际上想要如何组织。

2371
00:58:00,955 --> 00:58:03,055
0,365 1435,1665 1665,1740 1740,1860 1860,2100
itself, we need to decide

2372
00:58:03,055 --> 00:58:03,865
0,270 270,465 465,600 600,675 675,810
how we actually want to

2373
00:58:03,865 --> 00:58:05,100
0,395
organize.|
|

2374
00:58:05,110 --> 00:58:07,530
0,275 275,530 530,790 1110,1510 2190,2420
The twople data, right. So
两个数据，对。所以在这节课的这一点上，我们将假设我们只在页面中存储了两个。我们稍后将讨论索引，然后我们将假设以面向行的方式存储两个球。

2375
00:58:07,530 --> 00:58:08,370
0,120 120,360 360,600 600,720 720,840
at this point in this

2376
00:58:08,370 --> 00:58:09,705
0,290 700,990 990,1035 1035,1125 1125,1335
lecture, we're going to assume

2377
00:58:09,705 --> 00:58:10,815
0,240 240,420 420,555 555,825 825,1110
that we're only storing twoles

2378
00:58:10,815 --> 00:58:12,660
0,90 90,195 195,455 1285,1605 1605,1845
in our pages. We'll discuss

2379
00:58:12,660 --> 00:58:14,145
0,360 360,620 970,1245 1245,1365 1365,1485
indexes later, and then we're

2380
00:58:14,145 --> 00:58:14,790
0,30 30,150 150,345 345,495 495,645
going to assume that we're

2381
00:58:14,790 --> 00:58:15,660
0,240 240,450 450,600 600,735 735,870
storing two balls in a

2382
00:58:15,660 --> 00:58:17,320
0,225 225,660 660,1010
row oriented manner.|
|

2383
00:58:17,710 --> 00:58:18,915
0,335 335,620 620,830 830,980 980,1205
Meaning like, if I have
意思是，如果我有五个属性，我会有两个，在我看到下两个碗之前，我会连续拥有这五个属性。

2384
00:58:18,915 --> 00:58:20,250
0,330 330,810 810,1065 1065,1155 1155,1335
five attributes I will have,

2385
00:58:20,250 --> 00:58:21,260
0,240 240,390 390,495 495,600 600,1010
I will have a twople

2386
00:58:21,400 --> 00:58:22,395
0,245 245,425 425,560 560,740 740,995
and I'll have those five

2387
00:58:22,395 --> 00:58:23,745
0,285 285,855 855,1050 1050,1230 1230,1350
attributes contiguously before I see

2388
00:58:23,745 --> 00:58:24,980
0,90 90,240 240,405 405,665
the next two bowl.|
|

2389
00:58:25,170 --> 00:58:26,870
0,400 990,1265 1265,1475 1475,1565 1565,1700
Next week we'll see about
下周我们将看看专栏商店。我们存储这个略有不同，但出于我们的目的，我们假设它是面向行的，我们将在下周讨论这个问题。

2390
00:58:26,870 --> 00:58:28,040
0,240 240,555 555,795 795,945 945,1170
column stores. We store this

2391
00:58:28,040 --> 00:58:29,075
0,270 270,570 570,825 825,930 930,1035
slightly different, but for our

2392
00:58:29,075 --> 00:58:31,985
0,225 225,575 1555,1860 1860,2165 2545,2910
purposes here, we assume that's

2393
00:58:31,985 --> 00:58:33,215
0,120 120,485 655,915 915,1080 1080,1230
row oriented and we'll break

2394
00:58:33,215 --> 00:58:34,960
0,305 505,795 795,1085
this next week.|
|

2395
00:58:35,540 --> 00:58:36,810
0,260 260,425 425,695 695,935 935,1270
So there's 300 approaches what,
所以在我们的页面上有300种方法，它实际上可能是什么。在两个面向存储的存储中，我们只存储两个池和这两个池拥有的精确值，这是一种日志结构方法，我们只存储自上次这两个池更新以来更改的增量。

2396
00:58:37,010 --> 00:58:37,720
0,245 245,335 335,485 485,635 635,710
what it could actually be

2397
00:58:37,720 --> 00:58:39,280
0,60 60,165 165,440 1180,1425 1425,1560
in our pages. So the

2398
00:58:39,280 --> 00:58:40,450
0,285 285,600 600,870 870,1035 1035,1170
twople oriented storage where we're

2399
00:58:40,450 --> 00:58:41,470
0,165 165,465 465,675 675,855 855,1020
only storing two pool and

2400
00:58:41,470 --> 00:58:43,105
0,150 150,440 820,1200 1200,1470 1470,1635
the exact values that those

2401
00:58:43,105 --> 00:58:44,650
0,255 255,545 1135,1395 1395,1455 1455,1545
twoils have, there be a

2402
00:58:44,650 --> 00:58:45,730
0,195 195,570 570,780 780,960 960,1080
log structured approach where we

2403
00:58:45,730 --> 00:58:46,860
0,150 150,345 345,750 750,870 870,1130
just store deltas of what

2404
00:58:46,940 --> 00:58:48,270
0,380 380,635 635,770 770,980 980,1330
changed since the last time

2405
00:58:49,580 --> 00:58:50,760
0,275 275,410 410,530 530,785 785,1180
last time these two updated.|
|

2406
00:58:51,990 --> 00:58:53,480
0,275 275,550 600,845 845,1090 1230,1490
And that should be in
这应该在索引中，在索引中组织，在存储中组织。

2407
00:58:53,480 --> 00:58:55,145
0,225 225,590 970,1245 1245,1440 1440,1665
index, organized in index, organized

2408
00:58:55,145 --> 00:58:56,560
0,180 180,300 300,545
store to be.|
|

2409
00:58:57,300 --> 00:58:58,265
0,290 290,425 425,545 545,725 725,965
It could be like a
它可能类似于树结构，在叶节点中，我实际上存储了数据本身。

2410
00:58:58,265 --> 00:59:00,365
0,285 285,635 1195,1595 1675,1950 1950,2100
tree structure, where in the

2411
00:59:00,365 --> 00:59:01,385
0,225 225,510 510,705 705,840 840,1020
leaf nodes I'm actually storing

2412
00:59:01,385 --> 00:59:02,780
0,135 135,375 375,755
the data itself.|
|

2413
00:59:02,910 --> 00:59:04,220
0,365 365,815 815,995 995,1205 1205,1310
So today's lecture, we're only
所以今天的课程，我们只会讨论第一个，两个点的存储，下周我们会讨论另外两种方法。

2414
00:59:04,220 --> 00:59:05,000
0,120 120,195 195,360 360,600 600,780
going to talk about the

2415
00:59:05,000 --> 00:59:06,850
0,165 165,470 1030,1290 1290,1500 1500,1850
first one, two point storage,

2416
00:59:07,170 --> 00:59:08,090
0,245 245,395 395,605 605,770 770,920
and then next week we'll

2417
00:59:08,090 --> 00:59:09,320
0,150 150,470 760,1020 1020,1110 1110,1230
talk about the two other

2418
00:59:09,320 --> 00:59:10,980
0,290
approaches.|
|

2419
00:59:12,630 --> 00:59:13,385
0,245 245,365 365,485 485,650 650,755
All right, so let's think
好的，那么让我们考虑一下我们实际上想要如何在我们的页面中存储两个油？

2420
00:59:13,385 --> 00:59:14,030
0,195 195,375 375,450 450,540 540,645
about how do we actually

2421
00:59:14,030 --> 00:59:14,630
0,60 60,150 150,285 285,510 510,600
want to store twoils in

2422
00:59:14,630 --> 00:59:15,780
0,90 90,350
our pages?|
|

2423
00:59:15,930 --> 00:59:16,805
0,335 335,500 500,665 665,770 770,875
Right. So let's say we
正确的。让我们假设我们有一个非常简单的方法，在我们的页眉中，我们只跟踪我们拥有的两个池的数量，对吗？任何时候我们想插入一个新的两个。

2424
00:59:16,805 --> 00:59:17,705
0,75 75,165 165,345 345,585 585,900
have a really simple approach

2425
00:59:17,705 --> 00:59:19,580
0,395 955,1215 1215,1365 1365,1575 1575,1875
where in our page header,

2426
00:59:19,580 --> 00:59:20,255
0,105 105,210 210,360 360,540 540,675
we just keep track of

2427
00:59:20,255 --> 00:59:20,780
0,90 90,195 195,300 300,405 405,525
the number of two pool

2428
00:59:20,780 --> 00:59:23,350
0,105 105,210 210,470 1330,1730 2170,2570
that we have, right? And

2429
00:59:23,820 --> 00:59:24,995
0,575 575,710 710,815 815,905 905,1175
anytime we want to insert

2430
00:59:24,995 --> 00:59:26,320
0,90 90,225 225,515
a new two.|
|

2431
00:59:26,320 --> 00:59:27,175
0,195 195,300 300,585 585,750 750,855
We just append to the
我们只是追加到末尾。

2432
00:59:27,175 --> 00:59:28,160
0,245
end.|
|

2433
00:59:28,620 --> 00:59:30,020
0,400 780,1010 1010,1070 1070,1220 1220,1400
Right, so we can assume
对，所以我们可以假设我们的数据是固定长度的。因此，如果我想对新的两个po排序，我只需查看页眉，看到第二个池，乘以两个池的大小，这就告诉我我想要写入页面的偏移量。

2434
00:59:30,020 --> 00:59:31,475
0,135 135,420 420,585 585,890 1240,1455
our data fixed length. So

2435
00:59:31,475 --> 00:59:32,000
0,45 45,150 150,285 285,405 405,525
if I want to sort

2436
00:59:32,000 --> 00:59:32,750
0,150 150,315 315,480 480,630 630,750
new two po, I just

2437
00:59:32,750 --> 00:59:33,700
0,165 165,330 330,450 450,555 555,950
go look at the header,

2438
00:59:33,810 --> 00:59:34,810
0,260 260,365 365,530 530,725 725,1000
see the number two pool,

2439
00:59:36,060 --> 00:59:37,700
0,530 530,725 725,1030 1230,1490 1490,1640
multiply that by the size

2440
00:59:37,700 --> 00:59:38,660
0,120 120,210 210,345 345,620 700,960
of the two pool and

2441
00:59:38,660 --> 00:59:39,650
0,150 150,345 345,510 510,750 750,990
that tells me where offset

2442
00:59:39,650 --> 00:59:40,205
0,135 135,255 255,345 345,450 450,555
I want to write the

2443
00:59:40,205 --> 00:59:41,140
0,245
page.|
|

2444
00:59:43,935 --> 00:59:44,860
0,60 60,305
What's wrong?|
怎么了？|

2445
00:59:46,310 --> 00:59:48,220
0,670 720,1010 1010,1160 1160,1420
Laterfly just kill it.|
大苍蝇就杀了它吧。|

2446
00:59:53,030 --> 00:59:54,540
0,350 350,700 810,1055 1055,1205 1205,1510
Is anybody keep that alive?
有人能让它活着吗？我们有苍蝇出没。

2447
00:59:58,970 --> 01:00:02,540
0,230 230,460 600,1270 1380,2140
We have lanfly infestation.|
|

2448
01:00:02,610 --> 01:00:05,280
0,260 260,520 1290,1595 1595,1900
All right, right. So.|
好的，好的。所以。|

2449
01:00:05,670 --> 01:00:06,470
0,245 245,350 350,470 470,650 650,800
Is this a good idea
这是个好主意还是坏主意？

2450
01:00:06,470 --> 01:00:09,280
0,60 60,120 120,300 300,650
or a bad idea?|
|

2451
01:00:09,320 --> 01:00:10,330
0,260 260,440 440,665 665,875 875,1010
I said straw man, so
我说的是稻草人，所以这显然不是个好主意。为什么这是个坏主意？

2452
01:00:10,330 --> 01:00:11,245
0,195 195,375 375,495 495,675 675,915
it's obviously a bad idea.

2453
01:00:11,245 --> 01:00:11,785
0,150 150,240 240,315 315,375 375,540
Why is it a bad

2454
01:00:11,785 --> 01:00:12,700
0,335
idea?|
|

2455
01:00:14,260 --> 01:00:16,340
0,400 510,910 1080,1400 1400,1700 1700,2080
Tu then it just throw
然后它就会把所有的东西都扔出去。

2456
01:00:16,420 --> 01:00:17,160
0,275 275,440 440,710
everything out of.|
|

2457
01:00:17,530 --> 01:00:18,510
0,305 305,440 440,515 515,710 710,980
Right, so if I deleted
对，所以如果我删除了两个，加上我删除了两个，两个，它把所有的东西都打乱了。

2458
01:00:18,510 --> 01:00:19,700
0,105 105,210 210,470 490,840 840,1190
two, plus I delete two,

2459
01:00:20,170 --> 01:00:21,930
0,400 1020,1280 1280,1520 1520,1670 1670,1760
two, it throws everything out

2460
01:00:21,930 --> 01:00:22,960
0,45 45,260
of order.|
|

2461
01:00:23,330 --> 01:00:25,285
0,305 305,485 485,635 635,910 1710,1955
Right. Because now I what
正确的。因为现在我想要做的是插入一个新的单位，而我不会把它放在最后。我想用这里的位置，对吗？

2462
01:00:25,285 --> 01:00:25,795
0,105 105,225 225,330 330,405 405,510
I want to be able

2463
01:00:25,795 --> 01:00:28,135
0,120 120,345 345,725 1825,2235 2235,2340
to do is insert a

2464
01:00:28,135 --> 01:00:29,095
0,360 360,585 585,705 705,870 870,960
newu and I won't put

2465
01:00:29,095 --> 01:00:29,650
0,105 105,195 195,315 315,465 465,555
at the end. I want

2466
01:00:29,650 --> 01:00:30,475
0,60 60,180 180,375 375,570 570,825
to use this spot here,

2467
01:00:30,475 --> 01:00:31,560
0,365
right?|
|

2468
01:00:31,810 --> 01:00:33,030
0,395 395,635 635,785 785,1025 1025,1220
So, you know, number two
所以，你知道，第二个加就足够了。也许我会记着东西放在哪里，第二面，把它们放在哪里，对吗？

2469
01:00:33,030 --> 01:00:34,230
0,105 105,255 255,560 760,1035 1035,1200
plus is enough. Maybe I

2470
01:00:34,230 --> 01:00:35,850
0,195 195,375 375,650 1060,1395 1395,1620
keep track of where things

2471
01:00:35,850 --> 01:00:37,005
0,240 240,540 540,810 810,1020 1020,1155
are located, second side, where

2472
01:00:37,005 --> 01:00:38,210
0,105 105,195 195,255 255,485 805,1205
to put them in, right?|
|

2473
01:00:38,830 --> 01:00:40,335
0,400 420,650 650,875 875,1265 1265,1505
But, you know, it's going
但是，你知道，它超出了我在这里展示的范围。

2474
01:00:40,335 --> 01:00:41,270
0,225 225,345 390,465 465,630 630,935
beyond what I'm showing here.|
|

2475
01:00:42,420 --> 01:00:44,080
0,90 90,300 300,540 540,830
What's another obvious problem?|
另一个明显的问题是什么？|

2476
01:00:44,080 --> 01:00:46,780
0,225 225,315 315,560 2320,2565 2565,2700
One of the he said
其中一个他说，哪一个太大了，不能在页面上开始？是的，但如果它们不是固定长度，大多数数据都是固定长度，不是固定长度，对吗？

2477
01:00:46,780 --> 01:00:48,010
0,290 310,570 570,645 645,860 970,1230
what one of the too

2478
01:00:48,010 --> 01:00:48,490
0,120 120,240 240,345 345,420 420,480
big to start on the

2479
01:00:48,490 --> 01:00:50,620
0,230 910,1310 1390,1740 1740,1980 1980,2130
page? Yes, but also what

2480
01:00:50,620 --> 01:00:51,700
0,120 120,435 435,675 675,870 870,1080
if they're not the fixed

2481
01:00:51,700 --> 01:00:53,520
0,320 730,1035 1035,1275 1275,1515 1515,1820
length, which most data is,

2482
01:00:53,600 --> 01:00:54,900
0,275 275,485 485,710 710,950 950,1300
is not fixed length, right?|
|

2483
01:00:55,630 --> 01:00:56,595
0,275 275,545 545,710 710,800 800,965
Email addresses aren't the same
电子邮件地址大小不同。Android ID并不相同，总是相同的大小。现在我可以只作为图表类型进行排序，但这会做什么来预先分配我所需的空间？你知道，如果最大的电子邮件地址是1千字节，那么我必须为每个电子邮件地址存储1千字节，即使它不会使用这个空间。

2484
01:00:56,595 --> 01:00:59,205
0,305 1915,2145 2145,2385 2385,2520 2520,2610
size. Android IDs aren't the

2485
01:00:59,205 --> 01:01:00,140
0,180 180,375 375,480 480,630 630,935
same, always the same size.

2486
01:01:00,610 --> 01:01:01,320
0,245 245,365 365,470 470,575 575,710
Now I can just sort

2487
01:01:01,320 --> 01:01:02,160
0,105 105,255 255,495 495,720 720,840
as a chart type, but

2488
01:01:02,160 --> 01:01:02,835
0,75 75,165 165,315 315,510 510,675
what does that do that

2489
01:01:02,835 --> 01:01:04,125
0,135 135,605 685,975 975,1140 1140,1290
pre allocates the space I

2490
01:01:04,125 --> 01:01:06,170
0,275 745,1050 1050,1200 1200,1445 1645,2045
need? And you know, if

2491
01:01:06,370 --> 01:01:08,030
0,260 260,520 780,1085 1085,1325 1325,1660
the largest email address is

2492
01:01:08,230 --> 01:01:09,630
0,290 290,470 470,1060 1080,1325 1325,1400
is one kilobyte then I

2493
01:01:09,630 --> 01:01:10,695
0,75 75,210 210,375 375,540 540,1065
have to store one kilobyte

2494
01:01:10,695 --> 01:01:11,580
0,135 135,270 270,510 510,720 720,885
for every single email address,

2495
01:01:11,580 --> 01:01:12,300
0,180 180,330 330,510 510,615 615,720
even though it's not going

2496
01:01:12,300 --> 01:01:13,130
0,60 60,150 150,330 330,540 540,830
to be using that space.|
|

2497
01:01:13,900 --> 01:01:15,465
0,400 810,1055 1055,1190 1190,1385 1385,1565
Right then, his comment is,
那么，他的评论是，嗯，如果桌子不能放在这一页怎么办？如何向多个页面发送垃圾邮件？

2498
01:01:15,465 --> 01:01:16,155
0,150 150,270 270,360 360,480 480,690
well, what if the table

2499
01:01:16,155 --> 01:01:18,180
0,425 1225,1500 1500,1695 1695,1950 1950,2025
can the table can't fit

2500
01:01:18,180 --> 01:01:19,470
0,60 60,165 165,440 970,1215 1215,1290
in this page? How do

2501
01:01:19,470 --> 01:01:21,140
0,90 90,255 255,480 480,830
I spam multiple pages?|
|

2502
01:01:21,140 --> 01:01:22,175
0,180 180,375 375,570 570,765 765,1035
We discuss that next week,
我们下周将讨论这一点，但这也不会奏效。

2503
01:01:22,175 --> 01:01:23,765
0,365 865,1200 1200,1380 1380,1470 1470,1590
but this also would not

2504
01:01:23,765 --> 01:01:24,640
0,275
work.|
|

2505
01:01:24,640 --> 01:01:25,620
0,290
Right.|
正确的。|

2506
01:01:25,810 --> 01:01:26,910
0,290 290,580 630,875 875,980 980,1100
So clearly, you know, this
所以很明显，你知道，这对我们来说是不够的。我们需要额外的元来跟踪，跟踪我们将如何存储这些内容。另一个问题也是，如果四个，如果四个不能去这里，对，我填补不了空白。

2507
01:01:26,910 --> 01:01:27,585
0,120 120,270 270,450 450,570 570,675
is not enough for us.

2508
01:01:27,585 --> 01:01:28,725
0,135 135,345 345,615 615,1020 1020,1140
We need additional meta to

2509
01:01:28,725 --> 01:01:31,590
0,135 135,330 330,635 2395,2685 2685,2865
keep track of, keep track

2510
01:01:31,590 --> 01:01:33,480
0,290 790,1190 1240,1605 1605,1800 1800,1890
of how we going to

2511
01:01:33,480 --> 01:01:34,890
0,120 120,380 580,915 915,1200 1200,1410
store this. Another problem too

2512
01:01:34,890 --> 01:01:37,395
0,255 255,650 760,1125 1125,1490 2200,2505
is again, if four, if

2513
01:01:37,395 --> 01:01:38,970
0,240 240,525 525,720 720,1055 1285,1575
four couldn't go here, right,

2514
01:01:38,970 --> 01:01:39,890
0,165 165,390 390,525 525,660 660,920
I couldn't fill the gap.|
|

2515
01:01:40,510 --> 01:01:42,015
0,400 510,860 860,1070 1070,1235 1235,1505
Ah, where? When I deleted
啊，在哪里？当我删除两个的时候？如果这里需要四个人，那我就是在浪费空间。但如果我想的话，也许可以再往上移三个。

2516
01:01:42,015 --> 01:01:43,185
0,275 355,645 645,840 840,1035 1035,1170
two? If four needs to

2517
01:01:43,185 --> 01:01:45,150
0,180 180,515 1225,1470 1470,1620 1620,1965
go here then I'm wasting

2518
01:01:45,150 --> 01:01:46,395
0,320 670,915 915,1005 1005,1125 1125,1245
space. But if I want

2519
01:01:46,395 --> 01:01:47,510
0,75 75,240 240,570 570,840 840,1115
to, maybe move three up.|
|

2520
01:01:48,550 --> 01:01:49,695
0,290 290,580 660,905 905,1010 1010,1145
But now I have to
但现在我必须告诉系统的其余部分，我移动了三个。

2521
01:01:49,695 --> 01:01:50,340
0,165 165,300 300,420 420,525 525,645
tell the rest of the

2522
01:01:50,340 --> 01:01:51,680
0,255 255,495 495,675 675,960 960,1340
system that I moved three.|
|

2523
01:01:52,620 --> 01:01:53,510
0,350 350,545 545,635 635,755 755,890
Right, because I have told
对，因为我已经告诉过你们我是如何指向3的，如何找到3的。

2524
01:01:53,510 --> 01:01:54,320
0,120 120,255 255,450 450,615 615,810
you how I'm pointing to

2525
01:01:54,320 --> 01:01:55,480
0,195 195,360 360,510 510,780 780,1160
three how I find three.|
|

2526
01:01:57,090 --> 01:01:57,935
0,305 305,485 485,695 695,770 770,845
But assuming it's going to
但假设这一页中会有一些偏移量，但现在如果我移动三个。

2527
01:01:57,935 --> 01:01:59,810
0,165 165,390 390,675 675,1055 1555,1875
be like some offset within

2528
01:01:59,810 --> 01:02:00,995
0,210 210,500 730,975 975,1080 1080,1185
this page, but now if

2529
01:02:00,995 --> 01:02:02,480
0,165 165,375 375,755
I'm moving three.|
|

2530
01:02:02,590 --> 01:02:03,420
0,365 365,590 590,695 695,770 770,830
Then then I have to
然后我就得去更新所有可能的索引。这或许表明了这一点。

2531
01:02:03,420 --> 01:02:04,545
0,135 135,330 330,540 540,840 840,1125
go update every possible index.

2532
01:02:04,545 --> 01:02:05,475
0,195 195,345 345,525 525,765 765,930
That is maybe pointing to

2533
01:02:05,475 --> 01:02:06,280
0,245
it.|
|

2534
01:02:06,370 --> 01:02:06,745
0,105 105,195 195,255 255,285 285,375
And that's going to be
这将是非常昂贵的。

2535
01:02:06,745 --> 01:02:07,980
0,210 210,545
super expensive.|
|

2536
01:02:09,910 --> 01:02:11,450
0,400 450,710 710,890 890,1175 1175,1540
So the most common approach
因此，处理此问题的最常见方法称为时隙页面。我在这里描述的并不是每个系统是如何做到这一点的，但从更高的层面来看，这就是每个人都在做的事情。如果你是一个面向行的数据库系统，它使用两个面向页面，所以不是日志结构。

2537
01:02:11,560 --> 01:02:13,140
0,275 275,455 455,635 635,910 1290,1580
to handle this problem is

2538
01:02:13,140 --> 01:02:15,195
0,240 240,645 645,920 1630,1920 1920,2055
called slotted pages. And what

2539
01:02:15,195 --> 01:02:16,680
0,195 195,435 435,705 705,1175 1255,1485
I'll describe here isn't, you

2540
01:02:16,680 --> 01:02:17,265
0,105 105,330 330,390 390,435 435,585
know, isn't going to be

2541
01:02:17,265 --> 01:02:18,420
0,255 255,450 450,645 645,915 915,1155
exactly how every system does

2542
01:02:18,420 --> 01:02:19,575
0,290 490,735 735,840 840,960 960,1155
this, but at a high

2543
01:02:19,575 --> 01:02:20,505
0,240 240,420 420,555 555,750 750,930
level, this is what everyone

2544
01:02:20,505 --> 01:02:21,450
0,120 120,300 300,585 585,855 855,945
is doing. If you're a

2545
01:02:21,450 --> 01:02:23,955
0,150 150,420 420,630 630,950 2080,2505
row oriented database system that's

2546
01:02:23,955 --> 01:02:25,580
0,270 270,555 555,930 930,1245 1245,1625
using two oriented pages, so

2547
01:02:25,720 --> 01:02:27,260
0,320 320,575 575,1090
not log structured.|
|

2548
01:02:27,425 --> 01:02:28,130
0,90 90,150 150,330 330,555 555,705
Then they're doing something that
然后他们在做一些看起来像这样的事情。

2549
01:02:28,130 --> 01:02:29,420
0,120 120,270 270,560
looks like this.|
|

2550
01:02:29,870 --> 01:02:30,600
0,245 245,380 380,425 425,485 485,730
So we're going to have,
所以我们会有，我们会有一个标题，跟踪所有的元数据。我们谈到了四个，但在标题之后，我们将拥有这个槽阵列。

2551
01:02:31,580 --> 01:02:32,605
0,290 290,365 365,470 470,740 740,1025
we'll have a header that

2552
01:02:32,605 --> 01:02:33,580
0,270 270,405 405,480 480,695 745,975
keeps track of all the

2553
01:02:33,580 --> 01:02:34,470
0,255 255,345 345,450 450,600 600,890
metadat. We talked about four,

2554
01:02:34,850 --> 01:02:36,120
0,215 215,350 350,635 635,860 860,1270
but then after the header,

2555
01:02:36,770 --> 01:02:38,040
0,290 290,425 425,635 635,920 920,1270
we'll have this slot array.|
|

2556
01:02:38,840 --> 01:02:40,420
0,290 400,800
Where the?|
在哪里？|

2557
01:02:40,640 --> 01:02:42,040
0,290 290,580 660,1025 1025,1250 1250,1400
At every position in that
在该槽中的每个位置，数组将指向我们页面中的几个二进制数。

2558
01:02:42,040 --> 01:02:43,450
0,240 240,560 850,1125 1125,1245 1245,1410
slot, array is going to

2559
01:02:43,450 --> 01:02:46,780
0,270 270,620 1270,1635 1635,2180 3070,3330
point to some twople in

2560
01:02:46,780 --> 01:02:48,060
0,150 150,440
our page.|
|

2561
01:02:48,060 --> 01:02:48,735
0,135 135,270 270,420 420,555 555,675
And the two balls will
这两个球将从页面末尾的底部开始。

2562
01:02:48,735 --> 01:02:49,575
0,120 120,300 300,465 465,600 600,840
be starting at the bottom

2563
01:02:49,575 --> 01:02:50,265
0,225 225,330 330,465 465,600 600,690
at the end of the

2564
01:02:50,265 --> 01:02:51,260
0,245
page.|
|

2565
01:02:51,530 --> 01:02:52,840
0,380 380,760 780,1040 1040,1145 1145,1310
Right. So at the bottom
正确的。所以在底部会有所有固定长度和长度的ta数据。现在，假设一切都放在一起，对吗？如果你有一个非常大的值，它不会存储在单独的页面中。整个表格必须存储在此页面内。

2566
01:02:52,840 --> 01:02:53,500
0,165 165,270 270,390 390,510 510,660
will have all the fixed

2567
01:02:53,500 --> 01:02:54,990
0,165 165,440 640,960 960,1230 1230,1490
length and length ta data.

2568
01:02:55,520 --> 01:02:56,880
0,245 245,485 485,800 800,1040 1040,1360
For now assume that that

2569
01:02:56,990 --> 01:02:58,600
0,320 320,530 530,725 725,1030 1290,1610
everything is put together, right?

2570
01:02:58,600 --> 01:03:00,030
0,165 165,315 315,620 730,1005 1005,1430
So meaning like there isn't,

2571
01:03:00,110 --> 01:03:00,820
0,275 275,395 395,470 470,560 560,710
if you have a really

2572
01:03:00,820 --> 01:03:02,035
0,180 180,450 450,675 675,960 960,1215
large value, it isn't stored

2573
01:03:02,035 --> 01:03:04,285
0,255 255,555 555,875 1135,1535 1915,2250
in separate page. The entire

2574
01:03:04,285 --> 01:03:04,960
0,210 210,315 315,375 375,450 450,675
table has to be stored

2575
01:03:04,960 --> 01:03:06,100
0,180 180,315 315,590
inside this page.|
|

2576
01:03:07,420 --> 01:03:08,385
0,275 275,410 410,530 530,770 770,965
And so the slot array
因此，缝隙阵列将存储固定长度的偏移量，以找到单个管子的起始位置。

2577
01:03:08,385 --> 01:03:08,940
0,150 150,315 315,435 435,480 480,555
is just going to be

2578
01:03:08,940 --> 01:03:11,295
0,290 400,690 690,885 885,1400 2080,2355
storing fixed length offsets to

2579
01:03:11,295 --> 01:03:12,750
0,275 505,765 765,960 960,1185 1185,1455
where to find the starting

2580
01:03:12,750 --> 01:03:15,120
0,375 375,770 940,1275 1275,1730
location of individual tubes.|
|

2581
01:03:15,190 --> 01:03:16,005
0,245 245,365 365,485 485,635 635,815
And maybe you could also
如果你愿意的话，也许你也可以存储大小、tple和页眉。

2582
01:03:16,005 --> 01:03:17,160
0,165 165,455 595,900 900,1050 1050,1155
store the size and the

2583
01:03:17,160 --> 01:03:18,050
0,195 195,240 240,315 315,570 570,890
tple and the header if

2584
01:03:18,160 --> 01:03:19,520
0,260 260,440 440,760
you wanted to.|
|

2585
01:03:19,790 --> 01:03:20,940
0,400
Right.|
正确的。|

2586
01:03:21,380 --> 01:03:22,045
0,245 245,365 455,515 515,590 590,665
So now what's going to
所以现在要发生的事情是，我们需要更新。

2587
01:03:22,045 --> 01:03:23,380
0,195 195,545 685,1035 1035,1230 1230,1335
happen is as we need

2588
01:03:23,380 --> 01:03:24,620
0,180 180,500
to update.|
|

2589
01:03:25,090 --> 01:03:27,315
0,400 540,940 1080,1355 1355,1630 1950,2225
The the the table and
打开表格并添加新页面。抱歉，请在页面内添加新管。插槽阵列将从头到尾增长。

2590
01:03:27,315 --> 01:03:29,385
0,180 180,390 390,695 1255,1655 1795,2070
add new pages. Sorry, add

2591
01:03:29,385 --> 01:03:30,500
0,150 150,525 525,750 750,855 855,1115
new tubes inside the page.

2592
01:03:30,880 --> 01:03:31,890
0,275 275,560 560,785 785,920 920,1010
The slot array is going

2593
01:03:31,890 --> 01:03:33,225
0,105 105,330 330,680 760,1080 1080,1335
to grow from the beginning

2594
01:03:33,225 --> 01:03:34,560
0,180 180,285 285,545
to the end.|
|

2595
01:03:34,560 --> 01:03:35,715
0,255 255,450 450,690 690,900 900,1155
And then all our tubal
然后我们所有的输卵管数据都将从头到尾增长。

2596
01:03:35,715 --> 01:03:36,510
0,180 180,375 375,480 480,600 600,795
data is going to grow

2597
01:03:36,510 --> 01:03:37,890
0,240 240,560 760,1095 1095,1260 1260,1380
from the end to the

2598
01:03:37,890 --> 01:03:39,000
0,290
beginning.|
|

2599
01:03:39,430 --> 01:03:40,365
0,275 275,440 440,635 635,815 815,935
And any single time I
每当我向槽阵列中添加新条目new til时，我都会更新槽阵列，告诉我在哪里可以找到它。

2600
01:03:40,365 --> 01:03:41,780
0,120 120,225 225,420 420,785 1015,1415
add a new entry into

2601
01:03:41,980 --> 01:03:43,760
0,290 290,515 515,820 1110,1385 1385,1780
my slot array, new til,

2602
01:03:43,780 --> 01:03:46,935
0,400 780,1180 2640,2900 2900,3005 3005,3155
I put update the slot

2603
01:03:46,935 --> 01:03:47,775
0,135 135,255 255,375 375,615 615,840
array to tell me where

2604
01:03:47,775 --> 01:03:48,780
0,90 90,195 195,330 330,605
to go find it.|
|

2605
01:03:48,850 --> 01:03:49,900
0,400
Right.|
正确的。|

2606
01:03:50,920 --> 01:03:51,525
0,230 230,335 335,440 440,515 515,605
So now if I go
现在回到我之前遇到的问题，我说我删除了两个，三个，好的，这很好，因为我没有移动其他任何两个池。

2607
01:03:51,525 --> 01:03:52,065
0,120 120,210 210,285 285,420 420,540
back to the problem I

2608
01:03:52,065 --> 01:03:52,875
0,90 90,300 300,495 495,615 615,810
had before where I say

2609
01:03:52,875 --> 01:03:55,970
0,210 210,480 480,690 690,1025 2695,3095
I deleted two, three, well,

2610
01:03:56,320 --> 01:03:58,215
0,275 275,440 440,725 725,1120 1560,1895
this is fine because I

2611
01:03:58,215 --> 01:03:59,265
0,345 345,480 480,645 645,855 855,1050
didn't move any other two

2612
01:03:59,265 --> 01:04:00,340
0,275
pool.|
|

2613
01:04:00,340 --> 01:04:02,140
0,240 240,495 495,735 735,1040 1510,1800
The slot array, still for
插槽数组，仍然是4个，仍然指向它，所以我不会告诉系统的任何其他部分，我移动了。

2614
01:04:02,140 --> 01:04:03,180
0,225 225,450 450,645 645,795 795,1040
four, still points to it,

2615
01:04:03,410 --> 01:04:04,380
0,230 230,305 305,515 515,695 695,970
so I don't tell any

2616
01:04:04,490 --> 01:04:05,290
0,290 290,425 425,500 500,590 590,800
other part of the system

2617
01:04:05,290 --> 01:04:06,720
0,180 180,285 285,480 480,800
that I moved for.|
|

2618
01:04:06,720 --> 01:04:08,610
0,260 640,915 915,1190 1540,1785 1785,1890
Right. But even, you know,
正确的。但是，你知道，如果我现在想要收回ve 3曾经的空间，我删除了，如果我想把3到4个滑动到，你知道，压缩它，他们现在需要做的就是更新屠宰数组，指向新的偏移量。

2619
01:04:08,610 --> 01:04:09,375
0,120 120,270 270,450 450,600 600,765
if I now wanted to

2620
01:04:09,375 --> 01:04:11,240
0,390 390,665 715,1050 1050,1215 1215,1865
reclaim this space that ive

2621
01:04:12,550 --> 01:04:13,140
0,245 245,350 350,440 440,515 515,590
three used to be and

2622
01:04:13,140 --> 01:04:14,415
0,150 150,620 760,1020 1020,1155 1155,1275
I deleted, if I want

2623
01:04:14,415 --> 01:04:15,630
0,150 150,455 475,810 810,1035 1035,1215
to slide three or four

2624
01:04:15,630 --> 01:04:17,550
0,290 580,915 915,1250 1330,1710 1710,1920
over to, to take, you

2625
01:04:17,550 --> 01:04:20,010
0,135 135,480 480,800 1960,2280 2280,2460
know, compact it, all they

2626
01:04:20,010 --> 01:04:20,865
0,135 135,270 270,420 420,585 585,855
need to do now is

2627
01:04:20,865 --> 01:04:21,930
0,255 255,465 465,765 765,945 945,1065
update the slaughter array to

2628
01:04:21,930 --> 01:04:22,760
0,120 120,225 225,300 300,480 480,830
point to the new offset.|
|

2629
01:04:24,580 --> 01:04:25,520
0,245 245,335 335,515 515,695 695,940
Which is easy to do.|
这很容易做到。|

2630
01:04:27,430 --> 01:04:28,515
0,230 230,365 365,545 545,860 860,1085
I don't have to. Again,
我没必要这么做。再说一次，关系模型说他们不必这样做。有些，有些系统有，有些系统没有。我们很快就会看到这一点，对吗？

2631
01:04:28,515 --> 01:04:29,325
0,210 210,420 420,585 585,690 690,810
relational model says they don't

2632
01:04:29,325 --> 01:04:30,225
0,60 60,120 120,195 195,455 625,900
have to do this. Some,

2633
01:04:30,225 --> 01:04:31,290
0,165 165,390 390,660 660,855 855,1065
some systems do, some systems

2634
01:04:31,290 --> 01:04:32,040
0,300 300,435 435,540 540,660 660,750
don't. We'll see this in

2635
01:04:32,040 --> 01:04:33,820
0,90 90,350 670,1070
a second, right?|
|

2636
01:04:33,860 --> 01:04:34,800
0,275 275,395 395,500 500,650 650,940
And this is all fine.|
这一切都很好。|

2637
01:04:37,220 --> 01:04:38,100
0,245 245,335 335,410 410,515 515,880
So this is what sql
这就是SQL实际上不知道的，SQL做到了这一点，但Postgres所做的，SQL，SQL SERVER，不带页面是最常见的方法。这是每个人都会做的事。

2638
01:04:38,720 --> 01:04:39,940
0,395 395,500 500,785 785,965 965,1220
actuallyt know, sql does this,

2639
01:04:39,940 --> 01:04:42,540
0,270 270,435 435,765 765,1040 2140,2600
but what postgres does, sql,

2640
01:04:42,800 --> 01:04:45,175
0,365 365,485 485,2045 2045,2210 2210,2375
sql server, doesotted pages is

2641
01:04:45,175 --> 01:04:45,970
0,60 60,165 165,375 375,615 615,795
the most common approach. This

2642
01:04:45,970 --> 01:04:47,280
0,105 105,270 270,435 435,680
is what everyone does.|
|

2643
01:04:47,670 --> 01:04:48,840
0,400
EM.|
嗯。|

2644
01:04:50,910 --> 01:04:52,040
0,400
Yes.|
是。|

2645
01:04:56,200 --> 01:04:57,680
0,260 260,520 660,905 905,1025 1025,1480
This question, can I reuse
这个问题，我可以重复使用插槽位置3吗？但我没必要把这个放在四个人前面，对吗？我可以把它放在任何地方。

2646
01:04:57,820 --> 01:05:01,410
0,335 335,620 620,1000 3210,3455 3455,3590
slot position three? But I

2647
01:05:01,410 --> 01:05:02,415
0,285 285,435 435,615 615,810 810,1005
don't have to put that

2648
01:05:02,415 --> 01:05:03,915
0,210 210,375 375,540 540,845 1225,1500
in front of four, right?

2649
01:05:03,915 --> 01:05:04,670
0,120 120,210 210,285 285,435 435,755
I can put it anywhere.|
|

2650
01:05:08,310 --> 01:05:09,620
0,275 275,550
Other questions?|
还有其他问题吗？|

2651
01:05:10,830 --> 01:05:11,980
0,400
Yes.|
是。|

2652
01:05:13,960 --> 01:05:15,480
0,420 420,645 645,975 975,1230 1230,1520
Wasting a small amount of.|
浪费了少量的。|

2653
01:05:18,370 --> 01:05:19,635
0,305 305,425 425,640 690,1055 1055,1265
Yeah, so her statement, her
是的，所以她的陈述，她的问题是，如果这两个长度是可变的，这不是在浪费空间吗？是啊，所以。

2654
01:05:19,635 --> 01:05:20,550
0,150 150,420 420,720 720,795 795,915
question is, wouldn't this be

2655
01:05:20,550 --> 01:05:22,605
0,375 375,710 940,1305 1305,1620 1620,2055
wasting space if the twoils

2656
01:05:22,605 --> 01:05:24,710
0,335 355,720 720,1085 1375,1740 1740,2105
are variable length? Yeah, so

2657
01:05:24,760 --> 01:05:26,000
0,400
the.|
|

2658
01:05:26,130 --> 01:05:27,490
0,380 380,665 665,950 950,1085 1085,1360
Again, my tubils are growing
再一次，我的长号是从两个，从，从两个。数据是从头到尾的。斯鲁蒂将从头到尾。在某种程度上，我会用完空间，可能会有一点，你知道，中间的一点空间我不能用来做任何事情。这是浪费吗？是。

2659
01:05:28,050 --> 01:05:30,040
0,305 305,610 1170,1520 1520,1730 1730,1990
from the, from, from the

2660
01:05:30,270 --> 01:05:31,115
0,365 365,470 470,575 575,710 710,845
twoa. Data is going from

2661
01:05:31,115 --> 01:05:31,930
0,105 105,270 270,405 405,525 525,815
the end to the beginning.

2662
01:05:32,580 --> 01:05:33,380
0,440 440,515 515,620 620,710 710,800
Sloty is going from the

2663
01:05:33,380 --> 01:05:34,460
0,105 105,180 180,255 255,500 760,1080
beginning to the end. At

2664
01:05:34,460 --> 01:05:35,150
0,255 255,465 465,615 615,645 645,690
some point, I'm going to

2665
01:05:35,150 --> 01:05:35,855
0,90 90,195 195,330 330,540 540,705
run out of space and

2666
01:05:35,855 --> 01:05:36,380
0,90 90,180 180,255 255,360 360,525
there might be a little

2667
01:05:36,380 --> 01:05:38,380
0,150 150,410 760,1005 1005,1250 1600,2000
bit of, you know, little

2668
01:05:38,670 --> 01:05:39,680
0,275 275,380 380,455 455,700 780,1010
space in the middle that

2669
01:05:39,680 --> 01:05:40,385
0,90 90,240 240,330 330,510 510,705
I can't use for anything.

2670
01:05:40,385 --> 01:05:41,920
0,105 105,210 210,585 585,905
Is that wasted? Yes.|
|

2671
01:05:42,660 --> 01:05:43,865
0,275 275,470 470,740 740,995 995,1205
But the advantage we get
但我们获得的优势是，每当我们洗牌时，不必更新其他东西，插槽阵列的成本是值得的。

2672
01:05:43,865 --> 01:05:46,175
0,195 195,420 420,750 750,1145 2035,2310
of not having to update

2673
01:05:46,175 --> 01:05:48,790
0,210 210,545 1105,1710 1710,2070 2070,2615
other things anytime we shuffle

2674
01:05:49,200 --> 01:05:50,290
0,260 260,425 425,575 575,770 770,1090
the order, the slot array

2675
01:05:50,550 --> 01:05:52,580
0,400 540,830 830,1025 1025,1330
is worth that cost.|
|

2676
01:05:58,470 --> 01:05:59,620
0,400
Okay.|
好吧。|

2677
01:06:00,010 --> 01:06:01,965
0,245 245,490 1410,1700 1700,1865 1865,1955
So now, assuming we sort
所以现在，假设我们认为有缝隙的页面。

2678
01:06:01,965 --> 01:06:02,780
0,75 75,195 195,330 330,570 570,815
of thinking the slotted pages.|
|

2679
01:06:04,450 --> 01:06:05,205
0,290 290,425 425,515 515,605 605,755
Now we need a way
现在我们需要一种方法来识别两个极点。

2680
01:06:05,205 --> 01:06:07,680
0,305 325,725 1255,1515 1515,1865
to identify two poles.|
|

2681
01:06:09,190 --> 01:06:10,200
0,305 305,575 575,815 815,905 905,1010
And this this one, we're
这一次，我们将使用记录ID的概念。不同的数据系统可能会将其称为行ID或行号，但这是一种更高层次的思考方式。这是一种唯一识别的方式。

2682
01:06:10,200 --> 01:06:11,550
0,45 45,105 105,350 970,1215 1215,1350
going to use the notion

2683
01:06:11,550 --> 01:06:13,215
0,135 135,255 255,435 435,740 1360,1665
of a record ID. Different

2684
01:06:13,215 --> 01:06:14,505
0,210 210,515 745,1020 1020,1155 1155,1290
data systems may call this

2685
01:06:14,505 --> 01:06:15,510
0,135 135,270 270,545 625,885 885,1005
the row ID or the

2686
01:06:15,510 --> 01:06:17,085
0,150 150,440 1090,1335 1335,1425 1425,1575
row number, but a high

2687
01:06:17,085 --> 01:06:17,985
0,305 385,630 630,720 720,795 795,900
level, the way to think

2688
01:06:17,985 --> 01:06:19,200
0,120 120,365 385,750 750,975 975,1215
about it. It is a

2689
01:06:19,200 --> 01:06:21,420
0,285 285,435 435,1040 1120,1520
way to uniquely identify.|
|

2690
01:06:21,420 --> 01:06:24,015
0,270 270,885 885,1370 2110,2430 2430,2595
Some logical til based on
某些逻辑分块基于其在页面内文件中的物理位置。

2691
01:06:24,015 --> 01:06:26,115
0,165 165,485 775,1175 1705,1980 1980,2100
its physical location inside of

2692
01:06:26,115 --> 01:06:26,880
0,120 120,375 375,600 600,675 675,765
a file inside of a

2693
01:06:26,880 --> 01:06:27,880
0,260
page.|
|

2694
01:06:28,140 --> 01:06:28,970
0,260 260,440 440,605 605,755 755,830
And it's typically going to
它通常是文件号、身份证号、页码的组合。

2695
01:06:28,970 --> 01:06:30,020
0,60 60,165 165,440 520,840 840,1050
be a combination of a

2696
01:06:30,020 --> 01:06:31,450
0,225 225,510 510,705 705,950 1030,1430
file number, an ID number,

2697
01:06:31,920 --> 01:06:33,620
0,305 305,545 545,880
the page number.|
|

2698
01:06:33,620 --> 01:06:34,520
0,120 120,255 255,420 420,675 675,900
And then the slot number
然后是对应于它们在该时隙阵列中存在的位置的时隙编号。

2699
01:06:34,520 --> 01:06:35,825
0,210 210,690 690,900 900,1125 1125,1305
that corresponds where they exist

2700
01:06:35,825 --> 01:06:37,260
0,105 105,240 240,510 510,845
in that slot array.|
|

2701
01:06:37,390 --> 01:06:38,265
0,245 245,395 395,605 605,770 770,875
So that when you want
所以当你想查一下我需要的时候，我需要这两个泳池。如果您有记录ID，则可以查看页面目录，然后获取该页面，以确定哪个页面具有该记录ID。然后使用插槽内的插槽编号，找出您知道该页面内的哪些非站点内容包含您要查找的数据的位置。

2702
01:06:38,265 --> 01:06:39,300
0,90 90,195 195,330 330,780 780,1035
to do a lookup to

2703
01:06:39,300 --> 01:06:40,470
0,165 165,360 360,650 760,1020 1020,1170
say I need, I need

2704
01:06:40,470 --> 01:06:41,655
0,180 180,360 360,650 790,1065 1065,1185
this two pool. If you

2705
01:06:41,655 --> 01:06:43,080
0,120 120,240 240,405 405,725 1195,1425
have the record ID, you

2706
01:06:43,080 --> 01:06:43,635
0,75 75,195 195,330 330,435 435,555
would then look in the

2707
01:06:43,635 --> 01:06:44,400
0,210 210,510 510,555 555,645 645,765
page directory and to figure

2708
01:06:44,400 --> 01:06:45,500
0,120 120,300 300,555 555,795 795,1100
out what page has it,

2709
01:06:45,820 --> 01:06:47,550
0,320 320,545 545,770 770,1090 1350,1730
go grab that page. Then

2710
01:06:47,550 --> 01:06:48,600
0,270 270,420 420,630 630,840 840,1050
use the slot number inside

2711
01:06:48,600 --> 01:06:49,560
0,135 135,375 375,585 585,705 705,960
the slot to figure out

2712
01:06:49,560 --> 01:06:50,955
0,380 610,840 840,1005 1005,1230 1230,1395
where you know what what

2713
01:06:50,955 --> 01:06:51,915
0,180 180,390 390,555 555,690 690,960
off site inside that page

2714
01:06:51,915 --> 01:06:52,785
0,270 270,405 405,555 555,720 720,870
has the data you're looking

2715
01:06:52,785 --> 01:06:53,520
0,335
for.|
|

2716
01:06:54,510 --> 01:06:55,775
0,245 245,425 425,935 935,1100 1100,1265
So most databases will not
所以大多数数据库不会存储这个记录ID。这是一个合成的，具体化的东西，再次基于你知道的页面目录，或者你如何跟踪如何找到有意义的东西，比如在字节日期本身，我没有存储这个记录ID。

2717
01:06:55,775 --> 01:06:56,690
0,165 165,300 300,465 465,705 705,915
store this record ID. This

2718
01:06:56,690 --> 01:06:58,270
0,120 120,270 270,540 540,1035 1035,1580
is something that's synthesized, materialize,

2719
01:06:58,440 --> 01:06:59,450
0,365 365,620 620,755 755,845 845,1010
again, based on the page

2720
01:06:59,450 --> 01:07:01,060
0,500 580,840 840,990 990,1245 1245,1610
directory you know of, of

2721
01:07:02,430 --> 01:07:03,440
0,275 275,500 500,725 725,860 860,1010
or how how you keep

2722
01:07:03,440 --> 01:07:04,250
0,165 165,375 375,555 555,660 660,810
track of how to find

2723
01:07:04,250 --> 01:07:05,735
0,290 400,720 720,930 930,1215 1215,1485
things meaning like within the

2724
01:07:05,735 --> 01:07:06,980
0,240 240,495 495,825 825,1095 1095,1245
tubil date itself, I'm not

2725
01:07:06,980 --> 01:07:08,600
0,285 285,465 465,645 645,950
storing this record ID.|
|

2726
01:07:08,640 --> 01:07:09,970
0,410 410,575 575,815 815,1040 1040,1330
Sql light does store this
SQL light确实将它存储为一个单独的列，您不应该看到它，但您可以访问它。而他们这样做的原因是因为这就是他们要做的。

2727
01:07:10,470 --> 01:07:11,650
0,260 260,365 365,545 545,830 830,1180
as a separate column that

2728
01:07:11,670 --> 01:07:12,725
0,410 410,620 620,770 770,905 905,1055
you're not supposed to see,

2729
01:07:12,725 --> 01:07:13,355
0,120 120,225 225,360 360,510 510,630
but you can get to

2730
01:07:13,355 --> 01:07:14,690
0,245 625,885 885,1005 1005,1170 1170,1335
it. And the way they

2731
01:07:14,690 --> 01:07:15,500
0,210 210,420 420,570 570,705 705,810
do, the reason why they

2732
01:07:15,500 --> 01:07:16,265
0,120 120,240 240,405 405,600 600,765
do this is because this

2733
01:07:16,265 --> 01:07:17,320
0,150 150,345 345,555 555,720 720,1055
is how they're going to.|
|

2734
01:07:18,480 --> 01:07:19,085
0,260 260,350 350,410 410,470 470,605
These are going to use
他们将使用这个，使用这个作为主键，以允许他们识别单独的两个。所以，如果像我一样，我们还没有讨论过二级索引，但我有，如果我有一个索引，那不是主键索引。

2735
01:07:19,085 --> 01:07:19,985
0,225 225,435 435,600 600,750 750,900
this, use this as the

2736
01:07:19,985 --> 01:07:20,915
0,275 295,570 570,690 690,825 825,930
primary key to allow them

2737
01:07:20,915 --> 01:07:23,555
0,215 235,635 1135,1470 1470,1925 2425,2640
to identify individual twoles. So

2738
01:07:23,555 --> 01:07:24,440
0,75 75,180 180,425 475,765 765,885
if like I, we, we

2739
01:07:24,440 --> 01:07:25,370
0,150 150,225 225,405 405,630 630,930
haven't talked about secondary indexes,

2740
01:07:25,370 --> 01:07:25,955
0,90 90,150 150,330 330,525 525,585
but I have, if I

2741
01:07:25,955 --> 01:07:26,855
0,60 60,225 225,495 495,810 810,900
have an index, that's not

2742
01:07:26,855 --> 01:07:28,460
0,105 105,315 315,555 555,845
the primary key index.|
|

2743
01:07:28,750 --> 01:07:30,590
0,400 660,995 995,1330 1350,1595 1595,1840
My, my value when I,
我，我的值，当我，当我在一个键上进行查找时，我将是那个行ID，然后我在主键的行ID索引中使用它来查找我需要的数据。

2744
01:07:30,610 --> 01:07:31,665
0,365 365,590 590,695 695,815 815,1055
when I do my lookup

2745
01:07:31,665 --> 01:07:32,670
0,90 90,210 210,485 625,900 900,1005
on a key is going

2746
01:07:32,670 --> 01:07:33,330
0,60 60,150 150,285 285,435 435,660
to be that row ID

2747
01:07:33,330 --> 01:07:34,425
0,210 210,345 345,555 555,870 870,1095
which I then use in

2748
01:07:34,425 --> 01:07:35,520
0,120 120,390 390,690 690,855 855,1095
the primary key row ID

2749
01:07:35,520 --> 01:07:36,330
0,270 270,420 420,555 555,675 675,810
index to find the data

2750
01:07:36,330 --> 01:07:37,240
0,150 150,410
I need.|
|

2751
01:07:37,900 --> 01:07:39,110
0,320 320,560 560,740 740,905 905,1210
Different systems do different things.|
不同的系统做不同的事情。|

2752
01:07:40,720 --> 01:07:41,745
0,275 275,440 440,680 680,890 890,1025
So, the size of this
因此，这一规模将根据实现实施的不同而不同。因此，postgres将是6，6个字节，而SQLTE将是8个字节或64位。SQL服务器有一个8字节的ID，然后Oracle有一个10字节的记录ID。

2753
01:07:41,745 --> 01:07:43,500
0,150 150,255 255,360 360,635 1495,1755
is going to vary based

2754
01:07:43,500 --> 01:07:44,985
0,135 135,300 300,590 850,1125 1125,1485
on implementation implementation. So postgres

2755
01:07:44,985 --> 01:07:45,590
0,120 120,180 180,210 210,315 315,605
is going to be six,

2756
01:07:45,820 --> 01:07:47,895
0,305 305,790 1380,1880 1880,1985 1985,2075
six bytes, sqltes going be

2757
01:07:47,895 --> 01:07:48,950
0,135 135,360 360,465 465,795 795,1055
eight bytes or 64 bits.

2758
01:07:49,930 --> 01:07:50,880
0,380 380,545 545,710 710,815 815,950
Sql server has an eight

2759
01:07:50,880 --> 01:07:51,780
0,195 195,330 330,465 465,570 570,900
byte one and then Oracle

2760
01:07:51,780 --> 01:07:54,765
0,260 1120,1395 1395,1560 1560,1970 2680,2985
has a ten byte record

2761
01:07:54,765 --> 01:07:55,620
0,305
ID.|
|

2762
01:07:56,150 --> 01:07:57,310
0,320 320,500 500,695 695,935 935,1160
Again, you can see this
同样，您可以在数据库系统中直接看到这一点，所以我们可以做一个快速演示来向您展示所有这些。

2763
01:07:57,310 --> 01:07:58,260
0,225 225,360 360,435 435,615 615,950
directly in the database system

2764
01:07:59,000 --> 01:07:59,530
0,230 230,290 290,350 350,425 425,530
so we can do a

2765
01:07:59,530 --> 01:08:00,490
0,135 135,315 315,480 480,720 720,960
quick demo just to show

2766
01:08:00,490 --> 01:08:02,200
0,105 105,210 210,470
you all this.|
|

2767
01:08:04,890 --> 01:08:05,810
0,275 275,440 440,590 590,770 770,920
So you're not supposed to
所以你不应该在你的应用程序中使用这个，对吗？因此，尽管这将唯一地识别一个。

2768
01:08:05,810 --> 01:08:06,890
0,225 225,420 420,525 525,735 735,1080
use this in your application,

2769
01:08:06,890 --> 01:08:08,285
0,380 640,900 900,1065 1065,1245 1245,1395
right? So even though this

2770
01:08:08,285 --> 01:08:11,200
0,135 135,690 690,1085 1195,1595
would uniquely identify a.|
|

2771
01:08:11,210 --> 01:08:13,015
0,290 290,730 1020,1385 1580,1670 1670,1805
A to, again, it's the
A到，再一次，这是它的物理位置。

2772
01:08:13,015 --> 01:08:14,840
0,275 355,690 690,900 900,1175
physical location of it.|
|

2773
01:08:14,880 --> 01:08:16,670
0,275 275,425 425,605 605,910 1440,1790
And it could change meaning,
它可能会改变意义，比如我插入一个TIL，然后我就会得到一个记录ID。

2774
01:08:16,670 --> 01:08:18,500
0,345 345,660 660,980 1300,1710 1710,1830
like if I insert a

2775
01:08:18,500 --> 01:08:19,895
0,410 820,1080 1080,1200 1200,1305 1305,1395
til and I get a

2776
01:08:19,895 --> 01:08:21,680
0,165 165,485
record ID.|
|

2777
01:08:21,900 --> 01:08:23,990
0,400 450,830 830,1210 1290,1595 1595,2090
If my application then references
如果我的应用程序随后引用了它，问题可能就像我可以运行压缩或垃圾回收一样。在Postgres中，这被称为真空，我可以在其中重新组织页面，现在可能会更改插槽编号或页码。现在我要找的东西已经不在那里了。同样，这是数据库系统的一个物理方面，我们不应该在我们的应用程序中真正使用它，但它对我们是公开的，因为如果我们需要管理和维护这些系统，我们需要知道数据实际在哪里。

2778
01:08:23,990 --> 01:08:25,355
0,260 580,855 855,1050 1050,1215 1215,1365
it, the problem could be

2779
01:08:25,355 --> 01:08:26,525
0,255 255,480 480,615 615,750 750,1170
like I could run compaction

2780
01:08:26,525 --> 01:08:27,800
0,225 225,525 525,750 750,990 990,1275
or garbage collection. In postgres

2781
01:08:27,800 --> 01:08:29,230
0,150 150,240 240,360 360,800 1030,1430
it's called the vacuum where

2782
01:08:29,520 --> 01:08:30,860
0,275 275,410 410,950 950,1130 1130,1340
I could reorganize that page

2783
01:08:30,860 --> 01:08:31,745
0,195 195,375 375,555 555,705 705,885
where maybe now the slot

2784
01:08:31,745 --> 01:08:32,990
0,195 195,515 685,945 945,1080 1080,1245
number changes or the page

2785
01:08:32,990 --> 01:08:33,995
0,195 195,450 450,660 660,840 840,1005
number changes. And now the

2786
01:08:33,995 --> 01:08:34,760
0,90 90,240 240,360 360,525 525,765
thing I'm looking for isn't

2787
01:08:34,760 --> 01:08:36,080
0,210 210,560 760,1035 1035,1185 1185,1320
there anymore. So again, this

2788
01:08:36,080 --> 01:08:37,385
0,105 105,240 240,530 880,1170 1170,1305
is a physical aspect of

2789
01:08:37,385 --> 01:08:38,225
0,90 90,270 270,510 510,675 675,840
the database system that we're

2790
01:08:38,225 --> 01:08:39,280
0,105 105,240 240,330 330,575 655,1055
not supposed to really use

2791
01:08:39,570 --> 01:08:41,705
0,245 245,440 440,790 1050,1450 1710,2135
in our application, but it's

2792
01:08:41,705 --> 01:08:43,055
0,270 270,450 450,660 660,1025 1105,1350
exposed to us because if

2793
01:08:43,055 --> 01:08:43,790
0,90 90,210 210,345 345,660 660,735
we need to administer and

2794
01:08:43,790 --> 01:08:45,185
0,210 210,465 465,740 1030,1275 1275,1395
maintain these systems, we need

2795
01:08:45,185 --> 01:08:46,280
0,120 120,365 535,795 795,900 900,1095
to know where the data

2796
01:08:46,280 --> 01:08:47,220
0,195 195,440
actually is.|
|

2797
01:08:51,160 --> 01:08:51,915
0,275 275,395 395,485 485,605 605,755
So let me log in
所以让我快速登录。抱歉的。

2798
01:08:51,915 --> 01:08:53,640
0,210 210,545
quickly. Sorry.|
|

2799
01:09:01,680 --> 01:09:03,760
0,260 260,380 380,485 485,880
We need to reconnect.|
我们需要重新连接。|

2800
01:09:04,710 --> 01:09:05,360
0,245 245,380 380,485 485,545 545,650
All right, so I do
好的，那我先做波斯特格雷斯。

2801
01:09:05,360 --> 01:09:07,700
0,285 285,560
postgres first.|
|

2802
01:09:08,135 --> 01:09:08,810
0,150 150,210 210,285 285,465 465,675
So we're going to create
所以我们要创建一个非常简单的表r。

2803
01:09:08,810 --> 01:09:09,850
0,135 135,300 300,495 495,720 720,1040
a really simple table r.|
|

2804
01:09:11,730 --> 01:09:13,120
0,260 260,410 410,700 720,995 995,1390
That just has three twoils.|
那只有三个两毛钱。|

2805
01:09:16,000 --> 01:09:17,985
0,400 900,1535 1535,1640 1640,1820 1820,1985
Right 101 o one one
好的101-01-1-02。

2806
01:09:17,985 --> 01:09:19,120
0,120 120,395
o two.|
|

2807
01:09:19,520 --> 01:09:20,695
0,305 305,725 725,845 845,1010 1010,1175
So postgresl has something called
因此，postgresl有一种叫做ctid的东西。

2808
01:09:20,695 --> 01:09:22,560
0,135 135,635
the ctid.|
|

2809
01:09:23,510 --> 01:09:24,430
0,335 335,545 545,695 695,815 815,920
And this is going to
这将是一场双人对决。现在，它将给你页码，然后是槽号。这两个加号在0页，1号槽，2号槽，3号槽。

2810
01:09:24,430 --> 01:09:26,530
0,260 340,645 645,975 975,1250 1660,2100
be a twoo. Now that's

2811
01:09:26,530 --> 01:09:27,420
0,75 75,180 180,330 330,555 555,890
going to give you the

2812
01:09:27,620 --> 01:09:29,185
0,350 350,700 1020,1280 1280,1415 1415,1565
page number and then the

2813
01:09:29,185 --> 01:09:30,910
0,195 195,485 1105,1365 1365,1545 1545,1725
slot number. So these two

2814
01:09:30,910 --> 01:09:31,795
0,135 135,315 315,450 450,615 615,885
plus here are at page

2815
01:09:31,795 --> 01:09:33,820
0,335 745,1065 1065,1355 1465,1800 1800,2025
zero, slot one, slot two,

2816
01:09:33,820 --> 01:09:35,000
0,255 255,560
slot three.|
|

2817
01:09:35,000 --> 01:09:36,060
0,320
Right.|
正确的。|

2818
01:09:37,770 --> 01:09:40,380
0,245 245,490 840,1220 1220,1600
So now if I.|
所以现在如果我。|

2819
01:09:40,510 --> 01:09:41,355
0,230 230,380 380,560 560,680 680,845
Say I delete the second
比方说，我删除了第二个，我删除了一对一。

2820
01:09:41,355 --> 01:09:42,360
0,345 345,570 570,765 765,900 900,1005
to I delete one on

2821
01:09:42,360 --> 01:09:43,460
0,260
one.|
|

2822
01:09:43,630 --> 01:09:44,400
0,290 290,425 425,515 515,605 605,770
Now when I do my
现在当我再次扫描的时候。

2823
01:09:44,400 --> 01:09:46,240
0,320 640,1040
scan again.|
|

2824
01:09:46,420 --> 01:09:47,235
0,275 275,395 395,500 500,635 635,815
Now you can see that
现在你可以看到，波斯格雷斯方面删除了这两个人。

2825
01:09:47,235 --> 01:09:49,430
0,540 540,905 1195,1635 1635,1785 1785,2195
postgres side deleted the twople.|
|

2826
01:09:51,630 --> 01:09:52,760
0,230 230,320 560,785 785,920 920,1130
But it didn't move things
但它并没有移动东西。

2827
01:09:52,760 --> 01:09:53,780
0,320
around.|
|

2828
01:09:54,200 --> 01:09:55,180
0,260 260,395 395,530 530,710 710,980
And let the data where
并让数据位于其实际存储的位置。

2829
01:09:55,180 --> 01:09:57,180
0,350 1150,1395 1395,1560 1560,1740 1740,2000
actually where it actually lives.|
|

2830
01:09:59,810 --> 01:10:00,960
0,260 260,380 380,500 500,680 680,1150
But I can run garbage,
但我可以运行垃圾，垃圾收集。

2831
01:10:01,010 --> 01:10:02,880
0,245 245,500 500,760
the garbage collection.|
|

2832
01:10:03,650 --> 01:10:04,855
0,380 380,725 725,935 935,1010 1010,1205
Let me start a ta
让我开始给你回个电话。

2833
01:10:04,855 --> 01:10:06,300
0,245
back.|
|

2834
01:10:06,430 --> 01:10:07,185
0,230 230,350 350,500 500,620 620,755
So I start one of
所以我开始了三个中的一个。

2835
01:10:07,185 --> 01:10:08,360
0,275
three.|
|

2836
01:10:09,400 --> 01:10:10,305
0,260 260,365 365,470 470,635 635,905
Now you can see again,
现在你可以再次看到，它没有从我删除的前两个位置中拿走o两个位置。

2837
01:10:10,305 --> 01:10:12,020
0,255 255,660 660,930 930,1235 1315,1715
it didn't take that that

2838
01:10:12,040 --> 01:10:13,425
0,395 395,710 710,950 950,1220 1220,1385
that o two slot from

2839
01:10:13,425 --> 01:10:14,480
0,105 105,255 255,420 420,615 615,1055
the first two I deleted.|
|

2840
01:10:15,100 --> 01:10:15,790
0,60 60,135 135,435 435,615 615,690
It is appended to the
它被附加到末尾，放在第四个槽中。

2841
01:10:15,790 --> 01:10:16,540
0,195 195,390 390,450 450,555 555,750
end, put it in slot

2842
01:10:16,540 --> 01:10:17,480
0,290
four.|
|

2843
01:10:18,090 --> 01:10:19,160
0,400
Right.|
正确的。|

2844
01:10:20,830 --> 01:10:21,810
0,245 245,470 470,710 710,815 815,980
So then I can now
那么我现在就可以运行。

2845
01:10:21,810 --> 01:10:23,880
0,270 270,620
run the.|
|

2846
01:10:23,950 --> 01:10:24,930
0,275 275,425 425,740 740,890 890,980
Getting in postgres it's called
进入波斯格雷斯，这被称为真空。

2847
01:10:24,930 --> 01:10:26,260
0,120 120,560
a vacuum.|
|

2848
01:10:29,040 --> 01:10:30,350
0,335 335,545 545,695 695,845 845,1310
So the command is vacuum.
所以命令是Vacuum。同样，这是Postgres的习语，所以Vacuum Full基本上就是Postgres。

2849
01:10:30,350 --> 01:10:31,160
0,240 240,360 360,450 450,540 540,810
Again, this is a postgres

2850
01:10:31,160 --> 01:10:33,410
0,410 820,1095 1095,1515 1515,1850 1960,2250
idiom, so vacuum full is

2851
01:10:33,410 --> 01:10:34,960
0,135 135,240 240,495 495,1100 1150,1550
going to have postgres basically.|
|

2852
01:10:36,020 --> 01:10:37,295
0,465 465,705 705,915 915,1110 1110,1275
Compact every single page and
压缩每一页，写出新的页面，新的文件。

2853
01:10:37,295 --> 01:10:38,780
0,150 150,345 345,555 555,845 1135,1485
write out a new page,

2854
01:10:38,780 --> 01:10:40,120
0,225 225,500
new files.|
|

2855
01:10:40,120 --> 01:10:41,305
0,165 165,380 790,1020 1020,1095 1095,1185
So I I have a
所以我我有一大堆空白的页面。它将在创建新版本时发布它们。

2856
01:10:41,305 --> 01:10:42,280
0,90 90,195 195,375 375,695 715,975
bunch of pages that are

2857
01:10:42,280 --> 01:10:44,635
0,260 610,1350 1350,1515 1515,1820 2110,2355
empty. It'll release them when

2858
01:10:44,635 --> 01:10:45,810
0,245 385,675 675,810 810,915 915,1175
it creates a new version.|
|

2859
01:10:47,130 --> 01:10:47,945
0,245 245,440 440,620 620,710 710,815
So now when I do
所以现在，当我以前做同样的查询时，现在，你看到它的紧凑，对吗？一零二零三。

2860
01:10:47,945 --> 01:10:49,720
0,120 120,285 285,495 495,785 1375,1775
that same query before, right

2861
01:10:49,920 --> 01:10:51,155
0,305 305,470 470,725 725,965 965,1235
now, you see it compact

2862
01:10:51,155 --> 01:10:54,095
0,135 135,255 255,545 1105,1505 2635,2940
of it, right? One o

2863
01:10:54,095 --> 01:10:56,000
0,165 165,330 330,635
two o three.|
|

2864
01:10:58,410 --> 01:11:00,005
0,260 260,520 780,1180 1260,1490 1490,1595
Makes sense, yes. So is
是的，这说得通。那么这是CID指的是吗？

2865
01:11:00,005 --> 01:11:01,955
0,275 505,765 765,1175 1195,1710 1710,1950
this the cid referring to

2866
01:11:01,955 --> 01:11:02,880
0,275
the?|
|

2867
01:11:03,550 --> 01:11:05,320
0,275 275,470 470,740 740,1090
Page number and offset.|
页码和偏移量。|

2868
01:11:05,900 --> 01:11:09,380
0,305 305,580
Slot number.|
插槽编号。|

2869
01:11:09,730 --> 01:11:10,950
0,320 320,665 665,890 890,1100 1100,1220
Going backwards or in the
向后移动或在槽阵列中移动。

2870
01:11:10,950 --> 01:11:11,940
0,225 225,560
slot array.|
|

2871
01:11:11,980 --> 01:11:12,950
0,245 245,335 335,440 440,650 650,970
Is in the slot array
位于槽阵列中，因为如果您使用槽阵列来表示页面中的偏移量，我能找到我需要的内容吗？

2872
01:11:13,330 --> 01:11:14,160
0,245 245,335 335,455 455,650 650,830
because if you use the

2873
01:11:14,160 --> 01:11:15,140
0,225 225,390 390,510 510,675 675,980
slot array to say what

2874
01:11:15,160 --> 01:11:16,575
0,400 720,1010 1010,1160 1160,1310 1310,1415
offset within the page, do

2875
01:11:16,575 --> 01:11:17,270
0,75 75,210 210,330 330,435 435,695
I find what I need?|
|

2876
01:11:18,130 --> 01:11:19,770
0,400 600,890 890,1385 1385,1565 1565,1640
Yes, the sly seem to
是的，狡猾似乎是一个指数，因为有一些东西是零的。

2877
01:11:19,770 --> 01:11:21,105
0,150 150,465 465,840 840,1080 1080,1335
be one index, because there's

2878
01:11:21,105 --> 01:11:22,520
0,225 225,495 495,815 865,1185 1185,1415
something at zero that's like.|
|

2879
01:11:24,020 --> 01:11:25,615
0,245 245,395 395,700 1080,1355 1355,1595
The question is the slot
问题是槽阵列从零索引开始，即使页零索引，对不起，槽阵列从一个索引开始，页从零索引开始。里面有什么东西吗？合二为一？让我们来找出答案。所以你不应该这么做，但你可以这么做。您实际上可以查询此c_tid等于。

2880
01:11:25,615 --> 01:11:26,980
0,305 415,720 720,900 900,1125 1125,1365
array starts at zero index

2881
01:11:26,980 --> 01:11:28,435
0,150 150,240 240,345 345,620 1090,1455
even though the page zero

2882
01:11:28,435 --> 01:11:29,680
0,270 270,575 595,930 930,1110 1110,1245
index, sorry, slot array starts

2883
01:11:29,680 --> 01:11:31,225
0,135 135,345 345,680 1060,1365 1365,1545
at one index, page starts

2884
01:11:31,225 --> 01:11:32,170
0,165 165,405 405,660 660,810 810,945
at zero index. Is there

2885
01:11:32,170 --> 01:11:34,645
0,240 240,590 1420,1710 1710,2000 2140,2475
something in? In one? Let's

2886
01:11:34,645 --> 01:11:35,920
0,105 105,365 685,990 990,1200 1200,1275
find out. So you're not

2887
01:11:35,920 --> 01:11:36,790
0,120 120,225 225,330 330,555 555,870
supposed to do this, but

2888
01:11:36,790 --> 01:11:38,710
0,255 255,560 640,1040 1540,1785 1785,1920
you can do. You can

2889
01:11:38,710 --> 01:11:40,770
0,135 135,315 315,620 1510,1770 1770,2060
actually query this c tid

2890
01:11:40,940 --> 01:11:42,000
0,400
equals.|
|

2891
01:11:42,040 --> 01:11:44,160
0,275 275,550 690,1090
Then o O.|
然后是OO。|

2892
01:11:46,400 --> 01:11:48,160
0,350 350,455 455,590 590,850
Doesn't have anything there.|
里面什么都没有。|

2893
01:11:48,520 --> 01:11:49,230
0,290 290,440 440,530 530,620 620,710
But I can get the
但我可以拿到另一个，所以我不知道他们为什么要这么做。

2894
01:11:49,230 --> 01:11:50,685
0,75 75,320 730,1110 1320,1395 1395,1455
other one, so I don't

2895
01:11:50,685 --> 01:11:51,290
0,60 60,165 165,270 270,360 360,605
know why they do that.|
|

2896
01:11:52,710 --> 01:11:54,840
0,400
Yes.|
是。|

2897
01:11:55,190 --> 01:11:56,760
0,380 380,1000
Six bytes.|
六个字节。|

2898
01:12:02,010 --> 01:12:03,905
0,380 380,665 665,970 1470,1730 1730,1895
The statement is when we
语句是，当我们说一个槽时，c ID将是6个字节。所以它可能是一个四字节的页码，然后是两个字节的偏移量。这不是限制了我们在一个页面中可以拥有的插槽数量吗？是。但Postgres的默认页面大小是8千字节，所以你不能在一个页面中有10亿个Twoo。

2899
01:12:03,905 --> 01:12:06,500
0,305 835,1140 1140,1475 2185,2460 2460,2595
say a slot, the c

2900
01:12:06,500 --> 01:12:07,360
0,225 225,480 480,600 600,645 645,860
ID is going to be

2901
01:12:07,440 --> 01:12:08,585
0,320 320,695 695,815 815,935 935,1145
six bytes. So it's probably

2902
01:12:08,585 --> 01:12:09,880
0,270 270,495 495,825 825,1005 1005,1295
a four byte page number

2903
01:12:10,290 --> 01:12:11,210
0,260 260,365 365,485 485,620 620,920
and then a two byte

2904
01:12:11,210 --> 01:12:12,830
0,350 700,1050 1050,1200 1200,1440 1440,1620
offset. Doesn't that limit the

2905
01:12:12,830 --> 01:12:14,195
0,195 195,530 820,1155 1155,1290 1290,1365
number of slots we can

2906
01:12:14,195 --> 01:12:15,095
0,90 90,165 165,225 225,455 535,900
have in a page? Yes.

2907
01:12:15,095 --> 01:12:16,280
0,255 255,645 645,795 795,990 990,1185
But postgres is by default

2908
01:12:16,280 --> 01:12:17,260
0,105 105,240 240,555 555,675 675,980
is eight kilobyte page sizes,

2909
01:12:17,280 --> 01:12:18,185
0,245 245,365 365,575 575,725 725,905
so you can't have a

2910
01:12:18,185 --> 01:12:19,025
0,210 210,525 525,630 630,705 705,840
billion twoos in a single

2911
01:12:19,025 --> 01:12:19,900
0,305
page.|
|

2912
01:12:21,290 --> 01:12:22,285
0,260 260,440 440,695 860,920 920,995
All right, so let's look
好的，让我们来看看其他系统。

2913
01:12:22,285 --> 01:12:23,660
0,75 75,210 210,515
at other systems.|
|

2914
01:12:24,760 --> 01:12:26,850
0,400 840,1175 1175,1640 1640,1850 1850,2090
So again, slite is it's
所以，再一次，斯莱特是不同的。因此，再次精简此行ID，它实际上正在存储此内容。这是AC四位。它实际上存储了这个，所以它使用这个作为主键。

2915
01:12:26,850 --> 01:12:30,075
0,230 760,1050 1050,1580 2770,3060 3060,3225
different. So slite this row

2916
01:12:30,075 --> 01:12:31,980
0,275 595,995 1075,1350 1350,1665 1665,1905
ID again and it's actually

2917
01:12:31,980 --> 01:12:33,795
0,255 255,590 1210,1530 1530,1620 1620,1815
storing this. It's A C

2918
01:12:33,795 --> 01:12:35,160
0,195 195,455 655,990 990,1200 1200,1365
four bit. It actually stores

2919
01:12:35,160 --> 01:12:37,815
0,290 400,800 1840,2175 2175,2445 2445,2655
this, so it uses this

2920
01:12:37,815 --> 01:12:40,320
0,135 135,240 240,420 420,755
as the primary key.|
|

2921
01:12:41,440 --> 01:12:42,345
0,320 320,515 515,650 650,800 800,905
Question is, the size of
问题是，这两个的大小通常会在浴缸的头部的某个地方排序，是的。

2922
01:12:42,345 --> 01:12:43,040
0,60 60,150 150,270 270,420 420,695
the two will sort somewhere

2923
01:12:43,180 --> 01:12:44,055
0,335 335,515 515,620 620,815 815,875
typically in the header of

2924
01:12:44,055 --> 01:12:45,300
0,90 90,255 255,575
the tub, yes.|
|

2925
01:12:48,410 --> 01:12:50,170
0,290 290,580 1140,1385 1385,1535 1535,1760
Right. So if we delete
正确的。因此，如果我们从中删除。

2926
01:12:50,170 --> 01:12:52,120
0,320
from.|
|

2927
01:12:53,790 --> 01:12:54,940
0,400 420,665 665,770 770,890 890,1150
We delete a two po.|
我们删除一个两个PO。|

2928
01:12:55,700 --> 01:12:58,520
0,210 210,315 315,435 435,740 2440,2820
Run the same query. It
运行相同的查询。它不会重用行ID。

2929
01:12:58,520 --> 01:12:59,680
0,375 375,645 645,780 780,900 900,1160
doesn't reuse the row ID.|
|

2930
01:13:01,095 --> 01:13:01,815
0,180 180,285 285,420 420,510 510,720
Because it's actually a physical
因为它实际上是一个物理的东西，主键。

2931
01:13:01,815 --> 01:13:03,380
0,255 255,390 390,585 585,935
thing, the primary key.|
|

2932
01:13:03,720 --> 01:13:04,810
0,275 275,470 470,635 635,830 830,1090
All right, so let's do
好了，那我们现在就开始吧。

2933
01:13:04,860 --> 01:13:06,320
0,400
now.|
|

2934
01:13:06,360 --> 01:13:07,880
0,350 350,610
Sql server.|
SQL服务器。|

2935
01:13:10,630 --> 01:13:12,140
0,400 540,890 890,1040 1040,1220 1220,1510
So sql server has this
所以SQL服务器有这个不同的语法，它有一个很难看到的双重语法。

2936
01:13:12,640 --> 01:13:14,805
0,335 335,790 1620,1865 1865,1985 1985,2165
different syntax, it has this

2937
01:13:14,805 --> 01:13:16,190
0,305 565,900 900,975 975,1110 1110,1385
double that's hard to see.|
|

2938
01:13:17,050 --> 01:13:17,910
0,245 245,350 350,530 530,710 710,860
If I highlight, I can
如果我高亮显示，我可以看到它。

2939
01:13:17,910 --> 01:13:18,880
0,120 120,350
see it.|
|

2940
01:13:21,610 --> 01:13:22,480
0,105 105,240 240,540 540,645 645,870
Now there's 2% there's percent
现在有2%，那里有百分号。请相信我。

2941
01:13:22,480 --> 01:13:25,400
0,270 270,590 850,1140 1140,1430
signs there. Trust me.|
|

2942
01:13:27,945 --> 01:13:29,140
0,60 60,120 120,225 225,485
So let's go back.|
所以让我们回到过去。|

2943
01:13:34,990 --> 01:13:36,015
0,245 245,335 335,580 690,935 935,1025
There you go. There you
这就对了。这就对了。有百分号，抱歉。所以当你运行这个的时候，你会得到一些像这样的十六进制数据，对吗？

2944
01:13:36,015 --> 01:13:37,730
0,245 445,750 750,930 930,1265 1315,1715
go. There's percent signs, sorry.

2945
01:13:39,250 --> 01:13:40,395
0,400 510,755 755,845 845,965 965,1145
So when you run this,

2946
01:13:40,395 --> 01:13:42,090
0,150 150,300 300,585 585,965 1315,1695
you get back some hex

2947
01:13:42,090 --> 01:13:43,780
0,150 150,300 300,560 640,1040
data like this, right?|
|

2948
01:13:43,850 --> 01:13:45,480
0,260 260,365 365,500 500,790
What does this mean?|
这是什么意思？|

2949
01:13:45,490 --> 01:13:48,540
0,400 1020,1265 1265,1370 1370,1630 2160,3050
So there is an undocumented
所以有一个未经记录的命令。实际上，这是你唯一不该做的事。这个，你不能。它是无符号的，这意味着微软不正式支持它，但这里有一个命令，叫做这个函数，你可以传递物理位置。

2950
01:13:48,540 --> 01:13:50,520
0,290 310,570 570,830 1600,1845 1845,1980
command. Actually, this is all

2951
01:13:50,520 --> 01:13:51,120
0,165 165,255 255,390 390,495 495,600
you're not supposed to do.

2952
01:13:51,120 --> 01:13:54,735
0,240 240,480 480,860 2620,2970 2970,3615
This, you can't. It's notumented,

2953
01:13:54,735 --> 01:13:56,295
0,245 385,735 735,1065 1065,1380 1380,1560
meaning Microsoft doesn't officially support

2954
01:13:56,295 --> 01:13:58,515
0,275 355,755 1135,1545 1545,1805 1855,2220
this, but there's a command

2955
01:13:58,515 --> 01:14:00,650
0,365 955,1320 1320,1560 1560,1785 1785,2135
called whatever this function here,

2956
01:14:00,910 --> 01:14:01,755
0,245 245,380 380,575 575,740 740,845
and you pass in the

2957
01:14:01,755 --> 01:14:03,100
0,240 240,635
physical location.|
|

2958
01:14:03,100 --> 01:14:04,105
0,120 120,255 255,630 630,765 765,1005
And then you'll get back
然后，您现在将得到格式化的文件号、页码，然后是槽号。

2959
01:14:04,105 --> 01:14:06,600
0,335 925,1325 1405,1965 1965,2175 2175,2495
now the formatted file number,

2960
01:14:06,860 --> 01:14:07,855
0,275 275,470 470,710 710,890 890,995
the page number, and then

2961
01:14:07,855 --> 01:14:09,020
0,105 105,285 285,575
the slot number.|
|

2962
01:14:09,020 --> 01:14:10,200
0,290
Right.|
正确的。|

2963
01:14:10,960 --> 01:14:12,045
0,275 275,395 395,530 530,740 740,1085
And you can actually, it's
你可以，今天学到这个很有趣，你可以找回那个函数的实际功能。所以你可以让它吐回它的实际功能。您可以看到它们正在获取该物理位置，以及它们如何跳转到不同的字节以获取页面ID文件编号和插槽编号。

2964
01:14:12,045 --> 01:14:13,980
0,240 240,545 1285,1545 1545,1680 1680,1935
interesting in learned this today,

2965
01:14:13,980 --> 01:14:15,050
0,225 225,375 375,570 570,765 765,1070
you can actually get back

2966
01:14:15,130 --> 01:14:16,815
0,320 320,640 810,1145 1145,1415 1415,1685
what the that function is

2967
01:14:16,815 --> 01:14:18,405
0,195 195,455 1015,1260 1260,1425 1425,1590
actually doing. So you can

2968
01:14:18,405 --> 01:14:19,190
0,105 105,210 210,315 315,495 495,785
get it to spit back

2969
01:14:19,930 --> 01:14:21,555
0,400 1020,1235 1235,1355 1355,1505 1505,1625
the what it actually does.

2970
01:14:21,555 --> 01:14:23,310
0,120 120,225 225,485 1285,1620 1620,1755
And you see they're taking

2971
01:14:23,310 --> 01:14:24,720
0,150 150,405 405,800 1000,1275 1275,1410
that physical location and how

2972
01:14:24,720 --> 01:14:25,665
0,165 165,300 300,435 435,600 600,945
they're jumping to different bytes

2973
01:14:25,665 --> 01:14:26,955
0,120 120,365 685,945 945,1065 1065,1290
to get the page ID

2974
01:14:26,955 --> 01:14:28,005
0,255 255,540 540,780 780,885 885,1050
file number and the slot

2975
01:14:28,005 --> 01:14:29,440
0,275
number.|
|

2976
01:14:31,035 --> 01:14:31,575
0,75 75,165 165,285 285,405 405,540
So let's do the same
所以让我们做之前做过的同样的事情。我们删掉一零一吧。

2977
01:14:31,575 --> 01:14:33,045
0,120 120,195 195,270 270,515 1075,1470
thing we did before. Let's

2978
01:14:33,045 --> 01:14:34,880
0,210 210,360 360,465 465,725
delete one o one.|
|

2979
01:14:36,140 --> 01:14:36,895
0,245 245,365 365,470 470,590 590,755
Then we run the same
然后我们运行相同的查询。

2980
01:14:36,895 --> 01:14:38,100
0,335
query.|
|

2981
01:14:38,230 --> 01:14:39,375
0,260 260,425 425,730 750,1010 1010,1145
To get the page number
以获得正确的页码偏移量。所以在这种情况下，它没有移动任何东西，对吗？

2982
01:14:39,375 --> 01:14:41,250
0,455 835,1215 1215,1545 1545,1740 1740,1875
offsets right. So in this

2983
01:14:41,250 --> 01:14:42,825
0,180 180,470 880,1140 1140,1350 1350,1575
case here, it didn't move

2984
01:14:42,825 --> 01:14:44,840
0,365 835,1235
anything, right?|
|

2985
01:14:44,880 --> 01:14:46,640
0,245 245,470 470,755 755,1060 1320,1760
So now if we insert
所以现在如果我们把我们的工具放回去，一个新的二元组。

2986
01:14:46,640 --> 01:14:48,800
0,120 120,315 315,560 1840,2070 2070,2160
our toolple back, a new

2987
01:14:48,800 --> 01:14:49,880
0,380
duple.|
|

2988
01:14:50,080 --> 01:14:51,860
0,275 275,410 410,560 560,880
Run that same query.|
运行相同的查询。|

2989
01:14:53,560 --> 01:14:54,380
0,275 275,395 395,485 485,575 575,820
Now look what it did.|
现在看看它做了什么。|

2990
01:14:56,510 --> 01:14:58,165
0,335 335,545 545,770 770,1120 1380,1655
So by two, four with
当我插入新的桌子时，它把第二张二一零二移到了第二个槽里。

2991
01:14:58,165 --> 01:14:59,785
0,275 295,555 555,705 705,995 1315,1620
ID one o two, that

2992
01:14:59,785 --> 01:15:01,570
0,150 150,330 330,675 675,1055 1525,1785
was at slot two, but

2993
01:15:01,570 --> 01:15:02,845
0,105 105,225 225,830 850,1110 1110,1275
when I inserted the new

2994
01:15:02,845 --> 01:15:05,200
0,305 715,1035 1035,1355 1645,2040 2040,2355
table, it moved that second

2995
01:15:05,200 --> 01:15:06,535
0,210 210,360 360,495 495,770 970,1335
two one o two into

2996
01:15:06,535 --> 01:15:07,920
0,330 330,665
slot two.|
|

2997
01:15:07,920 --> 01:15:09,720
0,210 210,390 390,710 1240,1485 1485,1800
And then put the newu
然后把纽U放到第三个槽里。

2998
01:15:09,720 --> 01:15:11,200
0,225 225,495 495,830
into slot three.|
|

2999
01:15:12,115 --> 01:15:13,020
0,120 120,210 210,315 315,540 540,905
Postgres didn't do that right.
波斯格雷斯没有做对这一点。波斯格雷斯只是一直在看比赛的结局。

3000
01:15:13,490 --> 01:15:14,590
0,440 440,575 575,755 755,950 950,1100
Postgres just kept depending on

3001
01:15:14,590 --> 01:15:15,640
0,90 90,320
the end.|
|

3002
01:15:16,810 --> 01:15:18,460
0,260 260,410 410,700
Is this wrong?|
这是错的吗？|

3003
01:15:20,060 --> 01:15:21,390
0,245 245,490 720,965 965,1070 1070,1330
Who knows, is it better?|
谁知道呢，是不是更好呢？|

3004
01:15:22,630 --> 01:15:24,640
0,245 245,490 900,1300
Who knows, right?|
谁知道呢，对吧？|

3005
01:15:24,650 --> 01:15:25,735
0,245 245,335 335,500 500,815 815,1085
And the reason why you
之所以可以这样做，是因为当您获取一个页面并将其放入内存时，您知道，开始向其中插入一个tple，您就握住了该页面上的闩锁或锁，数据决定它是否想要进行压缩或任何优化想要做的事情。

3006
01:15:25,735 --> 01:15:26,730
0,150 150,315 315,465 465,660 660,995
can do this is because

3007
01:15:27,080 --> 01:15:28,170
0,275 275,425 425,620 620,800 800,1090
when you fetch a page

3008
01:15:28,250 --> 01:15:29,340
0,260 260,380 380,605 605,830 830,1090
and bring it into memory

3009
01:15:29,870 --> 01:15:30,870
0,290 290,455 455,620 620,755 755,1000
and you start, you know,

3010
01:15:30,920 --> 01:15:32,160
0,485 485,575 575,770 770,920 920,1240
inserting a tple into it,

3011
01:15:32,390 --> 01:15:33,685
0,320 320,500 500,695 695,1000 1050,1295
you're holding the latch or

3012
01:15:33,685 --> 01:15:34,770
0,120 120,375 375,615 615,780 780,1085
the lock on that page,

3013
01:15:35,480 --> 01:15:36,835
0,350 350,695 695,980 980,1175 1175,1355
the data to decide whether

3014
01:15:36,835 --> 01:15:37,585
0,120 120,240 240,345 345,435 435,750
it wants to do compaction

3015
01:15:37,585 --> 01:15:38,620
0,240 240,405 405,555 555,870 870,1035
or whatever the optimization wants

3016
01:15:38,620 --> 01:15:39,440
0,105 105,350
to do.|
|

3017
01:15:39,440 --> 01:15:40,190
0,135 135,240 240,420 420,615 615,750
Because it knows that no
因为它知道没有其他线程可以同时写入该页。

3018
01:15:40,190 --> 01:15:41,120
0,210 210,480 480,660 660,810 810,930
other thread can write to

3019
01:15:41,120 --> 01:15:41,765
0,105 105,270 270,405 405,495 495,645
that page at the same

3020
01:15:41,765 --> 01:15:42,780
0,305
time.|
|

3021
01:15:42,780 --> 01:15:43,740
0,240 240,360 360,510 510,735 735,960
So we can decide whether
这样我们就可以决定我们是否想要。我们想要，你知道，压缩或不压缩它。当我们这样做的时候，邮政编码不能做到这一点。SQL，SQL SERVER有。

3022
01:15:43,740 --> 01:15:44,460
0,135 135,285 285,450 450,585 585,720
or not we want. We

3023
01:15:44,460 --> 01:15:46,785
0,165 165,470 1600,1830 1830,1995 1995,2325
want to, you know, compact

3024
01:15:46,785 --> 01:15:47,685
0,105 105,180 180,425 505,780 780,900
it or not. As we

3025
01:15:47,685 --> 01:15:48,465
0,75 75,180 180,480 480,690 690,780
do it, postcode doesn't do

3026
01:15:48,465 --> 01:15:49,670
0,135 135,435 435,735 735,915 915,1205
it. Sql, sql server does.|
|

3027
01:15:50,750 --> 01:15:51,760
0,275 275,410 485,650 650,860 860,1010
All right, let's look at
好的，让我们来看看S最喜欢的甲骨文。

3028
01:15:51,760 --> 01:15:53,660
0,120 120,210 210,375 375,890
everyone s favorite Oracle.|
|

3029
01:15:56,310 --> 01:15:57,050
0,260 260,365 365,470 470,605 605,740
I need to create the
我想，我需要先创建一张桌子。

3030
01:15:57,050 --> 01:15:58,740
0,165 165,330 330,465 465,740
table first, I think.|
|

3031
01:16:04,650 --> 01:16:05,180
0,215 215,335 335,365 365,470 470,530
I don't think it's gonna
我想它不会让我这么做的。不，它做到了。

3032
01:16:05,180 --> 01:16:05,825
0,60 60,150 150,270 270,465 465,645
let me do that. No,

3033
01:16:05,825 --> 01:16:07,380
0,90 90,335
it did.|
|

3034
01:16:07,390 --> 01:16:09,160
0,305 305,470 470,970
So in Oracle.|
因此，在甲骨文中。|

3035
01:16:09,200 --> 01:16:10,050
0,260 260,365 365,470 470,590 590,850
They have a row ID.|
它们有一个行ID。|

3036
01:16:13,340 --> 01:16:14,260
0,290 290,425 425,515 515,665 665,920
Right. But you get again
正确的。但是你在这里又得到了一些二进制数据，对吗？

3037
01:16:14,260 --> 01:16:16,530
0,350 970,1515 1515,1740 1740,1965 1965,2270
some binary data here, right?|
|

3038
01:16:18,480 --> 01:16:20,220
0,275 275,425 425,575 575,850
And again, this is.|
再说一次，这是。|

3039
01:16:20,350 --> 01:16:21,480
0,290 290,710 710,845 845,965 965,1130
Stack overflow. This is not
堆栈溢出。这不是我，但你可以做很多功能。运行此命令，您会看到它们现在存储的是对象ID、文件号、块号或页码，然后是行槽。

3040
01:16:21,480 --> 01:16:22,860
0,290 790,1080 1080,1275 1275,1305 1305,1380
me, but there's a bunch

3041
01:16:22,860 --> 01:16:23,690
0,105 105,285 285,465 465,570 570,830
of functions you can do.

3042
01:16:24,580 --> 01:16:27,525
0,275 275,550 2310,2615 2615,2795 2795,2945
Run this and you see

3043
01:16:27,525 --> 01:16:28,695
0,225 225,525 525,720 720,975 975,1170
now they're storing an object

3044
01:16:28,695 --> 01:16:30,090
0,245 265,570 570,825 825,1140 1140,1395
ID, a file number, a

3045
01:16:30,090 --> 01:16:30,840
0,195 195,390 390,510 510,600 600,750
block number or the page

3046
01:16:30,840 --> 01:16:31,965
0,290 460,720 720,840 840,960 960,1125
number, and then the row

3047
01:16:31,965 --> 01:16:33,780
0,335
slot.|
|

3048
01:16:34,290 --> 01:16:35,680
0,400 480,800 800,980 980,1115 1115,1390
So again, this is something
再说一次，这是在教科书中定义的东西，在逻辑层面或理论层面上进行描述。下面是如何组织您的数据库系统，然后您可以看到它的不同限制。

3049
01:16:35,850 --> 01:16:37,130
0,335 335,560 560,875 875,1100 1100,1280
taking something that's defined in

3050
01:16:37,130 --> 01:16:38,390
0,120 120,540 540,870 870,1050 1050,1260
the textbook, describing at like

3051
01:16:38,390 --> 01:16:40,360
0,120 120,405 405,650 940,1340 1450,1970
a logical level or describing

3052
01:16:40,560 --> 01:16:41,870
0,245 245,590 590,820 900,1250 1250,1310
a theoretical level. Here's how

3053
01:16:41,870 --> 01:16:42,820
0,150 150,390 390,480 480,630 630,950
to organize your database system,

3054
01:16:43,350 --> 01:16:44,060
0,245 245,335 335,440 440,575 575,710
and then you can see

3055
01:16:44,060 --> 01:16:45,620
0,135 135,600 600,780 780,1040
different limitations of it.|
|

3056
01:16:45,620 --> 01:16:46,610
0,285 285,600 600,690 690,765 765,990
Through sql you can then
通过SQL，您可以看到如何知道它们是特定的槽，并在槽中对页面进行排序。

3057
01:16:46,610 --> 01:16:47,690
0,315 315,630 630,855 855,960 960,1080
see how you know they

3058
01:16:47,690 --> 01:16:49,025
0,195 195,480 480,855 855,1140 1140,1335
are certain slots, sort things

3059
01:16:49,025 --> 01:16:51,180
0,195 195,480 480,840 840,1085
in slot slotted pages.|
|

3060
01:16:51,180 --> 01:16:52,780
0,210 210,440
All right.|
好的。|

3061
01:16:53,370 --> 01:16:54,305
0,260 260,455 455,680 680,815 815,935
All right, so in the
好吧，为了时间着想。

3062
01:16:54,305 --> 01:16:56,800
0,150 150,330 330,635
sake of time.|
|

3063
01:16:58,930 --> 01:16:59,700
0,275 275,395 455,500 500,575 575,770
I think I'm going to
我想我要跳过了。

3064
01:16:59,700 --> 01:17:00,840
0,380
skip.|
|

3065
01:17:02,900 --> 01:17:04,705
0,275 275,440 440,830 830,1150 1500,1805
This will segue into next
这将进入下一节课，但是。

3066
01:17:04,705 --> 01:17:06,540
0,285 285,665
class, but.|
|

3067
01:17:07,840 --> 01:17:09,585
0,305 305,610 630,1030 1230,1550 1550,1745
The tub itself is just
浴缸本身将只是一个字节序列。

3068
01:17:09,585 --> 01:17:10,065
0,105 105,165 165,225 225,315 315,480
going to be a sequence

3069
01:17:10,065 --> 01:17:11,460
0,165 165,575
of bytes.|
|

3070
01:17:12,370 --> 01:17:14,190
0,335 335,455 455,880 1140,1540 1560,1820
There's some header and then
有一些头，然后是字节序列，然后是数据库系统知道如何根据类型和您正在查看的值来解释这些字节。

3071
01:17:14,190 --> 01:17:15,525
0,105 105,285 285,530 970,1230 1230,1335
a byte sequence, and then

3072
01:17:15,525 --> 01:17:16,260
0,135 135,255 255,390 390,510 510,735
it's up for the database

3073
01:17:16,260 --> 01:17:17,580
0,300 300,540 540,830 910,1155 1155,1320
system to know how to

3074
01:17:17,580 --> 01:17:19,260
0,225 225,420 420,920 1210,1515 1515,1680
interpret those bytes based on

3075
01:17:19,260 --> 01:17:21,195
0,150 150,440 730,1130 1420,1710 1710,1935
the type and based on

3076
01:17:21,195 --> 01:17:22,455
0,195 195,455 685,960 960,1125 1125,1260
the values that you're looking

3077
01:17:22,455 --> 01:17:23,300
0,305
at.|
|

3078
01:17:23,300 --> 01:17:24,290
0,210 210,345 345,570 570,720 720,990
So again, we'll cover this
同样，我们将在下一节课上讲，但是思考这个问题的方法是。

3079
01:17:24,290 --> 01:17:25,340
0,300 300,600 600,855 855,960 960,1050
next class, but the way

3080
01:17:25,340 --> 01:17:25,960
0,90 90,165 165,270 270,375 375,620
to think about this is.|
|

3081
01:17:26,790 --> 01:17:27,815
0,275 275,335 335,470 470,785 785,1025
There'll be some header that
将有一些标题，其中包含关于这两个是否是这两个的信息。我们可以存储，您知道，我们是否想要存储，跟踪哪些列具有空值，然后执行引擎将知道如何根据模式跳到TOL中的不同偏移量。

3082
01:17:27,815 --> 01:17:29,060
0,335 415,705 705,870 870,1065 1065,1245
contains information on whether this

3083
01:17:29,060 --> 01:17:31,145
0,260 460,735 735,855 855,1100 1840,2085
two this or not. We

3084
01:17:31,145 --> 01:17:31,835
0,135 135,315 315,450 450,570 570,690
can store, you know, whether

3085
01:17:31,835 --> 01:17:32,270
0,90 90,195 195,285 285,345 345,435
or not we want to

3086
01:17:32,270 --> 01:17:33,245
0,260 280,540 540,675 675,810 810,975
store, keep track of what

3087
01:17:33,245 --> 01:17:35,110
0,270 270,405 405,905 1315,1590 1590,1865
columns have nulls and then

3088
01:17:36,750 --> 01:17:37,985
0,365 365,680 680,920 920,1085 1085,1235
then the execution engine will

3089
01:17:37,985 --> 01:17:39,005
0,165 165,300 300,545 655,915 915,1020
know how to jump to

3090
01:17:39,005 --> 01:17:40,420
0,150 150,555 555,795 795,1020 1020,1415
different offsets within the tole

3091
01:17:40,500 --> 01:17:41,940
0,305 305,455 455,605 605,1030
based on the schema.|
|

3092
01:17:42,130 --> 01:17:43,370
0,320 320,530 530,770 770,935 935,1240
So again, we'll cover this
再次强调，我们将在下一节课中讨论这一点，但只是作为结束。

3093
01:17:43,840 --> 01:17:45,555
0,275 275,455 455,760 1380,1610 1610,1715
in next class, but just

3094
01:17:45,555 --> 01:17:47,080
0,120 120,285 285,605
to finish up.|
|

3095
01:17:49,400 --> 01:17:50,320
0,350 350,575 575,740 740,860 860,920
Again what we what do
再说一遍，我们今天讨论了什么？有一个数据库系统来维护一个数据库，数据将被跨不同的文件跟踪并分解成页面，然后我们有不同的方法来跟踪这些页面，跟踪哪些内容以及如何在这些页面中存储内容，然后下一节课，我们将讨论如何实际存储这两个二进制数，所以再次讨论下一节课，祝你周末愉快，我是那个操他妈的钩子的罂粟花28克，这取决于它是否结束了你还没有打击暴徒，还没有闭嘴我用剪刀的底部打你告诉你抬起头，让我看看你的脸被打回去是什么意思。我有一个细木工板水龙头，无法追踪，风格就像是大便，你不能把它系在支配线上，或者你得叫我男人。

3096
01:17:50,320 --> 01:17:51,595
0,90 90,240 240,530 940,1215 1215,1275
we discussed today? There's a

3097
01:17:51,595 --> 01:17:53,605
0,225 225,605 1435,1680 1680,1845 1845,2010
database system to maintain a

3098
01:17:53,605 --> 01:17:54,415
0,210 210,450 450,600 600,720 720,810
database that data is going

3099
01:17:54,415 --> 01:17:56,425
0,135 135,450 450,755 1555,1830 1830,2010
be tracked in across different

3100
01:17:56,425 --> 01:17:58,030
0,305 775,1110 1110,1320 1320,1470 1470,1605
files and broke up into

3101
01:17:58,030 --> 01:17:59,425
0,260 910,1155 1155,1230 1230,1290 1290,1395
pages and then we have

3102
01:17:59,425 --> 01:18:00,205
0,180 180,345 345,465 465,615 615,780
different ways to keep track

3103
01:18:00,205 --> 01:18:01,510
0,120 120,255 255,545 835,1125 1125,1305
of those pages keep track

3104
01:18:01,510 --> 01:18:02,425
0,165 165,360 360,570 570,795 795,915
of what's and how to

3105
01:18:02,425 --> 01:18:03,180
0,150 150,285 285,375 375,480 480,755
store things in those pages

3106
01:18:03,500 --> 01:18:04,375
0,245 245,365 365,545 545,725 725,875
and then next class we'll

3107
01:18:04,375 --> 01:18:05,155
0,60 60,195 195,450 450,675 675,780
talk about what how to

3108
01:18:05,155 --> 01:18:07,225
0,90 90,225 225,360 360,725 1825,2070
store actually the twoples so

3109
01:18:07,225 --> 01:18:08,200
0,150 150,390 390,600 600,780 780,975
again lot discuss next next

3110
01:18:08,200 --> 01:18:09,150
0,285 285,525 525,600 600,690 690,950
class have a good weekend

3111
01:18:28,340 --> 01:18:29,500
0,365 365,485 485,845 845,995 995,1160
I'm the poppy with the

3112
01:18:29,500 --> 01:18:31,830
0,600 600,950 1270,1800 1800,1995 1995,2330
motherfuck hook 28 a gram

3113
01:18:31,910 --> 01:18:33,300
0,335 335,560 560,725 725,1040 1040,1390
depending on if it's up

3114
01:18:33,410 --> 01:18:34,360
0,260 260,485 485,605 605,755 755,950
you ain't hit the mob

3115
01:18:34,360 --> 01:18:35,695
0,320 460,765 765,960 960,1155 1155,1335
yet still got your shut

3116
01:18:35,695 --> 01:18:36,715
0,225 225,510 510,765 765,900 900,1020
up I smack you with

3117
01:18:36,715 --> 01:18:38,035
0,165 165,405 405,735 735,1155 1155,1320
the bottom of cliper tell

3118
01:18:38,035 --> 01:18:39,265
0,165 165,360 360,665 775,1065 1065,1230
you look up show me

3119
01:18:39,265 --> 01:18:40,210
0,105 105,225 225,450 450,735 735,945
what it sa at for

3120
01:18:40,210 --> 01:18:41,335
0,165 165,345 345,540 540,810 810,1125
a blow your face back.

3121
01:18:41,335 --> 01:18:42,640
0,225 225,360 360,525 525,990 990,1305
I got a blockboard taps

3122
01:18:42,640 --> 01:18:44,040
0,240 240,495 495,870 870,1095 1095,1400
the f can't trace that

3123
01:18:44,090 --> 01:18:45,385
0,320 320,485 485,725 725,1040 1040,1295
styl is like t for

3124
01:18:45,385 --> 01:18:46,630
0,270 270,495 495,795 795,990 990,1245
poop you can't lace that

3125
01:18:46,630 --> 01:18:48,310
0,225 225,1005 1005,1245 1245,1410 1410,1680
to dominicin or you got

3126
01:18:48,310 --> 01:18:49,000
0,270 270,420 420,555 555,660
call me the man.|
|

3127
01:18:49,040 --> 01:18:50,890
0,395 395,755 755,1175 1175,1430 1430,1850
An black sclly black leather
一辆黑色的黑色皮革，黑色的松木铺满了我的整个黑色，肮脏的八层，把你送到了普尔门。你得到了中国的冠军，这是你的第一个错误。我为那块蛋糕排队，你称我幸福的重量，我活着的错误。

3128
01:18:50,890 --> 01:18:52,480
0,285 285,630 630,1125 1125,1335 1335,1590
black sued timberlands my whole

3129
01:18:52,480 --> 01:18:53,725
0,315 315,630 630,855 855,1050 1050,1245
black dirty eight to send

3130
01:18:53,725 --> 01:18:54,810
0,165 165,300 300,465 465,735 735,1085
you to the pur gates.

3131
01:18:54,950 --> 01:18:56,380
0,275 275,410 410,920 920,1160 1160,1430
You get youravat China skate

3132
01:18:56,380 --> 01:18:57,540
0,165 165,375 375,480 480,740 760,1160
and that's your first mistake.

3133
01:18:57,740 --> 01:18:58,840
0,290 290,470 470,725 725,935 935,1100
I in line for that

3134
01:18:58,840 --> 01:19:01,105
0,320 760,1050 1050,1340 1420,1820 1930,2265
cake you weight my happy

3135
01:19:01,105 --> 01:19:03,630
0,255 255,570 570,965 985,1385 2125,2525
weight the the mistake I

3136
01:19:04,400 --> 01:19:10,291
0,400
living.|
|
