1
00:00:25,480 --> 00:00:28,035
0,305 305,610 960,1535 1535,2000 2000,2555
Good morning, I'm Jignesh Patel|
早上好，我是 Jignesh Patel ，|

2
00:00:28,035 --> 00:00:29,940
0,395 535,935 1075,1410 1410,1695 1695,1905
and I am going to
我将在 10 月份教授这门课，

3
00:00:29,940 --> 00:00:31,725
0,225 225,590 730,1110 1110,1490 1540,1785
be teaching this class for

4
00:00:31,725 --> 00:00:33,330
0,90 90,225 225,465 465,815 1225,1605
the month of October| Andy
|Andy 将在 11 月份回来，

5
00:00:33,330 --> 00:00:35,030
0,255 255,420 420,710 1060,1380 1380,1700
will be back in November,|
|

6
00:00:36,010 --> 00:00:37,335
0,305 305,590 590,875 875,1070 1070,1325
an additional change is that,|
另一个变化是，|

7
00:00:37,335 --> 00:00:39,195
0,315 315,665 745,1080 1080,1415 1585,1860
on Wednesday both Andy and
周三 Andy 和我都要去旅行，

8
00:00:39,195 --> 00:00:41,090
0,210 210,495 495,845 1315,1605 1605,1895
I are traveling,| so Matt
|所以 Matt 将在周三主持课程，

9
00:00:41,260 --> 00:00:42,375
0,305 305,500 500,650 650,860 860,1115
is going to run the

10
00:00:42,375 --> 00:00:44,535
0,240 240,480 480,785 1555,1905 1905,2160
class on Wednesday,| Matt is
|Matt 是 Andy 的学生。

11
00:00:44,535 --> 00:00:45,980
0,495 495,785
Andy student.|
|

12
00:00:46,130 --> 00:00:47,200
0,275 275,410 410,530 530,755 755,1070
This is a {re-recording -}
这是周一那节课的重录，

13
00:00:47,200 --> 00:00:48,805
0,225 225,420 420,740 1090,1380 1380,1605
of the class that happened

14
00:00:48,805 --> 00:00:50,305
0,255 255,575 955,1215 1215,1350 1350,1500
on Monday,| so those of
|所以周一上课的同学，

15
00:00:50,305 --> 00:00:51,130
0,150 150,300 300,465 465,645 645,825
you who were in class

16
00:00:51,130 --> 00:00:52,975
0,165 165,440 580,980 1510,1755 1755,1845
on Monday| and see a
|看到了不同的背景，

17
00:00:52,975 --> 00:00:54,265
0,180 180,515 745,990 990,1125 1125,1290
different background,| see a few
|看到了几组不同的笔记，

18
00:00:54,265 --> 00:00:55,960
0,240 240,465 465,615 615,905 1315,1695
different set of notes,| it's
|这是因为他们周一的录制没有奏效。

19
00:00:55,960 --> 00:00:56,980
0,165 165,405 405,615 615,795 795,1020
because they're recording on Monday

20
00:00:56,980 --> 00:00:59,140
0,300 300,560 1000,1400 1690,2025 2025,2160
didn't work.| So let's get
|那么让我们先从几个公告开始吧。

21
00:00:59,140 --> 00:01:00,265
0,210 210,375 375,480 480,645 645,1125
started with a few announcements

22
00:01:00,265 --> 00:01:01,260
0,305
first.|
|

23
00:01:01,260 --> 00:01:03,260
0,290 460,765 765,1070 1450,1725 1725,2000
{} We have the database
我们有数据库研讨会系列，

24
00:01:03,280 --> 00:01:04,665
0,470 470,725 725,995 995,1205 1205,1385
seminar series,| as many of
|你们很多人都知道，

25
00:01:04,665 --> 00:01:06,615
0,135 135,395 805,1205 1465,1740 1740,1950
you know,| and there are
|这里有两节课，

26
00:01:06,615 --> 00:01:08,805
0,335 505,1145 1465,1785 1785,2010 2010,2190
two lectures,| {Weaviate -}, which
|Weaviate 是昨天发生的，

27
00:01:08,805 --> 00:01:10,515
0,195 195,480 480,845 1255,1560 1560,1710
just happened yesterday,| there's a
|有一个录制是这样的，

28
00:01:10,515 --> 00:01:11,535
0,285 285,510 510,705 705,885 885,1020
recording for that,| you can
|你可以在 CMU 数据库页面中找到这个。

29
00:01:11,535 --> 00:01:12,885
0,165 165,360 360,600 600,885 885,1350
find that from the CMU

30
00:01:12,885 --> 00:01:15,500
0,305 445,845 1315,1835 1855,2235 2235,2615
database page.| There's {FeatureForm -}
|有一个 FeatureForm ，它是一个特征存储，

31
00:01:15,580 --> 00:01:17,840
0,365 365,605 605,1000 1050,1450 1860,2260
that's a feature store, {}|
|

32
00:01:18,010 --> 00:01:19,890
0,400 540,920 920,1300 1380,1655 1655,1880
that works with machine learning
它与机器学习模型一起工作，

33
00:01:19,890 --> 00:01:22,560
0,350 1030,1430 1540,1940 1960,2355 2355,2670
models| and stores features helps
|存储特征帮助你管理整个再训练管道，

34
00:01:22,560 --> 00:01:24,525
0,320 370,770 880,1200 1200,1455 1455,1965
you manage the entire retraining

35
00:01:24,525 --> 00:01:26,500
0,365 985,1385
pipeline,| there
|这个演讲将在下周一举行，

36
00:01:26,630 --> 00:01:28,225
0,400 780,1070 1070,1250 1250,1400 1400,1595
presentation is on the coming

37
00:01:28,225 --> 00:01:29,785
0,335 595,825 825,900 900,1205 1225,1560
Monday,| so if you're interested
|所以，如果你对传统关系数据库之外的与数据相关的东西感兴趣，

38
00:01:29,785 --> 00:01:32,470
0,335 805,1185 1185,1530 1530,1895 2335,2685
in data related things outside

39
00:01:32,470 --> 00:01:34,525
0,285 285,675 675,1520 1630,1905 1905,2055
traditional relational databases,| but where
|在数据库与机器学习的交汇点上，

40
00:01:34,525 --> 00:01:36,490
0,555 555,840 840,1110 1110,1385 1675,1965
databases meet machine learning,| this
|这个系列研讨会是一个很棒的活动，

41
00:01:36,490 --> 00:01:37,585
0,345 345,585 585,780 780,900 900,1095
seminar series is a great

42
00:01:37,585 --> 00:01:39,400
0,335 475,780 780,1085 1435,1695 1695,1815
event| and hope you can
|希望你能来参加。

43
00:01:39,400 --> 00:01:40,400
0,165 165,315 315,560
come to it.|
|

44
00:01:41,510 --> 00:01:43,150
0,290 290,785 785,1145 1145,1430 1430,1640
Few announcements,| homework #3 is
一些公告，|作业 #3 在周日午夜截止，

45
00:01:43,150 --> 00:01:45,660
0,320 610,945 945,1280 1720,2115 2115,2510
due on Sunday at midnight|
|

46
00:01:46,070 --> 00:01:47,520
0,365 365,590 590,950 950,1160 1160,1450
and the midterm coming up
期中考试将在 10 月 13 日星期三，

47
00:01:47,630 --> 00:01:49,870
0,400 420,820 1110,1460 1460,1810 1920,2240
on Wednesday, October 13,| so
|所以，开始复习那些材料，

48
00:01:49,870 --> 00:01:50,860
0,225 225,540 540,675 675,810 810,990
start brushing up on the

49
00:01:50,860 --> 00:01:52,720
0,320 400,800 1000,1320 1320,1545 1545,1860
material,| that we've been discussing
|我们在课堂上讨论的，

50
00:01:52,720 --> 00:01:53,725
0,210 210,450 450,690 690,855 855,1005
in class| since the start
|从学期开始的。

51
00:01:53,725 --> 00:01:55,165
0,135 135,255 255,635 1045,1305 1305,1440
of the semester.| And of
|当然，也可以来找我们的工作人员提问，

52
00:01:55,165 --> 00:01:56,190
0,195 195,405 405,525 525,690 690,1025
course, come to our officers

53
00:01:56,210 --> 00:01:57,865
0,260 260,470 470,820 1170,1460 1460,1655
and ask questions,| if some
|如果有些事情不清楚。

54
00:01:57,865 --> 00:01:59,460
0,285 285,555 555,780 780,1115
things are not clear.|
|

55
00:02:00,050 --> 00:02:01,270
0,245 245,350 350,605 605,995 995,1220
So with that, let's get
好了，让我们开始吧。

56
00:02:01,270 --> 00:02:02,680
0,350 640,990 990,1170 1170,1260 1260,1410
started.| Today we are going
|今天，我们将讨论如何在数据库引擎中执行查询。

57
00:02:02,680 --> 00:02:04,590
0,150 150,315 315,620 1000,1440 1440,1910
to talk about executing queries

58
00:02:04,940 --> 00:02:06,860
0,290 290,440 440,700 720,1120
inside a database engine.|
|

59
00:02:06,860 --> 00:02:07,865
0,165 165,345 345,495 495,690 690,1005
And you see the structure
你可以在右侧看到数据库引擎的结构，

60
00:02:07,865 --> 00:02:10,025
0,395 985,1245 1245,1505 1525,1905 1905,2160
of the database engine on

61
00:02:10,025 --> 00:02:10,955
0,120 120,300 300,525 525,795 795,930
the right side,| you've seen
|你以前见过这个，

62
00:02:10,955 --> 00:02:13,040
0,165 165,455 1105,1505 1585,1890 1890,2085
this before,| and the part
|你今天要关注的部分是运算符执行引擎。

63
00:02:13,040 --> 00:02:13,790
0,135 135,300 300,390 390,525 525,750
that you're going to focus

64
00:02:13,790 --> 00:02:15,730
0,285 285,620 640,975 975,1310 1540,1940
on today is that operator

65
00:02:15,930 --> 00:02:18,395
0,350 350,700 1260,1660 1920,2210 2210,2465
execution engine.| So at this
|所以，在查询生命周期的这一点上，

66
00:02:18,395 --> 00:02:19,700
0,360 360,615 615,735 735,1200 1200,1305
point in the lifecycle of

67
00:02:19,700 --> 00:02:21,050
0,120 120,410 670,930 930,1125 1125,1350
a query,| the query has
|查询已经开始，查询已经计划，进行了优化，

68
00:02:21,050 --> 00:02:22,535
0,320 700,960 960,1140 1140,1305 1305,1485
started, the query has been

69
00:02:22,535 --> 00:02:25,835
0,305 685,1085 1645,2135 2575,2975 3025,3300
planned, basically optimized,| and you
|你最终在这种情况，

70
00:02:25,835 --> 00:02:28,360
0,165 165,455 715,1005 1005,1295 2125,2525
end up with this situation|
|

71
00:02:28,440 --> 00:02:29,630
0,320 320,640 690,950 950,1070 1070,1190
now where you have to
现在你必须在那个查询中执行操作符，

72
00:02:29,630 --> 00:02:31,090
0,105 105,350 490,825 825,1020 1020,1460
go and execute the operators

73
00:02:31,170 --> 00:02:32,540
0,260 260,425 425,760 990,1280 1280,1370
in that query,| there's a
|从今天开始有四节课，

74
00:02:32,540 --> 00:02:34,280
0,255 255,650 700,1005 1005,1455 1455,1740
sequence of four lectures starting

75
00:02:34,280 --> 00:02:35,440
0,315 315,555 555,720 720,885 885,1160
today,| where we look at
|我们来看看用来执行这些运算符的算法，

76
00:02:35,610 --> 00:02:36,800
0,500 500,650 650,755 755,905 905,1190
algorithms that are used for

77
00:02:36,800 --> 00:02:39,185
0,375 375,555 555,1070 1660,2060 2110,2385
executing these operators| and they
|它们最终会使用访问方法，

78
00:02:39,185 --> 00:02:40,535
0,150 150,300 300,465 465,755 955,1350
will end up using the

79
00:02:40,535 --> 00:02:42,245
0,300 300,605 1045,1365 1365,1560 1560,1710
access methods,| might scan a
|可能会扫描文件，

80
00:02:42,245 --> 00:02:43,330
0,275 325,570 570,690 690,825 825,1085
file,| they might end up
|可能会使用你们以前知道的 B 树之类的东西。

81
00:02:43,410 --> 00:02:44,990
0,335 335,530 530,725 725,1060 1260,1580
using a B tree stuff

82
00:02:44,990 --> 00:02:46,030
0,225 225,390 390,570 570,765 765,1040
that you know from before.|
|

83
00:02:46,790 --> 00:02:48,115
0,400 450,725 725,935 935,1145 1145,1325
Though the data that gets
从磁盘获取的数据被拉到缓冲区管理器中，

84
00:02:48,115 --> 00:02:49,735
0,330 330,510 510,1050 1050,1395 1395,1620
fetched from disk gets pulled

85
00:02:49,735 --> 00:02:51,600
0,180 180,345 345,630 630,905 1465,1865
into the buffer manager| and
|你知道缓冲区管理器是如何工作的，

86
00:02:51,800 --> 00:02:52,890
0,275 275,410 410,545 545,830 830,1090
you know how buffer manager

87
00:02:52,940 --> 00:02:54,640
0,395 395,680 680,905 905,1240 1320,1700
work,| that was your {}
|这是你的第一个项目任务，

88
00:02:54,640 --> 00:02:58,465
0,380 760,1160 1240,1880 2170,2570 3460,3825
first project assignment,| and essentially
|基本上目标是从磁盘获取数据，

89
00:02:58,465 --> 00:03:01,165
0,210 210,450 450,845 1405,1805 2335,2700
the goal is to fetch

90
00:03:01,165 --> 00:03:02,540
0,240 240,435 435,555 555,995
data from the disk,|
|

91
00:03:02,540 --> 00:03:03,410
0,165 165,315 315,450 450,645 645,870
keep all the hot stuff
尽可能长时间地将所有热门内容保存在缓冲池中，

92
00:03:03,410 --> 00:03:04,355
0,150 150,270 270,555 555,765 765,945
in the buffer pool for

93
00:03:04,355 --> 00:03:06,080
0,135 135,330 330,540 540,845 1465,1725
as long as possible,| so
|以便你可以从内存中重新访问需要重新访问的任何数据，

94
00:03:06,080 --> 00:03:07,640
0,260 280,555 555,830 940,1320 1320,1560
that you can {re-access -}

95
00:03:07,640 --> 00:03:08,990
0,180 180,500 670,960 960,1155 1155,1350
any data that you {need

96
00:03:08,990 --> 00:03:10,720
0,165 165,440 460,860 1120,1425 1425,1730
-} to re-access from memory,|
|

97
00:03:11,160 --> 00:03:12,725
0,260 260,410 410,635 635,970 1260,1565
which is far cheaper than
这比去磁盘访问要便宜得多。

98
00:03:12,725 --> 00:03:14,140
0,255 255,450 450,540 540,785
going to the disk.|
|

99
00:03:15,330 --> 00:03:17,060
0,365 365,730 900,1310 1310,1490 1490,1730
Alright, so let's jump into
好的，让我们开始，

100
00:03:17,060 --> 00:03:17,960
0,350
it,|
|

101
00:03:17,970 --> 00:03:19,440
0,400
and,
看看查询解析后会发生什么。

102
00:03:19,740 --> 00:03:20,855
0,275 275,425 425,575 575,850 870,1115
look at what happens to

103
00:03:20,855 --> 00:03:22,205
0,90 90,395 505,870 870,1200 1200,1350
the query after it's been

104
00:03:22,205 --> 00:03:24,275
0,305 385,1025 1495,1755 1755,1965 1965,2070
{} parsed.| So here's a
|所以，这是一个 SQL 查询，

105
00:03:24,275 --> 00:03:27,100
0,330 330,635 1195,1575 1575,1955
SQL query,| which does
|在两个表之间做 JOIN ，

106
00:03:27,100 --> 00:03:28,680
0,260 430,825 825,1110 1110,1290 1290,1580
a JOIN between two tables,|
|

107
00:03:29,360 --> 00:03:30,490
0,320 320,485 485,770 770,995 995,1130
there's a selection on one
在其中一张表 S 上有一个选择，

108
00:03:30,490 --> 00:03:32,230
0,105 105,225 225,500 580,980 1360,1740
of the tables S| and
|并从每一张表中投影出一列，

109
00:03:32,230 --> 00:03:33,475
0,270 270,510 510,750 750,990 990,1245
projects out a column from

110
00:03:33,475 --> 00:03:35,040
0,195 195,360 360,495 495,755
each of the tables,|
|

111
00:03:35,210 --> 00:03:36,630
0,400 420,710 710,950 950,1145 1145,1420
after this query is presented
在将该查询呈现给数据库引擎之后，

112
00:03:36,740 --> 00:03:38,290
0,245 245,335 335,580 630,1030 1200,1550
to the database engine,| it's
|将通过语法分析器对其进行检查，

113
00:03:38,290 --> 00:03:39,400
0,135 135,270 270,510 510,885 885,1110
going to get checked through

114
00:03:39,400 --> 00:03:41,485
0,90 90,765 765,1370 1690,1965 1965,2085
a syntactical parser| and then
|然后将其转换为关系代数表示，

115
00:03:41,485 --> 00:03:42,750
0,180 180,285 285,405 405,645 645,1265
it's going to get converted

116
00:03:42,770 --> 00:03:44,880
0,335 335,515 515,965 965,1400 1400,2110
into a relationalial algebraic representation,|
|

117
00:03:45,410 --> 00:03:47,035
0,275 275,425 425,1025 1025,1340 1340,1625
and that representation is what
而这种表示就是得到优化的，

118
00:03:47,035 --> 00:03:48,940
0,305 385,795 795,1020 1020,1265 1525,1905
gets optimized,| we'll talk about
|我们将在稍后的课程中讨论优化，

119
00:03:48,940 --> 00:03:50,800
0,560 1060,1380 1380,1575 1575,1710 1710,1860
optimization later on in the

120
00:03:50,800 --> 00:03:52,705
0,270 270,600 600,825 825,1100 1630,1905
class,| but for today we
|但今天我们只是假设我们获得了查询的树的表示形式，

121
00:03:52,705 --> 00:03:54,025
0,255 255,600 600,855 855,1095 1095,1320
just assume that we've got

122
00:03:54,025 --> 00:03:56,670
0,365 535,855 855,1095 1095,1865 2245,2645
some tree like representation for

123
00:03:56,720 --> 00:03:57,980
0,275 275,580
the query,|
|

124
00:03:57,980 --> 00:03:59,180
0,260 370,675 675,870 870,1035 1035,1200
and in the tree are
树中的节点是运算符，

125
00:03:59,180 --> 00:04:01,355
0,345 345,480 480,740 1210,1820 1900,2175
nodes that are operators,| so
|所以在这里你得到关系 R ，

126
00:04:01,355 --> 00:04:03,275
0,275 415,795 795,1055 1315,1620 1620,1920
here you've got the relation

127
00:04:03,275 --> 00:04:04,670
0,375 375,735 735,960 960,1140 1140,1395
R,| that's feeding into a
|它是 JOIN 操作符，

128
00:04:04,670 --> 00:04:06,500
0,320 400,800 1150,1395 1395,1560 1560,1830
JOIN operator,| with a condition
|JOIN 的条件是，

129
00:04:06,500 --> 00:04:08,015
0,195 195,315 315,590 730,1130 1180,1515
for the JOIN is| looking
|在 R 和 S 表记录上的 id 字段之间寻找相等，

130
00:04:08,015 --> 00:04:10,000
0,255 255,840 840,1205 1435,1710 1710,1985
for equality between the id

131
00:04:10,020 --> 00:04:11,585
0,400 450,850 960,1235 1235,1400 1400,1565
fields on the R and

132
00:04:11,585 --> 00:04:14,160
0,150 150,425 775,1175 1345,1745
the S tables records,|
|

133
00:04:15,200 --> 00:04:18,430
0,395 395,755 755,1120 1560,1960 2880,3230
the S table is being
扫描 S 表，

134
00:04:18,430 --> 00:04:20,970
0,560 670,1070 1510,1910 1930,2235 2235,2540
scanned| and only the records
|只有值大于 10 的记录才会发送到这个 JOIN 操作符，

135
00:04:20,990 --> 00:04:22,495
0,400 510,800 800,1040 1040,1295 1295,1505
that have value greater than

136
00:04:22,495 --> 00:04:23,545
0,270 270,540 540,735 735,885 885,1050
10 are sent to this

137
00:04:23,545 --> 00:04:25,180
0,305 325,660 660,885 885,1175 1375,1635
JOIN operator,| now here, if
|现在，如果有一个建立在值上的索引，它将被使用，

138
00:04:25,180 --> 00:04:26,065
0,150 150,315 315,570 570,750 750,885
there's an index built on

139
00:04:26,065 --> 00:04:27,190
0,120 120,365 565,825 825,960 960,1125
the value, that will get

140
00:04:27,190 --> 00:04:28,585
0,290 640,945 945,1110 1110,1245 1245,1395
used| and you know how
|你们从上一节课知道这些索引是如何工作的。

141
00:04:28,585 --> 00:04:29,920
0,555 555,795 795,1020 1020,1140 1140,1335
{those,indexes} work from the last

142
00:04:29,920 --> 00:04:30,860
0,350
lecture.|
|

143
00:04:31,240 --> 00:04:32,235
0,350 350,545 545,650 650,785 785,995
The output of the JOIN
JOIN 的输出进入投影操作符，

144
00:04:32,235 --> 00:04:33,620
0,210 210,360 360,555 555,1035 1035,1385
goes into a projection operator,|
|

145
00:04:33,670 --> 00:04:35,085
0,290 290,580 600,905 905,1220 1220,1415
where these two columns are
投影这两个列，生成结果的输出。

146
00:04:35,085 --> 00:04:36,480
0,495 495,795 795,1080 1080,1275 1275,1395
projected, producing the output of

147
00:04:36,480 --> 00:04:37,500
0,195 195,465 465,675 675,795 795,1020
the result.| And so that's
|这就是查询树的样子，

148
00:04:37,500 --> 00:04:39,630
0,180 180,405 405,710 940,1370 1810,2130
really what the query tree

149
00:04:39,630 --> 00:04:41,595
0,240 240,560 910,1310 1330,1740 1740,1965
looks like| and tables are
|表就在其中流动，

150
00:04:41,595 --> 00:04:42,480
0,405 405,570 570,675 675,780 780,885
flowing through it,| and you
|你可以把一个查询树想象成一个数据流图，

151
00:04:42,480 --> 00:04:43,290
0,135 135,285 285,420 420,555 555,810
can think of a query

152
00:04:43,290 --> 00:04:44,750
0,300 300,495 495,645 645,1155 1155,1460
tree as a dataflow graph,|
|

153
00:04:45,040 --> 00:04:46,215
0,260 260,380 380,635 635,1025 1025,1175
where the record flowing from
记录从底部流出，

154
00:04:46,215 --> 00:04:47,625
0,135 135,395 775,1065 1065,1260 1260,1410
the bottom,| they go through
|它们经过运算符，

155
00:04:47,625 --> 00:04:49,980
0,105 105,575 985,1260 1260,1535 2035,2355
the operators,| where they get
|它们在那里根据每个运算符的语义进行处理，

156
00:04:49,980 --> 00:04:51,765
0,630 630,960 960,1185 1185,1335 1335,1785
processed based upon the semantics

157
00:04:51,765 --> 00:04:52,910
0,180 180,360 360,525 525,690 690,1145
of each of those operators,|
|

158
00:04:53,110 --> 00:04:54,975
0,320 320,640 930,1220 1220,1510 1530,1865
a selection, a JOIN, a
在本例中，选择、 JOIN 、投影，

159
00:04:54,975 --> 00:04:56,550
0,390 390,510 510,690 690,995 1255,1575
projection in this case,| and
|最终在这里生成输出，

160
00:04:56,550 --> 00:04:58,785
0,320 790,1155 1155,1485 1485,1850 1990,2235
eventually you produce the output

161
00:04:58,785 --> 00:05:00,750
0,165 165,485 595,885 885,1565 1615,1965
over here,| that satisfies all
|满足查询中所有条件。

162
00:05:00,750 --> 00:05:02,610
0,330 330,705 705,1035 1035,1370 1570,1860
the conditions that are in

163
00:05:02,610 --> 00:05:03,380
0,135 135,410
the query.|
|

164
00:05:04,460 --> 00:05:06,340
0,350 350,700 870,1270 1380,1670 1670,1880
What we are seeing over
我们在这里看到的是这个查询的树形式，

165
00:05:06,340 --> 00:05:07,620
0,270 270,495 495,690 690,945 945,1280
here is a tree form

166
00:05:07,850 --> 00:05:09,775
0,400 600,920 920,1270 1500,1760 1760,1925
for this query,| but in
|但通常这可以是一个 DAG ，

167
00:05:09,775 --> 00:05:10,720
0,285 285,555 555,720 720,840 840,945
general this can be a

168
00:05:10,720 --> 00:05:11,860
0,260 370,630 630,780 780,960 960,1140
DAG,| where it may be
|可能是查询的一部分，

169
00:05:11,860 --> 00:05:12,700
0,165 165,330 330,435 435,645 645,840
that there's a portion of

170
00:05:12,700 --> 00:05:14,275
0,120 120,410 790,1095 1095,1365 1365,1575
the query,| where the output
|这个 JOIN 的输出被送到另一棵树中，

171
00:05:14,275 --> 00:05:15,310
0,135 135,315 315,555 555,840 840,1035
of this JOIN gets fed

172
00:05:15,310 --> 00:05:16,825
0,225 225,585 585,980 1060,1350 1350,1515
into another tree,| and all
|所有这些都在你产生最终输出之前聚集在一起。

173
00:05:16,825 --> 00:05:17,950
0,150 150,330 330,585 585,870 870,1125
of those come together before

174
00:05:17,950 --> 00:05:19,680
0,270 270,570 570,825 825,1130 1330,1730
you produce the final output.|
|

175
00:05:20,130 --> 00:05:21,460
0,260 260,365 365,470 470,830 830,1330
When you have nested queries,
当你有嵌套的查询时，你有 CTE ，

176
00:05:21,570 --> 00:05:23,870
0,275 275,550 570,1120 1620,1985 1985,2300
you have CTEs,| often you'll
|你通常会得到一个看起来像 DAG 的结构，

177
00:05:23,870 --> 00:05:25,000
0,150 150,405 405,645 645,825 825,1130
end up with a structure

178
00:05:25,050 --> 00:05:26,950
0,320 320,640 1170,1460 1460,1610 1610,1900
that looks like a DAG|
|

179
00:05:27,120 --> 00:05:29,210
0,290 290,580 600,1000 1410,1805 1805,2090
and not a {regular,tree} like
而不是你在这里看到的常规树，

180
00:05:29,210 --> 00:05:30,755
0,180 180,330 330,525 525,860 1180,1545
you see over here,| which
|这永远不是一个图，

181
00:05:30,755 --> 00:05:32,920
0,165 165,345 345,635 985,1385 1765,2165
never a graph,| is the,
|在最糟糕的情况下，复杂性将是一个 DAG ，

182
00:05:33,300 --> 00:05:35,015
0,365 365,1060 1170,1430 1430,1535 1535,1715
the complexity, in the worst

183
00:05:35,015 --> 00:05:35,810
0,240 240,435 435,600 600,720 720,795
case is going to be

184
00:05:35,810 --> 00:05:36,635
0,105 105,330 330,570 570,705 705,825
a DAG,| things are going
|东西将流入并传出顶部的一个节点，

185
00:05:36,635 --> 00:05:37,820
0,180 180,375 375,665 715,1020 1020,1185
to flow in and come

186
00:05:37,820 --> 00:05:39,410
0,260 400,780 780,1065 1065,1410 1410,1590
out with one node at

187
00:05:39,410 --> 00:05:40,370
0,165 165,375 375,585 585,765 765,960
the top,| which is going
|将是该查询的输出。

188
00:05:40,370 --> 00:05:41,345
0,135 135,255 255,530 580,840 840,975
to be the output of

189
00:05:41,345 --> 00:05:42,260
0,180 180,515
that query.|
|

190
00:05:44,050 --> 00:05:45,315
0,290 290,485 485,725 725,1070 1070,1265
All right, now let's jump
好了，现在让我们跳到，

191
00:05:45,315 --> 00:05:48,435
0,305 1555,1935 1935,2205 2205,2495 2725,3120
into,| what are we trying
|我们试图用这些运算符的算法来做什么。

192
00:05:48,435 --> 00:05:49,845
0,255 255,405 405,555 555,815 865,1410
to do with the algorithms

193
00:05:49,845 --> 00:05:51,795
0,210 210,375 375,875 1585,1830 1830,1950
for these operators.| So the
|所以第一件事是数据库需要处理大量的数据，

194
00:05:51,795 --> 00:05:53,070
0,195 195,375 375,525 525,1110 1110,1275
first thing is databases need

195
00:05:53,070 --> 00:05:54,885
0,150 150,410 430,830 1180,1545 1545,1815
to work with large amounts

196
00:05:54,885 --> 00:05:57,140
0,180 180,455 925,1325
of data,| so,
|所以，我们希望我们的运算符算法处理内存无法容纳的数据，

197
00:05:57,140 --> 00:05:59,710
0,225 225,495 495,860 1360,1760 1930,2570
we want our operator algorithms

198
00:06:00,330 --> 00:06:02,345
0,400 1050,1355 1355,1535 1535,1730 1730,2015
to work on data that

199
00:06:02,345 --> 00:06:03,620
0,315 315,525 525,660 660,935 985,1275
cannot fit in memory,| so
|因此我们希望能够处理

200
00:06:03,620 --> 00:06:04,445
0,165 165,330 330,465 465,585 585,825
we want to be able

201
00:06:04,445 --> 00:06:05,900
0,285 285,510 510,815 835,1215 1215,1455
to deal with| data that
|远远大于我们可用的内存的数据。

202
00:06:05,900 --> 00:06:06,965
0,240 240,540 540,765 765,930 930,1065
is far bigger than the

203
00:06:06,965 --> 00:06:08,080
0,210 210,435 435,585 585,780 780,1115
memory that we have available.|
|

204
00:06:09,240 --> 00:06:11,225
0,400 1050,1340 1340,1565 1565,1775 1775,1985
Second, we want to use
第二，我们希望使用可用的内存，

205
00:06:11,225 --> 00:06:12,430
0,225 225,480 480,705 705,885 885,1205
the memory that is available|
|

206
00:06:12,780 --> 00:06:13,730
0,305 305,590 590,680 680,800 800,950
and that's in the form
以缓冲池的形式，

207
00:06:13,730 --> 00:06:15,050
0,150 150,270 270,570 570,860 1060,1320
of the buffer pool,| we
|我们希望尽可能高效地使用该内存，

208
00:06:15,050 --> 00:06:16,130
0,150 150,360 360,680 700,960 960,1080
want that memory to be

209
00:06:16,130 --> 00:06:18,010
0,225 225,590 670,1350 1350,1545 1545,1880
used as efficiently as possible|
|

210
00:06:18,600 --> 00:06:19,910
0,275 275,410 410,560 560,850 1050,1310
and this is where we
这就是我们将页面放入缓冲池，

211
00:06:19,910 --> 00:06:20,960
0,180 180,405 405,645 645,885 885,1050
will bring pages into the

212
00:06:20,960 --> 00:06:22,730
0,300 300,590 820,1200 1200,1500 1500,1770
buffer pool,| we'll apply some
|我们应用某种类型的缓冲区替换策略，

213
00:06:22,730 --> 00:06:23,855
0,135 135,240 240,360 360,770 820,1125
sort of a buffer {}

214
00:06:23,855 --> 00:06:26,470
0,305 565,1065 1065,1355 1855,2295 2295,2615
{} replacement policy,| you've implemented
|你们在上一次作业中实现的 LRU-2(LRU-K) ，

215
00:06:26,580 --> 00:06:28,180
0,305 305,530 530,850 1050,1325 1325,1600
{LRU-2 - -} in the

216
00:06:28,260 --> 00:06:30,815
0,400 960,1570 1800,2105 2105,2345 2345,2555
last assignment| and so you
|所以你们知道这些东西是如何运作的，

217
00:06:30,815 --> 00:06:32,020
0,195 195,420 420,645 645,885 885,1205
know how those things work|
|

218
00:06:32,280 --> 00:06:33,500
0,275 275,530 530,695 695,980 980,1220
and that's what we are
这就是我们正在努力做的，

219
00:06:33,500 --> 00:06:34,160
0,150 150,285 285,435 435,555 555,660
trying to do,| we are
|我们试图尽量避免访问磁盘，

220
00:06:34,160 --> 00:06:35,420
0,165 165,390 390,740 820,1110 1110,1260
trying to avoid going to

221
00:06:35,420 --> 00:06:36,575
0,150 150,540 540,735 735,960 960,1155
the disk as much as

222
00:06:36,575 --> 00:06:38,950
0,305 955,1355 1405,1830 1830,2040 2040,2375
possible,| because accessing a page
|因为访问内存中缓冲池中的页面，

223
00:06:39,180 --> 00:06:40,400
0,335 335,545 545,875 875,1040 1040,1220
in the buffer pool in

224
00:06:40,400 --> 00:06:42,680
0,290 730,1130 1210,1560 1560,1800 1800,2280
memory| is orders of magnitude
|比访问磁盘要便宜几个数量级。

225
00:06:42,680 --> 00:06:43,760
0,300 300,570 570,795 795,975 975,1080
cheaper than going to the

226
00:06:43,760 --> 00:06:44,460
0,260
disk.|
|

227
00:06:44,950 --> 00:06:45,870
0,260 260,410 410,605 605,755 755,920
And now things get even
现在，在云环境中，事情变得更加复杂，

228
00:06:45,870 --> 00:06:47,535
0,225 225,530 670,990 990,1290 1290,1665
more complicated in cloud settings,|
|

229
00:06:47,535 --> 00:06:48,960
0,270 270,545 595,960 960,1140 1140,1425
we both delve into that
我们在本课程中对此进行了深入研究，

230
00:06:48,960 --> 00:06:50,265
0,210 210,375 375,680 880,1140 1140,1305
in this class,| but the
|但是高级数据库课程对此进行了更详细的介绍，

231
00:06:50,265 --> 00:06:51,690
0,225 225,545 655,1005 1005,1230 1230,1425
advanced database class goes into

232
00:06:51,690 --> 00:06:52,940
0,210 210,360 360,540 540,855 855,1250
that in much more detail,|
|

233
00:06:53,080 --> 00:06:54,180
0,365 365,590 590,755 755,920 920,1100
sometimes the data is not
有时数据不是来自本地磁盘，

234
00:06:54,180 --> 00:06:55,275
0,240 240,465 465,810 810,930 930,1095
coming from disk that is

235
00:06:55,275 --> 00:06:56,475
0,305 325,615 615,780 780,960 960,1200
local,| it may come from
|它可能来自远程云存储，

236
00:06:56,475 --> 00:06:57,920
0,315 315,645 645,855 855,1080 1080,1445
cloud storage that is remote,|
|

237
00:06:58,030 --> 00:06:59,190
0,290 290,440 440,590 590,830 830,1160
which could be even more
这可能会更加昂贵，

238
00:06:59,190 --> 00:07:01,455
0,380 970,1365 1365,1590 1590,1755 1755,2265
expensive,| sometimes there are configurations,|
|有时会有这样的配置，|

239
00:07:01,455 --> 00:07:02,400
0,255 255,360 360,510 510,705 705,945
where the data is coming
数据来自不同节点的内存，

240
00:07:02,400 --> 00:07:04,190
0,300 300,650 730,1130 1150,1470 1470,1790
from memory from a different

241
00:07:04,210 --> 00:07:05,295
0,380 380,500 500,650 650,815 815,1085
node,| in which case, it's
|在这种情况下，它不像访问磁盘那样昂贵，

242
00:07:05,295 --> 00:07:06,560
0,180 180,435 435,720 720,960 960,1265
not as expensive as going

243
00:07:06,850 --> 00:07:07,770
0,245 245,365 365,635 635,725 725,920
to a disk,| but it's
|但仍然比访问本地内存中的数据更昂贵。

244
00:07:07,770 --> 00:07:09,315
0,135 135,375 375,735 735,1125 1125,1545
still more expensive than accessing

245
00:07:09,315 --> 00:07:11,260
0,305 475,765 765,1035 1035,1415
data in local memory.|
|

246
00:07:11,590 --> 00:07:12,795
0,320 320,640 690,950 950,1085 1085,1205
So regardless of where the
所以，无论数据来自哪里，

247
00:07:12,795 --> 00:07:13,770
0,135 135,315 315,540 540,765 765,975
data is coming from,| there's
|数据所在位置都有一个层次结构，

248
00:07:13,770 --> 00:07:15,090
0,90 90,720 720,1005 1005,1185 1185,1320
a hierarchy for where the

249
00:07:15,090 --> 00:07:16,730
0,195 195,530 940,1215 1215,1365 1365,1640
data lives,| and you want
|你希望使用位于 DRAM 中的缓冲池，

250
00:07:16,780 --> 00:07:17,835
0,260 260,410 410,560 560,875 875,1055
to use the buffer pool,

251
00:07:17,835 --> 00:07:18,960
0,165 165,315 315,525 525,825 825,1125
which is sitting in DRAM,|
|

252
00:07:18,960 --> 00:07:20,085
0,165 165,345 345,795 795,960 960,1125
that is closest to where
它最接近尽可能高效地处理东西的位置，

253
00:07:20,085 --> 00:07:21,630
0,195 195,330 330,525 525,1200 1200,1545
things are getting processed as

254
00:07:21,630 --> 00:07:23,660
0,495 495,660 660,980 1480,1755 1755,2030
efficiently as possible,| but we
|但我们也希望我们的算法能够处理大量数据。

255
00:07:23,740 --> 00:07:25,470
0,260 260,395 395,670 720,1300 1470,1730
also want our algorithms to

256
00:07:25,470 --> 00:07:26,490
0,150 150,330 330,570 570,825 825,1020
work on large amounts of

257
00:07:26,490 --> 00:07:28,590
0,290 760,1125 1125,1490 1600,1890 1890,2100
data.| And generally when we
|通常在我们必须去从磁盘取回东西的时候，

258
00:07:28,590 --> 00:07:29,690
0,270 270,495 495,630 630,780 780,1100
have to go and fetch

259
00:07:29,830 --> 00:07:32,220
0,400 990,1310 1310,1505 1505,2080
something from the disk,|
|

260
00:07:32,320 --> 00:07:34,260
0,320 320,590 590,940 1050,1630 1650,1940
we want the I/O access
我们希望 I/O 访问模式是顺序的，

261
00:07:34,260 --> 00:07:36,195
0,290 580,825 825,960 960,1650 1650,1935
pattern to be sequential,| because
|因为通常情况下，磁盘会更好，

262
00:07:36,195 --> 00:07:39,470
0,365 535,1175 1465,1865 2215,2615 2875,3275
generally disks are { -}

263
00:07:39,520 --> 00:07:41,190
0,400 720,995 995,1145 1145,1385 1385,1670
better,| if you ask them
|如果你请求一堆页面，是顺序的而不是随机的。

264
00:07:41,190 --> 00:07:42,630
0,320 520,825 825,1035 1035,1215 1215,1440
for a bunch of pages

265
00:07:42,630 --> 00:07:44,160
0,675 675,840 840,1335 1335,1440 1440,1530
sequentially than randomly.| So if
|所以，如果你需要到磁盘获取十个页面，

266
00:07:44,160 --> 00:07:45,135
0,120 120,300 300,570 570,825 825,975
you need to go to

267
00:07:45,135 --> 00:07:46,560
0,120 120,555 555,795 795,1125 1125,1425
the disk and fetch ten

268
00:07:46,560 --> 00:07:49,065
0,320 880,1245 1245,1610 1630,2030 2200,2505
pages| and if your access
|如果你的访问模式，你的操作符，

269
00:07:49,065 --> 00:07:51,150
0,285 285,665 685,1085 1225,1625 1705,2085
pattern, your operator| is asking
|要求在磁盘上的任意位置获取这十个页面，

270
00:07:51,150 --> 00:07:52,740
0,240 240,390 390,570 570,860 1270,1590
for those ten pages at

271
00:07:52,740 --> 00:07:54,290
0,320 340,690 690,915 915,1035 1035,1550
random locations on the disk,|
|

272
00:07:54,520 --> 00:07:55,695
0,305 305,470 470,725 725,995 995,1175
compared to asking for ten
与请求在磁盘上连续或连续的十个页面相比，

273
00:07:55,695 --> 00:07:57,930
0,305 685,960 960,1235 1255,2010 2010,2235
pages that are contiguous or

274
00:07:57,930 --> 00:07:59,670
0,525 525,720 720,885 885,1340 1450,1740
sequential together on disk,| the
|后者几乎总是更快。

275
00:07:59,670 --> 00:08:01,065
0,240 240,480 480,770 910,1215 1215,1395
latter is nearly always going

276
00:08:01,065 --> 00:08:02,250
0,120 120,255 255,545 805,1050 1050,1185
to be faster.| So we
|所以，我们希望我们的算法高效地使用缓冲池，

277
00:08:02,250 --> 00:08:04,845
0,290 670,1070 1660,2190 2190,2400 2400,2595
want our algorithms to use

278
00:08:04,845 --> 00:08:06,510
0,165 165,435 435,630 630,1320 1320,1665
the buffer pool efficiently| and
|并且当我们必须访问磁盘时，

279
00:08:06,510 --> 00:08:07,320
0,240 240,390 390,525 525,660 660,810
when we have to go

280
00:08:07,320 --> 00:08:08,475
0,150 150,600 600,855 855,1020 1020,1155
to disk,| do that in
|以一种最大限度地减少从磁盘获取这些页面所需的时间的方式来完成这项工作。

281
00:08:08,475 --> 00:08:10,575
0,105 105,365 625,1025 1225,1845 1845,2100
a way that minimizes the

282
00:08:10,575 --> 00:08:11,505
0,180 180,390 390,570 570,765 765,930
time that might need to

283
00:08:11,505 --> 00:08:13,290
0,135 135,420 420,785 1045,1445 1495,1785
go fetch those pages from

284
00:08:13,290 --> 00:08:13,980
0,470
disk.|
|

285
00:08:14,970 --> 00:08:15,875
0,350 350,575 575,680 680,770 770,905
So, how do we do
那么，我们如何做到这个呢，

286
00:08:15,875 --> 00:08:18,280
0,275 625,930 930,1125 1125,1475 2005,2405
that,| we'll go through sort
|在今天的课程中，我们将介绍排序和聚合操作，

287
00:08:18,420 --> 00:08:21,110
0,335 335,1000 1440,1840 2040,2315 2315,2690
and aggregation operations in today's

288
00:08:21,110 --> 00:08:22,190
0,210 210,420 420,675 675,900 900,1080
lecture,| and we'll continue with
|在后续课程中，我们将继续讨论 JOIN 和其他操作。

289
00:08:22,190 --> 00:08:24,440
0,315 315,405 405,645 645,1040 1990,2250
JOIN and other operations in

290
00:08:24,440 --> 00:08:26,120
0,120 120,380 490,1100
the subsequent lectures.|
|

291
00:08:26,350 --> 00:08:27,720
0,290 290,500 500,725 725,1030 1110,1370
So, starting with sort,| the
所以，从排序开始，|可能会想到的第一个问题是，

292
00:08:27,720 --> 00:08:28,995
0,165 165,435 435,800 820,1110 1110,1275
first question that might come

293
00:08:28,995 --> 00:08:30,345
0,135 135,315 315,635 775,1020 1020,1350
to mind is,| the relational
|关系模型，它基于关系代数，基于集合论，

294
00:08:30,345 --> 00:08:32,040
0,395 955,1215 1215,1350 1350,1530 1530,1695
model, which is based on

295
00:08:32,040 --> 00:08:33,945
0,285 285,1010 1180,1470 1470,1665 1665,1905
relational algebra, is based on

296
00:08:33,945 --> 00:08:36,170
0,255 255,575 1135,1535 1555,1890 1890,2225
set theory| and sets are
|集合是不排序的，

297
00:08:36,310 --> 00:08:37,425
0,335 335,725 725,860 860,995 995,1115
not sorted,| so why do
|那么，我们为什么需要排序？

298
00:08:37,425 --> 00:08:38,620
0,120 120,315 315,815
we need sort?|
|

299
00:08:38,660 --> 00:08:40,780
0,320 320,880 1170,1570 1590,1925 1925,2120
Now, SQL has that,| so
现在， SQL 有这个，|所以我们需要排序，原因有很多。

300
00:08:40,780 --> 00:08:41,560
0,105 105,255 255,585 585,690 690,780
we need sorting for a

301
00:08:41,560 --> 00:08:42,810
0,165 165,345 345,620 670,960 960,1250
number of reasons.| One is,
|一个是， SQL 有一个 ORDER BY 子句，

302
00:08:42,950 --> 00:08:44,785
0,470 470,760 990,1295 1295,1565 1565,1835
SQL has an ORDER BY

303
00:08:44,785 --> 00:08:46,285
0,335 655,915 915,1050 1050,1260 1260,1500
clause| and that ORDER BY
|ORDER BY 子句要求生成数据，

304
00:08:46,285 --> 00:08:47,970
0,335 595,990 990,1260 1260,1410 1410,1685
clause requires that the data

305
00:08:48,230 --> 00:08:50,050
0,380 380,760 810,1130 1130,1450 1530,1820
be produced,| the final result
|最终结果按照 ORDER BY 子句中指定的列进行排序，

306
00:08:50,050 --> 00:08:52,075
0,240 240,590 760,1340 1450,1770 1770,2025
be produced sorted by the

307
00:08:52,075 --> 00:08:54,025
0,285 285,480 480,725 1105,1710 1710,1950
column that is specified in

308
00:08:54,025 --> 00:08:55,735
0,120 120,285 285,510 510,845 1405,1710
the ORDER BY clause,| and
|有时，你需要 SQL ，

309
00:08:55,735 --> 00:08:57,565
0,305 325,585 585,795 795,1385 1555,1830
sometimes you need SQL,| you
|你需要排序能够应用像 DISTINCT 这样的操作，

310
00:08:57,565 --> 00:08:58,765
0,180 180,725 745,990 990,1065 1065,1200
need sorting to be able

311
00:08:58,765 --> 00:09:00,340
0,210 210,510 510,900 900,1290 1290,1575
to apply operations like DISTINCT,|
|

312
00:09:00,340 --> 00:09:01,620
0,165 165,390 390,525 525,800
and we'll see that.|
我们将看到这个。|

313
00:09:01,620 --> 00:09:02,985
0,495 495,885 885,1125 1125,1230 1230,1365
Aggregations can also be done
聚合也可以使用排序来完成，

314
00:09:02,985 --> 00:09:04,440
0,275 295,905 955,1200 1200,1320 1320,1455
using sorting| and as we
|随着我们今天在本课程的后半部分进入聚合，

315
00:09:04,440 --> 00:09:05,840
0,120 120,285 285,855 855,1125 1125,1400
get into aggregations in the

316
00:09:06,070 --> 00:09:07,560
0,320 320,530 530,725 725,1030 1110,1490
second half of this lecture

317
00:09:07,560 --> 00:09:09,135
0,380 670,1035 1035,1215 1215,1410 1410,1575
today,| we'll see that there
|我们将看到有基于排序的方法来计算聚合运算符，

318
00:09:09,135 --> 00:09:11,415
0,275 715,1115 1135,1500 1500,1865 1945,2280
are sort based methods to

319
00:09:11,415 --> 00:09:13,395
0,335 385,645 645,1125 1125,1475 1705,1980
evaluate the aggregate operator,| but
|但它们也是基于哈希的方法来实现这个，

320
00:09:13,395 --> 00:09:14,445
0,120 120,285 285,510 510,825 825,1050
they are also hash based

321
00:09:14,445 --> 00:09:15,960
0,335 355,615 615,735 735,995 1225,1515
methods to do that,| and
|我们将看到排序和哈希之间的二元性，

322
00:09:15,960 --> 00:09:17,775
0,345 345,525 525,705 705,1485 1485,1815
we'll see that duality between

323
00:09:17,775 --> 00:09:19,815
0,575 625,960 960,1565 1735,1965 1965,2040
sorting and hashing,| they are
|它们就像兄弟一样，互相竞争，

324
00:09:19,815 --> 00:09:21,240
0,210 210,645 645,795 795,960 960,1425
like siblings that are rivaling

325
00:09:21,240 --> 00:09:22,815
0,180 180,360 360,650 1000,1305 1305,1575
with each other| in terms
|在何时进行排序以评估特定操作比哈希更好方面，

326
00:09:22,815 --> 00:09:24,690
0,365 535,825 825,1110 1110,1620 1620,1875
of when is sorting better

327
00:09:24,690 --> 00:09:26,360
0,270 270,675 675,870 870,1160 1270,1670
for evaluating a specific operations

328
00:09:26,380 --> 00:09:29,055
0,400 450,1120 1650,2050 2100,2555 2555,2675
versus hashing,| generally, hashing is
|总的来说，哈希将会更好，

329
00:09:29,055 --> 00:09:30,465
0,150 150,270 270,405 405,695 1105,1410
going to be better| and
|这个现在是众所周知的，

330
00:09:30,465 --> 00:09:31,500
0,285 285,450 450,660 660,870 870,1035
that's well known now,| but
|但在社区中有一段时间这是一场活跃的辩论，

331
00:09:31,500 --> 00:09:32,085
0,90 90,165 165,300 300,465 465,585
there was a time in

332
00:09:32,085 --> 00:09:33,240
0,165 165,485 535,825 825,1005 1005,1155
the community where that was

333
00:09:33,240 --> 00:09:35,115
0,105 105,350 430,830 1120,1635 1635,1875
an active debate,| sorting still
|排序在许多情况下仍然有用，

334
00:09:35,115 --> 00:09:36,555
0,255 255,480 480,675 675,995 1165,1440
helps in many cases| and
|我们将讨论这个，

335
00:09:36,555 --> 00:09:38,025
0,195 195,375 375,585 585,875 1165,1470
we'll talk about that,| those
|这些情况在很大程度上将集中在数据已经预先排序的情况下，

336
00:09:38,025 --> 00:09:38,985
0,240 240,435 435,660 660,870 870,960
cases are largely going to

337
00:09:38,985 --> 00:09:40,170
0,120 120,420 420,645 645,945 945,1185
be centered around when data

338
00:09:40,170 --> 00:09:42,020
0,240 240,540 540,780 780,1280 1450,1850
is already pre sorted,| then
|然后，你可以，基于排序的方法很可能会胜过基于哈希的方法，

339
00:09:42,160 --> 00:09:43,785
0,275 275,550 870,1160 1160,1370 1370,1625
you can, the sort based

340
00:09:43,785 --> 00:09:45,150
0,330 330,615 615,885 885,1170 1170,1365
methods will likely win over

341
00:09:45,150 --> 00:09:46,845
0,150 150,390 390,600 600,920 1450,1695
the hash based methods,| and
|当然，如果因为有 ORDER BY 而必须生成记录，

342
00:09:46,845 --> 00:09:47,745
0,165 165,450 450,675 675,780 780,900
of course if you have

343
00:09:47,745 --> 00:09:49,095
0,195 195,450 450,785 925,1185 1185,1350
to produce records because there's

344
00:09:49,095 --> 00:09:50,235
0,105 105,360 360,720 720,990 990,1140
an ORDER BY,| you will
|你必须对最终结果进行排序。

345
00:09:50,235 --> 00:09:51,405
0,165 165,330 330,555 555,810 810,1170
have to do a sorting

346
00:09:51,405 --> 00:09:52,820
0,135 135,285 285,575 625,1025
for that final result.|
|

347
00:09:53,050 --> 00:09:54,320
0,290 290,580
Okay, but,|
好的，但是，|

348
00:09:54,330 --> 00:09:55,640
0,320 320,515 515,755 755,1145 1145,1310
many of these algorithms we're
我们将在后面的课程中研究许多聚合 JOIN 算法，

349
00:09:55,640 --> 00:09:56,830
0,105 105,225 225,345 345,555 555,1190
going to look at aggregation

350
00:09:57,300 --> 00:09:59,690
0,410 410,560 560,850 1350,1750 2070,2390
JOINs in later classes,| they'll
|它们将具有基于排序的方法和基于哈希的方法，

351
00:09:59,690 --> 00:10:01,145
0,120 120,410 580,900 900,1185 1185,1455
have a sort based approach

352
00:10:01,145 --> 00:10:02,290
0,150 150,255 255,510 510,780 780,1145
and a hash based approach,|
|

353
00:10:02,370 --> 00:10:04,010
0,260 260,470 470,730 1080,1535 1535,1640
and they're constantly duelling with
并且它们不断地争斗以获得更高的性能。

354
00:10:04,010 --> 00:10:05,380
0,150 150,440 460,720 720,975 975,1370
each other for higher performance.|
|

355
00:10:07,280 --> 00:10:08,815
0,275 275,530 530,725 725,1060 1140,1535
So let's start with very
所以，让我们从最基本的内存排序开始，

356
00:10:08,815 --> 00:10:11,100
0,395 625,930 930,1235 1255,1865
basic {in-memory -} sorting,|
|

357
00:10:11,140 --> 00:10:12,195
0,275 275,410 410,635 635,890 890,1055
if the data fits in
如果数据可以存储在内存中，

358
00:10:12,195 --> 00:10:13,290
0,275 415,690 690,825 825,945 945,1095
memory,| then we can use
|那么我们可以使用快速排序这样的标准算法，

359
00:10:13,290 --> 00:10:14,910
0,210 210,530 760,1185 1185,1380 1380,1620
a standard algorithm like quick

360
00:10:14,910 --> 00:10:15,690
0,210 210,360 360,495 495,630 630,780
sort| and all of you
|你们都已经看过了一些内存中的排序算法，

361
00:10:15,690 --> 00:10:17,385
0,210 210,530 640,930 930,1220 1390,1695
guys have looked at a

362
00:10:17,385 --> 00:10:19,005
0,285 285,615 615,840 840,1080 1080,1620
number of in memory sorting

363
00:10:19,005 --> 00:10:21,015
0,635 1015,1320 1320,1560 1560,1785 1785,2010
algorithms| and yesterday in class,|
|昨天在课程上，|

364
00:10:21,015 --> 00:10:23,025
0,225 225,405 405,695 745,1475 1765,2010
many of you volunteered the
你们中的许多人自愿使用了不同类型的算法，

365
00:10:23,025 --> 00:10:24,480
0,195 195,450 450,705 705,1230 1230,1455
different types of algorithms,| some
|一些你们查看的其他算法，

366
00:10:24,480 --> 00:10:25,620
0,120 120,225 225,470 550,975 975,1140
of the other algorithms that

367
00:10:25,620 --> 00:10:27,375
0,225 225,360 360,650 940,1290 1290,1755
you've looked at,| including bubble
|包括气泡排序和插入排序，

368
00:10:27,375 --> 00:10:30,840
0,365 1735,2010 2010,2610 2610,2915
sort and insertion sort,|
|

369
00:10:31,680 --> 00:10:33,395
0,320 320,640 690,1090 1260,1535 1535,1715
most database systems,| when they
大多数数据库系统，|当它们必须在进行内存排序时，

370
00:10:33,395 --> 00:10:34,220
0,255 255,450 450,540 540,660 660,825
have to do an {in-memory

371
00:10:34,220 --> 00:10:35,750
0,290 310,710 880,1200 1200,1350 1350,1530
-} sort,| remember, we are
|记住，我们还要弄清楚如何对比内存大得多的数据进行排序，

372
00:10:35,750 --> 00:10:36,530
0,195 195,300 300,435 435,600 600,780
also going to figure out

373
00:10:36,530 --> 00:10:37,565
0,165 165,330 330,570 570,855 855,1035
how to sort things that

374
00:10:37,565 --> 00:10:39,700
0,165 165,480 480,875 1525,1830 1830,2135
are much larger than memory,|
|

375
00:10:39,720 --> 00:10:40,630
0,260 260,380 380,485 485,620 620,910
so that we can sort
这样我们就可以对超大的数据进行排序，

376
00:10:40,650 --> 00:10:42,440
0,350 350,620 620,860 860,1180 1410,1790
extremely large data| without requiring
|而不需要所有这些数据都放在内存中，

377
00:10:42,440 --> 00:10:43,175
0,195 195,300 300,465 465,615 615,735
all of that fit in

378
00:10:43,175 --> 00:10:44,825
0,275 715,1020 1020,1260 1260,1500 1500,1650
memory,| but there will be
|但是其中的一部分管理外部排序算法，

379
00:10:44,825 --> 00:10:46,240
0,135 135,360 360,570 570,845
a portion of that,

380
00:10:46,240 --> 00:10:49,420
0
,380 1360,1760 1780,2180 2290,2870 2890,3180
master external sort algorithm,| for
|对于需要在内存中对进行的排序，

381
00:10:49,420 --> 00:10:50,335
0,180 180,330 330,465 465,645 645,915
which you need to sort

382
00:10:50,335 --> 00:10:51,715
0,255 255,545 985,1245 1245,1320 1320,1380
in memory,| and so you
|所以你需要内存中的排序算法，

383
00:10:51,715 --> 00:10:52,890
0,120 120,330 330,570 570,825 825,1175
need an in memory sort

384
00:10:52,970 --> 00:10:54,355
0,440 440,575 575,755 755,1055 1055,1385
algorithm| and most database systems
|大多数数据库系统都会使用快速排序来实现内存中的排序，

385
00:10:54,355 --> 00:10:55,630
0,210 210,360 360,495 495,755 955,1275
are going to use quick

386
00:10:55,630 --> 00:10:56,635
0,255 255,450 450,600 600,765 765,1005
sort for this in memory

387
00:10:56,635 --> 00:10:58,060
0,365 415,995
sort algorithm,|
|

388
00:10:58,130 --> 00:10:59,820
0,335 335,485 485,725 725,1060 1290,1690
it's not quite true,| most,
这不完全是真的，|大多数数据库系统将使用快速排序来实现内存中的排序算法，

389
00:10:59,930 --> 00:11:01,525
0,290 290,575 575,935 935,1265 1265,1595
most database systems will use

390
00:11:01,525 --> 00:11:02,845
0,315 315,665 715,990 990,1155 1155,1320
quick sort for that in

391
00:11:02,845 --> 00:11:05,125
0,225 225,575 625,1125 1125,1475 1945,2280
memory sort algorithm,| but in
|但在快速排序中，

392
00:11:05,125 --> 00:11:06,355
0,255 255,575 625,900 900,1065 1065,1230
quick sort,| you find a
|你找到一个轴心点，

393
00:11:06,355 --> 00:11:07,555
0,270 270,540 540,765 765,960 960,1200
pivot point,| then you sort
|然后在两侧进行排序，

394
00:11:07,555 --> 00:11:08,890
0,195 195,435 435,785 985,1230 1230,1335
on both sides,| but if
|但如果一侧变得非常小，

395
00:11:08,890 --> 00:11:09,745
0,120 120,225 225,345 345,585 585,855
one of the sides becomes

396
00:11:09,745 --> 00:11:11,020
0,300 300,695
really small,|
|

397
00:11:11,020 --> 00:11:11,905
0,240 240,480 480,600 600,735 735,885
then they might end up
然后，他们可能会使用类似插入排序的方法，

398
00:11:11,905 --> 00:11:13,495
0,225 225,510 510,720 720,1335 1335,1590
using something like insertion sort,|
|

399
00:11:13,495 --> 00:11:14,520
0,210 210,375 375,510 510,720 720,1025
because it's just much faster,|
因为这样做会快得多，|

400
00:11:14,930 --> 00:11:16,440
0,260 260,350 350,580 690,1090 1110,1510
when you have really small
当记录的数量非常少时，

401
00:11:16,460 --> 00:11:18,070
0,290 290,470 470,760 1110,1385 1385,1610
number of records,| like maybe
|例如十条或二十条，

402
00:11:18,070 --> 00:11:20,410
0,350 430,765 765,1100 1720,2040 2040,2340
ten or twenty,| that number
|这一数字还取决于你运行的硬件。

403
00:11:20,410 --> 00:11:21,970
0,360 360,740 880,1200 1200,1410 1410,1560
really depends also on the

404
00:11:21,970 --> 00:11:22,930
0,240 240,480 480,600 600,810 810,960
hardware in which you're running

405
00:11:22,930 --> 00:11:23,740
0,320
on.|
|

406
00:11:24,140 --> 00:11:26,200
0,290 290,500 500,820 1320,1610 1610,2060
In data platform,| more sortably
在数据平台中，|更值得称道的是 Python ，

407
00:11:26,200 --> 00:11:27,340
0,420 420,570 570,705 705,885 885,1140
Python,| which is very popular
|在数据科学界非常流行，

408
00:11:27,340 --> 00:11:28,510
0,240 240,375 375,570 570,885 885,1170
in the data science world,|
|

409
00:11:28,510 --> 00:11:29,485
0,210 210,390 390,540 540,705 705,975
then many of those data
你经常看到的许多数据科学 notebook ，

410
00:11:29,485 --> 00:11:31,140
0,365 535,1095 1095,1215 1215,1365 1365,1655
science notebooks that you see,|
|

411
00:11:31,250 --> 00:11:32,665
0,350 350,620 620,940 1110,1340 1340,1415
often get connected to a
都要连接到关系数据库来获取数据，

412
00:11:32,665 --> 00:11:34,225
0,345 345,725 865,1125 1125,1305 1305,1560
relational database to go pull

413
00:11:34,225 --> 00:11:35,440
0,270 270,450 450,705 705,915 915,1215
stuff,| so it's like the
|它就像是扩展，

414
00:11:35,440 --> 00:11:37,195
0,380 700,990 990,1215 1215,1515 1515,1755
extension,| in many cases of
|在很多情况下，用于进行数据科学工作，

415
00:11:37,195 --> 00:11:38,620
0,150 150,425 535,935 1015,1275 1275,1425
the database platform for doing

416
00:11:38,620 --> 00:11:40,435
0,255 255,570 570,920 1150,1455 1455,1815
data science work,| and Python
|很多这样的事情都是用 Python 语言来完成的，

417
00:11:40,435 --> 00:11:41,230
0,90 90,195 195,435 435,675 675,795
is a language in which

418
00:11:41,230 --> 00:11:42,070
0,120 120,255 255,420 420,615 615,840
a lot of these things

419
00:11:42,070 --> 00:11:44,350
0,210 210,500 940,1610 1870,2130 2130,2280
get done,| Python, you can
|你可以将数据拉入到 Python 数据结构中，

420
00:11:44,350 --> 00:11:45,880
0,165 165,360 360,680 820,1290 1290,1530
pull data into Python data

421
00:11:45,880 --> 00:11:48,160
0,350 760,1050 1050,1260 1260,1490 1930,2280
structures| and there's a default
|并且在 Python 中有一个默认的排序机制，

422
00:11:48,160 --> 00:11:51,120
0,315 315,680 1060,1460 1720,2390
sort mechanism in Python,|
|

423
00:11:51,340 --> 00:11:52,920
0,290 290,530 530,880 930,1295 1295,1580
and that uses something called
这使用了一种叫做 TimSort 的东西，

424
00:11:52,920 --> 00:11:53,760
0,240 240,465 465,615 615,720 720,840
{TimSort -},| which is a
|它是插入排序和二分排序的组合。

425
00:11:53,760 --> 00:11:55,395
0,260 310,555 555,1140 1140,1380 1380,1635
combination of insertion sort and

426
00:11:55,395 --> 00:11:56,985
0,420 420,755 1075,1335 1335,1485 1485,1590
binary sort.| So there's a
|所以有很多内存中的排序算法，

427
00:11:56,985 --> 00:11:58,515
0,165 165,450 450,735 735,990 990,1530
lot of in memory sorting

428
00:11:58,515 --> 00:12:00,920
0,575 865,1265 1495,1860 1860,2055 2055,2405
algorithms| and it's really fun
|去看看它们并思考真的很有趣，

429
00:12:00,940 --> 00:12:01,860
0,275 275,440 440,620 620,770 770,920
to go and look at

430
00:12:01,860 --> 00:12:03,050
0,210 210,450 450,675 675,885 885,1190
them and think about that,|
|

431
00:12:03,220 --> 00:12:04,980
0,290 290,500 500,820 930,1280 1280,1760
and what combination of algorithms
最有效的算法组合也在变化，即使在今天，

432
00:12:04,980 --> 00:12:07,125
0,360 360,740 1150,1500 1500,1830 1830,2145
works best is changing, even

433
00:12:07,125 --> 00:12:08,580
0,335 625,885 885,1005 1005,1215 1215,1455
today,| because the hardware is
|因为硬件在变化，一些考虑因素也在变化，

434
00:12:08,580 --> 00:12:10,370
0,290 310,555 555,690 690,980 1270,1790
changing, some of the considerations

435
00:12:10,480 --> 00:12:12,750
0,400 720,1120 1320,1720 1770,2075 2075,2270
change,| and sometimes depending upon
|有时取决于数据分布，

436
00:12:12,750 --> 00:12:14,655
0,150 150,410 430,830 1150,1545 1545,1905
the data distribution,| which algorithm
|哪种算法对内存中的排序组件会做得更好也在变化。

437
00:12:14,655 --> 00:12:15,375
0,120 120,240 240,330 330,480 480,720
is going to do better

438
00:12:15,375 --> 00:12:16,455
0,195 195,360 360,525 525,735 735,1080
for this in memory sort

439
00:12:16,455 --> 00:12:18,520
0,395 835,1125 1125,1415
component also changes.|
|

440
00:12:18,900 --> 00:12:19,655
0,245 245,425 425,515 515,620 620,755
So let's go and take
所以，让我们来快速了解一下几个排序算法，并将它们可视化。

441
00:12:19,655 --> 00:12:21,365
0,275 295,600 600,870 870,1235 1315,1710
a quick look at a

442
00:12:21,365 --> 00:12:23,345
0,360 360,725 745,1245 1245,1440 1440,1980
couple sort algorithms and visualize

443
00:12:23,345 --> 00:12:24,755
0,335 715,1005 1005,1110 1110,1260 1260,1410
them.| I'm not going to
|我不会详细介绍所有排序算法的细节，

444
00:12:24,755 --> 00:12:25,625
0,150 150,285 285,405 405,630 630,870
go in through the details

445
00:12:25,625 --> 00:12:27,125
0,165 165,390 390,630 630,935 1015,1500
of all the sort algorithms,|
|

446
00:12:27,125 --> 00:12:27,920
0,165 165,300 300,435 435,615 615,795
but let me just pull
但让我打开这个网页，

447
00:12:27,920 --> 00:12:29,240
0,210 210,465 465,945 945,1155 1155,1320
up this webpage| and bear
|请容忍我，我试图将窗口重新聚焦并到 Zoom 这里，

448
00:12:29,240 --> 00:12:30,245
0,180 180,300 300,390 390,650 730,1005
with me as I try

449
00:12:30,245 --> 00:12:31,625
0,165 165,405 405,720 720,1080 1080,1380
to bring that window back

450
00:12:31,625 --> 00:12:33,610
0,255 255,605 835,1235 1315,1665 1665,1985
into focus and Zoom here,|
|

451
00:12:34,230 --> 00:12:35,380
0,400

452
00:12:35,380 --> 00:12:36,070
0,150 150,270 270,375 375,510 510,690
and so as you can
正如你在这里看到的，

453
00:12:36,070 --> 00:12:37,015
0,210 210,480 480,720 720,825 825,945
see here,| this is a
|这是一个页面，

454
00:12:37,015 --> 00:12:38,065
0,180 180,390 390,645 645,870 870,1050
page,| in which we can
|我们可以在其中查看一些不同的排序算法。

455
00:12:38,065 --> 00:12:39,055
0,210 210,450 450,660 660,825 825,990
look at a number of

456
00:12:39,055 --> 00:12:41,100
0,255 255,635 775,1355
different sort algorithms.|
|

457
00:12:41,650 --> 00:12:43,215
0,350 350,530 530,620 620,880 1230,1565
Again, we are focusing just
再次，我们在这里只关注内存中的排序方法，

458
00:12:43,215 --> 00:12:45,075
0,315 315,600 600,905 1165,1515 1515,1860
on {in-memory -} sort methods

459
00:12:45,075 --> 00:12:46,140
0,395
here,|
|

460
00:12:46,180 --> 00:12:47,370
0,365 365,605 605,770 770,965 965,1190
and the key point over
这里的关键点是，

461
00:12:47,370 --> 00:12:49,305
0,320 400,705 705,975 975,1340 1450,1935
here is that,| which algorithm
|哪种算法获胜，

462
00:12:49,305 --> 00:12:50,490
0,300 300,555 555,735 735,930 930,1185
wins,| is going to depend
|将取决于数据分布，

463
00:12:50,490 --> 00:12:51,860
0,350 490,795 795,990 990,1125 1125,1370
upon things like the data

464
00:12:51,910 --> 00:12:54,195
0,400 1050,1450 1470,1730 1730,1865 1865,2285
distribution| and also the inherent
|以及算法的固有属性。

465
00:12:54,195 --> 00:12:56,080
0,360 360,630 630,855 855,1415
properties of the algorithm.|
|

466
00:12:56,570 --> 00:12:57,670
0,400 450,800 800,890 890,995 995,1100
So let's take a look
所以，让我们随便看看，

467
00:12:57,670 --> 00:12:59,245
0,225 225,590 670,1070 1090,1455 1455,1575
at random| and let's go
|让我们把这个放大，

468
00:12:59,245 --> 00:13:00,130
0,135 135,330 330,510 510,705 705,885
and bump this up,| so
|这样我们就有了 50 个数据点，

469
00:13:00,130 --> 00:13:00,985
0,135 135,255 255,390 390,600 600,855
that we have 50 data

470
00:13:00,985 --> 00:13:01,945
0,315 315,555 555,690 690,825 825,960
points,| so that we can
|这样我们就可以看到模拟发生的时间更长一点。

471
00:13:01,945 --> 00:13:03,130
0,135 135,270 270,690 690,1005 1005,1185
see the simulation happen for

472
00:13:03,130 --> 00:13:04,500
0,60 60,195 195,375 375,650
a little bit longer.|
|

473
00:13:04,500 --> 00:13:05,535
0,210 210,300 300,420 420,675 675,1035
I'm going to run random
我将随机运行，然后看这个，

474
00:13:05,535 --> 00:13:06,600
0,240 240,420 420,675 675,915 915,1065
and just watch this,| this
|这个是插入排序，

475
00:13:06,600 --> 00:13:08,505
0,120 120,675 675,900 900,1220 1600,1905
is insertion sort here,| this
|这是归并排序，

476
00:13:08,505 --> 00:13:10,395
0,305 355,755 775,1245 1245,1545 1545,1890
is {} merge sort,| we'll
|稍后我们将使用类似的东西，

477
00:13:10,395 --> 00:13:11,850
0,240 240,585 585,870 870,1170 1170,1455
use something like that later

478
00:13:11,850 --> 00:13:13,215
0,290 430,705 705,855 855,1215 1215,1365
on| as a primitive for
|作为构建外部排序方法的原语，

479
00:13:13,215 --> 00:13:15,800
0,210 210,495 495,845 1855,2220 2220,2585
building that external sort method,|
|

480
00:13:15,850 --> 00:13:16,725
0,320 320,410 410,515 515,680 680,875
we're going to talk about
我们稍后将讨论这个，

481
00:13:16,725 --> 00:13:18,000
0,120 120,225 225,485 805,1095 1095,1275
in a second,| and then
|然后是快速排序，

482
00:13:18,000 --> 00:13:19,350
0,165 165,360 360,600 600,920 1090,1350
here is quick sort| and
|这也是快速排序，

483
00:13:19,350 --> 00:13:20,355
0,105 105,255 255,510 510,780 780,1005
this is quick sort,| that
|它分为三个部分。

484
00:13:20,355 --> 00:13:21,285
0,225 225,360 360,465 465,675 675,930
splits it up into three

485
00:13:21,285 --> 00:13:22,260
0,270 270,540 540,630 630,795 795,975
parts.| Let's just go run
|我们运行这个，

486
00:13:22,260 --> 00:13:22,980
0,290
that,|
|

487
00:13:23,090 --> 00:13:24,025
0,275 275,410 410,575 575,770 770,935
as you can see,| things
正如你所看到的，|事情正在排序，

488
00:13:24,025 --> 00:13:26,310
0,135 135,345 345,905 1135,1535 1885,2285
are getting sorted,| {} and
|这是随机数据，

489
00:13:26,600 --> 00:13:28,015
0,275 275,425 425,680 680,1060 1110,1415
this is random data,| so
|所以右边的这些算法，

490
00:13:28,015 --> 00:13:29,395
0,305 355,765 765,975 975,1185 1185,1380
these algorithms here on this

491
00:13:29,395 --> 00:13:30,360
0,225 225,435 435,585 585,705 705,965
right side,| which are more
|更复杂，会做得更好，

492
00:13:30,410 --> 00:13:31,495
0,400 480,740 740,875 875,995 995,1085
complex, are going to do

493
00:13:31,495 --> 00:13:32,320
0,105 105,270 270,495 495,675 675,825
a lot better,| you can
|你可以看到堆排序快完成了，

494
00:13:32,320 --> 00:13:33,355
0,165 165,420 420,600 600,780 780,1035
see heap sort is nearly

495
00:13:33,355 --> 00:13:35,005
0,285 285,605 955,1260 1260,1455 1455,1650
done there,| quick sort is
|快速排序快完成了，

496
00:13:35,005 --> 00:13:37,240
0,255 255,605 1285,1650 1650,1965 1965,2235
getting there,| Shell sort is
|Shell 排序完成了，

497
00:13:37,240 --> 00:13:39,210
0,320 460,765 765,990 990,1310 1570,1970
done| and all these five
|右边的这五个算法都完成了，

498
00:13:39,290 --> 00:13:40,315
0,470 470,620 620,755 755,875 875,1025
algorithms here on the right

499
00:13:40,315 --> 00:13:41,545
0,180 180,455 595,855 855,1005 1005,1230
are done,| and these most
|而这些最简单的算法，

500
00:13:41,545 --> 00:13:44,365
0,515 535,1035 1035,2165 2185,2565 2565,2820
simpler algorithms,| insertion, selection and
|插入排序、选择排序和冒泡排序仍在运行。

501
00:13:44,365 --> 00:13:45,415
0,285 285,450 450,630 630,810 810,1050
bubble sort are still working

502
00:13:45,415 --> 00:13:46,240
0,255 255,545
on. {}|
|

503
00:13:46,590 --> 00:13:48,080
0,400 570,920 920,1070 1070,1235 1235,1490
Now, let's change the scenario
现在，让我们稍微改变一下场景，

504
00:13:48,080 --> 00:13:48,995
0,225 225,360 360,555 555,735 735,915
a little bit,| we let
|我们让顶部的那些完成。

505
00:13:48,995 --> 00:13:50,420
0,300 300,570 570,845 955,1245 1245,1425
that complete on the top

506
00:13:50,420 --> 00:13:52,325
0,195 195,500 580,945 945,1220 1660,1905
over there.| Let's go to
|让我们转到数据几乎被排序的场景，

507
00:13:52,325 --> 00:13:53,285
0,120 120,390 390,645 645,780 780,960
the scenario where the data

508
00:13:53,285 --> 00:13:55,250
0,240 240,575 655,1265 1435,1695 1695,1965
is nearly sorted| and let's
|现在让我们运行，

509
00:13:55,250 --> 00:13:56,285
0,225 225,435 435,615 615,840 840,1035
now go and play through

510
00:13:56,285 --> 00:13:57,520
0,270 270,540 540,720 720,930 930,1235
that| and watch how quickly
|来看看更简单的算法完成的速度有多快。

511
00:13:57,840 --> 00:13:59,830
0,320 320,880 900,1400 1400,1655 1655,1990
the simpler algorithms finish up.|
|

512
00:14:00,260 --> 00:14:01,475
0,380 430,705 705,840 840,1005 1005,1215
And as you can see,|
正如你所看到的，|

513
00:14:01,475 --> 00:14:02,735
0,150 150,375 375,720 720,1110 1110,1260
the more complex algorithms on
右边更复杂的算法，

514
00:14:02,735 --> 00:14:03,830
0,120 120,365 385,735 735,870 870,1095
the right,| they're still working
|他们仍在运行，

515
00:14:03,830 --> 00:14:04,670
0,210 210,345 345,495 495,645 645,840
on it,| but the first
|但第一列的插入排序已经完成了。

516
00:14:04,670 --> 00:14:06,370
0,225 225,780 780,1155 1155,1380 1380,1700
column insertion {sort,is} already done.|
|

517
00:14:06,950 --> 00:14:08,710
0,230 230,410 410,635 635,1300 1470,1760
So hopefully that illustrates how
希望这说明了这些排序算法是如何工作的，

518
00:14:08,710 --> 00:14:10,710
0,195 195,600 600,1035 1035,1340 1600,2000
these sorting algorithms work| and
|为什么，

519
00:14:10,760 --> 00:14:12,900
0,400 690,965 965,1240 1500,1820 1820,2140
why there is,| this constant
|即使在数据库系统中也有这种持续的兴趣，

520
00:14:12,950 --> 00:14:14,155
0,260 260,410 410,575 575,850 870,1205
interest even in database systems

521
00:14:14,155 --> 00:14:15,025
0,225 225,390 390,555 555,705 705,870
is| to find the right
|找到合适的在内存中的排序算法，

522
00:14:15,025 --> 00:14:16,930
0,180 180,405 405,755 835,1415 1615,1905
in memory sort algorithms| and
|人们在不断地重新评估这个。

523
00:14:16,930 --> 00:14:18,505
0,165 165,315 315,590 730,1035 1035,1575
people are constantly {re-evaluating -}

524
00:14:18,505 --> 00:14:19,380
0,365
that.|
|

525
00:14:19,530 --> 00:14:21,230
0,455 455,635 635,880 1020,1415 1415,1700
I'm also very briefly going
我也会非常简短地进入另一个网站，

526
00:14:21,230 --> 00:14:22,895
0,165 165,440 550,900 900,1250 1270,1665
to go into this other

527
00:14:22,995 --> 00:14:24,360
0,375 375,630 630,905 925,1200 1200,1365
site,| which is the link
|这个网站的链接是，

528
00:14:24,460 --> 00:14:26,400
0,290 610,990 990,1370
is,| in the
|在幻灯片中，

529
00:14:26,620 --> 00:14:28,730
0,305 305,610 960,1360 1440,1835 1835,2110
slide [deck]| and let's go
|让我们转到那个网站，

530
00:14:28,870 --> 00:14:30,795
0,275 275,545 545,940 1050,1450 1650,1925
to that site| and also
|看看另一种看待排序的方式。

531
00:14:30,795 --> 00:14:32,490
0,150 150,300 300,555 555,935 1405,1695
take a look at a

532
00:14:32,490 --> 00:14:33,555
0,255 255,480 480,630 630,840 840,1065
different way of looking at

533
00:14:33,555 --> 00:14:34,640
0,515
sorting.|
|

534
00:14:35,670 --> 00:14:37,640
0,400 420,890 890,1210 1500,1790 1790,1970
So let's see,| I might
让我们看看，|我可以直接把它输入进去，

535
00:14:37,640 --> 00:14:39,460
0,195 195,405 405,630 630,950
just type that in,|
|

536
00:14:46,770 --> 00:14:48,470
0,275 275,410 410,670 1110,1475 1475,1700
there we go, okay,| and
我们好了，好的，|我要把这个切换到探索模式，

537
00:14:48,470 --> 00:14:49,340
0,150 150,225 225,390 390,630 630,870
I'm going to switch this

538
00:14:49,340 --> 00:14:52,940
0,320 910,1310 1810,2415 2415,2810 3340,3600
over to exploration mode| and
|这真的是一种看待算法的[可爱]方式，

539
00:14:52,940 --> 00:14:54,890
0,120 120,270 270,560 580,980 1630,1950
this is really a cute

540
00:14:54,890 --> 00:14:56,380
0,240 240,465 465,660 660,930 930,1490
way of looking at algorithms,|
|

541
00:14:57,100 --> 00:14:59,430
0,320 760,1160 1450,1845 1845,2025 2025,2330
where effectively it's like a
它实际上就像一个调试器，

542
00:14:59,990 --> 00:15:01,135
0,575 575,725 725,890 890,995 995,1145
debugger| and as you can
|正如你所看到的，我们将从快速排序开始，

543
00:15:01,135 --> 00:15:02,680
0,305 325,690 690,930 930,1260 1260,1545
see we'll start with quick

544
00:15:02,680 --> 00:15:05,815
0,320 700,1100 1780,2115 2115,2450 2860,3135
sort,| which has this, you
|它有这个，你选择一个轴心，

545
00:15:05,815 --> 00:15:06,685
0,150 150,285 285,540 540,690 690,870
pick a pivot| and then
|然后在两边进行排序，

546
00:15:06,685 --> 00:15:07,855
0,180 180,330 330,525 525,845 865,1170
sort on both sides,| it's
|这是一种分而治之的算法，

547
00:15:07,855 --> 00:15:09,330
0,135 135,330 330,495 495,945 945,1475
a divide and conquer algorithm|
|

548
00:15:09,560 --> 00:15:10,540
0,275 275,530 530,650 650,770 770,980
and let's go ahead and
让我们继续，对其进行排序。

549
00:15:10,540 --> 00:15:11,800
0,285 285,620 790,1035 1035,1125 1125,1260
sort that.| And the nice
|这样做的好处是，

550
00:15:11,800 --> 00:15:12,580
0,195 195,390 390,540 540,660 660,780
thing about this is,| you
|你可以看到用于快速排序的代码是什么样子的，

551
00:15:12,580 --> 00:15:13,555
0,180 180,390 390,555 555,735 735,975
can see what that code

552
00:15:13,555 --> 00:15:14,995
0,255 255,525 525,855 855,1170 1170,1440
for quick step, for quick

553
00:15:14,995 --> 00:15:16,930
0,285 285,555 555,875 1105,1505 1525,1935
sort looks like| and it's
|它遍历元素，

554
00:15:16,930 --> 00:15:18,100
0,285 285,510 510,630 630,890 940,1170
walking through the elements| and
|它是一种非常好的方式，

555
00:15:18,100 --> 00:15:19,290
0,150 150,255 255,480 480,810 810,1190
it's a very nice way|
|

556
00:15:19,340 --> 00:15:21,430
0,335 335,670 840,1235 1235,1810 1830,2090
to connect the algorithm in
以代码为中心的方式将算法与可视化发生的事情联系起来。

557
00:15:21,430 --> 00:15:22,990
0,165 165,405 405,825 825,1130 1270,1560
that code centric way with

558
00:15:22,990 --> 00:15:24,835
0,300 300,555 555,1190 1450,1680 1680,1845
what's happening visually.| So I
|所以我鼓励你们玩玩这个，

559
00:15:24,835 --> 00:15:25,810
0,225 225,375 375,540 540,750 750,975
encourage you to play around

560
00:15:25,810 --> 00:15:26,980
0,210 210,500 550,810 810,945 945,1170
with this,| if you have
|如果你忘记内存中的排序算法，

561
00:15:26,980 --> 00:15:28,980
0,350 490,765 765,1005 1005,1370 1450,2000
forgotten {in-memory -} sort algorithms,|
|

562
00:15:29,060 --> 00:15:30,115
0,260 260,365 365,500 500,725 725,1055
you should at least know
你至少应该知道一些基本的算法，比如快速排序和插入排序，

563
00:15:30,115 --> 00:15:31,915
0,270 270,545 745,1290 1290,1545 1545,1800
the basic algorithms like quick

564
00:15:31,915 --> 00:15:33,700
0,270 270,465 465,1050 1050,1355 1525,1785
sort and insertion sort| and
|然后去刷新一下，

565
00:15:33,700 --> 00:15:35,190
0,150 150,405 405,675 675,1140 1140,1490
just go and refresh that,|
|

566
00:15:35,600 --> 00:15:36,845
0,260 340,690 690,930 930,1155 1155,1245
{} you're probably going to
你可能会需要它，

567
00:15:36,845 --> 00:15:37,880
0,120 120,395 475,750 750,915 915,1035
need it,| if you're going
|如果你要去面试，

568
00:15:37,880 --> 00:15:39,700
0,290 370,770 820,1260 1260,1470 1470,1820
to interview,| it's a fundamental
|这是一个被多次问及的基本问题。

569
00:15:39,810 --> 00:15:42,140
0,350 350,605 605,890 890,1270 1980,2330
question that gets asked many

570
00:15:42,140 --> 00:15:43,220
0,350
times.|
|

571
00:15:43,910 --> 00:15:45,265
0,290 290,580 630,995 995,1115 1115,1355
All right, let's get back
好的，让我们回到幻灯片上，

572
00:15:45,265 --> 00:15:46,150
0,195 195,330 330,585 585,750 750,885
to a slide,| so I'm
|所以我要关闭这个，

573
00:15:46,150 --> 00:15:46,885
0,60 60,180 180,375 375,570 570,735
going to close this| and
|让你们自己玩这个网站上的算法。

574
00:15:46,885 --> 00:15:48,445
0,150 150,315 315,605 805,1200 1200,1560
let you play with the

575
00:15:48,445 --> 00:15:49,750
0,405 405,570 570,720 720,975 975,1305
algorithms on this site by

576
00:15:49,750 --> 00:15:50,760
0,350
yourself.|
|

577
00:15:52,040 --> 00:15:53,590
0,260 260,470 470,820 1140,1430 1430,1550
So moving along,| we're going
所以接下来，|我们将从排序操作开始，

578
00:15:53,590 --> 00:15:55,510
0,180 180,470 940,1340 1420,1695 1695,1920
to start into the sort

579
00:15:55,510 --> 00:15:57,000
0,350 370,660 660,810 810,1070 1090,1490
operation,| start with something simple
|从称为 top-N 堆排序的简单方法开始。

580
00:15:57,050 --> 00:15:58,900
0,320 320,560 560,800 800,1120 1470,1850
called the {top-N -}, {top-N

581
00:15:58,900 --> 00:16:00,805
0,330 330,660 660,950 1390,1680 1680,1905
-} heap sort.| And that
|它出现在，当你有一个 ORDER BY 时，

582
00:16:00,805 --> 00:16:02,110
0,225 225,515 535,840 840,1050 1050,1305
shows up when you have

583
00:16:02,110 --> 00:16:03,400
0,240 240,495 495,860 880,1155 1155,1290
an ORDER BY,| as we
|正如我们刚才所讨论的，

584
00:16:03,400 --> 00:16:05,455
0,240 240,620 970,1550 1690,1950 1950,2055
just discussed,| SQL has an
|SQL 有一个 ORDER BY 子句，

585
00:16:05,455 --> 00:16:06,880
0,180 180,420 420,755 925,1215 1215,1425
ORDER BY clause| and when
|当它出现在 SQL 查询中时，

586
00:16:06,880 --> 00:16:08,005
0,315 315,525 525,705 705,825 825,1125
that's present in the SQL

587
00:16:08,005 --> 00:16:08,785
0,195 195,315 315,405 405,540 540,780
query,| you have to present
|你必须显示按 ORDER BY 中的列排序的结果，

588
00:16:08,785 --> 00:16:10,765
0,285 285,540 540,1085 1225,1625 1705,1980
the results sorted by the

589
00:16:10,765 --> 00:16:11,880
0,270 270,405 405,540 540,765 765,1115
columns in that ORDER BY

590
00:16:11,900 --> 00:16:13,960
0,400 750,980 980,1085 1085,1360 1740,2060
here,| you have to output
|你必须按 sid 排序输出 enrolled 表中的记录，

591
00:16:13,960 --> 00:16:14,920
0,320
the

592
00:16:14,920 --> 00:16:16,260
0,315 315,585 585,690 690,1065 1065,1340
records from the enrolled table

593
00:16:16,400 --> 00:16:17,670
0,350 350,575 575,740 740,950 950,1270
ordered by the {sid -},|
|

594
00:16:18,290 --> 00:16:20,070
0,290 290,395 395,620 620,970 1380,1780
there's a few additional components
SQL 还允许你执行其他一些组件，

595
00:16:20,120 --> 00:16:21,280
0,290 290,635 635,860 860,1040 1040,1160
that SQL allows you to

596
00:16:21,280 --> 00:16:23,455
0,180 180,375 375,650 1240,1640 1870,2175
do,| so here we are
|在这里，我们要求系统只发送按 sid 排序的前 4 行，

597
00:16:23,455 --> 00:16:25,885
0,305 955,1215 1215,1455 1455,1835 2155,2430
asking the system to send

598
00:16:25,885 --> 00:16:27,385
0,180 180,450 450,735 735,1055 1165,1500
us only the first 4

599
00:16:27,385 --> 00:16:29,755
0,545 715,1125 1125,1385 1795,2115 2115,2370
rows sorted by {sid -}

600
00:16:29,755 --> 00:16:31,060
0,210 210,485 745,990 990,1110 1110,1305
of course,| so the first
|排序后的前 4 个，

601
00:16:31,060 --> 00:16:32,010
0,165 165,255 255,405 405,705 705,950
4 in that sorted order|
|

602
00:16:32,450 --> 00:16:34,120
0,305 305,470 470,650 650,970 1080,1670
and this is extra optional
这个额外的可选子句，说的是 WITH TIES ，

603
00:16:34,120 --> 00:16:35,760
0,270 270,540 540,860 940,1305 1305,1640
clause, that says WITH TIES,|
|

604
00:16:35,990 --> 00:16:37,090
0,275 275,425 425,650 650,935 935,1100
so there any ties in
所以在前 4 个中有任何并列，

605
00:16:37,090 --> 00:16:38,460
0,135 135,345 345,680
the top 4,|
|

606
00:16:39,260 --> 00:16:40,350
0,290 290,455 455,635 635,800 800,1090
give me all the ties,|
把所有的并列给我，|

607
00:16:40,910 --> 00:16:42,265
0,245 245,365 365,560 560,880 1050,1355
so in this case,| if
所以，在本例中，|如果该表有 4 条以上的记录，

608
00:16:42,265 --> 00:16:44,050
0,240 240,575 775,1175 1225,1545 1545,1785
this table has more than

609
00:16:44,050 --> 00:16:46,360
0,320 1000,1400
4 records,|
|

610
00:16:46,500 --> 00:16:47,645
0,395 395,650 650,800 800,980 980,1145
the output of this will
它的输出将至少是 4 个，但可能更多，

611
00:16:47,645 --> 00:16:49,070
0,275 325,630 630,915 915,1200 1200,1425
be at least four, but

612
00:16:49,070 --> 00:16:50,750
0,225 225,405 405,680 1120,1455 1455,1680
could be more,| so, if
|所以，如果前四个 sid 中的有一个重复，

613
00:16:50,750 --> 00:16:52,480
0,165 165,315 315,590 730,1130 1330,1730
one of those top 4

614
00:16:53,220 --> 00:16:55,040
0,290 290,755 755,995 995,1360 1500,1820
{sids -} is repeated,| that
|那个重复的值将会显示给我们。

615
00:16:55,040 --> 00:16:56,090
0,255 255,525 525,720 720,870 870,1050
repeated value will be shown

616
00:16:56,090 --> 00:16:57,590
0,210 210,375 375,620 1090,1365 1365,1500
back to us.| Okay, so
|好的，所以让我们看看这是如何工作的，

617
00:16:57,590 --> 00:16:58,690
0,225 225,390 390,600 600,795 795,1100
let's see how that works,|
|

618
00:16:59,040 --> 00:17:00,500
0,245 245,380 380,670
we will use
我们将使用堆排序的一个版本称为 top-N 堆排序。

619
00:17:00,500 --> 00:17:02,180
0,290 490,840 840,1110 1110,1410 1410,1680
a version of heap sort

620
00:17:02,180 --> 00:17:03,440
0,270 270,435 435,660 660,945 945,1260
called the {top-N -} heap

621
00:17:03,440 --> 00:17:04,280
0,290
sort.|
|

622
00:17:04,290 --> 00:17:06,160
0,400 1080,1430 1430,1505 1505,1610 1610,1870
And here's how it works,|
这就是它的工作原理，|

623
00:17:06,720 --> 00:17:08,330
0,400 810,1040 1040,1130 1130,1325 1325,1610
here we are going to
这里我们要去看看记录，

624
00:17:08,330 --> 00:17:09,950
0,350 520,870 870,1095 1095,1365 1365,1620
go and look at the

625
00:17:09,950 --> 00:17:11,060
0,225 225,495 495,690 690,885 885,1110
records,| so assume the {sids
|所以假设 sid 这些值，

626
00:17:11,060 --> 00:17:13,325
0,680 1210,1515 1515,1820 1870,2190 2190,2265
-} these values,| we're going
|我们从获取第一个 sid 开始，也就是 3 ，

627
00:17:13,325 --> 00:17:14,795
0,135 135,425 535,825 825,1260 1260,1470
to start by fetching the

628
00:17:14,795 --> 00:17:15,920
0,210 210,450 450,705 705,930 930,1125
first {sid -}, which is

629
00:17:15,920 --> 00:17:17,195
0,320 640,885 885,1020 1020,1125 1125,1275
3,| and we're going to
|我们将在内存中构建一个堆，

630
00:17:17,195 --> 00:17:19,150
0,255 255,570 570,905 1225,1515 1515,1955
build {in-memory -} a heap,|
|

631
00:17:19,620 --> 00:17:21,080
0,90 90,300 300,480 480,780 780,1460
and we'll start by allocating
我们从分配一个大小为 4 的堆开始，

632
00:17:21,550 --> 00:17:22,695
0,290 290,515 515,665 665,905 905,1145
a heap of size 4,|
|

633
00:17:22,695 --> 00:17:24,120
0,285 285,665 865,1140 1140,1320 1320,1425
and obviously a heap is
显然堆是一种排序的数据结构，

634
00:17:24,120 --> 00:17:25,515
0,135 135,435 435,675 675,1040 1060,1395
a sorted data structure,| its
|它的核心实现是数组，

635
00:17:25,515 --> 00:17:26,880
0,300 300,665 775,1050 1050,1215 1215,1365
core implementation is that of

636
00:17:26,880 --> 00:17:28,050
0,225 225,590 700,960 960,1050 1050,1170
an array,| and so I'm
|我将只展示这个数组表现形式，

637
00:17:28,050 --> 00:17:29,030
0,105 105,255 255,435 435,660 660,980
just going to show that

638
00:17:29,140 --> 00:17:31,170
0,820 1170,1475 1475,1535 1535,1730 1730,2030
{array,representation},| I'm going to assume
|我将假设你知道堆是如何工作的，

639
00:17:31,170 --> 00:17:32,055
0,225 225,375 375,510 510,645 645,885
you know how a heap

640
00:17:32,055 --> 00:17:33,315
0,275 415,660 660,750 750,990 990,1260
works,| and if you've forgotten,
|如果你忘了，你可以很快去查一查。

641
00:17:33,315 --> 00:17:34,230
0,210 210,315 315,465 465,690 690,915
then you can quickly go

642
00:17:34,230 --> 00:17:35,300
0,165 165,315 315,590
look that up.|
|

643
00:17:35,520 --> 00:17:36,605
0,400 450,770 770,875 875,980 980,1085
So I'm just going to
所以，我将在插入元素时按排序顺序显示该数组，

644
00:17:36,605 --> 00:17:37,685
0,150 150,360 360,690 690,945 945,1080
show that array in a

645
00:17:37,685 --> 00:17:38,765
0,285 285,465 465,660 660,780 780,1080
sorted order as we insert

646
00:17:38,765 --> 00:17:40,340
0,275 355,750 750,1125 1125,1470 1470,1575
elements,| because ultimately that's what
|因为最终这就是堆所做的事情。

647
00:17:40,340 --> 00:17:41,690
0,105 105,315 315,590 1000,1215 1215,1350
a heap does.| So we'll
|所以我们将获取 3 ，将其插入堆中，

648
00:17:41,690 --> 00:17:43,535
0,240 240,620 970,1470 1470,1650 1650,1845
fetch 3, insert that into

649
00:17:43,535 --> 00:17:45,005
0,165 165,515 835,1095 1095,1275 1275,1470
the heap,| then we'll fetch
|然后我们将获取 4 ，以排序的顺序将其插入堆中，

650
00:17:45,005 --> 00:17:46,610
0,335 565,1080 1080,1275 1275,1455 1455,1605
4, insert that into the

651
00:17:46,610 --> 00:17:48,035
0,165 165,315 315,615 615,860 1150,1425
heap in sorted order,| this
|我要展示的这个堆从右到左排序，

652
00:17:48,035 --> 00:17:49,330
0,180 180,360 360,495 495,785 895,1295
heap I'm going to show

653
00:17:49,410 --> 00:17:51,635
0,500 500,820 1470,1790 1790,1970 1970,2225
sorted from right to left,|
|

654
00:17:51,635 --> 00:17:53,105
0,300 300,480 480,750 750,1145 1165,1470
so 3 is smaller than
所以 3 比 4 小，

655
00:17:53,105 --> 00:17:54,245
0,305 385,660 660,780 780,870 870,1140
4| and so the heap
|所以堆在这个方向上增长，

656
00:17:54,245 --> 00:17:56,140
0,305 475,750 750,975 975,1325
growing in this direction,|
|

657
00:17:56,530 --> 00:17:58,305
0,400 540,815 815,980 980,1270 1410,1775
then go to 6, that's
然后转到 6 ，把它添加到堆中，

658
00:17:58,305 --> 00:17:59,400
0,195 195,390 390,480 480,780 780,1095
added to the heap,| so
|所以 3 4 6 ，

659
00:17:59,400 --> 00:18:01,170
0,285 285,540 540,890 1150,1470 1470,1770
3 4 6,| now add
|现在加上 2 ，

660
00:18:01,170 --> 00:18:02,940
0,380 670,975 975,1280 1330,1605 1605,1770
2| and we have a
|我们就得到了一个满的堆，

661
00:18:02,940 --> 00:18:04,460
0,255 255,405 405,585 585,890
heap that is full,|
|

662
00:18:04,630 --> 00:18:05,910
0,400 450,770 770,920 920,1070 1070,1280
now we come to this
现在我们到达这个值 9 ，

663
00:18:05,910 --> 00:18:07,740
0,350 730,1130 1360,1635 1635,1740 1740,1830
value 9| and we have
|我们必须决定我们想要用它做什么，

664
00:18:07,740 --> 00:18:08,850
0,195 195,525 525,795 795,945 945,1110
to decide what we want

665
00:18:08,850 --> 00:18:10,110
0,150 150,300 300,465 465,740 1000,1260
to do with it,| so
|所以昨天在课堂上，

666
00:18:10,110 --> 00:18:11,685
0,210 210,450 450,675 675,1010 1240,1575
yesterday in class,| I pause
|我暂停了讲课，提问，

667
00:18:11,685 --> 00:18:12,795
0,195 195,420 420,645 645,855 855,1110
the lecture and asked| like
|你会怎么处理 9 ，

668
00:18:12,795 --> 00:18:13,530
0,195 195,345 345,465 465,585 585,735
what would you do with

669
00:18:13,530 --> 00:18:14,220
0,240 240,420 420,480 480,555 555,690
9,| there were a bunch
|有一大堆答案给出，

670
00:18:14,220 --> 00:18:15,180
0,150 150,405 405,660 660,795 795,960
of answers that were given

671
00:18:15,180 --> 00:18:16,725
0,290 850,1125 1125,1275 1275,1410 1410,1545
out| in terms of what
|关于你能做什么，

672
00:18:16,725 --> 00:18:17,580
0,135 135,270 270,480 480,690 690,855
you could do,| the simple
|简单的答案是将 9 加到堆中，并增加堆，

673
00:18:17,580 --> 00:18:19,575
0,255 255,540 540,860 1390,1770 1770,1995
answer was add 9 to

674
00:18:19,575 --> 00:18:20,505
0,105 105,360 360,570 570,780 780,930
the heap and grow the

675
00:18:20,505 --> 00:18:22,620
0,345 345,615 615,905 1225,1625 1855,2115
heap,| which is correct,| but
|这是正确的，|但是有一个更好的方法来做，

676
00:18:22,620 --> 00:18:23,370
0,150 150,240 240,405 405,600 600,750
there's a better way to

677
00:18:23,370 --> 00:18:24,890
0,150 150,440 670,960 960,1245 1245,1520
do it,| when you're doing
|当你在做前 4 名的评估时，

678
00:18:25,420 --> 00:18:28,760
0,400 1020,1415 1415,1810 2130,2830
this top 4 evaluation,|
|

679
00:18:29,660 --> 00:18:30,595
0,275 275,470 470,665 665,800 800,935
and the inside is the
内部如下，

680
00:18:30,595 --> 00:18:32,935
0,275 655,1125 1125,1440 1440,1805 2035,2340
following,| I've already seen,| that
|我已经看到，|数据中已经扫描的有 4 个数字，

681
00:18:32,935 --> 00:18:34,645
0,180 180,455 655,975 975,1295 1435,1710
there are 4 numbers in

682
00:18:34,645 --> 00:18:35,785
0,150 150,360 360,615 615,945 945,1140
the data have scanned so

683
00:18:35,785 --> 00:18:38,650
0,305 775,1155 1155,1530 1530,1925 2515,2865
far,| that are all less
|它们都比 9 小，

684
00:18:38,650 --> 00:18:39,860
0,270 270,590
than 9,|
|

685
00:18:39,860 --> 00:18:40,895
0,150 150,330 330,630 630,885 885,1035
if I only have to
如果我只需要检索前 4 行，

686
00:18:40,895 --> 00:18:43,030
0,665 865,1140 1140,1365 1365,1620 1620,2135
retrieve the first 4 rows,|
|

687
00:18:43,470 --> 00:18:45,430
0,305 305,610 840,1235 1235,1670 1670,1960
the first 4 smallest values,|
前 4 个最小值，|

688
00:18:45,570 --> 00:18:47,180
0,260 260,470 470,680 680,1030 1320,1610
because it's ordered by the
因为它是按 sid 排序的，

689
00:18:47,180 --> 00:18:48,520
0,210 210,530
{sid -},|
|

690
00:18:49,070 --> 00:18:50,680
0,290 290,545 545,845 845,1180 1320,1610
there is no way I
我不可能输出 9 ，

691
00:18:50,680 --> 00:18:52,075
0,180 180,470 610,900 900,1170 1170,1395
would ever output 9,| because
|因为我已经有 4 个小于 9 的值，

692
00:18:52,075 --> 00:18:53,250
0,180 180,405 405,615 615,855 855,1175
I already have 4 values

693
00:18:53,840 --> 00:18:54,990
0,245 245,395 395,635 635,860 860,1150
that are smaller than 9,|
|

694
00:18:55,280 --> 00:18:56,605
0,275 275,550 660,950 950,1130 1130,1325
so 9 does not even
所以甚至不需要处理 9 ，

695
00:18:56,605 --> 00:18:58,195
0,195 195,330 330,465 465,1145 1315,1590
need to be processed,| because
|因为我有 4 个值，

696
00:18:58,195 --> 00:18:59,710
0,120 120,255 255,450 450,755 1225,1515
I have 4 values,| each
|每个值都小于 9 ，

697
00:18:59,710 --> 00:19:00,865
0,180 180,390 390,675 675,960 960,1155
of which are smaller than

698
00:19:00,865 --> 00:19:02,650
0,240 240,495 495,1085 1345,1620 1620,1785
9,| so anytime in my
|所以在我的堆中的任何时候我都有足够的值，

699
00:19:02,650 --> 00:19:04,230
0,410 460,855 855,1065 1065,1290 1290,1580
heap I've got enough values,|
|

700
00:19:05,080 --> 00:19:06,890
0,395 395,665 665,830 830,1120 1410,1810
4, in this case,| and
在本例中是 4 ，|我看到一个大于堆中最大值的值， 6 ，

701
00:19:07,510 --> 00:19:09,060
0,335 335,530 530,665 665,940 1290,1550
I see a value that

702
00:19:09,060 --> 00:19:10,280
0,165 165,435 435,690 690,900 900,1220
is greater than the largest

703
00:19:10,480 --> 00:19:11,850
0,335 335,530 530,650 650,1000 1050,1370
value in the heap, 6,|
|

704
00:19:11,850 --> 00:19:12,900
0,180 180,345 345,630 630,885 885,1050
in this case, I can
在这种情况下，我可以简单地把它扔掉。

705
00:19:12,900 --> 00:19:14,260
0,255 255,585 585,860
simply toss it.|
|

706
00:19:14,270 --> 00:19:15,100
0,260 260,380 380,500 500,650 650,830
So now you can start
现在你可以开始看到，

707
00:19:15,100 --> 00:19:16,560
0,180 180,470 700,1005 1005,1185 1185,1460
to see,| how when you
|当你在内存中实现内存中排序时，

708
00:19:16,700 --> 00:19:18,205
0,350 350,635 635,965 965,1235 1235,1505
implement things like {in-memory -}

709
00:19:18,205 --> 00:19:20,280
0,635 805,1125 1125,1305 1305,1565 1675,2075
sorting,| in the database context,
|在数据库上下文中，你拥有这些语义，

710
00:19:20,480 --> 00:19:21,900
0,260 260,380 380,545 545,755 755,1420
where you have these semantics,|
|

711
00:19:22,160 --> 00:19:23,770
0,275 275,470 470,710 710,1030 1320,1610
you can do very interesting
你可以做非常有趣的事情，

712
00:19:23,770 --> 00:19:24,990
0,180 180,315 315,465 465,945 945,1220
things,| you can modify those
|你可以修改这些算法以使其更高效，

713
00:19:25,070 --> 00:19:26,755
0,640 720,1010 1010,1220 1220,1430 1430,1685
algorithms to make it more

714
00:19:26,755 --> 00:19:28,270
0,365 685,945 945,1185 1185,1350 1350,1515
efficient,| and we'll see that,|
|我们将看到，|

715
00:19:28,270 --> 00:19:29,965
0,240 240,555 555,975 975,1280 1390,1695
with external merge sort is,|
在外部合并排序中，|

716
00:19:29,965 --> 00:19:31,510
0,305 535,990 990,1185 1185,1365 1365,1545
the algorithms that you know
你喜欢的排序、哈希和其他类型的东西的算法，

717
00:19:31,510 --> 00:19:33,115
0,165 165,330 330,620 790,1095 1095,1605
and you love for sorting,

718
00:19:33,115 --> 00:19:34,530
0,525 525,765 765,960 960,1125 1125,1415
hashing, other kinds of things,|
|

719
00:19:34,640 --> 00:19:35,515
0,245 245,395 395,590 590,740 740,875
when you start to make
当你开始在数据库中这样做时，

720
00:19:35,515 --> 00:19:37,030
0,120 120,240 240,965 1045,1335 1335,1515
that in databases,| in in
|在内存中的情况下，

721
00:19:37,030 --> 00:19:38,215
0,270 270,570 570,795 795,1005 1005,1185
memory case,| like this with
|像这个 top-N 语义或外部内存，

722
00:19:38,215 --> 00:19:39,910
0,165 165,345 345,965 1045,1395 1395,1695
{top-N -} semantics or external

723
00:19:39,910 --> 00:19:41,410
0,350 580,855 855,990 990,1185 1185,1500
memory,| you make these subtle
|你进行了这些微妙的修改，

724
00:19:41,410 --> 00:19:42,880
0,290 610,870 870,1005 1005,1185 1185,1470
changes| and make that magic
|并使其发挥神奇的作用，

725
00:19:42,880 --> 00:19:44,815
0,300 300,450 450,540 540,800 1630,1935
work,| so you can do
|所以，你可以以更高效的方式进行操作，

726
00:19:44,815 --> 00:19:46,090
0,305 385,630 630,735 735,945 945,1275
things in a more efficient

727
00:19:46,090 --> 00:19:48,055
0,380 550,950 1090,1380 1380,1620 1620,1965
way| and do these operations
|在更大的数据集上做这些操作，

728
00:19:48,055 --> 00:19:50,110
0,270 270,545 625,960 960,1595 1705,2055
on much larger datasets,| much
|比你拥有的内存量大得多。

729
00:19:50,110 --> 00:19:51,100
0,285 285,495 495,645 645,810 810,990
larger than the amount of

730
00:19:51,100 --> 00:19:52,400
0,255 255,510 510,660 660,920
memory that you have.|
|

731
00:19:53,100 --> 00:19:53,915
0,245 245,320 320,410 410,560 560,815
So let me just pause,|
所以让我暂停一下，|

732
00:19:53,915 --> 00:19:54,910
0,240 240,375 375,525 525,705 705,995
let you take that in,|
让你们理解一下，|

733
00:19:55,080 --> 00:19:56,600
0,290 290,425 425,650 650,1030 1230,1520
make sure you understand why
确保你们理解为什么我们可以跳过 9 ，

734
00:19:56,600 --> 00:19:58,520
0,150 150,330 330,555 555,830 1660,1920
we can skip 9,| it
|它大于 6 ，

735
00:19:58,520 --> 00:19:59,960
0,165 165,435 435,735 735,1070 1150,1440
is greater than 6| and
|我们保证我们在最终答案中不需要它。

736
00:19:59,960 --> 00:20:01,250
0,225 225,480 480,1080 1080,1200 1200,1290
we are guaranteed we are

737
00:20:01,250 --> 00:20:02,255
0,180 180,390 390,555 555,720 720,1005
not going to need it

738
00:20:02,255 --> 00:20:03,920
0,270 270,405 405,600 600,935
in the final answer.|
|

739
00:20:04,530 --> 00:20:05,530
0,275 275,425 425,590 590,740 740,1000
Then we come to 1,
然后我们到达 1 ，这很有意思，

740
00:20:06,000 --> 00:20:08,075
0,290 290,580 1110,1510 1620,1895 1895,2075
which is interesting,| we have
|我们必须把它放入堆中，

741
00:20:08,075 --> 00:20:08,810
0,165 165,300 300,465 465,615 615,735
to put that in the

742
00:20:08,810 --> 00:20:10,415
0,380 520,920 1060,1335 1335,1455 1455,1605
heap,| but as you might
|但正如你可能注意到的，

743
00:20:10,415 --> 00:20:12,920
0,305 505,795 795,1085 1285,1685 2185,2505
notice,| there was previously 2,
|前面有 2 3 4 6 ，

744
00:20:12,920 --> 00:20:14,405
0,225 225,480 480,830 1060,1335 1335,1485
3, 4, 6,| as I
|随着我放入 1 ，

745
00:20:14,405 --> 00:20:15,635
0,180 180,465 465,765 765,975 975,1230
put 1,| I no longer
|我不再需要保留 6 ，

746
00:20:15,635 --> 00:20:17,080
0,255 255,435 435,720 720,1080 1080,1445
need to keep 6 around|
|

747
00:20:17,190 --> 00:20:18,125
0,260 260,380 380,545 545,785 785,935
and I can toss that
我可以扔掉它，

748
00:20:18,125 --> 00:20:19,610
0,275 325,615 615,810 810,1035 1035,1485
out,| again, that same reasoning,|
|再次，同样的原因，|

749
00:20:19,610 --> 00:20:20,650
0,120 120,285 285,465 465,720 720,1040
that I've got 4 numbers,|
我有 4 个数字，|

750
00:20:22,060 --> 00:20:23,430
0,335 335,545 545,740 740,1100 1100,1370
that are the smallest I've
这是我到目前为止见过的最小的，

751
00:20:23,430 --> 00:20:24,615
0,165 165,375 375,675 675,960 960,1185
seen so far,| I only
|我只需要输出 4 个，

752
00:20:24,615 --> 00:20:26,145
0,225 225,435 435,660 660,965 1225,1530
need to output 4,| I
|我现在可以扔掉 6 ，

753
00:20:26,145 --> 00:20:27,255
0,180 180,375 375,675 675,900 900,1110
can now toss away 6,|
|

754
00:20:27,255 --> 00:20:28,755
0,180 180,390 390,935 1015,1320 1320,1500
which had scanned a few
以前扫描过的记录。

755
00:20:28,755 --> 00:20:29,960
0,275 295,695
records ago.|
|

756
00:20:29,970 --> 00:20:31,070
0,320 320,530 530,755 755,935 935,1100
Okay, so again we are
好的，我们再次对算法进行了优化。

757
00:20:31,070 --> 00:20:33,020
0,320 580,945 945,1490 1510,1755 1755,1950
making these optimizations to the

758
00:20:33,020 --> 00:20:34,140
0,560
algorithm.|
|

759
00:20:34,390 --> 00:20:35,780
0,400 510,800 800,950 950,1100 1100,1390
Now, because we have these
现在，因为我们有这些 WITH TIES ，

760
00:20:35,800 --> 00:20:36,900
0,365 365,680 680,935 935,995 995,1100
WITH TIES,| we're going to
|我们将到达这个 4 ，

761
00:20:36,900 --> 00:20:38,205
0,260 370,705 705,885 885,1020 1020,1305
come, come to this number

762
00:20:38,205 --> 00:20:39,660
0,395 865,1125 1125,1215 1215,1290 1290,1455
4| and we have to
|我们必须决定我们要做什么，

763
00:20:39,660 --> 00:20:40,560
0,225 225,405 405,540 540,690 690,900
decide what we do,| we
|我们不能扔掉它，

764
00:20:40,560 --> 00:20:41,955
0,330 330,465 465,600 600,890 1090,1395
can't throw it away,| because
|因为 4 是最小的数字之一，

765
00:20:41,955 --> 00:20:42,735
0,195 195,360 360,495 495,615 615,780
4 is one of the

766
00:20:42,735 --> 00:20:44,040
0,315 315,600 600,870 870,1035 1035,1305
smallest number| and we have
|我们有 WITH TIES ，

767
00:20:44,040 --> 00:20:45,150
0,345 345,570 570,750 750,885 885,1110
WITH TIES,| if we didn't
|如果我们没有 WITH TIES ，我们可以把它扔掉，

768
00:20:45,150 --> 00:20:45,945
0,120 120,300 300,510 510,675 675,795
have WITH TIES, we could

769
00:20:45,945 --> 00:20:47,235
0,210 210,375 375,665 895,1155 1155,1290
toss it away,| but in
|但在这种情况下，我们需要保留它，

770
00:20:47,235 --> 00:20:48,015
0,165 165,360 360,510 510,630 630,780
this case, we need to

771
00:20:48,015 --> 00:20:49,065
0,165 165,455 535,765 765,870 870,1050
keep it,| we have no
|我们别无选择，只能扩大堆，

772
00:20:49,065 --> 00:20:50,145
0,270 270,510 510,705 705,915 915,1080
choice, but to grow the

773
00:20:50,145 --> 00:20:51,330
0,395 595,840 840,930 930,1050 1050,1185
heap| and you can grow
|你可以通过多种方式扩大堆，

774
00:20:51,330 --> 00:20:52,365
0,120 120,285 285,405 405,675 675,1035
the heap in multiple ways,|
|

775
00:20:52,365 --> 00:20:53,835
0,285 285,465 465,815 895,1200 1200,1470
it's often an array data
它通常是用于写入堆数据结构的数组数据结构，

776
00:20:53,835 --> 00:20:55,095
0,315 315,525 525,675 675,915 915,1260
structure that is used to

777
00:20:55,095 --> 00:20:58,040
0,390 390,660 660,1025 1615,2015 2545,2945
write a heap data structure|
|

778
00:20:58,330 --> 00:20:59,460
0,305 305,610
and so
所以，我们通常会把这个数字翻一倍，

779
00:20:59,460 --> 00:21:00,750
0,210 210,360 360,650 700,1035 1035,1290
we would generally double that,|
|

780
00:21:00,750 --> 00:21:01,455
0,180 180,360 360,450 450,630 630,705
so that's what we're going
这就是我们要对这里做的，

781
00:21:01,455 --> 00:21:02,820
0,105 105,345 345,615 615,905 1045,1365
to do to here,| double
|将堆的大小增加一倍，

782
00:21:02,820 --> 00:21:03,830
0,195 195,360 360,510 510,630 630,1010
the size of the heap,|
|

783
00:21:03,910 --> 00:21:05,190
0,350 350,620 620,785 785,920 920,1280
add 4 to the sorted
在已排序的堆中添加 4 个，

784
00:21:05,190 --> 00:21:06,480
0,440 640,930 930,1065 1065,1155 1155,1290
heap,| go to the next
|转到下一个元素，也是 4 ，

785
00:21:06,480 --> 00:21:07,760
0,255 255,480 480,705 705,975 975,1280
element, which is also 4,|
|

786
00:21:08,560 --> 00:21:09,460
0,240 240,465 465,615 615,735 735,900
then we come to this
然后我们来到最后一个元素，也就是 8 ，

787
00:21:09,460 --> 00:21:10,620
0,240 240,525 525,750 750,885 885,1160
last element, which is 8,|
|

788
00:21:11,120 --> 00:21:13,080
0,400 570,860 860,1100 1100,1450 1560,1960
and as we discussed in
就像我们在课堂上讨论的那样，

789
00:21:13,100 --> 00:21:14,845
0,400 750,1085 1085,1295 1295,1520 1520,1745
class,| ask for questions as
|询问你们会对 8 做什么，

790
00:21:14,845 --> 00:21:15,535
0,120 120,270 270,420 420,540 540,690
to what you would do

791
00:21:15,535 --> 00:21:16,945
0,165 165,455 715,1005 1005,1200 1200,1410
with 8,| at that point,
|在这一点上，你们中的许多人自愿地，知道你们会跳过 8 ，

792
00:21:16,945 --> 00:21:18,475
0,195 195,360 360,510 510,1085 1135,1530
many of you volunteered and

793
00:21:18,475 --> 00:21:19,930
0,390 390,750 750,990 990,1200 1200,1455
knew that you would skip

794
00:21:19,930 --> 00:21:21,385
0,290 520,795 795,960 960,1185 1185,1455
8| and that totally makes
|这完全有意义，

795
00:21:21,385 --> 00:21:22,915
0,330 330,660 660,930 930,1200 1200,1530
sense,| because just like 9,|
|因为就像 9 ，|

796
00:21:22,915 --> 00:21:24,205
0,240 240,375 375,885 885,1050 1050,1290
we are guaranteed, we don't
我们有保证。我们不需要 8 ，

797
00:21:24,205 --> 00:21:25,555
0,165 165,485 745,1035 1035,1185 1185,1350
need 8,| 4 is the
|4 是目前堆中最小的数字，

798
00:21:25,555 --> 00:21:26,875
0,360 360,665 685,945 945,1095 1095,1320
smallest number in the heap

799
00:21:26,875 --> 00:21:28,530
0,195 195,515 715,1005 1005,1275 1275,1655
right now,| we have 4
|我们这里有 4 个不同的值，

800
00:21:28,550 --> 00:21:30,340
0,320 320,640 720,1120 1290,1565 1565,1790
distinct values here,| we can
|我们可以跳过，简单地输出排序后的堆。

801
00:21:30,340 --> 00:21:31,710
0,380 400,690 690,840 840,1035 1035,1370
skip and we can simply

802
00:21:32,030 --> 00:21:33,860
0,400 570,875 875,1220 1220,1600
output the sorted heap.|
|

803
00:21:34,400 --> 00:21:36,070
0,400 420,725 725,1205 1205,1445 1445,1670
So a modified version of
这是堆排序的修改版本，

804
00:21:36,070 --> 00:21:37,800
0,270 270,560 760,1095 1095,1380 1380,1730
heap sort,| far more efficient
|在内存中的效率要高得多，

805
00:21:38,150 --> 00:21:39,925
0,320 320,640 990,1340 1340,1595 1595,1775
{in-memory -},| but allows you
|但允许你获取 WITH TIES 的前 4 行，

806
00:21:39,925 --> 00:21:42,660
0,150 150,425 685,1085 1345,1745 2095,2735
to go, do the fetching

807
00:21:42,740 --> 00:21:44,070
0,290 290,440 440,620 620,860 860,1330
of the first 4 rows

808
00:21:44,420 --> 00:21:45,510
0,290 290,500 500,695 695,830 830,1090
WITH TIES| and the different
|这些 SQL 中的不同变体，

809
00:21:45,590 --> 00:21:47,185
0,620 620,845 845,1025 1025,1205 1205,1595
variants of this in SQL|
|

810
00:21:47,185 --> 00:21:48,460
0,165 165,390 390,725 925,1170 1170,1275
in terms of how you
取决于你可以指定要读取哪些行，

811
00:21:48,460 --> 00:21:49,900
0,165 165,645 645,885 885,1185 1185,1440
can specify which rows to

812
00:21:49,900 --> 00:21:51,790
0,380 520,920 1300,1605 1605,1770 1770,1890
fetch,| and this type of
|这种类型的结构在经过一些修改后适用于它，

813
00:21:51,790 --> 00:21:53,080
0,165 165,465 465,810 810,1050 1050,1290
a structure works for it

814
00:21:53,080 --> 00:21:54,655
0,240 240,405 405,950 1090,1350 1350,1575
with some modification,| but that's
|但这是总体想法。

815
00:21:54,655 --> 00:21:55,980
0,105 105,365 475,875
the overall idea.|
|

816
00:21:57,230 --> 00:21:58,780
0,275 275,550 1020,1310 1310,1490 1490,1550
All right, now we're going
好的，现在我们将进入今天课程中更有趣的部分，

817
00:21:58,780 --> 00:22:00,480
0,90 90,345 345,740 1120,1410 1410,1700
to get into the more

818
00:22:01,160 --> 00:22:02,455
0,290 290,470 470,650 650,1025 1025,1295
interesting part of today's lecture|
|

819
00:22:02,455 --> 00:22:04,225
0,285 285,575 655,1050 1050,1365 1365,1770
and probably something you haven't
可能还有一些你们以前没有看过的东西，

820
00:22:04,225 --> 00:22:06,655
0,240 240,575 1255,1590 1590,1925 2095,2430
seen before,| which is how
|那就是你们如何对一个表的记录排序，

821
00:22:06,655 --> 00:22:08,080
0,195 195,405 405,755
do you sort

822
00:22:08,290 --> 00:22:10,335
0,305 305,545 545,800 800,1120 1770,2045
a table of records,| when
|当表的大小远远大于你拥有的内存量。

823
00:22:10,335 --> 00:22:12,080
0,165 165,405 405,755 925,1325 1345,1745
the table is much larger

824
00:22:12,580 --> 00:22:14,025
0,275 275,470 470,790 810,1145 1145,1445
than the amount of memory

825
00:22:14,025 --> 00:22:15,380
0,270 270,450 450,725
that you have.|
|

826
00:22:15,680 --> 00:22:17,050
0,290 290,545 545,815 815,1130 1130,1370
As you'll see,| a theme
正如你将看到的，|许多算法的一个主题，

827
00:22:17,050 --> 00:22:18,660
0,210 210,405 405,600 600,890 970,1610
for many of the algorithms,|
|

828
00:22:18,830 --> 00:22:21,330
0,335 335,580 660,1060 1800,2150 2150,2500
they're called external, the memory
它们被称为外部内存算法，

829
00:22:21,560 --> 00:22:22,920
0,610
algorithms,|
|

830
00:22:22,920 --> 00:22:25,200
0,375 375,705 705,1040 1750,2055 2055,2280
they are based on the
它们基于分而治之的想法，

831
00:22:25,200 --> 00:22:26,625
0,225 225,495 495,750 750,960 960,1425
idea of divide and conquer,|
|

832
00:22:26,625 --> 00:22:27,360
0,195 195,270 270,390 390,555 555,735
you're going to take that
你将面对我们所面临的大问题，

833
00:22:27,360 --> 00:22:28,460
0,210 210,465 465,675 675,825 825,1100
big problem that we have,|
|

834
00:22:28,840 --> 00:22:29,760
0,275 275,440 440,575 575,740 740,920
data is too large to
数据太大无法放入内存，

835
00:22:29,760 --> 00:22:31,125
0,105 105,270 270,590 1030,1275 1275,1365
fit into memory,| split it
|请将其拆分成较小的块，

836
00:22:31,125 --> 00:22:33,015
0,105 105,330 330,675 675,1265 1555,1890
up into smaller chunks,| in
|这样单独处理每个块，

837
00:22:33,015 --> 00:22:34,250
0,240 240,405 405,600 600,885 885,1235
such a way that processing

838
00:22:34,450 --> 00:22:36,915
0,365 365,760 780,1360 1680,2300 2300,2465
each chunk individually| guarantees that
|就可以确保我们可以聚合生成最终输出。

839
00:22:36,915 --> 00:22:38,030
0,135 135,345 345,615 615,825 825,1115
we can produce the final

840
00:22:38,260 --> 00:22:39,700
0,305 305,470 470,1090
output in aggregate.|
|

841
00:22:39,770 --> 00:22:40,735
0,275 275,395 395,665 665,815 815,965
Okay, so let's see how
好的，让我们看看这是怎么工作的。

842
00:22:40,735 --> 00:22:43,320
0,150 150,425
this works.|
|

843
00:22:43,360 --> 00:22:44,925
0,350 350,575 575,850 1050,1370 1370,1565
Before we go,| as we
在我们开始之前，|在我们进行排序时，

844
00:22:44,925 --> 00:22:46,200
0,210 210,735 735,1020 1020,1140 1140,1275
do sorting,| we're going to
|我们将对要排序的数据进行多次遍历，

845
00:22:46,200 --> 00:22:48,890
0,165 165,470 490,890 1240,1640 2290,2690
take multiple passes on the

846
00:22:49,060 --> 00:22:50,300
0,335 335,545 545,650 650,770 770,1240
data that we are sorting,|
|

847
00:22:50,780 --> 00:22:52,070
0,260 520,765 765,870 870,1035 1035,1290
and we will have to
我们将不得不在中间文件中写出记录，

848
00:22:52,070 --> 00:22:55,040
0,350 670,1070 1090,1490 1660,2060 2230,2970
write records out in intermediate

849
00:22:55,040 --> 00:22:56,675
0,290 820,1095 1095,1230 1230,1410 1410,1635
files,| and the question is,
|问题是，我们在这些中间文件中写什么，

850
00:22:56,675 --> 00:22:57,515
0,180 180,300 300,420 420,630 630,840
what do we write in

851
00:22:57,515 --> 00:22:59,435
0,165 165,750 750,1055 1495,1740 1740,1920
those intermediate files,| so we're
|所以，我们对一些关键字进行排序，

852
00:22:59,435 --> 00:23:00,755
0,210 210,345 345,555 555,875 1045,1320
sorting on some key,| so
|这就是这里显示的键值，

853
00:23:00,755 --> 00:23:02,435
0,285 285,545 655,1020 1020,1380 1380,1680
that's the key value shown

854
00:23:02,435 --> 00:23:03,485
0,300 300,570 570,735 735,915 915,1050
here,| {K1 -} {K2 -},
|K1 K2 ，这里的两个不同的键值，

855
00:23:03,485 --> 00:23:04,570
0,135 135,285 285,545 565,825 825,1085
our two distinct key values

856
00:23:04,590 --> 00:23:06,220
0,400 810,1085 1085,1205 1205,1340 1340,1630
here,| and we could either
|我们可以将整个记录与键一起存储在这些中间形式中，

857
00:23:07,320 --> 00:23:09,080
0,320 320,560 560,830 830,1180 1470,1760
take the entire record along

858
00:23:09,080 --> 00:23:10,130
0,150 150,285 285,435 435,710 730,1050
with the key and store

859
00:23:10,130 --> 00:23:11,660
0,320 340,630 630,795 795,1320 1320,1530
that in these intermediate form,|
|

860
00:23:11,660 --> 00:23:13,620
0,255 255,390 390,675 675,1430
that's called early materialization,|
这就是所谓的早期物化，|

861
00:23:13,630 --> 00:23:14,490
0,275 275,410 410,515 515,635 635,860
or we could do something
或者我们可以进行一种称为后期物化的操作，

862
00:23:14,490 --> 00:23:16,065
0,240 240,495 495,1185 1185,1440 1440,1575
called late materialization,| where we
|我们只需要获取键并存储指向记录的指针，

863
00:23:16,065 --> 00:23:17,355
0,165 165,330 330,495 495,785 955,1290
just take the key and

864
00:23:17,355 --> 00:23:18,465
0,225 225,450 450,870 870,990 990,1110
store a pointer to the

865
00:23:18,465 --> 00:23:19,480
0,275
record,|
|

866
00:23:19,550 --> 00:23:21,810
0,400 750,1025 1025,1265 1265,1720 1860,2260
obviously, if I'm sorting a
显然，如果我对一个表进行排序，

867
00:23:22,220 --> 00:23:24,490
0,400 480,785 785,1090 1560,1940 1940,2270
table| in which each record
|其中每条记录都有 1000 个字节长，

868
00:23:24,490 --> 00:23:25,885
0,300 300,555 555,810 810,1140 1140,1395
is {1000 -} bytes long|
|

869
00:23:25,885 --> 00:23:26,785
0,195 195,390 390,525 525,810 810,900
and I'm just sorting on
我只是对一个 int4 排序，

870
00:23:26,785 --> 00:23:29,335
0,210 210,525 525,875 2095,2370 2370,2550
an {int4,key -},| you will,
|这里的有效负载，

871
00:23:29,335 --> 00:23:31,150
0,225 225,645 645,935 1165,1560 1560,1815
this payload here this,| if
|如果你认为这里的一切都是一个键值对，

872
00:23:31,150 --> 00:23:32,020
0,120 120,240 240,495 495,750 750,870
you think of everything here

873
00:23:32,020 --> 00:23:33,060
0,120 120,255 255,390 390,645 645,1040
as a key value pair,|
|

874
00:23:33,200 --> 00:23:34,345
0,275 275,530 530,830 830,1010 1010,1145
the value portion is going
那么值部分将是 1000 个字节，

875
00:23:34,345 --> 00:23:35,430
0,105 105,165 165,270 270,525 525,1085
to be {1000 -} bytes,|
|

876
00:23:35,720 --> 00:23:37,045
0,400 420,695 695,860 860,1070 1070,1325
and if this record ID
假设这个记录 ID 是 8 个字节，

877
00:23:37,045 --> 00:23:38,370
0,240 240,480 480,615 615,840 840,1325
is, let's say, 8 bytes,|
|

878
00:23:38,600 --> 00:23:40,410
0,425 425,700 840,1205 1205,1565 1565,1810
that's the space, that's this,
那是空间，那是表示磁盘上指针所需的字节数，

879
00:23:41,030 --> 00:23:42,415
0,400 480,815 815,1160 1160,1280 1280,1385
number of bytes that you

880
00:23:42,415 --> 00:23:43,480
0,120 120,255 255,495 495,750 750,1065
need to represent a pointer

881
00:23:43,480 --> 00:23:44,665
0,135 135,645 645,885 885,1020 1020,1185
on disk| and you saw
|你可以看到这些指针是什么样子的，

882
00:23:44,665 --> 00:23:45,870
0,150 150,330 330,705 705,900 900,1205
what those pointers look like,|
|

883
00:23:46,010 --> 00:23:47,110
0,275 275,440 440,605 605,755 755,1100
the same type of pointers
与 B 树的叶子节点的指针类型相同，

884
00:23:47,110 --> 00:23:48,070
0,150 150,300 300,480 480,690 690,960
that read the leaf node

885
00:23:48,070 --> 00:23:49,680
0,120 120,270 270,480 480,800 1210,1610
of a B tree, {}|
|

886
00:23:50,590 --> 00:23:52,155
0,350 350,740 740,1025 1025,1310 1310,1565
8 bytes here for the
这里 8 个字节用于指向记录的指针，

887
00:23:52,155 --> 00:23:53,960
0,555 555,735 735,870 870,1145 1405,1805
pointer to the record| versus
|而不是存储实际记录，

888
00:23:54,010 --> 00:23:56,205
0,440 440,770 770,1010 1010,1300 1800,2195
storing the actual record,| obviously
|显然，这将大大提高空间方面的效率，

889
00:23:56,205 --> 00:23:56,985
0,255 255,390 390,540 540,645 645,780
this is going to be

890
00:23:56,985 --> 00:23:58,755
0,255 255,570 570,935 1045,1410 1410,1770
far more efficient space wise,|
|

891
00:23:58,755 --> 00:23:59,630
0,225 225,330 330,450 450,585 585,875
so if we are writing
所以，如果我们在写东西，

892
00:23:59,650 --> 00:24:01,335
0,400 540,800 800,950 950,1240 1350,1685
stuff,| this would take fewer
|这将占用更少的字节数，

893
00:24:01,335 --> 00:24:02,910
0,240 240,435 435,905 1165,1440 1440,1575
number of bytes,| that we
|需要写入磁盘的字节数，

894
00:24:02,910 --> 00:24:03,900
0,150 150,300 300,560 610,870 870,990
need to write to the

895
00:24:03,900 --> 00:24:05,220
0,435 435,690 690,825 825,1050 1050,1320
disk,| as we are doing
|因为我们在文件上执行多次遍历，

896
00:24:05,220 --> 00:24:07,520
0,285 285,680 850,1250 1720,2010 2010,2300
multiple passes on the file,|
|

897
00:24:08,120 --> 00:24:09,440
0,320 490,780 780,960 960,1155 1155,1320
but at the end, when
但是最后，当我们完成排序时，

898
00:24:09,440 --> 00:24:10,310
0,90 90,180 180,375 375,765 765,870
we are done sorting,| we
|我们必须检索所有这些记录，

899
00:24:10,310 --> 00:24:11,240
0,75 75,180 180,315 315,795 795,930
have to go retrieve all

900
00:24:11,240 --> 00:24:12,125
0,180 180,420 420,645 645,750 750,885
these records| and they have
|它们可能有一大堆随机 I/O ，

901
00:24:12,125 --> 00:24:12,965
0,210 210,360 360,495 495,675 675,840
maybe a whole bunch of

902
00:24:12,965 --> 00:24:14,380
0,225 225,755
random I/Os,|
|

903
00:24:14,380 --> 00:24:16,620
0,285 285,540 540,830 910,1310 1840,2240
generally what happens is, {}|
通常的情况是，|

904
00:24:17,360 --> 00:24:18,730
0,335 335,635 635,890 890,1115 1115,1370
row stores will use this
行存储会使用这种格式，

905
00:24:18,730 --> 00:24:20,620
0,320 700,1050 1050,1275 1275,1550 1630,1890
format,| column stores are naturally
|列存储自然是这样的格式，

906
00:24:20,620 --> 00:24:21,445
0,120 120,240 240,465 465,690 690,825
in the format,| where the
|其中键还没有组合在一起，

907
00:24:21,445 --> 00:24:22,435
0,165 165,360 360,570 570,750 750,990
keys have not been brought

908
00:24:22,435 --> 00:24:24,205
0,365 535,810 810,1050 1050,1415 1465,1770
together| and they ultimately need
|它们最终需要被拉入，

909
00:24:24,205 --> 00:24:25,780
0,165 165,375 375,600 600,875 1225,1575
to be pulled in| and
|所以最好保留记录 ID 或它的某个逻辑版本，

910
00:24:25,780 --> 00:24:26,620
0,255 255,420 420,540 540,690 690,840
so might as well keep

911
00:24:26,620 --> 00:24:28,075
0,135 135,330 330,945 945,1185 1185,1455
the record IDs or some

912
00:24:28,075 --> 00:24:29,680
0,510 510,780 780,1080 1080,1305 1305,1605
logical version of that around,|
|

913
00:24:29,680 --> 00:24:31,270
0,270 270,450 450,740 1000,1305 1305,1590
because you know these records
因为你知道这些记录一开始还没有组合在一起，

914
00:24:31,270 --> 00:24:32,965
0,360 360,540 540,885 885,1190 1390,1695
haven't been stitched together to

915
00:24:32,965 --> 00:24:34,105
0,210 210,515 565,825 825,945 945,1140
begin with,| might as well
|所以不妨将组合推迟到以后，

916
00:24:34,105 --> 00:24:35,530
0,225 225,405 405,795 795,1110 1110,1425
delay that stitching till later

917
00:24:35,530 --> 00:24:36,925
0,270 270,620 640,960 960,1170 1170,1395
on,| so row stores often
|所以行存储通常会使用这种格式，

918
00:24:36,925 --> 00:24:38,425
0,210 210,390 390,615 615,935 1165,1500
will use this format,| column
|列存储通常使用这种格式，

919
00:24:38,425 --> 00:24:39,535
0,225 225,375 375,615 615,900 900,1110
stores will often use this

920
00:24:39,535 --> 00:24:41,340
0,305 565,965 1105,1380 1380,1530 1530,1805
format| for how they represent
|来表示内部排序内容，

921
00:24:41,420 --> 00:24:43,015
0,320 320,620 620,950 950,1280 1280,1595
the internal sort stuff,| obviously
|显然，这是更节省空间的方法。

922
00:24:43,015 --> 00:24:44,020
0,210 210,360 360,525 525,735 735,1005
this is way more space

923
00:24:44,020 --> 00:24:44,780
0,350
efficient.|
|

924
00:24:47,010 --> 00:24:48,180
0,275 275,550
All right,
好的，所以，让我们进入归并排序的设置。

925
00:24:48,730 --> 00:24:50,415
0,245 245,380 380,670 840,1240 1380,1685
so let's go into the

926
00:24:50,415 --> 00:24:53,020
0,455 505,905 1075,1350 1350,1625
setup for the {merge,sort}.|
|

927
00:24:53,030 --> 00:24:53,890
0,260 260,365 365,470 470,665 665,860
We have a data that
我们有一个 N 页的数据，

928
00:24:53,890 --> 00:24:55,740
0,210 210,510 510,860
is N pages,|
|

929
00:24:55,890 --> 00:24:57,260
0,400 660,890 890,980 980,1085 1085,1370
and we have a buffer
我们有一个缓冲池是 B 页，

930
00:24:57,260 --> 00:24:58,210
0,150 150,300 300,450 450,645 645,950
pool that is B pages,|
|

931
00:24:58,620 --> 00:25:00,095
0,290 290,575 575,920 920,1220 1220,1475
N is much larger than
N 比 B 大得多，

932
00:25:00,095 --> 00:25:01,715
0,305 685,945 945,1155 1155,1365 1365,1620
B,| and we've started a
|我们开始一个非常简单的外部合并排序版本，

933
00:25:01,715 --> 00:25:03,665
0,255 255,605 1135,1500 1500,1740 1740,1950
very simple version of the

934
00:25:03,665 --> 00:25:05,255
0,300 300,705 705,995 1165,1440 1440,1590
external merge sort,| in which
|在这个版本中，我们将以两路方式合并，

935
00:25:05,255 --> 00:25:06,155
0,105 105,180 180,300 300,480 480,900
we are going to merge

936
00:25:06,155 --> 00:25:07,670
0,285 285,555 555,845 1165,1410 1410,1515
things two ways,| and then
|然后我们将看看如何推广它，

937
00:25:07,670 --> 00:25:08,360
0,195 195,315 315,435 435,540 540,690
we'll see how we can

938
00:25:08,360 --> 00:25:09,830
0,480 480,800 880,1125 1125,1260 1260,1470
generalize that,| so the 2
|2 是合并树的度数，

939
00:25:09,830 --> 00:25:11,930
0,320 610,990 990,1370 1510,1860 1860,2100
is the degree of the

940
00:25:11,930 --> 00:25:13,490
0,405 405,740 970,1230 1230,1440 1440,1560
merge tree,| and I'll show
|接下来我会向你们展示。

941
00:25:13,490 --> 00:25:14,680
0,120 120,300 300,620
you that next.|
|

942
00:25:14,830 --> 00:25:15,810
0,335 335,440 440,605 605,770 770,980
I'll come back to this
稍后我会再谈到这个，

943
00:25:15,810 --> 00:25:16,815
0,195 195,300 300,465 465,750 750,1005
in a little bit,| but
|但让我来看看图表，

944
00:25:16,815 --> 00:25:17,535
0,120 120,225 225,390 390,585 585,720
let me just go to

945
00:25:17,535 --> 00:25:18,735
0,120 120,645 645,900 900,1065 1065,1200
the diagram| and show you
|并向你展示它是如何工作的。

946
00:25:18,735 --> 00:25:20,100
0,135 135,285 285,575
how it works.|
|

947
00:25:20,140 --> 00:25:22,545
0,275 275,560 560,820 1380,2120 2120,2405
So, here's a pictorial way
所以，这是一个关于归并排序的图解，

948
00:25:22,545 --> 00:25:23,990
0,315 315,570 570,825 825,1170 1170,1445
of looking at merge sort,|
|

949
00:25:25,020 --> 00:25:26,135
0,380 380,575 575,680 680,920 920,1115
imagine we are starting with
假设我们从一个有八页的文件开始，

950
00:25:26,135 --> 00:25:27,605
0,120 120,395 775,1080 1080,1290 1290,1470
a file in which there

951
00:25:27,605 --> 00:25:30,080
0,225 225,575 775,1175 1945,2235 2235,2475
are eight pages,| the first
|第一页有两条记录，

952
00:25:30,080 --> 00:25:32,105
0,350 550,855 855,1035 1035,1310 1750,2025
page has two records,| just
|只是为了使图表易于管理，

953
00:25:32,105 --> 00:25:33,455
0,120 120,240 240,375 375,705 705,1350
to keep the diagram manageable,|
|

954
00:25:33,455 --> 00:25:34,865
0,315 315,540 540,810 810,1140 1140,1410
obviously, a page will have
显然，一个页面将包含比两条多得多的记录，通常是数百条，

955
00:25:34,865 --> 00:25:35,840
0,210 210,405 405,615 615,810 810,975
a lot more than two

956
00:25:35,840 --> 00:25:37,535
0,260 280,630 630,980 1360,1605 1605,1695
records, often hundreds,| or if
|或者，如果你使用更大的块大小，甚至可能是数千条，

957
00:25:37,535 --> 00:25:39,140
0,135 135,365 745,1080 1080,1320 1320,1605
you're using bigger block sizes,

958
00:25:39,140 --> 00:25:41,100
0,270 270,525 525,795 795,1130
maybe even many thousands,|
|

959
00:25:41,200 --> 00:25:42,600
0,275 275,410 410,560 560,850 1110,1400
but in this case, just
但在这种情况下，为了简单起见，

960
00:25:42,600 --> 00:25:43,875
0,150 150,300 300,495 495,800 1000,1275
to keep things simple,| here
|这是一个只有两个记录的页面，3 和 4 ，

961
00:25:43,875 --> 00:25:44,685
0,120 120,240 240,450 450,645 645,810
is a page which has

962
00:25:44,685 --> 00:25:45,975
0,270 270,510 510,785 895,1140 1140,1290
only two records, 3 and

963
00:25:45,975 --> 00:25:46,890
0,255 255,525 525,675 675,780 780,915
4| and 3 and 4
|3 和 4 是我排序的键，

964
00:25:46,890 --> 00:25:48,270
0,180 180,435 435,660 660,950 1120,1380
is really the key on

965
00:25:48,270 --> 00:25:49,200
0,120 120,345 345,660 660,780 780,930
which I'm sorting| and not
|而不是显示所有的有效负载，所有的整个记录，

966
00:25:49,200 --> 00:25:51,300
0,195 195,390 390,680 820,1430 1810,2100
showing all the payload, all

967
00:25:51,300 --> 00:25:52,935
0,195 195,435 435,770 850,1250 1360,1635
the entire record| or the
|或我们可能保留的键指针对，

968
00:25:52,935 --> 00:25:53,790
0,135 135,330 330,585 585,735 735,855
key pointer pairs that we

969
00:25:53,790 --> 00:25:55,035
0,135 135,345 345,680 700,1005 1005,1245
might keep around,| this is
|这只是键值。

970
00:25:55,035 --> 00:25:56,700
0,270 270,480 480,630 630,905
just the key values.|
|

971
00:25:56,910 --> 00:25:57,860
0,275 275,410 410,545 545,740 740,950
And then the second page
然后第二页有 6 和 2 ，等等，

972
00:25:57,860 --> 00:25:58,970
0,180 180,375 375,585 585,840 840,1110
has 6 and 2, and

973
00:25:58,970 --> 00:25:59,900
0,195 195,405 405,600 600,735 735,930
so on,| we want to
|我们想要对这些排序，

974
00:25:59,900 --> 00:26:00,845
0,255 255,465 465,615 615,780 780,945
sort all of this,| of
|当然，当我们进行排序后，

975
00:26:00,845 --> 00:26:02,390
0,180 180,345 345,510 510,1025 1195,1545
course, when we sorted,| the
|在最终输出文件中，

976
00:26:02,390 --> 00:26:03,820
0,225 225,390 390,680 850,1140 1140,1430
in the final output file,|
|

977
00:26:03,930 --> 00:26:05,000
0,275 275,455 455,695 695,905 905,1070
the first record will be
第一条记录将是 1 ，然后是 2 ，等等，

978
00:26:05,000 --> 00:26:06,545
0,290 460,810 810,1095 1095,1350 1350,1545
1, then 2, and so

979
00:26:06,545 --> 00:26:07,595
0,275 355,615 615,735 735,885 885,1050
on,| but we want to
|但是我们想要得到这个。

980
00:26:07,595 --> 00:26:08,600
0,180 180,330 330,575
get to that.|
|

981
00:26:08,770 --> 00:26:09,765
0,260 260,455 455,590 590,800 800,995
And we'll do this by
我们将只使用三个页面来实现这个，

982
00:26:09,765 --> 00:26:11,880
0,240 240,605 715,1065 1065,1415 1825,2115
using only three pages,| just
|只是为了展示如何对文件进行排序，

983
00:26:11,880 --> 00:26:13,155
0,285 285,680 700,960 960,1095 1095,1275
to show how you can

984
00:26:13,155 --> 00:26:15,090
0,305 715,1305 1305,1560 1560,1770 1770,1935
do sorting of files,| that
|比内存大得多的文件。

985
00:26:15,090 --> 00:26:15,975
0,135 135,330 330,570 570,750 750,885
are much bigger than the

986
00:26:15,975 --> 00:26:16,935
0,165 165,345 345,585 585,825 825,960
amount of memory that you

987
00:26:16,935 --> 00:26:17,835
0,245 325,600 600,735 735,825 825,900
have.| So assume we have
|假设我们只有三个页面，非常小，

988
00:26:17,835 --> 00:26:19,550
0,225 225,495 495,785 1045,1380 1380,1715
only three pages, pretty small|
|

989
00:26:19,660 --> 00:26:21,495
0,305 305,545 545,790 900,1300 1500,1835
and we've got a seven
我们在这个文件中有七个页面，

990
00:26:21,495 --> 00:26:23,025
0,285 285,495 495,660 660,965 1225,1530
pages in this file,| there's
|有一个额外的虚拟页面放在这里，

991
00:26:23,025 --> 00:26:24,360
0,180 180,540 540,930 930,1140 1140,1335
an extra dummy page put

992
00:26:24,360 --> 00:26:26,220
0,180 180,500 910,1230 1230,1550 1570,1860
over here| to just indicate
|只是为了指示文件的结尾，

993
00:26:26,220 --> 00:26:27,090
0,120 120,225 225,405 405,630 630,870
the end of file,| that's
|这只是为了方便起见，

994
00:26:27,090 --> 00:26:28,590
0,105 105,330 330,890 1000,1335 1335,1500
just for convenience,| and also
|同样，在这种情况下，让它是 2 的幂，

995
00:26:28,590 --> 00:26:29,445
0,90 90,240 240,465 465,705 705,855
in this case, makes it

996
00:26:29,445 --> 00:26:30,645
0,120 120,315 315,540 540,845 955,1200
a power of 2,| you
|你不需要实际分配页面，

997
00:26:30,645 --> 00:26:31,860
0,165 165,270 270,540 540,840 840,1215
don't need to actually allocate

998
00:26:31,860 --> 00:26:32,715
0,135 135,330 330,510 510,630 630,855
a page,| you could just
|你可以记住这是最后一页，

999
00:26:32,715 --> 00:26:33,840
0,365 385,690 690,870 870,1005 1005,1125
remember that this is the

1000
00:26:33,840 --> 00:26:34,845
0,225 225,525 525,735 735,870 870,1005
last page,| but this is
|但这只是为了视觉清晰而显示在这里。

1001
00:26:34,845 --> 00:26:36,615
0,195 195,515 685,975 975,1245 1245,1770
just shown for visual clarity

1002
00:26:36,615 --> 00:26:37,440
0,180 180,515
over here.|
|

1003
00:26:37,950 --> 00:26:39,080
0,275 275,395 395,635 635,890 890,1130
Okay, so let's see what
好的，让我们看看会发生什么，

1004
00:26:39,080 --> 00:26:40,160
0,195 195,375 375,525 525,795 795,1080
happens,| in the first pass,|
|在第一次遍历时，|

1005
00:26:40,160 --> 00:26:40,990
0,165 165,270 270,375 375,525 525,830
we begin to make multiple
我们开始对数据进行多次遍历，

1006
00:26:41,040 --> 00:26:43,870
0,400 990,1390 1830,2090 2090,2350 2430,2830
passes on the data,| and
|在每次遍历中，

1007
00:26:44,550 --> 00:26:45,620
0,290 290,500 500,725 725,890 890,1070
in each pass,| we will
|我们将读取上一次遍历中的内容，

1008
00:26:45,620 --> 00:26:46,760
0,315 315,600 600,765 765,960 960,1140
read what we had in

1009
00:26:46,760 --> 00:26:48,545
0,120 120,345 345,710 1240,1515 1515,1785
the previous pass| and then
|然后写入新数据，

1010
00:26:48,545 --> 00:26:50,180
0,395 505,795 795,1085 1255,1515 1515,1635
write new data,| and when
|当我们写入数据时，

1011
00:26:50,180 --> 00:26:51,440
0,135 135,300 300,465 465,740 940,1260
we write that data,| we'll
|我们将使用该物化格式

1012
00:26:51,440 --> 00:26:53,260
0,230 460,750 750,990 990,1485 1485,1820
either use that materialized format|
|

1013
00:26:53,610 --> 00:26:55,070
0,275 275,455 455,760 960,1250 1250,1460
or that key and record
或键和记录 ID 格式。

1014
00:26:55,070 --> 00:26:56,320
0,270 270,620
ID format.|
|

1015
00:26:56,320 --> 00:26:57,180
0,180 180,240 240,330 330,525 525,860
So in the first pass,|
所以，在第一次遍历中，|

1016
00:26:57,380 --> 00:26:58,630
0,365 365,590 590,800 800,1055 1055,1250
the input data is the
输入数据是原始文件，

1017
00:26:58,630 --> 00:27:00,010
0,270 270,650 790,1035 1035,1170 1170,1380
original file,| so we start
|所以我们从那里开始，

1018
00:27:00,010 --> 00:27:01,495
0,320 580,840 840,1020 1020,1125 1125,1485
there| and that's the EOF
|这就是我们所说的 EOF 标记，

1019
00:27:01,495 --> 00:27:02,640
0,330 330,450 450,600 600,810 810,1145
marker as we talked about,|
|

1020
00:27:02,930 --> 00:27:04,765
0,305 305,610 750,1115 1115,1390 1470,1835
and then we'll bring one
然后我们将把一页放入内存，

1021
00:27:04,765 --> 00:27:07,230
0,365 715,1115 1375,1775 1855,2160 2160,2465
page into memory,| this page
|这一页已排序，

1022
00:27:07,430 --> 00:27:09,115
0,670 780,1085 1085,1280 1280,1460 1460,1685
sorted,| and write that back
|并将其写回新文件作为第一页，

1023
00:27:09,115 --> 00:27:10,960
0,180 180,345 345,630 630,995 1465,1845
to a new file as

1024
00:27:10,960 --> 00:27:12,370
0,255 255,465 465,800 1060,1305 1305,1410
the first page,| and in
|在这种情况下， 3,4 已经被排序了，

1025
00:27:12,370 --> 00:27:13,255
0,150 150,360 360,555 555,690 690,885
this case, {3\,4 -} was

1026
00:27:13,255 --> 00:27:14,920
0,255 255,690 690,1035 1035,1325 1345,1665
already sorted,| that's okay, we'll
|没关系，我们会写回去，

1027
00:27:14,920 --> 00:27:15,745
0,150 150,315 315,510 510,690 690,825
write that back,| so this
|这是一个新页面，

1028
00:27:15,745 --> 00:27:16,885
0,120 120,255 255,465 465,785 835,1140
is a new page,| a
|是在新文件中创建的页面的副本。

1029
00:27:16,885 --> 00:27:18,445
0,285 285,570 570,825 825,1175 1195,1560
copy of that page made

1030
00:27:18,445 --> 00:27:19,880
0,270 270,480 480,705 705,1025
in a new file.|
|

1031
00:27:21,000 --> 00:27:21,940
0,400
Okay?|
好的？|

1032
00:27:21,940 --> 00:27:23,185
0,240 240,435 435,690 690,960 960,1245
We'll take the second page,
我们将获取第二页，即 6,2 ，

1033
00:27:23,185 --> 00:27:24,985
0,210 210,375 375,630 630,995 1465,1800
which is {6\,2 -},| and
|然后在内存中对其进行排序，

1034
00:27:24,985 --> 00:27:26,430
0,270 270,540 540,870 870,1155 1155,1445
then sort that in memory|
|

1035
00:27:26,870 --> 00:27:28,225
0,260 260,500 500,755 755,1085 1085,1355
and we'll use quick sort
我们将使用快速排序或任何你最喜欢的内存排序方法做这个，

1036
00:27:28,225 --> 00:27:29,200
0,225 225,405 405,570 570,720 720,975
or any of your favorite

1037
00:27:29,200 --> 00:27:30,610
0,255 255,495 495,840 840,1185 1185,1410
in memory sort method to

1038
00:27:30,610 --> 00:27:32,400
0,150 150,440 670,990 990,1310 1390,1790
do that| and then write
|然后将 2,6 写入我们创建的新文件的第二页，

1039
00:27:32,570 --> 00:27:35,280
0,335 335,605 605,940 1350,1750 2310,2710
that {2\,6 -} on to

1040
00:27:35,750 --> 00:27:37,120
0,305 305,560 560,910 930,1205 1205,1370
the second page of this

1041
00:27:37,120 --> 00:27:38,010
0,180 180,345 345,450 450,585 585,890
new file we are creating|
|

1042
00:27:38,300 --> 00:27:39,370
0,275 275,410 410,620 620,875 875,1070
and then we keep going
然后我们继续进行，

1043
00:27:39,370 --> 00:27:40,885
0,255 255,480 480,615 615,890 1150,1515
on,| so you have {4\,9
|所以你有 4,9 ，然后 7,8 ，

1044
00:27:40,885 --> 00:27:43,500
0,365 925,1290 1290,1605 1605,1955 2215,2615
-}, then {7\,8 -},| basically
|基本上每一页都已经排序，

1045
00:27:43,550 --> 00:27:45,210
0,350 350,605 605,800 800,1055 1055,1660
each page is getting sorted|
|

1046
00:27:45,290 --> 00:27:46,495
0,260 260,410 410,700 750,1040 1040,1205
and you finally end up
你最终得到了这个文件，

1047
00:27:46,495 --> 00:27:48,260
0,270 270,665 715,1115
having this file,|
|

1048
00:27:48,410 --> 00:27:49,525
0,290 290,455 455,590 590,845 845,1115
in which you have what
其中有我们所说的 1-Page 运行，

1049
00:27:49,525 --> 00:27:50,790
0,150 150,300 300,525 525,870 870,1265
we call as {1-Page -}

1050
00:27:50,930 --> 00:27:53,200
0,400 1050,1450 1530,1805 1805,2000 2000,2270
runs,| basically in this file,|
|基本上在这个文件中，|

1051
00:27:53,200 --> 00:27:54,250
0,195 195,300 300,495 495,750 750,1050
there are as many pages
有和输入文件中一样多的页面，

1052
00:27:54,250 --> 00:27:55,585
0,360 360,630 630,840 840,1050 1050,1335
as there are in the

1053
00:27:55,585 --> 00:27:56,900
0,300 300,605
input file,|
|

1054
00:27:58,090 --> 00:28:00,435
0,400 870,1270 1380,1780 1860,2150 2150,2345
and each page in this
这个文件中的每一页，

1055
00:28:00,435 --> 00:28:03,000
0,255 255,605 655,1055 1225,1625 2185,2565
file,| each one page is
|每一页都是排序的，

1056
00:28:03,000 --> 00:28:04,215
0,510 510,690 690,840 840,1020 1020,1215
sorted,| and this one page
|这一页现在看起来有点奇怪，

1057
00:28:04,215 --> 00:28:05,175
0,210 210,420 420,615 615,795 795,960
seems odd right now,| but
|但是稍等到第二次遍历发生了什么。

1058
00:28:05,175 --> 00:28:06,045
0,165 165,330 330,525 525,720 720,870
just hold on till what

1059
00:28:06,045 --> 00:28:07,190
0,225 225,435 435,570 570,795 795,1145
happens in the second pass.|
|

1060
00:28:07,860 --> 00:28:09,060
0,105 105,210 210,420 420,770 1095,1200
In the second pass, here's
在第二次遍历中，我们将这样做，

1061
00:28:09,060 --> 00:28:10,280
0,135 240,330 330,590
what we'll do,|
|

1062
00:28:10,280 --> 00:28:11,750
0,240 240,405 405,690 690,1290 1290,1470
we will start merging| and
我们将开始合并，|这就是双路合并的使用的地方，

1063
00:28:11,750 --> 00:28:12,455
0,120 120,255 255,390 390,540 540,705
this is where the {2-way

1064
00:28:12,455 --> 00:28:13,460
0,165 165,480 480,660 660,840 840,1005
-} merge comes in,| we're
|我们将合并两个页面，

1065
00:28:13,460 --> 00:28:14,470
0,60 60,165 165,480 480,705 705,1010
going to merge two pages|
|

1066
00:28:14,970 --> 00:28:16,160
0,365 365,575 575,755 755,980 980,1190
and the records in each
每个页面中的记录都是排序的，

1067
00:28:16,160 --> 00:28:17,240
0,195 195,375 375,735 735,855 855,1080
page are sorted,| so we'll
|所以，我们将把该页放入缓冲池，

1068
00:28:17,240 --> 00:28:18,980
0,270 270,585 585,920 970,1370 1480,1740
bring this page into the

1069
00:28:18,980 --> 00:28:20,330
0,285 285,560 670,915 915,1065 1065,1350
buffer pool,| so now we've
|所以，现在我们已经在三页缓冲区管理器中使用了一页，

1070
00:28:20,330 --> 00:28:21,460
0,240 240,510 510,705 705,870 870,1130
used one page in our

1071
00:28:21,540 --> 00:28:23,540
0,275 275,485 485,800 800,1060 1650,2000
three page buffer manager,| we'll
|我们将把第二个页面放入缓冲池，

1072
00:28:23,540 --> 00:28:25,250
0,195 195,465 465,780 780,1160 1390,1710
bring the second page into

1073
00:28:25,250 --> 00:28:26,465
0,165 165,435 435,690 690,990 990,1215
the buffer pool,| second page
|第二页用掉了，

1074
00:28:26,465 --> 00:28:27,950
0,195 195,485 775,1125 1125,1290 1290,1485
is gone,| we'll reserve the
|我们将为输出保留第三页。

1075
00:28:27,950 --> 00:28:29,470
0,255 255,555 555,780 780,1040 1120,1520
third page for the output.|
|

1076
00:28:29,760 --> 00:28:30,500
0,245 245,365 365,545 545,620 620,740
And I don't know why
我不知道为什么会出现这些气泡，

1077
00:28:30,500 --> 00:28:31,595
0,165 165,525 525,705 705,900 900,1095
those bubbles came up,| I
|我认为 Zoom 试图变得太聪明了，

1078
00:28:31,595 --> 00:28:32,705
0,275 385,675 675,825 825,990 990,1110
think Zoom is trying to

1079
00:28:32,705 --> 00:28:34,625
0,135 135,360 360,695 955,1355 1555,1920
get too smart| and {}
|自动地做了这个，

1080
00:28:34,625 --> 00:28:36,425
0,240 240,510 510,905 1135,1515 1515,1800
did that automatically,| hopefully you
|希望你喜欢这样。

1081
00:28:36,425 --> 00:28:38,600
0,225 225,545 1645,1890 1890,2010 2010,2175
enjoyed that.| So we bring
|所以，我们将第一页和第二页放入内存，

1082
00:28:38,600 --> 00:28:39,590
0,150 150,345 345,615 615,840 840,990
the first page and the

1083
00:28:39,590 --> 00:28:41,675
0,210 210,560 820,1155 1155,1490 1840,2085
second page into memory| and
|然后我们把游标放在第一页中的最小值上，

1084
00:28:41,675 --> 00:28:43,150
0,120 120,375 375,615 615,885 885,1475
then we'll hold a cursor

1085
00:28:43,230 --> 00:28:45,125
0,400 930,1235 1235,1565 1565,1745 1745,1895
on the smallest value in

1086
00:28:45,125 --> 00:28:46,240
0,105 105,300 300,635
the first page,|
|

1087
00:28:46,950 --> 00:28:48,230
0,290 290,470 470,920 920,1115 1115,1280
hold a pointer and that
持有一个指针，指向 3 ，

1088
00:28:48,230 --> 00:28:50,045
0,210 210,435 435,740 1390,1665 1665,1815
points to 3,| hold a
|持有一个指针指向 2 ，

1089
00:28:50,045 --> 00:28:51,410
0,360 360,600 600,930 930,1215 1215,1365
pointer to 2,| which is
|这是第二页上最小的记录，

1090
00:28:51,410 --> 00:28:53,270
0,180 180,680 700,1100 1270,1605 1605,1860
the smallest record on the

1091
00:28:53,270 --> 00:28:55,310
0,320 550,950 1300,1560 1560,1770 1770,2040
second page,| and then compare
|然后比较这两个，

1092
00:28:55,310 --> 00:28:56,560
0,270 270,620
those two,|
|

1093
00:28:56,560 --> 00:28:58,015
0,150 150,440 490,870 870,1185 1185,1455
and then output the smaller
然后输出两个中较小的一个，即 2 ，

1094
00:28:58,015 --> 00:28:58,900
0,210 210,405 405,585 585,705 705,885
of those two, which is

1095
00:28:58,900 --> 00:29:00,205
0,320 640,900 900,1035 1035,1170 1170,1305
2,| and as we do
|随着我们这样做，

1096
00:29:00,205 --> 00:29:02,710
0,275 385,660 660,825 825,1115 2125,2505
that,| we will move the
|我们把第二页上的游标移动到 6 ，

1097
00:29:02,710 --> 00:29:04,015
0,495 495,615 615,780 780,1020 1020,1305
cursor on the second page

1098
00:29:04,015 --> 00:29:05,140
0,240 240,545 685,915 915,1005 1005,1125
to 6,| so in the
|所以在下一步中，

1099
00:29:05,140 --> 00:29:06,295
0,195 195,435 435,720 720,960 960,1155
next step,| we'll compare 3
|我们将比较 3 和 6 ，输出 3 ，依此类推。

1100
00:29:06,295 --> 00:29:08,260
0,180 180,485 835,1170 1170,1505 1645,1965
and 6, output 3, and

1101
00:29:08,260 --> 00:29:09,660
0,210 210,500 610,900 900,1095 1095,1400
so on.| And so effectively
|所以，我们将有效地开始产生这些输出，

1102
00:29:10,310 --> 00:29:12,595
0,545 545,890 890,1270 1350,1750 1890,2285
we'll start producing these output,|
|

1103
00:29:12,595 --> 00:29:13,765
0,285 285,435 435,570 570,845 895,1170
as soon as that output
一旦有第三个页面的输出缓冲区页面变满，

1104
00:29:13,765 --> 00:29:14,635
0,270 270,435 435,600 600,735 735,870
buffer page, which has a

1105
00:29:14,635 --> 00:29:16,285
0,210 210,545 565,885 885,1205 1315,1650
third page becomes full,| we'll
|我们就会将其写入磁盘，

1106
00:29:16,285 --> 00:29:17,455
0,135 135,300 300,435 435,905 925,1170
write it to disk,| so
|现在缓存页的输出是空闲的，

1107
00:29:17,455 --> 00:29:18,325
0,120 120,375 375,615 615,735 735,870
now that output of buffer

1108
00:29:18,325 --> 00:29:19,420
0,150 150,345 345,665 775,1005 1005,1095
page is free,| so we
|所以我们可以用下一页再次填充它。

1109
00:29:19,420 --> 00:29:20,305
0,180 180,345 345,435 435,585 585,885
can fill it up again

1110
00:29:20,305 --> 00:29:21,640
0,255 255,375 375,570 570,905
with the next page.|
|

1111
00:29:21,930 --> 00:29:22,655
0,230 230,305 305,410 410,575 575,725
So, as you can see,|
所以，正如你所看到的，|

1112
00:29:22,655 --> 00:29:23,615
0,90 90,240 240,420 420,615 615,960
as I do this merge
在我做这个合并步骤时，

1113
00:29:23,615 --> 00:29:26,470
0,305 715,1065 1065,1415 2095,2475 2475,2855
step,| in this second pass,
|在第二次遍历中，称为 pass #1 ，

1114
00:29:26,490 --> 00:29:27,995
0,400 600,890 890,1070 1070,1280 1280,1505
which is called pass {#1

1115
00:29:27,995 --> 00:29:30,260
0,305 355,630 630,795 795,1085 2005,2265
-},| because we started the
|因为我们开始的第一次遍历被标记为 0 ，

1116
00:29:30,260 --> 00:29:31,450
0,180 180,405 405,585 585,825 825,1190
first pass was label 0,|
|

1117
00:29:31,890 --> 00:29:33,635
0,305 305,545 545,800 800,1120 1440,1745
in pass {#1 -}, we
在 pass #1 中，我们创建一个包含两个页面的序列，

1118
00:29:33,635 --> 00:29:36,845
0,305 535,930 930,1325 1735,2135 2845,3210
will have created a sequence

1119
00:29:36,845 --> 00:29:38,645
0,270 270,480 480,785 1315,1635 1635,1800
of two pages| and the
|并且这两个页面上的记录已完全排序，

1120
00:29:38,645 --> 00:29:40,490
0,245 625,1025 1135,1440 1440,1620 1620,1845
records across those two pages

1121
00:29:40,490 --> 00:29:41,780
0,255 255,510 510,1040
are fully sorted,|
|

1122
00:29:41,790 --> 00:29:42,995
0,290 290,440 440,695 695,905 905,1205
and so that's called a
这称为 2-Page 运行，

1123
00:29:42,995 --> 00:29:44,495
0,360 360,755 775,1125 1125,1350 1350,1500
{2-page -} run,| you can
|你可以获取两页序列，

1124
00:29:44,495 --> 00:29:45,440
0,150 150,300 300,525 525,765 765,945
take a sequence of two

1125
00:29:45,440 --> 00:29:47,165
0,290 640,990 990,1290 1290,1560 1560,1725
pages| and across that the
|其中的记录是排序的。

1126
00:29:47,165 --> 00:29:48,710
0,195 195,435 435,935 1075,1380 1380,1545
records are sorted.| And so
|所以 2,3 被写到磁盘上，

1127
00:29:48,710 --> 00:29:49,505
0,135 135,300 300,450 450,600 600,795
the {2\,3 -} gets written

1128
00:29:49,505 --> 00:29:50,585
0,195 195,345 345,660 660,840 840,1080
out to disk,| then {4\,6
|然后是 4,6 ，

1129
00:29:50,585 --> 00:29:51,335
0,240 240,375 375,525 525,630 630,750
-},| and I'm just going
|我会用一种稍微不同的方式来画它，

1130
00:29:51,335 --> 00:29:51,995
0,150 150,315 315,435 435,540 540,660
to draw it in a

1131
00:29:51,995 --> 00:29:53,645
0,210 210,495 495,845 985,1320 1320,1650
slightly different way,| this file
|在 pass #1 结束时，创建的这个文件仍然像以前一样有 7 页，

1132
00:29:53,645 --> 00:29:54,440
0,300 300,465 465,555 555,645 645,795
created at the end of

1133
00:29:54,440 --> 00:29:56,165
0,240 240,540 540,750 750,1010 1390,1725
pass #1 still has 7

1134
00:29:56,165 --> 00:29:57,455
0,270 270,480 480,755 805,1110 1110,1290
pages as before,| 8, if
|如果添加那个虚拟页，则有 8 页。

1135
00:29:57,455 --> 00:29:58,930
0,275 415,720 720,915 915,1200 1200,1475
you add that dummy page.|
|

1136
00:29:59,130 --> 00:29:59,825
0,260 260,350 350,470 470,575 575,695
But now I'm just going
但现在我将绘制两页的顺序，

1137
00:29:59,825 --> 00:30:00,920
0,135 135,360 360,600 600,855 855,1095
to draw the sequence of

1138
00:30:00,920 --> 00:30:03,065
0,165 165,420 420,750 750,1100 1570,2145
two pages,| each pair vertically
|每一对都是这样垂直的，

1139
00:30:03,065 --> 00:30:04,190
0,180 180,435 435,675 675,885 885,1125
like that,| just to show
|只是为了表明它们是经过排序的，

1140
00:30:04,190 --> 00:30:05,165
0,195 195,315 315,450 450,810 810,975
that they are sorted, right,|
|

1141
00:30:05,165 --> 00:30:06,160
0,195 195,300 300,450 450,660 660,995
it's a {2-page -} run.|
这是 2-page 运行。|

1142
00:30:07,180 --> 00:30:08,550
0,275 275,470 470,650 650,910 1110,1370
The first {2-page -} in
这个文件中的第一个 2-page 有你所看到的，

1143
00:30:08,550 --> 00:30:10,350
0,150 150,440 850,1250 1330,1620 1620,1800
this file have what you

1144
00:30:10,350 --> 00:30:11,730
0,180 180,470 550,855 855,1125 1125,1380
see here,| the second {2-page
|第二个 2-page 也将被合并，

1145
00:30:11,730 --> 00:30:13,065
0,270 270,615 615,825 825,945 945,1335
-} will also be merged|
|

1146
00:30:13,065 --> 00:30:14,070
0,255 255,480 480,570 570,720 720,1005
and there'll be a second
页将有第二个 2-page 运行，

1147
00:30:14,070 --> 00:30:16,460
0,300 300,585 585,950 1270,1670 1990,2390
{2-page -} run for the

1148
00:30:17,200 --> 00:30:18,660
0,400 450,845 845,1100 1100,1250 1250,1460
second for,| for the {4\,9
|对于 4,9 和 7,8 页，

1149
00:30:18,660 --> 00:30:19,910
0,255 255,495 495,705 705,930 930,1250
-} and {7\,8 -} page,|
|

1150
00:30:20,260 --> 00:30:21,345
0,275 275,440 440,650 650,875 875,1085
that we had written out
我们在[]结束时写出。

1151
00:30:21,345 --> 00:30:22,125
0,195 195,315 315,420 420,570 570,780
at the end of {[]

1152
00:30:22,125 --> 00:30:23,000
0,335
-}.|
|

1153
00:30:23,460 --> 00:30:24,305
0,245 245,365 365,500 500,650 650,845
So now you can start
所以现在你可以开始看到，

1154
00:30:24,305 --> 00:30:25,580
0,195 195,485
to see,|
|

1155
00:30:25,710 --> 00:30:27,215
0,400 570,875 875,1115 1115,1325 1325,1505
first we started with data
首先，我们从完全未排序的数据开始，

1156
00:30:27,215 --> 00:30:29,040
0,305 325,645 645,885 885,1385
was completely {unsorted -},|
|

1157
00:30:29,080 --> 00:30:30,315
0,290 290,470 470,760 870,1130 1130,1235
then we said everything on
然后我们说，单个页面上的所有内容都已排序，

1158
00:30:30,315 --> 00:30:31,640
0,150 150,405 405,660 660,855 855,1325
a single page is sorted,|
|

1159
00:30:31,870 --> 00:30:32,730
0,275 275,470 470,575 575,680 680,860
now we're seeing in this
现在我们在这个生成的新文件中看到，

1160
00:30:32,730 --> 00:30:33,950
0,255 255,495 495,645 645,855 855,1220
new file that is produced,|
|

1161
00:30:34,360 --> 00:30:36,740
0,400 630,965 965,1190 1190,1480
every pair of pages
每个页面对的记录都被排序了。

1162
00:30:36,880 --> 00:30:38,100
0,260 260,520 540,860 860,1055 1055,1220
the records across that are

1163
00:30:38,100 --> 00:30:39,040
0,500
sorted.|
|

1164
00:30:39,350 --> 00:30:40,560
0,275 275,500 500,695 695,905 905,1210
Now we'll repeat this process
现在我们将使用三个缓冲池页面再次重复这个过程，

1165
00:30:41,000 --> 00:30:42,130
0,290 290,575 575,830 830,905 905,1130
again using three {} buffer

1166
00:30:42,130 --> 00:30:43,810
0,150 150,440 1030,1305 1305,1455 1455,1680
pool pages| and what we'll
|我们要做的是创建这个 4-page 运行文件，

1167
00:30:43,810 --> 00:30:45,445
0,260 610,915 915,1170 1170,1380 1380,1635
do is we'll create this

1168
00:30:45,445 --> 00:30:46,690
0,255 255,495 495,750 750,1020 1020,1245
{4-page -} run file,| we'll
|我们将通过执行以下操作来实现此目的，

1169
00:30:46,690 --> 00:30:47,710
0,105 105,285 285,590 610,885 885,1020
do that by doing the

1170
00:30:47,710 --> 00:30:49,390
0,260 520,870 870,1050 1050,1365 1365,1680
following,| we'll bring page {2\,3
|我们将页面 2,3 带到内存中，

1171
00:30:49,390 --> 00:30:50,815
0,180 180,375 375,710 880,1170 1170,1425
-} into memory,| again, now
|现在，我们对它使用一个缓冲池页面，

1172
00:30:50,815 --> 00:30:52,555
0,225 225,485 925,1230 1230,1545 1545,1740
we use one buffer pool

1173
00:30:52,555 --> 00:30:54,205
0,240 240,435 435,695 1105,1440 1440,1650
page for that,| we'll bring
|我们将页面 4,7 放入内存中，

1174
00:30:54,205 --> 00:30:55,585
0,210 210,480 480,840 840,1125 1125,1380
the page {4\,7 -} into

1175
00:30:55,585 --> 00:30:56,970
0,335 385,720 720,930 930,1095 1095,1385
memory,| second page is gone,|
|第二页不见了，|

1176
00:30:57,290 --> 00:30:59,395
0,455 455,695 695,1030 1290,1670 1670,2105
that's used for the smallest
它用于两次运行中最小的页面，

1177
00:30:59,395 --> 00:31:00,535
0,210 210,515 535,810 810,960 960,1140
page on,| the two runs
|我们尝试运行合并的，

1178
00:31:00,535 --> 00:31:01,350
0,135 135,225 225,390 390,555 555,815
we are trying to run

1179
00:31:01,370 --> 00:31:03,070
0,610 870,1130 1130,1265 1265,1490 1490,1700
merge| and then the output
|然后输出前面的页面，

1180
00:31:03,070 --> 00:31:04,680
0,225 225,590 910,1215 1215,1320 1320,1610
page before,| it's the same
|然后使用与之前相同的算法，

1181
00:31:04,730 --> 00:31:06,090
0,575 575,815 815,950 950,1085 1085,1360
algorithm that we did before,|
|

1182
00:31:06,140 --> 00:31:07,495
0,350 350,500 500,695 695,1115 1115,1355
we'll find the smallest between
我们将找出内存中的最小值，

1183
00:31:07,495 --> 00:31:09,310
0,255 255,360 360,635 1345,1650 1650,1815
what's in memory,| compared 2
|比较 2 和 4 ，输出 2 ，

1184
00:31:09,310 --> 00:31:11,440
0,165 165,470 880,1200 1200,1520 1840,2130
and 4, output 2,| move
|将光标移动到 3 ，

1185
00:31:11,440 --> 00:31:13,030
0,150 150,495 495,705 705,1040 1270,1590
the cursor to 3,| compare
|比较 3 和 4 ，输出 3 ，

1186
00:31:13,030 --> 00:31:14,820
0,180 180,360 360,680 1120,1455 1455,1790
3 and 4, output 3,|
|

1187
00:31:14,990 --> 00:31:15,880
0,245 245,365 365,530 530,725 725,890
fill up that page and
填满该页，输出缓冲区，

1188
00:31:15,880 --> 00:31:17,490
0,195 195,405 405,860 970,1290 1290,1610
the output buffer,| keep going,|
|继续运行，|

1189
00:31:18,540 --> 00:31:19,700
0,305 305,545 545,770 770,950 950,1160
at any point in time,|
在任何时候，|

1190
00:31:19,700 --> 00:31:21,035
0,180 180,345 345,600 600,950 1030,1335
we just need one input
我们只需要一个输入页面，

1191
00:31:21,035 --> 00:31:22,660
0,305 385,785
page from

1192
00:31:22,660 --> 00:31:25,165
0,260 670,1070 1360,1680 1680,2000 2110,2505
either side,| from these one
|一个输入页面来自两个合并的运行，

1193
00:31:25,165 --> 00:31:26,245
0,285 285,510 510,735 735,915 915,1080
input page from the two

1194
00:31:26,245 --> 00:31:27,300
0,195 195,375 375,465 465,555 555,1055
runs, that we are merging|
|一个输出页面，

1195
00:31:27,320 --> 00:31:29,050
0,290 290,580 630,905 905,1180 1440,1730
and one output page| and
|我们有效地创建了这个新文件，在 pass #2 ，

1196
00:31:29,050 --> 00:31:30,730
0,180 180,470 580,975 975,1350 1350,1680
we effectively create this new

1197
00:31:30,730 --> 00:31:31,600
0,285 285,495 495,600 600,705 705,870
file at the end of

1198
00:31:31,600 --> 00:31:34,240
0,290 310,710 1300,1695 1695,2090 2380,2640
pass #2,| surprise, surprise, now
|令人惊讶。这被称为 4-page 运行，

1199
00:31:34,240 --> 00:31:35,260
0,135 135,315 315,495 495,720 720,1020
this is called a {4-page

1200
00:31:35,260 --> 00:31:36,565
0,345 345,720 720,960 960,1095 1095,1305
-} run,| because in this
|因为在这个文件中，同样有 7 加 1 ， 8 页，

1201
00:31:36,565 --> 00:31:38,190
0,335 475,735 735,915 915,1230 1230,1625
file, there are again 7

1202
00:31:38,240 --> 00:31:39,900
0,335 335,620 620,1010 1010,1295 1295,1660
plus 1, dummy 8 page,|
|

1203
00:31:40,310 --> 00:31:41,800
0,365 365,650 650,935 935,1205 1205,1490
but the first four pages
但是前 4 页现在已完全排序，

1204
00:31:41,800 --> 00:31:43,200
0,255 255,405 405,615 615,1130
now are fully sorted,|
|

1205
00:31:43,200 --> 00:31:44,610
0,195 195,470 580,840 840,1100 1120,1410
the first, the records across
前四页上的记录，

1206
00:31:44,610 --> 00:31:45,480
0,150 150,330 330,510 510,675 675,870
the first four page,| you
|从第一页开始到最后一页，

1207
00:31:45,480 --> 00:31:46,500
0,180 180,345 345,510 510,780 780,1020
start from the first to

1208
00:31:46,500 --> 00:31:47,700
0,135 135,410 520,825 825,1095 1095,1200
the last| and it's in
|并且排序顺序正确。

1209
00:31:47,700 --> 00:31:49,200
0,105 105,285 285,540 540,860
the right sort order.|
|

1210
00:31:49,690 --> 00:31:51,255
0,260 260,365 365,545 545,880 1260,1565
To the last thing, which
最后一件事，那就是，

1211
00:31:51,255 --> 00:31:52,360
0,305
is,|
|

1212
00:31:52,610 --> 00:31:53,935
0,290 290,470 470,635 635,1070 1070,1325
do one more merge and
再做一次合并，你就完成了。

1213
00:31:53,935 --> 00:31:55,560
0,210 210,485 625,1025
you basically done.|
|

1214
00:31:56,050 --> 00:31:57,500
0,400 540,845 845,1010 1010,1160 1160,1450
So, as you can see,|
所以，正如你所看到的，|

1215
00:31:57,790 --> 00:31:59,025
0,245 245,365 365,545 545,850 900,1235
if you think about what's
如果你想想做这个操作的成本是多少，

1216
00:31:59,025 --> 00:32:01,110
0,150 150,455 895,1295 1495,1800 1800,2085
the cost of doing this

1217
00:32:01,110 --> 00:32:02,260
0,380
operation,|
|

1218
00:32:03,010 --> 00:32:04,800
0,400 960,1265 1265,1460 1460,1640 1640,1790
the cost is going to
成本将是页数的两倍，

1219
00:32:04,800 --> 00:32:05,860
0,260
be

1220
00:32:05,860 --> 00:32:06,865
0,285 285,510 510,690 690,840 840,1005
two times the number of

1221
00:32:06,865 --> 00:32:07,840
0,275 295,570 570,705 705,825 825,975
pages,| n is the number
|n 是每一遍的页数，

1222
00:32:07,840 --> 00:32:09,220
0,165 165,440
of pages

1223
00:32:09,220 --> 00:32:10,840
0,350 460,765 765,1020 1020,1365 1365,1620
{} in each pass,| because
|因为每一遍我们都在读，在写，

1224
00:32:10,840 --> 00:32:11,620
0,135 135,315 315,510 510,645 645,780
in each pass, we are

1225
00:32:11,620 --> 00:32:12,940
0,225 225,525 525,795 795,1050 1050,1320
reading it and writing it,|
|

1226
00:32:12,940 --> 00:32:14,040
0,210 210,420 420,660 660,840 840,1100
so hence, this {2N -}|
所以，这是 2N ，|

1227
00:32:14,420 --> 00:32:15,475
0,275 275,395 395,545 545,830 830,1055
and how many passes do
我们有多少遍，

1228
00:32:15,475 --> 00:32:16,555
0,105 105,365 445,765 765,885 885,1080
we have,| that's the depth
|就是这棵树的深度，

1229
00:32:16,555 --> 00:32:17,840
0,180 180,375 375,695
of this tree,|
|

1230
00:32:17,850 --> 00:32:19,235
0,275 275,455 455,740 740,980 980,1385
this is effectively a binary
这实际上是一棵二叉树，

1231
00:32:19,235 --> 00:32:20,810
0,365 805,1110 1110,1290 1290,1425 1425,1575
tree,| and so the depth
|所以深度将是 n 的以 2 为底的对数，

1232
00:32:20,810 --> 00:32:21,695
0,180 180,345 345,465 465,630 630,885
is going to be log

1233
00:32:21,695 --> 00:32:22,505
0,210 210,390 390,540 540,630 630,810
of n to the base

1234
00:32:22,505 --> 00:32:23,460
0,335
2,|
|

1235
00:32:23,460 --> 00:32:25,230
0,225 225,390 390,830 1000,1400 1480,1770
and the ceiling stuff is
而向上取整的东西只是为了照顾到这样一个事实，

1236
00:32:25,230 --> 00:32:25,920
0,180 180,330 330,465 465,585 585,690
just to take care of

1237
00:32:25,920 --> 00:32:26,715
0,135 135,330 330,525 525,660 660,795
the fact,| that the number
|即页数可能不是精确的 2 次方，

1238
00:32:26,715 --> 00:32:27,690
0,150 150,390 390,615 615,765 765,975
of pages may not be

1239
00:32:27,690 --> 00:32:29,520
0,240 240,465 465,770 1120,1520 1570,1830
exact power of 2,| but
|但我们不能通过半遍，

1240
00:32:29,520 --> 00:32:30,420
0,135 135,300 300,525 525,750 750,900
we can't take half a

1241
00:32:30,420 --> 00:32:31,140
0,210 210,405 405,510 510,615 615,720
pass,| we have to take
|我们必须通过一遍，

1242
00:32:31,140 --> 00:32:32,520
0,165 165,375 375,680 820,1110 1110,1380
a full pass,| and that's
|这就是我们所做的。

1243
00:32:32,520 --> 00:32:33,480
0,135 135,270 270,530
what we do.|
|

1244
00:32:33,650 --> 00:32:34,975
0,320 320,545 545,875 875,1145 1145,1325
There's an excellent question that
昨天我们在课堂上提出了一个很好的问题，

1245
00:32:34,975 --> 00:32:36,450
0,150 150,405 405,705 705,1055 1075,1475
was asked in class yesterday|
|

1246
00:32:37,220 --> 00:32:38,995
0,400 870,1250 1250,1475 1475,1595 1595,1775
about why do we go
关于为什么我们要用这种方式进行合并，

1247
00:32:38,995 --> 00:32:41,020
0,255 255,795 795,1080 1080,1445 1735,2025
about merging this way,| could
|我们能不能在第一遍中，

1248
00:32:41,020 --> 00:32:42,750
0,180 180,470 610,960 960,1310 1330,1730
we have in pass #1,|
|

1249
00:32:43,160 --> 00:32:45,430
0,380 380,740 740,1360 1650,1985 1985,2270
done this merge, then done
做这个合并，然后再做这个合并，

1250
00:32:45,430 --> 00:32:47,550
0,330 330,980 1090,1395 1395,1700 1720,2120
this merge| and before doing
|然后在进行 5,6 和 1,3 的合并来创建这 2-page 运行，

1251
00:32:47,840 --> 00:32:49,495
0,305 305,875 875,1190 1190,1430 1430,1655
the merge of the {5\,6

1252
00:32:49,495 --> 00:32:50,605
0,225 225,405 405,615 615,855 855,1110
-} and {1\,3 -} to

1253
00:32:50,605 --> 00:32:52,740
0,335 955,1290 1290,1515 1515,1770 1770,2135
create this {2-page -} run,|
|

1254
00:32:53,060 --> 00:32:55,165
0,275 275,470 470,790 1260,1760 1760,2105
could we have merged these
我们能不能把这两个合并起来来创建这个，|

1255
00:32:55,165 --> 00:32:57,160
0,375 375,660 660,965 985,1385
two to create this,|
|

1256
00:32:57,470 --> 00:32:58,495
0,275 275,410 410,605 605,830 830,1025
in the first place,| so
首先，|所以不是有效地一层一层地处理，

1257
00:32:58,495 --> 00:32:59,420
0,305
instead

1258
00:32:59,420 --> 00:33:00,860
0,260
{of,doing,the}

1259
00:33:01,320 --> 00:33:03,670
0,400 900,1300 1440,1790 1790,2045 2045,2350
processing effectively level by level,|
|

1260
00:33:04,140 --> 00:33:06,410
0,275 275,455 455,760 1440,1840 1950,2270
could we go, {} go
我们能不能走到尽可能深入树的深处，

1261
00:33:06,410 --> 00:33:07,430
0,240 240,450 450,660 660,855 855,1020
down the depth of the

1262
00:33:07,430 --> 00:33:08,225
0,135 135,285 285,465 465,630 630,795
tree as much as we

1263
00:33:08,225 --> 00:33:09,275
0,225 225,450 450,630 630,840 840,1050
can| and then keep coming
|然后继续回来，

1264
00:33:09,275 --> 00:33:10,340
0,240 240,450 450,690 690,930 930,1065
back,| so effectively what you
|所以你可以做的就是在过去的一遍中产生这个，

1265
00:33:10,340 --> 00:33:12,260
0,135 135,410 610,1010 1270,1620 1620,1920
could do is produce this

1266
00:33:12,260 --> 00:33:13,700
0,240 240,495 495,860
in pass #1,|
|

1267
00:33:13,700 --> 00:33:14,750
0,290 310,585 585,765 765,930 930,1050
pause the rest of the
暂停 pass #1 的其余处理，

1268
00:33:14,750 --> 00:33:16,280
0,255 255,540 540,780 780,1130 1240,1530
processing of pass #1,| go
|转到 pass #2 ，依此类推，

1269
00:33:16,280 --> 00:33:17,420
0,165 165,420 420,720 720,960 960,1140
to pass #2 and so

1270
00:33:17,420 --> 00:33:19,085
0,260 490,825 825,1050 1050,1335 1335,1665
on,| that was an excellent
|这是一个很好的问题，

1271
00:33:19,085 --> 00:33:20,320
0,300 300,495 495,675 675,930 930,1235
question,| the answer is yes,
|答案是可以的，你可以这样做，

1272
00:33:20,700 --> 00:33:22,340
0,305 305,545 545,755 755,1030 1350,1640
you can do that| and
|这样做的好处是，

1273
00:33:22,340 --> 00:33:23,560
0,210 210,360 360,680 730,975 975,1220
there's an advantage to that

1274
00:33:23,790 --> 00:33:26,675
0,400 810,1210 1920,2210 2210,2500 2580,2885
is,| {} you could, you
|你可以，你能处理这个，

1275
00:33:26,675 --> 00:33:28,180
0,305 415,815
process this,|
|

1276
00:33:28,180 --> 00:33:30,460
0,150 150,440 580,930 930,1280 1930,2280
you process these {2-page -}
你处理这些 2-page 运行，然后执行，

1277
00:33:30,460 --> 00:33:32,170
0,350 520,825 825,1035 1035,1340 1450,1710
runs and do that,| you
|你可以删除这个页面，

1278
00:33:32,170 --> 00:33:34,660
0,260 550,950 1120,1520 1540,1940 2140,2490
can delete this page,| this
|磁盘上这一组四个页面，

1279
00:33:34,660 --> 00:33:35,800
0,210 210,360 360,540 540,825 825,1140
set of four pages from

1280
00:33:35,800 --> 00:33:37,510
0,585 585,855 855,1005 1005,1280 1360,1710
disk| and you basically just
|你基本上只有这一部分，

1281
00:33:37,510 --> 00:33:39,250
0,300 300,555 555,855 855,1250 1450,1740
have this portion here,| but
|但是，你不会在磁盘上分配那么多空间，

1282
00:33:39,250 --> 00:33:41,005
0,105 105,270 270,500 520,1310 1390,1755
so you're not allocating as

1283
00:33:41,005 --> 00:33:42,580
0,360 360,675 675,900 900,1365 1365,1575
much space on disk,| because
|因为在这一点上，你可能会丢弃这些，

1284
00:33:42,580 --> 00:33:43,840
0,150 150,375 375,710 820,1095 1095,1260
at that point you could

1285
00:33:43,840 --> 00:33:45,610
0,290 310,780 780,990 990,1340 1480,1770
be tossing this away,| in
|在另一种情况下，你将在磁盘上分配两倍的页面，

1286
00:33:45,610 --> 00:33:46,525
0,150 150,360 360,645 645,825 825,915
the other case, you will

1287
00:33:46,525 --> 00:33:47,545
0,165 165,390 390,600 600,795 795,1020
have twice as many pages

1288
00:33:47,545 --> 00:33:49,015
0,525 525,735 735,1215 1215,1410 1410,1470
allocated on disk,| so if
|所以，如果你的磁盘已满，

1289
00:33:49,015 --> 00:33:50,065
0,120 120,360 360,480 480,735 735,1050
your disk is getting full|
|

1290
00:33:50,065 --> 00:33:51,900
0,210 210,375 375,570 570,875 1435,1835
then that might help,| generally
那么这可能会有所帮助，|一般来说，现在的磁盘有足够的空间，

1291
00:33:51,920 --> 00:33:53,455
0,550 570,875 875,1085 1085,1310 1310,1535
disks these days have plenty

1292
00:33:53,455 --> 00:33:54,205
0,210 210,405 405,510 510,645 645,750
of space,| so it's not
|所以这不是问题，

1293
00:33:54,205 --> 00:33:55,350
0,135 135,345 345,600 600,885 885,1145
a problem,| but that's definitely
|但这绝对是一种考虑它的方式，

1294
00:33:55,910 --> 00:33:56,950
0,290 290,485 485,650 650,830 830,1040
a way to think about

1295
00:33:56,950 --> 00:33:57,715
0,180 180,360 360,525 525,645 645,765
it,| and those are the
|这些都是人们仍在不断改进外部排序的方法，

1296
00:33:57,715 --> 00:33:58,585
0,180 180,345 345,495 495,675 675,870
ways in which people are

1297
00:33:58,585 --> 00:34:01,050
0,210 210,515 685,1085 1615,2015 2065,2465
still constantly improving external sort,|
|

1298
00:34:01,160 --> 00:34:02,350
0,320 320,425 425,575 575,860 860,1190
it's still a blood sport,|
这仍然是一项[血腥的]运动，|

1299
00:34:02,350 --> 00:34:03,840
0,345 345,645 645,885 885,1155 1155,1490
people compete very heavily on
人们在排序的速度展开了激烈的竞争，

1300
00:34:03,950 --> 00:34:05,430
0,380 380,740 740,995 995,1175 1175,1480
how fast they can sort|
|

1301
00:34:05,750 --> 00:34:08,010
0,400 630,965 965,1205 1205,1510 1860,2260
and ideas like that,| and
以及类似的想法，|比如试图改善内存中排序，针对特定硬件，

1302
00:34:08,210 --> 00:34:09,490
0,350 350,620 620,830 830,1055 1055,1280
ideas like trying to improve

1303
00:34:09,490 --> 00:34:10,615
0,165 165,330 330,600 600,900 900,1125
the {in-memory -} sort for

1304
00:34:10,615 --> 00:34:12,145
0,285 285,665 985,1275 1275,1410 1410,1530
specific hardware,| trying to make
|试图在数据来自云存储设备的环境中工作，

1305
00:34:12,145 --> 00:34:13,165
0,180 180,375 375,510 510,690 690,1020
this work in an environment

1306
00:34:13,165 --> 00:34:14,605
0,285 285,575 775,1050 1050,1215 1215,1440
where your data is coming

1307
00:34:14,605 --> 00:34:16,255
0,195 195,390 390,725 835,1235 1345,1650
from a cloud storage device|
|

1308
00:34:16,255 --> 00:34:17,140
0,210 210,390 390,540 540,690 690,885
and can you do things
你可以更快地处理事情，

1309
00:34:17,140 --> 00:34:18,535
0,320 670,945 945,1080 1080,1215 1215,1395
faster,| all of this is
|所有这一切仍然是一个有趣的话题，

1310
00:34:18,535 --> 00:34:20,040
0,305 385,675 675,965
still interesting topic,|
|

1311
00:34:20,040 --> 00:34:21,360
0,105 105,255 255,560 610,990 990,1320
in other words, external []
换言之，外部排序仍然是一个值得探讨的研究课题。

1312
00:34:21,360 --> 00:34:22,880
0,350 370,705 705,1005 1005,1245 1245,1520
sort is still a research

1313
00:34:22,930 --> 00:34:24,320
0,335 335,545 545,695 695,875 875,1390
topic that is worth pursuing.|
|

1314
00:34:26,440 --> 00:34:28,710
0,400 810,1210 1650,2030 2030,2135 2135,2270
Okay, now let's go and
好的，现在让我们看看，

1315
00:34:28,710 --> 00:34:29,535
0,165 165,315 315,450 450,600 600,825
see| how we can make
|如何才能把我们已经有的东西做得更好。

1316
00:34:29,535 --> 00:34:31,095
0,225 225,390 390,600 600,935 1345,1560
what we have better.| So,
|所以，我现在将回到算法的宏观角度，

1317
00:34:31,095 --> 00:34:32,565
0,180 180,300 300,540 540,905 1195,1470
I'll go back now to

1318
00:34:32,565 --> 00:34:34,380
0,275 325,1025 1075,1425 1425,1650 1650,1815
the macro perspective of what

1319
00:34:34,380 --> 00:34:36,690
0,285 285,780 780,1070 1720,2025 2025,2310
the algorithm does,| we have
|我们有 pass #0 ，

1320
00:34:36,690 --> 00:34:37,875
0,330 330,675 675,945 945,1065 1065,1185
pass #0,| where we were
|我们将一页读入内存，

1321
00:34:37,875 --> 00:34:39,020
0,210 210,450 450,630 630,825 825,1145
reading one page into memory,|
|

1322
00:34:39,490 --> 00:34:40,485
0,305 305,470 470,635 635,815 815,995
sort that into a {1-page
在 1-page 运行中排序，

1323
00:34:40,485 --> 00:34:41,930
0,240 240,575 715,975 975,1140 1140,1445
-} run,| then then pass
|然后 pass #1 #2 #3 ，

1324
00:34:41,950 --> 00:34:44,025
0,335 335,575 575,740 740,1210 1290,2075
#1, #2, #3, onwards,| recursively
|然后递归地合并所有这些对，

1325
00:34:44,025 --> 00:34:45,135
0,345 345,495 495,630 630,795 795,1110
merge all of these pairs,|
|

1326
00:34:45,135 --> 00:34:46,215
0,270 270,375 375,465 465,725 745,1080
till, we are finally done
直到我们终于完成，

1327
00:34:46,215 --> 00:34:47,670
0,240 240,495 495,845 955,1245 1245,1455
right,| pretty standard, divide and
|相当标准，分而治之。

1328
00:34:47,670 --> 00:34:48,760
0,560
conquer.|
|

1329
00:34:48,760 --> 00:34:51,415
0,380 1900,2145 2145,2265 2265,2460 2460,2655
And everything is great so
到目前为止，一切都很好，

1330
00:34:51,415 --> 00:34:52,435
0,275 415,645 645,735 735,855 855,1020
far,| we are now able
|我们现在能够以极快的速度对数据进行排序，

1331
00:34:52,435 --> 00:34:53,710
0,195 195,435 435,660 660,960 960,1275
to sort stuff that's extremely

1332
00:34:53,710 --> 00:34:55,435
0,380 730,990 990,1200 1200,1440 1440,1725
fast,| but if you had
|但是如果你有一个 PB 级的文件，

1333
00:34:55,435 --> 00:34:57,130
0,270 270,690 690,965 1285,1545 1545,1695
a petabyte file| and you
|而你在缓冲池中只有 100 个页面，

1334
00:34:57,130 --> 00:34:59,350
0,225 225,560 790,1190 1600,1935 1935,2220
just had a hundred pages

1335
00:34:59,350 --> 00:35:01,255
0,210 210,315 315,585 585,860 1570,1905
in the buffer pool,| or
|或者在缓冲池中有三个页面，

1336
00:35:01,255 --> 00:35:02,275
0,255 255,480 480,675 675,825 825,1020
three or just three pages

1337
00:35:02,275 --> 00:35:03,085
0,180 180,270 270,525 525,660 660,810
in the buffer pool,| like
|像我们在这里所做的那样，

1338
00:35:03,085 --> 00:35:04,255
0,120 120,240 240,420 420,725 925,1170
we were doing here,| you
|你最终将完成对该文件的排序，

1339
00:35:04,255 --> 00:35:05,605
0,150 150,455 475,810 810,1170 1170,1350
will eventually finish sorting that

1340
00:35:05,605 --> 00:35:07,045
0,305 655,915 915,1035 1035,1185 1185,1440
file,| but it will take
|但这将需要非常非常长的时间，

1341
00:35:07,045 --> 00:35:08,785
0,330 330,695 745,1110 1110,1440 1440,1740
a very, very long time,|
|

1342
00:35:08,785 --> 00:35:10,315
0,225 225,405 405,695 895,1290 1290,1530
it may take decades or
这可能需要几十年或一个世纪，

1343
00:35:10,315 --> 00:35:11,320
0,135 135,425 475,750 750,885 885,1005
a century,| depending on the
|取决于你拥有的硬件，

1344
00:35:11,320 --> 00:35:12,355
0,225 225,450 450,645 645,885 885,1035
hardware you have,| before you
|在你完成之前。

1345
00:35:12,355 --> 00:35:13,120
0,120 120,395
are done.|
|

1346
00:35:13,160 --> 00:35:14,040
0,260 260,365 365,485 485,620 620,880
So can we do better?
那么我们能做得更好吗？我们能做得更好吗？尤其是如果我们有更多的缓冲池？想象一下，你知道，今天，千兆字节的内存是非常可行的。事实上，许多数据库服务器和高端服务器运行的内存都是TB级的。想象一下，我给您的不仅仅是三个缓冲池页面。我们能让这件事进展得更快吗？

1347
00:35:14,450 --> 00:35:15,780
0,275 275,425 425,575 575,850 930,1330
Can we do better? Especially

1348
00:35:15,920 --> 00:35:17,815
0,290 290,470 470,760 1080,1480 1590,1895
if we have larger amounts

1349
00:35:17,815 --> 00:35:19,080
0,195 195,510 510,735 735,975 975,1265
of buffer pool? So imagine,

1350
00:35:19,370 --> 00:35:21,325
0,260 260,410 410,695 695,1420 1590,1955
you know, today, gigabyte memory

1351
00:35:21,325 --> 00:35:22,780
0,345 345,660 660,1080 1080,1200 1200,1455
is very feasible. In fact,

1352
00:35:22,780 --> 00:35:24,280
0,315 315,650 670,1155 1155,1335 1335,1500
many database servers, high end

1353
00:35:24,280 --> 00:35:26,050
0,470 610,945 945,1200 1200,1635 1635,1770
servers run with terabytes of

1354
00:35:26,050 --> 00:35:27,520
0,195 195,500 820,1095 1095,1290 1290,1470
made memory. So imagine I

1355
00:35:27,520 --> 00:35:28,225
0,120 120,210 210,300 300,495 495,705
give you a lot more

1356
00:35:28,225 --> 00:35:29,430
0,210 210,435 435,750 750,915 915,1205
than three buffer pool pages.

1357
00:35:29,750 --> 00:35:31,330
0,400 450,845 845,1160 1160,1400 1400,1580
Can we make this go

1358
00:35:31,330 --> 00:35:32,580
0,120 120,315 315,650
a lot faster?|
|

1359
00:35:32,730 --> 00:35:33,725
0,290 290,500 500,695 695,830 830,995
So what can we do
那么，我们可以做些什么来让事情进展得更快呢？我们可以将其更改为在每个任务中结束。我们将不得不这么做，这么多的iOS。我们能做的就是努力降低这个成本，基本上就是这样。

1360
00:35:33,725 --> 00:35:34,690
0,165 165,300 300,480 480,675 675,965
to make this go faster?

1361
00:35:35,160 --> 00:35:36,350
0,275 275,485 485,755 755,1010 1010,1190
We can change this to

1362
00:35:36,350 --> 00:35:37,745
0,260 490,765 765,960 960,1185 1185,1395
end in each task. We're

1363
00:35:37,745 --> 00:35:38,270
0,45 45,120 120,240 240,375 375,525
going to have to do

1364
00:35:38,270 --> 00:35:40,670
0,290 820,1110 1110,1320 1320,1790 2110,2400
that, that many ios. What

1365
00:35:40,670 --> 00:35:42,320
0,195 195,465 465,830 1150,1470 1470,1650
we can do is try

1366
00:35:42,320 --> 00:35:43,895
0,195 195,480 480,765 765,1100 1300,1575
and reduce this cost, which

1367
00:35:43,895 --> 00:35:45,360
0,135 135,395 475,875
is basically this.|
|

1368
00:35:46,000 --> 00:35:47,115
0,305 305,560 560,770 770,950 950,1115
And effectively, you can do
实际上，你可以用它来做一些事情。第一，你真的必须专注于你在这里能做什么。这基本上确定了n的以2为底的对数由这棵树的形状确定。

1369
00:35:47,115 --> 00:35:48,255
0,255 255,450 450,585 585,810 810,1140
something with this. Number one,

1370
00:35:48,255 --> 00:35:49,580
0,300 300,585 585,870 870,1050 1050,1325
you really have to focus

1371
00:35:49,690 --> 00:35:50,580
0,275 275,425 425,560 560,710 710,890
on what you can do

1372
00:35:50,580 --> 00:35:53,030
0,290 730,1005 1005,1170 1170,1460 2050,2450
here. This is basically determined

1373
00:35:53,050 --> 00:35:55,035
0,400 540,940 990,1295 1295,1600 1740,1985
that log of n to

1374
00:35:55,035 --> 00:35:55,995
0,90 90,270 270,450 450,630 630,960
the base two is determined

1375
00:35:55,995 --> 00:35:56,940
0,270 270,435 435,600 600,750 750,945
by the shape of this

1376
00:35:56,940 --> 00:35:57,960
0,320
tree.|
|

1377
00:35:57,960 --> 00:35:58,605
0,120 120,195 195,315 315,480 480,645
So you can do two
所以你可以做两件事。如果我告诉你，在这种情况下，我会给你五页纸，你会怎么做？你可以砍掉这棵树。所以不是从一页开始，你可以立即转到四页或五页一页，你知道，如果我给你五页，或者让我们从四页开始，把所有的四页都放在内存中。

1378
00:35:58,605 --> 00:35:59,760
0,275 445,705 705,855 855,1035 1035,1155
things. If I told you

1379
00:35:59,760 --> 00:36:00,600
0,75 75,225 225,465 465,720 720,840
in this case I'm going

1380
00:36:00,600 --> 00:36:03,440
0,150 150,300 300,590 2140,2490 2490,2840
to give you five pages,

1381
00:36:03,820 --> 00:36:05,160
0,290 290,440 440,560 560,820 1080,1340
what could you do? You

1382
00:36:05,160 --> 00:36:06,255
0,150 150,375 375,645 645,885 885,1095
could chop this tree. So

1383
00:36:06,255 --> 00:36:07,890
0,150 150,345 345,695 805,1205 1315,1635
instead of starting with a

1384
00:36:07,890 --> 00:36:09,300
0,255 255,540 540,890 1000,1260 1260,1410
one page run, you could

1385
00:36:09,300 --> 00:36:10,515
0,290 310,615 615,795 795,1005 1005,1215
immediately go to something like

1386
00:36:10,515 --> 00:36:11,370
0,165 165,375 375,585 585,735 735,855
a four page or a

1387
00:36:11,370 --> 00:36:12,690
0,195 195,465 465,800 1000,1245 1245,1320
five page one, you know,

1388
00:36:12,690 --> 00:36:13,725
0,75 75,195 195,330 330,590 700,1035
if I give you five

1389
00:36:13,725 --> 00:36:15,360
0,335 715,1050 1050,1320 1320,1455 1455,1635
pages or let's just start

1390
00:36:15,360 --> 00:36:17,070
0,180 180,375 375,680 1150,1470 1470,1710
with four pages, bring all

1391
00:36:17,070 --> 00:36:18,710
0,195 195,360 360,650 1030,1335 1335,1640
the four pages in memory.|
|

1392
00:36:19,470 --> 00:36:21,215
0,335 335,670 870,1205 1205,1505 1505,1745
Sort them, and immediately you
把它们分类，你马上就能把它做对。

1393
00:36:21,215 --> 00:36:22,400
0,180 180,390 390,695
get this right.|
|

1394
00:36:23,470 --> 00:36:24,390
0,275 275,500 500,695 695,800 800,920
So effectively what you can
所以实际上你能做的就是拿起这棵树，然后你可以砍下树的底部。

1395
00:36:24,390 --> 00:36:25,365
0,105 105,255 255,435 435,645 645,975
do is take this tree

1396
00:36:25,365 --> 00:36:26,535
0,240 240,360 360,600 600,930 930,1170
and you can chop the

1397
00:36:26,535 --> 00:36:28,100
0,195 195,390 390,555 555,845
base of the tree.|
|

1398
00:36:28,110 --> 00:36:29,165
0,245 245,440 440,650 650,830 830,1055
So that you can reduce
所以你可以通过从这里跳到那里来减少通过次数，但因为你有更多的内存，所以如果我有四页，我可以把这四页直接转到这里，然后必须做这两次通过，省去两次。

1399
00:36:29,165 --> 00:36:30,700
0,150 150,285 285,435 435,695 1135,1535
the number of passes by

1400
00:36:30,870 --> 00:36:32,170
0,380 380,665 665,875 875,1040 1040,1300
jumping from here to there,

1401
00:36:32,370 --> 00:36:33,305
0,365 365,590 590,680 680,755 755,935
but because you have a

1402
00:36:33,305 --> 00:36:34,310
0,255 255,465 465,735 735,945 945,1005
lot more memory, so if

1403
00:36:34,310 --> 00:36:35,645
0,120 120,255 255,465 465,770 1060,1335
I've got four pages, I

1404
00:36:35,645 --> 00:36:36,670
0,150 150,330 330,510 510,705 705,1025
can just bring those four,

1405
00:36:36,750 --> 00:36:38,120
0,320 320,545 545,850 900,1190 1190,1370
go straight here, then have

1406
00:36:38,120 --> 00:36:39,010
0,135 135,270 270,465 465,630 630,890
to do these two passes,

1407
00:36:39,090 --> 00:36:40,620
0,320 320,500 500,760
save two passes.|
|

1408
00:36:41,140 --> 00:36:42,030
0,320 320,500 500,620 620,755 755,890
Second thing you can do
如果你有更多的页面，你可以做的第二件事是，没有理由进行双向合并。我可以做三向合并或四向合并，或者你知道我有多少其他页面。如果我有最好的缓冲区页面，我总是需要一个页面来输出，我可以做A，P减去单向合并，这基本上扩大了树。所以我们要砍树，把树加宽。这极大地减少了遍数，在实践中，即使是在非常大的数据集上也很少看到，因为如果你有一个PB的数据集，你可能会得到TB的主存来对其进行排序。你很少需要两个以上的遍来对数据进行排序，如果你正在做一些疯狂的、非常大的并且没有太多内存的事情，可能需要三遍。但在实践中，传球的次数不会比两三次多很多，这是因为这种技术。那么，这是如何运作的呢？

1409
00:36:42,030 --> 00:36:42,735
0,120 120,210 210,285 285,435 435,705
if you have more pages,

1410
00:36:42,735 --> 00:36:43,725
0,285 285,435 435,675 675,885 885,990
there's no reason to do

1411
00:36:43,725 --> 00:36:44,820
0,135 135,300 300,450 450,855 855,1095
a two way merge. I

1412
00:36:44,820 --> 00:36:45,570
0,120 120,240 240,390 390,570 570,750
could do a three way

1413
00:36:45,570 --> 00:36:46,470
0,300 300,405 405,525 525,705 705,900
merge or a four way

1414
00:36:46,470 --> 00:36:48,240
0,500 610,1010 1030,1290 1290,1515 1515,1770
merge or you know how

1415
00:36:48,240 --> 00:36:50,160
0,195 195,500 1240,1590 1590,1800 1800,1920
many other pages that I

1416
00:36:50,160 --> 00:36:51,060
0,150 150,300 300,510 510,660 660,900
have. If I've got b

1417
00:36:51,060 --> 00:36:52,400
0,345 345,600 600,885 885,1065 1065,1340
buffer pages, I always need

1418
00:36:52,630 --> 00:36:54,060
0,350 350,620 620,800 800,1055 1055,1430
one page for the output

1419
00:36:54,060 --> 00:36:54,810
0,225 225,330 330,465 465,585 585,750
and I could do A

1420
00:36:54,810 --> 00:36:56,460
0,285 285,650 730,1035 1035,1245 1245,1650
P minus one way merge

1421
00:36:56,460 --> 00:36:58,200
0,225 225,420 420,740 910,1500 1500,1740
and that basically widens the

1422
00:36:58,200 --> 00:36:59,220
0,320 460,690 690,795 795,855 855,1020
tree. So we're going to

1423
00:36:59,220 --> 00:37:00,915
0,255 255,480 480,770 850,1215 1215,1695
chop the tree and widen

1424
00:37:00,915 --> 00:37:02,750
0,165 165,455 535,840 840,1265 1285,1835
the tree. That dramatically reduces

1425
00:37:02,920 --> 00:37:04,590
0,305 305,530 530,740 740,1030 1380,1670
the number of passes and

1426
00:37:04,590 --> 00:37:07,130
0,270 270,650 1210,1545 1545,1880 2140,2540
in practice you rarely see

1427
00:37:07,480 --> 00:37:09,470
0,320 320,590 590,905 905,1265 1265,1990
even on very large datasets

1428
00:37:09,880 --> 00:37:10,590
0,245 245,350 350,455 455,560 560,710
because if you have a

1429
00:37:10,590 --> 00:37:12,150
0,390 390,765 765,1005 1005,1280 1300,1560
petabyte dataset you're probably going

1430
00:37:12,150 --> 00:37:13,560
0,120 120,330 330,945 945,1185 1185,1410
to get terabytes of main

1431
00:37:13,560 --> 00:37:15,210
0,255 255,510 510,735 735,1070 1330,1650
memory to sort that. You

1432
00:37:15,210 --> 00:37:16,395
0,320 340,645 645,825 825,1005 1005,1185
rarely need more than two

1433
00:37:16,395 --> 00:37:18,590
0,275 745,1050 1050,1275 1275,1595 1795,2195
passes to sort data, maybe

1434
00:37:18,610 --> 00:37:19,730
0,305 305,485 485,680 680,815 815,1120
three if you're doing something

1435
00:37:19,810 --> 00:37:21,405
0,400 450,830 830,1145 1145,1355 1355,1595
crazy, crazy big and don't

1436
00:37:21,405 --> 00:37:22,520
0,245 265,525 525,660 660,825 825,1115
have a lot of memory.

1437
00:37:22,930 --> 00:37:23,940
0,305 305,470 470,620 620,785 785,1010
But the number of passes

1438
00:37:23,940 --> 00:37:24,890
0,195 195,345 345,555 555,705 705,950
are not going to be

1439
00:37:25,000 --> 00:37:26,115
0,275 275,485 485,740 740,965 965,1115
a lot more than two

1440
00:37:26,115 --> 00:37:27,345
0,150 150,300 300,435 435,725 925,1230
or three in practice and

1441
00:37:27,345 --> 00:37:28,460
0,315 315,480 480,645 645,825 825,1115
it's because of this technique.

1442
00:37:28,780 --> 00:37:29,660
0,245 245,350 350,485 485,620 620,880
So how does this work?|
|

1443
00:37:31,020 --> 00:37:32,920
0,400 600,1000
We are.|
我们是。|

1444
00:37:32,920 --> 00:37:34,750
0,260 370,615 615,795 795,1130 1570,1830
That idea is essentially what
这个想法基本上就是我告诉你的，在这里更详细地捕捉到了。从使用所有缓冲区池页开始。所有的b页都不需要留下1作为输出，把所有的东西都放到排序后的b页中，然后写出这些排序后的运行，这样就会产生n除以b，取上限函数，就可以得到这个很好的整数排序的运行。

1445
00:37:34,750 --> 00:37:35,740
0,135 135,285 285,465 465,735 735,990
I told you captured over

1446
00:37:35,740 --> 00:37:36,355
0,135 135,225 225,315 315,450 450,615
here in a little bit

1447
00:37:36,355 --> 00:37:37,780
0,270 270,665 715,1020 1020,1185 1185,1425
more detail. Start by using

1448
00:37:37,780 --> 00:37:39,025
0,330 330,540 540,825 825,990 990,1245
all the buffer pool pages.

1449
00:37:39,025 --> 00:37:40,690
0,270 270,450 450,615 615,905 1345,1665
All the b pages don't

1450
00:37:40,690 --> 00:37:41,350
0,90 90,210 210,345 345,510 510,660
have to leave one for

1451
00:37:41,350 --> 00:37:42,625
0,210 210,480 480,800 850,1110 1110,1275
the output, bring everything into

1452
00:37:42,625 --> 00:37:44,590
0,225 225,435 435,725 1015,1635 1635,1965
those b pages sorted and

1453
00:37:44,590 --> 00:37:46,150
0,270 270,495 495,855 855,1130 1300,1560
write these sorted runs so

1454
00:37:46,150 --> 00:37:47,815
0,135 135,390 390,770 1030,1380 1380,1665
that will produce n divided

1455
00:37:47,815 --> 00:37:49,230
0,255 255,575 595,855 855,1005 1005,1415
by b, take the ceiling

1456
00:37:49,820 --> 00:37:52,020
0,400 750,1010 1010,1145 1145,1420 1800,2200
function to get that nice

1457
00:37:52,040 --> 00:37:54,640
0,560 560,850 1260,1730 1730,2020
integer number sorted runs.|
|

1458
00:37:54,810 --> 00:37:56,165
0,320 320,545 545,740 740,1030 1050,1355
And each of them is
每一页都有b页长，然后以A、B减去的方式合并。最后的等式变成了以b减去1为底的对数，对，因为这个或另一个大的减少，通过次数的大量减少，因为你从树上的节点数量开始，你拥有的节点数量要少得多。这是A，B减去波扇出树，树上的树叶数是n除以b，再加上天花板函数。

1459
00:37:56,165 --> 00:37:58,055
0,210 210,495 495,875 1165,1455 1455,1890
b pages long, then merge

1460
00:37:58,055 --> 00:37:59,170
0,210 210,315 315,450 450,720 720,1115
in A B minus way.

1461
00:37:59,400 --> 00:38:01,655
0,275 275,545 545,940 1080,1480 1920,2255
The final equation becomes a

1462
00:38:01,655 --> 00:38:02,675
0,315 315,555 555,675 675,840 840,1020
log to the base of

1463
00:38:02,675 --> 00:38:04,240
0,165 165,435 435,750 750,1085 1165,1565
b minus one, right, massive

1464
00:38:04,380 --> 00:38:05,345
0,350 350,545 545,650 650,800 800,965
reduction in the number of

1465
00:38:05,345 --> 00:38:07,180
0,275 355,645 645,810 810,1085 1435,1835
passes because of that or

1466
00:38:07,230 --> 00:38:09,500
0,350 350,650 650,1000 1410,1810 1920,2270
another big reduction because you're

1467
00:38:09,500 --> 00:38:11,360
0,210 210,420 420,570 570,860 1510,1860
starting with a much smaller

1468
00:38:11,360 --> 00:38:12,545
0,240 240,435 435,795 795,975 975,1185
number of nodes in that

1469
00:38:12,545 --> 00:38:13,910
0,225 225,405 405,555 555,815 1105,1365
tree that you have. So

1470
00:38:13,910 --> 00:38:14,720
0,120 120,240 240,390 390,570 570,810
this is A B minus

1471
00:38:14,720 --> 00:38:16,070
0,255 255,450 450,660 660,980 1090,1350
wave fan out tree where

1472
00:38:16,070 --> 00:38:17,090
0,135 135,315 315,555 555,900 900,1020
the number of leafs in

1473
00:38:17,090 --> 00:38:18,770
0,180 180,500 580,945 945,1310 1360,1680
that tree is n divided

1474
00:38:18,770 --> 00:38:20,000
0,210 210,500 580,840 840,960 960,1230
by b with the ceiling

1475
00:38:20,000 --> 00:38:20,800
0,290
function.|
|

1476
00:38:21,480 --> 00:38:22,500
0,400
Okay.|
好吧。|

1477
00:38:23,990 --> 00:38:25,270
0,275 275,550 720,1010 1010,1160 1160,1280
All right, just to put
好的，客观地说，假设我们要对一个有108页的文件进行排序，并有五个缓冲池页面，一次将五个页面放入内存排序中，这样你就得到了一个五页运行文件，以及排序后的运行次数，这将是108除以5，四舍五入。

1478
00:38:25,270 --> 00:38:27,400
0,150 150,420 420,800 1060,1460 1780,2130
that in perspective, imagine we

1479
00:38:27,400 --> 00:38:28,530
0,270 270,480 480,660 660,840 840,1130
want to sort a file

1480
00:38:29,000 --> 00:38:30,720
0,275 410,905 905,1160 1160,1415 1415,1720
with 108 pages and have

1481
00:38:30,740 --> 00:38:32,845
0,320 320,650 650,800 800,1090 1740,2105
five buffer pool pages, bring

1482
00:38:32,845 --> 00:38:33,990
0,285 285,555 555,750 750,870 870,1145
five pages at a time

1483
00:38:34,070 --> 00:38:36,130
0,350 350,700 870,1510 1740,1970 1970,2060
into memory sortback so you

1484
00:38:36,130 --> 00:38:37,240
0,120 120,285 285,540 540,840 840,1110
get a five page run

1485
00:38:37,240 --> 00:38:39,750
0,320 760,1160 1180,1455 1455,1730 2110,2510
file and the number of,

1486
00:38:39,860 --> 00:38:41,880
0,400 960,1385 1385,1565 1565,1745 1745,2020
ah, sorted runs in, that

1487
00:38:41,960 --> 00:38:43,480
0,290 290,455 455,590 590,815 1025,1520
is going to be 108

1488
00:38:43,480 --> 00:38:45,300
0,315 315,540 540,830 1180,1575 1575,1820
divided by five, rounded up.|
|

1489
00:38:45,820 --> 00:38:47,430
0,590 730,1005 1005,1245 1245,1350 1350,1610
22 and that's how many
22分，这就是你有多少分。现在这22个运行中的每一个都必须合并，但您有b个页面，所以您可以进行四向合并。记住，我们仍然需要一个页面用于输出，因此输出将是一个5乘以4的文件，每次运行将有20个页面。这是一个20页的运行文件，其中的运行次数将是6次，再合并一次，基本上就完成了。

1490
00:38:47,480 --> 00:38:48,760
0,305 305,485 485,760 840,1115 1115,1280
runs you have. Now each

1491
00:38:48,760 --> 00:38:50,065
0,165 165,420 420,945 945,1125 1125,1305
of these 22 runs have

1492
00:38:50,065 --> 00:38:51,385
0,120 120,255 255,725 925,1200 1200,1320
to be merged, but you

1493
00:38:51,385 --> 00:38:52,840
0,135 135,330 330,635 1165,1380 1380,1455
have b pages so you

1494
00:38:52,840 --> 00:38:53,575
0,135 135,240 240,360 360,555 555,735
can do a four way

1495
00:38:53,575 --> 00:38:54,685
0,300 300,540 540,765 765,930 930,1110
merge. Remember, we still need

1496
00:38:54,685 --> 00:38:55,950
0,210 210,435 435,615 615,870 870,1265
one page for the output

1497
00:38:56,210 --> 00:38:58,330
0,400 450,850 1020,1420 1710,1970 1970,2120
and so the output of

1498
00:38:58,330 --> 00:39:00,000
0,290 550,900 900,1200 1200,1410 1410,1670
that is going to be

1499
00:39:00,350 --> 00:39:02,400
0,305 305,610 630,1025 1025,1420 1650,2050
a file that is five

1500
00:39:02,450 --> 00:39:04,030
0,380 380,760 1020,1280 1280,1400 1400,1580
times four, which will have

1501
00:39:04,030 --> 00:39:05,500
0,300 300,645 645,900 900,1140 1140,1470
twenty pages in each run.

1502
00:39:05,500 --> 00:39:06,715
0,210 210,375 375,600 600,930 930,1215
So it's a twenty page

1503
00:39:06,715 --> 00:39:08,490
0,270 270,605 1015,1335 1335,1515 1515,1775
run file and the number

1504
00:39:08,570 --> 00:39:10,240
0,400 540,860 860,1055 1055,1330 1380,1670
of runs in that is

1505
00:39:10,240 --> 00:39:11,545
0,165 165,285 285,450 450,770 1030,1305
going to be six, which

1506
00:39:11,545 --> 00:39:12,720
0,150 150,435 435,600 600,840 840,1175
you merge one more time

1507
00:39:12,950 --> 00:39:14,520
0,320 320,635 635,995 995,1240
and basically you're done.|
|

1508
00:39:14,590 --> 00:39:16,185
0,260 260,520 540,940 1080,1370 1370,1595
As an exercise, try to
作为练习，试着看看不同的价值观。试着看看当b等于3时会发生什么，试着让n等于一百万，这在数据库中有一百万页是很常见的。啊，把文件放到大型数据库中，你就会明白为什么我们做的每件事都是用更大的扇形分开的，这种合并可以发生。

1509
00:39:16,185 --> 00:39:17,625
0,210 210,375 375,615 615,965 1165,1440
look at different values. Try

1510
00:39:17,625 --> 00:39:18,510
0,165 165,300 300,420 420,645 645,885
to see what happens when

1511
00:39:18,510 --> 00:39:19,490
0,135 135,240 240,435 435,675 675,980
b is equal to three,

1512
00:39:19,570 --> 00:39:20,775
0,260 260,365 365,515 515,820 840,1205
try to make n equal

1513
00:39:20,775 --> 00:39:21,830
0,195 195,300 300,540 540,780 780,1055
to a million, which is

1514
00:39:22,270 --> 00:39:23,685
0,320 320,605 605,970 1020,1280 1280,1415
not very unusual to find

1515
00:39:23,685 --> 00:39:25,140
0,135 135,675 675,825 825,1085 1165,1455
in databases to have a

1516
00:39:25,140 --> 00:39:26,880
0,240 240,590 670,1070 1240,1560 1560,1740
million page. Ah, file in

1517
00:39:26,880 --> 00:39:28,530
0,120 120,315 315,1070 1150,1425 1425,1650
the large databases and you'll

1518
00:39:28,530 --> 00:39:29,760
0,180 180,500 790,1050 1050,1140 1140,1230
see why everything we are

1519
00:39:29,760 --> 00:39:30,735
0,180 180,345 345,450 450,690 690,975
doing with the larger fan

1520
00:39:30,735 --> 00:39:32,025
0,210 210,390 390,585 585,1050 1050,1290
out and this merge can

1521
00:39:32,025 --> 00:39:32,860
0,275
happen.|
|

1522
00:39:32,960 --> 00:39:34,720
0,335 335,635 635,1000
Again, happens fast.|
再说一次，发生得很快。|

1523
00:39:34,950 --> 00:39:36,080
0,275 275,550
All right.|
好的。|

1524
00:39:36,880 --> 00:39:37,940
0,400
Okay.|
好吧。|

1525
00:39:37,950 --> 00:39:39,200
0,400
Now.|
现在。|

1526
00:39:39,200 --> 00:39:40,670
0,150 150,375 375,1010 1030,1320 1320,1470
There's an optimization that you
这是一个优化，你可以使用外部边缘，你可以利用这样的想法，如果你绘制这个对数函数，你会看到，对于较大的n值，如果我增加n，通过的次数不会有明显的变化。它将以阶跃函数的形式跳跃。

1527
00:39:40,670 --> 00:39:42,460
0,135 135,285 285,555 555,950 1060,1790
can do with external verge,

1528
00:39:42,750 --> 00:39:44,135
0,400 510,830 830,1010 1010,1145 1145,1385
where you play on this

1529
00:39:44,135 --> 00:39:45,860
0,365 745,1065 1065,1260 1260,1455 1455,1725
idea that if you plot

1530
00:39:45,860 --> 00:39:48,425
0,350 370,765 765,1160 1960,2370 2370,2565
this log function, you'll see

1531
00:39:48,425 --> 00:39:50,960
0,270 270,635 925,1325 1735,2135 2185,2535
that for large values of

1532
00:39:50,960 --> 00:39:52,360
0,285 285,480 480,690 690,1020 1020,1400
n, if I increase n,

1533
00:39:52,680 --> 00:39:53,885
0,260 260,425 425,635 635,935 935,1205
the number of passes is

1534
00:39:53,885 --> 00:39:54,910
0,165 165,330 330,480 480,690 690,1025
not going to change significantly.

1535
00:39:55,410 --> 00:39:56,900
0,350 350,470 470,635 635,940 1230,1490
It's going to jump in

1536
00:39:56,900 --> 00:39:58,280
0,165 165,405 405,740
a step function.|
|

1537
00:39:58,290 --> 00:40:00,140
0,400 900,1250 1250,1505 1505,1685 1685,1850
And if that is the
如果是这样的话，实际上，即使我给你b页，或者给你一半的页，对于整个n值范围，通过的次数可能保持不变。因此，在许多情况下，执行这种称为双缓冲的优化是有意义的。

1538
00:40:00,140 --> 00:40:02,285
0,290 610,1010 1510,1800 1800,1935 1935,2145
case, effectively, even if I

1539
00:40:02,285 --> 00:40:03,740
0,255 255,465 465,690 690,995 1135,1455
give you b pages or

1540
00:40:03,740 --> 00:40:05,105
0,195 195,470 670,975 975,1170 1170,1365
give you half of those

1541
00:40:05,105 --> 00:40:06,095
0,270 270,480 480,615 615,765 765,990
pages, the number of passes

1542
00:40:06,095 --> 00:40:07,415
0,300 300,510 510,660 660,935 1075,1320
might remain the same for

1543
00:40:07,415 --> 00:40:08,345
0,105 105,285 285,510 510,720 720,930
a whole range of n

1544
00:40:08,345 --> 00:40:10,280
0,305 1195,1425 1425,1530 1530,1725 1725,1935
values. So in many of

1545
00:40:10,280 --> 00:40:12,340
0,255 255,620 1030,1410 1410,1725 1725,2060
those cases, it makes sense

1546
00:40:12,660 --> 00:40:14,500
0,275 275,470 470,790 840,1420 1440,1840
to do this optimization called

1547
00:40:14,670 --> 00:40:16,040
0,350 350,910
double buffering.|
|

1548
00:40:16,040 --> 00:40:17,555
0,180 180,390 390,950 1060,1350 1350,1515
And double buffering does the
而双缓冲则执行以下操作。

1549
00:40:17,555 --> 00:40:18,680
0,275
following.|
|

1550
00:40:19,050 --> 00:40:20,680
0,350 350,515 515,710 710,1000 1230,1630
It's going to try and
它将尝试使用缓冲池，而不是使用所有页面，它只使用了其中的一部分来执行一次传递，而另一些内容正在准备中。让我解释一下我的意思。假设我们想要排序的表位于磁盘上，并且有一堆页面。所有页面都是平等的。我刚刚把它涂成了亮和暗，以使这个动画工作。

1551
00:40:20,940 --> 00:40:23,150
0,350 350,575 575,905 905,1210 1860,2210
use the buffer pool and

1552
00:40:23,150 --> 00:40:24,080
0,165 165,240 240,465 465,750 750,930
instead of using all the

1553
00:40:24,080 --> 00:40:25,180
0,195 195,405 405,570 570,780 780,1100
pages, it has only used

1554
00:40:25,230 --> 00:40:26,290
0,290 290,440 440,605 605,785 785,1060
part of it to do

1555
00:40:26,580 --> 00:40:28,880
0,400 990,1385 1385,1780 1830,2090 2090,2300
one pass while the other

1556
00:40:28,880 --> 00:40:29,930
0,225 225,375 375,585 585,855 855,1050
stuff is getting ready. Let

1557
00:40:29,930 --> 00:40:31,180
0,195 195,530 610,870 870,990 990,1250
me explain what I mean.

1558
00:40:31,590 --> 00:40:33,665
0,400 600,890 890,1070 1070,1360 1800,2075
So assume we have the

1559
00:40:33,665 --> 00:40:34,910
0,180 180,345 345,480 480,755 1015,1245
table that we want to

1560
00:40:34,910 --> 00:40:35,945
0,120 120,495 495,675 675,855 855,1035
be sorted is sitting on

1561
00:40:35,945 --> 00:40:36,770
0,315 315,420 420,570 570,675 675,825
disk and there's a bunch

1562
00:40:36,770 --> 00:40:38,975
0,180 180,470 1510,1815 1815,2040 2040,2205
of pages. All pages are

1563
00:40:38,975 --> 00:40:39,980
0,195 195,480 480,630 630,840 840,1005
equal. I've just colored it

1564
00:40:39,980 --> 00:40:41,060
0,180 180,390 390,555 555,825 825,1080
into light and dark to

1565
00:40:41,060 --> 00:40:42,560
0,135 135,270 270,705 705,1070
make this animation work.|
|

1566
00:40:42,600 --> 00:40:43,985
0,400 480,755 755,995 995,1220 1220,1385
And so far, everything we've
到目前为止，我们讨论过的所有内容，如果我有四个缓冲池页面，引入三个页面，进行三天的合并，并将这些输出写入到这个排序的运行中，我们将如何操作？

1567
00:40:43,985 --> 00:40:44,765
0,180 180,435 435,615 615,705 705,780
talked about, what are we

1568
00:40:44,765 --> 00:40:45,485
0,90 90,195 195,345 345,495 495,720
going to do if I've

1569
00:40:45,485 --> 00:40:46,810
0,245 295,585 585,900 900,1050 1050,1325
got four buffer pool pages,

1570
00:40:47,280 --> 00:40:49,190
0,380 380,635 635,860 860,1210 1650,1910
bring three pages in, do

1571
00:40:49,190 --> 00:40:50,690
0,165 165,345 345,510 510,1040 1150,1500
a three day merge and

1572
00:40:50,690 --> 00:40:52,685
0,255 255,560 670,1070 1180,1580 1600,1995
write those output into the,

1573
00:40:52,685 --> 00:40:54,380
0,330 330,555 555,870 870,1145
into this sorted run?|
|

1574
00:40:54,380 --> 00:40:55,220
0,195 195,285 285,390 390,615 615,840
That we are creating on
是我们在磁盘上创建的。

1575
00:40:55,220 --> 00:40:56,220
0,500
disk.|
|

1576
00:40:56,260 --> 00:40:57,255
0,275 275,410 410,590 590,785 785,995
Okay, so now with double
好的，现在使用双缓冲，假设我们有更多的页面。

1577
00:40:57,255 --> 00:40:59,190
0,545 805,1205 1375,1635 1635,1785 1785,1935
buffering, assume we have a

1578
00:40:59,190 --> 00:41:00,920
0,165 165,360 360,650 1150,1440 1440,1730
lot more pages we have.|
|

1579
00:41:01,760 --> 00:41:03,245
0,210 210,560 970,1245 1245,1365 1365,1485
Eight pages and the number
八页，通过的次数保持不变，因为将会有一个完整的n值范围。

1580
00:41:03,245 --> 00:41:04,430
0,150 150,425 475,765 765,930 930,1185
of passes remains the same

1581
00:41:04,430 --> 00:41:05,120
0,255 255,435 435,525 525,615 615,690
because there's going to be

1582
00:41:05,120 --> 00:41:05,990
0,75 75,240 240,465 465,675 675,870
a whole range of n

1583
00:41:05,990 --> 00:41:07,250
0,290 430,705 705,885 885,1140 1140,1260
values for which that's going

1584
00:41:07,250 --> 00:41:08,280
0,120 120,380
to happen.|
|

1585
00:41:08,280 --> 00:41:09,830
0,345 345,690 690,915 915,1230 1230,1550
Now what's happening right now
现在我们正在做的事情是，我们本可以进行八方合并，这肯定会有所帮助。

1586
00:41:10,540 --> 00:41:11,520
0,305 305,500 500,695 695,845 845,980
with the way we are

1587
00:41:11,520 --> 00:41:12,600
0,240 240,555 555,795 795,945 945,1080
doing things is we could

1588
00:41:12,600 --> 00:41:14,205
0,150 150,440 460,860 1060,1365 1365,1605
have gone to an eight

1589
00:41:14,205 --> 00:41:15,075
0,210 210,480 480,585 585,720 720,870
way merge and that will

1590
00:41:15,075 --> 00:41:16,340
0,255 255,635
certainly help.|
|

1591
00:41:16,340 --> 00:41:17,180
0,135 135,255 255,420 420,600 600,840
And we can, we should
我们可以，当我们试图优化这一操作时，我们显然应该考虑这一点。但我们可以考虑的另一件事是，尝试并利用这里的观察，目前该处理的顺序性质是，如果我查看CPU和磁盘，当我将页面放入缓冲池时，CPU什么都不做。只是我的IO巴士不是很忙。

1592
00:41:17,180 --> 00:41:18,740
0,380 430,735 735,1040 1150,1425 1425,1560
obviously consider that when we

1593
00:41:18,740 --> 00:41:19,955
0,135 135,345 345,645 645,870 870,1215
try to optimize this operation.

1594
00:41:19,955 --> 00:41:21,065
0,330 330,585 585,765 765,885 885,1110
But another thing we can

1595
00:41:21,065 --> 00:41:22,790
0,315 315,665 1105,1395 1395,1545 1545,1725
consider is to try and

1596
00:41:22,790 --> 00:41:24,560
0,240 240,450 450,740 970,1370 1420,1770
play with the observation here

1597
00:41:24,560 --> 00:41:27,590
0,350 640,960 960,1280 1930,2280 2280,3030
that right now the sequential

1598
00:41:27,590 --> 00:41:29,360
0,285 285,585 585,890 1030,1430 1480,1770
nature of this processing is

1599
00:41:29,360 --> 00:41:30,725
0,290 700,975 975,1110 1110,1230 1230,1365
that if I look at

1600
00:41:30,725 --> 00:41:31,925
0,165 165,510 510,630 630,765 765,1200
the cpu and the disk,

1601
00:41:31,925 --> 00:41:33,040
0,210 210,405 405,615 615,840 840,1115
when I'm bringing the pages

1602
00:41:33,120 --> 00:41:35,480
0,400 1050,1310 1310,1595 1595,1870 2070,2360
into the buffer pool, the

1603
00:41:35,480 --> 00:41:36,740
0,315 315,450 450,630 630,920 940,1260
cpu is doing nothing. It's

1604
00:41:36,740 --> 00:41:38,420
0,135 135,410 640,945 945,1380 1380,1680
just either my io bus

1605
00:41:38,420 --> 00:41:39,620
0,285 285,590
is busy.|
|

1606
00:41:39,620 --> 00:41:40,475
0,210 210,375 375,495 495,630 630,855
And then when I start
然后，当我开始处理磁盘总线并且不做任何事情时，在任何时间点都只有CPU在做这件事，如果我查看CPU资源和磁盘资源，其中一个基本上是空闲的。

1607
00:41:40,475 --> 00:41:42,860
0,335 625,915 915,1215 1215,1715 2005,2385
processing the disk buses and

1608
00:41:42,860 --> 00:41:44,420
0,285 285,495 495,800 850,1250 1300,1560
is not doing anything, and

1609
00:41:44,420 --> 00:41:45,545
0,150 150,300 300,510 510,870 870,1125
it's only the cpu that's

1610
00:41:45,545 --> 00:41:46,595
0,165 165,450 450,675 675,855 855,1050
doing so at any point

1611
00:41:46,595 --> 00:41:47,285
0,150 150,300 300,435 435,555 555,690
in time, if I look

1612
00:41:47,285 --> 00:41:48,440
0,150 150,315 315,750 750,1005 1005,1155
at the cpu resource and

1613
00:41:48,440 --> 00:41:49,610
0,105 105,435 435,770 820,1065 1065,1170
the disk resource, one of

1614
00:41:49,610 --> 00:41:51,640
0,120 120,360 360,740 880,1550
them is basically idling.|
|

1615
00:41:51,640 --> 00:41:52,300
0,180 180,255 255,360 360,465 465,660
So what if you wanted
那么，如果您想要使用所有这些资源，而我们有额外的缓冲区空间，又会怎样呢？而你可以处理的方式如下所示。你要做双倍缓冲。因此，我们将开始相同的操作，只是我们将为您正在执行的每个实际缓冲区页创建一个阴影缓冲区页。因此，车辆仍将进行三向合并。但是，当这个数据被引入时，和以前一样，它正在被合并，我将开始获取其他页面，以便为下一个页面做好准备。

1616
00:41:52,300 --> 00:41:53,560
0,270 270,555 555,810 810,990 990,1260
to use all of that

1617
00:41:53,560 --> 00:41:54,595
0,270 270,435 435,600 600,765 765,1035
and we had this extra

1618
00:41:54,595 --> 00:41:56,695
0,515 775,1175 1525,1815 1815,1965 1965,2100
buffer space? And the way

1619
00:41:56,695 --> 00:41:57,810
0,150 150,405 405,690 690,855 855,1115
you could deal with that

1620
00:41:57,980 --> 00:41:59,395
0,335 335,545 545,820 990,1265 1265,1415
is the following. You do

1621
00:41:59,395 --> 00:42:00,685
0,210 210,660 660,810 810,1035 1035,1290
double buffering. So we'll start

1622
00:42:00,685 --> 00:42:02,290
0,240 240,450 450,785 1015,1320 1320,1605
the same thing, except we'll

1623
00:42:02,290 --> 00:42:03,625
0,240 240,510 510,780 780,1140 1140,1335
create a shadow buffer page

1624
00:42:03,625 --> 00:42:04,990
0,270 270,605 655,930 930,1200 1200,1365
for each actual buffer page

1625
00:42:04,990 --> 00:42:05,905
0,165 165,360 360,495 495,645 645,915
that you're doing. So vehicle

1626
00:42:05,905 --> 00:42:06,580
0,240 240,360 360,450 450,540 540,675
still going to do a

1627
00:42:06,580 --> 00:42:08,215
0,180 180,345 345,800 1060,1365 1365,1635
three way merge. But as

1628
00:42:08,215 --> 00:42:09,760
0,300 300,635 745,1050 1050,1260 1260,1545
this data is brought in,

1629
00:42:09,760 --> 00:42:11,275
0,255 255,420 420,710 1090,1335 1335,1515
same as before and it's

1630
00:42:11,275 --> 00:42:12,520
0,195 195,630 630,885 885,1005 1005,1245
getting merged, I'm going to

1631
00:42:12,520 --> 00:42:14,790
0,350 670,1365 1365,1650 1650,1905 1905,2270
start fetching the other pages

1632
00:42:15,050 --> 00:42:16,060
0,305 305,470 470,605 605,815 815,1010
to get it ready for

1633
00:42:16,060 --> 00:42:17,040
0,150 150,440
the next.|
|

1634
00:42:17,040 --> 00:42:19,725
0,260 310,750 750,1040 2050,2385 2385,2685
Ah, merge phase or the
啊，合并阶段或该排序运行阶段的下一次创建。所以现在当我结束的时候。

1635
00:42:19,725 --> 00:42:20,940
0,315 315,585 585,855 855,1065 1065,1215
the next creation of this

1636
00:42:20,940 --> 00:42:22,875
0,345 345,555 555,890 1330,1680 1680,1935
sorted run phase. And so

1637
00:42:22,875 --> 00:42:24,350
0,305 475,735 735,945 945,1140 1140,1475
now when I'm done with.|
|

1638
00:42:25,170 --> 00:42:26,950
0,560 560,845 845,1190 1190,1475 1475,1780
Merging together these three pages
将我拥有的这三页合并在一起，形成红色线条。

1639
00:42:26,970 --> 00:42:28,415
0,260 260,395 395,670 750,1115 1115,1445
that I have into the

1640
00:42:28,415 --> 00:42:29,820
0,300 300,635
red runs.|
|

1641
00:42:30,090 --> 00:42:31,390
0,290 290,590 590,725 725,950 950,1300
The cpu was really busy,
CPU真的很忙，但光盘也很忙，因为它正在提取下一组页，需要处理这些页才能完成这一红色运行。然后我们开始处理较暗的页面，我们引入到这里来创建蓝色运行，我们将继续在这些缓冲区页面之间切换。这实际上就像你得到了缓冲池，你把它一分为二，有一个池的影子版本，其中一个正在运行，影子正在从磁盘获取数据，你不断地切换哪个是活动的，哪个是影子版本。

1642
00:42:31,680 --> 00:42:32,765
0,245 245,380 380,560 560,845 845,1085
but the disc was also

1643
00:42:32,765 --> 00:42:33,950
0,225 225,465 465,570 570,750 750,1185
busy because it was fetching

1644
00:42:33,950 --> 00:42:34,985
0,165 165,405 405,615 615,780 780,1035
the next set of pages

1645
00:42:34,985 --> 00:42:36,310
0,240 240,420 420,570 570,705 705,1325
that needs to be processed

1646
00:42:36,570 --> 00:42:37,775
0,290 290,485 485,740 740,995 995,1205
to finish writing this red

1647
00:42:37,775 --> 00:42:39,125
0,305 565,855 855,1020 1020,1170 1170,1350
run. And then we start

1648
00:42:39,125 --> 00:42:40,655
0,305 385,750 750,975 975,1320 1320,1530
working on the darker pages

1649
00:42:40,655 --> 00:42:41,590
0,195 195,330 330,480 480,645 645,935
that we brought in here

1650
00:42:41,760 --> 00:42:43,270
0,275 275,500 500,850 900,1205 1205,1510
to create that blue run

1651
00:42:43,290 --> 00:42:45,245
0,400 480,875 875,1085 1085,1670 1670,1955
and we'll keep toggling between

1652
00:42:45,245 --> 00:42:46,715
0,210 210,540 540,795 795,1170 1170,1470
those buffer pages. It's effectively

1653
00:42:46,715 --> 00:42:47,705
0,255 255,450 450,570 570,705 705,990
like you've got the buffer

1654
00:42:47,705 --> 00:42:48,995
0,275 355,690 690,915 915,1065 1065,1290
pool, you divide it into

1655
00:42:48,995 --> 00:42:50,195
0,270 270,495 495,630 630,900 900,1200
two, there's a shadow version

1656
00:42:50,195 --> 00:42:51,350
0,195 195,330 330,605 685,975 975,1155
of the pool and one

1657
00:42:51,350 --> 00:42:52,600
0,225 225,555 555,810 810,960 960,1250
is operating and the shadow

1658
00:42:52,650 --> 00:42:54,395
0,320 320,875 875,1205 1205,1430 1430,1745
is fetching data from disk

1659
00:42:54,395 --> 00:42:55,835
0,165 165,315 315,605 625,1170 1170,1440
and you keep flipping which

1660
00:42:55,835 --> 00:42:56,660
0,135 135,240 240,450 450,690 690,825
one is active and which

1661
00:42:56,660 --> 00:42:57,940
0,135 135,285 285,510 510,860
is the shadow version.|
|

1662
00:42:58,480 --> 00:43:00,105
0,365 365,695 695,920 920,1180 1320,1625
Again, obviously with this we'll
同样，很明显，有了这一点，我们将获得更好的磁盘和io的资源利用率，您可以重叠计算，您将获得响应时间的减少，而另一个缺点是有效的，因为我们以前拥有的公式是我们拥有的一半。但正如我所说的，有一个对数函数和一个天花板函数，所以在许多情况下这并不重要，不会增加传球次数。因此，这一点肯定会有所帮助。

1663
00:43:00,105 --> 00:43:03,195
0,245 385,785 865,1265 2215,2520 2520,3090
get far better resource utilization

1664
00:43:03,195 --> 00:43:04,250
0,210 210,300 300,525 525,615 615,1055
for the disk and io

1665
00:43:04,540 --> 00:43:05,760
0,290 290,440 440,590 590,1025 1025,1220
and you can overlap that

1666
00:43:05,760 --> 00:43:07,700
0,530 730,1095 1095,1305 1305,1590 1590,1940
computation, you'll get a reduction

1667
00:43:08,020 --> 00:43:11,040
0,275 275,515 515,875 875,1270 2640,3020
in the response time and

1668
00:43:11,040 --> 00:43:12,615
0,345 345,710 820,1080 1080,1440 1440,1575
the other, the downside of

1669
00:43:12,615 --> 00:43:13,800
0,150 150,300 300,495 495,815 835,1185
that is the effective being

1670
00:43:13,800 --> 00:43:15,110
0,255 255,570 570,825 825,1005 1005,1310
the equations we had before

1671
00:43:15,220 --> 00:43:16,245
0,320 320,545 545,725 725,875 875,1025
is half of what we

1672
00:43:16,245 --> 00:43:17,280
0,275 385,630 630,720 720,855 855,1035
had. But as I said,

1673
00:43:17,280 --> 00:43:18,675
0,210 210,315 315,555 555,920 1150,1395
there's a log function and

1674
00:43:18,675 --> 00:43:19,590
0,105 105,375 375,630 630,825 825,915
a ceiling function, so in

1675
00:43:19,590 --> 00:43:21,110
0,195 195,530 760,1035 1035,1260 1260,1520
many cases it won't matter,

1676
00:43:21,190 --> 00:43:22,245
0,410 410,605 605,725 725,875 875,1055
won't increase the number of

1677
00:43:22,245 --> 00:43:23,940
0,275 655,930 930,1185 1185,1485 1485,1695
passes. So this this could

1678
00:43:23,940 --> 00:43:25,060
0,270 270,650
certainly help.|
|

1679
00:43:25,250 --> 00:43:26,485
0,305 305,575 575,845 845,1055 1055,1235
Reduce that response time because
缩短响应时间，因为您同时并行使用磁盘和CPU。

1680
00:43:26,485 --> 00:43:27,655
0,225 225,450 450,735 735,915 915,1170
you're using both the disk

1681
00:43:27,655 --> 00:43:30,400
0,150 150,540 540,720 720,1025
and cpu in parallel.|
|

1682
00:43:30,550 --> 00:43:31,755
0,275 275,425 425,665 665,965 965,1205
It may not change the
它可能不会改变吞吐量。您可以减少响应时间，但有很多排序操作是并行进行的。显然，吞吐量可能不会改变，所以这是您要做的权衡。但这是一种很酷的技术，特别是如果您想降低排序操作的延迟。你可以玩弄这样的技术。

1683
00:43:31,755 --> 00:43:33,045
0,485 505,765 765,900 900,1050 1050,1290
throughput. You could get a

1684
00:43:33,045 --> 00:43:34,395
0,300 300,570 570,870 870,1095 1095,1350
response time reduction, but you've

1685
00:43:34,395 --> 00:43:35,415
0,135 135,345 345,600 600,795 795,1020
got a lot of sort

1686
00:43:35,415 --> 00:43:37,460
0,315 315,630 630,840 840,1115 1645,2045
operations happening in parallel. Obviously,

1687
00:43:37,630 --> 00:43:38,930
0,305 305,650 650,800 800,980 980,1300
the throughput may not change,

1688
00:43:38,950 --> 00:43:39,690
0,230 230,365 365,455 455,605 605,740
so it's a trade off

1689
00:43:39,690 --> 00:43:40,395
0,135 135,270 270,435 435,570 570,705
that you make. But it's

1690
00:43:40,395 --> 00:43:41,895
0,105 105,300 300,605 955,1290 1290,1500
a cool technique, especially if

1691
00:43:41,895 --> 00:43:42,705
0,180 180,375 375,525 525,660 660,810
you want to get the

1692
00:43:42,705 --> 00:43:44,070
0,510 510,615 615,765 765,1020 1020,1365
latency of that sort operation

1693
00:43:44,070 --> 00:43:45,315
0,380 490,750 750,885 885,1050 1050,1245
down. You can play around

1694
00:43:45,315 --> 00:43:46,800
0,180 180,455 475,765 765,1055
with techniques like that.|
|

1695
00:43:48,390 --> 00:43:49,520
0,275 275,550
All right.|
好的。|

1696
00:43:49,930 --> 00:43:52,460
0,400 630,1030 1470,1880 1880,2135 2135,2530
One little tidbit of information
在排序核心深处的一个小信息中，我们正在对两个值进行比较。

1697
00:43:53,080 --> 00:43:54,495
0,335 335,670 690,965 965,1145 1145,1415
deep down in the sort

1698
00:43:54,495 --> 00:43:55,875
0,365 535,795 795,930 930,1095 1095,1380
core, we are doing a

1699
00:43:55,875 --> 00:43:58,420
0,395 685,1005 1005,1215 1215,1505
comparison between two values.|
|

1700
00:43:58,420 --> 00:44:00,400
0,290 1000,1350 1350,1575 1575,1785 1785,1980
And often it helps to
通常，编写专门的代码有助于快速进行比较。

1701
00:44:00,400 --> 00:44:01,915
0,240 240,855 855,1185 1185,1395 1395,1515
write specialized code so that

1702
00:44:01,915 --> 00:44:03,420
0,275 295,695 775,1050 1050,1215 1215,1505
that comparison can be fast.|
|

1703
00:44:04,180 --> 00:44:06,480
0,105 105,300 300,650 730,1130 1900,2300
You know, especially for types
如果我可以编写代码，如果我可以编写一个排序函数，其中键的类型是预定义的，而不是必须动态推断类型，那么尤其是对于可能是复杂类型的类型，例如DateTime，或者甚至对于教师类型，如果我可以编写代码，如果我可以编写一个排序函数，其中键的类型是预定义的，而不是必须动态推断类型。

1704
00:44:06,770 --> 00:44:09,295
0,380 380,760 1260,1595 1595,1930 2190,2525
that, ah, might be complex

1705
00:44:09,295 --> 00:44:11,425
0,335 475,795 795,1385 1705,1965 1965,2130
types like datetime or even

1706
00:44:11,425 --> 00:44:12,580
0,165 165,300 300,570 570,930 930,1155
for in teacher types, if

1707
00:44:12,580 --> 00:44:13,495
0,135 135,315 315,540 540,735 735,915
I can write the code,

1708
00:44:13,495 --> 00:44:14,140
0,165 165,270 270,360 360,480 480,645
if I can write a

1709
00:44:14,140 --> 00:44:16,560
0,240 240,590 700,1100 1600,2000 2020,2420
sort function where the type

1710
00:44:16,580 --> 00:44:18,745
0,380 380,665 665,970 1260,1565 1565,2165
of the keys is predefined

1711
00:44:18,745 --> 00:44:19,705
0,315 315,525 525,645 645,735 735,960
as opposed to have to

1712
00:44:19,705 --> 00:44:20,560
0,240 240,375 375,525 525,690 690,855
infer the type on the

1713
00:44:20,560 --> 00:44:21,500
0,290
fly.|
|

1714
00:44:21,500 --> 00:44:22,415
0,165 165,345 345,555 555,690 690,915
Have to infer the type
必须在飞行中推断出类型。我必须将指向函数的指针传入排序函数，以比较值和整型相等。如果我可以只使用原生的和平等的，那会更好，那么经常呢？

1715
00:44:22,415 --> 00:44:23,210
0,240 240,405 405,585 585,705 705,795
on the fly. I have

1716
00:44:23,210 --> 00:44:24,590
0,225 225,590 610,960 960,1185 1185,1380
to pass into the sort

1717
00:44:24,590 --> 00:44:27,260
0,320 1060,1460 1810,2175 2175,2580 2580,2670
function of a pointer to

1718
00:44:27,260 --> 00:44:28,325
0,105 105,360 360,675 675,915 915,1065
a function to compare the

1719
00:44:28,325 --> 00:44:30,320
0,245 595,915 915,1155 1155,1475 1705,1995
value and int equal. It'd

1720
00:44:30,320 --> 00:44:31,040
0,105 105,285 285,450 450,570 570,720
be better if I could

1721
00:44:31,040 --> 00:44:32,530
0,195 195,465 465,830 850,1170 1170,1490
just use native and equal

1722
00:44:33,150 --> 00:44:35,160
0,400 420,740 740,1040 1040,1420
and so often what?|
|

1723
00:44:35,620 --> 00:44:36,840
0,395 395,680 680,860 860,1025 1025,1220
Systems do is they will
系统所做的是，它们将以一种通用的方式编写排序代码，如果你使用c+plus，你可以使用模板编程来编写，然后实例化模板。当您为您关心的所有数据类型编译代码时，需要快速进行。通常，这些数据类型必须是固定数据类型，如ah、int、int、int表示int 8等等。你可以用字符串做更多的事情，但是这个代码专门化，我们要说的是，我有一个泛型的排序函数。也许我看到的是Quick Sort组件。一种书面形式的短文。有一次，我不想为int编写quick，为int排序，为int 8排序，以此类推。我只编写一次，使用模板元编程编译它。所以现在我有了一个专门版本的int 2，内部循环可能会得到优化。对比较谓词进行了优化，以使int或int4get运行得非常快，但可能是，即使内部循环的某些部分作为循环，编译器也可能在编译时展开，因为它拥有完美的类型信息。

1724
00:44:36,840 --> 00:44:38,565
0,255 255,495 495,765 765,1130 1450,1725
write the sort code in

1725
00:44:38,565 --> 00:44:39,750
0,165 165,645 645,885 885,1080 1080,1185
a generic way and if

1726
00:44:39,750 --> 00:44:40,730
0,90 90,210 210,420 420,660 660,980
you in c plus plus

1727
00:44:40,900 --> 00:44:41,895
0,260 260,395 395,560 560,725 725,995
you can write that using

1728
00:44:41,895 --> 00:44:44,460
0,450 450,755 1405,1665 1665,1925 1975,2565
template programming and then instantiate

1729
00:44:44,460 --> 00:44:46,340
0,210 210,630 630,795 795,1065 1065,1880
the template. When you're compiling

1730
00:44:46,720 --> 00:44:48,525
0,290 290,580 870,1175 1175,1475 1475,1805
the code for all the

1731
00:44:48,525 --> 00:44:50,055
0,300 300,585 585,810 810,1115 1165,1530
data types that you care

1732
00:44:50,055 --> 00:44:51,510
0,365 775,1050 1050,1185 1185,1320 1320,1455
about that you need to

1733
00:44:51,510 --> 00:44:53,115
0,165 165,470 820,1095 1095,1350 1350,1605
go fast. And usually those

1734
00:44:53,115 --> 00:44:54,030
0,195 195,420 420,600 600,720 720,915
data types have to be

1735
00:44:54,030 --> 00:44:55,995
0,350 370,705 705,1020 1020,1400 1630,1965
fixed data types like ah,

1736
00:44:55,995 --> 00:44:58,080
0,335 625,1025 1195,1530 1530,1815 1815,2085
int, int, int for int

1737
00:44:58,080 --> 00:44:59,370
0,240 240,465 465,645 645,920 1030,1290
eight and so on. You

1738
00:44:59,370 --> 00:45:00,015
0,120 120,225 225,345 345,495 495,645
can do a few more

1739
00:45:00,015 --> 00:45:01,035
0,165 165,405 405,690 690,855 855,1020
things with strings but this

1740
00:45:01,035 --> 00:45:02,745
0,225 225,875 1165,1455 1455,1560 1560,1710
code specialization we're going to

1741
00:45:02,745 --> 00:45:03,480
0,105 105,165 165,240 240,360 360,735
say I have a generic

1742
00:45:03,480 --> 00:45:05,055
0,225 225,560 880,1200 1200,1425 1425,1575
sort function. Maybe I'm looking

1743
00:45:05,055 --> 00:45:06,225
0,180 180,345 345,630 630,855 855,1170
at the quicks sort component.

1744
00:45:06,225 --> 00:45:07,460
0,210 210,450 450,780 780,930 930,1235
A written quicks sort. Once

1745
00:45:07,690 --> 00:45:08,475
0,260 260,425 425,515 515,635 635,785
I don't want to write

1746
00:45:08,475 --> 00:45:09,675
0,240 240,390 390,600 600,855 855,1200
quicks sort for int to

1747
00:45:09,675 --> 00:45:11,220
0,465 465,615 615,810 810,1110 1110,1545
quicksot for int for quicksot

1748
00:45:11,220 --> 00:45:12,090
0,150 150,315 315,510 510,705 705,870
for int eight and so

1749
00:45:12,090 --> 00:45:13,125
0,240 240,510 510,675 675,825 825,1035
on. I write it once

1750
00:45:13,125 --> 00:45:15,090
0,270 270,630 630,885 885,1145 1465,1965
using template meta programming compiled

1751
00:45:15,090 --> 00:45:16,020
0,285 285,555 555,720 720,855 855,930
it. So now I have

1752
00:45:16,020 --> 00:45:17,250
0,120 120,525 525,780 780,1005 1005,1230
a specialized version of int

1753
00:45:17,250 --> 00:45:18,555
0,350 460,705 705,825 825,1050 1050,1305
two and that inner loop

1754
00:45:18,555 --> 00:45:19,875
0,180 180,420 420,780 780,1005 1005,1320
might be optimized. The comparison

1755
00:45:19,875 --> 00:45:21,740
0,510 510,815 985,1425 1425,1605 1605,1865
predicate is optimized to make

1756
00:45:21,820 --> 00:45:23,370
0,400 450,770 770,1025 1025,1280 1280,1550
int or int four get

1757
00:45:23,370 --> 00:45:24,645
0,225 225,465 465,830 940,1170 1170,1275
go really fast but it

1758
00:45:24,645 --> 00:45:25,575
0,165 165,330 330,465 465,675 675,930
might be that even some

1759
00:45:25,575 --> 00:45:26,550
0,210 210,375 375,525 525,750 750,975
parts of that inner loop

1760
00:45:26,550 --> 00:45:27,510
0,165 165,300 300,420 420,680 700,960
with as a loop, the

1761
00:45:27,510 --> 00:45:28,815
0,420 420,540 540,780 780,1095 1095,1305
compiler may be able to

1762
00:45:28,815 --> 00:45:31,065
0,450 450,785 865,1485 1485,1865 1975,2250
unroll at compilation time because

1763
00:45:31,065 --> 00:45:32,990
0,240 240,605 775,1155 1155,1530 1530,1925
it has perfect type information.|
|

1764
00:45:33,440 --> 00:45:34,895
0,180 180,315 315,540 540,1185 1185,1455
So that code specialization is
因此，代码专门化通过在C+集群编写的数据库中的各种方法在多个DATAB系统中应用。这通常是通过模板机制和编译那些显式实例化模板来完成的，以使代码运行得更快。

1765
00:45:34,895 --> 00:45:35,660
0,225 225,360 360,465 465,615 615,765
applied in a bunch of

1766
00:45:35,660 --> 00:45:36,845
0,260 310,675 675,870 870,960 960,1185
datab systems through a variety

1767
00:45:36,845 --> 00:45:38,465
0,240 240,515 895,1200 1200,1410 1410,1620
of methods in c plus

1768
00:45:38,465 --> 00:45:39,920
0,210 210,390 390,1005 1005,1215 1215,1455
cluster written databases. It's often

1769
00:45:39,920 --> 00:45:42,100
0,380 490,780 780,1125 1125,1400 1780,2180
done through template mechanism and

1770
00:45:42,120 --> 00:45:44,360
0,790 930,1265 1265,1565 1565,2060 2060,2240
compilation of those templates that

1771
00:45:44,360 --> 00:45:46,930
0,195 195,830 1240,1970 2020,2295 2295,2570
are instantiated explicitly to make

1772
00:45:47,100 --> 00:45:49,120
0,380 380,760 1200,1520 1520,1730 1730,2020
that that code go fast.|
|

1773
00:45:50,610 --> 00:45:53,080
0,260 260,515 515,760 1380,2050 2070,2470
If I'm doing sorting on.|
如果我在做分类。|

1774
00:45:54,420 --> 00:45:56,690
0,400 420,815 815,1210 1410,1810 1950,2270
Their car keys basically string
他们的车钥匙基本上是串钥匙的。然后我可以做一件简单的事情，只对整个字符串进行比较。但如果字符串很长，它们可能会有100个字符。我需要很多周期来进行单独的键比较，我们在进行这种排序时会做很多这样的键比较。

1775
00:45:56,690 --> 00:45:58,205
0,320 700,1005 1005,1185 1185,1350 1350,1515
keys. Then I could do

1776
00:45:58,205 --> 00:45:59,165
0,165 165,405 405,615 615,765 765,960
a simple thing and just

1777
00:45:59,165 --> 00:46:00,230
0,150 150,345 345,660 660,885 885,1065
do a comparison on the

1778
00:46:00,230 --> 00:46:01,280
0,320 340,645 645,780 780,870 870,1050
entire string. But if the

1779
00:46:01,280 --> 00:46:02,435
0,225 225,405 405,710 790,1035 1035,1155
strings are long, they might

1780
00:46:02,435 --> 00:46:04,265
0,105 105,345 345,695 715,1115 1495,1830
be 100 characters long. I'm

1781
00:46:04,265 --> 00:46:04,910
0,90 90,180 180,300 300,465 465,645
going to need a lot

1782
00:46:04,910 --> 00:46:06,200
0,210 210,660 660,855 855,1020 1020,1290
of cycles to just do

1783
00:46:06,200 --> 00:46:07,610
0,345 345,645 645,980 1030,1305 1305,1410
individual key comparison and we

1784
00:46:07,610 --> 00:46:08,435
0,90 90,225 225,405 405,630 630,825
are doing a lot of

1785
00:46:08,435 --> 00:46:09,575
0,180 180,405 405,870 870,1020 1020,1140
these key comparisons as we

1786
00:46:09,575 --> 00:46:10,640
0,135 135,300 300,575
do this sort.|
|

1787
00:46:10,650 --> 00:46:13,400
0,275 275,550 1110,1510 1950,2350 2370,2750
So one alternative popular technique
因此，使用的另一种流行技术是以某种编码的固定长度形式获得键的表示形式，通常类似于该字符串的64位编码版本，并且其属性基本上可以仅仅是字符串的前缀。因此，如果我比较64位编码64位版本，我可以像64位整型一样读取并在比较中使用，这比进行字符串比较更快，我可以判断某个字符串是否小于另一个字符串。

1788
00:46:13,400 --> 00:46:15,430
0,270 270,480 480,800 1330,1680 1680,2030
that gets used is to

1789
00:46:15,570 --> 00:46:16,865
0,260 260,380 380,950 950,1130 1130,1295
get a representation of the

1790
00:46:16,865 --> 00:46:18,635
0,300 300,615 615,810 810,1470 1470,1770
key in some encoded fixed

1791
00:46:18,635 --> 00:46:20,435
0,240 240,575 805,1205 1225,1560 1560,1800
length form, usually something like

1792
00:46:20,435 --> 00:46:23,210
0,305 535,1245 1245,1595 1825,2505 2505,2775
a 64 bit encoded version

1793
00:46:23,210 --> 00:46:25,070
0,240 240,480 480,830 1180,1580 1600,1860
of that string, and which

1794
00:46:25,070 --> 00:46:26,210
0,135 135,270 270,530 610,915 915,1140
has a property such that

1795
00:46:26,210 --> 00:46:27,350
0,210 210,390 390,570 570,860 880,1140
it could be basically just

1796
00:46:27,350 --> 00:46:28,540
0,165 165,540 540,705 705,885 885,1190
the prefix of the string.

1797
00:46:28,740 --> 00:46:30,130
0,230 230,305 305,545 545,940 990,1390
So if I compare that

1798
00:46:30,330 --> 00:46:32,000
0,305 305,830 830,1295 1295,1445 1445,1670
bit encoded 64 bit version

1799
00:46:32,000 --> 00:46:32,885
0,195 195,285 285,420 420,645 645,885
that I can just read

1800
00:46:32,885 --> 00:46:34,210
0,180 180,330 330,795 795,1005 1005,1325
like a 64 bit int

1801
00:46:34,380 --> 00:46:35,870
0,290 290,485 485,770 770,1150 1230,1490
and use in comparison, which

1802
00:46:35,870 --> 00:46:37,235
0,150 150,440 640,915 915,1110 1110,1365
is faster than doing string

1803
00:46:37,235 --> 00:46:38,980
0,335 775,1050 1050,1215 1215,1425 1425,1745
comparison, I can tell whether

1804
00:46:39,330 --> 00:46:41,780
0,335 335,590 590,860 860,1210 2070,2450
something is less than another

1805
00:46:41,780 --> 00:46:42,460
0,380
string.|
|

1806
00:46:42,650 --> 00:46:44,290
0,350 350,635 635,830 830,1180 1320,1640
And it's only when that
只有当前缀相等时，才必须进行完整的字符串比较。所以我不需要对这些操作中的许多操作进行完整的字符串比较。而这些比较运算正在被大量使用。因此，当您对字符串进行排序时，应该这样做。

1807
00:46:44,290 --> 00:46:45,715
0,375 375,540 540,830 1000,1275 1275,1425
prefix is equal to have

1808
00:46:45,715 --> 00:46:46,300
0,135 135,255 255,375 375,465 465,585
to go and do a

1809
00:46:46,300 --> 00:46:47,800
0,195 195,465 465,830 1150,1410 1410,1500
full string comparison. And so

1810
00:46:47,800 --> 00:46:48,370
0,90 90,270 270,375 375,495 495,570
I don't need to do

1811
00:46:48,370 --> 00:46:50,070
0,120 120,315 315,570 570,920 1300,1700
a full string comparison for

1812
00:46:50,510 --> 00:46:52,180
0,400 420,740 740,1040 1040,1400 1400,1670
many of these operations. And

1813
00:46:52,180 --> 00:46:53,680
0,290 400,800 820,1155 1155,1335 1335,1500
these comparison operations are getting

1814
00:46:53,680 --> 00:46:54,910
0,225 225,375 375,620 940,1170 1170,1230
used a lot. So when

1815
00:46:54,910 --> 00:46:56,500
0,180 180,480 480,660 660,1010 1300,1590
you're sorting on strings, you

1816
00:46:56,500 --> 00:46:57,400
0,290
should.|
|

1817
00:46:57,440 --> 00:47:00,100
0,395 395,790 1380,1670 1670,2110 2340,2660
Very rarely be sorting using
很少使用相等函数或比较函数和本机字符串进行排序。如果弦真的很小，你可以使用它，你知道的。但如果它是可变字符串，那么您通常想要使用一种看起来像这样的技术。

1818
00:47:00,100 --> 00:47:01,590
0,240 240,675 675,885 885,1155 1155,1490
an equality function or comparison

1819
00:47:01,610 --> 00:47:03,030
0,365 365,605 605,725 725,970 990,1420
function and the native strings.

1820
00:47:03,440 --> 00:47:04,360
0,260 260,380 380,530 530,740 740,920
You could use that if

1821
00:47:04,360 --> 00:47:05,320
0,135 135,315 315,450 450,690 690,960
the strings are really small

1822
00:47:05,320 --> 00:47:06,055
0,135 135,255 255,405 405,585 585,735
and you know that. But

1823
00:47:06,055 --> 00:47:07,650
0,90 90,330 330,605 685,1085 1165,1595
if it's variable character strings,

1824
00:47:07,760 --> 00:47:09,055
0,260 260,455 455,790 870,1160 1160,1295
then you generally want to

1825
00:47:09,055 --> 00:47:10,300
0,135 135,315 315,495 495,785 955,1245
go use a technique that

1826
00:47:10,300 --> 00:47:11,440
0,195 195,390 390,680
looks like that.|
|

1827
00:47:11,440 --> 00:47:12,595
0,195 195,390 390,600 600,855 855,1155
And this type of idea
这种获取关键字并使用后缀套装作为获得正确比较的替代方法的想法，在需要时只需查看完整的字符串，这种想法到处都在使用。通常在内部节点中具有字符串键的节拍树在本例中将具有该后缀表示，因为它们较小。有各种各样的有趣的东西，你可以玩弄串b树。所以后缀的想法，嗯，被用来到处都是。

1828
00:47:12,595 --> 00:47:13,915
0,225 225,510 510,870 870,1110 1110,1320
of taking keys and using

1829
00:47:13,915 --> 00:47:15,325
0,225 225,600 600,1005 1005,1215 1215,1410
a suffix suit as a

1830
00:47:15,325 --> 00:47:17,590
0,465 465,785 1165,1560 1560,1920 1920,2265
surrogate for getting correct comparison

1831
00:47:17,590 --> 00:47:18,535
0,240 240,435 435,675 675,825 825,945
and only having to look

1832
00:47:18,535 --> 00:47:20,455
0,135 135,285 285,525 525,875 1645,1920
at the full string if

1833
00:47:20,455 --> 00:47:21,385
0,135 135,300 300,540 540,750 750,930
you need to, is used

1834
00:47:21,385 --> 00:47:22,915
0,195 195,390 390,570 570,845 1225,1530
all over the place. Beat

1835
00:47:22,915 --> 00:47:24,900
0,240 240,510 510,845 1255,1620 1620,1985
trees that have string keys

1836
00:47:25,130 --> 00:47:26,680
0,400 540,815 815,965 965,1205 1205,1550
often in the inner nodes

1837
00:47:26,680 --> 00:47:27,505
0,120 120,255 255,390 390,555 555,825
are going to have that

1838
00:47:27,505 --> 00:47:29,575
0,390 390,1085 1465,1740 1740,1875 1875,2070
suffix representation in the case

1839
00:47:29,575 --> 00:47:30,895
0,210 210,315 315,465 465,785 1045,1320
because they are smaller. And

1840
00:47:30,895 --> 00:47:31,620
0,90 90,165 165,300 300,450 450,725
there are all kinds of

1841
00:47:31,670 --> 00:47:32,590
0,290 290,470 470,620 620,755 755,920
interesting things that you can

1842
00:47:32,590 --> 00:47:33,670
0,180 180,390 390,645 645,870 870,1080
play around with string b

1843
00:47:33,670 --> 00:47:35,160
0,315 315,555 555,705 705,1125 1125,1490
trees. So the suffix idea,

1844
00:47:35,570 --> 00:47:37,555
0,400 540,860 860,1180 1410,1700 1700,1985
um, is used shows up

1845
00:47:37,555 --> 00:47:38,580
0,270 270,545
all over.|
|

1846
00:47:39,840 --> 00:47:40,595
0,275 275,395 395,500 500,620 620,755
Now, some of you might
现在，你们中的一些人可能会想，就像我们一直在讨论的排序一样，排序和你们在b树上学到的东西之间有很多联系。我们能用b3来分拣吗？有两种情况需要考虑，答案是肯定的，你可以使用b树进行排序，但你必须小心它是哪种类型的b树。

1847
00:47:40,595 --> 00:47:41,810
0,150 150,425 625,915 915,1095 1095,1215
be thinking, as we've been

1848
00:47:41,810 --> 00:47:43,520
0,225 225,480 480,1040 1210,1515 1515,1710
talking about sorting, that there's

1849
00:47:43,520 --> 00:47:44,675
0,105 105,255 255,465 465,800 820,1155
a lot of connection between

1850
00:47:44,675 --> 00:47:45,830
0,405 405,570 570,780 780,960 960,1155
sorting and what you guys

1851
00:47:45,830 --> 00:47:47,680
0,270 270,510 510,735 735,1070 1450,1850
learned for b trees. And

1852
00:47:48,060 --> 00:47:49,175
0,260 260,455 455,740 740,950 950,1115
could we use the b

1853
00:47:49,175 --> 00:47:50,360
0,195 195,390 390,885 885,1095 1095,1185
three for sorting? And there

1854
00:47:50,360 --> 00:47:51,550
0,105 105,255 255,510 510,840 840,1190
are two cases to consider

1855
00:47:51,900 --> 00:47:52,715
0,230 230,290 290,440 440,635 635,815
and the answer is yes,

1856
00:47:52,715 --> 00:47:53,525
0,165 165,285 285,435 435,615 615,810
you can use b trees

1857
00:47:53,525 --> 00:47:54,305
0,195 195,495 495,615 615,705 705,780
for sorting, but you have

1858
00:47:54,305 --> 00:47:55,265
0,90 90,195 195,450 450,750 750,960
to be careful about what

1859
00:47:55,265 --> 00:47:56,435
0,195 195,485 565,870 870,1035 1035,1170
type of b tree it

1860
00:47:56,435 --> 00:47:57,260
0,275
is.|
|

1861
00:47:57,360 --> 00:47:58,265
0,245 245,515 515,635 635,755 755,905
So BRI come in two
因此，BRI有两种形式，聚集和非聚集聚集表示该灰色区域所示的记录ID和b树的叶级别。在这里，它们通常遵循存储在磁盘中的页面的记录ID。所以如果我有一棵簇状的b树，那么我就可以排序了。

1862
00:47:58,265 --> 00:48:00,965
0,275 565,1175 1195,1485 1485,2225 2245,2700
form, clustered and unclustered clustered

1863
00:48:00,965 --> 00:48:02,630
0,275 715,990 990,1185 1185,1560 1560,1665
means the record IDs and

1864
00:48:02,630 --> 00:48:03,485
0,135 135,330 330,555 555,720 720,855
the leaf level of the

1865
00:48:03,485 --> 00:48:04,985
0,180 180,485 685,1020 1020,1245 1245,1500
b tree shown by this

1866
00:48:04,985 --> 00:48:06,470
0,285 285,525 525,750 750,1055 1225,1485
gray area. Over here they

1867
00:48:06,470 --> 00:48:08,180
0,165 165,470 550,950 1240,1515 1515,1710
will generally follow the record

1868
00:48:08,180 --> 00:48:10,220
0,320 670,1070 1090,1395 1395,1700 1780,2040
ID of the pages that

1869
00:48:10,220 --> 00:48:11,350
0,135 135,375 375,540 540,660 660,1130
are stored in the disk.

1870
00:48:11,400 --> 00:48:12,080
0,230 230,305 305,410 410,515 515,680
So if I have a

1871
00:48:12,080 --> 00:48:14,255
0,435 435,675 675,1010 1240,1640 1900,2175
clustered b tree, then I

1872
00:48:14,255 --> 00:48:15,520
0,135 135,330 330,665
could just sort.|
|

1873
00:48:15,520 --> 00:48:16,760
0,260
A.|
一个。|

1874
00:48:16,800 --> 00:48:18,260
0,400 630,1030 1050,1280 1280,1355 1355,1460
The keys. So if A
钥匙。因此，如果A、B、3是基于学生ID构建的，我们之前一直使用的例子，某个人和查询是按学生ID排序。

1875
00:48:18,260 --> 00:48:18,980
0,150 150,270 270,390 390,540 540,720
B three is built on

1876
00:48:18,980 --> 00:48:20,480
0,240 240,560 700,990 990,1230 1230,1500
student ID, the example we've

1877
00:48:20,480 --> 00:48:21,970
0,90 90,315 315,680 910,1200 1200,1490
been using before, and someone

1878
00:48:21,990 --> 00:48:23,360
0,275 275,425 425,665 665,1000 1020,1370
and the query says order

1879
00:48:23,360 --> 00:48:24,900
0,255 255,495 495,830
by student ID.|
|

1880
00:48:24,900 --> 00:48:26,235
0,270 270,360 360,495 495,770 1060,1335
Don't need to sort, you
不需要排序，你可以只去看看从最左边的叶节点开始，去追赶。

1881
00:48:26,235 --> 00:48:27,770
0,150 150,345 345,665 985,1260 1260,1535
could just go look at

1882
00:48:27,790 --> 00:48:29,535
0,290 290,440 440,700 930,1490 1490,1745
start with the leftmost leaf

1883
00:48:29,535 --> 00:48:31,920
0,455 715,1035 1035,1290 1290,1625
node, go chase the.|
|

1884
00:48:32,870 --> 00:48:34,405
0,400 660,935 935,1100 1100,1295 1295,1535
Records in that leaf node
从左到右，从左到右拉起指针，有效地得到排序的输出，对吧，因为键已经排序在前三个记录中的最低级别。这些记录是聚集在一起的。所以这里的前三个键都属于第一页、第一页和第一页，所以每个页面只能访问一次。基本上，在一次文件扫描和最低级别的b树扫描中，您将完成排序，这将比外部排序合并更快。

1885
00:48:34,405 --> 00:48:35,665
0,135 135,330 330,495 495,755 1015,1260
from left to right, pull

1886
00:48:35,665 --> 00:48:36,985
0,135 135,315 315,810 810,1125 1125,1320
up the pointer andeff effectively

1887
00:48:36,985 --> 00:48:38,305
0,255 255,360 360,510 510,785 985,1320
you're going to get a

1888
00:48:38,305 --> 00:48:39,865
0,465 465,795 795,1065 1065,1275 1275,1560
sorted output, right, because the

1889
00:48:39,865 --> 00:48:40,900
0,240 240,405 405,630 630,930 930,1035
key is already sorted at

1890
00:48:40,900 --> 00:48:42,115
0,260 400,735 735,945 945,1095 1095,1215
the lowest level of the

1891
00:48:42,115 --> 00:48:43,240
0,135 135,420 420,735 735,945 945,1125
b three just fr g

1892
00:48:43,240 --> 00:48:44,605
0,165 165,440 640,900 900,1110 1110,1365
the records. The records are

1893
00:48:44,605 --> 00:48:46,765
0,545 625,1025 1225,1530 1530,1835 1855,2160
clustered. So the first three

1894
00:48:46,765 --> 00:48:48,130
0,195 195,390 390,695 715,1080 1080,1365
keys over here all belong

1895
00:48:48,130 --> 00:48:50,020
0,270 270,585 585,950 1420,1725 1725,1890
to page one, page one

1896
00:48:50,020 --> 00:48:51,235
0,135 135,410 490,810 810,990 990,1215
and one, and so you're

1897
00:48:51,235 --> 00:48:52,710
0,245 295,690 690,900 900,1155 1155,1475
only accessing each page once.

1898
00:48:52,760 --> 00:48:54,460
0,400 750,995 995,1115 1115,1355 1355,1700
Basically, in a single scan

1899
00:48:54,460 --> 00:48:55,840
0,270 270,435 435,710 820,1155 1155,1380
of the file and a

1900
00:48:55,840 --> 00:48:57,430
0,290 370,675 675,915 915,1250 1300,1590
scan of the lowest level

1901
00:48:57,430 --> 00:48:58,540
0,150 150,270 270,435 435,740 790,1110
of the b tree, you're

1902
00:48:58,540 --> 00:48:59,365
0,90 90,210 210,390 390,630 630,825
going to get sort done,

1903
00:48:59,365 --> 00:48:59,995
0,135 135,270 270,390 390,480 480,630
which is going to be

1904
00:48:59,995 --> 00:49:01,600
0,305 595,870 870,1050 1050,1320 1320,1605
faster than the external sort

1905
00:49:01,600 --> 00:49:02,300
0,440
merge.|
|

1906
00:49:02,670 --> 00:49:03,935
0,245 245,335 335,500 500,635 635,1265
However, if it's an unclustered
然而，如果它是一棵无簇的b树，那么使用它可能不是一个好主意。嗯，除非你在b树上也有一个范围选择谓词。假设您刚才说的是按学生ID排序。b树构建在学生ID上，它是叶级别的。那么使用无簇b3就不是一个好主意，因为正如你在这里看到的，你要去追逐密钥。你会拿到这一页。这里的第二个密钥转到第二个页面，稍后您将引用该页面。所以它是随机的IO，在这种情况下，不仅是随机的IO，而且还会多次重新访问同一页面。这将是相当昂贵的。

1907
00:49:03,935 --> 00:49:04,940
0,180 180,345 345,525 525,765 765,1005
b tree, it's probably a

1908
00:49:04,940 --> 00:49:06,010
0,210 210,450 450,600 600,765 765,1070
bad idea to use it.

1909
00:49:06,240 --> 00:49:07,985
0,400 630,950 950,1265 1265,1490 1490,1745
Um, unless you've got a

1910
00:49:07,985 --> 00:49:09,575
0,300 300,645 645,1175 1225,1470 1470,1590
range selection predicate also on

1911
00:49:09,575 --> 00:49:10,660
0,135 135,315 315,540 540,765 765,1085
the b tree. So assume

1912
00:49:10,800 --> 00:49:12,110
0,335 335,470 470,695 695,1010 1010,1310
you're just saying order by

1913
00:49:12,110 --> 00:49:13,550
0,255 255,590 880,1140 1140,1305 1305,1440
student ID. The b tree

1914
00:49:13,550 --> 00:49:14,650
0,120 120,285 285,495 495,765 765,1100
is built on student ID

1915
00:49:14,910 --> 00:49:16,000
0,290 290,485 485,590 590,770 770,1090
and it's the leaf level.

1916
00:49:16,410 --> 00:49:17,645
0,260 260,470 470,650 650,965 965,1235
Then it's a bad idea

1917
00:49:17,645 --> 00:49:18,875
0,135 135,285 285,465 465,1050 1050,1230
to use an unclustered b

1918
00:49:18,875 --> 00:49:19,715
0,240 240,420 420,540 540,675 675,840
three because as you can

1919
00:49:19,715 --> 00:49:20,885
0,195 195,485 715,990 990,1050 1050,1170
see here you're going to

1920
00:49:20,885 --> 00:49:21,815
0,195 195,390 390,540 540,720 720,930
chase the key down. You're

1921
00:49:21,815 --> 00:49:22,780
0,45 45,150 150,390 390,645 645,965
going to fetch this page.

1922
00:49:22,950 --> 00:49:24,455
0,275 275,500 500,740 740,1030 1200,1505
The second key here goes

1923
00:49:24,455 --> 00:49:25,715
0,135 135,255 255,510 510,875 985,1260
to a second page and

1924
00:49:25,715 --> 00:49:26,540
0,195 195,390 390,585 585,675 675,825
later on you're going to

1925
00:49:26,540 --> 00:49:27,500
0,180 180,420 420,645 645,840 840,960
ref fetch this page. So

1926
00:49:27,500 --> 00:49:29,080
0,120 120,300 300,615 615,1160 1180,1580
it's at random ios and

1927
00:49:29,190 --> 00:49:30,350
0,275 275,455 455,710 710,950 950,1160
in this case not just

1928
00:49:30,350 --> 00:49:31,970
0,270 270,645 645,885 885,1220 1240,1620
random ios but also {re-accessing

1929
00:49:31,970 --> 00:49:33,160
0,375 375,510 510,660 660,870 870,1190
-} the same page multiple

1930
00:49:33,180 --> 00:49:34,385
0,400 690,935 935,1025 1025,1115 1115,1205
times. This is going to

1931
00:49:34,385 --> 00:49:35,760
0,135 135,405 405,785
be pretty expensive.|
|

1932
00:49:35,920 --> 00:49:37,230
0,320 320,620 620,950 950,1160 1160,1310
You are going to be
在进行了外部合并之后，您的情况会更好。

1933
00:49:37,230 --> 00:49:38,550
0,225 225,540 540,855 855,1065 1065,1320
better off having done that

1934
00:49:38,550 --> 00:49:40,200
0,345 345,765 765,1040
external merge on.|
|

1935
00:49:40,430 --> 00:49:41,155
0,230 230,305 305,410 410,560 560,725
So if you have to
所以如果你必须排序，你在排序关键字上有一个簇状的b树，你可以使用它。否则，如果它是无簇的b树，则可以避免这种情况。这些是优化器在选择正确的算法或访问选项卡时可以做出的决定类型。

1936
00:49:41,155 --> 00:49:42,595
0,275 685,915 915,990 990,1095 1095,1440
sort, you have a clustered

1937
00:49:42,595 --> 00:49:43,420
0,165 165,300 300,420 420,585 585,825
b tree on the sort

1938
00:49:43,420 --> 00:49:44,880
0,350 520,780 780,915 915,1125 1125,1460
key, you can use that.

1939
00:49:45,260 --> 00:49:47,050
0,400 810,1055 1055,1205 1205,1265 1265,1790
Otherwise, if it's an unclustered

1940
00:49:47,050 --> 00:49:47,890
0,195 195,345 345,450 450,615 615,840
b tree, you can avoid

1941
00:49:47,890 --> 00:49:48,610
0,210 210,360 360,480 480,600 600,720
that. And these are the

1942
00:49:48,610 --> 00:49:49,840
0,135 135,360 360,690 690,960 960,1230
types of decisions that an

1943
00:49:49,840 --> 00:49:51,310
0,510 510,690 690,980 1060,1350 1350,1470
optimizer can make as they

1944
00:49:51,310 --> 00:49:52,855
0,120 120,410 550,825 825,1100 1120,1545
are picking the right algorithm

1945
00:49:52,855 --> 00:49:54,300
0,105 105,345 345,615 615,905
or the access tab.|
|

1946
00:49:55,870 --> 00:49:58,160
0,290 290,580 600,1180 1260,1870 1890,2290
All right, switching gears from
好的，从排序操作符切换到聚合操作符。

1947
00:49:58,630 --> 00:50:00,150
0,320 320,640 720,1120 1140,1385 1385,1520
the sort operator to the

1948
00:50:00,150 --> 00:50:01,960
0,590 670,1070
aggregation operator.|
|

1949
00:50:01,960 --> 00:50:03,490
0,320 580,900 900,1140 1140,1365 1365,1530
Ah, we can start to
啊，我们现在可以开始研究它的不同算法，也开始考虑散列。

1950
00:50:03,490 --> 00:50:05,110
0,165 165,345 345,600 600,980 1150,1620
now look at different algorithms

1951
00:50:05,110 --> 00:50:06,490
0,195 195,435 435,800 940,1215 1215,1380
for it and also start

1952
00:50:06,490 --> 00:50:08,180
0,150 150,330 330,555 555,1130
to think about hashing.|
|

1953
00:50:08,370 --> 00:50:11,780
0,395 395,1090 1470,1870 2070,2470 3180,3410
So aggregation basically involves, yeah,
所以聚合基本上涉及到，是的，你以前见过聚合。所以让我们用一个例子来看看它。下面是一个查询，在这个包含学生ID、列ID和年级的注册表上，我们只查找成绩为b和c的学生。正如我昨天在课堂上开玩笑说的那样，显然这不是一个你会在CMU中运行的查询，因为它可能是空的。每个人都得了a，我只是开玩笑的，啊。

1954
00:50:11,780 --> 00:50:12,905
0,75 75,270 270,390 390,825 825,1125
and you've seen aggregation before.

1955
00:50:12,905 --> 00:50:13,670
0,210 210,375 375,495 495,645 645,765
So let's just go look

1956
00:50:13,670 --> 00:50:14,530
0,120 120,255 255,375 375,540 540,860
at it with an example.

1957
00:50:15,030 --> 00:50:16,775
0,400 600,950 950,1040 1040,1330 1440,1745
So here's a query in

1958
00:50:16,775 --> 00:50:18,245
0,255 255,495 495,675 675,1185 1185,1470
which on this enrolled table

1959
00:50:18,245 --> 00:50:19,505
0,255 255,435 435,675 675,975 975,1260
which has student ID, column

1960
00:50:19,505 --> 00:50:21,310
0,240 240,495 495,815 1255,1530 1530,1805
ID and grade, we are

1961
00:50:22,050 --> 00:50:23,680
0,365 365,650 650,965 965,1295 1295,1630
looking for only those students

1962
00:50:23,700 --> 00:50:25,265
0,400 420,820 1080,1340 1340,1445 1445,1565
that are, that have a

1963
00:50:25,265 --> 00:50:26,480
0,150 150,315 315,480 480,965 985,1215
grade of b andc. And

1964
00:50:26,480 --> 00:50:27,350
0,90 90,240 240,540 540,720 720,870
as I joked about this

1965
00:50:27,350 --> 00:50:29,690
0,195 195,450 450,770 1150,1550 2050,2340
in class yesterday, obviously this

1966
00:50:29,690 --> 00:50:30,725
0,270 270,525 525,660 660,870 870,1035
is not a query you

1967
00:50:30,725 --> 00:50:31,970
0,120 120,255 255,450 450,975 975,1245
would run in cmu because

1968
00:50:31,970 --> 00:50:33,100
0,300 300,540 540,675 675,840 840,1130
probably it comes out empty.

1969
00:50:33,240 --> 00:50:34,610
0,275 275,440 440,605 605,880 960,1370
Everyone gets an a, I'm

1970
00:50:34,610 --> 00:50:36,480
0,150 150,560 820,1220
just kidding, ah.|
|

1971
00:50:36,480 --> 00:50:37,580
0,90 90,285 285,435 435,585 585,1100
But here we are selecting
但在这里，我们选择符合此条件的记录，按列ID对其进行排序，然后选择此项。所以这是一个非常简单的集合。

1972
00:50:38,020 --> 00:50:40,070
0,395 395,710 710,1030 1080,1385 1385,2050
records that fit this criteria,

1973
00:50:40,420 --> 00:50:42,315
0,515 515,710 710,1030 1350,1670 1670,1895
ordering it by the column

1974
00:50:42,315 --> 00:50:45,140
0,305 1285,1605 1605,1925 2095,2550 2550,2825
ID and then selecting this.

1975
00:50:45,250 --> 00:50:46,125
0,230 230,350 350,455 455,650 650,875
So it's a very simple

1976
00:50:46,125 --> 00:50:47,260
0,635
aggregate.|
|

1977
00:50:47,260 --> 00:50:48,445
0,165 165,360 360,630 630,840 840,1185
We will bring group buys
我们将在稍后引入团购。DISTINCT COUNT ID是一个聚合，我们将看到如何使用基于排序的方法来实现这一点，然后我们还将看到基于散列的版本。

1978
00:50:48,445 --> 00:50:49,470
0,255 255,450 450,555 555,720 720,1025
in in a little bit.

1979
00:50:49,790 --> 00:50:51,070
0,350 350,590 590,875 875,1145 1145,1280
Distinct count ID is an

1980
00:50:51,070 --> 00:50:52,420
0,590 670,945 945,1125 1125,1230 1230,1350
aggregate and we'll see how

1981
00:50:52,420 --> 00:50:53,140
0,120 120,255 255,405 405,570 570,720
we can do that with

1982
00:50:53,140 --> 00:50:54,580
0,135 135,330 330,570 570,890 1180,1440
a sort based method and

1983
00:50:54,580 --> 00:50:55,435
0,210 210,375 375,510 510,630 630,855
we'll also see the hash

1984
00:50:55,435 --> 00:50:57,160
0,225 225,555 555,900 900,1265
based version after that.|
|

1985
00:50:57,490 --> 00:50:58,410
0,260 260,425 425,605 605,800 800,920
So first thing we'll do
所以我们在查询树中要做的第一件事是，我不会像您之前看到的那样绘制那棵树，但这是树的最底层。您在该表上应用选择，并且只保留b和cs记录。

1986
00:50:58,410 --> 00:50:59,310
0,150 150,285 285,540 540,750 750,900
in the query tree, I'm

1987
00:50:59,310 --> 00:51:00,120
0,135 135,285 285,420 420,600 600,810
not going to draw that

1988
00:51:00,120 --> 00:51:01,520
0,320 490,765 765,930 930,1110 1110,1400
tree as you saw before,

1989
00:51:01,540 --> 00:51:02,535
0,290 290,440 440,575 575,740 740,995
but this is the bottom

1990
00:51:02,535 --> 00:51:03,705
0,270 270,435 435,585 585,870 870,1170
level of the tree. You

1991
00:51:03,705 --> 00:51:04,755
0,210 210,435 435,690 690,885 885,1050
apply the selection on this

1992
00:51:04,755 --> 00:51:06,345
0,305 565,840 840,1035 1035,1305 1305,1590
table and you keep just

1993
00:51:06,345 --> 00:51:07,425
0,210 210,480 480,735 735,870 870,1080
the records that are bs

1994
00:51:07,425 --> 00:51:08,520
0,150 150,575
and CS.|
|

1995
00:51:08,690 --> 00:51:09,925
0,400 570,845 845,980 980,1085 1085,1235
Now you go to that
现在转到该树中的第二个运算符，它将投影和删除列，只保留列ID。所以只有这一列，这就是您在查询树中的第二个运算符产生的结果，然后我们进行了排序，您可以使用外部排序合并。如果这个文件真的很大，我知道这是一个很小的例子，四条记录，但想象一下是400万条。如果缓冲池中没有足够的空间，您可以使用外部内存对其进行排序。如果是一个小文件，您将使用内存排序对其进行排序。无论如何，您都会得到排序后的输出，现在您所能做的就是消除重复项，只需从上到下扫描此文件，并仅输出值。

1996
00:51:09,925 --> 00:51:11,065
0,305 355,660 660,810 810,960 960,1140
second operator in that tree,

1997
00:51:11,065 --> 00:51:12,610
0,150 150,330 330,600 600,965 1195,1545
which is to project and

1998
00:51:12,610 --> 00:51:13,795
0,240 240,405 405,720 720,975 975,1185
remove the columns, keeping just

1999
00:51:13,795 --> 00:51:14,845
0,150 150,360 360,660 660,885 885,1050
the column ID. So just

2000
00:51:14,845 --> 00:51:16,195
0,225 225,545 715,1050 1050,1155 1155,1350
this column, that's what you

2001
00:51:16,195 --> 00:51:17,520
0,240 240,420 420,600 600,905 925,1325
produce at that second operator

2002
00:51:17,840 --> 00:51:19,555
0,290 290,500 500,800 800,1150 1440,1715
in that query tree and

2003
00:51:19,555 --> 00:51:21,250
0,165 165,375 375,965 1255,1545 1545,1695
then we sorted and you

2004
00:51:21,250 --> 00:51:22,525
0,120 120,360 360,705 705,990 990,1275
can use external sort merge.

2005
00:51:22,525 --> 00:51:23,515
0,105 105,270 270,495 495,735 735,990
If this file were really

2006
00:51:23,515 --> 00:51:24,490
0,335 385,660 660,765 765,870 870,975
large, I know it's a

2007
00:51:24,490 --> 00:51:25,675
0,225 225,495 495,750 750,945 945,1185
small example here, four records,

2008
00:51:25,675 --> 00:51:26,725
0,270 270,495 495,690 690,855 855,1050
but imagine it were 4

2009
00:51:26,725 --> 00:51:28,255
0,305 655,915 915,1080 1080,1305 1305,1530
million. You would sort that

2010
00:51:28,255 --> 00:51:29,530
0,305 325,660 660,915 915,1095 1095,1275
using external memory if you

2011
00:51:29,530 --> 00:51:31,000
0,315 315,495 495,830 880,1245 1245,1470
didn't have enough space in

2012
00:51:31,000 --> 00:51:32,155
0,105 105,405 405,680 790,1005 1005,1155
the buffer pool. If it's

2013
00:51:32,155 --> 00:51:33,040
0,105 105,300 300,495 495,735 735,885
a small file, you'll sort

2014
00:51:33,040 --> 00:51:34,410
0,165 165,360 360,630 630,975 975,1370
it using a memory sort.

2015
00:51:34,670 --> 00:51:36,030
0,380 380,620 620,755 755,920 920,1360
Regardless, you get a sorted

2016
00:51:36,050 --> 00:51:37,300
0,400 540,815 815,980 980,1130 1130,1250
output and now what you

2017
00:51:37,300 --> 00:51:38,680
0,165 165,470 580,855 855,1020 1020,1380
can do is to eliminate

2018
00:51:38,680 --> 00:51:40,675
0,195 195,690 690,1010 1300,1680 1680,1995
the duplicates, just scan over

2019
00:51:40,675 --> 00:51:41,845
0,240 240,525 525,795 795,990 990,1170
this file from top to

2020
00:51:41,845 --> 00:51:43,630
0,275 535,840 840,1145 1375,1650 1650,1785
bottom and only output the

2021
00:51:43,630 --> 00:51:44,480
0,260
values.|
|

2022
00:51:44,480 --> 00:51:45,575
0,345 345,615 615,765 765,930 930,1095
Once that you see, so
一旦你看到了，那么这里我们将输出4，4，5，第一个记录。跳过第二个，因为它是重复的。副本将始终紧挨着彼此。所以在任何时间点，你只要记住输出这个值，记住那个值，转到下一个记录。如果它是相同的值，则跳过。

2023
00:51:45,575 --> 00:51:47,225
0,165 165,480 480,845 1015,1365 1365,1650
here we'll output four, four,

2024
00:51:47,225 --> 00:51:48,800
0,255 255,435 435,615 615,935 1285,1575
five, the first record. Skip

2025
00:51:48,800 --> 00:51:50,150
0,150 150,315 315,555 555,920 1090,1350
over the second one because

2026
00:51:50,150 --> 00:51:51,635
0,195 195,645 645,780 780,1230 1230,1485
it's duplicate. The duplicates will

2027
00:51:51,635 --> 00:51:52,535
0,255 255,420 420,615 615,780 780,900
always be next to each

2028
00:51:52,535 --> 00:51:53,645
0,275 505,735 735,810 810,945 945,1110
other. So at any point

2029
00:51:53,645 --> 00:51:54,550
0,135 135,255 255,375 375,570 570,905
in time you just remember

2030
00:51:54,960 --> 00:51:56,570
0,275 275,425 425,700 1080,1400 1400,1610
output this value, remember that

2031
00:51:56,570 --> 00:51:57,815
0,290 550,825 825,945 945,1050 1050,1245
value, go to the next

2032
00:51:57,815 --> 00:51:58,670
0,270 270,465 465,615 615,705 705,855
record. If it's the same

2033
00:51:58,670 --> 00:52:00,080
0,290 370,645 645,890
value, skip over.|
|

2034
00:52:01,080 --> 00:52:02,405
0,260 260,365 365,575 575,1100 1100,1325
Just a little optimization, you
只要一点优化，你就可以跳过这些东西，如果你回到我们很多张幻灯片之前的地方，这里有个合并树，你可以跳过这个想法。

2035
00:52:02,405 --> 00:52:04,090
0,150 150,425 505,885 885,1265 1285,1685
can do this idea of

2036
00:52:04,380 --> 00:52:06,770
0,485 485,820 1500,1805 1805,2075 2075,2390
skipping stuff, of having dropped

2037
00:52:06,770 --> 00:52:08,045
0,350 490,750 750,885 885,1035 1035,1275
this if you go back

2038
00:52:08,045 --> 00:52:09,710
0,360 360,645 645,810 810,1085 1285,1665
to where we were many

2039
00:52:09,710 --> 00:52:11,345
0,345 345,630 630,840 840,1110 1110,1635
slides ago with that merge

2040
00:52:11,345 --> 00:52:13,200
0,300 300,555 555,765 765,1085
tree up over here.|
|

2041
00:52:13,200 --> 00:52:14,340
0,150 150,330 330,650 730,1005 1005,1140
You could imagine that you
您可以想象一下，您可以将其中的一些优化合并到这个级别。想象一下，你必须在这里的键上做一个截然不同的操作，想象这里有一个三，而不是这两个。

2042
00:52:14,340 --> 00:52:15,360
0,195 195,450 450,705 705,900 900,1020
could fold in some of

2043
00:52:15,360 --> 00:52:16,880
0,225 225,780 780,1020 1020,1200 1200,1520
that optimization to this level.

2044
00:52:17,290 --> 00:52:18,435
0,350 350,635 635,875 875,1040 1040,1145
Imagine you had to do

2045
00:52:18,435 --> 00:52:20,295
0,240 240,635 715,1115 1345,1635 1635,1860
a distinct on the keys

2046
00:52:20,295 --> 00:52:21,825
0,335 595,900 900,1200 1200,1425 1425,1530
here and imagine instead of

2047
00:52:21,825 --> 00:52:22,650
0,195 195,405 405,540 540,645 645,825
this two, there was a

2048
00:52:22,650 --> 00:52:23,800
0,225 225,530
three here.|
|

2049
00:52:24,030 --> 00:52:25,775
0,275 275,395 395,545 545,850 1470,1745
And there was another what
当你做这个模型的时候，还有一个你可以做的事情，你可以只写一次这三个。您可以早点删除这三个，因为您只是在寻找DISTINCT。因此，如果您正在进行排序以进行DISTINCT，您实际上可以更改核心排序算法，以在更早的时候进行DISTINCT，使用基本上相同的想法，当您有DISTINCT时，您只需要保留该记录的一个副本，您可以推动我们在本幻灯片中看到的优化，我们跳过了第二个重复值。

2050
00:52:25,775 --> 00:52:26,540
0,135 135,270 270,435 435,600 600,765
you could do at that

2051
00:52:26,540 --> 00:52:27,260
0,165 165,285 285,435 435,555 555,720
point when you're doing this

2052
00:52:27,260 --> 00:52:28,265
0,290 370,615 615,705 705,810 810,1005
mod, you could have written

2053
00:52:28,265 --> 00:52:29,240
0,225 225,375 375,570 570,810 810,975
the three only once. You

2054
00:52:29,240 --> 00:52:30,245
0,105 105,270 270,510 510,765 765,1005
can have dropped that three

2055
00:52:30,245 --> 00:52:31,610
0,305 595,870 870,1050 1050,1170 1170,1365
earlier because you're just looking

2056
00:52:31,610 --> 00:52:33,320
0,285 285,650 880,1110 1110,1335 1335,1710
for distinct. So if new

2057
00:52:33,320 --> 00:52:34,730
0,240 240,390 390,675 675,1245 1245,1410
you were doing sorting to

2058
00:52:34,730 --> 00:52:36,440
0,260 280,680 760,1020 1020,1280 1390,1710
do distinct, you can actually

2059
00:52:36,440 --> 00:52:37,630
0,225 225,450 450,645 645,855 855,1190
go change the core sort

2060
00:52:37,770 --> 00:52:39,440
0,640 690,950 950,1085 1085,1355 1355,1670
algorithm to do that distinct

2061
00:52:39,440 --> 00:52:41,420
0,320 610,1010 1030,1425 1425,1710 1710,1980
earlier using essentially that same

2062
00:52:41,420 --> 00:52:42,665
0,375 375,690 690,885 885,1005 1005,1245
ideas that when you have

2063
00:52:42,665 --> 00:52:43,985
0,395 595,870 870,1020 1020,1170 1170,1320
distinct, you just need to

2064
00:52:43,985 --> 00:52:45,515
0,195 195,465 465,815 955,1275 1275,1530
keep one copy of that

2065
00:52:45,515 --> 00:52:47,135
0,335 625,900 900,1035 1035,1260 1260,1620
record and you could push

2066
00:52:47,135 --> 00:52:49,775
0,395 1255,1835 2005,2280 2280,2430 2430,2640
that optimization that we just

2067
00:52:49,775 --> 00:52:51,640
0,335 505,870 870,1170 1170,1485 1485,1865
saw here on this slide

2068
00:52:51,840 --> 00:52:53,390
0,260 260,440 440,665 665,940 1200,1550
where we skipped over that

2069
00:52:53,390 --> 00:52:54,980
0,330 330,840 840,1100
second duplicate value.|
|

2070
00:52:54,980 --> 00:52:56,525
0,260 370,720 720,945 945,1200 1200,1545
Up ahead in that operator
就在操作员树的前面。现在，您可以看到我是否可以在操作符中解压SQL查询的完整语义，也就是我们正在研究的外部排序合并操作符，我实际上可以在查询的其余部分的上下文中修改该操作符，并且做得更好。

2071
00:52:56,525 --> 00:52:57,845
0,365 655,900 900,1020 1020,1155 1155,1320
tree. So now you can

2072
00:52:57,845 --> 00:52:59,240
0,305 385,645 645,765 765,915 915,1395
see if I can unpack

2073
00:52:59,240 --> 00:53:00,320
0,195 195,360 360,795 795,930 930,1080
the full semantics of the

2074
00:53:00,320 --> 00:53:02,285
0,360 360,680 1120,1425 1425,1680 1680,1965
sql query in the operator,

2075
00:53:02,285 --> 00:53:04,360
0,335 415,815 955,1335 1335,1620 1620,2075
that same external sort merge

2076
00:53:04,590 --> 00:53:05,435
0,305 305,470 470,560 560,650 650,845
operator that we are looking

2077
00:53:05,435 --> 00:53:07,235
0,335 355,630 630,905 955,1290 1290,1800
at, I can actually modify

2078
00:53:07,235 --> 00:53:08,555
0,240 240,555 555,810 810,1020 1020,1320
that operator within the context

2079
00:53:08,555 --> 00:53:09,365
0,270 270,390 390,540 540,705 705,810
of the rest of the

2080
00:53:09,365 --> 00:53:10,780
0,275 475,765 765,915 915,1095 1095,1415
query and do even better.|
|

2081
00:53:12,180 --> 00:53:13,100
0,400
Okay.|
好吧。|

2082
00:53:13,280 --> 00:53:15,415
0,260 260,380 380,620 620,1000 1770,2135
Now, as I started earlier
现在，正如我在前面开始告诉您的，您将看到基于排序的方法和基于散列的方法之间的这种二元性，就像发生的兄弟贿赂一样，我们现在可以开始解开它，并查看聚合和基于散列的聚合。

2083
00:53:15,415 --> 00:53:16,740
0,255 255,435 435,645 645,945 945,1325
on and told you that

2084
00:53:16,850 --> 00:53:18,835
0,350 350,470 470,620 620,1360 1650,1985
you'll see this duality between

2085
00:53:18,835 --> 00:53:20,110
0,255 255,480 480,765 765,1035 1035,1275
sort based methods and hash

2086
00:53:20,110 --> 00:53:21,340
0,210 210,530 550,855 855,1050 1050,1230
based methods, and like the

2087
00:53:21,340 --> 00:53:23,665
0,390 390,1010 1540,1815 1815,2070 2070,2325
sibling bribery that happens, we

2088
00:53:23,665 --> 00:53:25,690
0,240 240,540 540,810 810,1145 1495,2025
now can start to unpack

2089
00:53:25,690 --> 00:53:27,810
0,320 400,720 720,975 975,1310 1420,2120
that and look at aggregation

2090
00:53:28,400 --> 00:53:29,485
0,335 335,545 545,680 680,830 830,1085
and look at the hash

2091
00:53:29,485 --> 00:53:30,820
0,180 180,755
based aggregation.|
|

2092
00:53:30,890 --> 00:53:32,485
0,400 540,905 905,1160 1160,1430 1430,1595
So imagine we don't need
想象一下，我们不需要对数据进行排序，因为我们有一个GROUP BY或AND DISTINCT。因此，这打开了使用基于散列的聚合的机会。在这种情况下，散列几乎总是一个更好的替代方案，因为它可能不是更好的选择，如果我有一个构建在GROUP BY COLUMN上的B树，因为我可以，而且它是一个集群B树，我可以使用它来获得更快的操作。同样，优化器会考虑这一点。

2093
00:53:32,485 --> 00:53:33,540
0,165 165,390 390,615 615,765 765,1055
the data to be ordered

2094
00:53:33,800 --> 00:53:34,540
0,275 275,380 380,455 455,575 575,740
because we have a group

2095
00:53:34,540 --> 00:53:36,150
0,210 210,405 405,645 645,1010 1210,1610
by or and distinct. So

2096
00:53:36,260 --> 00:53:37,900
0,365 365,605 605,785 785,1090 1290,1640
that opens up the chance

2097
00:53:37,900 --> 00:53:38,770
0,210 210,330 330,465 465,615 615,870
to go use a hash

2098
00:53:38,770 --> 00:53:41,220
0,180 180,740 1210,1610 1690,2175 2175,2450
based aggregation. And hashing is

2099
00:53:41,600 --> 00:53:42,715
0,400 510,800 800,950 950,1040 1040,1115
nearly always going to be

2100
00:53:42,715 --> 00:53:44,065
0,90 90,335 355,755 925,1200 1200,1350
a better alternative in this

2101
00:53:44,065 --> 00:53:46,210
0,275 1375,1650 1650,1785 1785,1935 1935,2145
scenario when it may not

2102
00:53:46,210 --> 00:53:47,365
0,165 165,270 270,530 550,915 915,1155
be a better option is

2103
00:53:47,365 --> 00:53:48,115
0,135 135,255 255,405 405,585 585,750
that if I have A

2104
00:53:48,115 --> 00:53:48,865
0,180 180,345 345,465 465,600 600,750
B tree that is built

2105
00:53:48,865 --> 00:53:49,780
0,135 135,270 270,435 435,630 630,915
on the group by column,

2106
00:53:49,780 --> 00:53:50,710
0,240 240,375 375,600 600,795 795,930
because I could, and it's

2107
00:53:50,710 --> 00:53:51,625
0,90 90,435 435,615 615,780 780,915
a clustered b tree, I

2108
00:53:51,625 --> 00:53:53,200
0,225 225,555 555,840 840,1145 1255,1575
could potentially use that and

2109
00:53:53,200 --> 00:53:55,360
0,285 285,525 525,800 1270,1670 1780,2160
get a faster operation. And

2110
00:53:55,360 --> 00:53:56,755
0,255 255,465 465,915 915,1125 1125,1395
again, an optimizer will consider

2111
00:53:56,755 --> 00:53:57,440
0,305
that.|
|

2112
00:53:57,720 --> 00:53:58,760
0,335 335,515 515,620 620,875 875,1040
So in a hash based
因此，在基于散列的聚合中，我将通过一个示例来说明这一点。这将是两个阶段，分而治之。在分割阶段，我们将拆分文件，将其分割为两个，啊，两个或更多个部分。然后我们希望每一块都被单独处理，以得到最终的答案。我们希望每个分区都足够小，以便我们可以在内存中使用它。文件太大，内存无法容纳，请将其拆分成小部分，以便每个小部分都可以在内存中处理。因此，拆分是第一阶段的重新散列，它正在对每一个阶段进行处理。在本例中，分区将是您在内存中工作第二阶段。

2113
00:53:58,760 --> 00:53:59,840
0,510 510,750 750,840 840,945 945,1080
aggregate, I'm just going to

2114
00:53:59,840 --> 00:54:00,770
0,270 270,510 510,645 645,765 765,930
go through this with an

2115
00:54:00,770 --> 00:54:02,000
0,320 580,915 915,1020 1020,1110 1110,1230
example. It's going to be

2116
00:54:02,000 --> 00:54:03,490
0,165 165,585 585,795 795,975 975,1490
two phases, divide and conquer.

2117
00:54:03,750 --> 00:54:04,820
0,260 260,410 410,620 620,845 845,1070
In the divide phase we're

2118
00:54:04,820 --> 00:54:05,975
0,120 120,410 610,885 885,1020 1020,1155
going to break up the

2119
00:54:05,975 --> 00:54:07,340
0,210 210,615 615,795 795,1020 1020,1365
file, partition it into two,

2120
00:54:07,340 --> 00:54:08,380
0,300 300,480 480,600 600,750 750,1040
ah, two or more pieces.

2121
00:54:08,790 --> 00:54:09,920
0,290 290,530 530,740 740,905 905,1130
And then we want each

2122
00:54:09,920 --> 00:54:11,705
0,240 240,420 420,675 675,1335 1335,1785
piece to be processed individually

2123
00:54:11,705 --> 00:54:12,650
0,150 150,270 270,420 420,630 630,945
to get the final answer.

2124
00:54:12,650 --> 00:54:13,460
0,240 240,345 345,495 495,675 675,810
And we want each of

2125
00:54:13,460 --> 00:54:14,555
0,150 150,540 540,735 735,870 870,1095
those partitions to be small

2126
00:54:14,555 --> 00:54:15,740
0,335 445,705 705,810 810,960 960,1185
enough that we can do

2127
00:54:15,740 --> 00:54:16,780
0,255 255,450 450,600 600,765 765,1040
things with it in memory.

2128
00:54:17,580 --> 00:54:18,410
0,275 275,425 425,545 545,680 680,830
File is too big to

2129
00:54:18,410 --> 00:54:19,490
0,105 105,210 210,470 700,975 975,1080
fit in memory, break it

2130
00:54:19,490 --> 00:54:20,765
0,75 75,285 285,555 555,860 1060,1275
up into small parts so

2131
00:54:20,765 --> 00:54:21,710
0,105 105,315 315,555 555,780 780,945
that each small part can

2132
00:54:21,710 --> 00:54:22,540
0,120 120,270 270,420 420,555 555,830
be worked on in memory.

2133
00:54:23,010 --> 00:54:24,425
0,400 450,770 770,1055 1055,1280 1280,1415
So breaking up is the

2134
00:54:24,425 --> 00:54:26,105
0,210 210,545 715,1365 1365,1515 1515,1680
first phase rehashing, which is

2135
00:54:26,105 --> 00:54:26,945
0,225 225,390 390,525 525,690 690,840
working on each of those.

2136
00:54:26,945 --> 00:54:28,370
0,360 360,570 570,750 750,1055 1135,1425
Partition in this case is

2137
00:54:28,370 --> 00:54:29,150
0,165 165,285 285,375 375,525 525,780
going to be that second

2138
00:54:29,150 --> 00:54:30,575
0,350 520,780 780,915 915,1170 1170,1425
phase that you work in

2139
00:54:30,575 --> 00:54:31,280
0,275
memory.|
|

2140
00:54:32,580 --> 00:54:34,055
0,260 260,455 455,700 780,1175 1175,1475
So we'll use the two
所以我们将使用两个散列函数，h1和h2，我们假设我们有b个缓冲区页面，现在对于这个基于散列的聚合，我们必须为输出保留一个页面。

2141
00:54:34,055 --> 00:54:35,420
0,285 285,575 685,1020 1020,1230 1230,1365
hash functions, h one and

2142
00:54:35,420 --> 00:54:37,130
0,195 195,530 880,1245 1245,1455 1455,1710
h two, we'll assume we've

2143
00:54:37,130 --> 00:54:39,275
0,255 255,555 555,900 900,1160 1870,2145
got b buffer pages, and

2144
00:54:39,275 --> 00:54:40,205
0,180 180,345 345,495 495,780 780,930
now for this hash based

2145
00:54:40,205 --> 00:54:41,375
0,510 510,735 735,825 825,960 960,1170
aggregation, we'll have to keep

2146
00:54:41,375 --> 00:54:42,700
0,270 270,540 540,735 735,960 960,1325
one page for the output.|
|

2147
00:54:43,220 --> 00:54:44,225
0,300 300,570 570,720 720,870 870,1005
And we'll start in the
我们将从以下几个方面开始。假设这个查询中我们必须使用这个不同的课程ID。我没有一个群组应用程序，但请稍等。这个例子得到了简化，您可以在这里再次进行优化，以便在早期消除一些不同的值，但是。

2148
00:54:44,225 --> 00:54:45,740
0,240 240,605 835,1125 1125,1320 1320,1515
following way. So assume this

2149
00:54:45,740 --> 00:54:47,210
0,350 640,1020 1020,1245 1245,1350 1350,1470
query where we have to

2150
00:54:47,210 --> 00:54:48,550
0,165 165,470 490,795 795,1020 1020,1340
do this distinct course ID.

2151
00:54:48,810 --> 00:54:49,670
0,275 275,455 455,545 545,680 680,860
I don't have a group

2152
00:54:49,670 --> 00:54:50,705
0,240 240,480 480,660 660,840 840,1035
APP, but just hold on

2153
00:54:50,705 --> 00:54:52,780
0,150 150,395 625,1025 1405,1740 1740,2075
to that. This example is

2154
00:54:52,860 --> 00:54:54,425
0,760 780,1055 1055,1175 1175,1295 1295,1565
simplified and there are again

2155
00:54:54,425 --> 00:54:55,810
0,540 540,765 765,900 900,1080 1080,1385
optimizations you could do here

2156
00:54:56,130 --> 00:54:57,725
0,305 305,515 515,770 770,1120 1230,1595
to fold in some early

2157
00:54:57,725 --> 00:55:00,220
0,515 775,1155 1155,1530 1530,1925 2095,2495
elimination of distinct values, but.|
|

2158
00:55:01,090 --> 00:55:01,980
0,335 335,500 500,680 680,785 785,890
Don't worry about it. In
不必为那事担心了。在这个例子中，这是一个低效的例子。但为了向您展示散列是如何工作的，如果您多次查看此站点，您会说我本可以更早地进行此散列，但这只是为了显示分区阶段，同时保留我们以前为基于排序的内容提供的相同类型的示例。

2159
00:55:01,980 --> 00:55:03,510
0,195 195,530 550,840 840,945 945,1530
this example, it's an inefficient

2160
00:55:03,510 --> 00:55:05,295
0,320 370,690 690,1010 1240,1560 1560,1785
example. But just to show

2161
00:55:05,295 --> 00:55:07,440
0,225 225,420 420,780 780,1055 1885,2145
you how hashing works, if

2162
00:55:07,440 --> 00:55:08,145
0,135 135,255 255,390 390,540 540,705
you look at this site

2163
00:55:08,145 --> 00:55:09,195
0,285 285,585 585,810 810,915 915,1050
multiple times, you'll say I

2164
00:55:09,195 --> 00:55:10,080
0,120 120,225 225,360 360,525 525,885
could have done this hashing

2165
00:55:10,080 --> 00:55:11,460
0,290 670,945 945,1080 1080,1215 1215,1380
earlier, but this just to

2166
00:55:11,460 --> 00:55:13,365
0,285 285,540 540,915 915,1280 1600,1905
show a partition phase while

2167
00:55:13,365 --> 00:55:14,685
0,225 225,420 420,695 835,1110 1110,1320
keeping the same type of

2168
00:55:14,685 --> 00:55:15,900
0,285 285,495 495,660 660,960 960,1215
example we had before for

2169
00:55:15,900 --> 00:55:17,320
0,135 135,345 345,615 615,950
the sort based stuff.|
|

2170
00:55:17,540 --> 00:55:18,550
0,395 395,695 695,845 845,920 920,1010
So now we have a
所以现在我们这里有一大堆记录。假设这里有很多更多的数据，我们将应用过滤器。我们拿到一份文件。它有这四条记录，但这里还有更多记录，因为现在我们的数据要大得多，我们将删除这些列。我们得到一个很长的列ID列表。同样，假设它真的很大，并且无法存储在内存中。

2171
00:55:18,550 --> 00:55:19,560
0,150 150,315 315,450 450,660 660,1010
whole bunch of records here.

2172
00:55:19,700 --> 00:55:20,710
0,275 275,425 425,560 560,755 755,1010
Assume that there are lots

2173
00:55:20,710 --> 00:55:22,390
0,320 460,795 795,1005 1005,1280 1390,1680
of lots more data in

2174
00:55:22,390 --> 00:55:24,265
0,290 730,1125 1125,1515 1515,1710 1710,1875
here and we'll apply the

2175
00:55:24,265 --> 00:55:25,410
0,275 295,585 585,735 735,870 870,1145
filter. We get a file.

2176
00:55:25,580 --> 00:55:26,710
0,260 260,410 410,650 650,890 890,1130
It has these four records,

2177
00:55:26,710 --> 00:55:27,730
0,300 300,480 480,570 570,750 750,1020
but also a lot more

2178
00:55:27,730 --> 00:55:28,720
0,330 330,570 570,705 705,840 840,990
here, because now our data

2179
00:55:28,720 --> 00:55:30,955
0,165 165,345 345,650 1240,1640 1870,2235
is much larger and we'll

2180
00:55:30,955 --> 00:55:31,795
0,165 165,330 330,600 600,735 735,840
remove the columns. We get

2181
00:55:31,795 --> 00:55:33,145
0,150 150,455 685,975 975,1155 1155,1350
a long list of column

2182
00:55:33,145 --> 00:55:35,050
0,605 805,1185 1185,1440 1440,1695 1695,1905
IDs. Again, assume that's really

2183
00:55:35,050 --> 00:55:36,625
0,350 640,1005 1005,1260 1260,1485 1485,1575
big and it can't fit

2184
00:55:36,625 --> 00:55:37,460
0,120 120,395
in memory.|
|

2185
00:55:37,810 --> 00:55:39,600
0,335 335,635 635,970 1260,1535 1535,1790
Now we apply a hash
现在，我们应用散列函数来创建。

2186
00:55:39,600 --> 00:55:41,640
0,290 670,975 975,1280
function to create.|
|

2187
00:55:41,640 --> 00:55:43,905
0,260 340,855 855,1220 1690,2025 2025,2265
Different partition files. We'll create
不同的分区文件。我们将创建b减去1的分区文件，因此我们将引入一个球拍。我们将使用一个缓冲区页面进行输入。我们将为b减去1个输出分区文件分配b减去1页。

2188
00:55:43,905 --> 00:55:45,360
0,255 255,495 495,735 735,1140 1140,1455
b minus one partition files,

2189
00:55:45,360 --> 00:55:47,220
0,195 195,435 435,740 1030,1430 1570,1860
so we'll bring in a

2190
00:55:47,220 --> 00:55:48,675
0,450 450,750 750,900 900,1125 1125,1455
racket. We'll use one buffer

2191
00:55:48,675 --> 00:55:50,235
0,255 255,495 495,720 720,1085 1255,1560
page for the input. We'll

2192
00:55:50,235 --> 00:55:52,010
0,465 465,815 835,1200 1200,1470 1470,1775
allocate b minus one pages

2193
00:55:52,090 --> 00:55:53,570
0,290 290,580 600,875 875,1115 1115,1480
for the b minus one

2194
00:55:53,710 --> 00:55:55,460
0,290 290,665 665,1030
output partition files.|
|

2195
00:55:55,460 --> 00:55:56,270
0,150 150,315 315,450 450,570 570,810
As we read a record,
当我们读取记录时，我们将应用散列函数，将其放入该分区的输出缓冲区页中。随着存储空间的填满，我们将把它写入磁盘。对于每个分区，我们只需要一个输出页面，但在它的末尾，我们最终得到的是在第一个分区中有一整串页面。我只显示了一年，但可能会有一大堆，随着时间的推移，嗯，我们把输入文件，在本例中，列ID分解为p减1。

2196
00:55:56,270 --> 00:55:57,460
0,345 345,540 540,675 675,900 900,1190
we'll apply the hash function,

2197
00:55:57,810 --> 00:55:59,585
0,260 260,425 425,710 710,1090 1500,1775
put it into the output

2198
00:55:59,585 --> 00:56:00,820
0,285 285,450 450,615 615,765 765,1235
buffer page for that partition.

2199
00:56:01,080 --> 00:56:02,165
0,275 275,440 440,680 680,890 890,1085
As that fills up, we

2200
00:56:02,165 --> 00:56:03,200
0,105 105,255 255,420 420,555 555,1035
will write it to disk.

2201
00:56:03,200 --> 00:56:04,460
0,240 240,375 375,600 600,950 1000,1260
We just need one output

2202
00:56:04,460 --> 00:56:06,215
0,180 180,375 375,600 600,1100 1480,1755
page for each partition but

2203
00:56:06,215 --> 00:56:07,010
0,150 150,315 315,480 480,630 630,795
the end of it, what

2204
00:56:07,010 --> 00:56:08,465
0,135 135,240 240,390 390,680 1090,1455
we end up having is

2205
00:56:08,465 --> 00:56:10,240
0,330 330,575 805,1125 1125,1410 1410,1775
we'll have a whole bunch

2206
00:56:10,320 --> 00:56:11,750
0,350 350,700 780,1055 1055,1220 1220,1430
of pages in the first

2207
00:56:11,750 --> 00:56:13,010
0,390 390,645 645,780 780,1005 1005,1260
partition. I'm just showing one

2208
00:56:13,010 --> 00:56:14,165
0,320 550,810 810,930 930,1050 1050,1155
year, but there could be

2209
00:56:14,165 --> 00:56:14,990
0,90 90,240 240,450 450,630 630,825
a whole bunch as that

2210
00:56:14,990 --> 00:56:17,170
0,300 300,560 940,1340 1450,1755 1755,2180
spills over, um, and we

2211
00:56:17,280 --> 00:56:19,460
0,320 320,560 560,880 1650,1970 1970,2180
break up the input file,

2212
00:56:19,460 --> 00:56:21,130
0,165 165,345 345,650 760,1065 1065,1670
in this case column IDs

2213
00:56:21,270 --> 00:56:23,280
0,395 395,740 740,1090 1110,1510
into p minus one.|
|

2214
00:56:23,290 --> 00:56:26,070
0,640 840,1390 2100,2375 2375,2540 2540,2780
Chunks, partitions where in each
块，分区，每个分区中的所有键都有这样的属性，如果它们使用这个hone函数，它们就会散列到相同的值，为什么这很重要？因为如果我有两个像这样的副本，我就有一个副本在这里，一个副本在这里。

2215
00:56:26,070 --> 00:56:27,810
0,530 790,1155 1155,1410 1410,1575 1575,1740
partition all the keys have

2216
00:56:27,810 --> 00:56:30,260
0,165 165,440 940,1335 1335,1730 2050,2450
the property that if they

2217
00:56:30,970 --> 00:56:32,160
0,365 365,740 740,875 875,995 995,1190
they hash to the same

2218
00:56:32,160 --> 00:56:33,540
0,270 270,585 585,870 870,1125 1125,1380
value using this h one

2219
00:56:33,540 --> 00:56:35,025
0,320 790,1065 1065,1200 1200,1305 1305,1485
function and why is that

2220
00:56:35,025 --> 00:56:36,360
0,335 625,885 885,990 990,1185 1185,1335
important? Because if I've got

2221
00:56:36,360 --> 00:56:37,950
0,225 225,840 840,1155 1155,1380 1380,1590
two duplicates like here, I've

2222
00:56:37,950 --> 00:56:39,270
0,90 90,210 210,615 615,890 1060,1320
got a duplicate here and

2223
00:56:39,270 --> 00:56:40,620
0,105 105,495 495,770
a duplicate here.|
|

2224
00:56:40,870 --> 00:56:41,970
0,275 275,650 650,740 740,905 905,1100
A duplicate, if I apply
如果我应用相同的散列函数，则重复的散列将散列到相同的位置。Always将散列到存储桶零，这里的分区为零，因此我将把所有副本放在一起。这就是我的分拆策略。第二部分，我所做的就是处理每个分区以消除重复项。

2225
00:56:41,970 --> 00:56:42,975
0,150 150,300 300,555 555,780 780,1005
the same hash function, will

2226
00:56:42,975 --> 00:56:44,150
0,240 240,345 345,450 450,725 775,1175
hash to the same position.

2227
00:56:44,800 --> 00:56:45,825
0,290 290,455 455,665 665,800 800,1025
Always will hash to bucket

2228
00:56:45,825 --> 00:56:47,720
0,365 565,840 840,1200 1200,1530 1530,1895
zero the partition zero here

2229
00:56:47,980 --> 00:56:49,680
0,400 600,980 980,1235 1235,1430 1430,1700
and hence I will bring

2230
00:56:49,680 --> 00:56:51,405
0,255 255,420 420,945 945,1310 1480,1725
all the duplicates together. So

2231
00:56:51,405 --> 00:56:53,415
0,195 195,450 450,840 840,1235 1735,2010
that's my divide strategy. And

2232
00:56:53,415 --> 00:56:54,480
0,150 150,375 375,660 660,885 885,1065
the second part, all I

2233
00:56:54,480 --> 00:56:55,920
0,285 285,570 570,810 810,1065 1065,1440
do is process each partition

2234
00:56:55,920 --> 00:56:57,520
0,195 195,495 495,1100
to eliminate duplicates.|
|

2235
00:56:57,520 --> 00:56:59,095
0,240 240,855 855,1110 1110,1335 1335,1575
I'm guaranteed, because I've applied
我可以保证，因为我已经申请了一年的分区，如果两个记录相同，它们将位于相同的分区中。

2236
00:56:59,095 --> 00:57:00,750
0,270 270,525 525,765 765,960 960,1655
h one year for partitioning,

2237
00:57:00,980 --> 00:57:02,260
0,335 335,575 575,800 800,1070 1070,1280
that if two records are

2238
00:57:02,260 --> 00:57:03,865
0,135 135,410 580,930 930,1245 1245,1605
the same, they will be

2239
00:57:03,865 --> 00:57:05,780
0,285 285,465 465,735 735,1265
in the same partition.|
|

2240
00:57:06,250 --> 00:57:07,470
0,245 245,395 395,770 770,980 980,1220
So by dividing the file
因此，通过将文件划分为更小的片段，即这些分区，然后为该片段单独处理每个分区，我们使用内存中算法。我们得到保证，我们已经高效地完成了整个行动。

2241
00:57:07,470 --> 00:57:09,740
0,380 400,765 765,1130 1540,1830 1830,2270
into smaller pieces, these partitions,

2242
00:57:10,090 --> 00:57:11,570
0,260 260,410 410,700 720,1025 1025,1480
and then processing each partition

2243
00:57:11,620 --> 00:57:13,215
0,580 840,1100 1100,1250 1250,1445 1445,1595
individually for that piece we

2244
00:57:13,215 --> 00:57:14,810
0,120 120,285 285,465 465,755 1015,1595
use an in memory algorithm.

2245
00:57:14,980 --> 00:57:16,280
0,230 230,335 335,800 800,1040 1040,1300
We are guaranteed we've done

2246
00:57:16,690 --> 00:57:19,480
0,400 600,995 995,1390 1410,2170
the entire operation efficiently.|
|

2247
00:57:19,480 --> 00:57:20,995
0,225 225,480 480,690 690,980 1180,1515
In this, two passes protection
在这种情况下，两次传递保护传递，然后是一次合并传递，然后是A次重新散列传递。

2248
00:57:20,995 --> 00:57:22,240
0,335 415,660 660,765 765,915 915,1245
pass and then an merge

2249
00:57:22,240 --> 00:57:23,530
0,270 270,540 540,690 690,950 1000,1290
pass and then A A

2250
00:57:23,530 --> 00:57:24,960
0,375 375,710
rehash pass.|
|

2251
00:57:25,090 --> 00:57:26,020
0,400
Okay.|
好吧。|

2252
00:57:26,020 --> 00:57:26,995
0,210 210,420 420,525 525,735 735,975
So that's the second page
这是该分区中的第二个页面，因为我们正在扫描它，这表明该分区可以有多个页面。

2253
00:57:26,995 --> 00:57:28,150
0,165 165,300 300,725 745,1035 1035,1155
in that partition as we

2254
00:57:28,150 --> 00:57:28,990
0,135 135,465 465,585 585,690 690,840
are scanning through it, just

2255
00:57:28,990 --> 00:57:30,325
0,195 195,500 550,1005 1005,1200 1200,1335
showing that partition can have

2256
00:57:30,325 --> 00:57:31,860
0,275 295,695
multiple pages.|
|

2257
00:57:31,860 --> 00:57:32,580
0,225 225,315 315,405 405,540 540,720
So now in this three
现在，在这三个散列中，将应用第二个散列函数。让我们去看看它是什么样子的。想象一下，这些是我们在所有这些分区上获得的页面。所以第一个分区有两个页面，然后我们有一堆其他的分区在这里。当我们把它拉进来的时候，我们会申请的。

2258
00:57:32,580 --> 00:57:33,540
0,240 240,420 420,600 600,750 750,960
hash will apply a second

2259
00:57:33,540 --> 00:57:35,190
0,300 300,590 1060,1410 1410,1515 1515,1650
hash function. Let's go and

2260
00:57:35,190 --> 00:57:36,285
0,165 165,510 510,690 690,885 885,1095
see visually what that looks

2261
00:57:36,285 --> 00:57:39,770
0,305 805,1205 2185,2585 2665,3065 3085,3485
like. So imagine these are

2262
00:57:40,000 --> 00:57:42,375
0,380 380,650 650,920 920,1180 2010,2375
pages that we've got across

2263
00:57:42,375 --> 00:57:43,740
0,285 285,510 510,915 915,1155 1155,1365
all these partitions. So that

2264
00:57:43,740 --> 00:57:45,110
0,285 285,690 690,915 915,1095 1095,1370
first partition has two pages

2265
00:57:45,640 --> 00:57:46,470
0,290 290,440 440,620 620,710 710,830
and then we've got a

2266
00:57:46,470 --> 00:57:48,060
0,150 150,300 300,495 495,980 1330,1590
bunch of other partitions that

2267
00:57:48,060 --> 00:57:49,335
0,120 120,285 285,590 760,1050 1050,1275
are in here. As we

2268
00:57:49,335 --> 00:57:50,900
0,225 225,465 465,815 1015,1290 1290,1565
pull that in, we will

2269
00:57:51,070 --> 00:57:52,140
0,400
apply.|
|

2270
00:57:52,140 --> 00:57:53,930
0,120 120,375 375,650 1120,1455 1455,1790
The hash function. And so
散列函数。因此，我们将获取第一条记录，将其放入内存哈希表中，然后当我们获取第二条记录并对其已有的记录应用哈希函数时。所以我们就把它扔了。

2271
00:57:53,950 --> 00:57:54,810
0,260 260,395 395,530 530,665 665,860
we will take the first

2272
00:57:54,810 --> 00:57:56,250
0,320 610,885 885,1035 1035,1215 1215,1440
record, put that into that

2273
00:57:56,250 --> 00:57:58,155
0,210 210,500 610,990 990,1280 1630,1905
in memory hash table, then

2274
00:57:58,155 --> 00:57:59,475
0,150 150,425 655,945 945,1110 1110,1320
when we take the second

2275
00:57:59,475 --> 00:58:00,675
0,285 285,585 585,810 810,960 960,1200
record and apply a hash

2276
00:58:00,675 --> 00:58:01,850
0,225 225,405 405,630 630,825 825,1175
function to its already there.

2277
00:58:01,960 --> 00:58:02,715
0,230 230,350 350,470 470,665 665,755
So we'll just toss it

2278
00:58:02,715 --> 00:58:03,440
0,245
out.|
|

2279
00:58:03,440 --> 00:58:04,970
0,315 315,420 420,630 630,960 960,1530
That's how we're eliminating duplicates,
这就是我们消除重复项的方法，因为它是散列到相同的值。

2280
00:58:04,970 --> 00:58:05,870
0,210 210,360 360,675 675,795 795,900
because it's hashing to the

2281
00:58:05,870 --> 00:58:07,040
0,180 180,500
same value.|
|

2282
00:58:07,040 --> 00:58:09,620
0,120 120,270 270,530 850,1250 2290,2580
At the end, ah, when
最后，啊，等我们做完了。对不起，在本例中，这是同一分区中的第二个页面，因此我们将在这里对其进行散列。所以我们仍然在第一个分区中，您将其放入哈希表中，在哈希表的末尾，当您处理完该分区中的所有记录时，我们将输出结果，查看哈希表。任何有价值的东西都会填满它。

2283
00:58:09,620 --> 00:58:10,745
0,120 120,210 210,470 610,945 945,1125
we are done. Sorry, in

2284
00:58:10,745 --> 00:58:12,275
0,195 195,545 955,1215 1215,1350 1350,1530
this example, this is the

2285
00:58:12,275 --> 00:58:13,450
0,255 255,540 540,735 735,885 885,1175
second page in that same

2286
00:58:13,770 --> 00:58:15,185
0,530 530,770 770,980 980,1205 1205,1415
partition, so we'll hash that

2287
00:58:15,185 --> 00:58:16,430
0,335 565,810 810,885 885,1005 1005,1245
here. So we are still

2288
00:58:16,430 --> 00:58:18,280
0,210 210,345 345,540 540,1010 1450,1850
in the first partition and

2289
00:58:18,660 --> 00:58:20,420
0,400 900,1190 1190,1400 1400,1610 1610,1760
you put that into the

2290
00:58:20,420 --> 00:58:21,920
0,270 270,560 940,1215 1215,1365 1365,1500
hash table and at the

2291
00:58:21,920 --> 00:58:22,895
0,135 135,315 315,555 555,750 750,975
end of it, when you're

2292
00:58:22,895 --> 00:58:24,095
0,210 210,545 595,885 885,1020 1020,1200
done processing all the records

2293
00:58:24,095 --> 00:58:25,205
0,195 195,330 330,690 690,870 870,1110
in that partition, we will

2294
00:58:25,205 --> 00:58:26,825
0,300 300,540 540,875 1165,1470 1470,1620
output the results, look through

2295
00:58:26,825 --> 00:58:27,905
0,105 105,345 345,605 715,975 975,1080
the hash table. Anything that

2296
00:58:27,905 --> 00:58:29,015
0,105 105,210 210,455 625,930 930,1110
is a value will fill

2297
00:58:29,015 --> 00:58:29,840
0,150 150,425
that up.|
|

2298
00:58:29,910 --> 00:58:30,970
0,230 230,410 410,575 575,770 770,1060
So we're done with processing
因此，我们已经完成了对此分区中所有记录的处理。

2299
00:58:30,990 --> 00:58:32,075
0,305 305,470 470,665 665,890 890,1085
all the records in this

2300
00:58:32,075 --> 00:58:33,280
0,455
partition.|
|

2301
00:58:33,280 --> 00:58:34,630
0,290 370,765 765,1065 1065,1230 1230,1350
Now we clear up the
现在我们清理哈希表。

2302
00:58:34,630 --> 00:58:35,900
0,255 255,530
hash table.|
|

2303
00:58:35,900 --> 00:58:36,755
0,210 210,375 375,525 525,675 675,855
Then do the same thing
然后对另一个分区和输出中的记录再次执行相同的操作。这些都是对最终结果的补充。因此，我们开始处理的第二个分区，清除哈希表。

2304
00:58:36,755 --> 00:58:37,610
0,180 180,315 315,540 540,765 765,855
again for records in the

2305
00:58:37,610 --> 00:58:39,100
0,150 150,585 585,945 945,1215 1215,1490
other partition and output. Those

2306
00:58:39,240 --> 00:58:40,690
0,260 260,785 785,995 995,1145 1145,1450
keep appending to this final

2307
00:58:40,710 --> 00:58:43,280
0,400 810,1210 1470,1865 1865,2360 2360,2570
result. So second partition that

2308
00:58:43,280 --> 00:58:44,110
0,75 75,165 165,375 375,570 570,830
we are starting to process,

2309
00:58:44,640 --> 00:58:45,670
0,275 275,410 410,530 530,755 755,1030
clear up the hash table.|
|

2310
00:58:46,480 --> 00:58:48,410
0,305 305,545 545,815 815,1150 1530,1930
Use that space now to
现在使用该空间执行与之前的rehash函数相同的操作，并继续执行该操作，直到处理完所有分区。

2311
00:58:48,730 --> 00:58:49,545
0,260 260,395 395,560 560,695 695,815
do the same thing as

2312
00:58:49,545 --> 00:58:50,745
0,135 135,270 270,540 540,825 825,1200
we did before that rehash

2313
00:58:50,745 --> 00:58:52,530
0,335 775,1155 1155,1425 1425,1590 1590,1785
function, and keep doing that

2314
00:58:52,530 --> 00:58:53,760
0,180 180,375 375,620 790,1065 1065,1230
till you've done with all

2315
00:58:53,760 --> 00:58:55,100
0,150 150,560
the partitions.|
|

2316
00:58:55,970 --> 00:58:57,100
0,260 260,425 425,710 710,965 965,1130
So, very simple, divide and
所以，很简单，在你首先把它分成几个分区的地方，分而治之。这是第一个分区。这是第二个分区，还会有更多分区，因为当你应用hone时。

2317
00:58:57,100 --> 00:58:59,230
0,500 820,1220 1450,1740 1740,1950 1950,2130
conquer where you first break

2318
00:58:59,230 --> 00:59:00,475
0,105 105,270 270,540 540,1020 1020,1245
it up into partition. So

2319
00:59:00,475 --> 00:59:01,500
0,120 120,240 240,360 360,555 555,1025
this is the first partition.

2320
00:59:01,580 --> 00:59:02,755
0,260 260,380 380,515 515,725 725,1175
This is the second partition

2321
00:59:02,755 --> 00:59:03,930
0,225 225,450 450,615 615,855 855,1175
and there'd be many more

2322
00:59:04,490 --> 00:59:06,295
0,400 840,1100 1100,1265 1265,1505 1505,1805
because when you apply h

2323
00:59:06,295 --> 00:59:07,280
0,365
one.|
|

2324
00:59:07,280 --> 00:59:08,735
0,225 225,390 390,650 1060,1320 1320,1455
All the records that have
因此，具有重复项的所有记录都将散列到相同的存储桶中，因此，在本例中，对于五条记录而言。这样一来，您就可以保证可以消除重复项。

2325
00:59:08,735 --> 00:59:09,980
0,435 435,645 645,960 960,1110 1110,1245
duplicates will hash to the

2326
00:59:09,980 --> 00:59:11,270
0,225 225,560 670,945 945,1095 1095,1290
same bucket because of that,

2327
00:59:11,270 --> 00:59:12,590
0,195 195,360 360,650 850,1140 1140,1320
in this case, for for

2328
00:59:12,590 --> 00:59:15,100
0,290 340,740 1360,1760 1870,2190 2190,2510
five records. And that way

2329
00:59:15,180 --> 00:59:16,160
0,230 230,335 335,710 710,815 815,980
you are guaranteed you can

2330
00:59:16,160 --> 00:59:17,740
0,345 345,920
eliminate duplicates.|
|

2331
00:59:18,340 --> 00:59:19,340
0,400
Okay.|
好吧。|

2332
00:59:19,740 --> 00:59:21,320
0,400 660,965 965,1190 1190,1415 1415,1580
And in this case, if
在这种情况下，如果你得到了正确的分区，那么可能会出现一个问题，嘿，假设这个分区有很多重复值，而这个哈希表放不下内存，你会怎么做？你可以做几件事中的一件。您可以获取此分区并对其进行重新分区。

2333
00:59:21,320 --> 00:59:22,445
0,195 195,375 375,570 570,900 900,1125
you've gotten the partition right,

2334
00:59:22,445 --> 00:59:23,830
0,150 150,285 285,525 525,870 870,1385
so one question might arises,

2335
00:59:24,120 --> 00:59:26,090
0,290 290,470 470,760 930,1330 1620,1970
hey, what happens if, let's

2336
00:59:26,090 --> 00:59:27,290
0,105 105,270 270,630 630,960 960,1200
say this partition had a

2337
00:59:27,290 --> 00:59:28,655
0,135 135,300 300,735 735,1010 1090,1365
lot of duplicate values and

2338
00:59:28,655 --> 00:59:29,630
0,150 150,375 375,540 540,840 840,975
this hash table doesn't fit

2339
00:59:29,630 --> 00:59:31,355
0,135 135,410 1210,1485 1485,1605 1605,1725
in memory, what would you

2340
00:59:31,355 --> 00:59:32,300
0,255 255,495 495,630 630,795 795,945
do at that point? You

2341
00:59:32,300 --> 00:59:33,035
0,105 105,210 210,330 330,480 480,735
could do one of several

2342
00:59:33,035 --> 00:59:34,775
0,365 565,855 855,1145 1225,1530 1530,1740
things. You could take this

2343
00:59:34,775 --> 00:59:36,280
0,375 375,630 630,825 825,1185 1185,1505
partition and {re-partition -} it.|
|

2344
00:59:36,750 --> 00:59:38,470
0,400 840,1115 1115,1265 1265,1430 1430,1720
Or what you could do
或者你可以说这里的唱片太多了。如果我还没有输出任何记录，嗯，我可以使用这个分区。

2345
00:59:38,700 --> 00:59:40,625
0,290 290,440 440,620 620,940 1680,1925
is you could say there

2346
00:59:40,625 --> 00:59:41,510
0,105 105,225 225,390 390,630 630,885
are too many records over

2347
00:59:41,510 --> 00:59:43,175
0,320 520,780 780,900 900,1310 1360,1665
here. If I haven't output

2348
00:59:43,175 --> 00:59:45,410
0,270 270,635 775,1175 1435,1835 1945,2235
any records already, um, I

2349
00:59:45,410 --> 00:59:48,720
0,290 970,1370 1750,2100 2100,2630
can take this partition.|
|

2350
00:59:48,840 --> 00:59:49,925
0,260 260,380 380,620 620,890 890,1085
And I can use a
我可以对此分区使用基于排序的算法，以便您可以混合和匹配一些分区。您可以使用散列函数应用分区的第一阶段，但每个单独的分区都可以决定是使用基于散列的方法来消除重复项，还是使用基于排序的方法。很多时候，当您创建分区时，您知道每个分区文件中有多少个键。这样你就可以决定如何选择。但它们也是适应性技术，可以在飞行中进行适应。高级数据库课程谈到了这一点，但只是想知道有时您可能需要处理溢出。

2351
00:59:49,925 --> 00:59:51,290
0,225 225,545 565,1035 1035,1200 1200,1365
sort based algorithm for this

2352
00:59:51,290 --> 00:59:52,115
0,360 360,510 510,585 585,690 690,825
partition so you can mix

2353
00:59:52,115 --> 00:59:54,065
0,135 135,395 835,1230 1230,1625 1645,1950
and match some. You apply

2354
00:59:54,065 --> 00:59:55,660
0,180 180,405 405,755 865,1170 1170,1595
the first phase of partition

2355
00:59:55,680 --> 00:59:56,770
0,245 245,425 425,605 605,815 815,1090
everything using a hash function,

2356
00:59:57,120 --> 00:59:58,580
0,290 290,545 545,860 860,1250 1250,1460
but each individual partition you

2357
00:59:58,580 --> 00:59:59,765
0,290 490,795 795,945 945,1095 1095,1185
could decide whether you're going

2358
00:59:59,765 --> 01:00:00,695
0,120 120,240 240,390 390,645 645,930
to use a hash based

2359
01:00:00,695 --> 01:00:02,930
0,395 565,870 870,1230 1230,1865 1915,2235
approach for eliminating duplicates or

2360
01:00:02,930 --> 01:00:03,725
0,180 180,300 300,435 435,600 600,795
you could use a sort

2361
01:00:03,725 --> 01:00:05,465
0,300 300,695 1045,1320 1320,1500 1500,1740
based approach. And many times

2362
01:00:05,465 --> 01:00:06,590
0,180 180,375 375,585 585,795 795,1125
when you've created the partition

2363
01:00:06,590 --> 01:00:08,255
0,320 430,720 720,1010 1210,1470 1470,1665
you, you know how many

2364
01:00:08,255 --> 01:00:09,380
0,255 255,450 450,725 745,1005 1005,1125
keys there are in each

2365
01:00:09,380 --> 01:00:10,430
0,120 120,240 240,585 585,870 870,1050
of the partition files. So

2366
01:00:10,430 --> 01:00:11,255
0,90 90,285 285,495 495,660 660,825
you could decide how to

2367
01:00:11,255 --> 01:00:12,320
0,275 385,630 630,705 705,840 840,1065
choose. But they are also

2368
01:00:12,320 --> 01:00:13,640
0,435 435,675 675,915 915,1095 1095,1320
adaptive techniques that can adapt

2369
01:00:13,640 --> 01:00:15,020
0,180 180,330 330,620 850,1155 1155,1380
on the fly. The advanced

2370
01:00:15,020 --> 01:00:16,565
0,320 430,765 765,1050 1050,1305 1305,1545
database course talks about that,

2371
01:00:16,565 --> 01:00:17,450
0,210 210,360 360,555 555,720 720,885
but just wanted to be

2372
01:00:17,450 --> 01:00:19,115
0,320 640,990 990,1320 1320,1560 1560,1665
aware that sometimes you may

2373
01:00:19,115 --> 01:00:20,650
0,135 135,300 300,450 450,660 660,1535
need to deal with overflows.|
|

2374
01:00:21,300 --> 01:00:23,120
0,350 460,735 735,975 975,1340 1420,1820
Of the data structure because
因为散列并不完美。也可能是，当我们执行h操作时，啊，或者数据有很多重复项，或者有很多映射到第一个分区的值。你首先在这里进行分区，这样你可能不得不做其他的事情。当您开始执行重新哈希时，重新哈希表的哈希表无法放入内存。

2375
01:00:23,350 --> 01:00:24,780
0,425 425,530 530,695 695,1000 1170,1430
hashing is not perfect. And

2376
01:00:24,780 --> 01:00:25,560
0,150 150,330 330,480 480,615 615,780
it may be that when

2377
01:00:25,560 --> 01:00:26,750
0,150 150,285 285,495 495,810 810,1190
we were doing h one,

2378
01:00:27,130 --> 01:00:29,505
0,400 600,1000 1680,1955 1955,2135 2135,2375
ah, or the data is

2379
01:00:29,505 --> 01:00:30,240
0,285 285,495 495,585 585,660 660,735
such that it had a

2380
01:00:30,240 --> 01:00:31,365
0,105 105,375 375,960 960,1050 1050,1125
lot of duplicates or it

2381
01:00:31,365 --> 01:00:32,030
0,90 90,165 165,270 270,405 405,665
had a lot of values

2382
01:00:32,050 --> 01:00:33,075
0,320 320,620 620,725 725,830 830,1025
that mapped to the first

2383
01:00:33,075 --> 01:00:34,965
0,485 625,900 900,1140 1140,1425 1425,1890
partition. You go first partition

2384
01:00:34,965 --> 01:00:36,660
0,365 595,855 855,975 975,1235 1375,1695
here that you might have

2385
01:00:36,660 --> 01:00:38,100
0,165 165,300 300,525 525,860 1180,1440
to do something else. When

2386
01:00:38,100 --> 01:00:38,775
0,150 150,315 315,435 435,540 540,675
you start to do the

2387
01:00:38,775 --> 01:00:40,695
0,450 450,705 705,1110 1110,1445 1585,1920
rehash, the rehash table hash

2388
01:00:40,695 --> 01:00:41,750
0,195 195,525 525,660 660,780 780,1055
table doesn't fit in memory.|
|

2389
01:00:42,760 --> 01:00:43,905
0,260 260,365 365,590 590,920 920,1145
But there are details. Just
但也有一些细节。只是想知道你可能需要做一些其他的事情，如果你遇到那个案子，如果你需要的话，你可以查一下。

2390
01:00:43,905 --> 01:00:44,775
0,180 180,330 330,480 480,690 690,870
wanted to be aware that

2391
01:00:44,775 --> 01:00:45,555
0,165 165,330 330,495 495,645 645,780
you may need to do

2392
01:00:45,555 --> 01:00:46,755
0,210 210,545 655,915 915,1035 1035,1200
something else and you can

2393
01:00:46,755 --> 01:00:48,465
0,210 210,405 405,695 1315,1590 1590,1710
look things up if you

2394
01:00:48,465 --> 01:00:49,500
0,165 165,480 480,750 750,900 900,1035
need to you if you

2395
01:00:49,500 --> 01:00:50,860
0,150 150,345 345,650
hit that case.|
|

2396
01:00:52,030 --> 01:00:55,860
0,305 305,610 900,1300 2130,2530 3390,3830
All right, so essentially we've
好的，基本上我们已经研究了如何使用基于排序和基于散列的方法进行散列。现在，让我们讨论聚合中的最后一个场景，其中聚合稍微复杂一些。你知道，不同的计数，这是你能想到的最简单的集合，你有一个组。圆周率是一个连接，然后你计算平均值。

2397
01:00:55,860 --> 01:00:56,880
0,180 180,405 405,675 675,870 870,1020
looked at how we can

2398
01:00:56,880 --> 01:00:58,580
0,285 285,780 780,1035 1035,1365 1365,1700
do hashing using sort based

2399
01:00:58,630 --> 01:01:00,690
0,305 305,590 590,800 800,1120 1800,2060
and hash based methods. Now

2400
01:01:00,690 --> 01:01:02,955
0,240 240,435 435,770 910,1310 1870,2265
let's cover this last scenario

2401
01:01:02,955 --> 01:01:04,815
0,255 255,815 1135,1380 1380,1470 1470,1860
in aggregation where the aggregation

2402
01:01:04,815 --> 01:01:05,720
0,180 180,300 300,450 450,630 630,905
is a little bit more

2403
01:01:05,740 --> 01:01:06,900
0,400 480,710 710,860 860,1040 1040,1160
complex. You know, instead of

2404
01:01:06,900 --> 01:01:08,070
0,255 255,600 600,870 870,1050 1050,1170
the distinct count, which is

2405
01:01:08,070 --> 01:01:09,180
0,135 135,465 465,855 855,960 960,1110
the simplest aggregate you can

2406
01:01:09,180 --> 01:01:10,425
0,165 165,440 700,1020 1020,1110 1110,1245
think of, you've got a

2407
01:01:10,425 --> 01:01:11,930
0,165 165,455 835,1095 1095,1230 1230,1505
group. Pi is a join,

2408
01:01:12,250 --> 01:01:13,605
0,290 290,530 530,890 890,1220 1220,1355
and then you're computing the

2409
01:01:13,605 --> 01:01:14,720
0,275
average.|
|

2410
01:01:14,760 --> 01:01:15,820
0,260 260,410 410,575 575,755 755,1060
So now in this case,
因此，现在在这种情况下，假设我们正在创建存储桶，就像我们在应用散列函数之前所做的那样，就像我们之前所做的那样。你知道，忽略我们在第一阶段之前是怎么做的。这和以前完全一样。重要的是在重新哈希阶段，当我们处理每个单独的分区时，我们现在将存储在哈希表中，不仅是键，还包括值。

2411
01:01:16,020 --> 01:01:18,050
0,400 780,1040 1040,1300 1440,1805 1805,2030
imagine we are creating the

2412
01:01:18,050 --> 01:01:19,210
0,345 345,540 540,705 705,870 870,1160
buckets as we did before

2413
01:01:19,800 --> 01:01:21,620
0,350 350,635 635,970 1140,1565 1565,1820
we applying the hash function,

2414
01:01:21,620 --> 01:01:22,790
0,240 240,390 390,555 555,860 910,1170
as we did before. You

2415
01:01:22,790 --> 01:01:24,260
0,260 490,890 940,1200 1200,1320 1320,1470
know, ignore how we did

2416
01:01:24,260 --> 01:01:25,835
0,290 370,690 690,1005 1005,1320 1320,1575
the h one stuff before

2417
01:01:25,835 --> 01:01:26,960
0,210 210,390 390,600 600,885 885,1125
the first phase. That's exactly

2418
01:01:26,960 --> 01:01:28,460
0,210 210,345 345,510 510,800 1210,1500
the same as before. What

2419
01:01:28,460 --> 01:01:29,720
0,270 270,510 510,630 630,795 795,1260
matters is in that rehash

2420
01:01:29,720 --> 01:01:31,060
0,270 270,435 435,585 585,830 940,1340
phase when we're processing each

2421
01:01:31,290 --> 01:01:33,980
0,380 380,910 1530,1820 1820,2110 2310,2690
individual partition, we will store

2422
01:01:33,980 --> 01:01:35,500
0,380 550,825 825,960 960,1230 1230,1520
now in the hash table,

2423
01:01:35,730 --> 01:01:37,330
0,290 290,470 470,650 650,940 1200,1600
not just the key, but

2424
01:01:37,410 --> 01:01:38,920
0,305 305,530 530,850
also a value.|
|

2425
01:01:39,190 --> 01:01:40,530
0,275 275,470 470,790 870,1130 1130,1340
In this case, if I've
在本例中，如果我在第一个分区中有两个记录，并且它们有两个不同的GPA，那么我存储在值中的是Running吗？

2426
01:01:40,530 --> 01:01:41,790
0,165 165,420 420,740 850,1110 1110,1260
got two records in that

2427
01:01:41,790 --> 01:01:43,815
0,225 225,740 1270,1620 1620,1845 1845,2025
first partition and they have

2428
01:01:43,815 --> 01:01:46,095
0,180 180,435 435,1115 1795,2055 2055,2280
two different gpas, what I've

2429
01:01:46,095 --> 01:01:46,935
0,180 180,315 315,435 435,630 630,840
stored in the value is

2430
01:01:46,935 --> 01:01:48,240
0,180 180,485
that running?|
|

2431
01:01:48,310 --> 01:01:49,530
0,350 350,605 605,770 770,935 935,1220
Count of how many records
有多少条记录散列到此值的计数？多少?四张、四张、五张唱片？我看过了。第二，这些GPA 7.2的累加是多少，因为我是在计算一个平均值，如果我只是把平均值存储在这里。

2432
01:01:49,530 --> 01:01:50,660
0,270 270,585 585,705 705,840 840,1130
have hashed to this value?

2433
01:01:50,680 --> 01:01:52,080
0,275 275,545 545,845 845,1100 1100,1400
How many? Four, four, five

2434
01:01:52,080 --> 01:01:54,240
0,300 300,645 645,920 970,1370 1810,2160
records? I've seen. Two, what's

2435
01:01:54,240 --> 01:01:56,360
0,165 165,500 670,1070 1420,1770 1770,2120
a running sum of those

2436
01:01:56,770 --> 01:01:59,625
0,700 900,1840 2100,2345 2345,2585 2585,2855
gpas 7.2 because I'm computing

2437
01:01:59,625 --> 01:02:01,050
0,150 150,455 685,1050 1050,1260 1260,1425
an average if instead I

2438
01:02:01,050 --> 01:02:02,780
0,240 240,555 555,825 825,1160 1330,1730
just stored the average here.|
|

2439
01:02:03,520 --> 01:02:04,615
0,105 105,210 210,360 360,945 945,1095
I would be averaging the
我会以一种连续的形式对平均值进行平均，这并不准确。平均数不是真正的平均数。所以在这里，我们把求和和算作两个不同的东西，我们把它们放在一起。当我们扫描完该分区中的所有记录时，将通过将此值7.32除以计数(即2)来输出聚合，这将是正确的平均值。

2440
01:02:04,615 --> 01:02:06,150
0,555 555,675 675,870 870,1170 1170,1535
averages in a continuous form

2441
01:02:06,320 --> 01:02:07,690
0,260 260,485 485,635 635,940 1020,1370
and that's not precise. Average

2442
01:02:07,690 --> 01:02:08,860
0,210 210,660 660,810 810,990 990,1170
of averages is not the

2443
01:02:08,860 --> 01:02:10,315
0,165 165,440 910,1185 1185,1305 1305,1455
true average. And so here

2444
01:02:10,315 --> 01:02:11,575
0,195 195,285 285,495 495,845 985,1260
we'll do the sum and

2445
01:02:11,575 --> 01:02:12,685
0,150 150,330 330,585 585,840 840,1110
the count as two different

2446
01:02:12,685 --> 01:02:14,280
0,270 270,450 450,660 660,995 1195,1595
things we keep around. And

2447
01:02:14,330 --> 01:02:15,295
0,305 305,440 440,545 545,740 740,965
when we are done with

2448
01:02:15,295 --> 01:02:16,315
0,330 330,510 510,675 675,855 855,1020
scanning all the records in

2449
01:02:16,315 --> 01:02:17,845
0,135 135,605 775,1185 1185,1425 1425,1530
that partition will output the

2450
01:02:17,845 --> 01:02:19,530
0,435 435,630 630,1050 1050,1365 1365,1685
aggregate by dividing this value

2451
01:02:19,580 --> 01:02:21,475
0,1055 1055,1325 1325,1475 1475,1685 1685,1895
7.32 by the count, which

2452
01:02:21,475 --> 01:02:22,465
0,180 180,480 480,735 735,870 870,990
is two, and that will

2453
01:02:22,465 --> 01:02:23,880
0,90 90,240 240,435 435,725
be the correct average.|
|

2454
01:02:24,040 --> 01:02:25,010
0,275 275,425 425,575 575,710 710,970
So two things are happening.
因此，有两件事正在发生。哈希表现在具有键和值。第二，值可能不是最终值，但可能是某种中间运行的数据结构，它允许我们计算最终值，正如您在Average中看到的那样。

2455
01:02:25,180 --> 01:02:26,685
0,275 275,515 515,725 725,1060 1230,1505
A hash table now has

2456
01:02:26,685 --> 01:02:27,530
0,165 165,330 330,465 465,585 585,845
the key and a value.

2457
01:02:27,940 --> 01:02:28,970
0,275 275,455 455,620 620,755 755,1030
The second is the value

2458
01:02:29,080 --> 01:02:30,555
0,260 260,425 425,730 930,1220 1220,1475
may not be the final

2459
01:02:30,555 --> 01:02:32,480
0,315 315,540 540,810 810,1125 1125,1925
value, but maybe some intermediate

2460
01:02:32,590 --> 01:02:34,650
0,365 365,710 710,1090 1320,1715 1715,2060
running data structure that allows

2461
01:02:34,650 --> 01:02:35,895
0,240 240,405 405,870 870,1020 1020,1245
us to calculate the final

2462
01:02:35,895 --> 01:02:37,020
0,365 415,690 690,825 825,975 975,1125
value, as you can see

2463
01:02:37,020 --> 01:02:38,120
0,120 120,380
with average.|
|

2464
01:02:38,570 --> 01:02:40,300
0,245 245,470 470,755 755,1060 1350,1730
Okay, now of course if
好的，当然，如果把它的平均值加起来等于一分钟，那么我们放在值空间里的就是最小。因为MIN的MIN保证为MIN。数量最多时也是这样。平均水平是不同的。数据库通常还支持中位数和模式等统计聚合，以及在这里处理它的不同方法，以采用高级数据库类。啊，我们谈到如何处理更复杂的统计聚合，以及它们的属性是什么？什么时候才是容易的事？什么时候会有困难？在某些情况下，你必须保留所有的价值观，这就变得复杂了。但有一些方法可以尝试解决这个问题，或者至少减少它的影响。

2465
01:02:40,300 --> 01:02:42,325
0,380 670,960 960,1185 1185,1785 1785,2025
the if the aggregate of

2466
01:02:42,325 --> 01:02:43,290
0,240 240,465 465,540 540,660 660,965
average it to a min

2467
01:02:43,430 --> 01:02:44,320
0,260 260,425 425,635 635,785 785,890
then what we put in

2468
01:02:44,320 --> 01:02:45,370
0,120 120,380 400,690 690,870 870,1050
the value space would just

2469
01:02:45,370 --> 01:02:46,255
0,150 150,360 360,600 600,750 750,885
be min. Because min of

2470
01:02:46,255 --> 01:02:47,215
0,135 135,285 285,735 735,855 855,960
min is guaranteed to be

2471
01:02:47,215 --> 01:02:48,540
0,275 505,780 780,915 915,1050 1050,1325
min. Same thing with maximum

2472
01:02:48,680 --> 01:02:51,370
0,400 450,845 845,1190 1190,1540 2010,2690
count. Average is different. Databases

2473
01:02:51,370 --> 01:02:54,145
0,290 430,795 795,1160 1210,2060 2140,2775
often also support statistical aggregates

2474
01:02:54,145 --> 01:02:55,810
0,285 285,705 705,870 870,1175 1405,1665
like median and mode and

2475
01:02:55,810 --> 01:02:57,340
0,135 135,410 490,890 940,1260 1260,1530
the different ways of dealing

2476
01:02:57,340 --> 01:02:58,570
0,210 210,405 405,740 850,1110 1110,1230
with that here to take

2477
01:02:58,570 --> 01:03:00,430
0,180 180,435 435,770 850,1250 1480,1860
the advanced database class. Ah,

2478
01:03:00,430 --> 01:03:01,540
0,255 255,450 450,750 750,1005 1005,1110
we talk about how do

2479
01:03:01,540 --> 01:03:02,940
0,90 90,240 240,435 435,660 660,1400
you deal with more sophisticated

2480
01:03:02,990 --> 01:03:05,065
0,635 635,1180 1530,1805 1805,1955 1955,2075
statistical aggregation and what are

2481
01:03:05,065 --> 01:03:06,640
0,135 135,425 955,1230 1230,1365 1365,1575
their properties? When is something

2482
01:03:06,640 --> 01:03:07,920
0,345 345,585 585,705 705,930 930,1280
easy? When is something hard?

2483
01:03:08,090 --> 01:03:09,100
0,245 245,380 380,575 575,830 830,1010
And in some cases you

2484
01:03:09,100 --> 01:03:09,775
0,90 90,225 225,375 375,540 540,675
have to keep all the

2485
01:03:09,775 --> 01:03:10,840
0,245 295,570 570,705 705,855 855,1065
values around and that gets

2486
01:03:10,840 --> 01:03:11,845
0,320 460,720 720,795 795,870 870,1005
complicated. But there are ways

2487
01:03:11,845 --> 01:03:13,540
0,180 180,405 405,725 1105,1455 1455,1695
of trying to work around

2488
01:03:13,540 --> 01:03:14,380
0,150 150,285 285,435 435,585 585,840
that or to at least

2489
01:03:14,380 --> 01:03:15,480
0,285 285,480 480,645 645,810 810,1100
reduce the effect of that.|
|

2490
01:03:16,070 --> 01:03:17,900
0,560 560,1090
Statistical aggregates.|
统计数据汇总。|

2491
01:03:17,940 --> 01:03:19,460
0,335 335,665 665,920 920,1175 1175,1520
Are present in database systems.
存在于数据库系统中。您可以在SQL中请求它们，它们将需要进行一些额外的修改。这就是我们希望你们在这份材料中知道的主要事情。

2492
01:03:19,460 --> 01:03:21,230
0,210 210,345 345,620 670,1070 1390,1770
You can ask for those

2493
01:03:21,230 --> 01:03:23,030
0,360 360,950 1090,1395 1395,1575 1575,1800
in sql and they will

2494
01:03:23,030 --> 01:03:24,740
0,285 285,525 525,780 780,1400 1450,1710
require some additional modification. And

2495
01:03:24,740 --> 01:03:25,460
0,180 180,270 270,420 420,585 585,720
that's the main thing we

2496
01:03:25,460 --> 01:03:26,510
0,150 150,300 300,420 420,680 760,1050
want you to know in

2497
01:03:26,510 --> 01:03:28,200
0,290 640,1040
this material.|
|

2498
01:03:28,640 --> 01:03:29,830
0,275 275,550 750,980 980,1055 1055,1190
All right, so in this
好的，在这种情况下，最终结果是根据平均值输出的，非常简单。

2499
01:03:29,830 --> 01:03:31,450
0,285 285,675 675,1070 1120,1395 1395,1620
case, final result is being

2500
01:03:31,450 --> 01:03:33,100
0,315 315,435 435,555 555,830 1330,1650
outputted for that average, pretty

2501
01:03:33,100 --> 01:03:34,500
0,740
straightforward.|
|

2502
01:03:34,500 --> 01:03:35,835
0,195 195,300 300,390 390,650 970,1335
And so with that, we
到此为止，我们今天的课程就结束了。希望你已经看到了。

2503
01:03:35,835 --> 01:03:38,055
0,330 330,645 645,905 1435,1835 1855,2220
conclude today's lecture. Hopefully you've

2504
01:03:38,055 --> 01:03:39,660
0,275 415,815
seen that.|
|

2505
01:03:39,800 --> 01:03:41,190
0,365 365,470 470,605 605,880 990,1390
There's a huge emphasis database
数据库系统非常重视这些运算符算法，这些算法处理大量数据，即使这些数据不能放在内存中。它们需要重新思考你可能认为自己已经知道的基本算法。有各种各样有趣的优化可以拿到桌面上来，评审团还没有完全完成。你能对其进行更多优化吗？答案是肯定的。人们不断地做出各种微妙而有趣的变化，特别是当你开始将东西转移到云端时，你有了新的硬件，改变了很多权衡，并为新的算法创新打开了机会。

2506
01:03:41,210 --> 01:03:43,120
0,365 365,650 650,970 990,1390 1440,1910
systems on these operator algorithms

2507
01:03:43,120 --> 01:03:44,560
0,240 240,510 510,825 825,1185 1185,1440
that work with large amounts

2508
01:03:44,560 --> 01:03:45,940
0,150 150,410 460,860 940,1230 1230,1380
of data, even when it

2509
01:03:45,940 --> 01:03:47,365
0,300 300,435 435,555 555,830 1090,1425
doesn't fit in memory. They

2510
01:03:47,365 --> 01:03:48,690
0,255 255,450 450,930 930,1050 1050,1325
require a rethinking of basic

2511
01:03:48,800 --> 01:03:49,930
0,500 500,665 665,800 800,950 950,1130
algorithms that you might think

2512
01:03:49,930 --> 01:03:51,310
0,210 210,435 435,740 1030,1290 1290,1380
you already know. And there

2513
01:03:51,310 --> 01:03:52,345
0,60 60,240 240,450 450,705 705,1035
are all kinds of interesting

2514
01:03:52,345 --> 01:03:53,605
0,540 540,810 810,945 945,1080 1080,1260
optimizations that you can bring

2515
01:03:53,605 --> 01:03:55,045
0,150 150,270 270,545 1015,1290 1290,1440
to the table, and the

2516
01:03:55,045 --> 01:03:56,155
0,165 165,315 315,465 465,755 775,1110
jury is not yet completely

2517
01:03:56,155 --> 01:03:57,520
0,300 300,660 660,900 900,1065 1065,1365
done on. Can you optimize

2518
01:03:57,520 --> 01:03:58,390
0,150 150,345 345,495 495,660 660,870
it more? The answer is

2519
01:03:58,390 --> 01:03:59,700
0,240 240,465 465,615 615,890 910,1310
yes. People are constantly making

2520
01:03:59,870 --> 01:04:01,320
0,305 305,485 485,680 680,1115 1115,1450
all kinds of subtle and

2521
01:04:01,430 --> 01:04:03,115
0,290 290,580 1020,1370 1370,1565 1565,1685
interesting changes, especially as you

2522
01:04:03,115 --> 01:04:04,030
0,180 180,405 405,615 615,765 765,915
start moving things to the

2523
01:04:04,030 --> 01:04:05,340
0,290 490,720 720,825 825,1005 1005,1310
cloud, you have new hardware

2524
01:04:05,780 --> 01:04:06,760
0,305 305,545 545,740 740,860 860,980
that changes a lot of

2525
01:04:06,760 --> 01:04:08,100
0,135 135,630 630,870 870,1080 1080,1340
the tradeoffs and opens up

2526
01:04:08,150 --> 01:04:10,110
0,380 380,665 665,970 1020,1505 1505,1960
opportunities for new algorithmic innovations.|
|

2527
01:04:11,780 --> 01:04:13,320
0,320 320,640 750,1070 1070,1265 1265,1540
We saw that there are
我们看到了基于散列和排序的方法，这两种方法之间的对偶性将在我们进入下一节课时继续，我们将开始讨论联接和其他算法。

2528
01:04:13,760 --> 01:04:15,340
0,530 530,785 785,1040 1040,1280 1280,1580
hash and sort based methods

2529
01:04:15,340 --> 01:04:17,200
0,285 285,1040 1180,1500 1500,1710 1710,1860
that duality between these two

2530
01:04:17,200 --> 01:04:18,940
0,240 240,615 615,1010 1270,1560 1560,1740
methods will continue as we

2531
01:04:18,940 --> 01:04:20,280
0,255 255,555 555,750 750,975 975,1340
go into the next lecture

2532
01:04:20,570 --> 01:04:21,820
0,275 275,455 455,695 695,980 980,1250
and we start talking about

2533
01:04:21,820 --> 01:04:24,140
0,405 405,615 615,920 1090,1700
joins and other algorithms.|
|

2534
01:04:44,160 --> 01:04:45,890
0,545 545,740 740,1090 1170,1505 1505,1730
28 a gram depending on
一克28克取决于它是不是你还没有打暴徒，但仍然让你闭嘴我用夹子的底部打你，告诉你抬头，告诉我它是什么，我把你的脸吹回去，我有黑板敲打，f不能追踪，风格就像大便，你不能在多米尼加人那里系花边，你可以叫我多米尼加黑色的黑色黑色皮革黑色软木，我整个黑色肮脏的8号鞋把你送到酒吧门口，你得到了你的vatana溜冰鞋，这是你的第一个错误我排队买那个蛋糕，你的粉丝看你等着，我的宏重，跑过网络状态，我怎么活着，告诉我活得很棒。

2535
01:04:45,890 --> 01:04:47,315
0,165 165,480 480,830 940,1200 1200,1425
if it's up you ain't

2536
01:04:47,315 --> 01:04:48,545
0,120 120,270 270,465 465,785 925,1230
hit the mob yet still

2537
01:04:48,545 --> 01:04:49,625
0,195 195,390 390,570 570,795 795,1080
got your shut up I

2538
01:04:49,625 --> 01:04:50,540
0,255 255,390 390,510 510,675 675,915
smack you with the bottom

2539
01:04:50,540 --> 01:04:51,440
0,210 210,390 390,600 600,750 750,900
of a clip and tell

2540
01:04:51,440 --> 01:04:52,670
0,165 165,375 375,680 790,1080 1080,1230
you look up show me

2541
01:04:52,670 --> 01:04:53,615
0,105 105,240 240,450 450,720 720,945
what it sa at for

2542
01:04:53,615 --> 01:04:54,725
0,165 165,345 345,555 555,810 810,1110
I blow your face back

2543
01:04:54,725 --> 01:04:56,045
0,240 240,375 375,540 540,1020 1020,1320
I got a blackboard taps

2544
01:04:56,045 --> 01:04:57,460
0,240 240,510 510,885 885,1110 1110,1415
the f can't trace that

2545
01:04:57,540 --> 01:04:58,775
0,275 275,440 440,680 680,980 980,1235
style is like t for

2546
01:04:58,775 --> 01:04:59,945
0,270 270,510 510,825 825,1005 1005,1170
poop you can't lace that

2547
01:04:59,945 --> 01:05:01,445
0,165 165,330 330,1095 1095,1350 1350,1500
at the Dominican or you

2548
01:05:01,445 --> 01:05:03,215
0,255 255,525 525,675 675,1410 1410,1770
can call me Dominican black

2549
01:05:03,215 --> 01:05:04,925
0,420 420,675 675,1095 1095,1380 1380,1710
sclly black leather black sued

2550
01:05:04,925 --> 01:05:06,515
0,510 510,705 705,960 960,1290 1290,1590
timberins my whole black dirty

2551
01:05:06,515 --> 01:05:07,445
0,225 225,435 435,630 630,795 795,930
eight to send you to

2552
01:05:07,445 --> 01:05:08,780
0,150 150,420 420,785 925,1200 1200,1335
the pur gates you get

2553
01:05:08,780 --> 01:05:10,295
0,750 750,1020 1020,1170 1170,1395 1395,1515
youravatana skate and that's your

2554
01:05:10,295 --> 01:05:11,885
0,255 255,635 865,1155 1155,1335 1335,1590
first mistake I in line

2555
01:05:11,885 --> 01:05:12,890
0,210 210,360 360,570 570,750 750,1005
for that cake your fam

2556
01:05:12,890 --> 01:05:14,165
0,255 255,405 405,680 790,1080 1080,1275
see you wait my grand

2557
01:05:14,165 --> 01:05:15,170
0,165 165,360 360,615 615,810 810,1005
is heavy weight the ran

2558
01:05:15,170 --> 01:05:17,000
0,165 165,375 375,740 1330,1605 1605,1830
through web state how IM

2559
01:05:17,000 --> 01:05:18,185
0,210 210,450 450,675 675,900 900,1185
living to tell I living

2560
01:05:18,185 --> 01:05:23,707
0,395
great.|
|
