1
00:00:29,860 --> 00:00:31,940
0,400 900,1300 1320,1625 1625,1805 1805,2080
{I'll,send,you,guys} some information on Wednesday,|
我会在周三发布一些信息给你们，|

2
00:00:32,200 --> 00:00:33,225
0,245 245,335 335,575 575,800 800,1025
so if you free come
所以如果你有空的话，

3
00:00:33,225 --> 00:00:34,760
0,305 505,810 810,1115
down,| gonna be
|晚上 11 点到 1 点，

4
00:00:34,930 --> 00:00:36,380
0,305 305,470 470,730 810,1130 1130,1450
11 to 1, at night.|
|

5
00:00:38,010 --> 00:00:40,145
0,400 690,1090 1410,1745 1745,1970 1970,2135
Okay, and you, you said
好的，你说你有一个保镖，

6
00:00:40,145 --> 00:00:41,180
0,135 135,255 255,360 360,750 750,1035
you have a bouncer,| that's
|他会忽略身份证，或者你有假身份证，

7
00:00:41,180 --> 00:00:42,620
0,260 610,900 900,1035 1035,1335 1335,1440
gonna ignore the IDs or

8
00:00:42,620 --> 00:00:43,625
0,105 105,225 225,420 420,630 630,1005
you have like fake IDs,|
|

9
00:00:43,625 --> 00:00:44,120
0,105 105,240 240,300 300,375 375,495
that you're going to hand
你会把它当做生意来分发，

10
00:00:44,120 --> 00:00:44,900
0,150 150,285 285,435 435,615 615,780
out on the side as

11
00:00:44,900 --> 00:00:46,670
0,120 120,380 1060,1395 1395,1605 1605,1770
a business,| and all of
|所有这些信息我都不能在课上说出来。

12
00:00:46,670 --> 00:00:47,945
0,290 400,720 720,900 900,1095 1095,1275
that information I cannot say

13
00:00:47,945 --> 00:00:49,610
0,135 135,360 360,695 715,1115 1375,1665
in this class.| Okay, please
|好的，请不要那样做，请不要那样做。

14
00:00:49,610 --> 00:00:50,585
0,210 210,315 315,540 540,765 765,975
don't do that, please don't

15
00:00:50,585 --> 00:00:51,520
0,120 120,395
do that.|
|

16
00:00:51,800 --> 00:00:53,335
0,320 320,640 840,1145 1145,1325 1325,1535
Okay, great, excellent,| and we'll
好的，很好，|我们会为你们中的一些人准备一份旅行报告，

17
00:00:53,335 --> 00:00:54,565
0,105 105,255 255,480 480,815 895,1230
have a trip report for

18
00:00:54,565 --> 00:00:55,465
0,195 195,315 315,465 465,690 690,900
some of you guys make

19
00:00:55,465 --> 00:00:57,030
0,165 165,300 300,510 510,875 1165,1565
it to that,| so. {}|
|所以。|

20
00:00:57,410 --> 00:00:58,600
0,365 365,665 665,875 875,1040 1040,1190
Alright, sorry about taking a
好的，很抱歉花了一点时间才开始，

21
00:00:58,600 --> 00:00:59,365
0,150 150,285 285,420 420,615 615,765
little bit of time to

22
00:00:59,365 --> 00:01:00,280
0,195 195,510 510,690 690,765 765,915
get started,| I had a
|我在办公时间有一大群人，

23
00:01:00,280 --> 00:01:01,195
0,180 180,345 345,525 525,705 705,915
bunch of people at the

24
00:01:01,195 --> 00:01:03,385
0,210 210,485 1555,1875 1875,2085 2085,2190
office hours,| but we're going
|但我们今天要讨论的是并发控制。

25
00:01:03,385 --> 00:01:05,320
0,135 135,300 300,605 805,1205 1225,1935
to talk about the concurrency

26
00:01:05,320 --> 00:01:06,480
0,270 270,590
control today.|
|

27
00:01:06,480 --> 00:01:08,640
0,290 1390,1725 1725,1845 1845,1995 1995,2160
And let's just jump right
让我们直截了当地开始吧。

28
00:01:08,640 --> 00:01:10,515
0,195 195,500 520,920 1180,1530 1530,1875
into it.| Alright, so let's
|好的，让我们开始这个。

29
00:01:10,515 --> 00:01:12,375
0,195 195,465 465,815 1345,1695 1695,1860
get into this.| You've seen
|你已经看到了数据库引擎的示意图，

30
00:01:12,375 --> 00:01:14,370
0,195 195,755 895,1295 1345,1725 1725,1995
this diagram of what a

31
00:01:14,370 --> 00:01:16,185
0,290 400,800 820,1155 1155,1490 1510,1815
database engine looks like,| as
|作为不同组件的模块化体系结构。

32
00:01:16,185 --> 00:01:17,610
0,165 165,525 525,845 1045,1305 1305,1425
a modular architecture for the

33
00:01:17,610 --> 00:01:19,350
0,260 340,740 1270,1500 1500,1590 1590,1740
different components.| We are going
|今天我们将讨论并发控制机制，

34
00:01:19,350 --> 00:01:22,485
0,165 165,375 375,710 880,1280 2470,3135
to talk today about concurrency

35
00:01:22,485 --> 00:01:24,915
0,335 535,1355 1465,1815 1815,2115 2115,2430
control mechanisms,| that hit across
|影响这些不同层，

36
00:01:24,915 --> 00:01:26,700
0,270 270,540 540,1035 1035,1410 1410,1785
these different layers,| which largely
|这在很大程度上影响到操作执行层和访问方法层。

37
00:01:26,700 --> 00:01:28,110
0,255 255,465 465,800 910,1230 1230,1410
hits the operator execution and

38
00:01:28,110 --> 00:01:29,800
0,225 225,465 465,735 735,1250
the access method layers.|
|

39
00:01:29,800 --> 00:01:30,925
0,255 255,435 435,690 690,945 945,1125
In two classes from now,|
从现在开始的两节课中，|

40
00:01:30,925 --> 00:01:32,305
0,225 225,360 360,630 630,990 990,1380
we'll talk about recovery methods,|
我们将讨论恢复方法，|

41
00:01:32,305 --> 00:01:33,280
0,270 270,405 405,540 540,675 675,975
which is at the buffer
这在缓冲池层和磁盘管理器层。

42
00:01:33,280 --> 00:01:34,920
0,270 270,555 555,840 840,1095 1095,1640
pool and disk manager layers.|
|

43
00:01:35,120 --> 00:01:36,175
0,305 305,515 515,695 695,860 860,1055
Now all of this will
现在，所有这些都将变得更加清晰，

44
00:01:36,175 --> 00:01:37,135
0,165 165,285 285,450 450,675 675,960
become a lot more clear,|
|

45
00:01:37,135 --> 00:01:38,515
0,270 270,495 495,735 735,1050 1050,1380
as we jump into what
随着我们深入了解事务管理的含义，

46
00:01:38,515 --> 00:01:40,765
0,255 255,575 745,1145 1315,1715 1975,2250
that transaction management mean,| what
|恢复的含义。

47
00:01:40,765 --> 00:01:42,480
0,240 240,570 570,935 1075,1335 1335,1715
does recovery mean.| So let's
|所以让我们直接开始吧。

48
00:01:43,310 --> 00:01:44,720
0,320 320,560 560,725 725,970
go straight to that.|
|

49
00:01:45,370 --> 00:01:48,090
0,365 365,730 1020,1420 2160,2480 2480,2720
So transaction management allows us
所以，事务管理允许我们在数据库系统中安全地做事情，

50
00:01:48,090 --> 00:01:50,070
0,210 210,500 520,920 1060,1460 1720,1980
to do things safely in

51
00:01:50,070 --> 00:01:52,310
0,120 120,380 490,890 1510,1875 1875,2240
a database system,| in situations
|在同时更新多个东西的情况下。

52
00:01:52,450 --> 00:01:53,810
0,290 290,580 660,950 950,1100 1100,1360
where multiple things are getting

53
00:01:53,830 --> 00:01:55,995
0,400 1230,1580 1580,1805 1805,1955 1955,2165
updated all at the same

54
00:01:55,995 --> 00:01:56,840
0,335
time.|
|

55
00:01:57,080 --> 00:01:57,875
0,105 105,270 270,405 405,525 525,795
Let's start with a simple
让我们从一个简单的例子开始。

56
00:01:57,875 --> 00:01:59,020
0,395
example.|
|

57
00:01:59,260 --> 00:02:02,840
0,400 510,910 1350,1750 2550,3245 3245,3580
Here is a schematic of
这是一个数据库操作的示意图，

58
00:02:02,950 --> 00:02:04,650
0,400 570,970 1110,1400 1400,1550 1550,1700
database operations,| These could be
|这些可以通过一个 SQL 查询来触发，

59
00:02:04,650 --> 00:02:05,900
0,270 270,480 480,585 585,915 915,1250
fired through a SQL query,|
|

60
00:02:06,340 --> 00:02:07,515
0,275 275,545 545,860 860,1040 1040,1175
from the perspective of the
从事务管理组件的角度来看，

61
00:02:07,515 --> 00:02:09,615
0,275 445,845 1045,1445 1765,1995 1995,2100
transaction management component,| we are
|我们将在很大程度上查看对象级别发生的操作。

62
00:02:09,615 --> 00:02:10,880
0,255 255,525 525,690 690,915 915,1265
largely going to look at

63
00:02:11,140 --> 00:02:12,840
0,400 540,935 935,1220 1220,1460 1460,1700
the operations that happen at

64
00:02:12,840 --> 00:02:14,340
0,255 255,540 540,860 1000,1275 1275,1500
the object level.| So imagine
|想象一下，我们启动了一个事务，

65
00:02:14,340 --> 00:02:15,260
0,225 225,390 390,540 540,660 660,920
we fired up a transaction|
|

66
00:02:15,850 --> 00:02:17,130
0,275 275,425 425,605 605,910 960,1280
and that ends up reading
它最终读取一个对象，

67
00:02:17,130 --> 00:02:18,420
0,315 315,710 820,1095 1095,1200 1200,1290
an object,| could be a
|可能是一个记录，也可能是一个页面，

68
00:02:18,420 --> 00:02:19,650
0,260 460,735 735,855 855,975 975,1230
record, could be a page,|
|

69
00:02:19,650 --> 00:02:20,550
0,300 300,405 405,555 555,675 675,900
we're just going to refer
在这节课中，我们只将它们称为对象，

70
00:02:20,550 --> 00:02:21,800
0,225 225,330 330,590 640,945 945,1250
to them as objects here

71
00:02:21,940 --> 00:02:23,565
0,260 260,440 440,760 1020,1340 1340,1625
in this class,| does some
|对该值进行一些检查，

72
00:02:23,565 --> 00:02:25,650
0,365 475,780 780,975 975,1265 1795,2085
checking of that value,| does
|执行一些操作，比如支付，

73
00:02:25,650 --> 00:02:27,045
0,150 150,405 405,720 720,1040 1120,1395
some action like pay| and
|然后通过从 A 中减去 25 来更新它，

74
00:02:27,045 --> 00:02:28,665
0,275 385,735 735,990 990,1295 1315,1620
then updates that A by

75
00:02:28,665 --> 00:02:30,405
0,585 585,1020 1020,1230 1230,1470 1470,1740
subtracting 25 from it| and
|最终将其写入，

76
00:02:30,405 --> 00:02:32,160
0,305 685,1080 1080,1475
eventually writes that,|
|

77
00:02:32,710 --> 00:02:33,870
0,275 275,425 425,665 665,905 905,1160
for the purpose of the
为了讨论事务管理，

78
00:02:33,870 --> 00:02:35,985
0,330 330,555 555,830 970,1370 1870,2115
discussion for transaction management,| we
|我们主要关注读写操作，

79
00:02:35,985 --> 00:02:37,725
0,120 120,395 715,1115 1255,1530 1530,1740
are largely concerned with the

80
00:02:37,725 --> 00:02:39,810
0,335 475,855 855,1235 1375,1770 1770,2085
read and write operations,| that
|这些数据库对象中所发生的，

81
00:02:39,810 --> 00:02:41,325
0,320 430,750 750,1020 1020,1290 1290,1515
happen with each of these

82
00:02:41,325 --> 00:02:43,080
0,305 565,965 1225,1485 1485,1620 1620,1755
database objects,| you can think
|你可以把它们想象成记录、页面、表等，

83
00:02:43,080 --> 00:02:44,630
0,165 165,330 330,480 480,770 1150,1550
of them as records, pages,

84
00:02:44,860 --> 00:02:46,080
0,400 540,815 815,980 980,1115 1115,1220
tables, what have you,| it
|这无关紧要，

85
00:02:46,080 --> 00:02:48,285
0,195 195,440 820,1220 1420,1820 1900,2205
won't matter,| just assume the
|只是假设我们关心的是数据库中对象的读取和写入。

86
00:02:48,285 --> 00:02:49,670
0,195 195,375 375,615 615,965 985,1385
read and writes for objects

87
00:02:49,840 --> 00:02:50,600
0,245 245,320 320,395 395,500 500,760
that are in the database

88
00:02:50,710 --> 00:02:51,860
0,290 290,455 455,605 605,815 815,1150
is what we care about.|
|

89
00:02:52,200 --> 00:02:53,175
0,195 195,330 330,495 495,720 720,975
And we want to have
我们希望有关于这些读写的某些属性。

90
00:02:53,175 --> 00:02:54,770
0,315 315,695 835,1110 1110,1290 1290,1595
certain properties about these {read,and}

91
00:02:54,820 --> 00:02:56,560
0,365 365,695 695,1060
write,| to ensure
|来确保我们定义的正确性概念，

92
00:02:56,660 --> 00:02:58,120
0,455 455,665 665,1085 1085,1235 1235,1460
notions of correctness as we

93
00:02:58,120 --> 00:02:59,260
0,225 225,525 525,795 795,1005 1005,1140
define it,| and that's what
|这就是事务管理所做的。

94
00:02:59,260 --> 00:03:01,160
0,290 370,770 850,1250
transaction management does.|
|

95
00:03:01,160 --> 00:03:02,350
0,210 210,450 450,690 690,885 885,1190
So what could go wrong,|
那么，可能会出什么问题，|

96
00:03:02,430 --> 00:03:04,160
0,275 275,395 395,545 545,850 1470,1730
this is a simple set
这是一组简单的操作，

97
00:03:04,160 --> 00:03:05,320
0,120 120,380 520,765 765,885 885,1160
of actions,| that are presented
|它们被呈现给数据库，

98
00:03:05,370 --> 00:03:07,150
0,245 245,350 350,610 990,1385 1385,1780
to the database| in response
|以响应应用程序可能发送的查询，

99
00:03:07,170 --> 00:03:08,915
0,400 690,980 980,1280 1280,1490 1490,1745
to a query that an

100
00:03:08,915 --> 00:03:11,210
0,395 715,990 990,1185 1185,1505 1915,2295
application might have sent,| and
|可能出现的几个错误。

101
00:03:11,210 --> 00:03:12,260
0,255 255,465 465,705 705,885 885,1050
a couple things could go

102
00:03:12,260 --> 00:03:14,015
0,255 255,620 730,1130 1150,1455 1455,1755
wrong.| So here on the
|所以在右边，

103
00:03:14,015 --> 00:03:15,140
0,315 315,540 540,735 735,945 945,1125
right side,| you see the
|你可以看到银行余额开始的值为 100 ，

104
00:03:15,140 --> 00:03:16,780
0,210 210,555 555,855 855,1160
bank balance starts out,

105
00:03:16,780 --> 00:03:18,360
0,290 640,915 915,1110 1110,1290 1290,1580
has a value of 100,|
|

106
00:03:18,950 --> 00:03:20,365
0,290 290,575 575,935 935,1175 1175,1415
the first thing that happens
发生的第一件事是检查，

107
00:03:20,365 --> 00:03:22,080
0,270 270,480 480,735 735,1085 1315,1715
is does that check| and
|一切看起来是正常的，

108
00:03:22,160 --> 00:03:23,815
0,290 290,545 545,910 1170,1460 1460,1655
everything looks okay,| it says
|它说是的，那个检查通过了，

109
00:03:23,815 --> 00:03:25,750
0,305 655,1035 1035,1335 1335,1655 1675,1935
yes, that check passes,| so
|所以有足够的余额来支付 25 美元，

110
00:03:25,750 --> 00:03:27,390
0,240 240,555 555,950 1000,1320 1320,1640
there's sufficient balance to pay

111
00:03:27,500 --> 00:03:28,705
0,470 470,710 710,920 920,1055 1055,1205
25 dollars,| so this is
|所以这是你去自动取款机要求取款，

112
00:03:28,705 --> 00:03:30,030
0,275 505,810 810,945 945,1050 1050,1325
you going to an ATM

113
00:03:30,200 --> 00:03:31,880
0,380 380,605 605,695 695,1090
asking for a withdrawal,|
|

114
00:03:32,070 --> 00:03:34,070
0,400 900,1325 1325,1460 1460,1625 1625,2000
and pays you that 25
然后付给你 25 美元，

115
00:03:34,070 --> 00:03:35,015
0,270 270,480 480,570 570,735 735,945
dollars,| so you now have
|这样你就有了它，

116
00:03:35,015 --> 00:03:36,770
0,305 505,905 1135,1410 1410,1545 1545,1755
it| and the new balance
|新的余额计算出来，

117
00:03:36,770 --> 00:03:38,705
0,255 255,920 1240,1515 1515,1665 1665,1935
is calculated,| and that balance
|现在，这些余额会记入你的银行账户。

118
00:03:38,705 --> 00:03:39,710
0,300 300,510 510,750 750,915 915,1005
now gets written to your

119
00:03:39,710 --> 00:03:41,090
0,225 225,590 880,1140 1140,1230 1230,1380
bank account.| Okay, so after
|好的，在计算出新的余额后，

120
00:03:41,090 --> 00:03:42,580
0,195 195,345 345,585 585,855 855,1490
the new balance gets calculated,|
|

121
00:03:42,750 --> 00:03:44,750
0,290 290,530 530,880 1440,1760 1760,2000
that last action of bank
银行余额为 75 的最后一个操作，

122
00:03:44,750 --> 00:03:45,995
0,240 240,450 450,870 870,1035 1035,1245
balance of 75| is that
|是你在左侧代码中看到的写入操作。

123
00:03:45,995 --> 00:03:47,380
0,330 330,675 675,900 900,1080 1080,1385
write operation, that you see

124
00:03:47,580 --> 00:03:49,010
0,290 290,515 515,850 960,1265 1265,1430
in that code on the

125
00:03:49,010 --> 00:03:49,960
0,195 195,530
left side.|
|

126
00:03:50,120 --> 00:03:52,780
0,320 320,640 1230,1625 1625,2020
But now, what if,|
但是现在，如果，|

127
00:03:52,780 --> 00:03:54,805
0,290 520,810 810,1100 1330,1695 1695,2025
after the ATM machine spitted
在 ATM 机吐出25美元后，

128
00:03:54,805 --> 00:03:56,780
0,150 150,345 345,735 735,1025
out the 25 dollars,|
|

129
00:03:57,650 --> 00:03:58,870
0,290 290,455 455,650 650,1070 1070,1220
you went and yanked that
你去拉了 ATM 机的电源线，

130
00:03:58,870 --> 00:04:00,295
0,290 430,735 735,990 990,1260 1260,1425
ATM machine power cord,| so
|这样它就不能把写入发回了，

131
00:04:00,295 --> 00:04:00,985
0,75 75,180 180,330 330,510 510,690
that it could not send

132
00:04:00,985 --> 00:04:02,160
0,120 120,270 270,575
the write back,|
|

133
00:04:02,450 --> 00:04:03,520
0,350 350,635 635,830 830,935 935,1070
okay, imagine you were that
好的，想象一下你那么快，

134
00:04:03,520 --> 00:04:04,810
0,195 195,500 580,885 885,1050 1050,1290
fast,| or there's a natural
|或者是自然停电了，

135
00:04:04,810 --> 00:04:07,260
0,240 240,590 1060,1460 1840,2145 2145,2450
power failure,| so the paying
|所以支付操作，

136
00:04:07,580 --> 00:04:08,940
0,400
action,|
|

137
00:04:09,070 --> 00:04:10,410
0,400 450,785 785,1055 1055,1235 1235,1340
and the write to the
和对数据库的写入不是原子的，

138
00:04:10,410 --> 00:04:12,195
0,255 255,555 555,780 780,1430 1450,1785
database is not atomic,| they're
|它们发生在不同的系统中，

139
00:04:12,195 --> 00:04:13,365
0,180 180,375 375,600 600,945 945,1170
happening in different systems,| they
|它们甚至可能在地理上分布得很广，

140
00:04:13,365 --> 00:04:14,820
0,105 105,285 285,495 495,1230 1230,1455
might even be geographically spread

141
00:04:14,820 --> 00:04:16,560
0,320 580,980 1000,1335 1335,1575 1575,1740
across,| and bad things could
|在这些行动之间，可能会发生糟糕的事情。

142
00:04:16,560 --> 00:04:18,260
0,180 180,450 450,800 1120,1410 1410,1700
happen in between those actions.|
|

143
00:04:18,850 --> 00:04:20,085
0,275 275,545 545,800 800,980 980,1235
So how do we make
那么，我们如何确保这笔交易是正确的，

144
00:04:20,085 --> 00:04:21,495
0,285 285,510 510,675 675,965 1075,1410
sure that this transaction is

145
00:04:21,495 --> 00:04:23,070
0,335 595,960 960,1185 1185,1425 1425,1575
correct,| obviously, we don't want
|显然，我们不希望这样，

146
00:04:23,070 --> 00:04:23,910
0,195 195,375 375,555 555,720 720,840
that,| Your bank would be
|你的银行会非常不安，

147
00:04:23,910 --> 00:04:25,065
0,260 280,600 600,795 795,1035 1035,1155
very upset,| if that's how
|如果数据库系统是这样工作的，

148
00:04:25,065 --> 00:04:27,045
0,270 270,660 660,1055 1435,1785 1785,1980
database systems work,| because they
|因为如果发生这个，他们会赔钱。

149
00:04:27,045 --> 00:04:28,360
0,120 120,270 270,495 495,845
would be losing money,

150
00:04:28,360 --> 00:04:29,800
0,180 180,360 360,650 1090,1335 1335,1440
if this happens.| So we
|那么我们希望这种类型的东西受到保护，

151
00:04:29,800 --> 00:04:30,760
0,165 165,375 375,540 540,735 735,960
want this type of stuff

152
00:04:30,760 --> 00:04:31,855
0,135 135,330 330,675 675,930 930,1095
to be protected| and we'll
|我们将讨论如何保护。

153
00:04:31,855 --> 00:04:33,060
0,150 150,345 345,635
talk about how.|
|

154
00:04:33,130 --> 00:04:34,755
0,410 410,665 665,1000 1110,1385 1385,1625
Here's another scenario,| a different
这是另一个场景，|一个不同的场景，

155
00:04:34,755 --> 00:04:35,940
0,365
scenario,|
|

156
00:04:35,980 --> 00:04:37,185
0,365 365,605 605,830 830,1055 1055,1205
showing a different type of
展示了一个我们也需要担心的不同类型的问题。

157
00:04:37,185 --> 00:04:38,205
0,240 240,480 480,705 705,900 900,1020
problems that we also need

158
00:04:38,205 --> 00:04:39,540
0,135 135,345 345,695 955,1215 1215,1335
to worry about.| So this
|所以，这不是停电或诸如此类的事情，

159
00:04:39,540 --> 00:04:40,460
0,105 105,210 210,330 330,555 555,920
is not a power failure

160
00:04:40,750 --> 00:04:42,110
0,395 395,680 680,845 845,1040 1040,1360
or things of that sort,|
|

161
00:04:42,190 --> 00:04:44,580
0,365 365,890 890,1150 1860,2135 2135,2390
but concurrent actions.| So imagine,|
而是同时发生的行动。|所以想象一下，|

162
00:04:44,580 --> 00:04:45,900
0,255 255,405 405,555 555,830 940,1320
you and your significant other
你和你的另一半都共享这个银行账户，

163
00:04:45,900 --> 00:04:47,145
0,330 330,585 585,765 765,1005 1005,1245
both shared this bank account|
|

164
00:04:47,145 --> 00:04:48,840
0,135 135,270 270,545 1015,1350 1350,1695
and you have individual debit
你有个人借记卡，

165
00:04:48,840 --> 00:04:50,520
0,290 550,950 1180,1455 1455,1575 1575,1680
cards,| that allow you to
|允许你从同一个银行账户借记，

166
00:04:50,520 --> 00:04:51,525
0,240 240,375 375,540 540,735 735,1005
debit from that same bank

167
00:04:51,525 --> 00:04:52,320
0,365
account,|
|

168
00:04:52,320 --> 00:04:53,670
0,345 345,615 615,840 840,1140 1140,1350
and you both go to
你们两个去两个不同的 ATM 机，

169
00:04:53,670 --> 00:04:55,790
0,150 150,405 405,720 720,1065 1065,2120
two separate ATMs| and simultaneously
|同时执行这笔交易，

170
00:04:56,600 --> 00:04:58,000
0,305 305,500 500,790 990,1265 1265,1400
run this transaction,| so both
|你们两个都在运行取款 25 美元的操作序列，

171
00:04:58,000 --> 00:04:58,750
0,135 135,240 240,330 330,525 525,750
of you are running these

172
00:04:58,750 --> 00:05:01,375
0,225 225,420 420,680 790,1190 2230,2625
sequence of actions to withdraw

173
00:05:01,375 --> 00:05:02,960
0,465 465,755
25 dollars,|
|

174
00:05:02,960 --> 00:05:04,180
0,320
and,
余额足够在两边检查通过，

175
00:05:04,460 --> 00:05:05,680
0,335 335,620 620,860 860,1040 1040,1220
sufficient balance is checked on

176
00:05:05,680 --> 00:05:07,530
0,225 225,560 1120,1395 1395,1560 1560,1850
both sides,| you get paid,
|你得到付款， ATM 吐出了 25 美元，

177
00:05:07,670 --> 00:05:09,270
0,395 395,695 695,890 890,1310 1310,1600
ATM spits out 25 dollars,|
|

178
00:05:09,770 --> 00:05:11,310
0,320 320,640 660,980 980,1220 1220,1540
your significant other gets paid,|
你的另一半也得到了付款，|

179
00:05:11,570 --> 00:05:13,015
0,290 290,580 750,1070 1070,1280 1280,1445
but now, because both of
但是现在，因为他们两人都读取了原始的银行余额，

180
00:05:13,015 --> 00:05:14,380
0,225 225,495 495,750 750,1065 1065,1365
them read the original bank

181
00:05:14,380 --> 00:05:15,400
0,300 300,555 555,705 705,855 855,1020
balance,| both of them have
|他们都计算出了新的余额为 75 ，

182
00:05:15,400 --> 00:05:16,660
0,465 465,675 675,825 825,1035 1035,1260
calculated the new balance as

183
00:05:16,660 --> 00:05:17,940
0,180 180,770
being 75,|
|

184
00:05:18,780 --> 00:05:21,010
0,400 690,950 950,1160 1160,1510 1830,2230
because everything looks correct,| and
因为一切看起来都是对的，|然后第一个写入，

185
00:05:21,420 --> 00:05:23,885
0,400 840,1100 1100,1265 1265,1570 2190,2465
then the first {one,writes},| the
|第二个覆盖了它，

186
00:05:23,885 --> 00:05:25,505
0,195 195,450 450,1020 1020,1350 1350,1620
second one overwrites that,| and
|现在银行缺少了 25 美元。

187
00:05:25,505 --> 00:05:26,465
0,150 150,315 315,540 540,765 765,960
now the bank is short

188
00:05:26,465 --> 00:05:27,860
0,405 405,695
25 dollars.|
|

189
00:05:27,870 --> 00:05:29,380
0,305 305,470 470,620 620,910
Again, this is not,
再说一次，对银行来说，这不是一个理想的局面，

190
00:05:29,750 --> 00:05:30,960
0,290 290,580 630,875 875,965 965,1210
ideal situation for the banks,|
|

191
00:05:31,100 --> 00:05:32,220
0,305 305,470 470,635 635,830 830,1120
banks would never use database
银行永远不会使用数据库系统，

192
00:05:32,240 --> 00:05:33,940
0,365 365,590 590,1120 1140,1535 1535,1700
systems,| or enterprises wouldn't use
|或者企业不会使用数据库系统，

193
00:05:33,940 --> 00:05:35,635
0,290 310,710 1000,1290 1290,1485 1485,1695
database systems,| if these types
|如果允许这种事情发生。

194
00:05:35,635 --> 00:05:36,535
0,180 180,345 345,540 540,750 750,900
of things are allowed to

195
00:05:36,535 --> 00:05:37,400
0,245
happen.|
|

196
00:05:37,400 --> 00:05:38,615
0,195 195,750 750,885 885,1020 1020,1215
So semantically,| what we wanted
所以，在语义上，|我们希望的是，

197
00:05:38,615 --> 00:05:40,570
0,255 255,555 555,795 795,1055 1555,1955
is that,| we wanted the
|我们希望数据库，

198
00:05:40,710 --> 00:05:43,865
0,400 1140,1540 2010,2410 2580,2915 2915,3155
database,| application was sending this
|发送这个读写请求的应用，

199
00:05:43,865 --> 00:05:45,320
0,165 165,315 315,605 625,1025 1195,1455
read and write request,| that
|由一些应用程序代码编写的，

200
00:05:45,320 --> 00:05:46,510
0,135 135,315 315,495 495,770 790,1190
was written by some application

201
00:05:46,530 --> 00:05:48,440
0,400 840,1205 1205,1475 1475,1805 1805,1910
code,| that is firing up
|向数据库系统发送 SQL 查询，

202
00:05:48,440 --> 00:05:49,415
0,165 165,480 480,750 750,870 870,975
the SQL queries to the

203
00:05:49,415 --> 00:05:51,425
0,245 265,665 955,1215 1215,1475 1705,2010
database system| and now to
|现在应用程序代码编写者没有错误，

204
00:05:51,425 --> 00:05:52,715
0,240 240,510 510,705 705,945 945,1290
no fault of the application

205
00:05:52,715 --> 00:05:54,320
0,285 285,605 925,1275 1275,1380 1380,1605
code writer,| that's what the
|这就是应用程序代码编写者做的事情，

206
00:05:54,320 --> 00:05:55,570
0,330 330,600 600,795 795,975 975,1250
application code writer is doing,|
|

207
00:05:55,770 --> 00:05:57,140
0,395 395,725 725,935 935,1145 1145,1370
effectively writing the code,| that
有效地编写代码，|最终将这些读写操作发送给数据库，

208
00:05:57,140 --> 00:05:58,985
0,195 195,500 700,1035 1035,1350 1350,1845
ends up, sending those {read,write}

209
00:05:58,985 --> 00:06:00,500
0,300 300,525 525,630 630,875 1225,1515
operations to the database,| it
|它感觉是数据库系统在破坏数据，

210
00:06:00,500 --> 00:06:01,715
0,195 195,345 345,590 640,990 990,1215
feels the database system is

211
00:06:01,715 --> 00:06:03,215
0,165 165,630 630,750 750,995 1225,1500
just corrupting the data,| so
|这显然不是我们想要的数据库系统，

212
00:06:03,215 --> 00:06:04,970
0,360 360,725 1135,1440 1440,1620 1620,1755
that's obviously not what we

213
00:06:04,970 --> 00:06:06,155
0,225 225,465 465,600 600,855 855,1185
want of a database system,|
|

214
00:06:06,155 --> 00:06:06,920
0,195 195,360 360,525 525,645 645,765
we want it to be
我们希望它表现良好，

215
00:06:06,920 --> 00:06:08,585
0,210 210,740 880,1140 1140,1395 1395,1665
well behaved,| we want the
|我们想要最后的余额，在这种情况下，是 50 美元。

216
00:06:08,585 --> 00:06:09,850
0,240 240,555 555,780 780,960 960,1265
final balance, in this case,

217
00:06:09,990 --> 00:06:11,360
0,245 245,365 365,575 575,910
to be 50 dollars.|
|

218
00:06:11,540 --> 00:06:12,480
0,260 260,395 395,560 560,695 695,940
Okay, so how do we
好的，那么我们如何处理这些糟糕的系统行为，

219
00:06:12,710 --> 00:06:15,180
0,335 335,670 750,1085 1085,1420 2070,2470
deal with these bad system's,

220
00:06:15,500 --> 00:06:17,240
0,400 510,910
system's behavior,|
|

221
00:06:17,250 --> 00:06:18,995
0,400 660,995 995,1175 1175,1420 1470,1745
and have the database be
并使数据库保持一致，

222
00:06:18,995 --> 00:06:20,495
0,345 345,675 675,1020 1020,1245 1245,1500
coherent,| because ultimately the database
|因为最终数据库是记录的保管者，

223
00:06:20,495 --> 00:06:21,830
0,315 315,635 715,1095 1095,1200 1200,1335
is the keeper of the

224
00:06:21,830 --> 00:06:23,750
0,255 255,675 675,950 1150,1550 1600,1920
records,| That's the master copy
|这是你在银行账户中的主副本，

225
00:06:23,750 --> 00:06:24,590
0,195 195,375 375,555 555,705 705,840
of what you have in

226
00:06:24,590 --> 00:06:25,625
0,105 105,315 315,660 660,900 900,1035
the bank account,| and it
|它必须保持一致，

227
00:06:25,625 --> 00:06:27,050
0,210 210,375 375,555 555,905 1105,1425
has to be consistent,| in
|尽管有这些不同的故障场景。

228
00:06:27,050 --> 00:06:28,040
0,225 225,390 390,555 555,735 735,990
spite of all these different

229
00:06:28,040 --> 00:06:29,580
0,360 360,1040
failure scenarios.|
|

230
00:06:29,820 --> 00:06:31,595
0,275 275,550 570,965 965,1360 1440,1775
So, one system way,| assuming
所以，一种系统方法，|假设你没有断电，

231
00:06:31,595 --> 00:06:32,450
0,195 195,315 315,510 510,630 630,855
that you don't have power

232
00:06:32,450 --> 00:06:33,965
0,350 610,885 885,1035 1035,1260 1260,1515
failure,| is to say, okay,
|是说，好的，我有的第二种选择是，

233
00:06:33,965 --> 00:06:35,470
0,210 210,515 565,855 855,1125 1125,1505
the second type of option

234
00:06:35,610 --> 00:06:37,025
0,260 260,380 380,545 545,850 930,1415
that I had were,| concurrent
|并发操作相互破坏，

235
00:06:37,025 --> 00:06:38,350
0,225 225,480 480,900 900,1035 1035,1325
actions were corrupting each other,|
|

236
00:06:39,080 --> 00:06:40,100
0,300 300,495 495,705 705,960 960,1020
is to say,| I'm going
就是说，|我将拥有一个非常简单的数据库系统，

237
00:06:40,100 --> 00:06:40,865
0,60 60,135 135,255 255,480 480,765
to have a very simple

238
00:06:40,865 --> 00:06:42,340
0,335 355,755
database system,|
|

239
00:06:42,350 --> 00:06:43,960
0,305 305,545 545,770 770,1060 1140,1610
even if two people requested
即使两个人同时请求查询，

240
00:06:43,960 --> 00:06:44,710
0,120 120,345 345,450 450,585 585,750
the queries at the same

241
00:06:44,710 --> 00:06:45,820
0,180 180,360 360,525 525,795 795,1110
time,| I will only run
|我一次也只运行一个查询，

242
00:06:45,820 --> 00:06:47,170
0,320 580,870 870,1080 1080,1230 1230,1350
the one query at a

243
00:06:47,170 --> 00:06:48,115
0,150 150,360 360,435 435,585 585,945
time,| I'm going to queue
|我将把我收到的所有请求都放入队列，

244
00:06:48,115 --> 00:06:49,495
0,270 270,545 685,960 960,1140 1140,1380
everything up, all the requests

245
00:06:49,495 --> 00:06:50,650
0,195 195,485 625,885 885,1005 1005,1155
I get,| I will run
|一次只运行一个查询，

246
00:06:50,650 --> 00:06:51,660
0,195 195,435 435,600 600,735 735,1010
one query at a time|
|

247
00:06:51,920 --> 00:06:54,400
0,400 1350,1625 1625,1805 1805,2110 2130,2480
and I can get a
这样我就可以获得合理、正确的行为，

248
00:06:54,400 --> 00:06:56,485
0,680 760,1110 1110,1460 1720,1965 1965,2085
sensible, correct behavior| for the
|针对我们刚才讨论的场景。

249
00:06:56,485 --> 00:06:57,750
0,240 240,480 480,660 660,915 915,1265
scenario we just talked about.|
|

250
00:06:58,140 --> 00:06:59,130
0,240 240,450 450,690 690,855 855,990
I can also start to
我还可以开始做一些事情，

251
00:06:59,130 --> 00:07:00,030
0,150 150,345 345,525 525,720 720,900
do things,| like before a
|比如在事务开始之前，

252
00:07:00,030 --> 00:07:01,410
0,260 520,840 840,1020 1020,1140 1140,1380
transaction starts,| I can make
|我可以复制整个数据库，

253
00:07:01,410 --> 00:07:02,445
0,270 270,480 480,660 660,825 825,1035
a copy of the entire

254
00:07:02,445 --> 00:07:04,200
0,305 865,1155 1155,1335 1335,1500 1500,1755
database,| make all the changes
|在那里进行所有更改，

255
00:07:04,200 --> 00:07:05,810
0,380 730,1050 1050,1215 1215,1335 1335,1610
there,| and if the transaction
|如果事务成功完成，

256
00:07:06,400 --> 00:07:08,370
0,305 305,610 1260,1610 1610,1880 1880,1970
complete successfully,| so didn't have
|所以没有停电，所有其他类型的事情，

257
00:07:08,370 --> 00:07:09,360
0,120 120,315 315,615 615,855 855,990
a power failure, all of

258
00:07:09,360 --> 00:07:10,340
0,120 120,285 285,480 480,675 675,980
that other kinds of stuff,|
|

259
00:07:10,780 --> 00:07:11,835
0,260 260,410 410,815 815,950 950,1055
I will overwrite it with
我将用新的副本覆盖它。

260
00:07:11,835 --> 00:07:12,920
0,120 120,285 285,575
a new copy.|
|

261
00:07:13,020 --> 00:07:13,940
0,275 275,425 425,575 575,710 710,920
Both of these are really
这两种方法都非常糟糕，

262
00:07:13,940 --> 00:07:15,905
0,350 640,975 975,1185 1185,1460 1690,1965
bad,| from they will give
|因为它们将给你提供某种形式的正确性，

263
00:07:15,905 --> 00:07:17,170
0,180 180,375 375,540 540,750 750,1265
you some form of correctness,|
|

264
00:07:17,250 --> 00:07:18,230
0,260 260,410 410,575 575,815 815,980
but they're really bad from
但从性能角度来看，它们非常糟糕，

265
00:07:18,230 --> 00:07:20,705
0,195 195,530 790,1190 1690,2090 2200,2475
a performance perspective,| because it
|因为它将是一个非常非常慢的数据库系统，

266
00:07:20,705 --> 00:07:22,870
0,165 165,345 345,635 1345,1745 1765,2165
would be a very, very

267
00:07:22,950 --> 00:07:25,780
0,400 570,970 1020,1420 1770,2170 2430,2830
slow database system| and you
|你甚至无法使用它。

268
00:07:25,800 --> 00:07:26,705
0,335 335,410 410,560 560,740 740,905
won't be able to quite

269
00:07:26,705 --> 00:07:27,740
0,210 210,405 405,585 585,825 825,1035
use that, right.| Today, when
|今天，当你去亚马逊，

270
00:07:27,740 --> 00:07:28,745
0,120 120,255 255,530 550,840 840,1005
you go to Amazon| and
|你在检查你的购物车时，

271
00:07:28,745 --> 00:07:30,365
0,395 715,1035 1035,1215 1215,1365 1365,1620
you're checking out your shopping

272
00:07:30,365 --> 00:07:32,210
0,365 475,720 720,915 915,1260 1260,1845
cart,| you know ultimately something
|最终一些事情会发生，发布数据库事务记录，

273
00:07:32,210 --> 00:07:34,180
0,180 180,345 345,720 720,1040 1570,1970
going and issuing database transaction

274
00:07:34,320 --> 00:07:35,890
0,400 420,710 710,1040 1040,1265 1265,1570
records| to debit from your,|
|从你的借记卡中扣除，|

275
00:07:36,180 --> 00:07:37,340
0,320 320,590 590,785 785,905 905,1160
to add to your shopping
添加到你的购物车中，

276
00:07:37,340 --> 00:07:39,305
0,380 490,890 910,1215 1215,1520 1630,1965
cart,| eventually another transaction gets
|最终，另一笔交易被发送到那里，

277
00:07:39,305 --> 00:07:40,505
0,335 475,765 765,885 885,990 990,1200
there,| sent to your credit
|发送给你的信用卡账户，记录下来，

278
00:07:40,505 --> 00:07:42,185
0,335 385,705 705,1025 1135,1455 1455,1680
card account to record that,|
|

279
00:07:42,185 --> 00:07:43,100
0,225 225,450 450,660 660,810 810,915
that amount needs to be
这笔金额需要借记，

280
00:07:43,100 --> 00:07:44,420
0,500 580,870 870,1035 1035,1170 1170,1320
debted| and all of that
|所有这些工作都是正确的，

281
00:07:44,420 --> 00:07:45,875
0,285 285,675 675,975 975,1170 1170,1455
works correctly,| even if multiple
|即使有多个人，

282
00:07:45,875 --> 00:07:46,840
0,395
people,|
|

283
00:07:46,840 --> 00:07:48,100
0,210 210,500 550,840 840,1140 1140,1260
{} multiple account holders on
同一张信用卡上的多个账户持有人，

284
00:07:48,100 --> 00:07:49,570
0,120 120,285 285,525 525,860 1090,1470
the same credit card| are
|同时进行交易，

285
00:07:49,570 --> 00:07:50,755
0,270 270,435 435,710 790,1050 1050,1185
doing the transactions at the

286
00:07:50,755 --> 00:07:52,405
0,195 195,515 595,995 1015,1365 1365,1650
same time,| multiple shopping carts
|创建多个购物车。

287
00:07:52,405 --> 00:07:53,680
0,105 105,330 330,695 925,1170 1170,1275
are getting created.| So we
|所以，我们真的希望能够规模化地进行这项工作，

288
00:07:53,680 --> 00:07:54,460
0,195 195,420 420,555 555,645 645,780
really want to be able

289
00:07:54,460 --> 00:07:55,410
0,150 150,270 270,405 405,615 615,950
to do this at scale,|
|

290
00:07:55,640 --> 00:07:56,320
0,245 245,365 365,425 425,530 530,680
we don't want to do
我们不想一次只做一笔交易，

291
00:07:56,320 --> 00:07:57,660
0,225 225,560 700,960 960,1080 1080,1340
one transactions at a time,|
|

292
00:07:57,770 --> 00:07:58,680
0,245 245,365 365,500 500,635 635,910
you want to be doing
你想要一次处理数千、数万，

293
00:07:58,700 --> 00:08:00,265
0,400 570,890 890,1085 1085,1325 1325,1565
thousands, tens of thousands,| if
|甚至数百万、数十亿的交易。

294
00:08:00,265 --> 00:08:01,375
0,210 210,495 495,720 720,975 975,1110
not millions or billions of

295
00:08:01,375 --> 00:08:02,740
0,275 355,615 615,750 750,1025
transactions at a time.|
|

296
00:08:02,870 --> 00:08:03,520
0,260 260,365 365,470 470,560 560,650
Okay, so how do we
好的，那我们该怎么做，

297
00:08:03,520 --> 00:08:04,420
0,135 135,315 315,540 540,660 660,900
do that,| that's a really
|这是个很难解决的问题。

298
00:08:04,420 --> 00:08:05,860
0,270 270,590 1000,1245 1245,1335 1335,1440
hard problem.| Okay, if we
|好的，如果我们希望更好地利用数据库硬件，

299
00:08:05,860 --> 00:08:07,285
0,165 165,405 405,1050 1050,1305 1305,1425
want better utilization for the

300
00:08:07,285 --> 00:08:09,295
0,245 595,995 1315,1575 1575,1740 1740,2010
database hardware,| we want higher
|我们需要更高的吞吐量和更快的响应时间，

301
00:08:09,295 --> 00:08:11,575
0,545 715,1115 1165,1515 1515,1865 2035,2280
throughput, better response times,| and
|当然，我们希望它是正确的，

302
00:08:11,575 --> 00:08:12,445
0,165 165,405 405,585 585,735 735,870
of course, we want it

303
00:08:12,445 --> 00:08:13,620
0,90 90,285 285,635
to be correct,|
|

304
00:08:13,630 --> 00:08:14,655
0,260 260,470 470,680 680,845 845,1025
so that the right thing
让正确的事情发生，

305
00:08:14,655 --> 00:08:15,780
0,275 295,570 570,795 795,975 975,1125
happens,| and we'll define what
|我们将定义正确的概念是什么。

306
00:08:15,780 --> 00:08:17,150
0,135 135,345 345,630 630,1065 1065,1370
that notion of correctness is.|
|

307
00:08:18,190 --> 00:08:19,365
0,305 305,470 470,650 650,905 905,1175
And in many cases, you
在许多情况下，你也希望这是公平的，

308
00:08:19,365 --> 00:08:19,995
0,180 180,300 300,420 420,510 510,630
also want it to be

309
00:08:19,995 --> 00:08:21,950
0,275 835,1110 1110,1305 1305,1590 1590,1955
fair,| so if multiple transactions
|所以如果同时有多个事务，

310
00:08:22,120 --> 00:08:23,210
0,275 275,410 410,545 545,755 755,1090
come at the same time,|
|

311
00:08:23,260 --> 00:08:24,285
0,245 245,410 410,650 650,845 845,1025
you want all of them
你希望所有的事务都有平等的机会完成，

312
00:08:24,285 --> 00:08:25,245
0,165 165,285 285,465 465,675 675,960
to be given that equal

313
00:08:25,245 --> 00:08:26,700
0,345 345,675 675,1035 1035,1290 1290,1455
chance to complete| and not
|而不是说我会永远把你们中的两个留在后面，

314
00:08:26,700 --> 00:08:27,255
0,165 165,270 270,420 420,480 480,555
just say I'm going to

315
00:08:27,255 --> 00:08:28,455
0,245 265,510 510,660 660,945 945,1200
hold two of you in

316
00:08:28,455 --> 00:08:29,895
0,120 120,365 415,815 955,1245 1245,1440
the back forever| and just
|让其他人继续前进，

317
00:08:29,895 --> 00:08:31,305
0,195 195,330 330,575 685,1085 1105,1410
let the other others go

318
00:08:31,305 --> 00:08:32,420
0,240 240,450 450,690 690,825 825,1115
forward, right,| that's not fair,|
|这不公平，|

319
00:08:32,530 --> 00:08:33,915
0,260 260,425 425,650 650,970 1110,1385
you want to have some
你想要有一些公平的概念。

320
00:08:33,915 --> 00:08:35,780
0,210 210,435 435,935
notion of fairness.|
|

321
00:08:36,090 --> 00:08:37,355
0,365 365,620 620,890 890,1130 1130,1265
And some systems may not
有些系统可能不具备这一点，

322
00:08:37,355 --> 00:08:38,300
0,135 135,270 270,510 510,750 750,945
have that,| sometimes you have
|有时你有优先级，

323
00:08:38,300 --> 00:08:39,530
0,320 430,675 675,780 780,1005 1005,1230
priorities,| where you say I
|你说我想要高优先级的事务完成，

324
00:08:39,530 --> 00:08:41,060
0,135 135,330 330,650 730,1130 1270,1530
want high priorities transactions to

325
00:08:41,060 --> 00:08:42,560
0,150 150,300 300,540 540,920 1210,1500
go through,| but assuming you
|但假设你想要公平，

326
00:08:42,560 --> 00:08:43,415
0,210 210,555 555,660 660,735 735,855
want fairness,| you at least
|你至少想要拥有公平的能力，

327
00:08:43,415 --> 00:08:44,585
0,135 135,285 285,575 685,945 945,1170
want the capability of having

328
00:08:44,585 --> 00:08:46,205
0,575 595,855 855,990 990,1265 1315,1620
fairness,| how you balance that,|
|如何平衡，|

329
00:08:46,205 --> 00:08:47,285
0,180 180,345 345,510 510,945 945,1080
in terms of partitioning your
对工作负载进行分区，让优先级较高工作负载先执行，

330
00:08:47,285 --> 00:08:48,970
0,545 715,990 990,1155 1155,1365 1365,1685
workload, to let higher priority

331
00:08:48,990 --> 00:08:50,705
0,320 320,640 1110,1385 1385,1520 1520,1715
stuff go| is a different
|是另一个问题，

332
00:08:50,705 --> 00:08:51,890
0,335 415,675 675,825 825,1005 1005,1185
issue,| but you do want
|但你确实希望将公平机制构建到数据库系统中。

333
00:08:51,890 --> 00:08:53,765
0,180 180,470 940,1245 1245,1725 1725,1875
the mechanism of fairness to

334
00:08:53,765 --> 00:08:55,265
0,135 135,425 655,1020 1020,1245 1245,1500
be built into the database

335
00:08:55,265 --> 00:08:56,120
0,395
system.|
|

336
00:08:56,870 --> 00:08:58,075
0,335 335,635 635,875 875,1040 1040,1205
Okay, questions so far,| in
好的，到目前为止有什么问题，|关于我们试图实现的目标。

337
00:08:58,075 --> 00:08:58,750
0,165 165,315 315,465 465,585 585,675
terms of what we are

338
00:08:58,750 --> 00:08:59,960
0,135 135,300 300,590
trying to achieve.|
|

339
00:09:02,240 --> 00:09:03,300
0,400
Yep.|
是的。|

340
00:09:03,310 --> 00:09:04,680
0,275 275,455 455,760

341
00:09:05,950 --> 00:09:06,900
0,260 260,395 395,545 545,755 755,950
We will try to,| we
我们试着，|我们会解决所有的问题，

342
00:09:06,900 --> 00:09:08,240
0,180 180,500 610,945 945,1110 1110,1340
will solve all the issues|
|

343
00:09:08,290 --> 00:09:09,620
0,275 275,425 425,665 665,980 980,1330
except the power failure issue|
除了停电问题，|

344
00:09:10,030 --> 00:09:11,480
0,320 320,515 515,755 755,1085 1085,1450
and the power failure issue
停电问题会解决，

345
00:09:11,740 --> 00:09:13,200
0,290 290,455 455,725 725,970 1170,1460
will be solved,| and we
|我们稍后将介绍所有的解决方案，

346
00:09:13,200 --> 00:09:13,935
0,180 180,345 345,480 480,600 600,735
get to all of that

347
00:09:13,935 --> 00:09:15,770
0,275 295,615 615,900 900,1265 1435,1835
solution later on| where the,
|在停电方面有一个非常微妙的问题，

348
00:09:16,420 --> 00:09:17,415
0,290 290,365 365,530 530,845 845,995
there's a very subtle issue

349
00:09:17,415 --> 00:09:18,770
0,165 165,330 330,585 585,935 955,1355
in the power failure stuff,|
|

350
00:09:18,940 --> 00:09:20,370
0,275 275,550 840,1115 1115,1280 1280,1430
which is with all the
在接下来的几节课中将讨论的所有问题，

351
00:09:20,370 --> 00:09:21,045
0,120 120,300 300,450 450,615 615,675
stuff we'll talk about in

352
00:09:21,045 --> 00:09:21,900
0,60 60,210 210,375 375,705 705,855
the next few lectures,| we
|我们可以确保数据库记录最终处于正确的状态。

353
00:09:21,900 --> 00:09:22,710
0,135 135,315 315,495 495,660 660,810
can make sure that the

354
00:09:22,710 --> 00:09:24,720
0,260 460,860 1420,1710 1710,1875 1875,2010
database record ends up in

355
00:09:24,720 --> 00:09:25,860
0,105 105,315 315,680
the right state.|
|

356
00:09:25,860 --> 00:09:26,910
0,165 165,345 345,525 525,780 780,1050
But if the bank has
但如果银行向你支付了 25 美元，

357
00:09:26,910 --> 00:09:28,335
0,210 210,390 390,780 780,1070 1120,1425
paid you 25 dollars| and
|然后停电了，

358
00:09:28,335 --> 00:09:30,360
0,225 225,330 330,555 555,905 1645,2025
there's a power failure,| there's
|就需要采取额外的操作，

359
00:09:30,360 --> 00:09:31,610
0,255 255,630 630,855 855,975 975,1250
extra action that is needed,|
|

360
00:09:32,080 --> 00:09:33,825
0,350 350,605 605,1040 1040,1360 1440,1745
because that 25 dollars has
因为这 25 美元是物理上的操作，

361
00:09:33,825 --> 00:09:35,550
0,180 180,390 390,705 705,1085 1465,1725
been a physical action,| everything
|其他一切都是数字上的操作，

362
00:09:35,550 --> 00:09:36,620
0,135 135,270 270,420 420,690 690,1070
else is a digital action,|
|

363
00:09:36,970 --> 00:09:39,030
0,305 305,610 840,1460 1460,1745 1745,2060
and to undo that action
为了取消支付给你的 25 美元的操作，

364
00:09:39,030 --> 00:09:40,140
0,225 225,390 390,555 555,885 885,1110
of paying you 25 dollars,|
|

365
00:09:40,140 --> 00:09:40,875
0,210 210,345 345,480 480,600 600,735
when they should not have
他们不应该支付的，

366
00:09:40,875 --> 00:09:42,255
0,275 625,885 885,1065 1065,1245 1245,1380
paid,| the bank would have
|银行必须在物理空间进行单独的事务，

367
00:09:42,255 --> 00:09:43,740
0,135 135,300 300,465 465,725 1105,1485
to then do a separate

368
00:09:43,740 --> 00:09:45,240
0,380 460,750 750,1040 1060,1350 1350,1500
transaction in physical space| where
|他们会给你发一封信，说，

369
00:09:45,240 --> 00:09:45,885
0,195 195,300 300,390 390,465 465,645
they'll send you a letter

370
00:09:45,885 --> 00:09:47,325
0,225 225,645 645,945 945,1305 1305,1440
saying,| whoops, we accidentally paid
|哎呀，我们不小心付给了你 25 美元，

371
00:09:47,325 --> 00:09:48,885
0,150 150,495 495,785 1045,1320 1320,1560
you 25 dollars,| but here's
|但这是你的银行账户。

372
00:09:48,885 --> 00:09:50,070
0,225 225,510 510,690 690,930 930,1185
what what your bank account

373
00:09:50,070 --> 00:09:51,225
0,290 610,855 855,930 930,990 990,1155
is.| So there are other
|所以，还有其他方法可以做到这个，

374
00:09:51,225 --> 00:09:52,410
0,255 255,435 435,555 555,815 895,1185
ways to do that,| we
|我们不会，

375
00:09:52,410 --> 00:09:53,550
0,410 490,750 750,870 870,975 975,1140
won't,| we will be able
|我们将能够撤销所有读写，

376
00:09:53,550 --> 00:09:54,945
0,270 270,765 765,975 975,1155 1155,1395
to undo all the {read,and}

377
00:09:54,945 --> 00:09:56,640
0,330 330,570 570,735 735,1175 1405,1695
writes,| if we don't want
|如果我们不希望它们发生。

378
00:09:56,640 --> 00:09:57,600
0,165 165,300 300,560
them to happen.|
|

379
00:09:57,670 --> 00:09:58,800
0,350 350,560 560,770 770,995 995,1130
But, you know, if the
但是，如果事务是，

380
00:09:58,800 --> 00:10:00,345
0,260 370,705 705,945 945,1320 1320,1545
transaction is,| {pay,25 -} dollars
|支付 25 美元是一个物理操作，

381
00:10:00,345 --> 00:10:01,425
0,195 195,330 330,570 570,870 870,1080
is a physical action,| you
|你不能撤销它，

382
00:10:01,425 --> 00:10:03,075
0,210 210,495 495,755 955,1305 1305,1650
can't undo it,| you'll undo
|你可以通过在物理世界中做其他物理操作来撤销这个。

383
00:10:03,075 --> 00:10:04,140
0,165 165,330 330,510 510,765 765,1065
that by doing other physical

384
00:10:04,140 --> 00:10:05,390
0,300 300,510 510,630 630,870 870,1250
actions in the physical world.|
|

385
00:10:05,770 --> 00:10:07,050
0,260 260,665 665,890 890,1190 1190,1280
Okay, similarly,| if there's a
好的，同样，|如果有一个事务发射了一枚导弹，

386
00:10:07,050 --> 00:10:08,220
0,260 280,570 570,765 765,915 915,1170
transaction that fired a missile,|
|

387
00:10:08,220 --> 00:10:09,210
0,120 120,300 300,510 510,660 660,990
you can't undo that missile,|
你就不能撤销那枚导弹，|

388
00:10:09,210 --> 00:10:10,080
0,150 150,315 315,435 435,585 585,870
you can't bring that missile
你不能撤回那枚导弹，

389
00:10:10,080 --> 00:10:11,100
0,290 430,675 675,780 780,900 900,1020
back,| you have to send
|你必须发一封道歉信或其他类似的东西。

390
00:10:11,100 --> 00:10:12,240
0,90 90,570 570,735 735,930 930,1140
an apology letter or something

391
00:10:12,240 --> 00:10:13,550
0,240 240,450 450,660 660,945 945,1310
else like that, right.| So,
|所以，或者一些非常糟糕的事情，

392
00:10:14,290 --> 00:10:15,860
0,320 320,590 590,890 890,1205 1205,1570
or something really bad,| so
|所以就像是，

393
00:10:15,880 --> 00:10:16,880
0,335 335,580
it's like,|
|

394
00:10:16,880 --> 00:10:18,550
0,270 270,735 735,975 975,1290 1290,1670
the undo for physical actions
事务中物理操作的撤消将需要在物理世界中撤消，

395
00:10:18,840 --> 00:10:21,140
0,305 305,610 1110,1475 1475,1790 1790,2300
in transactions will require undo

396
00:10:21,140 --> 00:10:22,805
0,165 165,345 345,645 645,1040 1390,1665
in the physical world,| which
|我们不会讨论这个，

397
00:10:22,805 --> 00:10:24,080
0,135 135,375 375,635 895,1170 1170,1275
we won't cover,| and there
|而且有一些机制可以做到这个，

398
00:10:24,080 --> 00:10:25,145
0,75 75,510 510,660 660,795 795,1065
are mechanisms to do that,|
|

399
00:10:25,145 --> 00:10:26,650
0,240 240,405 405,725 835,1170 1170,1505
that are business related actions,|
那就是与业务相关的操作，|

400
00:10:26,790 --> 00:10:28,030
0,380 380,635 635,860 860,980 980,1240
you'll sometimes get a letter
你有时会收到公司发来的一封信，说，

401
00:10:28,410 --> 00:10:29,585
0,260 260,395 395,620 620,860 860,1175
from your company saying,| whoops,
|哎呀，我们搞错了，抱歉，

402
00:10:29,585 --> 00:10:30,695
0,135 135,270 270,480 480,795 795,1110
we made a mistake, sorry

403
00:10:30,695 --> 00:10:32,135
0,225 225,515 655,1065 1065,1215 1215,1440
about that,| here's what really
|事情的真相是这样的，

404
00:10:32,135 --> 00:10:33,095
0,300 300,555 555,720 720,855 855,960
happened,| oh, and by the
|哦，顺便说一句，这是一张 10 美元的礼品卡来弥补错误。

405
00:10:33,095 --> 00:10:33,890
0,120 120,285 285,405 405,570 570,795
way, here's a 10 dollars

406
00:10:33,890 --> 00:10:35,165
0,285 285,620 730,990 990,1125 1125,1275
gift card to make up

407
00:10:35,165 --> 00:10:36,890
0,120 120,315 315,665 1105,1455 1455,1725
for a mistake.| But all
|但所有读写的数字操作，

408
00:10:36,890 --> 00:10:38,555
0,315 315,705 705,1100 1150,1425 1425,1665
the digital actions that reads

409
00:10:38,555 --> 00:10:39,860
0,135 135,425 625,885 885,1065 1065,1305
and writes,| we will cast
|我们将把它们转换成一个非常严格的结构，

410
00:10:39,860 --> 00:10:41,150
0,180 180,330 330,525 525,830 940,1290
them into a very strict

411
00:10:41,150 --> 00:10:43,235
0,350 670,930 930,1190 1330,1725 1725,2085
structure| to guarantee very well
|以确保我们持有非常明确的正确性属性，

412
00:10:43,235 --> 00:10:45,050
0,270 270,555 555,870 870,1385 1525,1815
defined properties of correctness that

413
00:10:45,050 --> 00:10:46,895
0,150 150,410 850,1250 1480,1740 1740,1845
we will hold,| through the
|通过我们将在今天和接下来的几节课讨论的机制。

414
00:10:46,895 --> 00:10:48,250
0,435 435,645 645,795 795,1035 1035,1355
mechanisms we'll talk about today

415
00:10:48,390 --> 00:10:49,295
0,290 290,440 440,605 605,755 755,905
and going into the next

416
00:10:49,295 --> 00:10:50,660
0,180 180,635
few lectures.|
|

417
00:10:50,700 --> 00:10:52,040
0,320 320,640
Great question.|
好问题。|

418
00:10:52,770 --> 00:10:54,200
0,320 320,640
Other questions?|
还有其他问题吗？|

419
00:10:55,970 --> 00:10:57,080
0,275 275,550
All right.|
好的。|

420
00:10:57,270 --> 00:10:58,460
0,400
So,
所以，我们希望这些操作的任意交错是正确的。

421
00:10:58,560 --> 00:11:01,070
0,350 350,635 635,920 920,1745 1745,2510
we want these arbitrary interleaving

422
00:11:01,070 --> 00:11:03,250
0,240 240,620 760,1160 1540,1860 1860,2180
of operations and be correct.|
|

423
00:11:03,880 --> 00:11:04,810
0,180 180,450 450,675 675,810 810,930
So before we go a
所以在我们更进一步之前，

424
00:11:04,810 --> 00:11:06,445
0,150 150,330 330,620 1180,1470 1470,1635
little bit further,| just want
|只是想要巩固事务的概念，

425
00:11:06,445 --> 00:11:07,870
0,150 150,750 750,975 975,1185 1185,1425
to solidify the notion of

426
00:11:07,870 --> 00:11:09,565
0,290 970,1260 1260,1365 1365,1500 1500,1695
transactions,| you're going to carry
|你要执行这些操作，

427
00:11:09,565 --> 00:11:12,190
0,225 225,495 495,875 1375,1775 2245,2625
out these operations| and the
|我们刚才谈到的数据库

428
00:11:12,190 --> 00:11:13,405
0,380 430,705 705,840 840,990 990,1215
database that we just talked

429
00:11:13,405 --> 00:11:14,875
0,210 210,390 390,695 865,1230 1230,1470
about| is only concerned about
|只关心对数据库对象的读写操作，

430
00:11:14,875 --> 00:11:15,970
0,165 165,345 345,510 510,750 750,1095
the read and write operations

431
00:11:15,970 --> 00:11:17,580
0,225 225,330 330,590 820,1215 1215,1610
to the database objects,| these
|这些物理世界的操作，

432
00:11:17,690 --> 00:11:20,010
0,395 395,755 755,1120 1650,1985 1985,2320
physical world actions| of paying
|支付金额，

433
00:11:20,270 --> 00:11:22,210
0,320 320,640 870,1270 1440,1715 1715,1940
an amount| or you know,
|或者开始发射导弹之类的东西，

434
00:11:22,210 --> 00:11:24,895
0,350 490,890 1060,1460 2140,2475 2475,2685
{ -} starting fighting for

435
00:11:24,895 --> 00:11:26,670
0,375 375,615 615,795 795,1085 1375,1775
missiles, stuff like that,| those
|我们无法修复，

436
00:11:27,290 --> 00:11:28,470
0,290 290,560 560,665 665,845 845,1180
we won't be able to

437
00:11:28,550 --> 00:11:30,330
0,400 630,980 980,1265 1265,1490 1490,1780
repair,| if bad things happen,
|如果发生了糟糕的事情。

438
00:11:30,410 --> 00:11:31,300
0,400
okay.|
|

439
00:11:32,290 --> 00:11:33,510
0,245 245,550 570,845 845,1010 1010,1220
And there's in the advanced
在高级数据库课程中，

440
00:11:33,510 --> 00:11:35,205
0,320 430,830 910,1215 1215,1410 1410,1695
database class,| depending upon the
|根据材料的不同，

441
00:11:35,205 --> 00:11:36,450
0,315 315,525 525,690 690,930 930,1245
material,| that says sometimes we'll
|有时我们会谈论这样的事情，

442
00:11:36,450 --> 00:11:37,530
0,180 180,465 465,735 735,915 915,1080
talk about stuff like that|
|

443
00:11:37,530 --> 00:11:38,870
0,150 150,270 270,420 420,1005 1005,1340
and what are compensating transactions
以及什么是补偿事务和可能发生的事情，

444
00:11:39,070 --> 00:11:40,065
0,305 305,500 500,665 665,830 830,995
and stuff like that that

445
00:11:40,065 --> 00:11:41,445
0,135 135,395 715,990 990,1155 1155,1380
might happen| and what people
|以及人们可能会以其他方式做什么。

446
00:11:41,445 --> 00:11:43,185
0,210 210,485 985,1275 1275,1485 1485,1740
might do as other ways.|
|

447
00:11:43,185 --> 00:11:44,145
0,225 225,405 405,570 570,735 735,960
So, but for the purpose
所以，但为了这门课的目标，

448
00:11:44,145 --> 00:11:45,290
0,210 210,390 390,615 615,885 885,1145
of this class,| we'll just
|我们只会从很多方面来看这个，

449
00:11:45,490 --> 00:11:46,920
0,275 275,550 630,920 920,1190 1190,1430
look at in this in

450
00:11:46,920 --> 00:11:48,120
0,150 150,330 330,570 570,915 915,1200
this many ways,| a more
|范围更有限。

451
00:11:48,120 --> 00:11:49,220
0,290 310,710
limited scope.|
|

452
00:11:49,770 --> 00:11:51,130
0,530 530,710 710,845 845,1040 1040,1360
Reiterating what we talked about,|
重申我们所讨论的内容，|

453
00:11:51,270 --> 00:11:53,465
0,365 365,730 990,1390 1560,1940 1940,2195
we think primarily about read
我们主要考虑读写操作，

454
00:11:53,465 --> 00:11:55,220
0,150 150,405 405,785 1225,1500 1500,1755
and write operations,| you notice
|你注意到，在我的代码中，

455
00:11:55,220 --> 00:11:56,075
0,255 255,390 390,525 525,705 705,855
that in the code that

456
00:11:56,075 --> 00:11:56,855
0,105 105,255 255,390 390,585 585,780
I had,| there was also
|有一个检查，有一个减法，

457
00:11:56,855 --> 00:11:57,875
0,165 165,485 565,810 810,900 900,1020
a check, there was a

458
00:11:57,875 --> 00:11:59,180
0,615 615,720 720,870 870,1080 1080,1305
subtraction,| there was math and
|有数学之类的东西，

459
00:11:59,180 --> 00:12:00,755
0,240 240,450 450,740 1000,1305 1305,1575
stuff like that,| from the
|从我们今天要讨论的事务管理的角度来看，

460
00:12:00,755 --> 00:12:01,715
0,270 270,435 435,615 615,810 810,960
perspective of what we want

461
00:12:01,715 --> 00:12:02,800
0,150 150,360 360,615 615,810 810,1085
to cover today for transaction

462
00:12:02,880 --> 00:12:04,505
0,400 810,1115 1115,1280 1280,1445 1445,1625
management,| all we care about
|我们所关心的是，

463
00:12:04,505 --> 00:12:05,390
0,180 180,345 345,540 540,735 735,885
is,| did an object get
|是否有对象被写入，是否被读取，

464
00:12:05,390 --> 00:12:06,850
0,290 580,825 825,945 945,1140 1140,1460
written, did it get read,|
|

465
00:12:07,280 --> 00:12:08,465
0,230 310,585 585,795 795,1065 1065,1185
and do those reads and
是否这些读写操作最终会以不好的方式相互干扰，

466
00:12:08,465 --> 00:12:09,845
0,210 210,405 405,525 525,1080 1080,1380
writes end up interfering with

467
00:12:09,845 --> 00:12:10,900
0,180 180,345 345,525 525,735 735,1055
each other in bad ways,|
|

468
00:12:11,190 --> 00:12:12,140
0,245 245,350 350,515 515,740 740,950
what are those bad ways|
这些不好的方式是什么，|

469
00:12:12,140 --> 00:12:12,845
0,165 165,315 315,405 405,495 495,705
and how do we prevent
我们如何防止这些不好的方式？

470
00:12:12,845 --> 00:12:14,200
0,225 225,435 435,755
those bad ways?|
|

471
00:12:15,510 --> 00:12:17,165
0,400 870,1175 1175,1310 1310,1430 1430,1655
And how do we prevent
我们如何防止这些不好的方式，

472
00:12:17,165 --> 00:12:18,965
0,270 270,570 570,935 1105,1470 1470,1800
those bad ways,| while allowing
|在允许最大数量的事务在系统上并发工作的同时，

473
00:12:18,965 --> 00:12:20,680
0,330 330,695 985,1260 1260,1425 1425,1715
the maximum number of transactions

474
00:12:20,850 --> 00:12:21,755
0,260 260,410 410,545 545,665 665,905
to work on the system

475
00:12:21,755 --> 00:12:23,350
0,720 720,975 975,1080 1080,1260 1260,1595
concurrently,| that's the hard part.|
|这正是难点。|

476
00:12:24,170 --> 00:12:25,120
0,260 260,410 410,605 605,785 785,950
Because you already saw there's
因为你已经看到有一种简单的方法，

477
00:12:25,120 --> 00:12:26,215
0,120 120,375 375,720 720,960 960,1095
an easy way,| which is
|那就是一次只做一个事务，

478
00:12:26,215 --> 00:12:27,090
0,135 135,285 285,435 435,585 585,875
to just do one transaction

479
00:12:27,140 --> 00:12:28,280
0,260 260,395 395,670
at a time,|
|

480
00:12:28,280 --> 00:12:29,030
0,225 225,345 345,450 450,555 555,750
you want to do better
你想要做得更好。

481
00:12:29,030 --> 00:12:30,980
0,195 195,470 1390,1605 1605,1755 1755,1950
than that.| So it's only
|所以只有这些对象，

482
00:12:30,980 --> 00:12:32,675
0,350 880,1200 1200,1395 1395,1590 1590,1695
these objects,| which we'll just
|我们称为变量 A B 和 C ，

483
00:12:32,675 --> 00:12:33,935
0,225 225,450 450,615 615,1065 1065,1260
refer to as variables A,

484
00:12:33,935 --> 00:12:35,480
0,150 150,330 330,665 1015,1350 1350,1545
B and C,| but if
|但如果你想有一个简单的模型，

485
00:12:35,480 --> 00:12:36,065
0,90 90,195 195,330 330,450 450,585
you want to have a

486
00:12:36,065 --> 00:12:37,010
0,210 210,480 480,660 660,795 795,945
simple model,| you can think
|你可以把它想象成一个记录，

487
00:12:37,010 --> 00:12:37,810
0,135 135,255 255,360 360,510 510,800
of it as a record,|
|

488
00:12:38,580 --> 00:12:40,030
0,395 395,650 650,770 770,1030 1050,1450
but inside a database system,|
但是在数据库系统内部，|

489
00:12:40,140 --> 00:12:41,000
0,275 275,425 425,560 560,710 710,860
in this we cover in
我们在高级数据库类中介绍，

490
00:12:41,000 --> 00:12:42,740
0,150 150,405 405,770 820,1220 1450,1740
the advanced database class,| that
|A 可以是列，

491
00:12:42,740 --> 00:12:43,660
0,210 210,390 390,495 495,630 630,920
a could be a column,|
|

492
00:12:43,890 --> 00:12:45,800
0,260 260,520 1200,1550 1550,1775 1775,1910
which is doing things at
以更精细的粒度执行操作，

493
00:12:45,800 --> 00:12:47,390
0,135 135,480 480,630 630,795 795,1590
a finer level of granularity|
|

494
00:12:47,390 --> 00:12:48,080
0,225 225,345 345,480 480,570 570,690
or it could be a
也可以是页，也可以是文件或数据库，

495
00:12:48,080 --> 00:12:49,130
0,290 430,690 690,825 825,960 960,1050
page or it could be

496
00:12:49,130 --> 00:12:50,195
0,120 120,410 580,825 825,945 945,1065
a file or it could

497
00:12:50,195 --> 00:12:51,650
0,75 75,165 165,425 895,1200 1200,1455
be a database,| some earlier
|一些较早版本的数据库，

498
00:12:51,650 --> 00:12:54,170
0,315 315,540 540,1250 1840,2145 2145,2520
versions of databases,| like Mongo
|比如 Mongo ，在某一时刻执行并发操作时会锁住整个数据库，

499
00:12:54,170 --> 00:12:55,490
0,225 225,465 465,770 910,1170 1170,1320
at one point to do

500
00:12:55,490 --> 00:12:57,125
0,690 690,945 945,1170 1170,1410 1410,1635
concurrency would lock the entire

501
00:12:57,125 --> 00:12:58,475
0,305 655,915 915,1095 1095,1185 1185,1350
database,| they don't do that
|他们现在不这么做了，

502
00:12:58,475 --> 00:13:01,000
0,305 595,995 1345,1605 1605,1865 2125,2525
now,| but the {} the,
|但是一组对象，

503
00:13:01,110 --> 00:13:02,975
0,400 510,910 1200,1490 1490,1640 1640,1865
the, the set of that

504
00:13:02,975 --> 00:13:04,640
0,225 225,360 360,635 745,1145 1285,1665
object| or the {} {A,B}
|或者 A B 和 C 只是指的是数据库对象。

505
00:13:04,640 --> 00:13:05,795
0,285 285,525 525,795 795,1020 1020,1155
and C just referred to

506
00:13:05,795 --> 00:13:07,250
0,240 240,635 775,1065 1065,1275 1275,1455
database {} objects, right.| For
|对于今天的目的，

507
00:13:07,250 --> 00:13:08,210
0,120 120,330 330,585 585,795 795,960
the purpose of today,| you
|你可以把它们看作是记录。

508
00:13:08,210 --> 00:13:09,130
0,120 120,300 300,510 510,660 660,920
can think about them as

509
00:13:09,330 --> 00:13:10,300
0,400
records.|
|

510
00:13:10,300 --> 00:13:11,515
0,290 340,690 690,945 945,1110 1110,1215
And everything today in the
接下来两节课的内容会更有意义，

511
00:13:11,515 --> 00:13:12,625
0,150 150,330 330,570 570,885 885,1110
next two classes will make

512
00:13:12,625 --> 00:13:13,345
0,120 120,255 255,420 420,585 585,720
a lot more sense,| if
|如果你选择一个[]模型。

513
00:13:13,345 --> 00:13:14,050
0,105 105,285 285,465 465,585 585,705
you wanted to pick a

514
00:13:14,050 --> 00:13:15,540
0,210 210,525 525,750 750,1010
[] model for that.|
|

515
00:13:17,210 --> 00:13:18,280
0,290 290,580
All right.|
好的。|

516
00:13:18,350 --> 00:13:19,520
0,400

517
00:13:19,710 --> 00:13:21,170
0,305 305,530 530,755 755,1060 1110,1460
How does the database system
数据库系统如何知道事务开始和事务结束，

518
00:13:21,170 --> 00:13:22,310
0,225 225,360 360,495 495,770 850,1140
know that a transaction is

519
00:13:22,310 --> 00:13:23,920
0,290 400,690 690,980 1030,1320 1320,1610
started and transaction is ended,|
|

520
00:13:24,930 --> 00:13:26,510
0,335 335,710 710,815 815,1040 1040,1580
in SQL, you can explicitly
在 SQL 中，你可以显式地放置一条开始事务语句和一条结束事务语句，

521
00:13:26,510 --> 00:13:27,920
0,120 120,315 315,540 540,830 1030,1410
put a begin transaction statement

522
00:13:27,920 --> 00:13:29,440
0,240 240,390 390,600 600,920 1120,1520
and an end transaction statement|
|

523
00:13:29,670 --> 00:13:30,905
0,275 275,455 455,620 620,875 875,1235
to tell the database system,|
告诉数据库系统，|

524
00:13:30,905 --> 00:13:32,015
0,315 315,570 570,750 750,900 900,1110
all the stuff that happened
在这两条语句之间发生的所有事情都是一个事务，

525
00:13:32,015 --> 00:13:33,730
0,285 285,635 1015,1290 1290,1440 1440,1715
in between is a transaction|
|

526
00:13:34,170 --> 00:13:35,120
0,260 260,455 455,695 695,845 845,950
and in between could be
而这两条语句之间可能是多个 SQL 查询。

527
00:13:35,120 --> 00:13:36,720
0,255 255,675 675,1130
multiple SQL queries.|
|

528
00:13:37,890 --> 00:13:38,750
0,275 275,410 410,620 620,695 695,860
If you don't have a
如果你没有开始和结束事务，

529
00:13:38,750 --> 00:13:39,830
0,180 180,285 285,420 420,710 820,1080
begin and end transaction,| like
|就像你在作业中所做的事情，

530
00:13:39,830 --> 00:13:40,745
0,150 150,330 330,540 540,795 795,915
all the stuff you've been

531
00:13:40,745 --> 00:13:42,080
0,150 150,270 270,405 405,695 1075,1335
doing in your homework,| when
|当你启动一个 SQL 查询，

532
00:13:42,080 --> 00:13:42,920
0,135 135,300 300,435 435,555 555,840
you fire up a SQL

533
00:13:42,920 --> 00:13:44,450
0,195 195,870 870,990 990,1230 1230,1530
query,| implicitly, the database system
|数据库系统将隐式地，

534
00:13:44,450 --> 00:13:45,755
0,210 210,360 360,570 570,920 1030,1305
will| put a begin at
|在查询的开始处放置一个开始，

535
00:13:45,755 --> 00:13:46,610
0,165 165,330 330,480 480,600 600,855
the beginning of the query|
|

536
00:13:46,610 --> 00:13:47,450
0,225 225,390 390,555 555,720 720,840
and an end at the
在查询的末尾放置一个结束。

537
00:13:47,450 --> 00:13:48,520
0,90 90,210 210,330 330,620
end of the query.|
|

538
00:13:48,520 --> 00:13:49,540
0,165 165,270 270,530 640,900 900,1020
But a transaction could be
但是一个事务可以是多个查询，

539
00:13:49,540 --> 00:13:51,190
0,660 660,855 855,975 975,1170 1170,1650
{multi,queries}, right,| you can explicitly
|你可以显式地防止开始和结束。

540
00:13:51,190 --> 00:13:52,620
0,210 210,435 435,585 585,860
put begin and end.|
|

541
00:13:52,620 --> 00:13:53,655
0,165 165,390 390,645 645,795 795,1035
You could also put an
你还可以放置一个显式的 ABORT 语句，

542
00:13:53,655 --> 00:13:55,425
0,515 565,1050 1050,1365 1365,1620 1620,1770
explicit ABORT statement,| which is
|也就是说，

543
00:13:55,425 --> 00:13:56,655
0,165 165,450 450,735 735,1005 1005,1230
to say,| so, and instead
|不是最终调用 COMMIT ，

544
00:13:56,655 --> 00:13:57,405
0,120 120,285 285,435 435,585 585,750
of end, it is called

545
00:13:57,405 --> 00:13:58,540
0,195 195,515
a COMMIT,|
|

546
00:13:58,950 --> 00:13:59,930
0,260 260,395 395,545 545,770 770,980
which is to say everything
是说，我从 BEGIN 到这里所做的一切，

547
00:13:59,930 --> 00:14:01,145
0,180 180,330 330,630 630,945 945,1215
I've done from the BEGIN

548
00:14:01,145 --> 00:14:02,690
0,210 210,485 805,1185 1185,1425 1425,1545
to here,| please commit it
|请提交它，让它的变更持久化，

549
00:14:02,690 --> 00:14:03,980
0,165 165,405 405,675 675,1005 1005,1290
and make its changes {permanent

550
00:14:03,980 --> 00:14:04,900
0,290
-},|
|

551
00:14:04,900 --> 00:14:05,770
0,120 120,255 255,435 435,630 630,870
the other way to end
结束事务的另一种方式是 ABORT ，

552
00:14:05,770 --> 00:14:07,000
0,240 240,560 640,915 915,1050 1050,1230
that transaction is to say

553
00:14:07,000 --> 00:14:07,920
0,320
ABORT,|
|

554
00:14:07,920 --> 00:14:09,105
0,105 105,195 195,360 360,650 820,1185
so it may be,| I'm
所以，它可能是，|我可能正在制定度假计划，

555
00:14:09,105 --> 00:14:10,365
0,120 120,240 240,485 505,900 900,1260
trying to make vacation plans,|
|

556
00:14:10,365 --> 00:14:11,120
0,195 195,285 285,390 390,495 495,755
so I do a transaction
所以我做了一个事务来预订机票，

557
00:14:11,620 --> 00:14:13,470
0,260 260,425 425,650 650,970 1560,1850
to book flight tickets,| then
|然后我在代码中做一点搜索，

558
00:14:13,470 --> 00:14:14,055
0,150 150,255 255,345 345,465 465,585
I do a little bit

559
00:14:14,055 --> 00:14:14,985
0,180 180,420 420,585 585,720 720,930
of search in the code|
|

560
00:14:14,985 --> 00:14:16,800
0,225 225,515 835,1125 1125,1590 1590,1815
to find hotel reservations| and
找到酒店预订，|发现没有酒店，

561
00:14:16,800 --> 00:14:17,880
0,180 180,470 490,825 825,915 915,1080
find, whoops, don't have a

562
00:14:17,880 --> 00:14:19,095
0,320 640,870 870,960 960,1095 1095,1215
hotel,| so I could say,|
|所以我可以说，|

563
00:14:19,095 --> 00:14:20,655
0,240 240,540 540,735 735,1025 1285,1560
oh, ABORT this transaction| and
哦，取消这个事务，|ABORT 表示，

564
00:14:20,655 --> 00:14:21,960
0,330 330,665 685,975 975,1140 1140,1305
ABORT says,| I did some
|我做了一些工作，读取和写入，

565
00:14:21,960 --> 00:14:23,720
0,290 400,750 750,855 855,1130
work, reads and writes,|
|

566
00:14:23,720 --> 00:14:24,890
0,320 550,825 825,1020 1020,1080 1080,1170
but I don't think I
但我不认为我能走得更远，

567
00:14:24,890 --> 00:14:26,195
0,135 135,300 300,590 640,990 990,1305
can go further,| something doesn't
|看起来有些不对劲，

568
00:14:26,195 --> 00:14:27,580
0,165 165,455 475,930 930,1110 1110,1385
look right,| ABORT this transaction|
|取消这个事务，|

569
00:14:27,630 --> 00:14:29,090
0,290 290,455 455,730 750,1130 1130,1460
and you could, the application
应用程序可以再次尝试。

570
00:14:29,090 --> 00:14:30,545
0,195 195,330 330,555 555,890 1210,1455
could be trying again.| You
|你可以显式地中止事务，

571
00:14:30,545 --> 00:14:32,200
0,210 210,825 825,1200 1200,1380 1380,1655
could explicitly abort the transaction|
|

572
00:14:32,850 --> 00:14:34,085
0,305 305,590 590,845 845,1025 1025,1235
and sometimes it may be
有时可能是数据库为你中止，

573
00:14:34,085 --> 00:14:35,420
0,165 165,315 315,605 625,1095 1095,1335
that the database abort for

574
00:14:35,420 --> 00:14:36,950
0,270 270,540 540,810 810,1190 1270,1530
you,| because multiple transactions are
|因为多个事务同时发生，

575
00:14:36,950 --> 00:14:37,960
0,180 180,360 360,495 495,690 690,1010
happening at the same time,|
|

576
00:14:38,190 --> 00:14:40,060
0,335 335,650 650,800 800,1505 1505,1870
it detects some unsafe condition|
它检测到一些不安全的条件，|

577
00:14:40,320 --> 00:14:41,315
0,290 290,470 470,740 740,920 920,995
and says, whoops, I'm going
并说，我要为你中止这个事务，

578
00:14:41,315 --> 00:14:42,545
0,90 90,390 390,570 570,845 955,1230
to abort this transaction for

579
00:14:42,545 --> 00:14:43,295
0,105 105,180 180,300 300,525 525,750
you| and you get an
|你会得到 ABORT 代码。

580
00:14:43,295 --> 00:14:44,380
0,360 360,725
ABORT code.|
|

581
00:14:45,000 --> 00:14:47,105
0,275 275,425 425,700 1050,1805 1805,2105
From the transaction manager's perspective,|
从事务管理器的角度来看，|

582
00:14:47,105 --> 00:14:48,050
0,210 210,630 630,765 765,855 855,945
the module that we are
我们今天试图理解和构建的模块，

583
00:14:48,050 --> 00:14:49,535
0,165 165,470 820,1110 1110,1290 1290,1485
trying to understand and build

584
00:14:49,535 --> 00:14:50,480
0,305
today,|
|

585
00:14:50,990 --> 00:14:52,090
0,275 275,410 410,545 545,820 840,1100
it will be presented with
它将被呈现一个 BEGIN 事务，

586
00:14:52,090 --> 00:14:53,635
0,180 180,390 390,680 1090,1380 1380,1545
a BEGIN transaction,| bunch of
|一串读写操作，

587
00:14:53,635 --> 00:14:55,410
0,165 165,330 330,605 1105,1440 1440,1775
read write actions| and eventually
|最终它将获得一个 COMMIT 或一个 ABORT 操作。

588
00:14:55,430 --> 00:14:56,965
0,230 230,365 365,670 840,1220 1220,1535
it will get a COMMIT

589
00:14:56,965 --> 00:14:59,200
0,195 195,375 375,785 1075,1475
or an ABORT action.|
|

590
00:14:59,200 --> 00:15:00,100
0,195 195,570 570,705 705,810 810,900
And that's what we have
这就是我们必须在系统代码中构建的，

591
00:15:00,100 --> 00:15:01,560
0,120 120,380 400,705 705,1010 1060,1460
to build in the system

592
00:15:01,580 --> 00:15:03,870
0,400 600,1000 1140,1540 1740,2015 2015,2290
code| to, to do transactions,|
|以进行事务，|

593
00:15:04,310 --> 00:15:05,635
0,260 260,520 630,920 920,1115 1115,1325
so transactions could end by
所以事务可以通过提交结束，

594
00:15:05,635 --> 00:15:07,015
0,395 685,990 990,1140 1140,1245 1245,1380
committing| or they could end
|或者可以通过中止结束，

595
00:15:07,015 --> 00:15:08,425
0,120 120,690 690,945 945,1230 1230,1410
by aborting,| {aborting -} means
|中止意味着取消可能完成的一切，

596
00:15:08,425 --> 00:15:09,490
0,405 405,615 615,765 765,930 930,1065
undo everything that might be

597
00:15:09,490 --> 00:15:10,885
0,260 430,720 720,1010 1030,1275 1275,1395
done,| commit says everything I
|提交是说我做的每一件事都让它持久化。

598
00:15:10,885 --> 00:15:12,600
0,275 355,630 630,795 795,1085
did make it permanent.|
|

599
00:15:14,210 --> 00:15:15,010
0,230 230,320 320,455 455,620 620,800
So they can end in
所以他们可以以这两种方式结束。

600
00:15:15,010 --> 00:15:16,300
0,210 210,390 390,650
those two ways.|
|

601
00:15:16,300 --> 00:15:17,440
0,290 340,615 615,855 855,990 990,1140
And the ABORT could be
ABORT 可能是自己造成的，

602
00:15:17,440 --> 00:15:18,565
0,180 180,600 600,795 795,930 930,1125
self inflicted,| as we talked
|正如我们所讨论的，

603
00:15:18,565 --> 00:15:20,680
0,335 805,1185 1185,1425 1425,1650 1650,2115
about,| application could have explicitly
|应用程序可以显式地放入 ABORT 调用，

604
00:15:20,680 --> 00:15:21,510
0,105 105,195 195,300 300,540 540,830
put an {ABORT -} call,|
|

605
00:15:21,680 --> 00:15:22,480
0,290 290,440 440,560 560,680 680,800
or it could be that,|
或者可能是，|

606
00:15:22,480 --> 00:15:23,620
0,135 135,410 430,780 780,1020 1020,1140
the database system has to
数据库系统由于某种原因而不得不中止，

607
00:15:23,620 --> 00:15:25,285
0,255 255,435 435,600 600,890 1270,1665
abort for some reason| to
|以完成我们所讨论的所有安全保证。

608
00:15:25,285 --> 00:15:26,670
0,255 255,390 390,630 630,990 990,1385
do all this safety guarantee

609
00:15:26,750 --> 00:15:27,895
0,320 320,515 515,740 740,980 980,1145
that we talked about.| And
|我们将看到不同方式，

610
00:15:27,895 --> 00:15:29,380
0,365 445,705 705,945 945,1260 1260,1485
we'll look at different ways|
|

611
00:15:29,380 --> 00:15:30,210
0,150 150,270 270,390 390,540 540,830
in which {ABORT -} happens
在数据库系统中发生的 ABORT ，

612
00:15:30,260 --> 00:15:31,690
0,260 260,380 380,635 635,1030 1140,1430
inside a database system| over
|在接下来的几节课中。

613
00:15:31,690 --> 00:15:32,700
0,120 120,255 255,435 435,555 555,1010
the next couple of lectures.|
|

614
00:15:34,600 --> 00:15:36,135
0,400 780,1070 1070,1235 1235,1385 1385,1535
Okay, many of you might
好的，你们中的很多人可能都听说过 ACID ，

615
00:15:36,135 --> 00:15:37,485
0,180 180,485 505,870 870,1140 1140,1350
have heard of this thing

616
00:15:37,485 --> 00:15:39,075
0,240 240,575 955,1290 1290,1425 1425,1590
called ACID,| it's a cool
|这是个很酷的首字母缩写，

617
00:15:39,075 --> 00:15:42,300
0,605 835,1235 1435,1835 2035,2435
acronym,| {} that was,|
|那是，|

618
00:15:42,370 --> 00:15:43,455
0,275 275,455 455,695 695,905 905,1085
that the community came up,|
社区想出来的，|

619
00:15:43,455 --> 00:15:44,610
0,285 285,540 540,735 735,975 975,1155
with a couple guys who
几个人想出来的，

620
00:15:44,610 --> 00:15:47,840
0,120 120,270 270,560 670,1070 2830,3230
came up with,| {} to,
|表示我们想要这些事务的属性是什么。

621
00:15:48,310 --> 00:15:49,250
0,275 275,410 410,515 515,650 650,940
say what are the properties

622
00:15:49,300 --> 00:15:50,510
0,275 275,500 500,725 725,905 905,1210
we want of these transactions.|
|

623
00:15:52,140 --> 00:15:54,610
0,400 660,920 920,1180 1200,1535 1535,2470
And the properties are atomicity
属性是，原子性、一致性、隔离性和持久性。

624
00:15:54,690 --> 00:15:57,680
0,770 770,1420 1440,1805 1805,2440
consistency, isolation and durability.|
|

625
00:15:57,750 --> 00:15:59,345
0,245 245,470 470,730 900,1295 1295,1595
So let's go through each
所以，让我们逐一查看这些内容，

626
00:15:59,345 --> 00:16:01,660
0,165 165,300 300,575 1135,1965 1965,2315
one of those,| atomicity says,|
|原子性表示，|

627
00:16:02,560 --> 00:16:03,640
0,120 120,270 270,420 420,680 820,1080
I have a transaction that
我有一个事务执行一大堆读写操作，

628
00:16:03,640 --> 00:16:04,450
0,120 120,240 240,405 405,615 615,810
did a whole bunch of

629
00:16:04,450 --> 00:16:05,700
0,180 180,470
read writes,|
|

630
00:16:05,700 --> 00:16:07,000
0,350
and,
当我说 COMMIT 时，

631
00:16:07,190 --> 00:16:09,010
0,335 335,590 590,875 875,1240 1530,1820
when I say COMMIT,| everything
|一切都应该提交到数据库中，

632
00:16:09,010 --> 00:16:10,960
0,135 135,330 330,680 1090,1490 1690,1950
should have committed to the

633
00:16:10,960 --> 00:16:12,115
0,260 490,750 750,855 855,975 975,1155
database| or if I say
|或者如果我说 ABORT ，

634
00:16:12,115 --> 00:16:13,225
0,285 285,600 600,780 780,885 885,1110
ABORT,| nothing should have happened.|
|则不应该发生任何事情。|

635
00:16:13,225 --> 00:16:14,275
0,195 195,360 360,605 655,915 915,1050
So it's like I want
所以，就像我想要这个事务的全部或没有的属性，

636
00:16:14,275 --> 00:16:15,550
0,210 210,495 495,705 705,930 930,1275
this all or nothing property

637
00:16:15,550 --> 00:16:17,125
0,240 240,390 390,680 1090,1395 1395,1575
of this transaction,| even though
|即使可能发生了很多读取和写入，

638
00:16:17,125 --> 00:16:18,190
0,165 165,345 345,600 600,885 885,1065
lots of {reads,and} writes might

639
00:16:18,190 --> 00:16:20,190
0,120 120,380 820,1220 1360,1680 1680,2000
have happened,| {} in this,
|在这个事务中，

640
00:16:20,390 --> 00:16:21,940
0,260 260,395 395,670 780,1175 1175,1550
in this transaction, right,| it
|对它应该感觉到它是原子的，

641
00:16:21,940 --> 00:16:22,870
0,270 270,450 450,615 615,750 750,930
it should feel like it's

642
00:16:22,870 --> 00:16:24,040
0,510 510,750 750,900 900,1050 1050,1170
atomic, right,| so it's very
|所以这非常像，

643
00:16:24,040 --> 00:16:25,135
0,180 180,470 520,795 795,945 945,1095
much like,| what you see
|你在处理器中看到的原子指令，

644
00:16:25,135 --> 00:16:27,930
0,165 165,720 720,1080 1080,1475 2395,2795
with atomic instructions in, in,

645
00:16:28,340 --> 00:16:29,980
0,305 305,935 935,1205 1205,1430 1430,1640
in processors,| but now this
|但现在这是针对多个读取和写入的，

646
00:16:29,980 --> 00:16:30,970
0,120 120,240 240,500 520,810 810,990
is for multiple reads and

647
00:16:30,970 --> 00:16:32,680
0,290 400,690 690,980 1090,1455 1455,1710
writes,| those {reads,and} writes may
|这些读写可能会将数据溢出到磁盘，

648
00:16:32,680 --> 00:16:34,240
0,290 370,735 735,945 945,1155 1155,1560
be spilling data to disk,|
|

649
00:16:34,240 --> 00:16:35,290
0,150 150,270 270,435 435,735 735,1050
so it's a much higher
所以这是一个更高粒度的问题，

650
00:16:35,290 --> 00:16:36,760
0,735 735,900 900,1065 1065,1230 1230,1470
granularity, right,| so much harder
|所以是更难的问题。

651
00:16:36,760 --> 00:16:37,360
0,350
problem.|
|

652
00:16:38,640 --> 00:16:40,480
0,695 695,1000
Consistency says,|
一致性表示，|

653
00:16:40,910 --> 00:16:42,040
0,500 500,575 575,665 665,845 845,1130
consistency is a little weird
一致性是一个有点奇怪的问题，

654
00:16:42,040 --> 00:16:43,345
0,350 520,750 750,975 975,1170 1170,1305
one,| and I'm actually going
|我将讨论最后讨论这个问题，

655
00:16:43,345 --> 00:16:45,090
0,165 165,485 955,1215 1215,1410 1410,1745
to go to that last,|
|

656
00:16:45,140 --> 00:16:46,150
0,245 245,350 350,470 470,575 575,1010
let me go to isolation|
让我去隔离性，|

657
00:16:46,150 --> 00:16:46,990
0,210 210,345 345,435 435,600 600,840
and I'll come back to
我会回来一致性。

658
00:16:46,990 --> 00:16:50,680
0,710 970,1670 1690,2090 2560,2960 3400,3690
consistency.| Isolation says,| {} if
|隔离性表示，|如果两个事务，

659
00:16:50,680 --> 00:16:51,850
0,180 180,470 610,885 885,1020 1020,1170
two transactions,| like we have
|比如我们有两个借记事务发生，

660
00:16:51,850 --> 00:16:53,250
0,210 210,405 405,660 660,920 1000,1400
those two debit transactions happening,|
|

661
00:16:53,810 --> 00:16:55,555
0,440 440,605 605,920 920,1180 1380,1745
withdrawal of 25 dollars from
从你和你的另一半的银行账户中提取 25 美元，

662
00:16:55,555 --> 00:16:56,635
0,210 210,405 405,735 735,975 975,1080
the bank account for you

663
00:16:56,635 --> 00:16:58,180
0,120 120,285 285,575 595,995
and your significant other,|
|

664
00:16:58,340 --> 00:16:59,695
0,290 290,580 720,1025 1025,1190 1190,1355
we want those to not
我们希望这些不会相互干扰，

665
00:16:59,695 --> 00:17:00,790
0,480 480,645 645,780 780,930 930,1095
interfere with each other,| it
|它应该让人感觉每个事务都是自己发生的。

666
00:17:00,790 --> 00:17:01,920
0,195 195,405 405,615 615,825 825,1130
should feel like each transaction

667
00:17:02,000 --> 00:17:03,480
0,335 335,605 605,940
happened by itself.|
|

668
00:17:03,490 --> 00:17:04,350
0,245 245,395 395,560 560,680 680,860
So even though we don't
所以，即使我们不想一次运行一个事务，

669
00:17:04,350 --> 00:17:05,300
0,120 120,255 255,420 420,645 645,950
want to run one transaction

670
00:17:05,380 --> 00:17:06,540
0,245 245,365 365,640 780,1025 1025,1160
at a time,| we want
|我们也希望系统一次运行一个事务的错觉，

671
00:17:06,540 --> 00:17:07,850
0,165 165,615 615,870 870,1020 1020,1310
the illusion of the system

672
00:17:08,140 --> 00:17:09,870
0,400 690,995 995,1300 1350,1610 1610,1730
running one transaction at a

673
00:17:09,870 --> 00:17:10,935
0,225 225,465 465,645 645,855 855,1065
time,| it should feel like,|
|这应该让我感觉，|

674
00:17:10,935 --> 00:17:12,525
0,195 195,390 390,695 865,1265 1315,1590
when my transaction ran,| I
当我的事务运行时，|整个系统都是我自己拥有的，

675
00:17:12,525 --> 00:17:13,485
0,150 150,255 255,405 405,675 675,960
had the whole system to

676
00:17:13,485 --> 00:17:14,340
0,335
myself,|
|

677
00:17:14,340 --> 00:17:15,675
0,150 150,360 360,600 600,1125 1125,1335
and nothing else interfered with
也没有其他东西干扰我。

678
00:17:15,675 --> 00:17:16,440
0,305
me.|
|

679
00:17:17,310 --> 00:17:18,650
0,245 245,365 365,515 515,790 1110,1340
Does that make sense?| So
这能理解吗？|所以我应该觉得没有人干扰我的工作。

680
00:17:18,650 --> 00:17:19,600
0,135 135,270 270,450 450,645 645,950
it's like I should feel

681
00:17:19,710 --> 00:17:20,825
0,245 245,350 350,785 785,965 965,1115
no one interfered with my

682
00:17:20,825 --> 00:17:21,640
0,275
work.|
|

683
00:17:22,620 --> 00:17:24,965
0,635 635,995 995,1390 1800,2135 2135,2345
Durability says that,| if the
持久性表示，|如果数据库返回给我并说，

684
00:17:24,965 --> 00:17:26,345
0,275 385,720 720,990 990,1170 1170,1380
database comes back to me

685
00:17:26,345 --> 00:17:27,605
0,270 270,480 480,840 840,1065 1065,1260
and says,| I've committed your
|我已经提交了你的事务，

686
00:17:27,605 --> 00:17:28,780
0,275
transaction,|
|

687
00:17:29,650 --> 00:17:31,245
0,380 380,760 930,1220 1220,1370 1370,1595
after that,| even if there's
在这之后，|即使出现故障，磁盘故障或内存故障，

688
00:17:31,245 --> 00:17:32,750
0,165 165,465 465,735 735,1050 1050,1505
some failure, the disk fails

689
00:17:32,950 --> 00:17:35,070
0,335 335,530 530,790 810,1420 1800,2120
or the memory fails,| I
|我也应该能够恢复数据库的该状态，

690
00:17:35,070 --> 00:17:36,105
0,180 180,270 270,420 420,690 690,1035
should be able to recover

691
00:17:36,105 --> 00:17:38,090
0,395 1195,1470 1470,1605 1605,1725 1725,1985
that state of the database,|
|

692
00:17:39,000 --> 00:17:41,260
0,400 420,820 870,1250 1250,1630
with all the commit
带着其中所有的提交信息。

693
00:17:42,440 --> 00:17:44,215
0,400 720,1025 1025,1250 1250,1535 1535,1775
information in that.| So if
|所以，如果我将银行帐户的最终值更改为 75 ，

694
00:17:44,215 --> 00:17:45,385
0,165 165,405 405,720 720,960 960,1170
I had changed the final

695
00:17:45,385 --> 00:17:46,495
0,285 285,510 510,645 645,870 870,1110
value of the bank account

696
00:17:46,495 --> 00:17:48,625
0,150 150,755 1255,1515 1515,1775 1795,2130
to 75,| the database said
|数据库说我已经提交了你的事务，

697
00:17:48,625 --> 00:17:50,350
0,420 420,630 630,795 795,1055 1435,1725
I've committed your transaction, right,|
|

698
00:17:50,350 --> 00:17:51,540
0,225 225,450 450,675 675,900 900,1190
that commit call came back
那个提交调用返回时发出绿色信号，

699
00:17:51,680 --> 00:17:53,320
0,260 260,380 380,560 560,880 1320,1640
with a green signal| and
|然后出现停电，

700
00:17:53,320 --> 00:17:54,360
0,195 195,375 375,465 465,690 690,1040
then there's a power failure,|
|

701
00:17:54,920 --> 00:17:56,395
0,380 380,755 755,1040 1040,1235 1235,1475
when I bring back the
当我把机器拿回来时，

702
00:17:56,395 --> 00:17:57,865
0,270 270,555 555,795 795,990 990,1470
machine,| I should see 75
|我应该看到里面有 75 ，

703
00:17:57,865 --> 00:17:59,455
0,180 180,455 595,930 930,1350 1350,1590
in there,| not 100 which
|而不是它一开始的值 100 。

704
00:17:59,455 --> 00:18:00,355
0,135 135,240 240,420 420,645 645,900
was the value it started

705
00:18:00,355 --> 00:18:01,000
0,365
with.|
|

706
00:18:02,880 --> 00:18:04,760
0,350 350,590 590,785 785,1085 1085,1880
Now, going back to consistency,|
现在，回到一致性上来，|

707
00:18:04,760 --> 00:18:06,125
0,210 210,470 610,960 960,1170 1170,1365
and I waited for that,|
我一直在等待，|

708
00:18:06,125 --> 00:18:06,905
0,195 195,375 375,510 510,675 675,780
because I'll just put a
因为我会贴上一些标签，

709
00:18:06,905 --> 00:18:08,390
0,180 180,585 585,905 1075,1350 1350,1485
little labels around,| how we
|我们如何做这样的事情。

710
00:18:08,390 --> 00:18:09,860
0,150 150,360 360,680 970,1275 1275,1470
go about doing things like

711
00:18:09,860 --> 00:18:11,660
0,290 610,1230 1230,1335 1335,1515 1515,1800
that.| Consistency is this weird
|一致性是一个奇怪的东西，它表示，

712
00:18:11,660 --> 00:18:13,400
0,285 285,540 540,890
thing, that says,|
|

713
00:18:13,400 --> 00:18:15,250
0,135 135,285 285,560 730,1130 1450,1850
if the database starts consistent,
如果数据库开始是一致的，就像某些定义一样，

714
00:18:15,450 --> 00:18:17,800
0,335 335,635 635,935 935,1270
as for some definition,|
|

715
00:18:18,460 --> 00:18:19,845
0,260 260,410 410,620 620,940 1110,1385
then it should end in
那么它应该以同样的一致状态结束。

716
00:18:19,845 --> 00:18:21,740
0,165 165,455 505,905 985,1385
that same consistent state.|
|

717
00:18:21,810 --> 00:18:23,330
0,260 260,520 690,965 965,1190 1190,1520
Now, that also seems vague,
现在，这看起来也很含糊，对吧？

718
00:18:23,330 --> 00:18:24,260
0,350
right?|
|

719
00:18:24,260 --> 00:18:25,145
0,225 225,375 375,510 510,675 675,885
So what does it mean
那么，数据库开始保持一致性是什么意思，

720
00:18:25,145 --> 00:18:26,740
0,180 180,315 315,575 655,1055 1195,1595
that the database started consistent,|
|

721
00:18:27,500 --> 00:18:28,760
0,240 240,510 510,960 960,1125 1125,1260
{} in SQL, there are
在 SQL 中，有一些东西，

722
00:18:28,760 --> 00:18:29,825
0,240 240,525 525,720 720,885 885,1065
things,| like you can define
|比如你可以定义主键，外键，

723
00:18:29,825 --> 00:18:31,055
0,135 135,375 375,630 630,870 870,1230
a primary key, foreign key,

724
00:18:31,055 --> 00:18:32,260
0,270 270,525 525,720 720,915 915,1205
right,| you've already done that,|
|你已经做过了，|

725
00:18:32,550 --> 00:18:33,860
0,500 500,725 725,860 860,1070 1070,1310
SQL also has these things
SQL 也有这些称为约束的东西，

726
00:18:33,860 --> 00:18:35,120
0,225 225,855 855,975 975,1095 1095,1260
called constraints,| where you can
|其中你可以说，称为检查的东西，

727
00:18:35,120 --> 00:18:38,360
0,290 340,630 630,920 2320,2720 2920,3240
say, at all and things

728
00:18:38,360 --> 00:18:39,695
0,255 255,770 850,1065 1065,1155 1155,1335
called checks,| so a check
|所以，检查可能会说，

729
00:18:39,695 --> 00:18:41,705
0,225 225,545 685,1005 1005,1325 1645,2010
might say,| the price, I've
|我在一张表里有一个 price 字段，

730
00:18:41,705 --> 00:18:42,590
0,120 120,270 270,495 495,735 735,885
got a price field in

731
00:18:42,590 --> 00:18:43,640
0,135 135,410
a table,|
|

732
00:18:43,640 --> 00:18:44,810
0,240 240,480 480,735 735,960 960,1170
and that price should never
这个 price 永远不应该超过 100 ，

733
00:18:44,810 --> 00:18:45,850
0,225 225,465 465,660 660,780 780,1040
be greater than a hundred,|
|

734
00:18:47,470 --> 00:18:48,800
0,245 245,350 350,605 605,965 965,1330
and the database is required,|
数据库需要，|

735
00:18:49,300 --> 00:18:50,775
0,290 290,575 575,935 935,1265 1265,1475
whenever any updates happen to
每当数据库系统发生任何更新时，

736
00:18:50,775 --> 00:18:51,765
0,105 105,345 345,645 645,825 825,990
the database system| to make
|以确保这些东西为真。

737
00:18:51,765 --> 00:18:53,360
0,195 195,405 405,725 895,1245 1245,1595
sure those things hold true.|
|

738
00:18:53,650 --> 00:18:56,080
0,365 365,730 840,1220 1220,1600
So consistently really says,|
所以一致性真正表示，|

739
00:18:56,080 --> 00:18:57,960
0,210 210,500 610,960 960,1245 1245,1880
if the application has specified
如果应用程序已经在 SQL DDL 中指定了，

740
00:18:58,430 --> 00:19:00,700
0,335 335,575 575,980 980,1570 1950,2270
in the SQL DDL,| all
|它们希望数据库正确保存的所有内容，

741
00:19:00,700 --> 00:19:01,645
0,210 210,405 405,585 585,750 750,945
the things that they want

742
00:19:01,645 --> 00:19:03,450
0,165 165,425 535,795 795,1055 1405,1805
the database to hold correct,|
|

743
00:19:05,340 --> 00:19:06,440
0,400
then,
然后，数据库事务不应该弄乱这些。

744
00:19:06,440 --> 00:19:07,970
0,165 165,440 460,860 1275,1380 1380,1530
the database transaction shouldn't mess

745
00:19:07,970 --> 00:19:08,940
0,165 165,440
that up.|
|

746
00:19:09,030 --> 00:19:09,830
0,245 245,335 335,485 485,665 665,800
And the main ways in
发生这种情况的主要方式是通过检查，主键，

747
00:19:09,830 --> 00:19:10,760
0,135 135,285 285,510 510,735 735,930
which that happens is by

748
00:19:10,760 --> 00:19:12,440
0,450 450,800 820,1220 1330,1575 1575,1680
checks, primary keys,| and you
|而且你还可以定义外部检查，

749
00:19:12,440 --> 00:19:14,410
0,195 195,465 465,800 1060,1460 1570,1970
can also define, ah, ah,

750
00:19:14,850 --> 00:19:16,445
0,365 365,560 560,860 860,1205 1205,1595
checks {outside -}| tables and
|表和其他定义约束的方式，

751
00:19:16,445 --> 00:19:18,790
0,330 330,570 570,875 1285,1680 1680,2345
other ways of defining constraints,|
|

752
00:19:18,930 --> 00:19:20,285
0,350 350,575 575,800 800,1115 1115,1355
and you really want all
你真的希望这一切都能保持下去。

753
00:19:20,285 --> 00:19:21,500
0,135 135,300 300,465 465,725
of that to hold.|
|

754
00:19:21,960 --> 00:19:23,030
0,230 230,470 470,665 665,830 830,1070
So it's sort of weird,|
所以这有点奇怪，|

755
00:19:23,030 --> 00:19:24,010
0,195 195,345 345,555 555,720 720,980
but it says if the
但它表明应用程序正确地定义了数据库的结构，

756
00:19:24,060 --> 00:19:27,470
0,400 420,820 930,1330 1980,2380 3060,3410
application has defined the structure

757
00:19:27,470 --> 00:19:28,930
0,210 210,330 330,590 730,1095 1095,1460
of the database correctly,| using
|并使用了 SQL 允许的所有这些检查，

758
00:19:29,070 --> 00:19:30,575
0,275 275,485 485,860 860,1180 1230,1505
everything that SQL allows with

759
00:19:30,575 --> 00:19:31,700
0,210 210,695
these checks,|
|

760
00:19:31,700 --> 00:19:34,340
0,255 255,530 760,1160 2290,2535 2535,2640
the transaction management,| everything that
事务管理，|我们在这里所做的一切都不应该弄乱。

761
00:19:34,340 --> 00:19:35,465
0,135 135,285 285,560 610,960 960,1125
we do here, shouldn't mess

762
00:19:35,465 --> 00:19:36,770
0,165 165,425 595,870 870,1080 1080,1305
that up.| If I said
|如果我说 A 加上 B 必须总是等于 100 ，

763
00:19:36,770 --> 00:19:38,015
0,225 225,480 480,690 690,975 975,1245
A plus B must always

764
00:19:38,015 --> 00:19:39,440
0,225 225,390 390,695 925,1215 1215,1425
equal to 100| and someone
|有人修改了 A ，

765
00:19:39,440 --> 00:19:40,920
0,510 510,830
modified A,|
|

766
00:19:41,270 --> 00:19:42,655
0,395 395,935 935,1100 1100,1220 1220,1385
and modified B in the
并以适当的方式修改了 B ，

767
00:19:42,655 --> 00:19:44,725
0,305 325,725 1555,1800 1800,1935 1935,2070
appropriate way,| so that it
|它在单个事务中仍然等于 100 ，

768
00:19:44,725 --> 00:19:45,660
0,135 135,270 270,450 450,615 615,935
is still equal to 100

769
00:19:46,190 --> 00:19:47,665
0,275 275,425 425,620 620,940 1200,1475
in a single transaction,| the
|事务不应违反任何内容，并更改该约束，

770
00:19:47,665 --> 00:19:50,275
0,275 475,995 1195,1805 1825,2220 2220,2610
transaction shouldn't violate anything and,

771
00:19:50,275 --> 00:19:51,745
0,375 375,675 675,885 885,1305 1305,1470
and change that constraint,| so
|所以，它应该保持这种正确性。

772
00:19:51,745 --> 00:19:53,280
0,120 120,375 375,705 705,990 990,1535
it should maintain that correctness.|
|

773
00:19:54,100 --> 00:19:54,960
0,260 260,425 425,530 530,710 710,860
And we'll come back to
我们会回到这个问题上来，

774
00:19:54,960 --> 00:19:55,665
0,75 75,210 210,390 390,540 540,705
it,| it sounds a little
|这听起来有点含糊，

775
00:19:55,665 --> 00:19:57,720
0,335 505,905 1375,1665 1665,1860 1860,2055
vague,| but in many ways,|
|但在很多方面，|

776
00:19:57,720 --> 00:19:58,845
0,210 210,420 420,645 645,960 960,1125
that C was fitted into
C 都符合 ACID 的定义，

777
00:19:58,845 --> 00:20:00,495
0,300 300,555 555,815 1225,1500 1500,1650
that ACID definition,| because the
|因为数据库真正做的关键事情是 AID ，

778
00:20:00,495 --> 00:20:01,425
0,240 240,495 495,675 675,825 825,930
real key things that the

779
00:20:01,425 --> 00:20:03,120
0,245 325,720 720,1020 1020,1455 1455,1695
database done is AID,| but
|但是如果首字母缩写是 AID ，

780
00:20:03,120 --> 00:20:04,500
0,135 135,405 405,900 900,1080 1080,1380
if the acronym was AID,|
|

781
00:20:04,500 --> 00:20:05,445
0,225 225,345 345,570 570,735 735,945
then it didn't sound as
那么它听起来就没有 ACID 那么好听了，

782
00:20:05,445 --> 00:20:07,095
0,150 150,300 300,605 1105,1440 1440,1650
good as ACID,| and this
|这是在嬉皮士统治湾区和欧洲的时候做的，

783
00:20:07,095 --> 00:20:08,610
0,210 210,480 480,815 895,1320 1320,1515
was done when hippies were

784
00:20:08,610 --> 00:20:09,930
0,315 315,465 465,615 615,890 1000,1320
ruling the Bay Area and

785
00:20:09,930 --> 00:20:11,360
0,285 285,585 585,825 825,1080 1080,1430
Europe| and they wanted acid
|他们想要到处都是酸。

786
00:20:11,590 --> 00:20:14,030
0,400 720,1120 1170,1640 1640,1960 2040,2440
everywhere.| So that's the, {}
|这就是我对 C 是如何插入的理解。

787
00:20:15,130 --> 00:20:16,490
0,380 380,620 620,920 920,1100 1100,1360
that's my understanding of how

788
00:20:16,540 --> 00:20:18,040
0,275 275,530 530,875 875,1120
C was plugged in.|
|

789
00:20:18,580 --> 00:20:20,175
0,305 305,455 455,635 635,875 875,1595
We'll talk about different mechanisms,|
我们将讨论不同的机制，|

790
00:20:20,175 --> 00:20:21,330
0,195 195,480 480,765 765,945 945,1155
and those are what you
这些就是你在蓝色气泡中看到的。

791
00:20:21,330 --> 00:20:22,790
0,315 315,585 585,810 810,1035 1035,1460
see in those blue bubble.|
|

792
00:20:23,380 --> 00:20:25,470
0,725 725,890 890,1420 1440,1805 1805,2090
Autonomity and durability will require
自主性和持久性将需要这种机制来重做和撤销东西，

793
00:20:25,470 --> 00:20:26,985
0,225 225,530 640,960 960,1350 1350,1515
this mechanism to redo and

794
00:20:26,985 --> 00:20:28,980
0,405 405,725 985,1365 1365,1770 1770,1995
undo stuff,| oh, I've changed
|哦，我修改了 A ，我把它推到了磁盘上，

795
00:20:28,980 --> 00:20:29,865
0,255 255,420 420,630 630,765 765,885
A and I've pushed it

796
00:20:29,865 --> 00:20:30,825
0,150 150,330 330,585 585,810 810,960
out to disk,| I've pushed
|我已经将它从我的缓冲池推送到磁盘，

797
00:20:30,825 --> 00:20:31,605
0,120 120,240 240,375 375,495 495,780
it out from my buffer

798
00:20:31,605 --> 00:20:32,850
0,165 165,330 330,785 805,1095 1095,1245
pool to disk,| oh, but
|哦，但我需要取消那个事务，

799
00:20:32,850 --> 00:20:33,980
0,120 120,255 255,390 390,780 780,1130
I need to abort that

800
00:20:34,180 --> 00:20:36,195
0,400 1440,1685 1685,1790 1790,1895 1895,2015
transaction,| so how do I
|那么我怎么才能撤销这个呢？

801
00:20:36,195 --> 00:20:37,320
0,360 360,635
undo that?|
|

802
00:20:37,400 --> 00:20:38,670
0,305 305,560 560,830 830,1010 1010,1270
Oh, I committed a transaction
哦，我用 A 的新值提交了一个事务，

803
00:20:39,200 --> 00:20:40,150
0,260 260,395 395,545 545,740 740,950
with a new value of

804
00:20:40,150 --> 00:20:41,005
0,180 180,315 315,510 510,660 660,855
A,| but it's still sitting
|但它仍然位于我的缓冲池中，

805
00:20:41,005 --> 00:20:41,950
0,165 165,450 450,615 615,765 765,945
my buffer pool,| it didn't
|它没有被放到磁盘上，

806
00:20:41,950 --> 00:20:42,880
0,105 105,240 240,375 375,735 735,930
make it to disk,| I
|我需要重做磁盘复制，

807
00:20:42,880 --> 00:20:43,900
0,120 120,255 255,600 600,765 765,1020
need to redo the disk

808
00:20:43,900 --> 00:20:45,475
0,260 520,780 780,900 900,1320 1320,1575
copy,| so the redo and
|所以 A 和 D 提供了重做和撤消机制，

809
00:20:45,475 --> 00:20:47,320
0,360 360,965 1195,1485 1485,1680 1680,1845
undo mechanisms is what the

810
00:20:47,320 --> 00:20:48,505
0,150 150,315 315,540 540,870 870,1185
A and D provides,| we'll
|我们将使用，今天和下一节课中讨论的内容。

811
00:20:48,505 --> 00:20:49,615
0,180 180,465 465,705 705,930 930,1110
use things that we'll see

812
00:20:49,615 --> 00:20:50,530
0,270 270,510 510,630 630,735 735,915
today and in the next

813
00:20:50,530 --> 00:20:52,080
0,285 285,540 540,750 750,1070
lecture that cover that.|
|

814
00:20:52,090 --> 00:20:54,270
0,275 275,425 425,700 1170,1910 1910,2180
As I said,| consistency is
正如我所说的，|一致性是通过确保在你的 SQL DDL 中定义了完整性约束来提供的，

815
00:20:54,270 --> 00:20:55,350
0,285 285,495 495,720 720,945 945,1080
provided by making sure there

816
00:20:55,350 --> 00:20:57,060
0,255 255,780 780,1320 1320,1560 1560,1710
are integrity constraints defined in

817
00:20:57,060 --> 00:20:58,730
0,150 150,450 450,980 1090,1380 1380,1670
your SQL DDL| and the
|并且事务管理系统不应该违反该约束。

818
00:20:58,810 --> 00:21:00,780
0,400 480,880 930,1310 1310,1580 1580,1970
transaction management system shouldn't violate

819
00:21:00,780 --> 00:21:02,730
0,290 610,1310 1360,1650 1650,1815 1815,1950
that.| Isolation is done by
|隔离是通过称为并发控制的东西来完成的，

820
00:21:02,730 --> 00:21:04,560
0,195 195,435 435,1020 1020,1370 1480,1830
something called concurrency control,| which
|我们也将讨论这一点，

821
00:21:04,560 --> 00:21:05,820
0,330 330,615 615,780 780,1020 1020,1260
we, which we will also

822
00:21:05,820 --> 00:21:07,245
0,135 135,405 405,800 850,1320 1320,1425
look at,| and locking and
|锁和其他机制将在那里发挥作用。

823
00:21:07,245 --> 00:21:08,640
0,150 150,780 780,1035 1035,1185 1185,1395
other mechanisms will come into

824
00:21:08,640 --> 00:21:09,615
0,240 240,530 580,795 795,900 900,975
play there.| So we're going
|所以，我们将深入研究其中的每一个，

825
00:21:09,615 --> 00:21:10,650
0,180 180,390 390,630 630,885 885,1035
to dig into each one

826
00:21:10,650 --> 00:21:11,490
0,120 120,300 300,480 480,675 675,840
of these,| so let's get
|让我们开始吧。

827
00:21:11,490 --> 00:21:12,200
0,320
started.|
|

828
00:21:12,570 --> 00:21:13,960
0,400 510,755 755,950 950,1085 1085,1390
Alright, so that's our agenda,|
好的，这就是我们的日程，|

829
00:21:14,460 --> 00:21:15,635
0,275 275,550 600,860 860,995 995,1175
dive into each of these
深入研究这四个组成部分中的每一个。

830
00:21:15,635 --> 00:21:17,100
0,300 300,695
four components.|
|

831
00:21:17,500 --> 00:21:20,200
0,400 480,1220 1220,1325 1325,1600
So, atomicity of transactions,|
所以，事务的原子性，|

832
00:21:20,990 --> 00:21:22,280
0,275 275,550
there are
执行事务有两种可能的结果，

833
00:21:22,500 --> 00:21:24,035
0,275 275,550 660,950 950,1205 1205,1535
two possible outcomes for executing

834
00:21:24,035 --> 00:21:25,775
0,105 105,365 865,1125 1125,1320 1320,1740
a transaction,| it either commits
|它要么提交，要么被中止，

835
00:21:25,775 --> 00:21:27,065
0,240 240,360 360,465 465,905 1015,1290
or it {aborts -}, right,|
|

836
00:21:27,065 --> 00:21:27,970
0,120 120,225 225,480 480,630 630,905
and the aborts could be
中止可以是显示地，

837
00:21:27,990 --> 00:21:29,260
0,730
explicitly,|
|

838
00:21:29,360 --> 00:21:31,320
0,410 410,575 575,830 830,1210 1560,1960
triggered by the application,| or
由应用程序触发，|或者可能是数据库不安全，

839
00:21:31,760 --> 00:21:32,890
0,305 305,485 485,635 635,890 890,1130
it could be something that

840
00:21:32,890 --> 00:21:34,555
0,120 120,380 400,795 795,1230 1230,1665
the database is something unsafe,|
|

841
00:21:34,555 --> 00:21:35,550
0,165 165,300 300,405 405,690 690,995
I need to abort you|
我需要中止你，|

842
00:21:35,810 --> 00:21:37,285
0,260 260,395 395,670 750,1150 1200,1475
and then that transaction could
然后事务可以重新启动并重新发出该 SQL 语句，

843
00:21:37,285 --> 00:21:39,175
0,420 420,615 615,1050 1050,1325 1435,1890
restart and reissue that SQL

844
00:21:39,175 --> 00:21:39,940
0,305
statement,|
|

845
00:21:40,070 --> 00:21:41,710
0,400 450,695 695,1160 1160,1355 1355,1640
and the DBMS needs to
DBMS 需要提供这些事务这种全部或没有的原子属性。

846
00:21:41,710 --> 00:21:42,720
0,270 270,450 450,615 615,750 750,1010
provide this all or nothing

847
00:21:42,740 --> 00:21:44,935
0,395 395,1025 1025,1330 1620,1955 1955,2195
[] atomic property of these

848
00:21:44,935 --> 00:21:46,220
0,305
transactions.|
|

849
00:21:46,900 --> 00:21:47,775
0,335 335,590 590,680 680,785 785,875
So let's make it a
所以让我们把它变得更具体一点，

850
00:21:47,775 --> 00:21:48,735
0,135 135,300 300,540 540,780 780,960
little bit more concrete,| we've
|我们一直在举这个例子，

851
00:21:48,735 --> 00:21:49,730
0,105 105,300 300,480 480,675 675,995
been playing around with examples,|
|

852
00:21:49,780 --> 00:21:50,850
0,335 335,545 545,695 695,890 890,1070
so we look at a
所以我们在深入研究这个时，看几个场景，

853
00:21:50,850 --> 00:21:52,290
0,195 195,830 880,1170 1170,1320 1320,1440
couple scenarios as we dig

854
00:21:52,290 --> 00:21:53,490
0,195 195,530 610,870 870,990 990,1200
into this.| We take 100
|我们从一个账户中提取 100 美元，

855
00:21:53,490 --> 00:21:54,590
0,255 255,465 465,600 600,780 780,1100
dollars out of an account,|
|

856
00:21:55,270 --> 00:21:57,020
0,290 290,470 470,760 780,1175 1175,1750
but the database system aborts
但在我们转账之前，数据库系统中止事务，

857
00:21:57,040 --> 00:21:58,485
0,260 260,520 600,935 935,1160 1160,1445
the transaction before we transfer

858
00:21:58,485 --> 00:22:00,015
0,395 475,780 780,1085 1135,1395 1395,1530
it, right,| so we want
|所以我们要确保这是正确反映的。

859
00:22:00,015 --> 00:22:02,175
0,120 120,270 270,575 835,1235 1885,2160
to make sure, {} that

860
00:22:02,175 --> 00:22:04,250
0,210 210,495 495,840 840,1235 1675,2075
that is reflected correctly.| Scenario
|第二种场景是，

861
00:22:04,270 --> 00:22:05,160
0,275 275,425 425,560 560,680 680,890
two is,| we take 100
|我们从一个账户中提取 100 美元，

862
00:22:05,160 --> 00:22:06,230
0,255 255,465 465,600 600,765 765,1070
dollars out of an account,|
|

863
00:22:06,280 --> 00:22:07,170
0,260 260,395 395,560 560,665 665,890
but then there's a power
但随后出现了停电，

864
00:22:07,170 --> 00:22:08,570
0,300 300,570 570,765 765,1020 1020,1400
failure,| before we transfer that.|
|在我们转账之前。|

865
00:22:08,590 --> 00:22:09,525
0,320 320,410 410,560 560,755 755,935
We've kind of seen both
我们已经看到了这两个事务，

866
00:22:09,525 --> 00:22:10,710
0,135 135,285 285,575 775,1035 1035,1185
of these transactions,| but just
|但只是给你更多的例子来说明应该是什么，

867
00:22:10,710 --> 00:22:12,470
0,180 180,345 345,570 570,920 1360,1760
giving you more examples of

868
00:22:12,580 --> 00:22:13,770
0,395 395,695 695,860 860,965 965,1190
what that should be,| and,
|而且我们必须确定账户的正确状态，

869
00:22:13,770 --> 00:22:14,775
0,225 225,465 465,705 705,825 825,1005
you know, we have to

870
00:22:14,775 --> 00:22:15,810
0,255 255,525 525,660 660,870 870,1035
determine what's the correct state

871
00:22:15,810 --> 00:22:17,055
0,135 135,300 300,590 610,975 975,1245
of the account| after both
|在这两个事务中止之后。

872
00:22:17,055 --> 00:22:18,900
0,305 535,935 1075,1475
these transaction aborts.|
|

873
00:22:19,280 --> 00:22:20,420
0,400
So,
所以，我们怎么能做一些这样的事情呢，

874
00:22:20,430 --> 00:22:21,515
0,290 290,455 455,620 620,875 875,1085
how can we do some

875
00:22:21,515 --> 00:22:23,855
0,135 135,345 345,665 1495,1725 1725,2340
of this stuff,| the atomity
|原子性部分可以通过两种方式之一来完成，

876
00:22:23,855 --> 00:22:24,815
0,255 255,510 510,645 645,795 795,960
part can be done in

877
00:22:24,815 --> 00:22:26,285
0,120 120,270 270,435 435,695 985,1470
one of two ways,| logging
|日志和跟踪，

878
00:22:26,285 --> 00:22:28,235
0,240 240,815 1225,1515 1515,1725 1725,1950
and shadowing,| one way is
|一种方法是记录我们所做的一切，

879
00:22:28,235 --> 00:22:29,585
0,195 195,485 775,1050 1050,1200 1200,1350
to log everything that we

880
00:22:29,585 --> 00:22:31,480
0,275 625,945 945,1155 1155,1545 1545,1895
do,| so if I'm recording
|所以，如果我记录我的所有操作，

881
00:22:31,710 --> 00:22:33,755
0,320 320,515 515,790 1620,1880 1880,2045
all my actions,| the minute
|我修改某个值从 100 到 75 的那一刻，

882
00:22:33,755 --> 00:22:35,400
0,210 210,435 435,630 630,905
I change a value

883
00:22:35,400 --> 00:22:37,365
0,210 210,600 600,1400 1480,1755 1755,1965
from 100 {to,75},| I can
|我可以记录我的值是 100 ，

884
00:22:37,365 --> 00:22:38,775
0,255 255,465 465,755 805,1170 1170,1410
record that my value was

885
00:22:38,775 --> 00:22:40,515
0,795 795,1020 1020,1185 1185,1320 1320,1740
100,| {I,change} it to 75,|
|我把它改成 75 ，|

886
00:22:40,515 --> 00:22:42,465
0,275 505,840 840,1050 1050,1385 1555,1950
my {before,value} was 100, after
我之前的值是 100 ，之后的值是 75 ，

887
00:22:42,465 --> 00:22:44,220
0,300 300,495 495,1115 1405,1650 1650,1755
value is 75,| now I
|现在我可以获取这些日志，

888
00:22:44,220 --> 00:22:45,630
0,150 150,345 345,570 570,1130 1150,1410
can take those logs| and
|我可以维护这些日志记录，

889
00:22:45,630 --> 00:22:46,800
0,120 120,270 270,560 610,930 930,1170
I can maintain those log

890
00:22:46,800 --> 00:22:49,110
0,320 820,1095 1095,1245 1245,1520 1990,2310
records| and I can store
|我可以在内存中存储这些日志记录，

891
00:22:49,110 --> 00:22:50,640
0,225 225,450 450,770
those log records

892
00:22:50,640 --> 00:22:52,670
0,380 490,890 1150,1440 1440,1680 1680,2030
in memory| and then appropriate
|然后适当的点将其移出到磁盘，

893
00:22:52,720 --> 00:22:53,805
0,380 380,605 605,725 725,890 890,1085
points move it out to

894
00:22:53,805 --> 00:22:55,305
0,545 685,960 960,1110 1110,1275 1275,1500
disk,| once it moves into
|一旦它移动到磁盘中，

895
00:22:55,305 --> 00:22:56,595
0,555 555,825 825,1020 1020,1170 1170,1290
disk,| I know it is
|我知道它就会在那里，

896
00:22:56,595 --> 00:22:57,450
0,135 135,240 240,375 375,630 630,855
going to be there,| it
|它将在停电后幸存下来。

897
00:22:57,450 --> 00:22:58,610
0,180 180,405 405,585 585,810 810,1160
will survive that power failure.|
|

898
00:22:59,280 --> 00:22:59,925
0,135 135,240 240,435 435,525 525,645
If I don't think I
如果我认为我不能信任单个磁盘来保存日志，

899
00:22:59,925 --> 00:23:01,275
0,150 150,330 330,540 540,795 795,1350
can trust a single disk

900
00:23:01,275 --> 00:23:02,460
0,255 255,390 390,555 555,845 895,1185
to hold that log,| many
|很多时候人们会使用磁盘镜像，

901
00:23:02,460 --> 00:23:03,780
0,195 195,435 435,675 675,945 945,1320
times people will use disk

902
00:23:03,780 --> 00:23:05,385
0,500 670,975 975,1155 1155,1365 1365,1605
mirroring,| remember, we talked about
|还记得，我们在几节课前讨论过磁盘镜像，

903
00:23:05,385 --> 00:23:06,660
0,255 255,525 525,660 660,855 855,1275
disk mirroring a couple lectures

904
00:23:06,660 --> 00:23:07,605
0,320 430,660 660,750 750,840 840,945
ago,| so if there are
|所以，如果有两个磁盘将具有我写入的同一文件的副本，

905
00:23:07,605 --> 00:23:08,960
0,165 165,450 450,570 570,845 955,1355
two disks that will have

906
00:23:09,070 --> 00:23:10,170
0,290 290,515 515,710 710,875 875,1100
a copy of that same

907
00:23:10,170 --> 00:23:11,640
0,240 240,480 480,800 1000,1245 1245,1470
file I write,| but it's
|但实际上它在两个位置被写入两次，

908
00:23:11,640 --> 00:23:12,680
0,180 180,345 345,525 525,735 735,1040
actually being written in twice

909
00:23:12,820 --> 00:23:14,175
0,290 290,470 470,760 1080,1295 1295,1355
in two places,| so that
|所以如果其中一个出现故障，我还有另一个副本，

910
00:23:14,175 --> 00:23:15,090
0,120 120,300 300,540 540,705 705,915
if one fails, I still

911
00:23:15,090 --> 00:23:16,605
0,195 195,390 390,615 615,950 1270,1515
have that other copy,| that
|如果两个都出现故障，你将不得不创建第三个副本，以此类推。

912
00:23:16,605 --> 00:23:17,865
0,105 105,300 300,635 865,1185 1185,1260
if both fail, you'd have

913
00:23:17,865 --> 00:23:18,585
0,90 90,195 195,315 315,495 495,720
to make a third copy

914
00:23:18,585 --> 00:23:19,170
0,195 195,345 345,465 465,540 540,585
and so on,| so you
|所以你必须决定你能容忍什么样的失败。

915
00:23:19,170 --> 00:23:20,460
0,75 75,255 255,590 730,1035 1035,1290
have to decide what failure

916
00:23:20,460 --> 00:23:21,945
0,210 210,360 360,860 970,1260 1260,1485
you can tolerate.| But once
|但是，一旦日志到达磁盘，

917
00:23:21,945 --> 00:23:23,895
0,240 240,545 925,1245 1245,1455 1455,1950
a log hits the disk,|
|

918
00:23:23,895 --> 00:23:24,750
0,255 255,405 405,540 540,705 705,855
you kind of know you
你知道可以从中恢复，

919
00:23:24,750 --> 00:23:25,875
0,210 210,495 495,720 720,915 915,1125
can recover from that| and
|并重建数据库的状态。

920
00:23:25,875 --> 00:23:27,165
0,645 645,855 855,1020 1020,1170 1170,1290
reconstruct the state of the

921
00:23:27,165 --> 00:23:28,000
0,245
database.|
|

922
00:23:28,300 --> 00:23:29,625
0,260 260,425 425,605 605,940 1050,1325
And we'll talk about the
我们将在接下来的两节课中讨论协议，

923
00:23:29,625 --> 00:23:31,830
0,525 525,1095 1095,1445 1765,2055 2055,2205
protocol as, as in two

924
00:23:31,830 --> 00:23:33,180
0,330 330,510 510,800 940,1215 1215,1350
lectures from now,| how we
|我们将如何实现这个。

925
00:23:33,180 --> 00:23:34,605
0,260 310,710 730,1005 1005,1170 1170,1425
go and make that happen.|
|

926
00:23:34,605 --> 00:23:35,870
0,300 300,705 705,840 840,990 990,1265
But logging is the mechanism
但是日志是大多数数据库系统将使用的机制，

927
00:23:36,520 --> 00:23:38,070
0,320 320,560 560,875 875,1265 1265,1550
that most database systems will

928
00:23:38,070 --> 00:23:39,160
0,290
use,|
|

929
00:23:39,160 --> 00:23:40,270
0,270 270,420 420,630 630,900 900,1110
to go and record the
去记录发生的变化。

930
00:23:40,270 --> 00:23:41,920
0,270 270,510 510,660 660,950
changes that are happening.|
|

931
00:23:43,710 --> 00:23:44,740
0,400
{All,right}.|
好的。|

932
00:23:45,160 --> 00:23:46,220
0,245 245,365 365,530 530,740 740,1060
Does that make sense? Questions?|
这能理解吗？有问题吗？|

933
00:23:47,270 --> 00:23:48,460
0,395 395,620 620,710 710,905 905,1190

934
00:23:48,460 --> 00:23:50,670
0,315 315,680 880,1280 1660,1935 1935,2210

935
00:23:50,690 --> 00:23:51,730
0,260 260,410 410,605 605,830 830,1040

936
00:23:51,730 --> 00:23:53,080
0,165 165,420 420,705 705,1010 1030,1350

937
00:23:53,080 --> 00:23:54,415
0,240 240,560 640,1035 1035,1170 1170,1335

938
00:23:54,415 --> 00:23:55,420
0,180 180,345 345,480 480,705 705,1005
{ -} No, don't confuse
不，不要将其与日志结构文件系统混淆，

939
00:23:55,420 --> 00:23:56,830
0,165 165,345 345,645 645,1140 1140,1410
this with log structured file

940
00:23:56,830 --> 00:23:57,760
0,330 330,570 570,705 705,840 840,930
system,| is that what you
|这是你认为的那样吗，

941
00:23:57,760 --> 00:23:58,990
0,90 90,350 640,900 900,1050 1050,1230
are thinking,| it will look
|它看起来方式是不同的。

942
00:23:58,990 --> 00:23:59,820
0,180 180,330 330,435 435,555 555,830
like, that way is different.|
|

943
00:23:59,840 --> 00:24:00,655
0,305 305,455 455,560 560,680 680,815
So a lot of this
所以这个很多起源于 70 和 80 年代，

944
00:24:00,655 --> 00:24:01,525
0,120 120,300 300,510 510,675 675,870
origin, origin in the {70

945
00:24:01,525 --> 00:24:03,000
0,165 165,315 315,495 495,785 1075,1475
-} and {80s -}, {}|
|

946
00:24:03,640 --> 00:24:05,460
0,180 180,300 300,590 1000,1400 1420,1820
it's a file of records,|
这是一个记录的文件，|

947
00:24:05,930 --> 00:24:06,880
0,275 275,410 410,605 605,800 800,950
but the records are going
但记录的长度是可变的，

948
00:24:06,880 --> 00:24:08,575
0,135 135,270 270,560 580,980 1300,1695
to be variable length| and
|结构将有一组特定的通用字段，

949
00:24:08,575 --> 00:24:10,585
0,315 315,635 1105,1425 1425,1740 1740,2010
the structure will have a

950
00:24:10,585 --> 00:24:11,730
0,195 195,360 360,495 495,765 765,1145
certain set of common fields,|
|

951
00:24:12,650 --> 00:24:13,675
0,400 420,680 680,800 800,905 905,1025
but think of it as
但可以将其视为一个文件，

952
00:24:13,675 --> 00:24:15,600
0,275 565,965 985,1385
a file,| with
|包含一堆可变的，

953
00:24:15,600 --> 00:24:18,015
0,260 310,615 615,825 825,1130 2110,2415
a bunch of variable,| with
|具有固定长度[分量]和一大堆变量，

954
00:24:18,015 --> 00:24:19,725
0,225 225,465 465,765 765,1145 1435,1710
some fixed length components and

955
00:24:19,725 --> 00:24:20,430
0,105 105,210 210,360 360,495 495,705
a whole bunch of variable,|
|

956
00:24:20,430 --> 00:24:21,360
0,270 270,570 570,705 705,825 825,930
and it's sitting in a
它位于一个通常被称为日志文件的文件中，

957
00:24:21,360 --> 00:24:22,365
0,210 210,420 420,570 570,795 795,1005
file that will often be

958
00:24:22,365 --> 00:24:24,020
0,150 150,300 300,540 540,905 1255,1655
called a log file| and
|基本上它将从头到尾按顺序写入，

959
00:24:24,160 --> 00:24:25,350
0,485 485,755 755,995 995,1085 1085,1190
it's basically going to be

960
00:24:25,350 --> 00:24:26,925
0,260 310,990 990,1185 1185,1410 1410,1575
written sequentially from first to

961
00:24:26,925 --> 00:24:27,900
0,90 90,330 330,660 660,855 855,975
the end,| and it will
|它将拥有自己的缓冲区管理，

962
00:24:27,900 --> 00:24:28,830
0,260 370,615 615,720 720,825 825,930
be, it will have its

963
00:24:28,830 --> 00:24:30,740
0,165 165,495 495,770 1030,1430 1510,1910
own buffer management,| so it,
|所以最近的页面将位于缓冲池中，

964
00:24:31,330 --> 00:24:32,400
0,260 260,470 470,770 770,980 980,1070
the recent pages will be

965
00:24:32,400 --> 00:24:33,540
0,75 75,165 165,450 450,710 820,1140
in the buffer pool,| at
|在这个点上，我们必须说出这个，

966
00:24:33,540 --> 00:24:34,740
0,315 315,660 660,870 870,1020 1020,1200
certain points, we will have

967
00:24:34,740 --> 00:24:35,920
0,165 165,390 390,740
to tell that,|
|

968
00:24:35,920 --> 00:24:37,180
0,255 255,495 495,765 765,1020 1020,1260
{} the buffer pool,| to
缓冲池，|也就是说，

969
00:24:37,180 --> 00:24:38,485
0,260 340,630 630,900 900,1155 1155,1305
say,| I cannot commit this
|我不能将此事务提交到内存中，

970
00:24:38,485 --> 00:24:40,105
0,275 715,1005 1005,1200 1200,1425 1425,1620
transaction to this page you

971
00:24:40,105 --> 00:24:42,100
0,195 195,515 775,1065 1065,1355 1675,1995
have here in memory,| that
|它需要命中磁盘，

972
00:24:42,100 --> 00:24:43,590
0,240 240,405 405,650 670,960 960,1490
needs to hit to disk,|
|

973
00:24:44,040 --> 00:24:45,630
0,320 760,1050 1050,1260 1260,1440 1440,1590
before I can commit this
在我可以提交这个事务之前，

974
00:24:45,630 --> 00:24:46,980
0,290 430,660 660,750 750,1010 1030,1350
transaction,| so we might hold
|所以我们可能会保留事务提交，

975
00:24:46,980 --> 00:24:48,585
0,195 195,470 700,1155 1155,1335 1335,1605
the transactions commit,| we won't
|我们不会返回，直到我们，

976
00:24:48,585 --> 00:24:49,725
0,195 195,485 565,840 840,1005 1005,1140
return it, utill {we,have},| but
|但是你可以把它想象成一个记录文件，

977
00:24:49,725 --> 00:24:50,340
0,90 90,210 210,360 360,495 495,615
you can think of it

978
00:24:50,340 --> 00:24:51,860
0,180 180,435 435,770 850,1185 1185,1520
as a file of records,|
|

979
00:24:52,630 --> 00:24:54,260
0,320 320,515 515,755 755,1120 1230,1630
just like a {} regular
就像一个普通的文件，

980
00:24:54,940 --> 00:24:56,430
0,400 510,725 725,905 905,1130 1130,1490
file,| but it's got its
|但它有特殊的结构。

981
00:24:56,430 --> 00:24:58,425
0,375 375,770 1150,1440 1440,1800 1800,1995
special structure.| { - -}
|

982
00:24:58,425 --> 00:24:59,355
0,105 105,270 270,330 330,575 625,930

983
00:24:59,355 --> 00:25:00,570
0,210 210,390 390,570 570,945 945,1215

984
00:25:00,570 --> 00:25:01,755
0,255 255,390 390,525 525,930 930,1185

985
00:25:01,755 --> 00:25:02,340
0,210 210,300 300,390 390,495 495,585

986
00:25:02,340 --> 00:25:02,980
0,420 420,600

987
00:25:03,180 --> 00:25:04,390
0,335 335,530 530,650 650,860 860,1210
Yeah, so the question is,|
是的，所以问题是，|

988
00:25:04,410 --> 00:25:05,410
0,260 260,395 395,530 530,695 695,1000
if I have a log
如果我有一个日志结构的文件系统，

989
00:25:05,430 --> 00:25:07,760
0,560 560,910 960,1360 1950,2195 2195,2330
structured file system,| do I
|我是否需要日志，

990
00:25:07,760 --> 00:25:09,530
0,210 210,740 880,1155 1155,1380 1380,1770
need logging,| a log structured
|一个日志结构文件系统只对那个文件有效，

991
00:25:09,530 --> 00:25:10,595
0,195 195,450 450,690 690,900 900,1065
file system just works for

992
00:25:10,595 --> 00:25:11,315
0,135 135,375 375,555 555,630 630,720
that file,| so in a
|所以，在一个数据库系统中，

993
00:25:11,315 --> 00:25:12,290
0,240 240,570 570,765 765,870 870,975
database system,| I may have
|我可能有 100 个表，

994
00:25:12,290 --> 00:25:14,000
0,330 330,680 880,1155 1155,1430 1480,1710
100 tables,| a transaction we
|我们在五个不同的位置更新了一个事务，

995
00:25:14,000 --> 00:25:15,200
0,210 210,525 525,750 750,945 945,1200
have updated in five different

996
00:25:15,200 --> 00:25:17,080
0,350 610,930 930,1230 1230,1545 1545,1880
places,| I need a global
|我需要一个全局日志机制来处理这个问题。

997
00:25:17,190 --> 00:25:18,890
0,395 395,875 875,1150 1290,1550 1550,1700
log logging mechanism to deal

998
00:25:18,890 --> 00:25:20,450
0,165 165,440 700,1035 1035,1440 1440,1560
with that.| So traditionally what
|所以，传统上做的，

999
00:25:20,450 --> 00:25:21,020
0,105 105,210 210,360 360,495 495,570
will be done,| I have
|我有一个日志文件，

1000
00:25:21,020 --> 00:25:22,325
0,120 120,390 390,770 910,1170 1170,1305
a log file,| which is
|它将保留所有这些变更，

1001
00:25:22,325 --> 00:25:23,950
0,150 150,285 285,545 865,1245 1245,1625
going to keep these changes,|
|

1002
00:25:24,060 --> 00:25:25,580
0,335 335,670 900,1175 1175,1370 1370,1520
for all the changes that
为所有发生的更改，

1003
00:25:25,580 --> 00:25:26,660
0,90 90,350 400,720 720,915 915,1080
are happening across,| not just
|而不仅仅是单个文件。

1004
00:25:26,660 --> 00:25:28,150
0,120 120,210 210,420 420,770 1090,1490
for a single file.| So
|所以，日志结构化文件系统确实有意义，

1005
00:25:28,170 --> 00:25:29,495
0,320 320,665 665,845 845,1085 1085,1325
log structured file system does

1006
00:25:29,495 --> 00:25:30,515
0,225 225,450 450,600 600,750 750,1020
make sense,| they have similar
|它们具有类似的元素到机制类型，

1007
00:25:30,515 --> 00:25:31,940
0,365 475,750 750,945 945,1200 1200,1425
elements to the types of

1008
00:25:31,940 --> 00:25:33,395
0,650 760,1020 1020,1185 1185,1305 1305,1455
mechanisms,| that you're trying to
|与你尝试执行的重做和撤消类型的东西相比，

1009
00:25:33,395 --> 00:25:34,595
0,240 240,615 615,720 720,1050 1050,1200
do redo and undo type

1010
00:25:34,595 --> 00:25:36,005
0,165 165,455 715,1065 1065,1275 1275,1410
of things,| but they are
|但它们在的文件基础池中，

1011
00:25:36,005 --> 00:25:37,060
0,135 135,270 270,465 465,720 720,1055
on a pool file basis,|
|

1012
00:25:37,080 --> 00:25:37,880
0,260 260,365 365,515 515,680 680,800
they may not be the
它们可能不是适合它的结构，

1013
00:25:37,880 --> 00:25:39,260
0,195 195,530 550,840 840,1125 1125,1380
right structure for it,| they
|它们不一定拥有所有缓冲的东西，

1014
00:25:39,260 --> 00:25:40,130
0,315 315,525 525,630 630,750 750,870
don't necessarily have all the

1015
00:25:40,130 --> 00:25:41,045
0,300 300,480 480,600 600,750 750,915
buffer stuff,| so it's good
|所以，它适用于某些应用程序和文件系统，

1016
00:25:41,045 --> 00:25:42,575
0,225 225,545 685,1050 1050,1305 1305,1530
for certain applications and file

1017
00:25:42,575 --> 00:25:43,985
0,335 475,750 750,870 870,1095 1095,1410
system,| but for database systems,
|但是对于数据库系统，我们需要一些不同的东西，

1018
00:25:43,985 --> 00:25:44,795
0,225 225,330 330,450 450,585 585,810
we're going to need something

1019
00:25:44,795 --> 00:25:46,025
0,335 535,810 810,930 930,1035 1035,1230
different| and we need it
|我们需要跨不同的文件。

1020
00:25:46,025 --> 00:25:47,780
0,255 255,525 525,870 870,1265
across different files, right.|
|

1021
00:25:49,200 --> 00:25:50,105
0,245 245,395 395,575 575,725 725,905
You might [pull] all our
你可能也会取消我们的所有操作，

1022
00:25:50,105 --> 00:25:51,275
0,300 300,675 675,900 900,1035 1035,1170
operations, too,| so we'll talk
|所以我们将在详细讨论时讨论所有这些操作，

1023
00:25:51,275 --> 00:25:51,905
0,165 165,285 285,405 405,510 510,630
about all of that as

1024
00:25:51,905 --> 00:25:52,820
0,135 135,240 240,465 465,750 750,915
we go into details,| but
|但这是一个很好的观点，

1025
00:25:52,820 --> 00:25:53,900
0,210 210,300 300,450 450,740 820,1080
that's a good point,| why
|为什么我，为什么操作系统的人谈论日志结构文件系统，

1026
00:25:53,900 --> 00:25:54,875
0,105 105,350 370,630 630,795 795,975
am I, you know, why

1027
00:25:54,875 --> 00:25:56,345
0,120 120,270 270,480 480,785 1135,1470
do the operating systems guys

1028
00:25:56,345 --> 00:25:57,820
0,240 240,435 435,975 975,1170 1170,1475
talk about {log,structured} file systems,|
|

1029
00:25:57,960 --> 00:25:59,540
0,365 365,605 605,935 935,1300 1320,1580
they're very similar elements to
它们是非常相似的元素，

1030
00:25:59,540 --> 00:26:00,580
0,195 195,420 420,555 555,720 720,1040
that,| can we use that,|
|我们能用这个吗，|

1031
00:26:01,860 --> 00:26:03,220
0,400 450,725 725,845 845,1025 1025,1360
we need to worry about
我们需要担心跨多个不同表更新记录的事务，

1032
00:26:03,510 --> 00:26:05,705
0,400 660,1060 1320,1610 1610,1880 1880,2195
transactions that update records across

1033
00:26:05,705 --> 00:26:07,610
0,335 385,785 1105,1500 1500,1770 1770,1905
multiple different tables,| which may
|这些表可能位于文件系统中的多个不同文件中，

1034
00:26:07,610 --> 00:26:08,690
0,90 90,180 180,405 405,735 735,1080
be in multiple different files

1035
00:26:08,690 --> 00:26:09,640
0,255 255,375 375,480 480,645 645,950
sitting in the file system,|
|

1036
00:26:09,750 --> 00:26:11,240
0,320 320,515 515,620 620,1145 1145,1490
and still be atomic across
并且这些文件之间仍然是原子的，

1037
00:26:11,240 --> 00:26:12,605
0,285 285,620 730,960 960,1110 1110,1365
those files,| so it's different.|
|所以这是不同的。|

1038
00:26:12,605 --> 00:26:13,700
0,390 390,645 645,810 810,990 990,1095
So in many ways,| we
所以，在许多方面，|我们必须做一些事情，

1039
00:26:13,700 --> 00:26:14,180
0,75 75,165 165,240 240,330 330,480
have to do a little

1040
00:26:14,180 --> 00:26:15,080
0,285 285,525 525,600 600,690 690,900
bit,| we have a harder
|我们有一个更难解决的问题。

1041
00:26:15,080 --> 00:26:16,320
0,300 300,525 525,800
problem to solve.|
|

1042
00:26:17,110 --> 00:26:18,770
0,305 305,560 560,910 1020,1340 1340,1660
Great question, though,| other questions?|
不过，这是个很好的问题，|还有其他问题吗？|

1043
00:26:21,400 --> 00:26:22,340
0,400
Okay.|
好的。|

1044
00:26:22,430 --> 00:26:24,250
0,290 290,515 515,850 1230,1670 1670,1820
All right, so logging is
好的，所以几乎每个数据库系统都在使用日志记录，

1045
00:26:24,250 --> 00:26:26,815
0,290 550,950 1270,1670 1900,2265 2265,2565
used, {} by nearly every

1046
00:26:26,815 --> 00:26:28,680
0,335 355,755 985,1350 1350,1530 1530,1865
database system,| what's the alternative,
|你可能会问，还有其他选择吗，

1047
00:26:28,730 --> 00:26:30,565
0,260 260,410 410,700 990,1390 1560,1835
you might ask,| {} in
|在日志之前的很早的日子里，

1048
00:26:30,565 --> 00:26:32,005
0,165 165,435 435,765 765,1095 1095,1440
the very early days before

1049
00:26:32,005 --> 00:26:33,880
0,605 805,1095 1095,1320 1320,1620 1620,1875
logging| and all the details
|以及所有关于日志真正有效的细节，

1050
00:26:33,880 --> 00:26:34,930
0,180 180,525 525,660 660,810 810,1050
about logging where it really

1051
00:26:34,930 --> 00:26:36,750
0,255 255,560 940,1230 1230,1470 1470,1820
worked out,| a very easy
|做这些事情的一个非常简单的方法是进行影子分页，

1052
00:26:36,830 --> 00:26:38,005
0,365 365,620 620,785 785,950 950,1175
way to kind of do

1053
00:26:38,005 --> 00:26:39,115
0,315 315,615 615,825 825,975 975,1110
this stuff was to do

1054
00:26:39,115 --> 00:26:40,675
0,225 225,755 835,1200 1200,1350 1350,1560
shadow paging,| it's like {copy-on-write
|它就像是写入时复制的东西，

1055
00:26:40,675 --> 00:26:41,605
0,180 180,375 375,570 570,735 735,930
- -} type of thing,

1056
00:26:41,605 --> 00:26:42,840
0,305 325,585 585,810 810,960 960,1235
right,| and you'll see that
|顺便说一句，你们会在许多应用程序中看到类似的概念，

1057
00:26:42,920 --> 00:26:44,410
0,275 275,550 630,1010 1010,1340 1340,1490
in many applications, you'll see

1058
00:26:44,410 --> 00:26:45,480
0,225 225,645 645,750 750,840 840,1070
similar concepts by the way,|
|

1059
00:26:45,620 --> 00:26:46,750
0,275 275,410 410,620 620,830 830,1130
those of you've taken operating
你们中的那些人使用过操作系统，

1060
00:26:46,750 --> 00:26:48,250
0,300 300,540 540,890 970,1290 1290,1500
systems| or I've dug into
|或者我已经深入研究过了，

1061
00:26:48,250 --> 00:26:49,135
0,195 195,360 360,465 465,615 615,885
that,| I going to find
|我要找出数据库系统和操作系统之间的许多共同之处，n

1062
00:26:49,135 --> 00:26:50,365
0,315 315,525 525,705 705,945 945,1230
a lot of common things

1063
00:26:50,365 --> 00:26:52,375
0,210 210,485 565,965 1255,1655 1675,2010
between database systems and operating

1064
00:26:52,375 --> 00:26:53,920
0,335 355,660 660,840 840,1050 1050,1545
systems,| we already hit latches
|我们已经遇到了 latch 和 lock ，

1065
00:26:53,920 --> 00:26:55,165
0,240 240,795 795,1050 1050,1170 1170,1245
and locks,| they try to
|它们试图做不同的事情，

1066
00:26:55,165 --> 00:26:56,395
0,75 75,315 315,645 645,995 1015,1230
do different things,| but a
|但许多数据库系统将存储更大的内容，

1067
00:26:56,395 --> 00:26:57,595
0,90 90,240 240,510 510,905 925,1200
lot of database systems are

1068
00:26:57,595 --> 00:26:58,500
0,150 150,270 270,375 375,570 570,905
going to be on larger

1069
00:26:58,520 --> 00:27:00,580
0,400 750,1085 1085,1310 1310,1600 1740,2060
things,| lots of files, lots
|大量的文件和大量的数据，

1070
00:27:00,580 --> 00:27:01,885
0,195 195,470 730,1005 1005,1155 1155,1305
of data,| and in some
|在我看来，在某些情况下，机制将不同于，通常更丰富。

1071
00:27:01,885 --> 00:27:03,025
0,135 135,285 285,825 825,975 975,1140
set, the mechanisms are going

1072
00:27:03,025 --> 00:27:04,195
0,150 150,270 270,510 510,875 895,1170
to be different than, in

1073
00:27:04,195 --> 00:27:05,620
0,165 165,345 345,615 615,1205
my view, often richer.|
|

1074
00:27:06,560 --> 00:27:08,605
0,400 450,1040 1040,1330 1500,1805 1805,2045
So shadowing is,| okay, I'm
所以影子是，|好的，我要更改页面上的记录，

1075
00:27:08,605 --> 00:27:09,620
0,135 135,425
gonna make

1076
00:27:09,930 --> 00:27:11,270
0,335 335,515 515,760 810,1145 1145,1340
change to a record on

1077
00:27:11,270 --> 00:27:12,365
0,120 120,380 580,825 825,915 915,1095
a page,| you know what,|
|你知道的，|

1078
00:27:12,365 --> 00:27:13,055
0,255 255,360 360,480 480,570 570,690
I'm just going to make
我只需要创建一个新的页面副本，

1079
00:27:13,055 --> 00:27:14,090
0,255 255,540 540,750 750,915 915,1035
a new copy of the

1080
00:27:14,090 --> 00:27:14,930
0,150 150,300 300,435 435,585 585,840
page| and make the changes
|然后在那里进行更改，

1081
00:27:14,930 --> 00:27:16,100
0,380 580,855 855,975 975,1065 1065,1170
there,| that way, if I
|这样，如果我需要撤消某些内容，

1082
00:27:16,100 --> 00:27:17,120
0,135 135,285 285,660 660,825 825,1020
need to undo stuff,| I'll
|我只需返回到旧页面，

1083
00:27:17,120 --> 00:27:17,735
0,120 120,255 255,390 390,525 525,615
just go back to the

1084
00:27:17,735 --> 00:27:18,840
0,165 165,485
old page,|
|

1085
00:27:18,840 --> 00:27:19,665
0,135 135,300 300,435 435,645 645,825
and I've got both my
我有整个页面的前后副本。

1086
00:27:19,665 --> 00:27:20,790
0,225 225,435 435,645 645,930 930,1125
before and after copy for

1087
00:27:20,790 --> 00:27:22,320
0,180 180,500 520,920 1180,1425 1425,1530
the entire page.| Now, of
|当然，现在一些系统仍然这样做，

1088
00:27:22,320 --> 00:27:25,035
0,260 700,1065 1065,1430 2260,2550 2550,2715
course, some systems still do

1089
00:27:25,035 --> 00:27:26,130
0,275 385,600 600,780 780,945 945,1095
that,| but it's not a
|但这不是一个好主意，

1090
00:27:26,130 --> 00:27:27,500
0,210 210,465 465,780 780,1020 1020,1370
good idea,| it's less efficient,|
|它的效率较低，|

1091
00:27:27,880 --> 00:27:28,845
0,260 260,395 395,560 560,770 770,965
if I just wanted to
如果我只想在一个页面中更改一个字节，

1092
00:27:28,845 --> 00:27:31,215
0,275 625,1025 1045,1605 1605,1955 2005,2370
change one byte in one

1093
00:27:31,215 --> 00:27:32,430
0,365 445,765 765,855 855,975 975,1215
page,| I'm going to make
|我会创建整个页面的副本，

1094
00:27:32,430 --> 00:27:33,600
0,315 315,585 585,840 840,1035 1035,1170
an entire copy of the

1095
00:27:33,600 --> 00:27:35,090
0,165 165,315 315,585 585,855 855,1490
page,| so that's obviously wasteful.|
|这显然是浪费的。|

1096
00:27:35,500 --> 00:27:36,190
0,120 120,285 285,435 435,570 570,690
I still need to go
我仍然需要去清理东西，

1097
00:27:36,190 --> 00:27:37,615
0,210 210,495 495,735 735,1040 1120,1425
and clean things up| and
|把东西合并到之前的上面，

1098
00:27:37,615 --> 00:27:38,910
0,315 315,480 480,675 675,945 945,1295
merge things up others before,|
|

1099
00:27:39,110 --> 00:27:40,240
0,275 275,440 440,695 695,920 920,1130
you know it, if I've
如果我有一个页面有一个热门记录，

1100
00:27:40,240 --> 00:27:41,500
0,230 250,570 570,870 870,1110 1110,1260
got one page which has

1101
00:27:41,500 --> 00:27:43,200
0,150 150,285 285,480 480,800 1300,1700
got a hot record,| and
|假设它是计数器，

1102
00:27:43,340 --> 00:27:44,935
0,380 380,640 780,1130 1130,1295 1295,1595
let's say it's the counter,|
|

1103
00:27:44,935 --> 00:27:46,870
0,300 300,540 540,750 750,1025 1525,1935
that says how many SKUs
显示我的粉色芭比娃娃有多少 SKU ，

1104
00:27:46,870 --> 00:27:47,755
0,135 135,255 255,495 495,735 735,885
do I have for the

1105
00:27:47,755 --> 00:27:49,195
0,240 240,720 720,945 945,1260 1260,1440
pink Barbie doll,| that's really
|那真的很受欢迎，

1106
00:27:49,195 --> 00:27:50,965
0,335 655,960 960,1155 1155,1410 1410,1770
popular,| every time someone buys
|每次有人买那个芭比娃娃，

1107
00:27:50,965 --> 00:27:52,405
0,150 150,510 510,785 865,1185 1185,1440
that Barbie doll,| that counter
|计数器就会改变，

1108
00:27:52,405 --> 00:27:53,395
0,240 240,525 525,825 825,900 900,990
will change,| I'm going to
|我要创建这个页面的副本一份又一份，

1109
00:27:53,395 --> 00:27:54,505
0,210 210,585 585,735 735,1005 1005,1110
make copies and copies of

1110
00:27:54,505 --> 00:27:55,285
0,105 105,345 345,615 615,720 720,780
the page, right,| so if
|所以如果我有一百万个芭比娃娃，

1111
00:27:55,285 --> 00:27:56,440
0,165 165,360 360,600 600,810 810,1155
I've got a million Barbie

1112
00:27:56,440 --> 00:27:57,190
0,225 225,375 375,435 435,540 540,750
dolls,| I'll have a million
|我就会有一百万个副本。

1113
00:27:57,190 --> 00:27:58,100
0,500
copies.|
|

1114
00:27:58,860 --> 00:27:59,885
0,260 260,365 365,500 500,875 875,1025
By the way, counters in
顺便说一句，数据库系统中的计数器不是以这种方式保存的，

1115
00:27:59,885 --> 00:28:01,220
0,255 255,600 600,975 975,1140 1140,1335
database systems aren't kept that

1116
00:28:01,220 --> 00:28:01,955
0,180 180,300 300,390 390,555 555,735
way,| they are done with
|它们是用更多的语义成分来完成的，使用[交换]动作，

1117
00:28:01,955 --> 00:28:04,595
0,195 195,845 1345,1740 1740,2085 2085,2640
more semantic components using commutative

1118
00:28:04,595 --> 00:28:05,975
0,245 505,840 840,945 945,1125 1125,1380
action,| that's just a side
|这只是一个次要的评论，

1119
00:28:05,975 --> 00:28:07,505
0,335 685,900 900,1035 1035,1425 1425,1530
comment,| also an encouragement to
|也是鼓励参加高级数据库课程，

1120
00:28:07,505 --> 00:28:08,800
0,120 120,300 300,525 525,845 895,1295
take the advanced database class|
|

1121
00:28:09,120 --> 00:28:11,585
0,400 900,1205 1205,1415 1415,1720 2160,2465
to talk about more complex
来讨论更复杂的机制，

1122
00:28:11,585 --> 00:28:13,040
0,510 510,660 660,795 795,1085 1195,1455
mechanisms| to make transactions go
|以使事务进行得更快、更好。

1123
00:28:13,040 --> 00:28:14,500
0,180 180,465 465,705 705,980
even faster and better.|
|

1124
00:28:15,520 --> 00:28:16,470
0,260 260,395 395,545 545,740 740,950
But you get the idea
但你会明白影子分页可以非常快，

1125
00:28:16,470 --> 00:28:18,675
0,225 225,555 555,1190 1450,1845 1845,2205
that shadow paging can very

1126
00:28:18,675 --> 00:28:19,910
0,300 300,555 555,690 690,915 915,1235
quickly,| it's a cheap mechanism,|
|这是一种廉价的机制，|

1127
00:28:20,020 --> 00:28:21,735
0,365 365,665 665,1000 1260,1535 1535,1715
easy to implement, but is
易于实施，但存在问题，

1128
00:28:21,735 --> 00:28:24,000
0,755 835,1245 1245,1440 1440,1775 2005,2265
problematic,| logging is superior,| and
|日志更好，|这也是大多数数据库系统使用的。

1129
00:28:24,000 --> 00:28:25,200
0,210 210,345 345,540 540,825 825,1200
that's what most database systems

1130
00:28:25,200 --> 00:28:26,160
0,380
use.|
|

1131
00:28:27,190 --> 00:28:28,140
0,260 260,470 470,620 620,770 770,950
So let's get to the
所以让我们来看看 C 部分，

1132
00:28:28,140 --> 00:28:29,370
0,240 240,510 510,720 720,945 945,1230
C part,| which has always
|这部分一直很难解释，

1133
00:28:29,370 --> 00:28:31,275
0,300 300,555 555,830 1390,1680 1680,1905
been a little difficult to

1134
00:28:31,275 --> 00:28:32,655
0,255 255,435 435,695 955,1215 1215,1380
explain,| but hopefully with this
|但是希望有了这张幻灯片会开始变得更好。

1135
00:28:32,655 --> 00:28:33,465
0,180 180,285 285,420 420,615 615,810
slide, it will start to

1136
00:28:33,465 --> 00:28:35,130
0,180 180,455 715,1095 1095,1380 1380,1665
become better.| It's essentially saying,|
|这实质上是说，|

1137
00:28:35,130 --> 00:28:36,795
0,165 165,285 285,420 420,710 1390,1665
I have a contract between
我和数据库系统之间有一个契约，

1138
00:28:36,795 --> 00:28:38,205
0,135 135,395 475,875 895,1200 1200,1410
the database system and I|
|

1139
00:28:38,205 --> 00:28:40,300
0,165 165,425 505,900 900,1655
as an application programmer.|
作为一名应用程序程序员，|

1140
00:28:40,730 --> 00:28:41,785
0,245 245,365 365,620 620,890 890,1055
have a contract with you,
与数据库系统签订契约，

1141
00:28:41,785 --> 00:28:43,150
0,135 135,395 415,765 765,1020 1020,1365
the database system,| that I'll
|我将告诉你我想要在应用程序中实现什么，

1142
00:28:43,150 --> 00:28:43,975
0,135 135,315 315,495 495,645 645,825
tell you what I want

1143
00:28:43,975 --> 00:28:45,475
0,165 165,405 405,785 1075,1335 1335,1500
in the application| through my
|通过我的 SQL 语句，我的主键约束，我的检查，

1144
00:28:45,475 --> 00:28:47,200
0,390 390,675 675,1020 1020,1385 1405,1725
sql statement, my primary key

1145
00:28:47,200 --> 00:28:49,270
0,770 850,1185 1185,1560 1560,1770 1770,2070
constraints, my checks| and other
|和其他我想要在系统中实现的东西，

1146
00:28:49,270 --> 00:28:50,245
0,270 270,420 420,540 540,750 750,975
things that I want in

1147
00:28:50,245 --> 00:28:52,405
0,150 150,425 835,1235 1675,2025 2025,2160
the system| and don't mess
|不要弄乱它。

1148
00:28:52,405 --> 00:28:53,220
0,120 120,365
it up.|
|

1149
00:28:53,330 --> 00:28:54,835
0,290 290,485 485,935 935,1175 1175,1505
if those constraint held before
如果在事务开始之前持有这些约束，

1150
00:28:54,835 --> 00:28:56,620
0,270 270,545 745,1145
the transaction started,|
|

1151
00:28:56,690 --> 00:28:58,030
0,275 275,410 410,670 810,1145 1145,1340
then the transaction ran,| and
然后，事务运行，|它可能已经触及了一百万个对象，

1152
00:28:58,030 --> 00:28:59,320
0,135 135,270 270,530 730,1065 1065,1290
it may have touched a

1153
00:28:59,320 --> 00:29:00,925
0,290 460,860 1000,1260 1260,1395 1395,1605
million objects,| read and write
|读写数百个表中的数百万个对象，

1154
00:29:00,925 --> 00:29:02,785
0,270 270,570 570,915 915,1295 1525,1860
millions of objects across hundreds

1155
00:29:02,785 --> 00:29:04,660
0,210 210,485 1075,1455 1455,1725 1725,1875
of tables,| once you say
|一旦你说它被提交了，

1156
00:29:04,660 --> 00:29:06,550
0,300 300,620 880,1200 1200,1425 1425,1890
it's committed,| all those constraints
|所有这些约束必须仍然是真的。

1157
00:29:06,550 --> 00:29:07,840
0,180 180,375 375,540 540,830
must still be true.|
|

1158
00:29:08,860 --> 00:29:09,945
0,260 260,520 540,815 815,950 950,1085
Okay, if one of my
好的，如果我的约束之一是，

1159
00:29:09,945 --> 00:29:11,700
0,450 450,725 1045,1365 1365,1560 1560,1755
constraints was,| the sum of
|价格字段中所有列的总和小于 100 ，

1160
00:29:11,700 --> 00:29:13,130
0,315 315,630 630,975 975,1140 1140,1430
all the columns in this,

1161
00:29:14,170 --> 00:29:16,155
0,335 335,575 575,880 1020,1420 1590,1985
the in the {} price

1162
00:29:16,155 --> 00:29:18,780
0,395 835,1235 1555,1860 1860,2010 2010,2625
field is less than 100,|
|

1163
00:29:18,780 --> 00:29:19,980
0,195 195,360 360,525 525,830 940,1200
{that,should} still be true,| if
它应该仍然是真的，|如果我说所有的列 A 加起来应该是一百万，

1164
00:29:19,980 --> 00:29:21,180
0,150 150,375 375,630 630,885 885,1200
I say all the column

1165
00:29:21,180 --> 00:29:22,695
0,380 640,930 930,1110 1110,1305 1305,1515
A should add up to

1166
00:29:22,695 --> 00:29:23,925
0,165 165,315 315,555 555,885 885,1230
be a million| and exactly
|就应该是一百万，

1167
00:29:23,925 --> 00:29:25,035
0,195 195,285 285,545 685,945 945,1110
be a million| and lots
|那个 A 列的两个不同的值发生了很大的变化，

1168
00:29:25,035 --> 00:29:26,630
0,180 180,405 405,750 750,1145 1195,1595
of changes happen to different,

1169
00:29:26,710 --> 00:29:30,465
0,400 780,1180 2700,2960 2960,3220 3390,3755
{ -} to different values

1170
00:29:30,465 --> 00:29:31,740
0,210 210,345 345,570 570,905 955,1275
in that column A,| that
|那应该仍然是真的，

1171
00:29:31,740 --> 00:29:32,835
0,225 225,420 420,645 645,870 870,1095
should still hold true| that
|在它结束的时候，总和应该仍然是一百万。

1172
00:29:32,835 --> 00:29:33,630
0,255 255,465 465,615 615,705 705,795
sum should still be a

1173
00:29:33,630 --> 00:29:34,320
0,165 165,345 345,450 450,555 555,690
million at the end of

1174
00:29:34,320 --> 00:29:35,420
0,105 105,195 195,405 405,810 810,1100
it.| And I've specified that
|我已经通过我的约束规定了这个，

1175
00:29:35,560 --> 00:29:36,990
0,245 245,365 365,880 960,1250 1250,1430
through my constraint,| that should
|这个应该仍然是真的。

1176
00:29:36,990 --> 00:29:38,260
0,285 285,555 555,735 735,1040
still still hold true.|
|

1177
00:29:39,760 --> 00:29:40,880
0,400
Now,
现在，事务管理不会做任何不同的事情，

1178
00:29:41,490 --> 00:29:42,980
0,275 275,550 690,1070 1070,1325 1325,1490
the transaction management is not

1179
00:29:42,980 --> 00:29:44,375
0,180 180,330 330,570 570,950 1000,1395
going to do anything different,|
|

1180
00:29:44,375 --> 00:29:45,710
0,300 300,585 585,875 955,1215 1215,1335
as you'll see,| we just
如你所见，|我们只需要确保保持原子性，

1181
00:29:45,710 --> 00:29:47,345
0,135 135,270 270,465 465,800 1240,1635
have to make sure that

1182
00:29:47,345 --> 00:29:49,750
0,225 225,900 900,1175 1525,1830 1830,2405
the atomicity holds,| the AID
|保持 AID 组件，

1183
00:29:49,950 --> 00:29:52,070
0,365 365,680 680,935 935,1480 1530,2120
components hold| and constraint consistency
|约束一致性将得到正确处理，

1184
00:29:52,070 --> 00:29:53,090
0,135 135,315 315,510 510,765 765,1020
will just get taken care

1185
00:29:53,090 --> 00:29:54,290
0,180 180,470 580,825 825,930 930,1200
of, right,| if we don't
|如果我们不弄乱的话。

1186
00:29:54,290 --> 00:29:55,595
0,225 225,450 450,660 660,960 960,1305
mess that up.| So that's
|这就是为什么 C 是连接这些东西的原因，

1187
00:29:55,595 --> 00:29:56,930
0,165 165,485 775,1035 1035,1155 1155,1335
why C kind of like

1188
00:29:56,930 --> 00:29:58,360
0,270 270,450 450,795 795,1110 1110,1430
plugged into this asset stuff,|
|

1189
00:29:58,530 --> 00:30:00,095
0,290 290,580 660,1205 1205,1415 1415,1565
the transaction mechanisms we'll talk
我们今天将在接下来的两节课中讨论的事务机制，

1190
00:30:00,095 --> 00:30:00,830
0,195 195,375 375,510 510,600 600,735
about today in the next

1191
00:30:00,830 --> 00:30:02,270
0,150 150,620 790,1200 1200,1305 1305,1440
two lectures,| aren't going to
|不会直接涉及 C ，

1192
00:30:02,270 --> 00:30:03,700
0,270 270,570 570,870 870,1185 1185,1430
directly address C,| it's the
|正确定义这些约束是应用程序程序员的责任。

1193
00:30:03,720 --> 00:30:05,705
0,400 480,740 740,965 965,1295 1295,1985
responsibility of the application programmer

1194
00:30:05,705 --> 00:30:07,180
0,315 315,525 525,705 705,1170 1170,1475
to define those constraints correctly.|
|

1195
00:30:08,420 --> 00:30:09,670
0,260 260,425 425,695 695,1010 1010,1250
To make matters even more
让事情变得更加混乱，

1196
00:30:09,670 --> 00:30:10,980
0,500
confusing,|
|

1197
00:30:11,580 --> 00:30:12,980
0,275 275,470 470,695 695,1000 1110,1400
a little while back close
回到大约十年前的一段时间，

1198
00:30:12,980 --> 00:30:14,390
0,120 120,210 210,470 490,890 1030,1410
to a decade ago,| there's
|所有这些关于最终一致性的东西都很令人兴奋，

1199
00:30:14,390 --> 00:30:17,200
0,260 310,710 910,1310 1600,2000 2410,2810
all this { -} excitement

1200
00:30:17,520 --> 00:30:19,060
0,320 320,530 530,680 680,920 920,1540
about this thing called eventual

1201
00:30:19,080 --> 00:30:20,380
0,820
consistency,|
|

1202
00:30:20,600 --> 00:30:21,340
0,305 305,440 440,515 515,620 620,740
even though it has the
尽管它有一致性这个词，

1203
00:30:21,340 --> 00:30:22,705
0,225 225,840 840,1005 1005,1200 1200,1365
word consistency,| has nothing to
|但与我们在这里 ACID 中定义的的 C 的一致性无关，

1204
00:30:22,705 --> 00:30:23,815
0,105 105,225 225,435 435,975 975,1110
do with the consistency that

1205
00:30:23,815 --> 00:30:24,655
0,135 135,330 330,555 555,705 705,840
we just defined here as

1206
00:30:24,655 --> 00:30:26,140
0,180 180,360 360,510 510,785
a C in acid,|
|

1207
00:30:26,530 --> 00:30:28,080
0,400 450,1070 1070,1205 1205,1325 1325,1550
that consistency was a model
那个一致性是一个模型表示，

1208
00:30:28,080 --> 00:30:29,865
0,380 610,915 915,1110 1110,1400 1510,1785
saying,| oh these transactions are
|这些事务在分布式系统中很难实现，

1209
00:30:29,865 --> 00:30:31,905
0,275 655,1005 1005,1335 1335,1680 1680,2040
hard in distributed systems,| it
|要做到这个变得非常困难，

1210
00:30:31,905 --> 00:30:32,880
0,285 285,480 480,690 690,855 855,975
becomes very tough to do

1211
00:30:32,880 --> 00:30:34,020
0,260 370,630 630,825 825,990 990,1140
that,| though now we have
|尽管现在我们已经弄清楚了，

1212
00:30:34,020 --> 00:30:35,055
0,255 255,480 480,705 705,900 900,1035
figured things out| and how
|以及如何在分布式系统中做事情，

1213
00:30:35,055 --> 00:30:35,970
0,120 120,255 255,435 435,645 645,915
to do things in distributed

1214
00:30:35,970 --> 00:30:37,380
0,330 330,630 630,950 1090,1320 1320,1410
systems well too,| but at
|但在那个时候，

1215
00:30:37,380 --> 00:30:38,385
0,165 165,375 375,570 570,795 795,1005
that time,| when people were
|当人们在构建这些系统时，

1216
00:30:38,385 --> 00:30:40,490
0,255 255,635 1075,1475 1555,1830 1830,2105
building these systems| and largely
|这些系统主要是由没有学习过数据库课程的人构建的，

1217
00:30:40,870 --> 00:30:42,075
0,380 380,710 710,920 920,1055 1055,1205
the systems were being built

1218
00:30:42,075 --> 00:30:42,960
0,150 150,345 345,525 525,735 735,885
by people who hadn't taken

1219
00:30:42,960 --> 00:30:44,400
0,135 135,380 400,800 1000,1290 1290,1440
a database course,| that was
|这就是问题所在。

1220
00:30:44,400 --> 00:30:46,080
0,120 120,380 1030,1320 1320,1515 1515,1680
the problem.| They said the
|他们说，我们能做到这个的最好方法是最终一致性，

1221
00:30:46,080 --> 00:30:46,755
0,165 165,315 315,420 420,540 540,675
best way we can make

1222
00:30:46,755 --> 00:30:47,610
0,165 165,375 375,570 570,705 705,855
this happen is to be

1223
00:30:47,610 --> 00:30:49,455
0,290 460,860 1180,1455 1455,1635 1635,1845
eventually consistent,| so let the
|所以，让更改发生，

1224
00:30:49,455 --> 00:30:51,740
0,300 300,695 1045,1365 1365,1685 1885,2285
changes happen| and then eventually
|然后最终如果两个事务对 A 进行更改，

1225
00:30:51,970 --> 00:30:54,240
0,335 335,670 840,1115 1115,1390 1980,2270
if a two transactions make

1226
00:30:54,240 --> 00:30:56,100
0,270 270,510 510,770 1000,1400 1600,1860
changes to A,| eventually they
|最终它们将是相同的。

1227
00:30:56,100 --> 00:30:57,045
0,120 120,255 255,405 405,680 700,945
would be the same.| So
|所以，如果从两个账户同时提取 25 美元，

1228
00:30:57,045 --> 00:30:58,875
0,210 210,495 495,915 915,1205 1285,1830
if that 25 dollars withdrawal

1229
00:30:58,875 --> 00:31:00,735
0,255 255,480 480,690 690,930 930,1860
from two accounts happening simultaneously,|
|

1230
00:31:00,735 --> 00:31:02,025
0,285 285,515 565,960 960,1200 1200,1290
it's like eventually they will
最终它们就会变成 50 美元，

1231
00:31:02,025 --> 00:31:02,930
0,120 120,285 285,435 435,600 600,905
end up to be 50,|
|

1232
00:31:03,160 --> 00:31:04,560
0,290 290,440 440,635 635,970 1080,1400
but for a while even
但有一段时间，即使两人都获得了 25 美元，

1233
00:31:04,560 --> 00:31:05,445
0,210 210,390 390,555 555,705 705,885
though both have been paid

1234
00:31:05,445 --> 00:31:06,810
0,375 375,665 835,1095 1095,1230 1230,1365
25 dollars,| you read the
|你读到的值，你会看到 75 ，

1235
00:31:06,810 --> 00:31:08,180
0,210 210,420 420,570 570,750 750,1370
value, you will see 75,|
|

1236
00:31:08,200 --> 00:31:09,735
0,245 245,365 365,785 785,1325 1325,1535
so the eventual consistency model
所以最终的一致性模型是，

1237
00:31:09,735 --> 00:31:10,580
0,335
is,|
|

1238
00:31:10,970 --> 00:31:12,685
0,365 365,500 500,635 635,880 1350,1715
don't trust the value, eventually
不要相信它的值，最终它会是正确的，

1239
00:31:12,685 --> 00:31:13,900
0,315 315,420 420,695 835,1095 1095,1215
it'll be right,| but the
|但从应用程序的角度来看，问题是，

1240
00:31:13,900 --> 00:31:15,310
0,195 195,390 390,615 615,980 1060,1410
question from the application perspective

1241
00:31:15,310 --> 00:31:16,495
0,350 490,765 765,945 945,1095 1095,1185
is,| how long do I
|我需要等待多长时间，

1242
00:31:16,495 --> 00:31:17,400
0,120 120,240 240,420 420,630 630,905
have to wait for it,|
|

1243
00:31:17,480 --> 00:31:18,420
0,275 275,425 425,530 530,650 650,940
and how do I know
我怎么知道什么是对的，什么是错的，

1244
00:31:18,650 --> 00:31:19,855
0,305 305,530 530,725 725,965 965,1205
when something is right or

1245
00:31:19,855 --> 00:31:21,160
0,275 505,795 795,945 945,1080 1080,1305
not,| and there were early
|在早期，人们还在构建这些应用程序，

1246
00:31:21,160 --> 00:31:22,290
0,270 270,465 465,660 660,855 855,1130
days when people were building

1247
00:31:22,610 --> 00:31:24,570
0,400 1050,1400 1400,1595 1595,1700 1700,1960
these applications,| with the venture
|有了 Facebook 应用程序的[风险]一致性，

1248
00:31:24,680 --> 00:31:25,975
0,545 545,790 810,1100 1100,1175 1175,1295
consistency where you'd have your

1249
00:31:25,975 --> 00:31:27,640
0,270 270,665 985,1335 1335,1500 1500,1665
Facebook APP,| you'd post a
|你发布一条消息，

1250
00:31:27,640 --> 00:31:28,580
0,260
message,|
|

1251
00:31:28,580 --> 00:31:29,900
0,260 490,780 780,960 960,1155 1155,1320
and your friend would see
你的朋友会看到，

1252
00:31:29,900 --> 00:31:31,240
0,210 210,405 405,540 540,990 990,1340
it,| you would refresh here
|你在这里刷新，它会消失，

1253
00:31:31,320 --> 00:31:32,170
0,245 245,335 335,440 440,575 575,850
and it would be gone,|
|

1254
00:31:32,220 --> 00:31:33,395
0,365 365,695 695,920 920,1040 1040,1175
because eventually it would be
因为它最终会在那里，

1255
00:31:33,395 --> 00:31:34,925
0,275 655,945 945,1125 1125,1425 1425,1530
there,| but just fetched from
|但只是从没有收到你的消息的不同服务器获取，

1256
00:31:34,925 --> 00:31:36,245
0,105 105,315 315,665 775,1050 1050,1320
a different server that hadn't

1257
00:31:36,245 --> 00:31:37,820
0,210 210,405 405,665 1075,1350 1350,1575
gotten your message,| your first
|你的第一个连接连接到服务器一，

1258
00:31:37,820 --> 00:31:38,855
0,270 270,480 480,660 660,825 825,1035
connection was made to server

1259
00:31:38,855 --> 00:31:40,745
0,335 505,855 855,1170 1170,1395 1395,1890
one,| second connection for refreshment
|第二个刷新的连接是另一个，

1260
00:31:40,745 --> 00:31:41,990
0,135 135,315 315,635 655,960 960,1245
is something else,| it hasn't
|它还没有得到更新。

1261
00:31:41,990 --> 00:31:43,260
0,195 195,465 465,800
gotten the update.|
|

1262
00:31:43,260 --> 00:31:43,910
0,75 75,135 135,225 225,360 360,650
So as you can imagine,|
所以，正如你可以想象的，|

1263
00:31:44,110 --> 00:31:45,735
0,365 365,665 665,980 980,1295 1295,1625
that became very hard for
这对应用程序程序员来说变得非常困难，

1264
00:31:45,735 --> 00:31:47,100
0,375 375,975 975,1110 1110,1230 1230,1365
application programmers to do,| the
|让数据库系统或数据平台处理事务的全部意义在于，

1265
00:31:47,100 --> 00:31:48,980
0,180 180,500 970,1245 1245,1500 1500,1880
whole point of having database

1266
00:31:49,030 --> 00:31:50,685
0,365 365,590 590,785 785,1120 1320,1655
systems or data platforms deal

1267
00:31:50,685 --> 00:31:52,275
0,210 210,485 865,1155 1155,1350 1350,1590
with transactions is,| so I,
|我作为一名应用程序程序员，我不必处理它。

1268
00:31:52,275 --> 00:31:53,745
0,195 195,435 435,765 765,1275 1275,1470
as an application programmer, don't

1269
00:31:53,745 --> 00:31:54,620
0,135 135,285 285,435 435,600 600,875
have to deal with it.|
|

1270
00:31:55,110 --> 00:31:57,665
0,400 630,1010 1010,1300 1350,2140 2160,2555
So it's now universally accepted,
所以，现在人们普遍认为这是一个非常糟糕的想法，

1271
00:31:57,665 --> 00:31:58,625
0,240 240,405 405,525 525,705 705,960
that it's a pretty bad

1272
00:31:58,625 --> 00:32:00,605
0,365 685,1085 1195,1500 1500,1710 1710,1980
idea,| unless there you have
|除非你对性能有非常严格的要求，

1273
00:32:00,605 --> 00:32:02,525
0,365 445,840 840,1235 1255,1605 1605,1920
very strict requirements for performance,|
|

1274
00:32:02,525 --> 00:32:03,695
0,365 385,705 705,900 900,1035 1035,1170
that require you to do
要求你只做这件事。

1275
00:32:03,695 --> 00:32:05,120
0,225 225,480 480,675 675,965
nothing but just that.|
|

1276
00:32:06,030 --> 00:32:07,115
0,320 320,515 515,695 695,905 905,1085
But it is not the
但这不是构建数据平台的方法说，

1277
00:32:07,115 --> 00:32:08,255
0,180 180,360 360,635 745,1005 1005,1140
go to way to build

1278
00:32:08,255 --> 00:32:09,845
0,225 225,575 595,885 885,1175 1315,1590
data platforms by saying,| you,
|你作为应用程序人员开始担心事务。

1279
00:32:09,845 --> 00:32:11,450
0,270 270,615 615,965 1015,1305 1305,1605
the application person, start worrying

1280
00:32:11,450 --> 00:32:12,900
0,180 180,470
about transactions.|
|

1281
00:32:12,900 --> 00:32:15,050
0,240 240,555 555,825 825,1130 1750,2150

1282
00:32:15,530 --> 00:32:16,795
0,320 320,530 530,710 710,995 995,1265
{} Bunch of systems still
很多系统仍然使用最终一致性，

1283
00:32:16,795 --> 00:32:18,895
0,210 210,695 925,1200 1200,1655 1705,2100
use {eventual,consistency},| but I'll briefly
|但我将简单地展示一下 Spanner 论文，

1284
00:32:18,895 --> 00:32:20,820
0,330 330,600 600,915 915,1295 1525,1925
flash the Spanner paper,| which
|它在全球范围内使用，

1285
00:32:21,050 --> 00:32:23,095
0,820 840,1145 1145,1450 1650,1925 1925,2045
globally is using things,| that
|甚至比 ACID 更强。

1286
00:32:23,095 --> 00:32:24,300
0,105 105,360 360,720 720,945 945,1205
are even stronger than ACID.|
|

1287
00:32:24,960 --> 00:32:25,890
0,240 240,435 435,645 645,810 810,930
And then again, if you
再说一次，如果你上了高级数据库课，

1288
00:32:25,890 --> 00:32:27,230
0,135 135,315 315,540 540,860 940,1340
take the advanced database class,|
|

1289
00:32:27,310 --> 00:32:28,485
0,275 275,470 470,725 725,980 980,1175
we talk about stuff like
我们会在那里讨论类似的东西。

1290
00:32:28,485 --> 00:32:29,990
0,195 195,450 450,785 925,1215 1215,1505
that over there, is there.|
|

1291
00:32:30,010 --> 00:32:31,460
0,365 365,680 680,845 845,1100 1100,1450
So it's not that systems
所以，这并不是说今天的系统不使用它，

1292
00:32:31,570 --> 00:32:33,465
0,410 410,605 605,815 815,1120 1410,1895
don't use that today,| I'm
|我只是说，

1293
00:32:33,465 --> 00:32:34,935
0,150 150,455 865,1140 1140,1320 1320,1470
just saying,| in my view,
|在我看来，这不是一个好主意，

1294
00:32:34,935 --> 00:32:35,780
0,165 165,255 255,360 360,525 525,845
it's not a good idea,|
|

1295
00:32:35,980 --> 00:32:37,005
0,305 305,500 500,650 650,770 770,1025
to use that as a
将它作为构建数据平台的默认方式。

1296
00:32:37,005 --> 00:32:37,920
0,315 315,525 525,675 675,795 795,915
default way to build a

1297
00:32:37,920 --> 00:32:39,020
0,195 195,530
data platform.|
|

1298
00:32:39,120 --> 00:32:40,310
0,320 320,470 470,680 680,965 965,1190
There's still some reasons why
你可能想这么做还是有一些原因的，

1299
00:32:40,310 --> 00:32:40,925
0,120 120,225 225,360 360,495 495,615
you may want to do

1300
00:32:40,925 --> 00:32:41,945
0,165 165,285 285,465 465,725 775,1020
that,| but it's not the
|但这不是你应该说的方式，

1301
00:32:41,945 --> 00:32:42,875
0,105 105,240 240,390 390,615 615,930
way you should say,| I'm
|我要让我的数据库在设计上保持最终一致性，

1302
00:32:42,875 --> 00:32:43,630
0,90 90,180 180,315 315,480 480,755
going to make my database

1303
00:32:43,800 --> 00:32:45,940
0,350 350,665 665,1145 1145,1805 1805,2140
by design eventual consistency,| because,
|因为，我没有想过做其他方式来做完整的事务，

1304
00:32:46,640 --> 00:32:47,620
0,210 210,435 435,540 540,690 690,980
I didn't think of doing

1305
00:32:47,820 --> 00:32:48,890
0,320 320,530 530,695 695,875 875,1070
other ways of doing full

1306
00:32:48,890 --> 00:32:51,005
0,290 910,1260 1260,1610 1660,1965 1965,2115
transactions,| their performance,| obviously you
|它们的性能，|显然，最终一致性可以获得更高的性能，

1307
00:32:51,005 --> 00:32:51,950
0,105 105,240 240,450 450,735 735,945
can get more performance with

1308
00:32:51,950 --> 00:32:53,345
0,480 480,885 885,1110 1110,1215 1215,1395
eventual consistency,| there's no doubt
|这一点是毫无疑问的。

1309
00:32:53,345 --> 00:32:54,300
0,195 195,485
about that.|
|

1310
00:32:54,300 --> 00:32:55,970
0,240 240,405 405,555 555,860 1270,1670
Sorry for this question, but.|
对于这个问题我很抱歉，但是。|

1311
00:32:56,330 --> 00:32:57,565
0,290 290,470 470,635 635,910 960,1235
I close my ears, everyone
我闭上耳朵。大家都闭上耳朵，没有。

1312
00:32:57,565 --> 00:32:58,800
0,165 165,330 330,585 585,900 900,1235
close their ears, no.| Basically,
|基本上，什么是最终一致性？

1313
00:33:00,920 --> 00:33:04,000
0,350 350,560 560,820 2010,2525 2525,3080
so what is {eventual,consistency}?| {Eventual,consistency}
|最终一致性是指，

1314
00:33:04,000 --> 00:33:05,545
0,290 490,885 885,1170 1170,1305 1305,1545
says,| eventually all the values
|最终所有的值都会是正确的值。

1315
00:33:05,545 --> 00:33:06,570
0,270 270,405 405,525 525,705 705,1025
will be the right values.|
|

1316
00:33:07,510 --> 00:33:08,460
0,230 230,470 470,650 650,815 815,950
So, it'll feel like you
所以，它就像你获得了你的事务，

1317
00:33:08,460 --> 00:33:09,615
0,135 135,285 285,560 730,1020 1020,1155
got your transactions,| but for
|但在一段时间内，你可能会看到不一致的值，

1318
00:33:09,615 --> 00:33:10,275
0,90 90,240 240,390 390,525 525,660
a while, you may see

1319
00:33:10,275 --> 00:33:11,730
0,645 645,915 915,1140 1140,1335 1335,1455
inconsistent value,| so that's what
|这就是最终一致性。

1320
00:33:11,730 --> 00:33:13,485
0,390 390,975 975,1220 1330,1560 1560,1755
eventual consistency is.| So an
|所以，就像应用程序到达那里，

1321
00:33:13,485 --> 00:33:16,170
0,365 505,810 810,1115 1615,2015 2395,2685
application gets there, like reaching

1322
00:33:16,170 --> 00:33:16,890
0,150 150,255 255,555 555,645 645,720
in the []| and it
|而它可能是错误的。

1323
00:33:16,890 --> 00:33:17,880
0,120 120,270 270,405 405,650 700,990
might just be wrong.| Yeah,
|是的，就像我说的，

1324
00:33:17,880 --> 00:33:18,825
0,150 150,300 300,570 570,810 810,945
as I said,| you may
|你可能会短期看到 75 美元，

1325
00:33:18,825 --> 00:33:19,830
0,150 150,630 630,780 780,870 870,1005
see 75 for a while,|
|

1326
00:33:19,830 --> 00:33:20,600
0,135 135,240 240,360 360,495 495,770
then it should be 50,|
然后它应该是 50 美元，|

1327
00:33:21,100 --> 00:33:22,410
0,275 275,410 410,670 690,1070 1070,1310
both of you, you're standing
你们并排站在两台并排的 ATM 机边上，

1328
00:33:22,410 --> 00:33:23,145
0,240 240,360 360,450 450,585 585,735
next to each other on

1329
00:33:23,145 --> 00:33:24,380
0,270 270,555 555,735 735,930 930,1235
two side by side ATM

1330
00:33:24,520 --> 00:33:26,220
0,400 570,845 845,995 995,1270 1410,1700
machines,| both of you got
|你们两个都拿到了 25 美元，

1331
00:33:26,220 --> 00:33:27,135
0,165 165,510 510,690 690,825 825,915
your 25 bucks| and you
|你们会说，哦， 75 美元在银行里，

1332
00:33:27,135 --> 00:33:28,545
0,120 120,270 270,750 750,1245 1245,1410
will say, {oh\,,75 -} is

1333
00:33:28,545 --> 00:33:29,480
0,135 135,240 240,485
in the bank,|
|

1334
00:33:29,480 --> 00:33:30,530
0,195 195,315 315,495 495,795 795,1050
which is not true,| and
但事实并非如此，|银行会说，

1335
00:33:30,530 --> 00:33:31,460
0,105 105,255 255,495 495,750 750,930
the bank will say,| you
|实际上我们寄给你的是 50 美元，

1336
00:33:31,460 --> 00:33:32,315
0,120 120,255 255,390 390,600 600,855
know what, it was actually

1337
00:33:32,315 --> 00:33:33,530
0,285 285,645 645,885 885,1005 1005,1215
50 we sent you that,|
|

1338
00:33:33,530 --> 00:33:34,385
0,315 315,525 525,630 630,750 750,855
eventually it will be the
最终会是正确的金额。

1339
00:33:34,385 --> 00:33:35,320
0,165 165,485
right amount.|
|

1340
00:33:35,800 --> 00:33:36,630
0,275 275,440 440,575 575,695 695,830
But as you can see,
但如你所见，这很难，

1341
00:33:36,630 --> 00:33:37,935
0,195 195,405 405,770 880,1140 1140,1305
it's hard, right,| you don't
|你不希望在你的应用程序中出现这种情况。

1342
00:33:37,935 --> 00:33:39,060
0,135 135,330 330,495 495,750 750,1125
want that in your application.|
|

1343
00:33:39,060 --> 00:33:39,980
0,380
Yep.|
是的。|

1344
00:33:40,460 --> 00:33:42,660
0,400 750,1040 1040,1330
Yeah, another question?|
是的，还有问题吗？|

1345
00:33:46,210 --> 00:33:47,385
0,290 290,440 440,530 530,695 695,1175
No, there are other []
不，还有其他[]有最终的致性，

1346
00:33:47,385 --> 00:33:49,280
0,195 195,615 615,1170 1170,1445 1495,1895
has eventual consistency,| other systems,
|其他系统也有最终一致性模型。

1347
00:33:49,330 --> 00:33:51,350
0,400 480,815 815,1250 1250,1760 1760,2020
too, have eventual consistency models.|
|

1348
00:33:52,640 --> 00:33:54,000
0,290 340,630 630,920

1349
00:33:56,350 --> 00:33:57,620
0,275 275,455 455,635 635,890 890,1270
Put this term out, yes.|
把这个词拿出来，是的。|

1350
00:33:57,790 --> 00:33:59,610
0,400 780,1100 1100,1295 1295,1565 1565,1820
Ah, but, but there there
但是有一段时间人们说，

1351
00:33:59,610 --> 00:34:00,645
0,120 120,270 270,555 555,855 855,1035
was a whole time where

1352
00:34:00,645 --> 00:34:02,085
0,275 355,645 645,935 1015,1260 1260,1440
people were saying,| we don't
|我们不需要 SQL ，

1353
00:34:02,085 --> 00:34:03,195
0,150 150,615 615,840 840,1005 1005,1110
need SQL,| we don't need
|我们不需要事务，

1354
00:34:03,195 --> 00:34:06,630
0,275 805,1590 1590,2100 2100,2795 3145,3435
transactions,| {no,SQL}, eventual consistency that
|没有 SQL ，最终一致性对这些人来说并不是很有效。

1355
00:34:06,630 --> 00:34:07,770
0,315 315,480 480,660 660,915 915,1140
hasn't quite worked out for

1356
00:34:07,770 --> 00:34:08,820
0,165 165,470
those people.|
|

1357
00:34:09,830 --> 00:34:11,035
0,350 350,650 650,770 770,950 950,1205
So I'm not saying there's
所以，我并不是说没有必要保持最终的一致性，

1358
00:34:11,035 --> 00:34:12,730
0,195 195,405 405,600 600,1050 1050,1695
no call for eventual consistency,|
|

1359
00:34:12,730 --> 00:34:13,585
0,270 270,375 375,615 615,735 735,855
I'm saying that's not what
我的意思是，默认情况下，这不是你应该为之设计的，

1360
00:34:13,585 --> 00:34:15,100
0,120 120,345 345,660 660,1025 1135,1515
you should design for by

1361
00:34:15,100 --> 00:34:16,645
0,380 910,1170 1170,1290 1290,1410 1410,1545
default,| unless you know what
|除非你知道你要面对的是什么，

1362
00:34:16,645 --> 00:34:17,875
0,180 180,300 300,605 805,1080 1080,1230
you're getting into,| and now
|而现在你将不得不将复杂性放在应用程序中。

1363
00:34:17,875 --> 00:34:18,385
0,180 180,240 240,315 315,405 405,510
you're going to have to

1364
00:34:18,385 --> 00:34:19,345
0,105 105,300 300,675 675,750 750,960
put the complexity in the

1365
00:34:19,345 --> 00:34:20,280
0,365
application.|
|

1366
00:34:20,850 --> 00:34:21,760
0,400
Okay?|
好的？|

1367
00:34:22,670 --> 00:34:23,560
0,275 275,410 410,560 560,725 725,890
So there is still some
所以，它仍然有一些位置，

1368
00:34:23,560 --> 00:34:24,550
0,210 210,390 390,540 540,720 720,990
place for it,| but not
|但这并不是默认设置。

1369
00:34:24,550 --> 00:34:25,555
0,255 255,480 480,585 585,780 780,1005
like that's not the default

1370
00:34:25,555 --> 00:34:26,440
0,305
setting.|
|

1371
00:34:26,450 --> 00:34:28,885
0,400 900,1300 1590,1985 1985,2195 2195,2435
So, alright, let's go find
所以，好的，让我们再去找我的鼠标，

1372
00:34:28,885 --> 00:34:30,115
0,165 165,390 390,755 835,1110 1110,1230
my mouse again,| there we
|我们走吧。

1373
00:34:30,115 --> 00:34:30,880
0,245
go.|
|

1374
00:34:32,650 --> 00:34:34,500
0,275 275,530 530,910 1050,1655 1655,1850
All right, so isolation of
好的，事务的隔离性。

1375
00:34:34,500 --> 00:34:35,520
0,260 430,690 690,780 780,885 885,1020
transactions.| So we are still
|所以我们仍然在 I ，

1376
00:34:35,520 --> 00:34:37,220
0,150 150,440 790,1110 1110,1365 1365,1700
on I,| users submit transaction,|
|用户提交事务，|

1377
00:34:37,420 --> 00:34:39,045
0,305 305,610 810,1265 1265,1490 1490,1625
each transaction executes as if
每个事务的执行方式就像它自己运行一样，

1378
00:34:39,045 --> 00:34:39,950
0,90 90,195 195,360 360,585 585,905
it is running by itself,|
|

1379
00:34:40,630 --> 00:34:41,775
0,365 365,635 635,830 830,920 920,1145
and obviously it's an easier
正如我们所说的，显然它是一种更容易的编程模型，

1380
00:34:41,775 --> 00:34:43,005
0,365 385,690 690,870 870,1020 1020,1230
programming model as we talked

1381
00:34:43,005 --> 00:34:44,775
0,335 595,915 915,1095 1095,1530 1530,1770
about,| and the DBMS is
|而 DBMS 将做它的事情，

1382
00:34:44,775 --> 00:34:45,770
0,195 195,375 375,480 480,660 660,995
going to do its stuff|
|

1383
00:34:45,910 --> 00:34:47,505
0,400 630,920 920,1205 1205,1475 1475,1595
to give this {one-at-a-time -
给这个每次一个或隔离的原则。

1384
00:34:47,505 --> 00:34:49,725
0,120 120,395 475,780 780,1385 1945,2220
- -} or isolation as

1385
00:34:49,725 --> 00:34:52,120
0,150 150,425 595,995 1165,1565
a principle.| So, {}
|所以，它是如果做到这个的？

1386
00:34:52,640 --> 00:34:53,580
0,275 275,410 410,530 530,665 665,940
how does it do that?|
|

1387
00:34:54,590 --> 00:34:56,485
0,260 260,440 440,760 1260,1640 1640,1895
There are two classes of
这里有两类方法，

1388
00:34:56,485 --> 00:34:58,075
0,240 240,510 510,815 1105,1395 1395,1590
methods,| and again today I'm
|再次，今天我从高层次上概述它，

1389
00:34:58,075 --> 00:34:59,110
0,120 120,240 240,390 390,885 885,1035
just going to outline it

1390
00:34:59,110 --> 00:34:59,965
0,120 120,240 240,375 375,600 600,855
at a high level,| we'll
|我们将在下次课程中详细介绍。

1391
00:34:59,965 --> 00:35:00,895
0,105 105,225 225,480 480,765 765,930
get into the details of

1392
00:35:00,895 --> 00:35:02,310
0,275 595,840 840,945 945,1110 1110,1415
it in the next lecture.|
|

1393
00:35:02,660 --> 00:35:03,970
0,275 275,470 470,790 840,1115 1115,1310
The two classes,| one is
两节课，|一个是悲观的，也就是说，

1394
00:35:03,970 --> 00:35:05,820
0,830 1000,1275 1275,1410 1410,1560 1560,1850
pessimistic, which is to say,|
|

1395
00:35:06,520 --> 00:35:07,555
0,255 255,540 540,765 765,900 900,1035
even before I let a
即使在我允许读写发生之前，

1396
00:35:07,555 --> 00:35:08,905
0,150 150,315 315,495 495,785 985,1350
read and write happen,| I'm
|我是悲观的，

1397
00:35:08,905 --> 00:35:10,075
0,90 90,180 180,300 300,960 960,1170
going to be pessimistic,| if
|如果我认为会发生一些不好的事情，

1398
00:35:10,075 --> 00:35:11,095
0,165 165,345 345,585 585,930 930,1020
I think something bad's going

1399
00:35:11,095 --> 00:35:12,010
0,90 90,335 415,735 735,810 810,915
to happen,| I'm going to
|我会阻止你，

1400
00:35:12,010 --> 00:35:13,260
0,180 180,375 375,630 630,930 930,1250
hold you back,| hold you
|阻止我认为会开始这个不好的操作的事务，

1401
00:35:13,340 --> 00:35:14,470
0,275 275,550 660,905 905,1010 1010,1130
that transaction that I think

1402
00:35:14,470 --> 00:35:15,265
0,135 135,285 285,450 450,630 630,795
is going to start this

1403
00:35:15,265 --> 00:35:17,200
0,150 150,420 420,815 1465,1740 1740,1935
bad action back,| and we'll
|我们将通过几个机制来看看这是如何发生的。

1404
00:35:17,200 --> 00:35:18,520
0,180 180,375 375,540 540,830 1060,1320
see how that happens in

1405
00:35:18,520 --> 00:35:19,480
0,120 120,285 285,525 525,780 780,960
a little bit with, with

1406
00:35:19,480 --> 00:35:21,140
0,120 120,270 270,450 450,1130
a couple of mechanisms.|
|

1407
00:35:21,600 --> 00:35:23,240
0,320 320,605 605,970
The second way
第二种方式基本上就是做一个叫乐观并发的事情，

1408
00:35:23,240 --> 00:35:26,690
0,320 520,920 1090,1490 2170,2570 3160,3450
{} is basically to do

1409
00:35:26,690 --> 00:35:29,560
0,290 310,710 1060,1460 1720,2120 2470,2870
something called { -} optimistic

1410
00:35:30,000 --> 00:35:31,210
0,605 605,710 710,830 830,950 950,1210
concurrency,| which is to say,|
|也就是说，|

1411
00:35:31,470 --> 00:35:33,065
0,320 320,640 690,1090 1110,1400 1400,1595
I think every life is
我觉得每个生活都是好的，

1412
00:35:33,065 --> 00:35:34,475
0,305 685,1020 1020,1140 1140,1260 1260,1410
good,| I'm going to let
|我要让每一个事务都通过，

1413
00:35:34,475 --> 00:35:36,400
0,240 240,575 715,1035 1035,1355
every transaction go through,|
|

1414
00:35:36,400 --> 00:35:37,585
0,210 210,405 405,615 615,735 735,1185
I'll still provide the isolation
我仍然会提供隔离原则，

1415
00:35:37,585 --> 00:35:39,085
0,365 415,675 675,935 1015,1275 1275,1500
principle,| so that they don't
|这样它们就不会相互干扰，

1416
00:35:39,085 --> 00:35:40,990
0,480 480,660 660,825 825,1115 1585,1905
interfere with each other,| but
|但我会通过检查来做到这个，

1417
00:35:40,990 --> 00:35:41,785
0,255 255,360 360,480 480,615 615,795
I'm going to do that

1418
00:35:41,785 --> 00:35:43,480
0,255 255,605 805,1205 1315,1560 1560,1695
by checking,| assuming everything is
|假设一切都会顺利进行，

1419
00:35:43,480 --> 00:35:44,230
0,195 195,360 360,480 480,630 630,750
going to go well,| so
|所以，就像每个人都去你的读写，

1420
00:35:44,230 --> 00:35:45,325
0,165 165,410 550,825 825,975 975,1095
it's like everyone go to

1421
00:35:45,325 --> 00:35:46,285
0,105 105,255 255,405 405,645 645,960
your reads and writes,| I'll
|我会跟踪它，去做你的变更，

1422
00:35:46,285 --> 00:35:47,155
0,135 135,315 315,495 495,690 690,870
keep track of it, go

1423
00:35:47,155 --> 00:35:48,730
0,150 150,300 300,575 1075,1350 1350,1575
make your changes,| but before
|但在你准备提交之前，

1424
00:35:48,730 --> 00:35:49,945
0,285 285,435 435,740 790,1065 1065,1215
you're ready {to,commit},| I will
|我会做一些检查，

1425
00:35:49,945 --> 00:35:50,845
0,165 165,345 345,600 600,765 765,900
do some checks| to see
|看看你们是否相互干扰，

1426
00:35:50,845 --> 00:35:51,850
0,120 120,255 255,405 405,840 840,1005
if you guys interfered with

1427
00:35:51,850 --> 00:35:52,660
0,135 135,345 345,555 555,690 690,810
each other,| all of you
|你们所有的人，

1428
00:35:52,660 --> 00:35:53,820
0,260 370,645 645,780 780,900 900,1160
guys,| all of you transactions
|你们所有同时运行的事务。

1429
00:35:53,840 --> 00:35:55,890
0,260 260,380 380,640 720,1070 1070,2050
that were running together simultaneously.|
|

1430
00:35:56,340 --> 00:35:58,720
0,380 380,760 900,1300 1770,2075 2075,2380
So optimistic is most transactions
所以，乐观是，大多数事务并不相互冲突，

1431
00:35:58,920 --> 00:36:00,220
0,425 425,665 665,890 890,1025 1025,1300
don't conflict with each other,|
|

1432
00:36:00,390 --> 00:36:01,040
0,230 230,305 305,425 425,545 545,650
so I can get a
所以，我可以通过乐观获得更高性能的系统，

1433
00:36:01,040 --> 00:36:03,490
0,240 240,620 640,1040 1510,1910 2050,2450
higher performance system by being

1434
00:36:03,510 --> 00:36:05,045
0,400 600,890 890,1130 1130,1370 1370,1535
optimistic,| that most things will
|大多数事情都会解决，

1435
00:36:05,045 --> 00:36:06,215
0,165 165,455 595,855 855,1005 1005,1170
work out,| It will still
|它仍然是正确的，

1436
00:36:06,215 --> 00:36:07,400
0,195 195,515 835,1050 1050,1095 1095,1185
be correct,| so it will
|所以它将确保不会发生不好的事情，

1437
00:36:07,400 --> 00:36:08,285
0,150 150,315 315,480 480,660 660,885
make sure bad things don't

1438
00:36:08,285 --> 00:36:09,305
0,245 355,570 570,720 720,825 825,1020
happen,| but it's a different
|但这是一种不同的哲学。

1439
00:36:09,305 --> 00:36:10,420
0,335
philosophy.|
|

1440
00:36:12,890 --> 00:36:13,940
0,275 275,550
All right,
好的，所以。

1441
00:36:14,280 --> 00:36:16,400
0,400
so.|
|

1442
00:36:20,440 --> 00:36:21,585
0,365 365,575 575,905 905,1025 1025,1145
Let's start digging into a
让我们开始深入研究几个例子。

1443
00:36:21,585 --> 00:36:22,860
0,120 120,300 300,605 715,1050 1050,1275
couple of examples.| Now, as
|现在，我们知道，事务将被转换为这些读写操作，

1444
00:36:22,860 --> 00:36:24,210
0,165 165,440 490,890 970,1215 1215,1350
we know, transactions are going

1445
00:36:24,210 --> 00:36:25,620
0,135 135,380 670,1005 1005,1230 1230,1410
to be cast in terms

1446
00:36:25,620 --> 00:36:27,020
0,165 165,360 360,570 570,860 1000,1400
of these read write operations|
|

1447
00:36:27,280 --> 00:36:28,215
0,260 260,365 365,545 545,710 710,935
and now you're starting to
现在你开始看到一些 BEGIN 和 COMMIT 调用进入。

1448
00:36:28,215 --> 00:36:29,610
0,305 475,735 735,855 855,1065 1065,1395
see some of the BEGIN

1449
00:36:29,610 --> 00:36:30,825
0,380 400,705 705,945 945,1125 1125,1215
and COMMIT calls that are

1450
00:36:30,825 --> 00:36:31,755
0,150 150,345 345,600 600,825 825,930
coming in.| So, {T1 -}
|所以， T1 是一个事务，

1451
00:36:31,755 --> 00:36:33,855
0,90 90,195 195,455 985,1455 1455,2100
is a transaction,| that subtracting,|
|那个减法，|

1452
00:36:33,855 --> 00:36:35,295
0,255 255,495 495,795 795,1110 1110,1440
that moving 100 dollars from
它将 100 美元从银行帐户 A 转移到银行帐户 B ，

1453
00:36:35,295 --> 00:36:36,300
0,285 285,510 510,675 675,810 810,1005
bank account A to bank

1454
00:36:36,300 --> 00:36:38,610
0,270 270,590 910,1310 1840,2145 2145,2310
account B,| and {T2 -}
|T2 是一个事务，

1455
00:36:38,610 --> 00:36:39,950
0,120 120,240 240,500 610,1065 1065,1340
is a transaction,| that's adding
|为所有银行帐户增加 6% 利息，

1456
00:36:40,150 --> 00:36:42,000
0,640 840,1240 1350,1595 1595,1715 1715,1850
6% interest to all the

1457
00:36:42,000 --> 00:36:43,170
0,225 225,540 540,810 810,1020 1020,1170
bank accounts| and assume this
|假设这是一家小银行，

1458
00:36:43,170 --> 00:36:44,505
0,120 120,380 490,825 825,1140 1140,1335
is a small bank,| so
|所以它只有两个银行帐户，

1459
00:36:44,505 --> 00:36:45,330
0,75 75,210 210,420 420,615 615,825
it just has two bank

1460
00:36:45,330 --> 00:36:46,140
0,350
accounts,|
|

1461
00:36:47,860 --> 00:36:49,100
0,260 260,410 410,590 590,860 860,1240
also keeps the example simple.|
还可以使示例保持简单。|

1462
00:36:50,300 --> 00:36:51,595
0,350 350,440 440,700 870,1130 1130,1295
What's the possible outcome of
这两个事务可能的结果是什么？

1463
00:36:51,595 --> 00:36:52,940
0,240 240,510 510,845
running these two?|
|

1464
00:36:53,320 --> 00:36:55,220
0,275 275,425 425,700 900,1300
The two possible outcomes.|
两种可能的结果。|

1465
00:36:55,340 --> 00:36:56,640
0,305 305,610
One is,|
一个是，|

1466
00:36:56,640 --> 00:36:57,680
0,260

1467
00:36:57,780 --> 00:36:58,775
0,290 290,485 485,665 665,815 815,995
assume both A and B,
假设 A 和 B 都是，从 1000 美元开始，

1468
00:36:58,775 --> 00:36:59,770
0,180 180,315 315,435 435,645 645,995
start with {1000 -} dollars,|
|

1469
00:37:00,660 --> 00:37:02,480
0,290 290,580 720,1120
if I run
如果我运行 A 在 B 之前或 B 在 A 之前，

1470
00:37:02,480 --> 00:37:04,340
0,240 240,585 585,870 870,1190 1540,1860
A followed by B or

1471
00:37:04,340 --> 00:37:05,915
0,240 240,510 510,765 765,1070 1210,1575
B followed by A,| I'm
|我会得到两种不同的执行策略，

1472
00:37:05,915 --> 00:37:07,060
0,120 120,270 270,545 595,870 870,1145
going to get two different

1473
00:37:08,790 --> 00:37:11,435
0,400 420,820 1320,1685 1685,2050 2280,2645
execution strategies,| but eventually A
|但最终 A 加上 B 应该是 2000 6% ，

1474
00:37:11,435 --> 00:37:15,050
0,330 330,695 1105,1380 1380,1545 1545,3615
plus B should be {2000,and,6%},|
|

1475
00:37:15,050 --> 00:37:16,760
0,255 255,560 790,1190 1240,1515 1515,1710
of that means that the
这意味着总的银行账户，

1476
00:37:16,760 --> 00:37:18,340
0,315 315,675 675,1040
total bank account,|
|

1477
00:37:18,380 --> 00:37:20,100
0,305 305,530 530,725 725,1000
across those two banks,|
跨越这两家银行，|

1478
00:37:20,170 --> 00:37:22,740
0,290 290,560 1040,1990
should be 2120.|
应该是 2120 。|

1479
00:37:23,470 --> 00:37:24,440
0,400
So,
所以，这就是我们想要的结果。

1480
00:37:24,660 --> 00:37:25,655
0,440 440,575 575,710 710,860 860,995
that's what we want to

1481
00:37:25,655 --> 00:37:26,700
0,120 120,315 315,635
end up with.|
|

1482
00:37:26,740 --> 00:37:27,840
0,400
Now,
现在，接下来我们要看的是，

1483
00:37:28,830 --> 00:37:30,155
0,400 690,920 920,1010 1010,1160 1160,1325
what we are going to

1484
00:37:30,155 --> 00:37:31,235
0,135 135,315 315,635 655,975 975,1080
look at next,| I'm just
|我将跳到这里是，

1485
00:37:31,235 --> 00:37:32,230
0,120 120,240 240,405 405,645 645,995
going to jump into this

1486
00:37:32,370 --> 00:37:33,680
0,400
is,|
|

1487
00:37:34,080 --> 00:37:35,530
0,335 335,620 620,905 905,1145 1145,1450
with just these two transactions,|
只有这两个事务，|

1488
00:37:36,420 --> 00:37:37,610
0,275 275,410 410,545 545,820 840,1190
I could have a correct
我可以保持正确的隔离属性，

1489
00:37:37,610 --> 00:37:40,600
0,710 1150,1545 1545,1845 1845,2150 2590,2990
isolation property being held| by
|通过无论先运行第一个事务，

1490
00:37:40,890 --> 00:37:42,610
0,350 350,700 960,1220 1220,1400 1400,1720
either running the first transaction

1491
00:37:42,810 --> 00:37:43,880
0,400
first,|
|

1492
00:37:43,920 --> 00:37:45,550
0,400 570,890 890,1085 1085,1295 1295,1630
and running the second transaction
和先运行第二个事务，

1493
00:37:45,990 --> 00:37:47,140
0,400 450,680 680,755 755,875 875,1150
first,| there are two possible
|这里有两种可能的结果，

1494
00:37:47,220 --> 00:37:48,430
0,350 350,560 560,695 695,890 890,1210
outcomes,| {T1 -} runs first
|T1 在 T2 之前运行，或者相反。

1495
00:37:48,570 --> 00:37:49,895
0,305 305,515 515,710 710,1000 1050,1325
followed by {T2 -} or

1496
00:37:49,895 --> 00:37:51,560
0,240 240,815 985,1275 1275,1440 1440,1665
vice versa.| And so here
|所以，在这里你可以看到，

1497
00:37:51,560 --> 00:37:53,050
0,210 210,375 375,680 790,1140 1140,1490
you can see,| one example,
|一个例子， A 的值是 954 ， B 是 1166 ，

1498
00:37:53,130 --> 00:37:54,910
0,400 720,995 995,1220 1220,1475 1475,1780
where the value of A

1499
00:37:55,440 --> 00:37:56,675
0,350 350,605 605,860 860,1070 1070,1235
is {954 - -} and

1500
00:37:56,675 --> 00:37:57,820
0,165 165,300 300,480 480,765 765,1145
B is {1166 - -},|
|

1501
00:37:57,900 --> 00:37:59,390
0,275 275,410 410,670 780,1175 1175,1490
that will correspond to having
这相当于首先完成了 100 美元的转账，然后加上 6% ，

1502
00:37:59,390 --> 00:38:00,640
0,210 210,330 330,600 600,885 885,1250
done the 100 dollars transfer

1503
00:38:00,720 --> 00:38:03,080
0,400 600,890 890,1145 1145,1510 2070,2360
first, then adding 6%,| and
|另一个是反过来做的。

1504
00:38:03,080 --> 00:38:04,085
0,150 150,315 315,570 570,825 825,1005
the other one is doing

1505
00:38:04,085 --> 00:38:04,930
0,150 150,255 255,390 390,570 570,845
it the other way around.|
|

1506
00:38:06,350 --> 00:38:07,735
0,400 420,755 755,965 965,1115 1115,1385
So either one of those
所以，根据隔离原则，这两种中的任何一种都是正确的，

1507
00:38:07,735 --> 00:38:09,265
0,270 270,405 405,885 885,1215 1215,1530
by the isolation principle is

1508
00:38:09,265 --> 00:38:10,885
0,225 225,390 390,570 570,875 1345,1620
correct,| if both transactions are
|如果两个事务同时在系统中，

1509
00:38:10,885 --> 00:38:11,695
0,135 135,270 270,465 465,660 660,810
in the system at the

1510
00:38:11,695 --> 00:38:13,350
0,195 195,515 835,1095 1095,1305 1305,1655
same time,| we are okay,|
|我们没有问题，|

1511
00:38:13,370 --> 00:38:14,610
0,245 245,350 350,485 485,760 840,1240
we as a transaction management
作为一个事务管理系统，

1512
00:38:14,630 --> 00:38:16,045
0,400 510,860 860,1055 1055,1190 1190,1415
system| are okay in picking
|我们可以选择那个顺序，

1513
00:38:16,045 --> 00:38:17,275
0,195 195,420 420,750 750,1050 1050,1230
that order,| so let's just
|所以，让我们更直观地看待它，

1514
00:38:17,275 --> 00:38:18,900
0,195 195,330 330,480 480,755 1045,1625
look at it more visually|
|

1515
00:38:19,070 --> 00:38:20,220
0,290 290,455 455,635 635,845 845,1150
and that might make sense.|
这可能是有意义的。|

1516
00:38:21,320 --> 00:38:22,195
0,215 215,275 275,425 425,665 665,875
There is this notion of
有一种串行执行的概念，

1517
00:38:22,195 --> 00:38:23,940
0,180 180,665 685,1085
a serial execution,|
|

1518
00:38:23,940 --> 00:38:25,290
0,120 120,255 255,630 630,945 945,1350
and the serial execution diagram
我们将在接下来的 10 到 15 张幻灯片中看到的串行执行图，

1519
00:38:25,290 --> 00:38:26,550
0,165 165,420 420,710 880,1140 1140,1260
that we'll see in the

1520
00:38:26,550 --> 00:38:27,860
0,225 225,480 480,645 645,915 915,1310
next 10 or 15 slides,|
|

1521
00:38:28,150 --> 00:38:29,150
0,290 290,440 440,590 590,740 740,1000
all are going to have
所有都有时间从上到下，

1522
00:38:29,350 --> 00:38:31,035
0,400 420,820 960,1280 1280,1520 1520,1685
time going from top to

1523
00:38:31,035 --> 00:38:32,850
0,105 105,365 805,1080 1080,1355 1555,1815
the bottom,| so, imagine you
|想象一下，你是机器，

1524
00:38:32,850 --> 00:38:34,110
0,120 120,300 300,620 790,1065 1065,1260
are the machine| and you're
|你看着事务向你过来。

1525
00:38:34,110 --> 00:38:35,570
0,195 195,560 730,990 990,1155 1155,1460
watching transactions come at you.|
|

1526
00:38:36,100 --> 00:38:38,870
0,400 690,1355 1355,1720 1800,2200 2370,2770
And isolation basically says,| if
隔离性基本上是说，|如果这个执行是这样的，

1527
00:38:38,890 --> 00:38:40,580
0,400 480,800 800,1025 1025,1310 1310,1690
this execution is such that,|
|

1528
00:38:40,840 --> 00:38:42,645
0,275 275,550 810,1130 1130,1450 1470,1805
you can show me, prove
你可以向我展示，向我证明，

1529
00:38:42,645 --> 00:38:43,560
0,195 195,390 390,600 600,735 735,915
to me,| that no matter
|无论你做什么，

1530
00:38:43,560 --> 00:38:45,270
0,195 195,345 345,620 940,1425 1425,1710
what you do,| whichever {order,you}
|无论你允许了哪一个事务，

1531
00:38:45,270 --> 00:38:46,320
0,195 195,330 330,570 570,840 840,1050
allowed the transaction,| it feels
|比如一个发生在另一个之前，

1532
00:38:46,320 --> 00:38:47,535
0,270 270,525 525,765 765,1035 1035,1215
like one happened before the

1533
00:38:47,535 --> 00:38:48,795
0,245 505,750 750,870 870,1035 1035,1260
other| and that one happened
|一个发生在另一个之前可以是，

1534
00:38:48,795 --> 00:38:49,910
0,255 255,420 420,615 615,840 840,1115
before the other could be,|
|

1535
00:38:49,930 --> 00:38:51,030
0,305 305,515 515,680 680,830 830,1100
all of {T1 -} happened
T1 发生在 T2 之前，在这个例子中，

1536
00:38:51,030 --> 00:38:52,170
0,300 300,510 510,705 705,930 930,1140
followed by {T2 -}, in

1537
00:38:52,170 --> 00:38:53,565
0,180 180,470 850,1110 1110,1245 1245,1395
this case,| which is the
|这是左边的例子，

1538
00:38:53,565 --> 00:38:54,510
0,210 210,405 405,525 525,735 735,945
example on the left,| which
|当你最终得到 A 等于 954 ， B 等于 1166 ，

1539
00:38:54,510 --> 00:38:55,065
0,120 120,240 240,345 345,435 435,555
is when you end up

1540
00:38:55,065 --> 00:38:55,935
0,165 165,360 360,555 555,705 705,870
with A equal to {954

1541
00:38:55,935 --> 00:38:57,420
0,270 270,635 835,1140 1140,1320 1320,1485
- -} and B is

1542
00:38:57,420 --> 00:38:58,940
0,165 165,345 345,555 555,860 1120,1520
{1166 - - -}| or
|或 T2 在前，

1543
00:38:59,260 --> 00:39:00,240
0,275 275,440 440,650 650,830 830,980
{T2 -} followed by that,|
|

1544
00:39:00,240 --> 00:39:01,160
0,165 165,315 315,435 435,600 600,920
both of them are correct.|
它们都是正确的。|

1545
00:39:01,580 --> 00:39:02,515
0,305 305,515 515,665 665,785 785,935
But if you are going
但是，如果你要干预这两个事务的这些读写操作，

1546
00:39:02,515 --> 00:39:04,015
0,165 165,870 870,1065 1065,1365 1365,1500
to intervene these reads and

1547
00:39:04,015 --> 00:39:04,980
0,195 195,375 375,525 525,690 690,965
writes for these two transactions,|
|

1548
00:39:05,810 --> 00:39:07,060
0,275 275,550 630,920 920,1085 1085,1250
the database better end up
数据库最好以这两个正确的结束状态之一结束，

1549
00:39:07,060 --> 00:39:08,790
0,290 370,770 820,1125 1125,1380 1380,1730
with one of these two

1550
00:39:08,870 --> 00:39:10,500
0,335 335,635 635,1000
correct end states,|
|

1551
00:39:10,500 --> 00:39:11,700
0,210 210,530
which one,
哪一个，并不重要，

1552
00:39:12,110 --> 00:39:13,330
0,380 380,640 750,980 980,1085 1085,1220
doesn't matter,| but it should
|但它应该是那两个中的一个，

1553
00:39:13,330 --> 00:39:14,160
0,120 120,225 225,345 345,525 525,830
be one of those two,|
|

1554
00:39:14,210 --> 00:39:15,510
0,260 260,485 485,740 740,965 965,1300
not, {} not something else.|
而不是别的。|

1555
00:39:15,800 --> 00:39:17,050
0,400 540,785 785,875 875,995 995,1250
Question?| { - - -}
问题？|

1556
00:39:17,050 --> 00:39:18,140
0,380 520,920

1557
00:39:18,170 --> 00:39:20,290
0,350 350,700 1200,1580 1580,1850 1850,2120

1558
00:39:22,070 --> 00:39:23,190
0,320 320,500 500,665 665,845 845,1120

1559
00:39:23,420 --> 00:39:24,670
0,380 380,760 810,1070 1070,1160 1160,1250

1560
00:39:24,670 --> 00:39:25,760
0,135 135,360 360,710

1561
00:39:25,760 --> 00:39:26,770
0,240 240,360 360,480 480,675 675,1010

1562
00:39:27,700 --> 00:39:28,770
0,335 335,620 620,710 710,875 875,1070
No, that's the whole point.|
不，这才是重点。|

1563
00:39:28,770 --> 00:39:29,925
0,135 135,225 225,405 405,740 850,1155
So the question is,| why
所以问题是，|为什么我们要并行做这件事，

1564
00:39:29,925 --> 00:39:30,735
0,180 180,330 330,495 495,660 660,810
are we doing this in

1565
00:39:30,735 --> 00:39:31,760
0,210 210,465 465,555 555,720 720,1025
parallel,| that's the whole point.|
|这就是重点。|

1566
00:39:32,230 --> 00:39:33,405
0,305 305,500 500,650 650,800 800,1175
Right now, this a serial
现在，这是一个串行执行，

1567
00:39:33,405 --> 00:39:34,470
0,315 315,540 540,675 675,870 870,1065
execution,| so {T1 -} happening
|所以在时间上 T1 发生在 T2 之后，

1568
00:39:34,470 --> 00:39:35,600
0,330 330,585 585,705 705,840 840,1130
after {T2 -} in time,|
|

1569
00:39:35,680 --> 00:39:36,480
0,260 260,380 380,500 500,650 650,800
but what we want to
但我们想要做的是，

1570
00:39:36,480 --> 00:39:38,145
0,120 120,300 300,620 1030,1380 1380,1665
do is,| to imagine I've
|假设我在这台服务器中有两个核心，

1571
00:39:38,145 --> 00:39:40,215
0,245 475,795 795,1325 1585,1875 1875,2070
got two cores in this

1572
00:39:40,215 --> 00:39:41,820
0,305 535,840 840,1200 1200,1440 1440,1605
server| and today's servers have
|而今天的服务器有 40 个核心，

1573
00:39:41,820 --> 00:39:43,320
0,240 240,615 615,795 795,1100 1210,1500
40 cores| and database machines
|数据库机器有时有数百台机器，

1574
00:39:43,320 --> 00:39:44,690
0,240 240,465 465,690 690,1005 1005,1370
sometimes have hundreds of machines,|
|

1575
00:39:45,210 --> 00:39:45,830
0,245 245,365 365,440 440,530 530,620
I don't want to be
我不想一次只运行一个事务，

1576
00:39:45,830 --> 00:39:46,955
0,150 150,360 360,570 570,860 880,1125
just running one transaction at

1577
00:39:46,955 --> 00:39:47,555
0,75 75,225 225,375 375,480 480,600
a time,| I want to
|我希望能够在任何给定的时间点执行尽可能多的操作，

1578
00:39:47,555 --> 00:39:48,290
0,90 90,240 240,420 420,570 570,735
be able to do as

1579
00:39:48,290 --> 00:39:50,165
0,210 210,530 880,1230 1230,1560 1560,1875
many actions at any given

1580
00:39:50,165 --> 00:39:51,395
0,240 240,435 435,725 865,1110 1110,1230
point in time,| I want
|我想做尽可能多的事情，

1581
00:39:51,395 --> 00:39:52,085
0,120 120,195 195,315 315,510 510,690
to do as many things

1582
00:39:52,085 --> 00:39:53,220
0,165 165,455
as possible,|
|

1583
00:39:53,590 --> 00:39:54,255
0,245 245,335 335,440 440,530 530,665
because I want to use
因为我想使用我有权访问的所有硬件，

1584
00:39:54,255 --> 00:39:55,245
0,210 210,360 360,570 570,780 780,990
all the hardware I have

1585
00:39:55,245 --> 00:39:56,280
0,270 270,570 570,840 840,945 945,1035
access to,| that way I
|所以我可以在系统中获得更多事务，

1586
00:39:56,280 --> 00:39:57,420
0,135 135,300 300,480 480,770 880,1140
can get more transactions in

1587
00:39:57,420 --> 00:39:59,400
0,120 120,380 610,990 990,1550 1690,1980
the system,| higher throughput and
|更高的吞吐量和更低的潜在延迟。

1588
00:39:59,400 --> 00:40:01,300
0,240 240,810 810,1130
lower latency potentially.|
|

1589
00:40:01,310 --> 00:40:03,000
0,400 510,1025 1025,1175 1175,1450

1590
00:40:03,660 --> 00:40:04,550
0,275 275,410 410,605 605,785 785,890
No, no, no, we will
不，不，不，我们不会降低标准，

1591
00:40:04,550 --> 00:40:05,525
0,180 180,405 405,570 570,780 780,975
not lower the standard,| so
|所以等等，我们不会降低标准，

1592
00:40:05,525 --> 00:40:06,545
0,120 120,395 475,720 720,840 840,1020
hold on, we will not

1593
00:40:06,545 --> 00:40:08,110
0,225 225,435 435,725 1075,1320 1320,1565
lower the standard,| we are
|我们肯定会稍微改变一下标准，

1594
00:40:08,550 --> 00:40:10,730
0,400 720,1120 1350,1670 1670,1955 1955,2180
definitely changing the standard a

1595
00:40:10,730 --> 00:40:12,040
0,180 180,500 550,825 825,1005 1005,1310
little bit| to say any
|说 T1 和 T2 的任何排列都是允许的，

1596
00:40:12,120 --> 00:40:14,585
0,700 780,1180 1380,1670 1670,1960 2130,2465
permutation of {T1 -} followed

1597
00:40:14,585 --> 00:40:15,545
0,240 240,435 435,585 585,750 750,960
by {T2 -} is allowed,

1598
00:40:15,545 --> 00:40:16,730
0,180 180,345 345,635 775,1050 1050,1185
{} {T2 -},| {T1 -}
|T1 和 T2 可以互换，

1599
00:40:16,730 --> 00:40:17,345
0,135 135,270 270,390 390,510 510,615
and {T2 -} can be

1600
00:40:17,345 --> 00:40:18,965
0,405 405,615 615,855 855,1175 1375,1620
interchanged,| as long as we
|只要我们能证明一个在另一个之前做了所有的工作。

1601
00:40:18,965 --> 00:40:20,885
0,150 150,455 865,1265 1465,1755 1755,1920
can prove one did all

1602
00:40:20,885 --> 00:40:21,770
0,135 135,285 285,465 465,705 705,885
of its work before the

1603
00:40:21,770 --> 00:40:22,610
0,210 210,435 435,540 540,675 675,840
other.| So hold on for
|所以等待两张幻灯片，

1604
00:40:22,610 --> 00:40:24,395
0,225 225,560 790,1155 1155,1400 1450,1785
two slides,| you're right, it's
|你是对的，就像为什么不是只有一种可能的方式，

1605
00:40:24,395 --> 00:40:25,415
0,225 225,510 510,690 690,855 855,1020
like why is it not

1606
00:40:25,415 --> 00:40:26,810
0,255 255,570 570,905 925,1215 1215,1395
only one possible way,| that
|

1607
00:40:26,810 --> 00:40:27,650
0,150 150,315 315,495 495,645 645,840
{T1 -} should be followed
T1 在 T2 之前，

1608
00:40:27,650 --> 00:40:28,895
0,210 210,390 390,680 820,1095 1095,1245
by {T2 -},| if we
|如果我们这样做了，

1609
00:40:28,895 --> 00:40:30,170
0,165 165,420 420,785 835,1095 1095,1275
did that,| then we would
|那么我们就会减少系统中的并行性。

1610
00:40:30,170 --> 00:40:32,255
0,320 670,1005 1005,1695 1695,1935 1935,2085
allow less parallelism in the

1611
00:40:32,255 --> 00:40:33,740
0,275 835,1050 1050,1170 1170,1260 1260,1485
system.| So you're going to
|所以你要放松严格的概念，什么是正确的，

1612
00:40:33,740 --> 00:40:35,705
0,315 315,615 615,870 870,1190 1600,1965
relax the strict notion of

1613
00:40:35,705 --> 00:40:36,830
0,240 240,435 435,720 720,975 975,1125
what is correct| and this
|这就是可串行化的严格概念，

1614
00:40:36,830 --> 00:40:38,270
0,165 165,470 790,1125 1125,1245 1245,1440
is where there's this notion

1615
00:40:38,270 --> 00:40:39,500
0,320 460,860
of strict

1616
00:40:39,500 --> 00:40:42,130
0,290 820,1790 1870,2145 2145,2325 2325,2630
{} serializable,| which will say,|
|这意味着，|

1617
00:40:42,360 --> 00:40:44,375
0,275 275,550 900,1300 1440,1775 1775,2015
the transactions should feel like,|
事务应该感觉像是，|

1618
00:40:44,375 --> 00:40:46,190
0,270 270,635 715,1110 1110,1470 1470,1815
they [] in the way
它们在物理世界中发生的那样[]，

1619
00:40:46,190 --> 00:40:47,120
0,270 270,450 450,600 600,765 765,930
in which they happen in

1620
00:40:47,120 --> 00:40:48,440
0,120 120,375 375,770 820,1155 1155,1320
the physical world,| we'll talk
|我们将在下一节课中讨论一点这个，

1621
00:40:48,440 --> 00:40:49,580
0,225 225,530 550,810 810,930 930,1140
about that in the next

1622
00:40:49,580 --> 00:40:51,035
0,345 345,600 600,765 765,1070 1180,1455
class a little bit,| and
|我们将在高级数据库课上更详细地讨论这个。

1623
00:40:51,035 --> 00:40:51,815
0,195 195,330 330,495 495,615 615,780
we'll talk about it a

1624
00:40:51,815 --> 00:40:52,820
0,270 270,510 510,645 645,795 795,1005
lot more in the advanced

1625
00:40:52,820 --> 00:40:54,100
0,320 370,770
database class.|
|

1626
00:40:54,560 --> 00:40:55,960
0,305 305,590 590,850 900,1190 1190,1400
First, let's get a little
首先，让我们做一点写入，

1627
00:40:55,960 --> 00:40:57,550
0,210 210,500 970,1275 1275,1455 1455,1590
bit write,| and this is,
|顺便说一句，这就是今天大多数数据库系统所做的事情，

1628
00:40:57,550 --> 00:40:58,060
0,120 120,225 225,300 300,375 375,510
by the way, of what

1629
00:40:58,060 --> 00:40:59,460
0,210 210,510 510,855 855,1110 1110,1400
most database systems do today,|
|

1630
00:40:59,630 --> 00:41:01,300
0,275 275,550 810,1100 1100,1355 1355,1670
they will take this slight
他们会稍微冒昧地[]一下，

1631
00:41:01,300 --> 00:41:03,295
0,350 640,960 960,1515 1515,1755 1755,1995
liberty of [] it,| because
|因为就像 T1 和 T2 同时发出，

1632
00:41:03,295 --> 00:41:04,075
0,225 225,360 360,510 510,675 675,780
it's also like {T1 -}

1633
00:41:04,075 --> 00:41:04,780
0,120 120,255 255,360 360,525 525,705
and {T2 -} issued at

1634
00:41:04,780 --> 00:41:05,560
0,135 135,315 315,495 495,645 645,780
the same time,| what does
|同时发出意味着什么，

1635
00:41:05,560 --> 00:41:06,505
0,120 120,315 315,615 615,825 825,945
it even mean for it

1636
00:41:06,505 --> 00:41:07,150
0,105 105,165 165,330 330,525 525,645
to be issued at the

1637
00:41:07,150 --> 00:41:08,170
0,180 180,500 550,810 810,930 930,1020
same time,| they may be
|他们可能在不同的城市，

1638
00:41:08,170 --> 00:41:10,195
0,90 90,350 940,1340 1540,1830 1830,2025
in different cities,| if you're
|如果你们坐在一起，

1639
00:41:10,195 --> 00:41:10,945
0,165 165,390 390,525 525,615 615,750
sitting next to each other,|
|

1640
00:41:10,945 --> 00:41:11,905
0,180 180,285 285,420 420,690 690,960
it's not as if you
你们不会在同一时间按下按钮，

1641
00:41:11,905 --> 00:41:12,840
0,150 150,300 300,585 585,690 690,935
would be pressing the button

1642
00:41:12,890 --> 00:41:14,125
0,335 335,530 530,680 680,920 920,1235
exactly at the same second,|
|

1643
00:41:14,125 --> 00:41:16,180
0,240 240,465 465,795 795,1055 1825,2055
because that doesn't happen,| so
因为这不会发生，|所以这就像同时是什么意思。

1644
00:41:16,180 --> 00:41:17,335
0,120 120,225 225,390 390,555 555,1155
it's like what does simultaneous

1645
00:41:17,335 --> 00:41:18,325
0,305 445,690 690,810 810,885 885,990
mean.| So we're going to
|所以我们会稍微放松一点，

1646
00:41:18,325 --> 00:41:19,075
0,105 105,225 225,390 390,570 570,750
be a little bit more

1647
00:41:19,075 --> 00:41:20,530
0,300 300,525 525,765 765,1055 1165,1455
relaxed,| all we have is
|我们所能说的是，

1648
00:41:20,530 --> 00:41:21,460
0,150 150,285 285,435 435,690 690,930
to say| for us to
|如果我们有这种适当的隔离，

1649
00:41:21,460 --> 00:41:23,070
0,260 340,630 630,810 810,1020 1020,1610
be have this proper isolation,|
|

1650
00:41:23,180 --> 00:41:24,595
0,290 290,530 530,880 1020,1280 1280,1415
the final values should be
最终的值应该是这两个值中的一个，

1651
00:41:24,595 --> 00:41:25,560
0,135 135,270 270,450 450,755
one of these two,|
|

1652
00:41:25,800 --> 00:41:26,705
0,260 260,395 395,560 560,755 755,905
not a third value.| Look
不是第三个值。|首先看看这张幻灯片，是的，

1653
00:41:26,705 --> 00:41:27,815
0,135 135,345 345,570 570,795 795,1110
at this slide here first,

1654
00:41:27,815 --> 00:41:28,760
0,395
yep,|
|

1655
00:41:28,800 --> 00:41:31,370
0,400 450,850 1230,1630 2040,2315 2315,2570
so here T {T1 -}
在这里 T1 开始，减去 100 ，

1656
00:41:31,370 --> 00:41:33,905
0,380 700,1100 1240,1640 1690,1980 1980,2535
starts and does its subtraction

1657
00:41:33,905 --> 00:41:35,410
0,105 105,485 805,1050 1050,1200 1200,1505
of 100,| so now A
|现在 A 已经把 100 美元去掉了，

1658
00:41:35,940 --> 00:41:37,325
0,290 290,425 425,605 605,940 1020,1385
has the 100 dollars already

1659
00:41:37,325 --> 00:41:38,855
0,365 535,825 825,1035 1035,1275 1275,1530
removed,| {T2 -} starts and
|T2 启动，产生 6% 的利息到两个银行账户，

1660
00:41:38,855 --> 00:41:41,060
0,330 330,965 1195,1595
gives 6% interest

1661
00:41:41,060 --> 00:41:42,310
0,285 285,495 495,645 645,885 885,1250
to the two bank accounts,|
|

1662
00:41:42,600 --> 00:41:44,720
0,320 320,575 575,910 1500,1835 1835,2120
but the bank account value
但它查看的 A 的银行账户价值还差 100 美元，

1663
00:41:44,720 --> 00:41:45,620
0,255 255,465 465,645 645,765 765,900
for A that it is

1664
00:41:45,620 --> 00:41:47,375
0,225 225,560 760,1065 1065,1425 1425,1755
looking at is 100 dollars

1665
00:41:47,375 --> 00:41:49,145
0,395 655,1005 1005,1305 1305,1560 1560,1770
short,| and so it ends
|所以它最终的值是 2114 作为总和，

1666
00:41:49,145 --> 00:41:50,165
0,225 225,405 405,525 525,750 750,1020
up with a value of

1667
00:41:50,165 --> 00:41:51,110
0,195 195,375 375,585 585,780 780,945
{2114 - - -} as

1668
00:41:51,110 --> 00:41:52,640
0,165 165,360 360,680 1090,1365 1365,1530
the sum total,| which is
|这比原来应该是的值少了 6 美元。

1669
00:41:52,640 --> 00:41:53,765
0,195 195,450 450,750 750,975 975,1125
6 dollars off from what

1670
00:41:53,765 --> 00:41:55,750
0,195 195,515 1135,1485 1485,1710 1710,1985
that original about should be.|
|

1671
00:41:56,550 --> 00:41:57,575
0,245 245,365 365,530 530,755 755,1025
So what we want to
所以我们想要允许的是这两个，

1672
00:41:57,575 --> 00:41:59,105
0,335 355,675 675,915 915,1235 1255,1530
allow is these two,| the
|前一张幻灯片中的交错是安全的，

1673
00:41:59,105 --> 00:42:00,790
0,675 675,900 900,1020 1020,1290 1290,1685
interleaving in the previous slide

1674
00:42:00,930 --> 00:42:02,405
0,275 275,470 470,790 1020,1310 1310,1475
that is safe,| where you
|即使有交错，你最终也会得到正确的值，

1675
00:42:02,405 --> 00:42:03,290
0,150 150,330 330,495 495,675 675,885
end up with the correct

1676
00:42:03,290 --> 00:42:04,900
0,240 240,510 510,705 705,900 900,1610
value, even though there's interleaving,|
|

1677
00:42:04,980 --> 00:42:06,160
0,305 305,500 500,650 650,845 845,1180
but this is an example
但这是一个不安全交错的例子，

1678
00:42:06,270 --> 00:42:08,300
0,275 275,455 455,1040 1040,1750 1770,2030
of an unsafe interleaving,| where
|你最终得到了错误的值。

1679
00:42:08,300 --> 00:42:08,990
0,105 105,255 255,435 435,570 570,690
you ended up with the

1680
00:42:08,990 --> 00:42:09,860
0,165 165,470
wrong value,

1681
00:42:10,190 --> 00:42:11,790
0,335 335,665 665,965 965,1235 1235,1600
right.| So this is fine,|
|所以这是好的，|

1682
00:42:12,320 --> 00:42:14,425
0,305 305,610 1500,1790 1790,1955 1955,2105
sorry, I was here on
抱歉，我看错幻灯片了，

1683
00:42:14,425 --> 00:42:16,435
0,135 135,330 330,585 585,905 1735,2010
the wrong slide here,| this
|这是好的，

1684
00:42:16,435 --> 00:42:17,335
0,180 180,390 390,555 555,690 690,900
is fine,| and the question
|问题是，我们如何确定这是可以的，

1685
00:42:17,335 --> 00:42:18,415
0,225 225,420 420,570 570,750 750,1080
is how do we determine

1686
00:42:18,415 --> 00:42:20,040
0,315 315,510 510,735 735,1085
that this is okay,|
|

1687
00:42:20,160 --> 00:42:21,785
0,290 290,440 440,575 575,1300 1350,1625
this type of interleaving of
这种跨不同事务的操作交错是可以的，

1688
00:42:21,785 --> 00:42:23,420
0,275 355,645 645,870 870,1205 1285,1635
actions across different transactions is

1689
00:42:23,420 --> 00:42:25,130
0,350 670,1070 1090,1380 1380,1545 1545,1710
okay,| but this one is
|但这个不可以。

1690
00:42:25,130 --> 00:42:25,920
0,290
not.|
|

1691
00:42:27,070 --> 00:42:27,980
0,400
Okay?|
好的？|

1692
00:42:28,205 --> 00:42:28,805
0,75 75,180 180,315 315,450 450,600
So let's look at, how
那么让我们来看看，我们是如何做到这个的。

1693
00:42:28,805 --> 00:42:29,770
0,135 135,285 285,480 480,675 675,965
we go about doing that.|
|

1694
00:42:30,300 --> 00:42:31,395
0,240 240,420 420,540 540,795 795,1095
So there's this formal notion
所以有一个正式的串行调度的概念，

1695
00:42:31,395 --> 00:42:33,470
0,255 255,645 645,965 1345,1710 1710,2075
of serial schedule,| that says
|它指的是一个不会交错任何操作的调度。

1696
00:42:33,970 --> 00:42:35,270
0,320 320,590 590,830 830,1010 1010,1300
a schedule that does not

1697
00:42:35,650 --> 00:42:36,870
0,575 575,725 725,905 905,1010 1010,1220
interleave any of the action.|
|

1698
00:42:36,870 --> 00:42:37,890
0,210 210,330 330,510 510,750 750,1020
So we saw that, right,|
所以我们看到，|

1699
00:42:37,890 --> 00:42:39,210
0,225 225,650 670,990 990,1170 1170,1320
a serial example of, a
一个串行调度的例子是，

1700
00:42:39,210 --> 00:42:41,115
0,360 360,680 1150,1485 1485,1725 1725,1905
serial schedule was one,| where
|你只有所有的 T1 ，

1701
00:42:41,115 --> 00:42:42,810
0,165 165,375 375,695 1015,1380 1380,1695
you just had {} all

1702
00:42:42,810 --> 00:42:44,910
0,350 610,915 915,1220 1600,1905 1905,2100
the {T1s -},| like here
|就像这是一个串行调度，

1703
00:42:44,910 --> 00:42:46,440
0,150 150,300 300,660 660,980 1300,1530
is a serial schedule,| so
|所以如果我们回去，

1704
00:42:46,440 --> 00:42:47,235
0,60 60,150 150,270 270,525 525,795
if we go back,| {this,is}
|这是一个串行调度，

1705
00:42:47,235 --> 00:42:48,720
0,150 150,480 480,785 1075,1335 1335,1485
a serial schedule,| {T1 -}
|T1 在 T2 之前，或者 T2 在 T1 之前。

1706
00:42:48,720 --> 00:42:50,025
0,210 210,420 420,600 600,890 1000,1305
followed by {T2 -} or

1707
00:42:50,025 --> 00:42:51,110
0,195 195,360 360,555 555,780 780,1085
{T2 -} followed by T

1708
00:42:51,910 --> 00:42:52,800
0,275 275,550
{T1 -}.|
|

1709
00:42:53,090 --> 00:42:55,885
0,290 290,580 1080,1480 2340,2630 2630,2795
Okay, now the thing that
好的，现在我们要做的是，

1710
00:42:55,885 --> 00:42:56,590
0,105 105,195 195,345 345,510 510,705
we are trying to get

1711
00:42:56,590 --> 00:42:58,200
0,210 210,375 375,615 615,980 1210,1610
to,| the harder part is
|更难的部分是一个等效调度。

1712
00:42:58,370 --> 00:43:00,780
0,400 600,1000 1200,1600
an equivalent schedule.|
|

1713
00:43:01,800 --> 00:43:03,700
0,400 750,1130 1130,1400 1400,1595 1595,1900
So here was a schedule
所以这是我们看到的一个正确的调度，

1714
00:43:03,840 --> 00:43:05,980
0,290 290,500 500,820 1290,1690 1740,2140
that we saw that was

1715
00:43:06,150 --> 00:43:07,260
0,400
correct,|
|

1716
00:43:07,260 --> 00:43:08,940
0,150 150,270 270,465 465,1010
it is not serial,|
它不是串行的，|

1717
00:43:08,940 --> 00:43:09,585
0,75 75,195 195,390 390,510 510,645
but as you'll see, this
但如你所见，这是正确的，

1718
00:43:09,585 --> 00:43:11,355
0,225 225,575 895,1295 1345,1605 1605,1770
is correct| and we want
|我们想看看这个调度，

1719
00:43:11,355 --> 00:43:12,470
0,180 180,330 330,525 525,780 780,1115
to look at this schedule|
|

1720
00:43:12,790 --> 00:43:14,370
0,335 335,670 780,1055 1055,1295 1295,1580
and say the one on
并说左边的那个等同于右边的串行调度，

1721
00:43:14,370 --> 00:43:16,730
0,320 580,980 1090,1410 1410,1730 1960,2360
the { -} left is

1722
00:43:16,750 --> 00:43:18,105
0,400 420,665 665,800 800,1115 1115,1355
equivalent to the serial schedule

1723
00:43:18,105 --> 00:43:19,035
0,195 195,315 315,570 570,810 810,930
on the right,| we want
|我们希望能够证明这一点，

1724
00:43:19,035 --> 00:43:20,270
0,120 120,195 195,345 345,665 835,1235
to be able to show

1725
00:43:20,800 --> 00:43:22,035
0,320 320,620 620,860 860,1025 1025,1235
that happens| and in which
|在这种情况下，

1726
00:43:22,035 --> 00:43:22,890
0,180 180,375 375,465 465,630 630,855
case,| we'll say that schedule
|我们说调度是安全的，这是允许的。

1727
00:43:22,890 --> 00:43:24,290
0,195 195,470 610,870 870,1125 1125,1400
is safe and that's allowed.|
|

1728
00:43:24,550 --> 00:43:26,390
0,260 260,380 380,640 690,1090 1440,1840
So the notion of equivalent
所以，等效调度的概念是说，

1729
00:43:26,500 --> 00:43:29,090
0,400 930,1330 1440,1745 1745,1910 1910,2590
schedule says,| allow some interleaving,|
|允许一些交错，|

1730
00:43:30,330 --> 00:43:31,220
0,260 260,425 425,605 605,755 755,890
and as long as you
只要你能证明交错是安全的，

1731
00:43:31,220 --> 00:43:32,420
0,150 150,345 345,525 525,660 660,1200
can prove that the interleaving

1732
00:43:32,420 --> 00:43:33,720
0,195 195,530
is safe,|
|

1733
00:43:34,450 --> 00:43:35,550
0,275 275,440 440,605 605,800 800,1100
and the proof of safety
而安全的证据是，

1734
00:43:35,550 --> 00:43:36,420
0,270 270,450 450,585 585,690 690,870
is going to be by

1735
00:43:36,420 --> 00:43:38,595
0,320 550,855 855,1035 1035,1310 1840,2175
saying| all these actions are
|所有这些操作都等效于某个串行调度，

1736
00:43:38,595 --> 00:43:40,400
0,335 535,810 810,1035 1035,1485 1485,1805
equivalent to some serial schedule,|
|

1737
00:43:40,660 --> 00:43:41,715
0,260 260,410 410,635 635,860 860,1055
in this case, one of
在这种情况下，其中一个，

1738
00:43:41,715 --> 00:43:42,795
0,270 270,570 570,750 750,885 885,1080
those two,| {T1 -} followed
|T1 在 T2 之前，或者 T2 在 T1 之前，

1739
00:43:42,795 --> 00:43:43,935
0,195 195,375 375,665 715,990 990,1140
by {T2 -}, or {T2

1740
00:43:43,935 --> 00:43:44,900
0,150 150,345 345,555 555,705 705,965
-} followed by {T1 -},|
|

1741
00:43:45,160 --> 00:43:46,305
0,260 260,455 455,785 785,1040 1040,1145
you are okay,| you will
都是可以的，|你最终可以得到正确的答案。

1742
00:43:46,305 --> 00:43:47,010
0,105 105,240 240,375 375,525 525,705
end up with the correct

1743
00:43:47,010 --> 00:43:47,900
0,290
answer.|
|

1744
00:43:48,250 --> 00:43:49,400
0,230 230,350 350,575 575,830 830,1150
So it sounds like magic,|
这听起来像是魔术，|

1745
00:43:50,020 --> 00:43:51,510
0,400 480,800 800,890 890,1130 1130,1490
but there's a very simple
但有一个非常简单的方法来解决这个问题。

1746
00:43:51,510 --> 00:43:54,450
0,380 670,960 960,1250 2410,2730 2730,2940
way to go figure that

1747
00:43:54,450 --> 00:43:55,340
0,290
out.|
|

1748
00:43:55,510 --> 00:43:56,310
0,275 275,410 410,530 530,650 650,800
And this is the part
这就是你所问的部分，

1749
00:43:56,310 --> 00:43:57,465
0,180 180,330 330,450 450,710 760,1155
that you were asking about,|
|

1750
00:43:57,465 --> 00:43:58,620
0,300 300,570 570,825 825,1005 1005,1155
is like, okay, but why
就是，好的，但是为什么数据库的两种状态是正确的，

1751
00:43:58,620 --> 00:43:59,610
0,105 105,255 255,495 495,750 750,990
are the two correct states

1752
00:43:59,610 --> 00:44:01,200
0,180 180,300 300,560 1060,1320 1320,1590
of the database,| and that's
|这就是我们在这个可串行化中放松的一点，

1753
00:44:01,200 --> 00:44:02,400
0,195 195,420 420,540 540,720 720,1200
really what we are relaxing

1754
00:44:02,400 --> 00:44:03,585
0,120 120,285 285,590 670,975 975,1185
a little bit in this

1755
00:44:03,585 --> 00:44:05,250
0,240 240,480 480,1295 1315,1560 1560,1665
notion of serializable,| and as
|正如我所说的，

1756
00:44:05,250 --> 00:44:06,000
0,120 120,285 285,495 495,585 585,750
I said,| there's a {two,sort}
|有两种严格的串行化，

1757
00:44:06,000 --> 00:44:07,440
0,225 225,450 450,1140 1140,1290 1290,1440
of strict serializable,| where that
|在那里，现实世界的效果发生了，

1758
00:44:07,440 --> 00:44:08,460
0,210 210,465 465,675 675,840 840,1020
real world effect is taken

1759
00:44:08,460 --> 00:44:10,650
0,240 240,590 730,1185 1185,1730 1870,2190
into place,| it's stricter,| but
|它更严格了，|但是为了这门课的目的，

1760
00:44:10,650 --> 00:44:12,240
0,285 285,525 525,750 750,1100 1240,1590
for the purpose of this

1761
00:44:12,240 --> 00:44:13,260
0,285 285,540 540,675 675,840 840,1020
class,| we're going to work
|我们将使用这个概念，

1762
00:44:13,260 --> 00:44:14,835
0,210 210,420 420,740 1120,1410 1410,1575
with this notion,| that we
|我们只需要证明它等效于许多串行调度之一。

1763
00:44:14,835 --> 00:44:15,630
0,165 165,330 330,465 465,585 585,795
just have to prove it

1764
00:44:15,630 --> 00:44:16,950
0,285 285,620 760,1035 1035,1185 1185,1320
equivalent to one of the

1765
00:44:16,950 --> 00:44:19,140
0,260 820,1185 1185,1620 1620,2040 2040,2190
many equivalent serial schedules.| And
|如果你有两个事务，

1766
00:44:19,140 --> 00:44:19,790
0,75 75,135 135,225 225,375 375,650
if you have two transactions,|
|

1767
00:44:20,200 --> 00:44:21,740
0,245 245,425 425,650 650,940 1140,1540
there only two possible outcomes,|
那么只有两种可能的结果，|

1768
00:44:21,790 --> 00:44:22,920
0,275 275,410 410,575 575,875 875,1130
if there were three, {T1
如果有三个， T1, T2, T3 ，

1769
00:44:22,920 --> 00:44:23,930
0,165 165,345 345,495 495,690 690,1010
-}, {T2 -}, {T3 -},|
|

1770
00:44:24,070 --> 00:44:25,240
0,290 290,470 470,760
it could be,|
它可能是，|

1771
00:44:25,310 --> 00:44:26,590
0,305 305,610 690,950 950,1085 1085,1280
first transaction could be either
第一个事务可能是其中之一，

1772
00:44:26,590 --> 00:44:27,865
0,210 210,390 390,680 940,1170 1170,1275
one of those,| there are
|有三种可能的组合，

1773
00:44:27,865 --> 00:44:29,940
0,135 135,375 375,965 1375,1725 1725,2075
three possible combinations,| then two,
|然后是两种，然后是一种，

1774
00:44:30,110 --> 00:44:31,290
0,290 290,530 530,785 785,935 935,1180
then one, right,| so you
|所以你得到了阶乘效应。

1775
00:44:31,310 --> 00:44:33,120
0,400 450,725 725,905 905,1490 1490,1810
you get that factorial effect.|
|

1776
00:44:34,300 --> 00:44:35,340
0,320 320,455 455,635 635,830 830,1040
We're going to think about
我们将考虑这些读写，

1777
00:44:35,340 --> 00:44:37,130
0,225 225,770 820,1155 1155,1440 1440,1790
these {reads,writes}| in terms of
|从可以发生在这些对象之间的冲突操作的角度，

1778
00:44:38,100 --> 00:44:39,670
0,635 635,890 890,1145 1145,1295 1295,1570
conflicting actions, that can happen

1779
00:44:39,810 --> 00:44:42,560
0,400 810,1210 1260,1660 2280,2585 2585,2750
between these objects,| like the
|比如 A B 和 C 。

1780
00:44:42,560 --> 00:44:43,385
0,270 270,375 375,495 495,720 720,825
As and the Bs and

1781
00:44:43,385 --> 00:44:44,420
0,150 150,575
the Cs.|
|

1782
00:44:44,520 --> 00:44:45,800
0,400 600,830 830,935 935,1100 1100,1280
So we are going to
所以我们将会有，

1783
00:44:45,800 --> 00:44:46,840
0,290
have,|
|

1784
00:44:46,880 --> 00:44:48,810
0,305 305,515 515,770 770,1085 1085,1930
we call these things anomalies,|
我们称这些东西为异常，|

1785
00:44:49,160 --> 00:44:50,530
0,400 660,890 890,995 995,1145 1145,1370
and there are three different
有三种不同的类型，

1786
00:44:50,530 --> 00:44:52,630
0,350 700,1005 1005,1260 1260,1530 1530,2100
types,| a read could interfere,|
|读操作可能会干扰，|

1787
00:44:52,630 --> 00:44:54,835
0,320 1030,1305 1305,1580 1660,1995 1995,2205
with a transaction, reads an
在一个事务中，读取对象，其他人向其写入内容，

1788
00:44:54,835 --> 00:44:56,770
0,365 595,915 915,1235 1255,1620 1620,1935
object and something else writes

1789
00:44:56,770 --> 00:44:57,720
0,195 195,440
to it,|
|

1790
00:44:57,810 --> 00:44:59,735
0,400 660,935 935,1210 1320,1640 1640,1925
or a transaction writes an
或者，一个事务写入一个对象，其他人读取该对象，

1791
00:44:59,735 --> 00:45:00,905
0,225 225,375 375,585 585,840 840,1170
object and someone else reads

1792
00:45:00,905 --> 00:45:02,100
0,270 270,665
that object,|
|

1793
00:45:02,140 --> 00:45:03,690
0,275 275,455 455,635 635,910 1260,1550
the third one is two
第三种是两个事务，

1794
00:45:03,690 --> 00:45:05,220
0,290 430,830 880,1170 1170,1380 1380,1530
transaction,| transaction one writes to
|一个事务写入对象，另一个事务也写入该对象。

1795
00:45:05,220 --> 00:45:06,345
0,165 165,420 420,740 760,990 990,1125
an object and the other

1796
00:45:06,345 --> 00:45:07,800
0,305 625,870 870,1035 1035,1215 1215,1455
transaction also writes to that

1797
00:45:07,800 --> 00:45:08,640
0,380
object.|
|

1798
00:45:08,640 --> 00:45:09,525
0,105 105,240 240,480 480,720 720,885
What is missing from this
这种组合中缺少的是读读，

1799
00:45:09,525 --> 00:45:11,520
0,275 325,615 615,810 810,1115 1735,1995
combination is read, read,| which
|这显然不是冲突，

1800
00:45:11,520 --> 00:45:12,560
0,180 180,435 435,630 630,765 765,1040
is obviously not a conflict,|
|

1801
00:45:12,880 --> 00:45:14,060
0,260 260,455 455,605 605,845 845,1180
if I'm just reading this
如果我只是在读这两个事务，

1802
00:45:14,140 --> 00:45:15,360
0,260 260,520 690,935 935,1100 1100,1220
two transactions,| if I've just
|如果我只有一份只读的副本，

1803
00:45:15,360 --> 00:45:16,275
0,135 135,270 270,495 495,780 780,915
got a copy that's read

1804
00:45:16,275 --> 00:45:18,255
0,275 805,1140 1140,1475 1585,1845 1845,1980
only,| many transactions could read
|那么许多事务都能读到它，

1805
00:45:18,255 --> 00:45:18,990
0,150 150,360 360,495 495,630 630,735
it,| you're not going to
|你们不会互相冲突的，

1806
00:45:18,990 --> 00:45:20,490
0,240 240,465 465,600 600,890 1090,1500
conflict with each other,| it's,
|这是只读副本。

1807
00:45:20,490 --> 00:45:21,560
0,270 270,360 360,480 480,705 705,1070
it's a read only copy.|
|

1808
00:45:22,350 --> 00:45:24,680
0,335 335,670 1050,1475 1475,1750 1980,2330
Alright, so let's take these
好的，让我们来看看这些读写冲突。

1809
00:45:24,680 --> 00:45:27,530
0,435 435,1050 1050,1430 2470,2730 2730,2850
read-write conflicts and go look

1810
00:45:27,530 --> 00:45:28,540
0,135 135,410
at that.|
|

1811
00:45:28,540 --> 00:45:30,060
0,120 120,225 225,375 375,680
Here is a schedule,|
这是一个调度，|

1812
00:45:30,060 --> 00:45:31,520
0,150 150,470 820,1080 1080,1200 1200,1460
in which there is a
有一个读取对象 A ，

1813
00:45:31,870 --> 00:45:33,320
0,305 305,470 470,710 710,1070 1070,1450
read of an object A,|
|

1814
00:45:33,460 --> 00:45:34,890
0,335 335,670 840,1130 1130,1295 1295,1430
followed by a write of
随后是写入对象 A ，

1815
00:45:34,890 --> 00:45:36,210
0,225 225,510 510,750 750,1020 1020,1320
an object A,| as these
|这些操作相互交错，

1816
00:45:36,210 --> 00:45:38,750
0,350 400,675 675,1370 1510,1910 2140,2540
actions got interleaved,| and so
|这就是读写冲突的一个例子。

1817
00:45:39,280 --> 00:45:40,820
0,400 630,905 905,1025 1025,1205 1205,1540
that would be an example

1818
00:45:41,350 --> 00:45:43,880
0,400 450,740 740,950 950,1270 2130,2530
of a read write conflict.|
|

1819
00:45:44,560 --> 00:45:45,610
0,240 240,345 345,525 525,960 960,1050
There are other conflicts in
调度中还存在其他冲突，

1820
00:45:45,610 --> 00:45:47,020
0,150 150,435 435,830
the schedule, too,|
|

1821
00:45:47,090 --> 00:45:49,075
0,400 630,1030 1110,1475 1475,1595 1595,1985
but, but what's the downside
但是，这个读写对象冲突事务的缺点是什么，

1822
00:45:49,075 --> 00:45:51,000
0,150 150,345 345,845 895,1295 1525,1925
of this read-write object conflict,|
|

1823
00:45:51,530 --> 00:45:53,170
0,400 480,800 800,1115 1115,1385 1385,1640
transaction one read the value
事务一读取 A 的值，

1824
00:45:53,170 --> 00:45:54,160
0,380
A,|
|

1825
00:45:54,680 --> 00:45:56,240
0,290 290,485 485,790
{T2 -} run,|
T2 运行，|

1826
00:45:56,850 --> 00:45:58,130
0,305 305,590 590,830 830,995 995,1280
and then {T1 -} reads
然后 T1 读取该值，并得到一个不同的值，

1827
00:45:58,130 --> 00:45:58,895
0,150 150,345 345,510 510,645 645,765
that value and got a

1828
00:45:58,895 --> 00:46:00,020
0,180 180,515 655,885 885,960 960,1125
different value,| So it was
|所以它之前是 10 ，

1829
00:46:00,020 --> 00:46:01,655
0,225 225,405 405,680 1150,1440 1440,1635
10 {before -},| {T2 -}
|T2 把它改为 19 ，

1830
00:46:01,655 --> 00:46:03,455
0,195 195,360 360,635 1345,1620 1620,1800
made it 19,| {T1 -}
|T1 再次读取它。

1831
00:46:03,455 --> 00:46:04,910
0,300 300,465 465,785 805,1170 1170,1455
reads it again.| And obviously
|显然，它没有看到隔离性原则，

1832
00:46:04,910 --> 00:46:05,885
0,180 180,315 315,585 585,855 855,975
it has not seen the

1833
00:46:05,885 --> 00:46:07,505
0,480 480,845 1075,1335 1335,1455 1455,1620
isolation principle,| in the same
|在同一个事务中，

1834
00:46:07,505 --> 00:46:08,960
0,305 745,1005 1005,1140 1140,1305 1305,1455
transaction,| if I read the
|如果我读取值两次，

1835
00:46:08,960 --> 00:46:10,370
0,255 255,650 790,1095 1095,1275 1275,1410
value twice,| I should see
|我应该看到相同的值，

1836
00:46:10,370 --> 00:46:11,555
0,135 135,300 300,590 730,1005 1005,1185
the same value| unless someone
|除非其他人干扰我。

1837
00:46:11,555 --> 00:46:13,010
0,195 195,675 675,870 870,1145 1225,1455
else interfered with me.| So
|所以，它违反了隔离性原则。

1838
00:46:13,010 --> 00:46:15,220
0,165 165,735 735,1070 1210,1860 1860,2210
it violates the isolation principle.|
|

1839
00:46:15,750 --> 00:46:16,810
0,350 350,545 545,650 650,785 785,1060
And so this is that.|
就是这样。|

1840
00:46:21,190 --> 00:46:23,780
0,400 660,1240 1260,1660 2010,2300 2300,2590
Alright, let's a look at
好的，我们来看一下，

1841
00:46:24,520 --> 00:46:25,760
0,400
the,|
|

1842
00:46:25,990 --> 00:46:27,495
0,275 275,410 410,650 650,800 800,1505
and so that's called unrepeatable
这被称为不可重复读，

1843
00:46:27,495 --> 00:46:28,305
0,240 240,495 495,630 630,720 720,810
read,| because when you have
|因为当你有读写冲突时，

1844
00:46:28,305 --> 00:46:29,730
0,105 105,255 255,465 465,785 1135,1425
a {read-write -} conflict,| same
|同一事务读取该值两次，

1845
00:46:29,730 --> 00:46:31,200
0,290 370,735 735,870 870,1130 1150,1470
transaction reads the value twice,|
|

1846
00:46:31,200 --> 00:46:31,980
0,255 255,345 345,450 450,570 570,780
it's going to see different
它将看到不同的值。

1847
00:46:31,980 --> 00:46:33,100
0,350
values.|
|

1848
00:46:33,100 --> 00:46:34,405
0,240 240,495 495,765 765,1035 1035,1305
A dirty read is,| I
脏读是指，|我读了一个值，假设这个 10 ，

1849
00:46:34,405 --> 00:46:35,785
0,195 195,345 345,605 925,1260 1260,1380
read a value, let's say

1850
00:46:35,785 --> 00:46:37,570
0,165 165,455 865,1155 1155,1445 1525,1785
this 10,| write it to
|将其写为 12 ，

1851
00:46:37,570 --> 00:46:39,430
0,195 195,530 1030,1350 1350,1590 1590,1860
be 12,| someone else reads
|其他人读取值，即 12 ，

1852
00:46:39,430 --> 00:46:40,950
0,120 120,380 730,1005 1005,1200 1200,1520
the value, which is 12,|
|

1853
00:46:41,960 --> 00:46:43,600
0,275 275,440 440,635 635,940 1350,1640
so far, no problem,| but
到目前为止，没有问题，|但稍晚发生的是，

1854
00:46:43,600 --> 00:46:44,515
0,165 165,390 390,585 585,720 720,915
what happens a little bit

1855
00:46:44,515 --> 00:46:46,285
0,305 535,840 840,1065 1065,1385 1495,1770
later is that,| transaction {T1
|事务 T1 中止，

1856
00:46:46,285 --> 00:46:47,910
0,120 120,485 955,1230 1230,1365 1365,1625
-} aborts| and when transaction
|当事务 T1 中止，

1857
00:46:48,020 --> 00:46:49,180
0,260 260,365 365,470 470,905 905,1160
{T1 -} {aborts -},| that
|值 12 永远不应该被读取，

1858
00:46:49,180 --> 00:46:50,395
0,285 285,600 600,810 810,1020 1020,1215
value 12 should never have

1859
00:46:50,395 --> 00:46:51,610
0,150 150,420 420,750 750,975 975,1215
been read,| because it didn't
|因为它没有提交到数据库，

1860
00:46:51,610 --> 00:46:52,555
0,165 165,420 420,600 600,705 705,945
get committed to the database,|
|

1861
00:46:52,555 --> 00:46:53,850
0,255 255,390 390,525 525,1020 1020,1295
it was an intermediate value,
这是一个被丢弃的中间值，

1862
00:46:54,020 --> 00:46:55,200
0,245 245,365 365,590 590,860 860,1180
which is getting thrown away,

1863
00:46:55,430 --> 00:46:56,430
0,290 290,500 500,590 590,725 725,1000
right,| that's what {abort -}
|这就是中止应该做的事情。

1864
00:46:56,780 --> 00:46:58,290
0,290 290,580 780,1070 1070,1235 1235,1510
should do.| And so now
|所以现在事务 T2 ，

1865
00:46:58,730 --> 00:47:00,430
0,400 540,845 845,1150 1320,1580 1580,1700
transaction {T2 -},| when it
|当它读取值 A 时，

1866
00:47:00,430 --> 00:47:01,560
0,135 135,330 330,510 510,750 750,1130
was reading the value A,|
|

1867
00:47:01,700 --> 00:47:03,550
0,350 350,605 605,905 905,1300 1530,1850
read a dirty value,| which
读取了一个脏值，|不应该存在于数据库中，

1868
00:47:03,550 --> 00:47:04,510
0,180 180,345 345,600 600,825 825,960
should have never been in

1869
00:47:04,510 --> 00:47:05,460
0,105 105,350
the database,|
|

1870
00:47:06,170 --> 00:47:07,285
0,260 260,380 380,485 485,850 870,1115
because of that abort.| So
因为那个中止。|所以这就是所谓的脏读。

1871
00:47:07,285 --> 00:47:08,280
0,180 180,285 285,405 405,630 630,995
that's called a dirty read.|
|

1872
00:47:10,350 --> 00:47:11,740
0,290 290,485 485,695 695,995 995,1390
A {write-write -} conflict is,|
写写冲突是，|

1873
00:47:11,970 --> 00:47:13,280
0,260 260,380 380,530 530,820 1050,1310
{T1 -} is writing a
T1 写入一个值，

1874
00:47:13,280 --> 00:47:16,520
0,260 1480,1785 1785,2090 2380,2780 2980,3240
value,| {T2 -} is also
|T2 也在写入那个值，

1875
00:47:16,520 --> 00:47:19,000
0,210 210,450 450,740 1210,1610
writing that value| and
|当 T1 写入另一个值 B ，

1876
00:47:19,130 --> 00:47:21,505
0,400 960,1250 1250,1540 1680,2075 2075,2375
when {T1 -} writes another

1877
00:47:21,505 --> 00:47:23,575
0,300 1135,1410 1410,1575 1575,1770 1770,2070
value B,| T1 it feels
|T1 感觉就像写入了 10 美元，

1878
00:47:23,575 --> 00:47:25,200
0,375 375,735 735,995 1015,1320 1320,1625
like it's writing 10 dollars,|
|

1879
00:47:25,730 --> 00:47:26,995
0,400 540,815 815,980 980,1130 1130,1265
imagine A and B are
想象 A 和 B 现在是列，

1880
00:47:26,995 --> 00:47:29,215
0,240 240,785 985,1290 1290,1715 1825,2220
now columns| and it's updating
|它更新 Alice 帐户中 10 美元的记录，

1881
00:47:29,215 --> 00:47:30,760
0,135 135,425 655,960 960,1245 1245,1545
a record where dollar 10

1882
00:47:30,760 --> 00:47:32,660
0,195 195,360 360,930 930,1250
is in Alice's account,|
|

1883
00:47:32,700 --> 00:47:34,175
0,395 395,845 845,1085 1085,1295 1295,1475
and it's column one is
它的第一列是 10 ，账户金额，

1884
00:47:34,175 --> 00:47:36,820
0,305 1165,1565 1615,2015
10, the account,

1885
00:47:36,990 --> 00:47:38,765
0,400 510,910 1080,1415 1415,1625 1625,1775
yeah, amount,| and B is
|而 B 是人名，

1886
00:47:38,765 --> 00:47:39,580
0,135 135,270 270,420 420,555 555,815
the name of the person,|
|

1887
00:47:39,810 --> 00:47:40,850
0,275 275,425 425,620 620,800 800,1040
it thinks it's adding 10
它认为它给 Alice 增加了 10 ，

1888
00:47:40,850 --> 00:47:42,455
0,150 150,410 640,1040 1060,1350 1350,1605
to Alice,| but the other
|但这里的另一个冲突是，

1889
00:47:42,455 --> 00:47:43,925
0,365 415,735 735,1005 1005,1245 1245,1470
conflict over there is| writing
|写入相同的记录，19 和 Bob 。

1890
00:47:43,925 --> 00:47:45,185
0,165 165,285 285,465 465,755 895,1260
to that same record, 19

1891
00:47:45,185 --> 00:47:46,865
0,240 240,515 625,1025 1255,1515 1515,1680
and Bob.| So you have
|所以这里你有 10 ，

1892
00:47:46,865 --> 00:47:48,340
0,180 180,345 345,635 715,1095 1095,1475
10 in there,| 19 and
|19 和 Bob 也被写进了同一个记录，

1893
00:47:48,750 --> 00:47:49,820
0,335 335,545 545,770 770,950 950,1070
Bob got written to that

1894
00:47:49,820 --> 00:47:51,305
0,195 195,500 730,1035 1035,1275 1275,1485
same record,| and then you
|然后你就有了这个 Alice B 被写入，

1895
00:47:51,305 --> 00:47:53,405
0,165 165,455 865,1265 1645,1935 1935,2100
have this Alice, B that

1896
00:47:53,405 --> 00:47:55,055
0,135 135,395 505,905 955,1350 1350,1650
is written,| that update of
|19 和 Bob 的更新刚刚被覆盖。

1897
00:47:55,055 --> 00:47:56,090
0,255 255,480 480,660 660,855 855,1035
19 and Bob just got

1898
00:47:56,090 --> 00:47:57,100
0,680
overwritten.|
|

1899
00:47:57,460 --> 00:47:59,355
0,260 260,520 750,1150 1470,1730 1730,1895
So transaction two did its
所以，事务二完成了它的工作，

1900
00:47:59,355 --> 00:48:00,480
0,270 270,480 480,615 615,870 870,1125
work,| but its values just
|但它的值刚刚被覆盖，

1901
00:48:00,480 --> 00:48:02,115
0,165 165,830 910,1140 1140,1305 1305,1635
got overwritten,| so it lost
|所以它丢失了更新，

1902
00:48:02,115 --> 00:48:03,360
0,395 415,705 705,885 885,1065 1065,1245
its update,| it never got
|它从未没有进入数据库。

1903
00:48:03,360 --> 00:48:04,185
0,165 165,360 360,555 555,705 705,825
made, it made it to

1904
00:48:04,185 --> 00:48:05,300
0,90 90,335
the database.|
|

1905
00:48:06,050 --> 00:48:06,960
0,400
Okay?|
好的？|

1906
00:48:08,040 --> 00:48:11,290
0,400 1770,2135 2135,2435 2435,2830 2850,3250
So we use these properties
所以，我们使用这些属性来定义，

1907
00:48:11,820 --> 00:48:14,720
0,400 480,880 960,1360 1890,2290 2610,2900
to then define,| how to
|如何使这个等效调度工作。

1908
00:48:14,720 --> 00:48:17,500
0,290 550,950 1150,1550 1720,2120 2380,2780
go make this equivalent schedule

1909
00:48:17,550 --> 00:48:18,480
0,400
work.|
|

1910
00:48:18,550 --> 00:48:20,600
0,305 305,515 515,820 960,1360
The two types of
这两种类型的冲突可串行化，

1911
00:48:20,600 --> 00:48:23,405
0,260 460,1370 1510,1890 1890,2640 2640,2805
{} serializability, conflict serializability,| which
|这是我们接下来要讨论的，

1912
00:48:23,405 --> 00:48:25,085
0,210 210,375 375,615 615,935 1345,1680
we'll talk about next,| something
|有时称为视图可串行化，

1913
00:48:25,085 --> 00:48:27,140
0,240 240,465 465,1355 1675,1950 1950,2055
called View serializability,| since we
|由于我们的时间不多了，

1914
00:48:27,140 --> 00:48:27,815
0,75 75,225 225,390 390,525 525,675
are running out of time,|
|

1915
00:48:27,815 --> 00:48:29,020
0,150 150,300 300,510 510,825 825,1205
I might just totally go
我可能会完全跳过这一部分，

1916
00:48:29,040 --> 00:48:30,275
0,305 305,530 530,830 830,1025 1025,1235
skip that piece,| but I'll
|但我会简要地暗示一下它的作用。

1917
00:48:30,275 --> 00:48:31,415
0,225 225,630 630,795 795,945 945,1140
briefly allude to what that

1918
00:48:31,415 --> 00:48:33,130
0,305 565,885 885,1230 1230,1440 1440,1715
does.| Okay, won't grill you
|好的，我不会拿视图可视化的考试试题来盘问你，

1919
00:48:33,270 --> 00:48:34,895
0,380 380,740 740,1100 1100,1400 1400,1625
with exam questions on view

1920
00:48:34,895 --> 00:48:37,220
0,870 870,1265 1465,1830 1830,2190 2190,2325
serializability, okay,| so it's okay,
|所以如果你不完全理解，也没有关系，

1921
00:48:37,220 --> 00:48:38,060
0,75 75,180 180,420 420,615 615,840
if you don't totally get

1922
00:48:38,060 --> 00:48:40,145
0,240 240,570 570,1320 1320,1670 1690,2085
that,| conflict serializabilities was database
|冲突可串行化是数据库系统实现的，

1923
00:48:40,145 --> 00:48:42,125
0,395 625,1025 1285,1575 1575,1815 1815,1980
systems implement| and let's just
|让我们直接跳到这个上面。

1924
00:48:42,125 --> 00:48:43,160
0,195 195,405 405,725
jump into that.|
|

1925
00:48:44,190 --> 00:48:45,170
0,245 245,365 365,560 560,785 785,980
Let me just go with
让我在这里使用这个图表形式，

1926
00:48:45,170 --> 00:48:46,715
0,290 340,720 720,1035 1035,1335 1335,1545
this graph form here| to
|以使它更容易理解。

1927
00:48:46,715 --> 00:48:47,770
0,120 120,285 285,510 510,750 750,1055
make it even more easier

1928
00:48:47,850 --> 00:48:49,430
0,395 395,790 990,1235 1235,1355 1355,1580
to understand.| So what we'll
|所以我们要做的是以下几点。

1929
00:48:49,430 --> 00:48:50,920
0,195 195,405 405,540 540,800
do is the following.|
|

1930
00:48:50,920 --> 00:48:52,465
0,285 285,590 700,1095 1095,1380 1380,1545
We take operations that we
我们采取我们已有的操作，

1931
00:48:52,465 --> 00:48:53,400
0,275
have,|
|

1932
00:48:53,620 --> 00:48:54,940
0,400
and
这是我们有的调度，

1933
00:48:55,010 --> 00:48:56,095
0,275 275,410 410,575 575,845 845,1085
here is the schedule that

1934
00:48:56,095 --> 00:48:57,080
0,135 135,395
we have,|
|

1935
00:48:57,210 --> 00:48:58,565
0,275 275,545 545,890 890,1175 1175,1355
we will start going through
我们将开始经历这一过程，

1936
00:48:58,565 --> 00:49:00,760
0,135 135,315 315,1025 1045,1445 1795,2195
that| and enumerate all possible
|并列举所有可能的冲突，

1937
00:49:00,870 --> 00:49:03,400
0,820 1170,1490 1490,1810 1860,2195 2195,2530
conflicts,| {read-write -}, {write-write -}
|读写，写写，写读，

1938
00:49:03,600 --> 00:49:05,615
0,400 570,890 890,1210 1560,1835 1835,2015
and {write-read -},| okay, those
|好的，这三种冲突。

1939
00:49:05,615 --> 00:49:08,220
0,180 180,815 1105,1455 1455,1805
three conflicts.| We create
|我们创建一个称为依赖图的图，

1940
00:49:08,220 --> 00:49:09,735
0,255 255,645 645,900 900,1080 1080,1515
a graph called the dependence

1941
00:49:09,735 --> 00:49:10,640
0,335
graph,|
|

1942
00:49:10,640 --> 00:49:11,510
0,135 135,285 285,435 435,630 630,870
so I've got two nodes
所以我在图中有两个节点， T1 和 T2 ，

1943
00:49:11,510 --> 00:49:12,380
0,90 90,255 255,510 510,735 735,870
in that graph, {T1 -}

1944
00:49:12,380 --> 00:49:13,505
0,150 150,330 330,620 700,990 990,1125
and {T2 -},| every time
|每次有事务进入时，都会添加新的节点，

1945
00:49:13,505 --> 00:49:14,555
0,120 120,395 475,750 750,900 900,1050
a transaction comes in, a

1946
00:49:14,555 --> 00:49:15,400
0,150 150,315 315,480 480,600 600,845
new node will be added,|
|

1947
00:49:15,660 --> 00:49:16,430
0,245 245,350 350,500 500,650 650,770
so the graph will have
所以，该图将具有尽可能多的事务，

1948
00:49:16,430 --> 00:49:17,855
0,135 135,330 330,650 790,1155 1155,1425
as many transactions,| that are
|在任何时间点系统中处于活动状态的（事务）。

1949
00:49:17,855 --> 00:49:18,965
0,255 255,465 465,615 615,870 870,1110
active in the system at

1950
00:49:18,965 --> 00:49:20,240
0,180 180,390 390,585 585,875
any point in time.|
|

1951
00:49:20,610 --> 00:49:22,085
0,305 305,590 590,785 785,1115 1115,1475
Now I'll just start going
现在我将开始遍历调度，

1952
00:49:22,085 --> 00:49:24,110
0,240 240,495 495,875 1375,1740 1740,2025
through the schedule| and start
|并开始标记所有的冲突，

1953
00:49:24,110 --> 00:49:26,280
0,405 405,690 690,960 960,1610
marking all the conflicts,|
|

1954
00:49:26,280 --> 00:49:27,950
0,320 580,915 915,1185 1185,1395 1395,1670
and I start with the
我从我看到的第一个冲突开始，

1955
00:49:28,780 --> 00:49:29,940
0,335 335,620 620,830 830,980 980,1160
first conflict that I see,|
|

1956
00:49:29,940 --> 00:49:30,830
0,165 165,300 300,420 420,585 585,890
which is a {read-write -},|
这是一个读写，|

1957
00:49:31,850 --> 00:49:33,085
0,395 395,605 605,800 800,950 950,1235
doesn't matter what the conflict
是什么冲突并不重要，

1958
00:49:33,085 --> 00:49:34,495
0,395 445,810 810,1080 1080,1260 1260,1410
is,| as soon as I
|一旦我有了这三种冲突中的一种，

1959
00:49:34,495 --> 00:49:35,425
0,180 180,360 360,525 525,735 735,930
have one of those three

1960
00:49:35,425 --> 00:49:36,870
0,165 165,345 345,635 805,1125 1125,1445
types of conflict,| {read-write -},
|读写，写写或写读，

1961
00:49:36,980 --> 00:49:38,250
0,320 320,560 560,755 755,950 950,1270
{write-write -} or {write-read -},|
|

1962
00:49:38,600 --> 00:49:39,595
0,365 365,485 485,635 635,800 800,995
I'm going to put an
我就会在那里放一个箭头，

1963
00:49:39,595 --> 00:49:41,670
0,300 300,695 1075,1320 1320,1565 1675,2075
arrow there,| so the first
|所以第一个冲突在这个对象 A 上，

1964
00:49:41,780 --> 00:49:42,960
0,400
conflict

1965
00:49:43,330 --> 00:49:45,615
0,400 1290,1580 1580,1760 1760,2015 2015,2285
A is on this object

1966
00:49:45,615 --> 00:49:47,240
0,305 535,810 810,975 975,1245 1245,1625
A| and it goes from
|它从 T1 到 T2 ，

1967
00:49:47,560 --> 00:49:48,645
0,290 290,485 485,665 665,845 845,1085
{T1 -} to {T2 -},|
|

1968
00:49:48,645 --> 00:49:50,210
0,335 535,810 810,960 960,1200 1200,1565
because {T1 -} happens before
因为在调度中 T1 在 T2 之前，

1969
00:49:50,440 --> 00:49:51,465
0,305 305,470 470,605 605,770 770,1025
{T2 -} in the schedule,

1970
00:49:51,465 --> 00:49:52,340
0,365
right,|
|

1971
00:49:52,340 --> 00:49:53,465
0,210 210,390 390,570 570,825 825,1125
so I'll draw a directed
所以我会画一条从 T1 到 T2 的有向弧线。

1972
00:49:53,465 --> 00:49:54,695
0,495 495,705 705,900 900,1065 1065,1230
arc from {T1 -} to

1973
00:49:54,695 --> 00:49:55,700
0,180 180,485
{T2 -}.|
|

1974
00:49:56,360 --> 00:49:57,805
0,260 260,380 380,530 530,820 1170,1445
Does that make sense?| So,
这能理解吗？|所以，真的很简单，

1975
00:49:57,805 --> 00:49:59,550
0,255 255,635 955,1290 1290,1440 1440,1745
really simple,| I'm going to
|我将遍历这个，

1976
00:49:59,810 --> 00:50:01,780
0,400 570,950 950,1235 1235,1540 1680,1970
just walk through this,| for
|对所遇到的每一个冲突，

1977
00:50:01,780 --> 00:50:03,000
0,255 255,600 600,825 825,945 945,1220
every conflict that I have,|
|

1978
00:50:03,050 --> 00:50:04,440
0,380 380,500 500,680 680,995 995,1390
I'll draw a directed graph
按照冲突发生的顺序绘制一个有向图。

1979
00:50:04,550 --> 00:50:05,635
0,290 290,455 455,695 695,935 935,1085
in the order in which

1980
00:50:05,635 --> 00:50:07,220
0,165 165,435 435,690 690,965
this conflict is happening.|
|

1981
00:50:09,130 --> 00:50:11,240
0,400 720,1040 1040,1360 1410,1760 1760,2110
Now I go and find
现在我要去寻找下一个冲突，

1982
00:50:11,650 --> 00:50:14,040
0,400 690,1090 1140,1540
the next conflict,|
|

1983
00:50:14,040 --> 00:50:15,630
0,320 400,765 765,1080 1080,1350 1350,1590
which is this write followed
它是写后面跟着读，

1984
00:50:15,630 --> 00:50:17,655
0,225 225,530 880,1280 1600,1875 1875,2025
by read,| and I will
|我会这样做。

1985
00:50:17,655 --> 00:50:18,700
0,165 165,455
do that.|
|

1986
00:50:19,610 --> 00:50:21,090
0,260 260,455 455,740 740,1085 1085,1480
So the proof is really
所以，证明非常简单，

1987
00:50:21,470 --> 00:50:22,580
0,400
simple,|
|

1988
00:50:22,890 --> 00:50:24,840
0,290 290,470 470,680 680,1000
you take a schedule,|
你拿到一个调度，|

1989
00:50:25,130 --> 00:50:26,670
0,305 305,530 530,850 930,1235 1235,1540
if you walk through it|
如果你遍历它，|

1990
00:50:26,930 --> 00:50:29,275
0,400 930,1310 1310,1625 1625,1960 1980,2345
and draw a line for
为每一个读写、写写或写读冲突画一条线，

1991
00:50:29,275 --> 00:50:30,640
0,365
every

1992
00:50:30,740 --> 00:50:32,605
0,350 350,700 930,1280 1280,1595 1595,1865
{read-write -}, {write-write -} or

1993
00:50:32,605 --> 00:50:34,360
0,240 240,510 510,845
{write-read -} conflict,|
|

1994
00:50:35,150 --> 00:50:36,420
0,275 275,425 425,700
and if it,
如果这张图里有一个环，

1995
00:50:36,460 --> 00:50:37,950
0,380 380,590 590,940 1020,1295 1295,1490
there's a cycle in that

1996
00:50:37,950 --> 00:50:40,070
0,320 610,1010 1060,1440 1440,1770 1770,2120
graph,| you have a bad
|你的调度是糟糕的，

1997
00:50:40,300 --> 00:50:41,480
0,400
schedule,|
|

1998
00:50:41,550 --> 00:50:43,835
0,350 350,700 1140,1540 1620,2150 2150,2285
that schedule will violate the
这个调度将会违反隔离性原则，

1999
00:50:43,835 --> 00:50:46,370
0,495 495,875 1345,1725 1725,2105 2155,2535
isolation principle,| that schedule should
|这个调度永远不应该被允许在数据库系统中运行。

2000
00:50:46,370 --> 00:50:47,900
0,380 550,870 870,1110 1110,1350 1350,1530
never have been allowed to

2001
00:50:47,900 --> 00:50:49,180
0,225 225,450 450,570 570,830 880,1280
run in the database system.|
|

2002
00:50:49,790 --> 00:50:50,830
0,275 275,395 395,575 575,815 815,1040
In the next class,| we'll
在下一节课中，|我们将看到可以用来防止这种情况发生的机制。

2003
00:50:50,830 --> 00:50:51,970
0,150 150,705 705,855 855,990 990,1140
see mechanisms that you can

2004
00:50:51,970 --> 00:50:53,770
0,290 700,1035 1035,1350 1350,1635 1635,1800
use to prevent that from

2005
00:50:53,770 --> 00:50:55,020
0,195 195,530
ever happening.|
|

2006
00:50:55,980 --> 00:50:57,440
0,260 260,395 395,560 560,850 1200,1460
Does that make sense,| if
这能理解吗，|如果你因为幻灯片中的那个错误而没有得到任何其他东西，

2007
00:50:57,440 --> 00:50:58,445
0,105 105,285 285,530 550,795 795,1005
you didn't get anything else

2008
00:50:58,445 --> 00:50:59,240
0,225 225,345 345,495 495,660 660,795
because of that bug in

2009
00:50:59,240 --> 00:51:00,395
0,150 150,405 405,825 825,975 975,1155
the slide,| that's the main
|这就是我希望你从这个隔离性原则中得到的主要东西。

2010
00:51:00,395 --> 00:51:01,115
0,165 165,285 285,435 435,585 585,720
thing I want you to

2011
00:51:01,115 --> 00:51:02,740
0,275 295,585 585,735 735,1260 1260,1625
get from this isolation principle.|
|

2012
00:51:03,740 --> 00:51:05,080
0,255 255,620
What direction?|
方向是什么？|

2013
00:51:05,960 --> 00:51:07,675
0,290 290,725 725,1060 1110,1460 1460,1715
The edges go in the
这些边是按时间顺序排列的，

2014
00:51:07,675 --> 00:51:08,875
0,225 225,540 540,810 810,1005 1005,1200
time order,| see, so look
|请看写入后面跟着读取，

2015
00:51:08,875 --> 00:51:10,720
0,275 475,875 1045,1380 1380,1635 1635,1845
at the write followed by

2016
00:51:10,720 --> 00:51:11,680
0,210 210,405 405,585 585,795 795,960
read,| the red line that
|现在这里显示的红线，

2017
00:51:11,680 --> 00:51:12,720
0,150 150,345 345,540 540,735 735,1040
is shown here right now,|
|

2018
00:51:13,910 --> 00:51:15,055
0,410 410,575 575,785 785,965 965,1145
it's going from {T1 -}
它是从 T1 到 T2 ，

2019
00:51:15,055 --> 00:51:16,150
0,195 195,375 375,555 555,840 840,1095
to {T2 -}, right,| the
|对 A 的写入发生在 T2 读取之前，

2020
00:51:16,150 --> 00:51:17,440
0,260 340,615 615,780 780,990 990,1290
read, the write in A

2021
00:51:17,440 --> 00:51:18,880
0,380 490,870 870,1110 1110,1260 1260,1440
happened before the read in

2022
00:51:18,880 --> 00:51:19,900
0,195 195,500
{T2 -},|
|

2023
00:51:20,110 --> 00:51:21,120
0,230 230,320 320,455 455,695 695,1010
so I will draw a
所以我将从 T1 到 T2 画一条有向线，

2024
00:51:21,120 --> 00:51:22,245
0,330 330,615 615,810 810,975 975,1125
directed line from {T1 -}

2025
00:51:22,245 --> 00:51:23,700
0,150 150,300 300,480 480,785 1105,1455
to {T2 -},| saying some
|表示在 T1 中的一些动作发生在 T2 中的动作之前，

2026
00:51:23,700 --> 00:51:25,580
0,345 345,660 660,870 870,1160
action in {T1 -}

2027
00:51:25,580 --> 00:51:27,290
0,320 340,740 1030,1275 1275,1455 1455,1710
happens before the action in

2028
00:51:27,290 --> 00:51:29,435
0,225 225,530 1030,1335 1335,1640 1840,2145
{T2 -},| which means {T2
|这意味着 T2 最好不要做事情，

2029
00:51:29,435 --> 00:51:30,755
0,210 210,465 465,750 750,1035 1035,1320
-} better not do stuff,|
|

2030
00:51:30,755 --> 00:51:31,595
0,210 210,360 360,495 495,660 660,840
that is the other way
这是相反的，

2031
00:51:31,595 --> 00:51:33,125
0,240 240,510 510,815 1045,1410 1410,1530
around,| because now I've got
|因为现在我有一个矛盾的状态，

2032
00:51:33,125 --> 00:51:34,760
0,255 255,975 975,1275 1275,1500 1500,1635
a contradictory state,| that I'm
|我将以此结束。

2033
00:51:34,760 --> 00:51:35,560
0,105 105,225 225,330 330,495 495,800
going to end up with.|
|

2034
00:51:36,460 --> 00:51:37,460
0,400
Okay?|
好的？|

2035
00:51:37,460 --> 00:51:38,900
0,180 180,345 345,795 795,1130 1150,1440
So the serial schedule is,
所以，串行调度是，调度是，

2036
00:51:38,900 --> 00:51:40,325
0,240 240,585 585,855 855,1130 1150,1425
the schedule is the,| the
|左侧的时间是，

2037
00:51:40,325 --> 00:51:41,195
0,180 180,360 360,495 495,675 675,870
time on the left side

2038
00:51:41,195 --> 00:51:42,020
0,150 150,300 300,510 510,705 705,825
is| the order in which
|数据库看到这些操作的顺序。

2039
00:51:42,020 --> 00:51:43,145
0,135 135,410 460,765 765,960 960,1125
a database is seeing those

2040
00:51:43,145 --> 00:51:44,750
0,275 775,1050 1050,1290 1290,1395 1395,1605
actions.| And let's come to
|让我们来构建这张图，

2041
00:51:44,750 --> 00:51:45,815
0,240 240,420 420,690 690,930 930,1065
construct this graph,| and what
|我们将在下一节课中看到的是，

2042
00:51:45,815 --> 00:51:46,610
0,255 255,390 390,525 525,630 630,795
we'll see in the next

2043
00:51:46,610 --> 00:51:48,185
0,210 210,500 850,1140 1140,1350 1350,1575
class is,| the [] is
|开始说的是，

2044
00:51:48,185 --> 00:51:49,570
0,225 225,450 450,755 775,1080 1080,1385
starts to say,| the second
|第二件事将导致这个图完成，

2045
00:51:49,590 --> 00:51:50,660
0,380 380,605 605,725 725,875 875,1070
stuff which is going to

2046
00:51:50,660 --> 00:51:51,785
0,225 225,405 405,585 585,840 840,1125
cause this graph to complete,|
|

2047
00:51:51,785 --> 00:51:53,135
0,195 195,360 360,660 660,960 960,1350
it will stop,| it won't
它会停下来，|它不会让，

2048
00:51:53,135 --> 00:51:55,355
0,335 505,765 765,900 900,1175 1855,2220
let,| it will basically not
|它不会让这件事执行，

2049
00:51:55,355 --> 00:51:57,350
0,360 360,645 645,855 855,1175 1705,1995
let this thing proceed,| beyond
|下面的对 B 的写入，

2050
00:51:57,350 --> 00:51:58,280
0,150 150,330 330,540 540,750 750,930
the write of B,| because
|因为它说，如果我允许这个写入发生，

2051
00:51:58,280 --> 00:51:59,405
0,135 135,405 405,675 675,885 885,1125
it says, if I allow

2052
00:51:59,405 --> 00:52:00,780
0,210 210,420 420,585 585,845
this write to happen,|
|

2053
00:52:00,780 --> 00:52:02,415
0,380 400,825 825,990 990,1280 1360,1635
this arc to form,| I
这条弧线形成，|我就会有冲突，

2054
00:52:02,415 --> 00:52:03,315
0,120 120,225 225,360 360,615 615,900
will have a conflict,| so
|这一行，

2055
00:52:03,315 --> 00:52:04,590
0,240 240,575 595,855 855,1005 1005,1275
this line,| it will pause
|它将暂停它，

2056
00:52:04,590 --> 00:52:06,890
0,345 345,600 600,890 1600,1950 1950,2300
that,| it will stop transaction
|它将停止事务 T1 继续执行，

2057
00:52:07,060 --> 00:52:08,505
0,260 260,425 425,605 605,1205 1205,1445
{T1 -} from proceeding| with
|使用我们将在下一节课中讨论的技术。

2058
00:52:08,505 --> 00:52:09,495
0,105 105,345 345,645 645,795 795,990
the techniques we'll talk about

2059
00:52:09,495 --> 00:52:10,780
0,120 120,210 210,390 390,725
in the next class.|
|

2060
00:52:13,030 --> 00:52:14,025
0,320 320,500 500,740 740,875 875,995
Yep.| { - - -}
是的。|

2061
00:52:14,025 --> 00:52:14,620
0,395

2062
00:52:15,650 --> 00:52:16,680
0,290 290,455 455,620 620,770 770,1030
Does it need to what?|
它需要什么？|

2063
00:52:16,700 --> 00:52:17,605
0,275 275,425 425,545 545,665 665,905

2064
00:52:17,605 --> 00:52:19,330
0,315 315,555 555,845 1195,1515 1515,1725
{ - -}| Yeah, and
|是的，然后它可能需要放弃一些东西或推迟一些东西，

2065
00:52:19,330 --> 00:52:19,975
0,150 150,285 285,405 405,525 525,645
then it may need to

2066
00:52:19,975 --> 00:52:21,630
0,360 360,725 745,1080 1080,1335 1335,1655
abort something or delay something,|
|

2067
00:52:21,680 --> 00:52:22,750
0,260 260,485 485,695 695,860 860,1070
so we'll, we'll talk about
所以我们会讨论这个，

2068
00:52:22,750 --> 00:52:24,030
0,210 210,530 610,885 885,1020 1020,1280
that, right,| so there are
|所以有时它可能只会说，

2069
00:52:24,260 --> 00:52:25,240
0,380 380,590 590,695 695,830 830,980
sometimes where it may just

2070
00:52:25,240 --> 00:52:25,990
0,165 165,285 285,375 375,555 555,750
say,| you know what, I
|你知道吗，我需要放弃，

2071
00:52:25,990 --> 00:52:27,835
0,135 135,240 240,560 1450,1710 1710,1845
need to abort| and I
|我不能再继续了。

2072
00:52:27,835 --> 00:52:29,200
0,240 240,345 345,540 540,875
can't go any further.|
|

2073
00:52:29,640 --> 00:52:30,905
0,290 290,425 425,695 695,965 965,1265
Alright, so it's really that
好的，就是这么简单。

2074
00:52:30,905 --> 00:52:31,940
0,335
simple.|
|

2075
00:52:31,940 --> 00:52:33,460
0,195 195,470 670,975 975,1200 1200,1520
We will construct this graph
我们将构建这个图，

2076
00:52:33,660 --> 00:52:34,540
0,275 275,425 425,530 530,620 620,880
and| now we have this
|现在我们有了这个漂亮的证明，它说，

2077
00:52:34,680 --> 00:52:36,665
0,320 320,640 1170,1475 1475,1715 1715,1985
beautiful proof that says,| how
|我如何才能拥有正确的隔离性。

2078
00:52:36,665 --> 00:52:39,400
0,180 180,425 1135,1535 1765,2100 2100,2735
do I have correct isolation

2079
00:52:40,020 --> 00:52:41,220
0,400
property.|
|

2080
00:52:41,860 --> 00:52:43,520
0,260 260,455 455,790 1080,1370 1370,1660
All right, so here is
好的，这是三个事务，

2081
00:52:43,780 --> 00:52:45,420
0,305 305,610
three transactions,|
|

2082
00:52:45,760 --> 00:52:47,010
0,290 290,485 485,790 810,1100 1100,1250
just to show this in
只是想用一种稍微复杂一点的方式来说明这一点。

2083
00:52:47,010 --> 00:52:48,650
0,225 225,510 510,735 735,1040 1240,1640
a slightly more complicated way.|
|

2084
00:52:50,530 --> 00:52:51,810
0,275 275,425 425,635 635,970 990,1280
As I walk down,| the
当我走下去的时候，|第一个冲突就是读写，

2085
00:52:51,810 --> 00:52:53,600
0,290 430,830 910,1185 1185,1425 1425,1790
first conflict is that read

2086
00:52:53,680 --> 00:52:55,050
0,395 395,790 840,1085 1085,1175 1175,1370
to write,| there are other
|这里面还有其他的冲突，

2087
00:52:55,050 --> 00:52:56,190
0,465 465,600 600,795 795,1020 1020,1140
conflicts in there,| there's a
|这里有 T1 的 W(A) 到读取 A ，

2088
00:52:56,190 --> 00:52:57,315
0,270 270,555 555,765 765,945 945,1125
{W(A) -} at {T1 -}

2089
00:52:57,315 --> 00:52:58,725
0,225 225,435 435,645 645,965 1105,1410
to read an A,| I'm
|我没有展示所有可能的冲突，

2090
00:52:58,725 --> 00:53:00,200
0,120 120,315 315,540 540,875 1075,1475
not showing every possible conflict

2091
00:53:00,280 --> 00:53:01,680
0,275 275,550 720,1040 1040,1235 1235,1400
in there,| but both of
|但是它们都会引出从 T1 到 T2 的弧线，

2092
00:53:01,680 --> 00:53:03,960
0,240 240,800 1330,1860 1860,2100 2100,2280
them induce arc from {T1

2093
00:53:03,960 --> 00:53:05,180
0,150 150,300 300,465 465,770
-} to {T2 -},|
|

2094
00:53:06,040 --> 00:53:08,250
0,365 365,500 500,665 665,1150 1890,2210
it's just a hazard,| and
这只是一种[危险]，|然后还有其他的冲突，

2095
00:53:08,250 --> 00:53:09,870
0,320 610,870 870,975 975,1140 1140,1620
then there are other conflicts,|
|

2096
00:53:09,870 --> 00:53:10,875
0,135 135,285 285,435 435,645 645,1005
but that will just redo
但这只会重做同样的线，

2097
00:53:10,875 --> 00:53:12,225
0,165 165,375 375,695 895,1170 1170,1350
that same line,| you don't
|你不必多次重新画这条线，

2098
00:53:12,225 --> 00:53:13,095
0,90 90,225 225,510 510,675 675,870
have to redraw that line

2099
00:53:13,095 --> 00:53:14,745
0,305 325,725 925,1200 1200,1470 1470,1650
multiple times,| one arc is,
|一条弧线就够了。

2100
00:53:14,745 --> 00:53:16,245
0,335 475,870 870,1035 1035,1260 1260,1500
one arc is enough, right.|
|

2101
00:53:16,245 --> 00:53:17,240
0,255 255,375 375,540 540,705 705,995
That's all this is showing,|
这就是这一切所显示的，|

2102
00:53:17,530 --> 00:53:18,590
0,260 260,380 380,530 530,740 740,1060
as you go further down,|
当你继续往下走，|

2103
00:53:18,730 --> 00:53:21,165
0,290 290,575 575,970 1020,1420 2130,2435
we see another conflict from
我们看到另一个从 T2 到 T1 的冲突，

2104
00:53:21,165 --> 00:53:22,100
0,180 180,330 330,495 495,660 660,935
{T2 -} to {T1 -},|
|

2105
00:53:25,420 --> 00:53:26,480
0,400
and
这就是这里所有的东西。

2106
00:53:26,615 --> 00:53:27,350
0,105 105,255 255,420 420,570 570,735
that's all there is in

2107
00:53:27,350 --> 00:53:28,240
0,290
here.|
|

2108
00:53:28,570 --> 00:53:30,660
0,290 290,485 485,790 870,1270
So this basically says,|
所以这基本上是在说，|

2109
00:53:30,750 --> 00:53:33,080
0,400 420,820 960,1360
in this schedule,|
在这个调度中，|

2110
00:53:33,450 --> 00:53:34,415
0,320 320,500 500,680 680,785 785,965
even though there's a bunch
尽管这三个事务之间存在大量交错，

2111
00:53:34,415 --> 00:53:35,945
0,180 180,780 780,945 945,1230 1230,1530
of interleaving going on between

2112
00:53:35,945 --> 00:53:38,405
0,305 595,885 885,1175 1885,2235 2235,2460
the three transactions,| this you
|你可以证明这个是正确的。

2113
00:53:38,405 --> 00:53:39,490
0,180 180,450 450,645 645,780 780,1085
can prove to be correct.|
|

2114
00:53:40,890 --> 00:53:42,350
0,275 275,395 395,515 515,790 960,1460
And can you guess what's
你可以猜猜正确的串行调度是什么，

2115
00:53:42,350 --> 00:53:44,780
0,290 490,885 885,1365 1365,1700
the correct serial schedule,|
|

2116
00:53:46,950 --> 00:53:48,420
0,260 260,380 380,515 515,790
look at the graph.|
看这张图。|

2117
00:53:49,970 --> 00:53:50,995
0,335 335,650 650,785 785,905 905,1025
Yeah, it's going to be
使得，这将是图的顺序，

2118
00:53:50,995 --> 00:53:52,350
0,180 180,485 535,840 840,1050 1050,1355
the order of that graph,|
|

2119
00:53:52,670 --> 00:53:53,940
0,305 305,610
{T2 -},
比如 T2 最先发生，

2120
00:53:54,015 --> 00:53:55,370
0,120 120,315 315,660 660,935 955,1355
it's like T2 happened first,|
|

2121
00:53:56,600 --> 00:53:58,780
0,400 720,1160 1160,1450
then T1 happened,|
然后 T1 发生，|

2122
00:53:58,850 --> 00:54:00,420
0,350 350,620 620,815 815,1070 1070,1570
then {T3 -} happened,| whoops,
然后 T3 发生，|这就像这是它们被执行的顺序，

2123
00:54:00,650 --> 00:54:02,170
0,440 440,680 680,920 920,1205 1205,1520
it's as if that was

2124
00:54:02,170 --> 00:54:03,985
0,350 370,980 1000,1365 1365,1605 1605,1815
the serial order in which

2125
00:54:03,985 --> 00:54:04,960
0,195 195,375 375,690 690,840 840,975
they were executed| and we
|而我们一次只运行一个事务。

2126
00:54:04,960 --> 00:54:06,060
0,150 150,345 345,585 585,810 810,1100
were just running one transaction

2127
00:54:06,140 --> 00:54:07,260
0,260 260,395 395,670
at a time.|
|

2128
00:54:08,310 --> 00:54:09,580
0,260 260,515 515,635 635,890 890,1270
And that's the whole idea,|
这就是整个想法，|

2129
00:54:10,020 --> 00:54:10,985
0,245 245,335 335,440 440,665 665,965
now, if you get why
现在，如果你明白为什么这张图是有意义的，

2130
00:54:10,985 --> 00:54:12,155
0,225 225,450 450,690 690,885 885,1170
this graph makes sense,| it's
|它是微不足道的，

2131
00:54:12,155 --> 00:54:12,890
0,330 330,435 435,525 525,630 630,735
trivial,| but it took a
|但人们花了一小段时间才弄明白这一点，

2132
00:54:12,890 --> 00:54:13,820
0,165 165,390 390,570 570,750 750,930
little while for people to

2133
00:54:13,820 --> 00:54:14,750
0,165 165,330 330,495 495,660 660,930
figure this out,| it wasn't
|它并不是那么微不足道，

2134
00:54:14,750 --> 00:54:15,995
0,165 165,590 730,975 975,1125 1125,1245
that trivial,| and that's what
|这就是这些美丽的想法中的许多，

2135
00:54:15,995 --> 00:54:17,195
0,210 210,375 375,635 655,975 975,1200
many of these beautiful ideas

2136
00:54:17,195 --> 00:54:18,530
0,305 355,630 630,840 840,1095 1095,1335
are,| they seem simple only
|回想起来，它们看起来很简单。

2137
00:54:18,530 --> 00:54:19,780
0,180 180,830
in retrospect.|
|

2138
00:54:22,170 --> 00:54:23,240
0,260 260,365 365,610 660,920 920,1070
So, {forget -} everything I
所以，忘记我在幻灯片中对那个错误所说的一切，

2139
00:54:23,240 --> 00:54:24,170
0,255 255,480 480,630 630,795 795,930
said with that bug in

2140
00:54:24,170 --> 00:54:25,595
0,165 165,470 820,1110 1110,1275 1275,1425
the slide,| this, if you
|如果你明白了，

2141
00:54:25,595 --> 00:54:26,990
0,165 165,435 435,815 835,1185 1185,1395
get it,| you understand how
|你就会明白隔离性是如何工作的。

2142
00:54:26,990 --> 00:54:28,500
0,510 510,860
isolation works.|
|

2143
00:54:39,790 --> 00:54:40,815
0,260 260,365 365,530 530,710 710,1025
Yeah, and we'll talk about
是的，我们将在那里讨论中止和其他类型的特殊处理，

2144
00:54:40,815 --> 00:54:41,955
0,435 435,555 555,750 750,960 960,1140
aborts and other kinds of

2145
00:54:41,955 --> 00:54:43,290
0,255 255,645 645,780 780,1055 1075,1335
special handling in there,| but
|但事实是，

2146
00:54:43,290 --> 00:54:44,270
0,120 120,315 315,525 525,690 690,980
what is true is that,|
|

2147
00:54:44,290 --> 00:54:45,675
0,320 320,605 605,875 875,1220 1220,1385
even before the abort,| if
即使在中止之前，|如果你开始看到环，

2148
00:54:45,675 --> 00:54:46,380
0,165 165,330 330,480 480,600 600,705
you start to see a

2149
00:54:46,380 --> 00:54:47,595
0,210 210,435 435,710 850,1095 1095,1215
cycle,| you know you will
|你知道你会陷入糟糕的境地，

2150
00:54:47,595 --> 00:54:48,225
0,135 135,270 270,390 390,480 480,630
end up in a bad

2151
00:54:48,225 --> 00:54:49,230
0,305 415,645 645,735 735,855 855,1005
situation,| so you need to
|所以你需要阻止它。

2152
00:54:49,230 --> 00:54:50,120
0,180 180,470
stop it.|
|

2153
00:54:52,960 --> 00:54:55,170
0,400 450,740 740,905 905,1570 1920,2210
Because time is evolving,| I
因为时间在发展，|我作为数据库事务管理者，

2154
00:54:55,170 --> 00:54:56,960
0,165 165,315 315,590 850,1250 1390,1790
as the database transaction manager,|
|

2155
00:54:57,670 --> 00:54:58,785
0,275 275,500 500,635 635,875 875,1115
if I'm at this point
如果我在这个时间点上，

2156
00:54:58,785 --> 00:55:00,030
0,210 210,515 685,945 945,1125 1125,1245
in time| and I've been
|并且我被告知，

2157
00:55:00,030 --> 00:55:01,005
0,240 240,435 435,600 600,795 795,975
told,| should I admit this
|我是否应该接受 B 的这个读取，

2158
00:55:01,005 --> 00:55:01,800
0,180 180,360 360,570 570,705 705,795
read of B,| I have
|我必须做出决定，

2159
00:55:01,800 --> 00:55:03,300
0,120 120,240 240,435 435,770 1240,1500
to make a decision,| if
|如果我是个悲观的事务管理系统，

2160
00:55:03,300 --> 00:55:05,030
0,210 210,345 345,945 945,1220 1330,1730
I'm this pessimistic transaction management

2161
00:55:05,260 --> 00:55:07,965
0,400 630,1325 1325,1790 1790,2140 2430,2705
system,| pessimistic isolation management,| if
|悲观的隔离性管理，|我将不得不决定是否让这种情况发生，

2162
00:55:07,965 --> 00:55:09,615
0,275 865,1170 1170,1335 1335,1470 1470,1650
I I will have to

2163
00:55:09,615 --> 00:55:10,455
0,195 195,390 390,555 555,690 690,840
decide whether to let that

2164
00:55:10,455 --> 00:55:11,355
0,180 180,345 345,480 480,615 615,900
happen or not,| if I'm
|如果我是乐观的，我会让它继续，

2165
00:55:11,355 --> 00:55:12,615
0,335 475,855 855,990 990,1125 1125,1260
optimistic, I'll let it go,|
|

2166
00:55:12,615 --> 00:55:13,185
0,90 90,195 195,300 300,420 420,570
and in the end I
最终，我会弄明白，

2167
00:55:13,185 --> 00:55:14,100
0,150 150,330 330,555 555,765 765,915
will figure out, right,| so
|这就是悲观和乐观的区别。

2168
00:55:14,100 --> 00:55:14,970
0,195 195,285 285,525 525,765 765,870
that's the difference between the

2169
00:55:14,970 --> 00:55:17,260
0,410 760,1035 1035,1245 1245,1580
pessimistic and the optimistic.|
|

2170
00:55:18,300 --> 00:55:19,570
0,275 275,440 440,680 680,950 950,1270

2171
00:55:20,920 --> 00:55:22,285
0,350 490,840 840,1050 1050,1185 1185,1365
{ -}| It has been
|它在发生的时候被创造出来，

2172
00:55:22,285 --> 00:55:23,790
0,285 285,570 570,825 825,1055 1105,1505
created while it's happening, right,|
|

2173
00:55:23,840 --> 00:55:25,050
0,230 230,305 305,455 455,760 810,1210
so you can imagine something
所以你可以想象这样的事情正在系统中发生，

2174
00:55:25,070 --> 00:55:26,170
0,320 320,515 515,665 665,890 890,1100
like this is happening in

2175
00:55:26,170 --> 00:55:28,210
0,135 135,410 790,1190 1420,1785 1785,2040
the system,| {} [] step
|[]步运行，

2176
00:55:28,210 --> 00:55:30,235
0,240 240,590 1300,1590 1590,1770 1770,2025
is run,| we start with
|我们从 T1 开始，

2177
00:55:30,235 --> 00:55:32,020
0,365 685,1005 1005,1215 1215,1500 1500,1785
begin on {T1 -},| then
|然后读取 A 完成，写入 A 完成，

2178
00:55:32,020 --> 00:55:32,970
0,180 180,360 360,525 525,675 675,950
read of A is done,

2179
00:55:33,290 --> 00:55:34,360
0,275 275,410 410,590 590,815 815,1070
write of A {is,done},| system
|系统说我可以让你继续，

2180
00:55:34,360 --> 00:55:35,080
0,210 210,330 330,450 450,585 585,720
says I can let you

2181
00:55:35,080 --> 00:55:35,840
0,260
go,|
|

2182
00:55:35,840 --> 00:55:37,460
0,290 880,1155 1155,1305 1305,1470 1470,1620
then when the write of
然后，当写入 A 到来，

2183
00:55:37,460 --> 00:55:38,855
0,165 165,470 700,1035 1035,1245 1245,1395
A comes,| system is say,
|系统会说，你知道吗，我需要在这个图表中画一条弧线，

2184
00:55:38,855 --> 00:55:39,620
0,135 135,240 240,420 420,630 630,765
you know what, I need

2185
00:55:39,620 --> 00:55:40,340
0,105 105,195 195,315 315,600 600,720
to put an arc in

2186
00:55:40,340 --> 00:55:41,510
0,165 165,470 520,750 750,930 930,1170
this graph,| so as time
|所以，随着时间的推移，

2187
00:55:41,510 --> 00:55:42,860
0,195 195,720 720,900 900,1230 1230,1350
is progressing,| these arcs are
|这些弧线正在被完成，

2188
00:55:42,860 --> 00:55:44,795
0,260 400,735 735,1070 1240,1605 1605,1935
being done,| the {} {reads,and}
|读写被呈现给发展的系统。

2189
00:55:44,795 --> 00:55:45,965
0,255 255,420 420,585 585,875 925,1170
writes are being presented to

2190
00:55:45,965 --> 00:55:48,660
0,120 120,395 1225,1500 1500,2045
the system that evolves.|
|

2191
00:55:49,690 --> 00:55:51,180
0,245 245,485 485,760

2192
00:55:51,890 --> 00:55:53,050
0,290 290,545 545,650 650,905 905,1160
And that's the difference between
这就是悲观的方法和乐观的区别，

2193
00:55:53,050 --> 00:55:55,180
0,135 135,920 1060,1460 1630,1920 1920,2130
the pessimistic method and the

2194
00:55:55,180 --> 00:55:57,385
0,320 520,1185 1185,1380 1380,1700 1870,2205
optimistic,| pessimistic will say,| first
|悲观的会说，|当我第一次认为有问题时，我会阻止你，

2195
00:55:57,385 --> 00:55:58,180
0,210 210,360 360,510 510,705 705,795
time I think there's a

2196
00:55:58,180 --> 00:55:58,960
0,150 150,375 375,435 435,585 585,780
problem, I'm going to stop

2197
00:55:58,960 --> 00:55:59,760
0,290
you,|
|

2198
00:56:00,490 --> 00:56:01,830
0,290 290,500 500,635 635,910 1080,1340
and we'll see how in
我们将在下一节课上看到，

2199
00:56:01,830 --> 00:56:03,570
0,105 105,285 285,620 970,1365 1365,1740
the next class,| and optimistic
|乐观的是，我让一切都过去，

2200
00:56:03,570 --> 00:56:04,635
0,240 240,390 390,660 660,915 915,1065
is I let everything go,|
|

2201
00:56:04,635 --> 00:56:05,295
0,135 135,255 255,390 390,540 540,660
but I know how to
但我知道如何把你带回一个安全的地方，

2202
00:56:05,295 --> 00:56:05,925
0,120 120,255 255,420 420,540 540,630
get you back to a

2203
00:56:05,925 --> 00:56:06,840
0,195 195,405 405,555 555,720 720,915
safe place,| if bad things
|如果发生了糟糕的事情。

2204
00:56:06,840 --> 00:56:07,800
0,150 150,410
had happened.|
|

2205
00:56:08,210 --> 00:56:09,720
0,400 780,1010 1010,1100 1100,1235 1235,1510

2206
00:56:10,490 --> 00:56:11,755
0,275 275,410 410,620 620,950 950,1265
This is not optimistic,| it's
这不是乐观的，|它只是在说，

2207
00:56:11,755 --> 00:56:12,640
0,135 135,345 345,555 555,690 690,885
just saying,| how do I
|我如何才能检测到某件事是好的还是坏的，

2208
00:56:12,640 --> 00:56:13,915
0,300 300,540 540,765 765,1020 1020,1275
detect that something is good

2209
00:56:13,915 --> 00:56:15,160
0,225 225,515 685,960 960,1110 1110,1245
or bad,| but this is
|但这就是机制。

2210
00:56:15,160 --> 00:56:16,885
0,120 120,380 760,1160 1240,1530 1530,1725
the mechanism.| Yep.| { -}
|是的。|

2211
00:56:16,885 --> 00:56:18,060
0,180 180,360 360,600 600,935

2212
00:56:20,090 --> 00:56:21,535
0,400 840,1115 1115,1235 1235,1325 1325,1445
{} If it is a
如果是环的话，就不行了，

2213
00:56:21,535 --> 00:56:22,630
0,195 195,360 360,510 510,780 780,1095
cycle, it is not okay,|
|

2214
00:56:22,630 --> 00:56:23,680
0,255 255,405 405,570 570,825 825,1050
how do I find the
我怎么找到环，

2215
00:56:23,680 --> 00:56:24,835
0,290 430,720 720,855 855,975 975,1155
cycle,| when do I find
|我什么时候找到环是不同之处，

2216
00:56:24,835 --> 00:56:26,605
0,195 195,485 925,1325 1345,1635 1635,1770
the cycle is where the

2217
00:56:26,605 --> 00:56:27,790
0,240 240,635 655,885 885,1005 1005,1185
difference is,| do I find
|我是不是在环形成就尽快找到它，

2218
00:56:27,790 --> 00:56:28,975
0,165 165,440 520,840 840,1035 1035,1185
the cycle as soon as

2219
00:56:28,975 --> 00:56:30,130
0,120 120,255 255,545 745,1035 1035,1155
it is formed,| or do
|或者，在我让在一切继续之后找到环。

2220
00:56:30,130 --> 00:56:31,345
0,105 105,270 270,435 435,710 880,1215
I find the cycle after

2221
00:56:31,345 --> 00:56:32,900
0,195 195,455 565,840 840,1115
I let everything go.|
|

2222
00:56:34,190 --> 00:56:35,800
0,400 510,920 920,1180 1200,1445 1445,1610
So that's basically the whole
所以，整个理论基本上就是说，

2223
00:56:35,800 --> 00:56:37,260
0,240 240,450 450,740 880,1170 1170,1460
theory of saying,| is this
|这是否等同于那个顺序。

2224
00:56:37,280 --> 00:56:39,310
0,400 810,1055 1055,1205 1205,1510 1680,2030
equivalent to that order or

2225
00:56:39,310 --> 00:56:40,260
0,350
not.|
|

2226
00:56:40,260 --> 00:56:43,310
0,350 940,1340 1450,1850 1870,2270 2650,3050
{} So here is another
这是另一个例子，

2227
00:56:43,540 --> 00:56:44,835
0,400 540,830 830,980 980,1115 1115,1295
example,| and this is where
|这就是我们进入这种新的串行化，

2228
00:56:44,835 --> 00:56:45,705
0,135 135,225 225,390 390,615 615,870
we are getting into this

2229
00:56:45,705 --> 00:56:47,970
0,255 255,780 780,1145 1615,2010 2010,2265
new {serializability -}| and kind
|这里正在发生的事情，

2230
00:56:47,970 --> 00:56:48,885
0,135 135,285 285,435 435,645 645,915
of what is happening over

2231
00:56:48,885 --> 00:56:51,000
0,335 355,755 1015,1415
here in, {}|
|

2232
00:56:51,370 --> 00:56:52,520
0,290 290,440 440,620 620,800 800,1150
{} here what's happening is,|
这里正在发生的事情是，|

2233
00:56:52,630 --> 00:56:53,940
0,290 290,580
{A,is} getting
A 拿出 10 美元，

2234
00:56:54,070 --> 00:56:55,550
0,305 305,610 660,980 980,1190 1190,1480
10 dollars removed from it|
|

2235
00:56:55,720 --> 00:56:57,735
0,365 365,680 680,910 1530,1835 1835,2015
and there's a sum that
有一个正在计算中的 sum 在这里打印出来，

2236
00:56:57,735 --> 00:56:59,160
0,135 135,285 285,825 825,1215 1215,1425
is being calculated that's getting

2237
00:56:59,160 --> 00:57:00,945
0,345 345,590 790,1110 1110,1430 1480,1785
printed out over here,| of
|当然，这个事务也有问题，

2238
00:57:00,945 --> 00:57:03,165
0,305 535,810 810,1085 1585,1965 1965,2220
course, there are problems with

2239
00:57:03,165 --> 00:57:04,770
0,180 180,485 805,1155 1155,1410 1410,1605
this transaction,| because that one
|因为这导致从 T1 到 T2 的弧线，

2240
00:57:04,770 --> 00:57:05,820
0,270 270,510 510,690 690,900 900,1050
causes the arc from {T1

2241
00:57:05,820 --> 00:57:07,335
0,150 150,315 315,510 510,830 1180,1515
-} to {T2 -},| and
|然后你有这个事务，

2242
00:57:07,335 --> 00:57:08,510
0,315 315,555 555,705 705,885 885,1175
then you have this transaction,|
|

2243
00:57:08,650 --> 00:57:10,400
0,260 260,395 395,560 560,800 800,1750
so this is not serializable,|
所以这是不可串行化的，|

2244
00:57:10,600 --> 00:57:11,920
0,260 260,455 455,635 635,880
but if instead of,|
但如果不是，|

2245
00:57:11,920 --> 00:57:13,420
0,255 255,480 480,800 1000,1290 1290,1500
the second transactions doing a
第二个事务做两个事务的 sum ，

2246
00:57:13,420 --> 00:57:14,340
0,195 195,345 345,495 495,645 645,920
sum of the two transactions,|
|

2247
00:57:14,600 --> 00:57:15,720
0,260 260,425 425,650 650,845 845,1120
if the code in there
如果其中的代码只是，

2248
00:57:15,950 --> 00:57:17,260
0,335 335,620 620,860 860,1070 1070,1310
was only about saying,| find
|查找值帐户值大于 100 的事务的数量，

2249
00:57:17,260 --> 00:57:18,565
0,180 180,330 330,495 495,770 1000,1305
the number of transactions that

2250
00:57:18,565 --> 00:57:20,575
0,225 225,545 1075,1380 1380,1685 1705,2010
have values account values greater

2251
00:57:20,575 --> 00:57:22,225
0,165 165,545 925,1215 1215,1440 1440,1650
than 100,| the fact that
|这是一个环的事实并不重要，

2252
00:57:22,225 --> 00:57:24,190
0,135 135,395 445,845 865,1265 1585,1965
it is a cycle,| doesn't
|从第二个事务的语义来看，

2253
00:57:24,190 --> 00:57:25,510
0,195 195,390 390,555 555,1170 1170,1320
matter from the semantics of

2254
00:57:25,510 --> 00:57:27,130
0,150 150,375 375,710 1240,1500 1500,1620
that second transaction,| at a
|在一个高级别的层次上，

2255
00:57:27,130 --> 00:57:28,150
0,165 165,345 345,540 540,855 855,1020
very high level,| that's what
|这就是视图可串行化的含义。

2256
00:57:28,150 --> 00:57:30,400
0,225 225,1005 1005,1340 1480,1880 1960,2250
view serializability is it.| If
|如果你对正在发生的事情的语义有所了解，

2257
00:57:30,400 --> 00:57:31,660
0,225 225,495 495,795 795,1065 1065,1260
you knew something about the

2258
00:57:31,660 --> 00:57:33,000
0,570 570,735 735,885 885,1050 1050,1340
semantics of what was happening,|
|

2259
00:57:33,380 --> 00:57:34,540
0,245 245,470 470,740 740,935 935,1160
you will admit a few
你将会承认更多类型的调度，否则你将不会这样做。

2260
00:57:34,540 --> 00:57:36,190
0,315 315,615 615,885 885,1425 1425,1650
more types of schedules that

2261
00:57:36,190 --> 00:57:37,615
0,135 135,270 270,465 465,770 1180,1425
you would not otherwise.| And
|正如我所说的，

2262
00:57:37,615 --> 00:57:38,380
0,105 105,240 240,390 390,630 630,765
as I said,| that's all
|这就是我想知道的这节课的全部内容，

2263
00:57:38,380 --> 00:57:39,700
0,165 165,390 390,615 615,890 1060,1320
I wanted to know for

2264
00:57:39,700 --> 00:57:40,525
0,150 150,345 345,510 510,630 630,825
this class,| if you didn't
|如果你不明白，那也没关系。

2265
00:57:40,525 --> 00:57:42,220
0,135 135,425 535,990 990,1295 1435,1695
get that, that's okay.| Let
|随它去吧，

2266
00:57:42,220 --> 00:57:43,360
0,150 150,440 580,885 885,990 990,1140
it go,| we're not going
|我们不会过多地谈论视图的可串行化，

2267
00:57:43,360 --> 00:57:44,320
0,120 120,300 300,495 495,675 675,960
to talk too much about

2268
00:57:44,320 --> 00:57:45,880
0,300 300,1160
view serializability,|
|

2269
00:57:45,980 --> 00:57:47,755
0,275 275,440 440,730 780,1180 1440,1775
it will just allow certain
它只是允许某些类型的环，

2270
00:57:47,755 --> 00:57:49,090
0,240 240,450 450,930 930,1170 1170,1335
types of cycles,| because it
|因为它说我认为应用程序是好的。

2271
00:57:49,090 --> 00:57:50,320
0,255 255,510 510,660 660,900 900,1230
says I think the application

2272
00:57:50,320 --> 00:57:51,380
0,270 270,590
is okay.|
|

2273
00:57:51,570 --> 00:57:52,620
0,275 275,550
All right.|
好的。|

2274
00:57:52,620 --> 00:57:53,780
0,180 180,360 360,480 480,765 765,1160
And there's a formal definition
这里有一个对它的正式的定义，

2275
00:57:53,860 --> 00:57:55,050
0,290 290,440 440,560 560,910 930,1190
of it,| if you're interested
|如果你有兴趣从它允许的方面来看它，

2276
00:57:55,050 --> 00:57:56,160
0,135 135,345 345,585 585,855 855,1110
in looking at it in

2277
00:57:56,160 --> 00:57:57,225
0,195 195,405 405,585 585,780 780,1065
terms of what it allows,|
|

2278
00:57:57,225 --> 00:57:59,295
0,240 240,515 1345,1650 1650,1860 1860,2070
it basically allows a few
它基本上允许比严格的串行调度允许的多的调度。

2279
00:57:59,295 --> 00:58:01,110
0,225 225,785 1015,1290 1290,1470 1470,1815
more schedules than a strictly

2280
00:58:01,110 --> 00:58:02,840
0,375 375,645 645,915 915,1220
serial schedule will allow.|
|

2281
00:58:03,080 --> 00:58:04,930
0,305 305,575 575,920 920,1685 1685,1850
Alright, so conflict serializability is
好的，所以冲突可串行化是我们想让你知道的主要事情。

2282
00:58:04,930 --> 00:58:07,270
0,120 120,300 300,620 760,1160 2080,2340
the main thing that we

2283
00:58:07,270 --> 00:58:08,550
0,150 150,300 300,560 670,975 975,1280
want you to know about.|
|

2284
00:58:09,850 --> 00:58:11,900
0,400 600,1480
Alright, pictorially,|
好的，图画形式，|

2285
00:58:12,040 --> 00:58:13,155
0,320 320,500 500,725 725,890 890,1115
here's the universe of all
以下是所有可能的调度，

2286
00:58:13,155 --> 00:58:14,910
0,335 415,995 1075,1395 1395,1575 1575,1755
possible schedules,| including the bad
|包括糟糕的调度，

2287
00:58:14,910 --> 00:58:16,350
0,320 640,900 900,1065 1065,1230 1230,1440
ones,| the ones we don't
|那些我们不希望发生的。

2288
00:58:16,350 --> 00:58:17,520
0,150 150,285 285,530
want to happen.|
|

2289
00:58:18,290 --> 00:58:19,615
0,335 335,575 575,935 935,1145 1145,1325
Sorry, yeah, serial schedule is
抱歉，是的，串行调度是严格串行内容，

2290
00:58:19,615 --> 00:58:20,845
0,225 225,495 495,885 885,1080 1080,1230
that strict serial stuff which

2291
00:58:20,845 --> 00:58:21,985
0,135 135,315 315,585 585,885 885,1140
you talked about,| T1 followed
|T1 在 T2 之前，

2292
00:58:21,985 --> 00:58:22,750
0,195 195,360 360,465 465,555 555,765
by {T2 -},| and that's
|这是唯一允许冲突可串行化的事情，

2293
00:58:22,750 --> 00:58:23,910
0,75 75,315 315,570 570,795 795,1160
the only thing that allow

2294
00:58:23,990 --> 00:58:25,330
0,350 350,995 995,1100 1100,1235 1235,1340
conflict serializable is,| if we
|如果我们允许更多的组合，

2295
00:58:25,330 --> 00:58:26,680
0,135 135,440 730,1035 1035,1200 1200,1350
are allowing a few more

2296
00:58:26,680 --> 00:58:28,855
0,530 910,1215 1215,1425 1425,2040 2040,2175
combinations| and view serializable is
|而视图可串行化是通过应用程序性能可能会有更多的东西。

2297
00:58:28,855 --> 00:58:29,650
0,165 165,315 315,465 465,645 645,795
where you might have a

2298
00:58:29,650 --> 00:58:30,550
0,150 150,330 330,510 510,720 720,900
little bit more by way

2299
00:58:30,550 --> 00:58:32,540
0,120 120,380 460,860 910,1310
of this application performance.|
|

2300
00:58:34,650 --> 00:58:35,870
0,290 290,425 425,635 635,965 965,1220
And there are many more
这里还有更多的层次，

2301
00:58:35,870 --> 00:58:37,235
0,330 330,510 510,795 795,1095 1095,1365
layers in there,| and we'll
|我们将在后面的课程中发现其中的一些，

2302
00:58:37,235 --> 00:58:38,330
0,495 495,630 630,750 750,930 930,1095
uncover some of those in

2303
00:58:38,330 --> 00:58:39,845
0,240 240,585 585,855 855,1160 1270,1515
later classes| and again, a
|在细节课中也会有更多的内容。

2304
00:58:39,845 --> 00:58:40,730
0,150 150,300 300,405 405,615 615,885
lot more in the detail

2305
00:58:40,730 --> 00:58:41,660
0,320
class.|
|

2306
00:58:42,340 --> 00:58:43,425
0,320 320,530 530,695 695,875 875,1085
So we still have one
所以我们还有一个字母要讲，

2307
00:58:43,425 --> 00:58:44,775
0,180 180,405 405,630 630,905 1075,1350
more letter to cover,| which
|那就是 D ，也就是持久性，

2308
00:58:44,775 --> 00:58:45,720
0,150 150,300 300,570 570,825 825,945
is the D, which is

2309
00:58:45,720 --> 00:58:46,830
0,120 120,585 585,810 810,975 975,1110
the durability,| right, we did
|我们说了原子性、一致性、隔离性，

2310
00:58:46,830 --> 00:58:48,200
0,120 120,380
{atomicity -},

2311
00:58:48,300 --> 00:58:50,645
0,820 930,1660 1830,2090 2090,2210 2210,2345
consistency, isolation,| which is where
|这是我们今天花的大部分时间，

2312
00:58:50,645 --> 00:58:51,470
0,165 165,345 345,540 540,705 705,825
we spend most of the

2313
00:58:51,470 --> 00:58:52,730
0,165 165,470 700,960 960,1080 1080,1260
time today,| and the last
|最后一个是持久性，

2314
00:58:52,730 --> 00:58:54,200
0,165 165,315 315,860 1030,1305 1305,1470
one is durability,| which will
|这将会讲得非常快。

2315
00:58:54,200 --> 00:58:55,720
0,210 210,510 510,890
cover really fast.|
|

2316
00:58:55,720 --> 00:58:57,595
0,380 760,1425 1425,1650 1650,1725 1725,1875
{} Durability, we have a
持久性，我们会有一个完整的课程讲它，

2317
00:58:57,595 --> 00:58:58,830
0,195 195,450 450,735 735,945 945,1235
full lecture coming on it,|
|

2318
00:58:58,910 --> 00:59:01,285
0,335 335,665 665,1060 1860,2150 2150,2375
on this in the second
在从现在的第二节课上，

2319
00:59:01,285 --> 00:59:03,930
0,315 315,695 1135,1455 1455,1775 2245,2645
class now,| which is about
|关于确保我们对系统所做的更改，

2320
00:59:04,560 --> 00:59:06,860
0,350 370,770 1180,1580 1660,1980 1980,2300
making sure that the changes

2321
00:59:06,910 --> 00:59:08,295
0,290 290,470 470,760 870,1175 1175,1385
that we make to the

2322
00:59:08,295 --> 00:59:10,380
0,305 865,1230 1230,1470 1470,1800 1800,2085
system,| we're making changes to
|我们对 A B 和 C 之类的内容进行更改，

2323
00:59:10,380 --> 00:59:12,000
0,660 660,915 915,1305 1305,1455 1455,1620
A, the Bs and the

2324
00:59:12,000 --> 00:59:13,190
0,285 285,450 450,675 675,885 885,1190
Cs and stuff like that,|
|

2325
00:59:13,540 --> 00:59:15,660
0,335 335,560 560,850 1470,1745 1745,2120
just in memory,| if you're
只是在内存中，|如果你更新列值或记录，

2326
00:59:15,660 --> 00:59:16,890
0,360 360,495 495,690 690,990 990,1230
updating a column value or

2327
00:59:16,890 --> 00:59:18,120
0,120 120,380 580,945 945,1080 1080,1230
a record,| that's sitting in
|它位于缓冲池中，

2328
00:59:18,120 --> 00:59:19,240
0,120 120,405 405,680
the buffer pool,|
|

2329
00:59:19,630 --> 00:59:21,690
0,400 960,1340 1340,1610 1610,1850 1850,2060
{} but what happens if
但是如果你断电了，

2330
00:59:21,690 --> 00:59:22,670
0,105 105,195 195,345 345,615 615,980
you have a power loss|
|

2331
00:59:22,720 --> 00:59:25,860
0,400 420,820 1410,1810 1950,2650 2880,3140
and memory is volatile,| so
内存是不稳定的，|这些更改从未到磁盘，

2332
00:59:25,860 --> 00:59:26,910
0,165 165,435 435,720 720,915 915,1050
those changes never made it

2333
00:59:26,910 --> 00:59:27,630
0,135 135,315 315,480 480,600 600,720
to disk,| but you might
|但你可能已经提交了该事务。

2334
00:59:27,630 --> 00:59:29,540
0,210 210,510 510,765 765,1070
have committed that transaction.|
|

2335
00:59:29,670 --> 00:59:31,220
0,290 290,815 815,995 995,1265 1265,1550
So durability is the aspect
所以持久性是指，

2336
00:59:31,220 --> 00:59:33,100
0,225 225,560 1150,1440 1440,1605 1605,1880
that says,| if the database
|如果数据库提交了事务，

2337
00:59:34,360 --> 00:59:36,405
0,410 410,560 560,820 1620,1895 1895,2045
commits the transaction,| oh, by
|顺便说一句，允许数据库使用缓冲池，

2338
00:59:36,405 --> 00:59:37,575
0,135 135,345 345,555 555,815 835,1170
the way, the database is

2339
00:59:37,575 --> 00:59:38,505
0,240 240,390 390,510 510,645 645,930
allowed to use a buffer

2340
00:59:38,505 --> 00:59:39,540
0,210 210,405 405,585 585,735 735,1035
pool,| because that's an efficient
|因为这是一种有效的方式来构建数据处理系统，

2341
00:59:39,540 --> 00:59:40,860
0,330 330,680
way to

2342
00:59:40,860 --> 00:59:43,200
0,315 315,630 630,980 1030,1430 2080,2340
build data processing systems,| you
|你不会希望每次访问磁盘，

2343
00:59:43,200 --> 00:59:43,785
0,150 150,225 225,330 330,450 450,585
don't want to go to

2344
00:59:43,785 --> 00:59:44,685
0,225 225,390 390,615 615,765 765,900
disk every time| you want
|你想要缓冲池，

2345
00:59:44,685 --> 00:59:46,215
0,135 135,420 420,645 645,995 1105,1530
a buffer pool,| because buffer
|因为访问缓冲池中的数据比访问磁盘上的数据要快得多。

2346
00:59:46,215 --> 00:59:47,520
0,275 355,750 750,900 900,1050 1050,1305
pool, accessing data in buffer

2347
00:59:47,520 --> 00:59:48,360
0,135 135,285 285,480 480,675 675,840
pool is just so much

2348
00:59:48,360 --> 00:59:49,590
0,255 255,555 555,900 900,1065 1065,1230
faster than accessing things on

2349
00:59:49,590 --> 00:59:50,440
0,500
disk.|
|

2350
00:59:51,050 --> 00:59:52,710
0,400 600,875 875,1010 1010,1265 1265,1660
But if the database is,
但是如果数据库已经提交，

2351
00:59:52,730 --> 00:59:53,950
0,440 440,755 755,995 995,1100 1100,1220
it's committed,| you want to
|你需要确保，

2352
00:59:53,950 --> 00:59:55,975
0,165 165,470 700,1100 1240,1640 1660,2025
make sure that,| if there's
|如果出现电源故障，

2353
00:59:55,975 --> 00:59:58,195
0,225 225,575 1075,1380 1380,1685 1885,2220
power failure,| you can get
|你可以在数据库中获得正确的值。

2354
00:59:58,195 --> 00:59:59,290
0,195 195,390 390,720 720,975 975,1095
the right values in the

2355
00:59:59,290 --> 01:00:00,625
0,255 255,525 525,960 960,1170 1170,1335
database.| So durability will do
|所以，持久性会做这个，

2356
01:00:00,625 --> 01:00:03,505
0,275 655,1055 1285,1680 1680,2075 2545,2880
that,| by making sure when
|通过确保提交发生时，

2357
01:00:03,505 --> 01:00:04,900
0,255 255,465 465,755
the commit happens,|
|

2358
01:00:04,970 --> 01:00:05,980
0,365 365,515 515,635 635,785 785,1010
it's going to make sure
它将确保将某些内容写入磁盘，

2359
01:00:05,980 --> 01:00:07,285
0,315 315,630 630,840 840,1080 1080,1305
certain things get written to

2360
01:00:07,285 --> 01:00:08,500
0,510 510,750 750,900 900,1035 1035,1215
disk| and it'll try to
|它将尝试对磁盘执行非常少的[]写入，

2361
01:00:08,500 --> 01:00:10,255
0,290 430,830 880,1215 1215,1470 1470,1755
do very small amounts of

2362
01:00:10,255 --> 01:00:12,370
0,365 535,930 930,1185 1185,1685 1855,2115
[] write to disk,| so
|以便提供这种持久性属性。

2363
01:00:12,370 --> 01:00:13,630
0,255 255,540 540,810 810,1080 1080,1260
that it can provide this

2364
01:00:13,630 --> 01:00:15,020
0,480 480,830
durability property.|
|

2365
01:00:15,950 --> 01:00:17,080
0,400 480,740 740,860 860,980 980,1130
And as I said,| in
正如我说的，|在之后的两节课中，我们将讨论这个。

2366
01:00:17,080 --> 01:00:18,115
0,150 150,450 450,630 630,810 810,1035
two lectures from now, we'll

2367
01:00:18,115 --> 01:00:19,240
0,165 165,375 375,665
talk about that.|
|

2368
01:00:19,610 --> 01:00:21,480
0,260 260,530 530,790 1290,1580 1580,1870
So that's basically what ACID
所以，这基本上就是 ACID 看起来的样子。

2369
01:00:21,500 --> 01:00:24,360
0,335 335,670 1650,2290 2310,2710
looks like. { -}|
|

2370
01:00:24,720 --> 01:00:26,690
0,400 540,940 1410,1715 1715,1865 1865,1970
Yeah, { -} we can
是的，我们可以在线下讨论这个，

2371
01:00:26,690 --> 01:00:27,980
0,180 180,360 360,480 480,960 960,1290
talk about that offline,| the
|答案是，可能会应用的原则，

2372
01:00:27,980 --> 01:00:29,375
0,300 300,525 525,705 705,1010 1120,1395
answer is the principles will

2373
01:00:29,375 --> 01:00:31,265
0,275 385,785 1045,1410 1410,1710 1710,1890
probably apply,| is like I
|就像我有易失性存储和非易失性存储，

2374
01:00:31,265 --> 01:00:32,675
0,150 150,690 690,960 960,1200 1200,1410
have volatile storage and non

2375
01:00:32,675 --> 01:00:34,730
0,510 510,845 1225,1605 1605,1860 1860,2055
volatile storage| and I can
|我可以将这个持久性原则应用于其中任何一个系统。

2376
01:00:34,730 --> 01:00:36,245
0,195 195,360 360,630 630,945 945,1515
apply this principle of durability

2377
01:00:36,245 --> 01:00:37,480
0,330 330,585 585,750 750,930 930,1235
across any of those systems.|
|

2378
01:00:37,740 --> 01:00:39,280
0,400 510,875 875,1100 1100,1250 1250,1540
Yeah, yeah, the same principles
是的，同样的原则也适用。

2379
01:00:39,300 --> 01:00:41,045
0,335 335,650 650,995 995,1340 1340,1745
to apply.| Yep.| { -}
|是的。|

2380
01:00:41,045 --> 01:00:42,140
0,615 615,810 810,1065

2381
01:00:43,050 --> 01:00:44,885
0,320 320,725 725,1000 1260,1610 1610,1835
The logs, sorry.| { -}
日志，抱歉。|

2382
01:00:44,885 --> 01:00:46,745
0,135 135,525 525,815 925,1325 1555,1860
{ - - -}| Yeah,
|是的，日志将保存在内存中，

2383
01:00:46,745 --> 01:00:47,705
0,195 195,570 570,705 705,825 825,960
the logs will be kept

2384
01:00:47,705 --> 01:00:48,455
0,135 135,300 300,525 525,630 630,750
in memory,| we'll get to
|从现在开始，我们将在两节课中讲到这个，

2385
01:00:48,455 --> 01:00:49,430
0,120 120,285 285,435 435,780 780,975
that in two lectures from

2386
01:00:49,430 --> 01:00:50,870
0,290 460,750 750,975 975,1245 1245,1440
now,| the log records that
|我们创建的日志记录也将保存在内存中，

2387
01:00:50,870 --> 01:00:51,905
0,150 150,390 390,645 645,855 855,1035
we create will be kept

2388
01:00:51,905 --> 01:00:53,315
0,150 150,420 420,815 955,1215 1215,1410
in memory too,| but at
|但在适当的时候，

2389
01:00:53,315 --> 01:00:54,800
0,335 415,795 795,1035 1035,1215 1215,1485
appropriate times,| we will actually
|我们会将它们刷新到磁盘上，

2390
01:00:54,800 --> 01:00:55,775
0,270 270,420 420,555 555,705 705,975
flush them out to disk|
|

2391
01:00:55,775 --> 01:00:57,640
0,135 135,425 445,845 925,1515 1515,1865
to guarantee the durability property.|
以保证持久性。|

2392
01:00:57,720 --> 01:00:58,850
0,305 305,455 455,545 545,770 770,1130

2393
01:00:58,850 --> 01:00:59,360
0,380

2394
01:01:00,370 --> 01:01:01,560
0,275 275,470 470,680 680,935 935,1190
We'll talk about that,| what
我们将会谈过这个问题，|如果日志失败，会发生什么情况，

2395
01:01:01,560 --> 01:01:02,730
0,255 255,465 465,570 570,765 765,1170
happens if the log fails,|
|

2396
01:01:02,730 --> 01:01:04,395
0,330 330,495 495,770 820,1220 1420,1665
that's the whole lecture, two
这就是从现在开始的两节课。

2397
01:01:04,395 --> 01:01:05,730
0,330 330,525 525,815 955,1260 1260,1335
lectures from now.| It's a
|这是一节完整的课，

2398
01:01:05,730 --> 01:01:06,645
0,150 150,375 375,585 585,750 750,915
full lecture,| I can give
|我可以给你十秒钟的回答，

2399
01:01:06,645 --> 01:01:07,580
0,105 105,210 210,390 390,615 615,935
you a ten second answer,|
|

2400
01:01:07,870 --> 01:01:09,135
0,365 365,620 620,815 815,1055 1055,1265
the ten second answer is,|
十秒钟的答案是，|

2401
01:01:09,135 --> 01:01:10,940
0,195 195,375 375,570 570,905 1405,1805
that we will {make,sure} that
我们将确保绝对必须写入磁盘的内容被写入，

2402
01:01:11,230 --> 01:01:12,495
0,395 395,710 710,920 920,1070 1070,1265
absolutely what must be written

2403
01:01:12,495 --> 01:01:13,980
0,195 195,450 450,585 585,875 1225,1485
to disk is written,| and
|如果我们写错了东西，

2404
01:01:13,980 --> 01:01:14,850
0,120 120,285 285,495 495,675 675,870
if we write the wrong

2405
01:01:14,850 --> 01:01:15,660
0,210 210,360 360,495 495,645 645,810
thing,| we will look at
|我们会查看它的值，然后如果我们需要的话，撤销它。

2406
01:01:15,660 --> 01:01:16,695
0,150 150,345 345,570 570,915 915,1035
the value and undo if

2407
01:01:16,695 --> 01:01:17,775
0,150 150,330 330,635 655,975 975,1080
we need to,| we'll do
|我们将用我们写在磁盘上的东西做两件事中的一件，

2408
01:01:17,775 --> 01:01:18,690
0,150 150,330 330,510 510,690 690,915
one of two things with

2409
01:01:18,690 --> 01:01:19,635
0,210 210,360 360,495 495,645 645,945
stuff we write on disk,|
|

2410
01:01:19,635 --> 01:01:21,555
0,245 535,960 960,1185 1185,1535 1645,1920
either redo the operation, because
要么重做操作，因为它与内存中的内容不一致，

2411
01:01:21,555 --> 01:01:23,220
0,210 210,1025 1075,1365 1365,1530 1530,1665
it's inconsistent with what was

2412
01:01:23,220 --> 01:01:24,510
0,120 120,375 375,705 705,1095 1095,1290
in memory| or undo it,
|要么撤销它，因为我们写了不应该写的东西。

2413
01:01:24,510 --> 01:01:25,890
0,240 240,465 465,705 705,1010 1120,1380
because we wrote something that

2414
01:01:25,890 --> 01:01:26,750
0,135 135,270 270,405 405,570 570,860
we should not have written.|
|

2415
01:01:28,180 --> 01:01:29,190
0,290 290,485 485,605 605,875 875,1010
So we'll do redo and
所以，我们将对它们进行重做和撤消逻辑。

2416
01:01:29,190 --> 01:01:31,070
0,330 330,590 850,1250 1300,1590 1590,1880
undo logic on on those.|
|

2417
01:01:32,400 --> 01:01:34,235
0,400 660,920 920,1115 1115,1205 1205,1835
Okay, so here's the conclusions.|
好的，这是总结。|

2418
01:01:34,235 --> 01:01:36,370
0,395 835,1470 1470,1650 1650,1815 1815,2135
{} Concurrency control and recovery
并发控制和恢复是事务最重要的功能之一，

2419
01:01:36,390 --> 01:01:37,810
0,350 350,560 560,785 785,1085 1085,1420
amongst the most important functions

2420
01:01:37,830 --> 01:01:39,970
0,275 275,550 1170,1475 1475,1760 1760,2140
that transactions,| are super important,|
|是非常重要的，|

2421
01:01:40,800 --> 01:01:43,010
0,275 275,560 560,820 870,1520 1520,2210
but that's a putit, definitional
但这是数据库系统的一个陈旧的、定义的组件，

2422
01:01:43,010 --> 01:01:44,675
0,350 520,810 810,1100 1120,1470 1470,1665
component of database systems,| and
|如果你回到数据库系统的早期，

2423
01:01:44,675 --> 01:01:45,305
0,75 75,180 180,315 315,480 480,630
if you go back to

2424
01:01:45,305 --> 01:01:46,270
0,120 120,330 330,555 555,705 705,965
the early days of database

2425
01:01:46,290 --> 01:01:47,900
0,400 720,1145 1145,1265 1265,1415 1415,1610
systems,| that's why they started
|这就是为什么它们开始在企业中被采用，

2426
01:01:47,900 --> 01:01:50,375
0,270 270,570 570,920 1180,1850 2170,2475
getting adopted in enterprises,| because
|因为它们允许所有这些记录保存。

2427
01:01:50,375 --> 01:01:51,410
0,195 195,390 390,585 585,765 765,1035
they allowed all this record

2428
01:01:51,410 --> 01:01:52,260
0,380
keeping.|
|

2429
01:01:52,270 --> 01:01:53,895
0,260 260,440 440,695 695,1030 1350,1625
I need five minutes to
我需要五分钟来回顾一些事情，

2430
01:01:53,895 --> 01:01:55,230
0,195 195,515 775,1050 1050,1185 1185,1335
go over a couple of

2431
01:01:55,230 --> 01:01:56,520
0,285 285,570 570,795 795,1035 1035,1290
things,| but before that, we've
|但在此之前，我们已经谈过几次了，

2432
01:01:56,520 --> 01:01:57,510
0,180 180,375 375,555 555,780 780,990
talked about this a few

2433
01:01:57,510 --> 01:02:00,300
0,290 760,1110 1110,1320 1320,1580 2350,2790
times,| that there are, there's
|对于事务，你还可以做更多的事情，

2434
01:02:00,300 --> 01:02:01,830
0,320 460,810 810,1110 1110,1350 1350,1530
still a lot more things

2435
01:02:01,830 --> 01:02:02,630
0,150 150,270 270,390 390,525 525,800
you can do with transactions,|
|

2436
01:02:03,220 --> 01:02:04,680
0,320 320,485 485,965 965,1205 1205,1460
there's this breakthrough paper that
Google 发布了一篇突破性的论文，名为 Spanner ，

2437
01:02:04,680 --> 01:02:05,775
0,150 150,300 300,480 480,750 750,1095
came out from Google called

2438
01:02:05,775 --> 01:02:07,290
0,545 805,1065 1065,1170 1170,1290 1290,1515
Spanner,| by the way, before
|顺便说一句，在此之前，他们在许多部分都在做最终一致性工作，

2439
01:02:07,290 --> 01:02:08,445
0,240 240,375 375,480 480,660 660,1155
that, they were doing eventual

2440
01:02:08,445 --> 01:02:09,810
0,600 600,780 780,930 930,1125 1125,1365
consistency stuff in many parts,|
|

2441
01:02:09,810 --> 01:02:11,610
0,180 180,405 405,690 690,1010 1450,1800
and they realized, wow, application
他们意识到，哇，应用程序程序员不能完全做到这一点，

2442
01:02:11,610 --> 01:02:13,220
0,660 660,1020 1020,1170 1170,1335 1335,1610
programmers can't quite do that,|
|

2443
01:02:13,420 --> 01:02:14,835
0,260 260,520 630,965 965,1205 1205,1415
so they actually build a
所以他们实际上构建了一个非常难的东西，

2444
01:02:14,835 --> 01:02:16,260
0,285 285,615 615,965
very hard thing,|
|

2445
01:02:16,260 --> 01:02:17,810
0,150 150,270 270,465 465,1130 1150,1550
which is a globally distributed
它是一个全球分布式系统，可以做事务，

2446
01:02:18,010 --> 01:02:19,280
0,380 380,635 635,800 800,980 980,1270
system that can do transactions,|
|

2447
01:02:19,960 --> 01:02:21,135
0,245 245,350 350,610 810,1055 1055,1175
where the transactions could be
事务可以是访问分布式数据库中的对象，

2448
01:02:21,135 --> 01:02:22,700
0,425 505,905
touching objects

2449
01:02:22,700 --> 01:02:24,395
0,290 550,870 870,1190 1240,1500 1500,1695
in the database, which is

2450
01:02:24,395 --> 01:02:25,790
0,335 745,975 975,1080 1080,1230 1230,1395
distributed,| so it might touch
|所以它可以访问伦敦的对象，访问美国的对象，

2451
01:02:25,790 --> 01:02:27,065
0,240 240,450 450,615 615,920 1000,1275
an object in London, touch

2452
01:02:27,065 --> 01:02:28,030
0,210 210,420 420,570 570,705 705,965
an object in the US|
|

2453
01:02:28,470 --> 01:02:30,905
0,395 395,695 695,890 890,1180 2100,2435
and commit that transaction across
并将该事务作为一个事务提交到全球各地，

2454
01:02:30,905 --> 01:02:32,020
0,225 225,420 420,630 630,825 825,1115
the globe as one transaction|
|

2455
01:02:32,520 --> 01:02:33,605
0,305 305,485 485,650 650,845 845,1085
and do that fast and
并快速高效地完成这一操作。

2456
01:02:33,605 --> 01:02:34,580
0,695
efficiently.|
|

2457
01:02:34,580 --> 01:02:35,300
0,120 120,210 210,375 375,570 570,720
And the reason they did
他们这样做的原因是，

2458
01:02:35,300 --> 01:02:36,875
0,290 490,855 855,1110 1110,1335 1335,1575
that is,| if they kept
|如果他们保持最终一致性，

2459
01:02:36,875 --> 01:02:38,860
0,180 180,600 600,1215 1215,1505 1585,1985
the eventual consistency stuff,| all
|各种应用程序编程错误就会出现，

2460
01:02:38,880 --> 01:02:40,775
0,275 275,545 545,935 935,1550 1550,1895
kinds of application programmer bugs

2461
01:02:40,775 --> 01:02:41,990
0,180 180,390 390,695 805,1080 1080,1215
was showing unp,| like the
|比如广告系统会报告错误的东西，

2462
01:02:41,990 --> 01:02:43,280
0,225 225,525 525,795 795,1050 1050,1290
AD system would report wrong

2463
01:02:43,280 --> 01:02:44,720
0,210 210,360 360,510 510,800 1150,1440
things,| it would tell the
|它会告诉同一个广告商，例如，在伦敦的宝洁公司，

2464
01:02:44,720 --> 01:02:46,460
0,270 270,840 840,1215 1215,1560 1560,1740
same advertiser, {Proctor,and} Gamble, for

2465
01:02:46,460 --> 01:02:47,855
0,225 225,435 435,710 970,1245 1245,1395
example, in London,| this is
|这就是我们展示的印象，

2466
01:02:47,855 --> 01:02:49,030
0,135 135,330 330,720 720,885 885,1175
how many impressions we showed,|
|

2467
01:02:49,200 --> 01:02:50,285
0,260 260,395 395,590 590,860 860,1085
and the same campaign in
而在美国同样的活动会显示一个不同的数字，

2468
01:02:50,285 --> 01:02:51,215
0,225 225,480 480,630 630,735 735,930
US would show a different

2469
01:02:51,215 --> 01:02:52,445
0,335 535,795 795,930 930,1065 1065,1230
number| and these two guys
|这两个人拿起电话说，

2470
01:02:52,445 --> 01:02:53,135
0,150 150,255 255,375 375,525 525,690
get on the phone and

2471
01:02:53,135 --> 01:02:53,855
0,225 225,435 435,540 540,645 645,720
say,| what the heck is
|到底发生了什么，

2472
01:02:53,855 --> 01:02:54,680
0,245
happening,|
|

2473
01:02:54,680 --> 01:02:55,820
0,255 255,615 615,750 750,885 885,1140
what impressions did we really
我们到底展示了什么印象，

2474
01:02:55,820 --> 01:02:57,020
0,380 430,690 690,825 825,975 975,1200
show,| you want that answer
|你想要准确的答案，

2475
01:02:57,020 --> 01:02:58,460
0,180 180,285 285,560 880,1140 1140,1440
to be precise,| because someone's
|因为有人为它付钱，

2476
01:02:58,460 --> 01:03:00,395
0,135 135,375 375,585 585,860 1660,1935
paying money for it,| that
|这是他们去构建这个的主要原因之一。

2477
01:03:00,395 --> 01:03:00,995
0,150 150,285 285,375 375,465 465,600
was one of the big

2478
01:03:00,995 --> 01:03:01,955
0,255 255,510 510,675 675,825 825,960
reasons why they went and

2479
01:03:01,955 --> 01:03:03,260
0,165 165,455 535,810 810,1020 1020,1305
built that.| It's a beautiful
|这是一个美丽的系统，

2480
01:03:03,260 --> 01:03:05,645
0,290 580,900 900,1470 1470,2000 2140,2385
system,| requires atomic clocks,| where
|需要原子钟，|你需要在数据中心之间进行卫星同步，

2481
01:03:05,645 --> 01:03:07,220
0,120 120,300 300,780 780,1260 1260,1575
you need satellite syncing across

2482
01:03:07,220 --> 01:03:08,795
0,180 180,390 390,740 1150,1425 1425,1575
the data centers,| so that
|这样两个时钟才不会不同步，

2483
01:03:08,795 --> 01:03:09,695
0,165 165,345 345,600 600,720 720,900
the two clocks are not

2484
01:03:09,695 --> 01:03:11,525
0,195 195,405 405,785 865,1425 1425,1830
out of sync.| {CockroachDB -}
|CockroachDB 是由 Google 的工作人员创建的，

2485
01:03:11,525 --> 01:03:13,220
0,315 315,585 585,905 1105,1455 1455,1695
was formed by people from

2486
01:03:13,220 --> 01:03:16,090
0,290 730,1130 1990,2310 2310,2550 2550,2870
Google who worked on this|
|

2487
01:03:16,140 --> 01:03:17,240
0,275 275,395 395,515 515,790 810,1100
and have a version of
他们有一个不需要卫星时钟的版本，

2488
01:03:17,240 --> 01:03:19,085
0,165 165,315 315,690 690,1040 1300,1845
it that doesn't require satellite

2489
01:03:19,085 --> 01:03:21,290
0,390 390,695 955,1320 1320,1685 1855,2205
clocks,| but fascinating feel,| there's
|但令人着迷的是，|仍然有很多新事物正在发生。

2490
01:03:21,290 --> 01:03:22,205
0,120 120,345 345,570 570,735 735,915
still a lot of new

2491
01:03:22,205 --> 01:03:23,440
0,180 180,345 345,480 480,755
things that are happening.|
|

2492
01:03:24,140 --> 01:03:25,195
0,425 425,575 575,725 725,875 875,1055
Bonus round, I leave this
奖励环节，我在幻灯片中留下这个链接，如果你想要。

2493
01:03:25,195 --> 01:03:26,275
0,195 195,330 330,480 480,785 835,1080
link in the slides if

2494
01:03:26,275 --> 01:03:27,370
0,105 105,255 255,545 595,930 930,1095
you want to.| We've talked
|我们已经讨论了各种不同的模型和一致性级别，

2495
01:03:27,370 --> 01:03:28,440
0,240 240,495 495,690 690,810 810,1070
about all kinds of different

2496
01:03:28,580 --> 01:03:30,565
0,400 420,755 755,1040 1040,1355 1355,1985
models and levels of consistency,|
|

2497
01:03:30,565 --> 01:03:31,440
0,135 135,315 315,390 390,555 555,875
but there's a lot more,|
但还有更多，|

2498
01:03:31,670 --> 01:03:32,545
0,245 245,350 350,500 500,695 695,875
and you can play around
你可以玩弄那张图表。

2499
01:03:32,545 --> 01:03:33,505
0,135 135,315 315,630 630,870 870,960
with that chart.| But I
|但我想在项目 #3 上花几分钟时间，

2500
01:03:33,505 --> 01:03:34,210
0,105 105,240 240,375 375,510 510,705
want to spend a couple

2501
01:03:34,210 --> 01:03:36,445
0,300 300,630 630,980 1480,1880 1900,2235
minutes on the project #3,|
|

2502
01:03:36,445 --> 01:03:37,920
0,210 210,345 345,555 555,935 1075,1475
which is on query execution.|
它是关于查询执行的。|

2503
01:03:38,560 --> 01:03:40,870
0,380 880,1280 1480,2010 2010,2130 2130,2310
And the overview of this
这个项目的概况是，

2504
01:03:40,870 --> 01:03:43,320
0,320 370,770 1270,1620 1620,1970 2050,2450
project is,| we essentially have,|
|我们基本上有，|

2505
01:03:45,200 --> 01:03:46,255
0,275 275,395 395,485 485,725 725,1055
these are the different components
这些都是 Bustub 的不同组成部分，

2506
01:03:46,255 --> 01:03:47,665
0,210 210,420 420,725 805,1095 1095,1410
of {Bustub -},| as you've
|随着时间的推移你逐渐了解和热爱，

2507
01:03:47,665 --> 01:03:48,565
0,255 255,465 465,570 570,705 705,900
gotten to know and love

2508
01:03:48,565 --> 01:03:50,515
0,240 240,575 895,1295 1345,1680 1680,1950
over time,| project #3 is
|项目 #3 与优化器和查询执行有关，

2509
01:03:50,515 --> 01:03:52,620
0,300 300,510 510,755 775,1505 1705,2105
related to the optimizer and

2510
01:03:52,820 --> 01:03:54,610
0,260 260,550 630,1030 1260,1550 1550,1790
the query execution| and project
|而即将到来的项目 #4 将是事务管理部分中的查询执行。

2511
01:03:54,610 --> 01:03:55,795
0,225 225,450 450,710 790,1065 1065,1185
#4 that's coming will be

2512
01:03:55,795 --> 01:03:56,970
0,275 295,615 615,795 795,915 915,1175
query execution in the transaction

2513
01:03:57,140 --> 01:03:58,600
0,400 510,910
management piece.|
|

2514
01:03:58,640 --> 01:03:59,850
0,290 290,545 545,770 770,920 920,1210
Okay, so what is project
好的，那么项目 #3 是什么，

2515
01:03:59,870 --> 01:04:02,010
0,400 720,1055 1055,1235 1235,1570 1740,2140
#3,| you're going to add
|你将添加访问方法，

2516
01:04:02,360 --> 01:04:03,880
0,305 305,610 660,920 920,1180 1230,1520
access methods,| two different access
|两种不同的访问方法，

2517
01:04:03,880 --> 01:04:05,560
0,290 400,1035 1035,1215 1215,1425 1425,1680
methods,| sequential scan and index
|顺序扫描和索引扫描，

2518
01:04:05,560 --> 01:04:06,460
0,320
scan,|
|

2519
01:04:06,880 --> 01:04:09,495
0,275 275,550 1020,1420 1530,1930 2070,2615
you will also do insert,
你还将做插入、删除和更新，

2520
01:04:09,495 --> 01:04:10,695
0,210 210,435 435,785 805,1065 1065,1200
delete and updates,| so these
|这些是你要添加的运算符，

2521
01:04:10,695 --> 01:04:12,225
0,225 225,465 465,935 1075,1365 1365,1530
are the operators stuff that

2522
01:04:12,225 --> 01:04:12,930
0,150 150,240 240,360 360,510 510,705
you're going to add,| you're
|你将把它们添加为系统中的新运算符，

2523
01:04:12,930 --> 01:04:14,180
0,90 90,225 225,500 730,990 990,1250
going to add these as

2524
01:04:14,830 --> 01:04:16,230
0,350 350,845 845,1070 1070,1220 1220,1400
new operators that are in

2525
01:04:16,230 --> 01:04:17,440
0,180 180,470
the system,|
|

2526
01:04:17,480 --> 01:04:18,600
0,260 260,440 440,650 650,830 830,1120
two different types of Join,
两种不同类型的 Join ，嵌套循环 Join 和哈希 Join ，

2527
01:04:18,860 --> 01:04:20,530
0,455 455,695 695,970 1080,1385 1385,1670
nested loops Join and hash

2528
01:04:20,530 --> 01:04:23,065
0,290 790,1190 1420,1740 1740,1830 1830,2535
Join| and there's some miscellaneous
|还有一些其他的窗口聚合函数， Limit Sort 和 Top-k 。

2529
01:04:23,065 --> 01:04:25,615
0,315 315,900 900,1295 1675,2075 2185,2550
window aggregation function, Limit Sort

2530
01:04:25,615 --> 01:04:26,900
0,270 270,495 495,815
and {Top-k -}.|
|

2531
01:04:27,010 --> 01:04:28,965
0,410 410,605 605,800 800,1120 1230,1955
You'll also touch the optimizer,|
你还将接触到优化器，|

2532
01:04:28,965 --> 01:04:30,390
0,255 255,540 540,720 720,945 945,1425
so there's already an optimizer
所以 Bustub 中已经有了一个优化器，

2533
01:04:30,390 --> 01:04:32,510
0,135 135,330 330,650 970,1370 1720,2120
in {Bustub -}| and {
|用来转换查询，

2534
01:04:32,680 --> 01:04:34,130
0,400 480,800 800,995 995,1145 1145,1450
-} to convert a query,|
|

2535
01:04:34,150 --> 01:04:35,295
0,260 260,380 380,605 605,890 890,1145
if a query has both
如果查询同时具有 ORDER BY 和 LIMIT ，

2536
01:04:35,295 --> 01:04:36,165
0,180 180,405 405,615 615,720 720,870
an ORDER BY and a

2537
01:04:36,165 --> 01:04:37,545
0,305 505,765 765,975 975,1215 1215,1380
LIMIT,| you can convert it
|你可以通过简单的转换，转换为 Top-k 查询。

2538
01:04:37,545 --> 01:04:38,580
0,120 120,365 415,660 660,780 780,1035
to a with a simple

2539
01:04:38,580 --> 01:04:40,080
0,380 610,915 915,1080 1080,1275 1275,1500
transformation into a {Top-k -}

2540
01:04:40,080 --> 01:04:41,715
0,320 700,1100 1180,1425 1425,1530 1530,1635
query.| So that will give
|所以，这将给你一个机会来查看优化器是如何工作的。

2541
01:04:41,715 --> 01:04:42,750
0,60 60,150 150,360 360,695 775,1035
you a chance to look

2542
01:04:42,750 --> 01:04:43,770
0,165 165,345 345,540 540,840 840,1020
at how do {optimizers -}

2543
01:04:43,770 --> 01:04:44,620
0,290
work.|
|

2544
01:04:44,870 --> 01:04:45,805
0,260 260,395 395,515 515,620 620,935
If you see a nested
如果你看到嵌套的循环，

2545
01:04:45,805 --> 01:04:46,855
0,255 255,465 465,645 645,825 825,1050
loops,| that's often a bad
|这通常不是一个好主意，

2546
01:04:46,855 --> 01:04:48,355
0,365 595,825 825,885 885,1035 1035,1500
idea,| so in the optimizer,|
|所以，在优化器中，|

2547
01:04:48,355 --> 01:04:49,240
0,135 135,270 270,465 465,675 675,885
you will write a rule
你将编写一个规则，将嵌套循环转换为哈希 Join ，

2548
01:04:49,240 --> 01:04:50,410
0,240 240,465 465,810 810,1035 1035,1170
to convert nested loops to

2549
01:04:50,410 --> 01:04:51,400
0,210 210,500
hash Join,|
|

2550
01:04:51,950 --> 01:04:53,035
0,275 275,410 410,545 545,800 800,1085
because those are typically much
因为这通常要快得多。

2551
01:04:53,035 --> 01:04:55,270
0,305 835,1185 1185,1650 1650,1770 1770,2235
faster.| And similarly with sequential
|同样，顺序扫描到索引扫描，

2552
01:04:55,270 --> 01:04:56,095
0,180 180,360 360,555 555,720 720,825
scan to index scan,| if
|如果存在索引，请不要执行顺序扫描，

2553
01:04:56,095 --> 01:04:57,535
0,165 165,485 505,905 1045,1380 1380,1440
an index exists, don't do

2554
01:04:57,535 --> 01:04:58,675
0,90 90,600 600,810 810,990 990,1140
a sequential scan,| go use
|而是使用索引扫描。

2555
01:04:58,675 --> 01:05:00,100
0,195 195,435 435,755 955,1230 1230,1425
an index scan.| These is,|
|这些就是，|

2556
01:05:00,100 --> 01:05:00,925
0,195 195,345 345,465 465,630 630,825
think of it as the
把它想象成启发式的东西，

2557
01:05:00,925 --> 01:05:02,305
0,600 600,840 840,1020 1020,1170 1170,1380
heuristic stuff,| that we talked
|我们在优化的东西里谈到的，

2558
01:05:02,305 --> 01:05:04,345
0,335 565,900 900,1155 1155,1685 1735,2040
about in the optimization stuff,

2559
01:05:04,345 --> 01:05:06,625
0,255 255,555 555,855 855,1205 1555,2280
right,| not cost based heuristics,
|不是基于成本的启发式，而是基于规则的。

2560
01:05:06,625 --> 01:05:08,020
0,255 255,525 525,875
just rules based.|
|

2561
01:05:09,390 --> 01:05:11,740
0,400 810,1070 1070,1610 1610,1970 1970,2350
{} The leaderboard will require
排行榜将需要对优化器进行更深层次的更改，

2562
01:05:11,970 --> 01:05:13,355
0,395 395,725 725,1010 1010,1205 1205,1385
making deeper changes to the

2563
01:05:13,355 --> 01:05:14,240
0,450 450,555 555,675 675,810 810,885
optimizer,| so even if you
|所以，即使你有来自项目 #1 和项目 #2 的令人惊叹的代码，

2564
01:05:14,240 --> 01:05:15,425
0,225 225,525 525,735 735,930 930,1185
have awesome code from project

2565
01:05:15,425 --> 01:05:16,865
0,225 225,360 360,600 600,965 1105,1440
#1 and project #2,| you're
|你也肯定不会在排行榜上获得好的高的统计数据，

2566
01:05:16,865 --> 01:05:18,305
0,465 465,750 750,945 945,1140 1140,1440
guaranteed not to get good

2567
01:05:18,305 --> 01:05:19,630
0,285 285,525 525,675 675,780 780,1325
high stats on the leaderboard,|
|

2568
01:05:19,860 --> 01:05:20,975
0,290 290,455 455,620 620,845 845,1115
unless you go add new
除非你添加新的优化规则，

2569
01:05:20,975 --> 01:05:23,735
0,510 510,875 1225,1625 2185,2535 2535,2760
optimization rules| and that's all
|这在项目中都有描述，

2570
01:05:23,735 --> 01:05:25,130
0,375 375,615 615,750 750,1025 1075,1395
described in the project,| you'll
|你将向窗口聚合和 top-k 添加规则。

2571
01:05:25,130 --> 01:05:26,330
0,90 90,300 300,615 615,945 945,1200
be adding rules to window

2572
01:05:26,330 --> 01:05:28,120
0,540 540,915 915,1230 1230,1470 1470,1790
aggregation and and {top-k -}.|
|

2573
01:05:28,610 --> 01:05:30,940
0,400 780,1100 1100,1420 1740,2105 2105,2330
{} Quick tips, start with
小贴士，从简单的事情开始，

2574
01:05:30,940 --> 01:05:32,395
0,135 135,410 460,810 810,1065 1065,1455
the easy stuff,| the insert
|插入和顺序扫描，

2575
01:05:32,395 --> 01:05:33,730
0,165 165,705 705,945 945,1230 1230,1335
and sequential scan,| that's the
|这是最简单的事情，

2576
01:05:33,730 --> 01:05:35,400
0,435 435,740 970,1230 1230,1380 1380,1670
easiest stuff,| get it right,|
|先把它弄好，|

2577
01:05:35,720 --> 01:05:38,455
0,400 1080,1370 1370,1660 2190,2495 2495,2735
before you go do other
在你用它做其他事情之前。

2578
01:05:38,455 --> 01:05:40,915
0,270 270,480 480,755 1015,1415 2095,2460
things with it.| And the
|关键的事情是，

2579
01:05:40,915 --> 01:05:43,900
0,285 285,605 625,1025 1915,2315 2725,2985
key thing is,| now you
|现在你可以真的在浏览器中运行 Bustub 了。

2580
01:05:43,900 --> 01:05:46,020
0,260 370,770 1210,1530 1530,1785 1785,2120
can actually go and run

2581
01:05:46,250 --> 01:05:47,540
0,380 380,760
{Bustub -}

2582
01:05:47,540 --> 01:05:48,800
0,260
in,

2583
01:05:49,380 --> 01:05:51,605
0,305 305,530 530,850 1500,1865 1865,2225
in the browser.| So I'm
|所以我要在这里结束了。

2584
01:05:51,605 --> 01:05:52,900
0,120 120,330 330,615 615,930 930,1295
going to close this here.|
|

2585
01:05:53,700 --> 01:05:55,600
0,260 610,1250
And whoops,
然后，不再需要 Powerpoint 了。

2586
01:05:59,035 --> 01:06:00,120
0,180 180,270 270,405 405,690 690,1085
Powerpoint don't need that anymore.|
|

2587
01:06:00,800 --> 01:06:03,320
0,320 1000,1290 1290,1515 1515,1850 2230,2520
And if you go look
如果你现在去看 Bustub ，

2588
01:06:03,320 --> 01:06:05,315
0,290 370,765 765,1160 1180,1580 1720,1995
at {Bustub -} now,| you
|你实际上可以在浏览器中运行 Bustub 。

2589
01:06:05,315 --> 01:06:07,000
0,275 415,815
can actually

2590
01:06:07,000 --> 01:06:08,545
0,380 580,930 930,1140 1140,1290 1290,1545
{ -} go and run

2591
01:06:08,545 --> 01:06:09,870
0,315 315,585 585,825 825,1020 1020,1325
{Bustub -} in the browser.|
|

2592
01:06:10,670 --> 01:06:11,710
0,245 245,365 365,560 560,815 815,1040
let me go find the
让我找到这里的链接。

2593
01:06:11,710 --> 01:06:13,160
0,240 240,590
link here.|
|

2594
01:06:13,500 --> 01:06:14,540
0,400
Yep.|
是的。|

2595
01:06:15,360 --> 01:06:17,000
0,430 540,890 890,1025 1025,1300 1350,1640
[Chi], who's just an awesome
Chi ，他是一个很棒的程序员，

2596
01:06:17,000 --> 01:06:18,220
0,710
programmer,|
|

2597
01:06:18,220 --> 01:06:20,335
0,270 270,650 1090,1410 1410,1725 1725,2115
has written this version,| which
编写了这个版本，|它完全在浏览器中以 VASM 代码运行，

2598
01:06:20,335 --> 01:06:21,880
0,375 375,660 660,855 855,1455 1455,1545
completely runs in {VASM,code} in

2599
01:06:21,880 --> 01:06:23,695
0,150 150,440 1000,1275 1275,1560 1560,1815
the browser| and it's already
|并且已经在其中加载了一些表，

2600
01:06:23,695 --> 01:06:25,120
0,360 360,525 525,720 720,1025 1105,1425
loaded with some tables in

2601
01:06:25,120 --> 01:06:26,470
0,320 550,825 825,945 945,1110 1110,1350
there,| and you can start
|你可以开始做一些事情，

2602
01:06:26,470 --> 01:06:28,750
0,180 180,375 375,675 675,1040 1930,2280
to do things,| like SELECT
|比如 SELECT * FROM _mock_table_，

2603
01:06:28,750 --> 01:06:31,765
0,350 910,1310 1510,1910 2380,2685 2685,3015
* {} FROM {} {_mock_table_

2604
01:06:31,765 --> 01:06:33,445
0,305 685,1005 1005,1215 1215,1440 1440,1680
-},| and do things like
|然后做这样的事情，

2605
01:06:33,445 --> 01:06:35,310
0,305 325,765 765,945 945,1125 1125,1865
that,| whoops, where's my semicolon,|
|糟糕，我的分号在哪里，|

2606
01:06:35,510 --> 01:06:36,595
0,380 380,620 620,770 770,950 950,1085
and you can start to
你就可以开始运行东西了。

2607
01:06:36,595 --> 01:06:37,420
0,165 165,375 375,525 525,645 645,825
run stuff.| You can use
|你可以使用它来测试你的代码是否工作，

2608
01:06:37,420 --> 01:06:38,500
0,270 270,510 510,735 735,930 930,1080
this to test if your

2609
01:06:38,500 --> 01:06:39,520
0,180 180,470
code works,|
|

2610
01:06:39,520 --> 01:06:40,765
0,180 180,480 480,735 735,975 975,1245
our solution is sitting behind
我们的解决方案就在这之后。

2611
01:06:40,765 --> 01:06:41,920
0,240 240,575
that.| Yep.|
|是的。|

2612
01:06:42,820 --> 01:06:44,000
0,105 105,270 270,560

2613
01:06:44,250 --> 01:06:45,635
0,395 395,670 840,1115 1115,1265 1265,1385

2614
01:06:45,635 --> 01:06:46,780
0,105 105,300 300,585 585,840 840,1145

2615
01:06:47,540 --> 01:06:50,200
0,430 870,1270 1320,1655 1655,2260 2340,2660

2616
01:06:50,200 --> 01:06:51,760
0,270 270,570 570,920

2617
01:06:52,740 --> 01:06:54,185
0,305 305,485 485,665 665,1145 1145,1445

2618
01:06:54,185 --> 01:06:55,360
0,270 270,615 615,995

2619
01:06:55,430 --> 01:06:57,190
0,350 350,700 930,1310 1310,1595 1595,1760

2620
01:06:57,190 --> 01:06:58,290
0,165 165,405 405,630 630,810 810,1100

2621
01:06:59,560 --> 01:07:01,980
0,400 780,1180 1260,1660
Yeah, so the,|
是的，所以，|

2622
01:07:02,280 --> 01:07:03,310
0,305 305,470 470,605 605,755 755,1030
use this as a reference,|
将这个作为参考，|

2623
01:07:03,960 --> 01:07:05,165
0,365 365,515 515,785 785,1025 1025,1205
don't use great scope as
不要使用大范围作为进行调试的方法，

2624
01:07:05,165 --> 01:07:06,485
0,195 195,485 595,930 930,1155 1155,1320
a way of doing your

2625
01:07:06,485 --> 01:07:08,840
0,605 775,1095 1095,1305 1305,1595 2005,2355
debugging,| write your tests,| otherwise,
|编写你的测试，|否则，你在这个项目中不会做得很好。

2626
01:07:08,840 --> 01:07:09,970
0,225 225,405 405,645 645,855 855,1130
you will not do well

2627
01:07:10,020 --> 01:07:11,880
0,290 290,485 485,790
in this project.|
|

2628
01:07:12,350 --> 01:07:13,255
0,230 230,395 395,635 635,725 725,905
So hopefully it's a fun
所以希望这是一个有趣的项目，

2629
01:07:13,255 --> 01:07:14,515
0,305 445,750 750,900 900,1020 1020,1260
project,| start with the simple
|从简单的事情开始，

2630
01:07:14,515 --> 01:07:15,340
0,240 240,390 390,540 540,690 690,825
stuff,| it may seem like
|这可能看起来很多，

2631
01:07:15,340 --> 01:07:16,285
0,120 120,380 430,705 705,825 825,945
a lot,| start with the
|从简单的事情开始，

2632
01:07:16,285 --> 01:07:17,170
0,225 225,450 450,585 585,720 720,885
simple stuff| and you'll be
|你会惊讶于你开始快速完成事情。

2633
01:07:17,170 --> 01:07:18,145
0,240 240,405 405,600 600,795 795,975
surprised how quickly you start

2634
01:07:18,145 --> 01:07:19,825
0,330 330,495 495,785 1105,1440 1440,1680
knocking things off.| Okay, all
|好的，谢谢， DJ []，点击它。

2635
01:07:19,825 --> 01:07:21,925
0,255 255,525 525,810 810,1355 1675,2100
right, thank you, DJ, []

2636
01:07:21,925 --> 01:07:23,600
0,210 210,485
hit it.

2637
01:07:59,960 --> 01:08:01,690
0,545 545,740 740,1090 1170,1505 1505,1730

2638
01:08:01,690 --> 01:08:02,890
0,165 165,375 375,525 525,830 940,1200

2639
01:08:02,890 --> 01:08:03,900
0,225 225,345 345,495 495,690 690,1010

2640
01:08:04,040 --> 01:08:05,140
0,305 305,500 500,695 695,875 875,1100

2641
01:08:05,140 --> 01:08:06,100
0,285 285,540 540,675 675,795 795,960

2642
01:08:06,100 --> 01:08:07,255
0,240 240,570 570,840 840,990 990,1155

2643
01:08:07,255 --> 01:08:08,470
0,180 180,375 375,665 775,1065 1065,1215

2644
01:08:08,470 --> 01:08:09,415
0,105 105,240 240,450 450,720 720,945

2645
01:08:09,415 --> 01:08:10,525
0,165 165,345 345,555 555,810 810,1110

2646
01:08:10,525 --> 01:08:11,845
0,240 240,375 375,540 540,1020 1020,1320

2647
01:08:11,845 --> 01:08:13,260
0,240 240,510 510,885 885,1110 1110,1415

2648
01:08:13,340 --> 01:08:14,575
0,275 275,425 425,665 665,980 980,1235

2649
01:08:14,575 --> 01:08:15,760
0,270 270,510 510,825 825,1005 1005,1185

2650
01:08:15,760 --> 01:08:17,245
0,165 165,315 315,1080 1080,1335 1335,1485

2651
01:08:17,245 --> 01:08:19,015
0,255 255,525 525,675 675,1410 1410,1770

2652
01:08:19,015 --> 01:08:20,740
0,420 420,675 675,1095 1095,1380 1380,1725

2653
01:08:20,740 --> 01:08:22,330
0,495 495,705 705,960 960,1275 1275,1590

2654
01:08:22,330 --> 01:08:23,245
0,225 225,420 420,615 615,780 780,915

2655
01:08:23,245 --> 01:08:24,580
0,150 150,420 420,785 925,1200 1200,1335

2656
01:08:24,580 --> 01:08:25,975
0,510 510,750 750,1020 1020,1170 1170,1395

2657
01:08:25,975 --> 01:08:27,430
0,120 120,375 375,755 985,1275 1275,1455

2658
01:08:27,430 --> 01:08:28,435
0,255 255,465 465,615 615,825 825,1005

2659
01:08:28,435 --> 01:08:29,880
0,255 255,510 510,660 660,935 1045,1445

2660
01:08:30,260 --> 01:08:31,360
0,320 320,515 515,710 710,875 875,1100

2661
01:08:31,360 --> 01:08:39,521
0,380 940,1320 1320,1700 2620,3020
