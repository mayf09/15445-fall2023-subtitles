1
00:00:34,900 --> 00:00:35,300
All right.

2
00:00:37,690 --> 00:00:42,240
All right, so some quick things, administrative things from from last class,

3
00:00:42,240 --> 00:00:45,260
it's only been one day. We already got emails,

4
00:00:45,520 --> 00:00:47,810
so the first thing is that,

5
00:00:47,860 --> 00:00:49,215
I made a mistake last class,

6
00:00:49,215 --> 00:00:51,950
I said Ted Codd got his PhD at Penn,

7
00:00:52,360 --> 00:00:53,330
he got his PhD at Michigan,

8
00:00:53,740 --> 00:00:55,760
where all the great data people got their PHDs,

9
00:00:56,560 --> 00:00:59,490
so Michael Stonebraker got his PHD there,

10
00:00:59,490 --> 00:01:00,525
Ted Codd got his PHD there,

11
00:01:00,525 --> 00:01:01,940
David DeWitt another famous Davis guy,

12
00:01:02,110 --> 00:01:04,820
so it was not Penn it was, it was Michigan.

13
00:01:05,290 --> 00:01:08,150
The other thing is people complain that about the audio,

14
00:01:08,530 --> 00:01:10,245
Dear Andy, the audio of your class sucks,

15
00:01:10,245 --> 00:01:12,290
so I can't see you afford a sound engineer, do it right,

16
00:01:12,490 --> 00:01:14,160
Andy, I love the course, but I can't listen to it,

17
00:01:14,160 --> 00:01:14,985
because the audio is messed up,

18
00:01:14,985 --> 00:01:16,245
what happened while you're doing this,

19
00:01:16,245 --> 00:01:17,120
I lost a way to live.

20
00:01:18,070 --> 00:01:20,460
So that that was my fault last time,

21
00:01:20,460 --> 00:01:21,345
so we're double recording,

22
00:01:21,345 --> 00:01:25,310
so hopefully we won't have any issues with posting it this time.

23
00:01:25,330 --> 00:01:27,110
And then we actually got emails about you,

24
00:01:27,790 --> 00:01:29,270
which is surprising, right,

25
00:01:29,950 --> 00:01:35,145
I saw DJ 2PL last month performing at the [bridge 21 over show] in Pittsburgh,

26
00:01:35,145 --> 00:01:35,720
is that true?

27
00:01:36,460 --> 00:01:36,860
All right.

28
00:01:37,270 --> 00:01:39,530
You're very lucky DJ like that, he is expensive,

29
00:01:40,840 --> 00:01:41,960
[] have a lot of money,

30
00:01:43,270 --> 00:01:44,510
does not have a lot of money, okay.

31
00:01:45,670 --> 00:01:49,010
Yo, DJ 2PL is ridiculous, is he single,

32
00:01:49,090 --> 00:01:49,970
I'm asking for my friend,

33
00:01:54,040 --> 00:01:56,805
and then she's like Taylor Swift without any thumbs,

34
00:01:56,805 --> 00:01:57,590
I dont know means,

35
00:01:59,560 --> 00:02:01,340
so are you single?

36
00:02:01,900 --> 00:02:02,640
I'm not.

37
00:02:03,020 --> 00:02:09,960
All right, anyway. That's their problem.

38
00:02:11,900 --> 00:02:14,100
So today's class we to talk about SQL,

39
00:02:14,240 --> 00:02:17,790
the last class we spent time talk on relational model,

40
00:02:18,170 --> 00:02:19,110
we talked about how,

41
00:02:19,190 --> 00:02:23,185
in my opinion, that a superior data model for every possible database,

42
00:02:23,185 --> 00:02:24,060
you can sort of think of,

43
00:02:24,200 --> 00:02:28,020
the relational data model can be used to represent

44
00:02:28,550 --> 00:02:30,990
pretty much all the different schemes, that that are out there.

45
00:02:31,490 --> 00:02:33,870
And then we showed how relational algebra was the building block

46
00:02:34,130 --> 00:02:40,350
for how we would execute queries or define queries to operate over, on a relational database.

47
00:02:40,910 --> 00:02:43,405
So today's class is really now to talk about SQL,

48
00:02:43,405 --> 00:02:50,100
which is a declarative or non-procedural language for interacting with a database system.

49
00:02:50,560 --> 00:02:53,550
And we'll see over time is that SQL has evolved,

50
00:02:53,630 --> 00:02:56,905
where in the beginning, in the 1970s, when it was first defined,

51
00:02:56,905 --> 00:03:00,420
it was very strict about what a relational database should look like,

52
00:03:00,830 --> 00:03:03,030
but in the last 40 years,

53
00:03:03,080 --> 00:03:07,230
it's expanded to support things that don't look relational, like json, for example.

54
00:03:07,820 --> 00:03:10,700
So let's, let's start the beginning, talk about how SQL got started,

55
00:03:10,700 --> 00:03:16,810
and then we'll talk about the more interesting things you can do in modern versions of it.

56
00:03:17,700 --> 00:03:22,210
So the the SQL goes back to the 1970s

57
00:03:22,590 --> 00:03:25,450
and again for Ted Codd, when he wrote that first paper,

58
00:03:25,800 --> 00:03:29,300
he didn't define a programming language for operating relational databases,

59
00:03:29,300 --> 00:03:30,370
it was all mathematical,

60
00:03:30,840 --> 00:03:35,890
people said like, oh, the, the, you know, the paper was so inscrutable,

61
00:03:35,890 --> 00:03:36,840
nobody can understand it,

62
00:03:37,550 --> 00:03:38,305
if you actually read it,

63
00:03:38,305 --> 00:03:39,985
it's actually pretty easily understandable,

64
00:03:39,985 --> 00:03:42,150
it's just people didn't like math back in the day, I guess.

65
00:03:43,010 --> 00:03:43,950
So then he,

66
00:03:45,610 --> 00:03:47,220
some people at IBM saws paper

67
00:03:47,220 --> 00:03:50,430
and try to start building, you know, experimental relational databases

68
00:03:50,430 --> 00:03:54,680
to see whether they can actually take his mathematical ideas and put it, put it into practice.

69
00:03:55,240 --> 00:03:58,110
And so the very first relational database language,

70
00:03:58,110 --> 00:04:01,650
as far as I know was this thing called SQUARE,

71
00:04:01,650 --> 00:04:04,070
that IBM invented in 1971

72
00:04:05,080 --> 00:04:07,125
and this was for a earlier project,

73
00:04:07,125 --> 00:04:10,550
that IBM was developing for one of the first relational database systems,

74
00:04:10,570 --> 00:04:11,660
probably the first one,

75
00:04:12,550 --> 00:04:14,990
which sounds it sounds like a weird experimental rock band,

76
00:04:15,280 --> 00:04:17,420
it's called the Peterlee Relational Test Vehicle,

77
00:04:17,890 --> 00:04:20,775
but that was the first thing they built as an early prototype

78
00:04:20,775 --> 00:04:24,770
to show that you could take ted codd's ideas and actually put it into a real system.

79
00:04:25,400 --> 00:04:27,400
The problem with SQUARE, though, is that,

80
00:04:27,510 --> 00:04:29,225
you can never actually reuse it,

81
00:04:29,225 --> 00:04:32,770
because you had to write in weird notation vertically,

82
00:04:33,000 --> 00:04:35,020
which you can't really do,

83
00:04:35,340 --> 00:04:39,365
so this is from the one of the papers, right,

84
00:04:39,365 --> 00:04:39,970
you would write,

85
00:04:40,620 --> 00:04:44,120
this is how to do a scan on on the sales table by department,

86
00:04:44,230 --> 00:04:46,350
like you would write in this weird vertical way,

87
00:04:46,350 --> 00:04:48,860
with characters that you wouldn't have on a keyboard even today,

88
00:04:49,390 --> 00:04:50,810
so no one actually ever did this.

89
00:04:51,500 --> 00:04:54,265
So then IBM threw that away

90
00:04:54,265 --> 00:04:57,570
and they started building a new query language called SEQUEL,

91
00:04:57,680 --> 00:04:59,220
spelled S E Q U E L,

92
00:04:59,570 --> 00:05:01,285
for the System R project,

93
00:05:01,285 --> 00:05:03,600
which is a system we'll talk about throughout the semester.

94
00:05:03,770 --> 00:05:07,060
But this was the the second relational database system that IBM started building

95
00:05:07,060 --> 00:05:10,320
to try to show that Ted Codd's work could actually be done.

96
00:05:10,700 --> 00:05:12,475
The Peter Lee one that was in the UK,

97
00:05:12,475 --> 00:05:13,350
that was a small team,

98
00:05:13,460 --> 00:05:17,455
the System R project was in San Jose at IBM research

99
00:05:17,455 --> 00:05:19,200
and that that was a major, major undertaking.

100
00:05:19,760 --> 00:05:23,005
So they defined SQL back in 1972,

101
00:05:23,005 --> 00:05:25,440
this was Don Chamberlin and Boyce,

102
00:05:25,760 --> 00:05:26,760
they work in this query language

103
00:05:27,980 --> 00:05:30,900
and the idea is the Structured English Query Language,

104
00:05:31,690 --> 00:05:33,195
but in the 1980s,

105
00:05:33,195 --> 00:05:36,045
when, when IBM put out a commercial relational database system,

106
00:05:36,045 --> 00:05:39,740
they got sued for the term SEQUEL, like the name SEQUEL,

107
00:05:39,760 --> 00:05:43,670
because there was some other system or some other piece of software that was using it,

108
00:05:43,750 --> 00:05:48,370
so then they just reverted it back to SQL,

109
00:05:48,370 --> 00:05:50,670
just the letters, the Structured Query Language.

110
00:05:52,530 --> 00:05:55,895
There was another very famous project at the same time

111
00:05:55,895 --> 00:05:57,740
at Berkeley in the 1970s,

112
00:05:57,740 --> 00:05:58,810
when System R was getting started,

113
00:05:59,580 --> 00:06:00,310
called Ingres,

114
00:06:00,810 --> 00:06:01,960
who here heard of Ingres?

115
00:06:03,720 --> 00:06:05,800
Nobody, who here hears of Postgres?

116
00:06:07,080 --> 00:06:08,810
You want to know why postgres is called Postgres,

117
00:06:08,810 --> 00:06:10,330
because it's Post-Ingres,

118
00:06:10,620 --> 00:06:12,850
the guy that built, Stonebraker, when he built Ingres,

119
00:06:13,560 --> 00:06:16,220
he commercialized it in the the late 1970s

120
00:06:16,220 --> 00:06:17,930
and then went back to Berkeley 1980s,

121
00:06:17,930 --> 00:06:18,820
they built a new system,

122
00:06:19,200 --> 00:06:20,620
that was supposed to be Post-Ingres,

123
00:06:21,030 --> 00:06:22,180
that's why it's called Postgres.

124
00:06:23,580 --> 00:06:27,880
The Postgres, sorry, Ingres had this other query language, called QUEL,

125
00:06:28,600 --> 00:06:32,250
and so SQL, the [plan] of the words is that, [] the SQL to QUEL,

126
00:06:32,920 --> 00:06:35,290
because they the IBM guys knew what what the Berkeley people were doing

127
00:06:35,290 --> 00:06:36,930
and they would try to build a better query language.

128
00:06:37,430 --> 00:06:39,000
Stonebraker would argue that QUEL is better,

129
00:06:40,010 --> 00:06:41,670
but of course no one uses that today.

130
00:06:42,320 --> 00:06:44,340
IBM released a couple of,

131
00:06:46,130 --> 00:06:49,375
in the 1970s, IBM was making a lot of money off of IMS,

132
00:06:49,375 --> 00:06:52,080
which is a non relational system, didn't support SQL,

133
00:06:52,280 --> 00:06:54,805
and then they realized that SQL was going to go somewhere,

134
00:06:54,805 --> 00:06:55,920
relational database were going to go somewhere,

135
00:06:56,150 --> 00:07:00,030
so they released a much early prototypes, like System/38 SQL/DS,

136
00:07:00,560 --> 00:07:04,135
but the big one that that really took off was DB2,

137
00:07:04,135 --> 00:07:05,310
which is still around today.

138
00:07:06,530 --> 00:07:09,235
Again, IBM was a big juggernaut in the computing world,

139
00:07:09,235 --> 00:07:11,485
so whatever IBM said they were going to do,

140
00:07:11,485 --> 00:07:13,230
that sort of became the de facto standard,

141
00:07:13,580 --> 00:07:16,410
so when IBM came out with a relational database that supported SQL,

142
00:07:16,640 --> 00:07:18,600
even though there were competing languages like QUEL,

143
00:07:19,160 --> 00:07:22,830
everyone coalesced around around SQL.

144
00:07:24,400 --> 00:07:26,895
So, SQL became a standard in, a ANSI standard,

145
00:07:26,895 --> 00:07:28,110
it was American Standard Institute,

146
00:07:28,110 --> 00:07:29,420
in 1986,

147
00:07:29,680 --> 00:07:34,020
and it became an international standard in 1987.

148
00:07:34,020 --> 00:07:38,540
And so even though it's a 50 60 year old language now,

149
00:07:38,950 --> 00:07:41,090
it has evolved and expanded over time.

150
00:07:41,530 --> 00:07:45,980
So the latest version of the SQL standard actually came out in March this year in 2023

151
00:07:47,020 --> 00:07:48,105
and sees her list here,

152
00:07:48,105 --> 00:07:49,340
the history of all the updates,

153
00:07:49,540 --> 00:07:51,320
the various features they've added over time,

154
00:07:51,840 --> 00:07:54,890
and the main takeaway from this, from this listing here is that,

155
00:07:55,780 --> 00:07:58,920
as as programs evolved, applications evolved,

156
00:07:58,920 --> 00:08:01,970
or the trends in in development software development has evolved,

157
00:08:02,380 --> 00:08:05,205
SQL has, has, has moved along with it

158
00:08:05,205 --> 00:08:07,910
and adopted the ideas and adopted new new capabilities.

159
00:08:08,770 --> 00:08:12,470
So, in in 2023, the big two features that have come out is

160
00:08:12,760 --> 00:08:16,220
now you can do property graph queries directly in SQL.

161
00:08:16,590 --> 00:08:18,790
So somebody brought up Neo4j last class,

162
00:08:19,140 --> 00:08:23,500
that's, that's a special purpose graph data model database system,

163
00:08:24,160 --> 00:08:25,270
but now you don't need that anymore,

164
00:08:25,270 --> 00:08:28,045
because now you can run graph queries directly in SQL,

165
00:08:28,045 --> 00:08:29,490
because the SQL standard supports it.

166
00:08:30,010 --> 00:08:32,570
They also add support for multi dimensional arrays,

167
00:08:33,070 --> 00:08:33,795
so I said before,

168
00:08:33,795 --> 00:08:36,980
that a lot of machine learning stuff is based on arrays or matrices,

169
00:08:37,270 --> 00:08:39,650
now you can operate directly on SQL these things.

170
00:08:40,000 --> 00:08:42,105
Now just because the standard has defines it,

171
00:08:42,105 --> 00:08:43,820
doesn't mean every system is going to support it, right,

172
00:08:45,430 --> 00:08:49,490
I don't think any system really supports the multi dimensional array stuff,

173
00:08:49,570 --> 00:08:51,015
Oracle supports the property graph stuff,

174
00:08:51,015 --> 00:08:51,975
Postgres will eventually get there,

175
00:08:51,975 --> 00:08:54,140
DuckDB eventually, DuckDB has a prototype for it.

176
00:08:54,400 --> 00:08:55,980
But because it's in the standard,

177
00:08:56,270 --> 00:08:58,050
now everyone's going to actually be able to support it.

178
00:08:59,000 --> 00:09:00,210
So I would say, in my opinion,

179
00:09:00,650 --> 00:09:04,800
the minimum support you need for SQL to say that your database support SQL

180
00:09:04,940 --> 00:09:07,020
is defined in the SQL-92 standard,

181
00:09:07,700 --> 00:09:10,140
that's like, SELECT INSERT UPDATE DELETE CREATE tables,

182
00:09:10,490 --> 00:09:12,360
that's, that's the basic functionality.

183
00:09:13,070 --> 00:09:15,145
So again, even though sql is over 50 years old,

184
00:09:15,145 --> 00:09:16,110
it's not a dead language

185
00:09:16,190 --> 00:09:17,580
and there's updates all the time.

186
00:09:18,220 --> 00:09:20,460
And of course, every ten years, every five years,

187
00:09:20,600 --> 00:09:22,075
some new technology comes out

188
00:09:22,075 --> 00:09:24,240
and people say that SQL is dead

189
00:09:24,890 --> 00:09:25,890
and it's about to be replaced,

190
00:09:27,020 --> 00:09:28,500
10 years ago, it was NoSQL,

191
00:09:28,730 --> 00:09:32,640
And the hot thing now is ChatGPT or vector databases,

192
00:09:32,930 --> 00:09:36,850
so you see a lot of these kind of things on Twitter or on social media,

193
00:09:36,850 --> 00:09:38,310
where they claim SQL is going to die,

194
00:09:38,450 --> 00:09:40,615
because ChatGPT is going to replace it

195
00:09:40,615 --> 00:09:41,970
or natural language is going to replace it, right,

196
00:09:42,710 --> 00:09:45,060
this is all a bunch of hype,

197
00:09:45,680 --> 00:09:47,970
it's interesting, but it's not going to replace SQL,

198
00:09:48,290 --> 00:09:49,650
SQL was here before you were born,

199
00:09:50,000 --> 00:09:51,210
SQL be here when you die.

200
00:09:53,990 --> 00:09:57,250
And I've made public statements basically about this,

201
00:09:57,250 --> 00:10:03,120
there's an article they quoted me in last year, some magazines or something,

202
00:10:03,170 --> 00:10:04,720
I basically said you need to know SQL,

203
00:10:04,720 --> 00:10:06,630
if you want to do anything in in computer science.

204
00:10:07,520 --> 00:10:08,010
All right,

205
00:10:09,440 --> 00:10:12,485
so the, in a relational language like SQL,

206
00:10:12,485 --> 00:10:14,320
it's going to have three parts,

207
00:10:14,790 --> 00:10:17,530
there's going to be the DML, the data manipulation language,

208
00:10:17,790 --> 00:10:21,500
that's how we're going to, that's our SELECT INSERT UPDATE DELETE queries,

209
00:10:21,500 --> 00:10:22,900
that interact with in our database,

210
00:10:23,430 --> 00:10:25,355
would be the DDL, the data definition language,

211
00:10:25,355 --> 00:10:27,280
that's the CREATE TABLE statement, the CREATE VIEW statement,

212
00:10:27,600 --> 00:10:31,030
to create the entities of the objects in our database

213
00:10:31,800 --> 00:10:33,650
and then there be, we're not really going to cover this,

214
00:10:33,650 --> 00:10:35,470
but there'll be the DCL, the data control language,

215
00:10:35,790 --> 00:10:37,930
that's for like security and access control,

216
00:10:38,340 --> 00:10:39,530
some systems allow you have,

217
00:10:39,530 --> 00:10:42,230
like, you know, you can specify what users are allowed to see

218
00:10:42,230 --> 00:10:44,560
what rows or what columns or what tables and so forth,

219
00:10:44,760 --> 00:10:47,050
so the SQL standard specifies for, for these things.

220
00:10:48,250 --> 00:10:48,945
Another big thing,

221
00:10:48,945 --> 00:10:51,980
we'll see later in the semester is the definition of transactions,

222
00:10:53,200 --> 00:10:58,040
how do you define a bunch of SQL statements you want to happen atomically in an isolated way,

223
00:10:58,210 --> 00:11:00,290
and again, the SQL standard supports this.

224
00:11:00,700 --> 00:11:03,500
So again, we'll see bits and pieces of this as we go throughout this semester,

225
00:11:03,580 --> 00:11:04,850
but for today's lecture,

226
00:11:05,170 --> 00:11:07,550
we're really going to focus on the first one, the DML.

227
00:11:08,350 --> 00:11:12,650
And in reminder from, from picking up where we we talked about last class,

228
00:11:13,450 --> 00:11:14,630
SQL is going to be based on bags,

229
00:11:14,740 --> 00:11:16,760
meaning there could be duplicates,

230
00:11:17,110 --> 00:11:19,610
whereas relational algebra was based on sets

231
00:11:20,080 --> 00:11:21,150
and we see some cases

232
00:11:21,150 --> 00:11:26,630
where we'll have to add extra stuff in our SQL statements to, to deal with that.

233
00:11:28,480 --> 00:11:31,485
So today, again, is supposed to be a crash course on modern SQL,

234
00:11:31,485 --> 00:11:34,190
I'm assuming everyone, whether or not you know it or not,

235
00:11:34,390 --> 00:11:36,470
you know enough from the SQL-92 standard,

236
00:11:37,090 --> 00:11:38,210
SELECT INSERT UPDATE DELETE

237
00:11:38,560 --> 00:11:40,040
and I want to talk about the,

238
00:11:40,900 --> 00:11:44,430
I want to talk about the more sophisticated things you can do with them,

239
00:11:44,960 --> 00:11:48,300
but, but the overarching theme also will be is that,

240
00:11:48,300 --> 00:11:49,520
we will open up the terminal,

241
00:11:49,630 --> 00:11:51,830
we'll try a bunch of these queries in different database systems,

242
00:11:52,270 --> 00:11:53,265
and we will see that,

243
00:11:53,265 --> 00:11:55,010
even though there is a SQL standard,

244
00:11:55,240 --> 00:11:57,930
there is an internationally recognized document,

245
00:11:57,930 --> 00:11:59,510
that says here's what sql should look like,

246
00:12:00,440 --> 00:12:03,350
nobody implements it exactly that way, right,

247
00:12:03,520 --> 00:12:05,430
everyone's going to have these weird nuances and quirks,

248
00:12:05,430 --> 00:12:09,440
where they have different features or different nomenclature or syntax to do certain things,

249
00:12:10,720 --> 00:12:13,940
in some cases, different semantics of different operations,

250
00:12:14,800 --> 00:12:16,510
where even though there's a SQL standard,

251
00:12:16,510 --> 00:12:18,240
it's going to be different from one system to the next.

252
00:12:19,650 --> 00:12:20,890
Who did, take a guess who,

253
00:12:20,910 --> 00:12:24,095
who do I think is the biggest offender for the worst SQL implementationation,

254
00:12:24,095 --> 00:12:25,010
worse is not the right word,

255
00:12:25,010 --> 00:12:27,670
but like the one that deviates from the standard the most,

256
00:12:28,740 --> 00:12:29,500
let me take a guess.

257
00:12:31,850 --> 00:12:32,920
The top four out of.

258
00:12:32,920 --> 00:12:33,690
Yes, in the back, yes.

259
00:12:34,550 --> 00:12:35,515
MySQL, he got it right,

260
00:12:35,515 --> 00:12:38,610
yes, MySQL is gonna be the of all these,

261
00:12:38,840 --> 00:12:40,230
where they're gonna do all sorts of weird,

262
00:12:41,420 --> 00:12:43,540
more recently, they now have a flag,

263
00:12:43,540 --> 00:12:44,760
where you can make it be more strict

264
00:12:44,930 --> 00:12:47,940
and try to be more closer to the SQL standard,

265
00:12:48,140 --> 00:12:50,040
but for the longest time, they do a bunch of weird things.

266
00:12:50,150 --> 00:12:51,390
And my problem is that,

267
00:12:51,560 --> 00:12:54,270
I first started using databases, relation databases in like,

268
00:12:54,500 --> 00:12:55,975
when I was in high school in the 90s

269
00:12:55,975 --> 00:12:57,300
and we were using MySQL 3,

270
00:12:57,680 --> 00:12:59,070
so I have all these bad habits,

271
00:12:59,240 --> 00:13:00,880
that like I picked up from MySQL

272
00:13:00,880 --> 00:13:02,250
and I'm like oh yeah, this is what SQL is,

273
00:13:02,270 --> 00:13:02,935
then you realize,

274
00:13:02,935 --> 00:13:04,375
when you start playing other systems,

275
00:13:04,375 --> 00:13:06,690
like this is crazy, they're doing some weird stuff,

276
00:13:07,760 --> 00:13:08,800
but it's gotten better,

277
00:13:08,850 --> 00:13:11,620
MySQL 8 has has certainly improved a lot.

278
00:13:11,790 --> 00:13:15,010
All right, so we'll go through all of these aggregations, group bys,

279
00:13:15,420 --> 00:13:16,955
the string date and time operations,

280
00:13:16,955 --> 00:13:18,610
that's going to be the one where we see all the problems

281
00:13:18,900 --> 00:13:22,480
and then a bunch of other different ways to to interact with SQL queries.

282
00:13:22,740 --> 00:13:25,240
And another theme about what we'll talk about is

283
00:13:25,650 --> 00:13:28,510
the goal of writing SQL statement oftentimes is to

284
00:13:28,710 --> 00:13:32,465
try to do all the computation on the the database server itself,

285
00:13:32,465 --> 00:13:35,110
within one sort of one overarching SQL query,

286
00:13:35,520 --> 00:13:37,340
meaning we don't want to have to do a SELECT,

287
00:13:37,340 --> 00:13:39,770
get some data back into a Python program or something,

288
00:13:39,770 --> 00:13:41,405
then then then operate on it

289
00:13:41,405 --> 00:13:42,700
and then push it back and do more queries,

290
00:13:42,750 --> 00:13:44,140
we want to try to do everything we can

291
00:13:44,430 --> 00:13:47,680
on the on, on the server side, inside the database system,

292
00:13:48,180 --> 00:13:50,270
because we want to be able to push the query to the data,

293
00:13:50,270 --> 00:13:52,600
not pull the, the, the data to the query.

294
00:13:53,890 --> 00:13:55,820
Again, this make more sense as we go along.

295
00:13:57,170 --> 00:14:00,480
All right, so for today we're using a simple example database like this,

296
00:14:00,830 --> 00:14:04,480
has three tables, student, enrolled and course, right,

297
00:14:04,480 --> 00:14:06,750
it's basically trying to mimic a university,

298
00:14:06,770 --> 00:14:10,330
there's students, they take classes and they're enrolled

299
00:14:10,330 --> 00:14:12,390
and they get grades in the various courses that are there.

300
00:14:12,950 --> 00:14:16,770
Okay, so we'll use this as the sample database as we go along.

301
00:14:18,230 --> 00:14:19,440
All right, first thing is aggregations,

302
00:14:20,120 --> 00:14:24,085
so aggregate functions are a, a way

303
00:14:24,085 --> 00:14:31,530
to compute some mathematical computation on a a sequence of data or a bag of tuples

304
00:14:31,850 --> 00:14:34,830
and you're basically going to going to coalesce it down into a single value.

305
00:14:35,500 --> 00:14:40,920
So the classic things would be AVG, MIN, AVG, MIN, MAX, SUM, COUNT,

306
00:14:41,390 --> 00:14:45,600
you're trying to compute the min value of a column

307
00:14:46,070 --> 00:14:48,720
across all tuples, within within a relation.

308
00:14:50,420 --> 00:14:51,625
So an simple example like this,

309
00:14:51,625 --> 00:14:52,380
say we want to get,

310
00:14:52,790 --> 00:14:55,765
for the students, we want to count the number of students,

311
00:14:55,765 --> 00:15:00,960
so have a login, where the login ends with @cs,

312
00:15:01,040 --> 00:15:03,330
do you have an @cs email address.

313
00:15:03,900 --> 00:15:06,680
And so we just put the count function here,

314
00:15:07,210 --> 00:15:09,345
and then inside of it, actually doesn't matter for COUNT,

315
00:15:09,345 --> 00:15:11,300
but we're account that logins

316
00:15:11,500 --> 00:15:12,425
and then we have our where clause

317
00:15:12,425 --> 00:15:15,590
specifying what tuple should qualify.

318
00:15:16,840 --> 00:15:19,160
So again, in my example here, I'm putting login,

319
00:15:19,270 --> 00:15:20,390
you don't actually have to do that,

320
00:15:20,530 --> 00:15:23,180
you could put a star, that's equivalent,

321
00:15:23,650 --> 00:15:26,150
because again, it's just counting the number of entries.

322
00:15:26,840 --> 00:15:27,670
You can actually put 1,

323
00:15:28,290 --> 00:15:30,490
again, also equivalent, it doesn't matter.

324
00:15:31,490 --> 00:15:32,550
Inside, you can really put anything,

325
00:15:32,870 --> 00:15:34,200
you can put 1+1+1.

326
00:15:35,000 --> 00:15:37,380
And the database system should be smart enough to realize that,

327
00:15:37,670 --> 00:15:39,180
in this last example here,

328
00:15:39,820 --> 00:15:42,360
I don't care what the expression is inside of the COUNT,

329
00:15:42,590 --> 00:15:43,860
and I won't actually do that math,

330
00:15:44,210 --> 00:15:47,310
because I just care about what's the count tuples that I have.

331
00:15:49,310 --> 00:15:51,780
You can have multiple aggregates in a single SELECT output,

332
00:15:51,980 --> 00:15:57,840
so here now we're going to compute the average gpa and the counting of the number of students,

333
00:15:58,250 --> 00:16:02,460
again, with that, have the @cs login.

334
00:16:03,060 --> 00:16:08,090
And you get back a single entry or single record in the output result

335
00:16:08,890 --> 00:16:09,920
for the two computations.

336
00:16:13,050 --> 00:16:15,005
Important thing to understand though, with aggregation,

337
00:16:15,005 --> 00:16:20,710
since you're trying to coalesce down, you know, multiple tuples within, you know, to to a single scalar value,

338
00:16:21,360 --> 00:16:25,490
you can't reference anything in the SELECT output,

339
00:16:25,690 --> 00:16:28,310
that isn't, that isn't part of the aggregate.

340
00:16:28,930 --> 00:16:30,060
So I can't do something like this,

341
00:16:30,060 --> 00:16:31,910
I can't go SELECT the average gpa,

342
00:16:32,860 --> 00:16:34,880
after you join the student table, the enrolled table,

343
00:16:35,230 --> 00:16:41,730
and then also spit out the the course id of the enrolled table, right,

344
00:16:42,480 --> 00:16:45,980
because this is not defined, this doesn't make any sense, right,

345
00:16:46,210 --> 00:16:47,090
there, there isn't,

346
00:16:47,830 --> 00:16:49,400
you, you're taking multiple rows,

347
00:16:49,420 --> 00:16:53,330
you you're condensing it down, closing it down, collapsing down for the average,

348
00:16:53,800 --> 00:16:57,000
what is the course id in this context, right,

349
00:16:57,050 --> 00:16:57,600
it's nothing.

350
00:16:58,830 --> 00:17:00,320
So, if you, in this case here,

351
00:17:00,320 --> 00:17:02,000
you sort of look at this,

352
00:17:02,000 --> 00:17:03,040
what you're really trying to do is,

353
00:17:03,120 --> 00:17:06,040
you're trying to get for each course id, get the average gpa,

354
00:17:07,890 --> 00:17:10,390
so what you need to do is, what to call a GROUP BY clause,

355
00:17:11,240 --> 00:17:15,230
where you're going to project tuples into buckets,

356
00:17:15,230 --> 00:17:18,070
based on whatever the parameters are in the GROUP BY clause,

357
00:17:18,820 --> 00:17:21,900
and then compute the aggregate on each individual bucket.

358
00:17:23,030 --> 00:17:23,980
So you sort of think it like this,

359
00:17:23,980 --> 00:17:28,320
if I first do the the JOIN between the enrolled table and the student table,

360
00:17:28,730 --> 00:17:31,950
I have all the, I have all possible combinations based on the JOIN

361
00:17:32,510 --> 00:17:35,470
and then now I'm going to split them up based on the the course id,

362
00:17:35,470 --> 00:17:38,640
because that's what I have in my, in my GROUP BY clause,

363
00:17:39,370 --> 00:17:44,600
and then now I compute the average for the gpa, for each, for each of those buckets.

364
00:17:46,730 --> 00:17:47,250
Makes sense?

365
00:17:50,660 --> 00:17:51,750
And just matches up like this.

366
00:17:53,510 --> 00:17:54,970
So again, the main takeaway this again,

367
00:17:54,970 --> 00:17:56,790
you have to have anything that's in a,

368
00:17:58,690 --> 00:18:02,660
anything that's not part of an aggregation, has to appear in the GROUP BY clause.

369
00:18:02,920 --> 00:18:03,990
So again, in this case here,

370
00:18:03,990 --> 00:18:05,150
I don't have the student name,

371
00:18:05,380 --> 00:18:07,100
I I can't, I can't put that there,

372
00:18:07,180 --> 00:18:09,080
I'd have to put it in in the GROUP BY clause.

373
00:18:10,530 --> 00:18:11,615
We can open the terminal if you want,

374
00:18:11,615 --> 00:18:13,870
MySQL used to let you do this in some cases,

375
00:18:16,460 --> 00:18:18,120
but we can actually try and see what happens.

376
00:18:20,750 --> 00:18:23,610
I hate typing on my, my Surface,

377
00:18:23,610 --> 00:18:25,160
I'm going to use this laptop here,

378
00:18:25,880 --> 00:18:26,680
I'll log into it.

379
00:18:33,870 --> 00:18:37,160
All right, so we want to do Postgres,

380
00:18:37,160 --> 00:18:38,440
I have a bunch of database systems running,

381
00:18:38,880 --> 00:18:40,660
so the query we were trying to do was,

382
00:18:45,730 --> 00:18:48,825
[essentially] this, right,

383
00:18:48,825 --> 00:18:53,700
select average gpa course id from enrolled joining enrolled table and student table, right.

384
00:18:53,840 --> 00:18:55,270
So Postgres doesn't let you do this,

385
00:18:55,270 --> 00:18:58,410
because it says the course id has to appear in the GROUP BY clause,

386
00:18:58,550 --> 00:19:00,270
that's good, that's what we expect.

387
00:19:01,085 --> 00:19:01,930
Let's go over to MySQL,

388
00:19:03,570 --> 00:19:04,780
MySQL doesn't let you do it,

389
00:19:06,120 --> 00:19:09,220
but let me see if I put it in the right mode by default,

390
00:19:11,670 --> 00:19:12,680
right, doesn't let you do it,

391
00:19:12,680 --> 00:19:13,660
but there's a way to,

392
00:19:14,400 --> 00:19:19,455
it's enforcing, it's enforcing the what mode it's in,

393
00:19:19,455 --> 00:19:20,450
if I go to traditional,

394
00:19:22,670 --> 00:19:23,910
then now run the same query,

395
00:19:24,560 --> 00:19:25,470
it lets me do it,

396
00:19:26,250 --> 00:19:28,750
and it spits out course id 15-445,

397
00:19:29,360 --> 00:19:30,100
is that correct?

398
00:19:32,410 --> 00:19:33,705
No, right, because what does that mean,

399
00:19:33,705 --> 00:19:35,180
it's the average gpa for all courses,

400
00:19:35,530 --> 00:19:36,920
but that's spitting out one of them,

401
00:19:37,300 --> 00:19:38,240
so that's bad.

402
00:19:39,400 --> 00:19:41,000
So let's go now, take the same query

403
00:19:41,560 --> 00:19:45,810
and we'll go over to, to SQLite.

404
00:19:48,250 --> 00:19:49,160
Who thinks it's going to work,

405
00:19:50,010 --> 00:19:50,980
raise your hand if you say yes,

406
00:19:51,860 --> 00:19:54,090
and the work meaning it'll actually run the query,

407
00:19:54,170 --> 00:19:55,350
I'm not saying the result correct,

408
00:19:56,290 --> 00:19:56,810
who thinks?

409
00:19:57,580 --> 00:19:58,860
We have one yes, two yesesf.

410
00:19:58,860 --> 00:19:59,480
Who says no?

411
00:20:01,120 --> 00:20:01,910
Most people say no.

412
00:20:03,370 --> 00:20:05,510
It did it, right,

413
00:20:06,160 --> 00:20:07,910
and it also spit out 15-445,

414
00:20:08,020 --> 00:20:09,440
is that the same value as my sql?

415
00:20:10,290 --> 00:20:14,530
Yeah, gpa looks, sorry, gpa looks the same,

416
00:20:16,120 --> 00:20:17,610
All right, let's go to Oracle,

417
00:20:20,210 --> 00:20:21,210
Oracle doesn't like it.

418
00:20:21,655 --> 00:20:22,440
Let's go to DuckDB,

419
00:20:25,350 --> 00:20:26,080
DuckDB didn't like it.

420
00:20:26,220 --> 00:20:27,580
So MySQL, you can do it,

421
00:20:27,690 --> 00:20:29,260
if if you, if you make it be,

422
00:20:29,280 --> 00:20:30,940
more like MySQL 5.7 and 8,

423
00:20:31,080 --> 00:20:32,110
but SQLite will do it.

424
00:20:32,760 --> 00:20:35,550
So again, this is the first example,

425
00:20:35,550 --> 00:20:36,350
we'll see it many times,

426
00:20:37,390 --> 00:20:39,020
SQL standard says one thing,

427
00:20:39,280 --> 00:20:41,210
but the different systems are doing different things.

428
00:20:45,170 --> 00:20:46,200
Next thing you do is have,

429
00:20:46,370 --> 00:20:47,460
you can have a HAVING clause,

430
00:20:47,780 --> 00:20:52,500
say, if you want to start filtering on on these aggregation, the aggregate columns you're generating,

431
00:20:53,660 --> 00:20:56,190
you can add a HAVING clause to specify

432
00:20:57,230 --> 00:20:59,250
whether, how many, what people should match,

433
00:21:00,200 --> 00:21:02,300
after you complete the aggregation, right,

434
00:21:02,300 --> 00:21:03,580
so say I want to get only,

435
00:21:04,920 --> 00:21:10,080
show me only the students that have an average gpa that's greater than 3.9,

436
00:21:10,460 --> 00:21:11,470
so in this case here,

437
00:21:11,470 --> 00:21:16,140
I'm computing the aggregation SELECT average gpa as avg_gpa

438
00:21:16,220 --> 00:21:19,500
and I'm trying to reference it here inside of my WHERE clause, right,

439
00:21:19,730 --> 00:21:20,680
I can't do that,

440
00:21:20,680 --> 00:21:24,060
because at this point, when the system is actually calculating the query,

441
00:21:24,820 --> 00:21:26,610
it's computing aggregation as it goes along,

442
00:21:26,900 --> 00:21:29,310
it can't, doesn't know what the final result is,

443
00:21:30,790 --> 00:21:33,230
so the easy fix of this is to have a HAVING clause,

444
00:21:34,040 --> 00:21:35,230
which is basically telling the system,

445
00:21:35,790 --> 00:21:40,260
okay, formative aggregation is produce the output that's defined in the SELECT statement,

446
00:21:40,760 --> 00:21:44,040
and then apply this additional filter for HAVING.

447
00:21:46,310 --> 00:21:48,210
This is actually not correct either, In some cases,

448
00:21:48,320 --> 00:21:50,830
I don't think the SQL standard lets you do this either, right,

449
00:21:50,830 --> 00:21:53,580
because even though I have an alias up here for average gpa,

450
00:21:54,490 --> 00:21:57,590
the data system can say, I don't know what this is,

451
00:21:58,630 --> 00:22:01,920
MySQL that you do it, Postgres does not,

452
00:22:01,920 --> 00:22:06,560
so instead you have to basically write the the aggregation clause again,

453
00:22:07,240 --> 00:22:09,830
and again, the database should be smart enough to recognize that,

454
00:22:10,000 --> 00:22:12,980
this average on the gpa is the same as that avg_gpa up there,

455
00:22:13,060 --> 00:22:17,690
and therefore compute the same computation, don't perform, perform the same computation twice.

456
00:22:20,030 --> 00:22:21,265
So essentially just doing this again,

457
00:22:21,265 --> 00:22:24,780
compute the aggregation and then do the additional filtering to throw out things you don't.

458
00:22:26,510 --> 00:22:27,030
Makes sense?

459
00:22:29,550 --> 00:22:34,085
All right, strings and timestamps or dates

460
00:22:34,085 --> 00:22:36,665
of when things get really get really weird,

461
00:22:36,665 --> 00:22:39,730
not weird, but like, really inconsistent.

462
00:22:40,470 --> 00:22:43,750
So for string function, string operations or sorry, string data types,

463
00:22:44,190 --> 00:22:46,775
the SQL standard specifies that,

464
00:22:46,775 --> 00:22:49,690
the, the case of the strings within the values,

465
00:22:49,770 --> 00:22:51,245
that I don't mean the strings and the select statements,

466
00:22:51,245 --> 00:22:52,810
I mean the actual data you're storing,

467
00:22:53,460 --> 00:22:54,680
that they should be case sensitive

468
00:22:55,240 --> 00:22:59,570
and that when you want to have in your SQL statement constant strings,

469
00:22:59,980 --> 00:23:01,370
you want to use single quotes,

470
00:23:02,260 --> 00:23:05,210
Postgres, SQL Server and Oracle follow the standard,

471
00:23:05,620 --> 00:23:10,470
MySQL is, by default, case insensitive

472
00:23:11,600 --> 00:23:14,520
and then they both SQLite and and MySQL support

473
00:23:14,660 --> 00:23:20,160
both single and double quotation marks to represent constants and strings.

474
00:23:21,325 --> 00:23:22,200
So let's do what MySQL does

475
00:23:22,370 --> 00:23:23,430
and see how weird this is.

476
00:23:25,100 --> 00:23:30,670
So let's go back here, right,

477
00:23:30,670 --> 00:23:36,210
so you can represent a constant like this, right,

478
00:23:36,210 --> 00:23:40,100
so you can have a SELECT statement without a FROM clause in MySQL

479
00:23:40,690 --> 00:23:41,420
and I can represent,

480
00:23:42,190 --> 00:23:43,880
it basically takes whatever the input is

481
00:23:43,990 --> 00:23:45,450
and I can, it'll spit it out,

482
00:23:45,450 --> 00:23:46,280
so I put a comma,

483
00:23:46,630 --> 00:23:51,700
like I can do like 1, 2, 3, like that,

484
00:23:51,960 --> 00:23:54,490
it'll make columns for all the things in the output.

485
00:23:55,100 --> 00:23:56,305
So for strings,

486
00:23:56,305 --> 00:24:01,690
I can have it as double quotes and single quotes

487
00:24:03,060 --> 00:24:09,110
in the case of Postgres, it won't let me do double quotes, right,

488
00:24:09,760 --> 00:24:10,330
can't do that,

489
00:24:10,330 --> 00:24:12,130
because it's trying to look for a column name tupac,

490
00:24:12,130 --> 00:24:14,400
that's the way you sort of escape column names,

491
00:24:14,750 --> 00:24:18,570
but it'll, it'll support single quotes.

492
00:24:19,550 --> 00:24:22,020
So in SQLite, they support both,

493
00:24:24,070 --> 00:24:25,460
so that can go tupac like this,

494
00:24:26,820 --> 00:24:28,960
and I can go with single quotes like that.

495
00:24:29,900 --> 00:24:34,820
In Oracle, it's single quotes,

496
00:24:36,780 --> 00:24:38,830
but it isn't like queries without a FROM clause,

497
00:24:40,690 --> 00:24:44,150
so in Oracle, they have this weird thing called the DUAL, the DUAL table,

498
00:24:44,530 --> 00:24:47,940
and this is a fake table that comes with Oracle,

499
00:24:48,230 --> 00:24:53,310
allow you to write these kind of queries against tables that don't actually exist, right,

500
00:24:53,310 --> 00:24:54,350
so then I can get that,

501
00:24:55,180 --> 00:24:57,470
if you try to do like, SELECT star from DUAL,

502
00:25:01,710 --> 00:25:02,860
you just get like an X,

503
00:25:04,870 --> 00:25:05,730
I think the newer version,

504
00:25:05,730 --> 00:25:07,065
they got rid of the DUAL, you don't need anymore,

505
00:25:07,065 --> 00:25:08,985
this is, this is Oracle 21,

506
00:25:08,985 --> 00:25:11,090
so it's a rather newer version, right,

507
00:25:12,850 --> 00:25:16,285
so like you can't do, you can't do this,

508
00:25:16,285 --> 00:25:18,630
but like in Postgres or any other database system,

509
00:25:18,950 --> 00:25:20,880
you can treat SQL as like a calculator,

510
00:25:21,050 --> 00:25:23,010
you can put whatever you want in clause like that.

511
00:25:24,350 --> 00:25:26,040
So, all right, let's go back to MySQL,

512
00:25:27,530 --> 00:25:29,010
and let's look at some string functions.

513
00:25:30,030 --> 00:25:33,920
So, I can call now,

514
00:25:36,870 --> 00:25:39,700
I can do SELECT star FROM student WHERE name equals TuPaC,

515
00:25:39,720 --> 00:25:41,320
with weird casing

516
00:25:41,610 --> 00:25:45,925
and then it matched on the string Tupac, right,

517
00:25:45,925 --> 00:25:50,280
because internally MySQL is treating the varchars as case insensitive.

518
00:25:51,510 --> 00:25:52,840
So if you want to now,

519
00:25:56,110 --> 00:26:00,045
if you want to treat it like, you know, like any other database system,

520
00:26:00,045 --> 00:26:02,570
where it actually is actually looking at the case as a TuPaC,

521
00:26:02,860 --> 00:26:07,970
you can add this BINARY flag in front of the, or keyword in front of the column name,

522
00:26:08,200 --> 00:26:10,890
and that'll treat it as a binary string,

523
00:26:10,890 --> 00:26:11,780
like any other system,

524
00:26:12,610 --> 00:26:13,995
in this case here, now it doesn't match,

525
00:26:13,995 --> 00:26:15,620
but now it tells me I have a warning.

526
00:26:16,460 --> 00:26:18,430
So now I've got to go now call show warnings,

527
00:26:18,540 --> 00:26:20,230
and this is MySQL specific,

528
00:26:20,820 --> 00:26:21,940
so now they tell me that,

529
00:26:22,350 --> 00:26:25,480
the binary expression is deprecated and be removed,

530
00:26:26,040 --> 00:26:28,240
and they tell me at least how to write it correctly,

531
00:26:29,350 --> 00:26:33,590
so now I have to CAST the name AS a BINARY

532
00:26:33,790 --> 00:26:34,820
and then I can call it.

533
00:26:35,500 --> 00:26:36,860
So if I change the casing again,

534
00:26:37,420 --> 00:26:38,270
then I get Tupac.

535
00:26:39,660 --> 00:26:40,820
So this burns a lot of people,

536
00:26:40,820 --> 00:26:42,400
because they up, you end up like thinking,

537
00:26:42,420 --> 00:26:46,900
oh, if you don't know that your varchar is case insensitive,

538
00:26:47,070 --> 00:26:48,670
you could store things multiple times,

539
00:26:51,300 --> 00:26:52,815
you know, thinking that it's going to be different,

540
00:26:52,815 --> 00:26:53,600
because the case is different,

541
00:26:53,920 --> 00:26:55,610
but MySQL says they're the same.

542
00:26:56,580 --> 00:26:57,800
Again, this is only MySQL,

543
00:26:57,800 --> 00:26:59,800
I don't know any other data that actually does this,

544
00:27:00,330 --> 00:27:01,360
so that's a weird one.

545
00:27:11,240 --> 00:27:13,830
The question is, why is the name capitalized?

546
00:27:22,280 --> 00:27:23,280
So his question is,

547
00:27:25,280 --> 00:27:26,190
I'm telling you,

548
00:27:26,270 --> 00:27:29,130
so there's the data being stored with the case sensitivity,

549
00:27:29,660 --> 00:27:34,140
the comparison operator, when it actually executes the WHERE clause is ignoring case,

550
00:27:36,130 --> 00:27:39,630
so it's not calling whatever string compare that you have in libc,

551
00:27:40,550 --> 00:27:42,565
it's calling either their own version of it

552
00:27:42,565 --> 00:27:44,430
or the case insensitive version of it,

553
00:27:45,610 --> 00:27:48,080
because that was some decision that somebody made in the 1990s,

554
00:27:48,310 --> 00:27:49,760
that has carried over today.

555
00:27:51,090 --> 00:27:51,490
Yes.

556
00:27:53,170 --> 00:27:54,110
Why do they make that decision?

557
00:27:55,460 --> 00:27:58,650
Ask me that question at the very end,

558
00:27:58,790 --> 00:28:01,180
get through all the again,

559
00:28:01,180 --> 00:28:03,505
it's probably because somebody just did it the one way,

560
00:28:03,505 --> 00:28:05,100
you know, decided how to do it,

561
00:28:05,480 --> 00:28:10,470
or MySQL, the guy was actually in many cases trying to follow what Oracle did in some cases,

562
00:28:10,670 --> 00:28:11,730
but Oracle doesn't do this,

563
00:28:12,140 --> 00:28:14,465
I have no idea, right,

564
00:28:14,465 --> 00:28:17,140
we can email the guy he still alive.

565
00:28:21,140 --> 00:28:25,060
So yeah, I think there's a lot of times where people just did stuff,

566
00:28:25,060 --> 00:28:28,380
because, like one person did it without really thinking through the, the implications of it,

567
00:28:29,780 --> 00:28:31,360
or they're trying to copy some other system,

568
00:28:31,360 --> 00:28:34,500
where they like out some other particular feature of functionality.

569
00:28:39,330 --> 00:28:39,850
Other questions?

570
00:28:42,340 --> 00:28:46,160
We'll see many examples are why would anyone ever do this, do it this way.

571
00:28:47,400 --> 00:28:49,400
All right, so I think I showed a query like this before,

572
00:28:49,420 --> 00:28:50,420
just make sure you see it.

573
00:28:50,500 --> 00:28:54,200
So there's this LIKE operation in in SQL

574
00:28:54,280 --> 00:28:58,100
and you use this for really primitive string matching or and pattern matching,

575
00:28:58,750 --> 00:29:02,000
so you would use a, you call LIKE and then you would say,

576
00:29:02,900 --> 00:29:05,690
you would have a percent sign to represent a wild card,

577
00:29:05,690 --> 00:29:07,720
so instead, if you're coming from the Unix world,

578
00:29:07,740 --> 00:29:11,530
star regular expression usually means match anything or dot,

579
00:29:12,410 --> 00:29:14,850
in SQL, it's the percent sign,

580
00:29:15,080 --> 00:29:18,810
and that'll match it any sub string, including empty strings,

581
00:29:18,980 --> 00:29:22,260
but if you want to match one character, you would use the underscore,

582
00:29:22,740 --> 00:29:24,770
and there is support for regular expressions,

583
00:29:24,770 --> 00:29:27,320
I forget whether that is in the SQL standard,

584
00:29:27,320 --> 00:29:28,870
but everyone does it slightly different,

585
00:29:29,820 --> 00:29:34,210
you can write more complex string matching, string matching patterns.

586
00:29:36,040 --> 00:29:38,120
There's a bunch of string functions that also come in the SQL standard

587
00:29:38,290 --> 00:29:39,770
to do things you could expect,

588
00:29:39,790 --> 00:29:40,800
if you're familiar with Python,

589
00:29:40,800 --> 00:29:41,900
there's all the python functions,

590
00:29:43,270 --> 00:29:46,340
upper case, lower case, sub strings, replacing strings,

591
00:29:46,840 --> 00:29:48,410
all that, all that's in the SQL standard

592
00:29:48,760 --> 00:29:49,935
and for the most part,

593
00:29:49,935 --> 00:29:54,210
these are going to be pretty consistent across the the various systems.

594
00:29:55,750 --> 00:29:57,890
Where things go wrong is,

595
00:29:57,940 --> 00:30:00,740
which we think would be the most simple operation, concatenating two strings,

596
00:30:01,120 --> 00:30:03,080
that's where everyone likes to do something slightly different.

597
00:30:03,880 --> 00:30:05,080
So the SQL standard says,

598
00:30:05,080 --> 00:30:09,120
the the double bar is the way you can concat strings,

599
00:30:10,640 --> 00:30:14,340
in in SQL Server, they, they use the plus sign,

600
00:30:15,790 --> 00:30:21,060
and then in MySQL, they don't have under the default mode,

601
00:30:21,060 --> 00:30:23,570
they don't have the double bar, they don't support the plus sign,

602
00:30:23,740 --> 00:30:28,165
you have to use the CONCAT function, right,

603
00:30:28,165 --> 00:30:29,130
and we can see that real quickly.

604
00:30:30,430 --> 00:30:32,790
So, going back to MySQL,

605
00:30:38,070 --> 00:30:43,520
so, want to do something like this, right,

606
00:30:44,780 --> 00:30:45,600
I get another warning,

607
00:30:45,710 --> 00:30:46,560
I show warnings,

608
00:30:50,750 --> 00:30:52,800
and it tells me it doesn't like my syntax, right,

609
00:30:54,960 --> 00:30:56,200
that was the first one, sorry,

610
00:30:56,940 --> 00:30:59,060
boom, I get two warnings,

611
00:30:59,320 --> 00:31:04,040
says the double bar is synonym for the OR, and therefore it's to be deprecated,

612
00:31:05,580 --> 00:31:06,510
and they didn't like the way,

613
00:31:06,510 --> 00:31:11,840
I was sending along the @cs,

614
00:31:12,370 --> 00:31:14,420
so we now try to call,

615
00:31:14,500 --> 00:31:16,880
we change the sql_mode in MySQL,

616
00:31:17,580 --> 00:31:19,460
to follow the sql standard,

617
00:31:19,780 --> 00:31:22,970
now I can, I can get the concatenation that I want.

618
00:31:26,110 --> 00:31:27,800
So again, it's concatenation,

619
00:31:27,820 --> 00:31:31,065
it would be super, everyone should do the same thing,

620
00:31:31,065 --> 00:31:33,405
but again, in case of MySQL,

621
00:31:33,405 --> 00:31:34,980
is some legacy thing from the 90s,

622
00:31:34,980 --> 00:31:36,710
that they're trying to slowly undo.

623
00:31:39,150 --> 00:31:42,920
All right, date and time is probably the worst one.

624
00:31:43,660 --> 00:31:45,955
So the SQL standard defines a bunch of ways

625
00:31:45,955 --> 00:31:52,020
to define date types, time types, also timestamps,

626
00:31:52,600 --> 00:31:55,830
different calendar types, Julian calendar, Gregorian calendar,

627
00:31:56,450 --> 00:32:01,680
but how, again, how the syntax is going to vary, is going to be pretty annoying.

628
00:32:02,220 --> 00:32:03,260
So I want to give it now a demo,

629
00:32:03,310 --> 00:32:08,480
where try to do what would seem like a simple calculation, a simple computation,

630
00:32:08,890 --> 00:32:10,520
we just want to count the number days,

631
00:32:11,550 --> 00:32:14,020
since from today to the beginning of the year,

632
00:32:14,740 --> 00:32:17,120
it's like 230 something, 240 something,

633
00:32:17,260 --> 00:32:19,610
just the number, the total number of calendar days.

634
00:32:20,390 --> 00:32:22,260
So we're going to do this first in Postgres

635
00:32:22,640 --> 00:32:25,980
and then we'll do this in, in MySQL

636
00:32:26,000 --> 00:32:27,630
and do this in, in SQL Server.

637
00:32:28,420 --> 00:32:29,805
So the first thing we need to do is figure out

638
00:32:29,805 --> 00:32:34,080
how to get the current, date, the current time, right.

639
00:32:34,670 --> 00:32:38,520
Well, there's in Postgres, there's a function called NOW,

640
00:32:39,260 --> 00:32:44,690
and that will give you, you get back a timestamp with the current date,

641
00:32:45,410 --> 00:32:51,130
in, in MySQL, you can do the same thing,

642
00:32:51,920 --> 00:32:55,890
in SQLite, they don't have a NOW function,

643
00:32:56,840 --> 00:33:01,015
in DuckDB, DuckDB is going to follow pretty much Postgres for a lot of things,

644
00:33:01,015 --> 00:33:04,320
because it's they use the same same SQL grammar,

645
00:33:04,900 --> 00:33:05,840
so they have a NOW function,

646
00:33:07,000 --> 00:33:07,970
I go to Oracle,

647
00:33:09,970 --> 00:33:11,300
Oracle does not have a NOW function.

648
00:33:12,200 --> 00:33:14,350
All right, so there's another way you can get the timestamp,

649
00:33:14,350 --> 00:33:15,390
so in the sql standard,

650
00:33:15,740 --> 00:33:21,060
there's something called, a function called CURRENT_TIMESTAMP, right,

651
00:33:21,320 --> 00:33:23,930
except it's not a function, it's a keyword,

652
00:33:25,620 --> 00:33:30,790
and then in MySQL, they have the function, they have the keyword,

653
00:33:32,300 --> 00:33:39,060
in SQLite, they don't have the function, they have the keyword,

654
00:33:39,840 --> 00:33:43,290
and on Oracle, doesn't,

655
00:33:43,880 --> 00:33:45,725
gives us a weird error about that one,

656
00:33:45,725 --> 00:33:46,510
we'll come back to that in a second

657
00:33:47,010 --> 00:33:48,605
and they don't have the keyword,

658
00:33:48,605 --> 00:33:50,800
so they have the function, but we're getting this other weird error,

659
00:33:51,090 --> 00:33:53,530
datetime interval precision out of range.

660
00:33:54,250 --> 00:33:55,070
Okay, so what's that,

661
00:33:56,650 --> 00:33:58,490
So now we got to go back, maybe,

662
00:33:59,470 --> 00:34:01,400
oh, because it's, it's, it's Oracle,

663
00:34:01,570 --> 00:34:05,150
It doesn't like having a SELECT clause without, a SELECT statement without a FROM clause,

664
00:34:05,530 --> 00:34:07,190
so let's add our fake table DUAL,

665
00:34:08,680 --> 00:34:10,160
then, we get it right,

666
00:34:10,270 --> 00:34:14,180
but it's the keyword, and not the timestamp, right.

667
00:34:15,030 --> 00:34:20,050
All right, so now, so at least now we can get the current time of the current day,

668
00:34:21,560 --> 00:34:22,625
and so what we can do is now,

669
00:34:22,625 --> 00:34:27,040
there we can start casting strings or varchars into date types,

670
00:34:27,450 --> 00:34:29,555
and then there's this EXTRACT function in the SQL standard,

671
00:34:29,555 --> 00:34:33,160
that allows us to extract some part of of that data timestamp,

672
00:34:33,300 --> 00:34:34,660
so this is saying extract the day from

673
00:34:35,700 --> 00:34:40,960
and then today's date as a string casted into a date type.

674
00:34:41,570 --> 00:34:45,695
All right, and again, there's syntactic sugar for all these different systems,

675
00:34:45,695 --> 00:34:46,930
that that are like non standard.

676
00:34:47,310 --> 00:34:48,700
So in Postgres,

677
00:34:48,960 --> 00:34:51,245
if I try to give the string, it's going to throw an error,

678
00:34:51,245 --> 00:34:52,175
because it says it can't,

679
00:34:52,175 --> 00:34:54,530
I need to operate, the extract function need to operate on a date,

680
00:34:54,530 --> 00:34:55,780
but you're giving me a varchar,

681
00:34:56,190 --> 00:34:58,270
but I can add these the two colons at the end

682
00:34:58,740 --> 00:35:00,010
and then put date at the end,

683
00:35:00,600 --> 00:35:04,460
and then that's going to cast it to a DATE type.

684
00:35:05,320 --> 00:35:06,270
Can you see that or no, sorry,

685
00:35:14,060 --> 00:35:15,370
let me do this, yeah,

686
00:35:18,090 --> 00:35:19,540
I know it's wrong, sorry, let's try it again.

687
00:35:22,690 --> 00:35:26,770
All right, so here, I can give it a string

688
00:35:26,880 --> 00:35:28,535
and then I put ::date

689
00:35:28,535 --> 00:35:30,790
and that converts it to a date,

690
00:35:31,170 --> 00:35:34,880
but that's only in, in Postgres,

691
00:35:35,940 --> 00:35:39,335
I can't do this in any other system, except for DuckDB,

692
00:35:39,335 --> 00:35:41,465
because they follow the same standard, right.

693
00:35:41,465 --> 00:35:43,855
So if I go to MySQL,

694
00:35:43,855 --> 00:35:44,670
try to do the same thing,

695
00:35:45,200 --> 00:35:45,960
doesn't like that.

696
00:35:46,400 --> 00:35:48,570
Go to SQLite, doesn't like that.

697
00:35:49,490 --> 00:35:51,570
Go to DuckDB, Oracle is not going like that,

698
00:35:51,920 --> 00:35:52,650
FROM DUAL,

699
00:35:55,030 --> 00:35:56,000
doesn't know what a DATE is.

700
00:35:56,230 --> 00:35:59,120
And this DuckDB should do it,

701
00:35:59,680 --> 00:36:01,640
because DuckDB follows the same grammar.

702
00:36:02,320 --> 00:36:08,630
So we can use EXTRACT function to maybe extract what the, the current date is,

703
00:36:08,630 --> 00:36:12,640
or try to figure out how many days since from now until beginning of the year.

704
00:36:13,020 --> 00:36:14,080
So let's start with postgres,

705
00:36:15,690 --> 00:36:18,580
so it turns out, it's pretty simple with Postgres,

706
00:36:19,790 --> 00:36:27,350
so we can just cast the string of today's current date to a DATE type

707
00:36:27,970 --> 00:36:34,900
and then subtract it from the string of the current, the beginning of the year

708
00:36:35,070 --> 00:36:38,270
and we could use, we wanted to, we could go back here

709
00:36:38,270 --> 00:36:40,870
and use CURRENT_TIMESTAMP or maybe use the NOW function,

710
00:36:42,060 --> 00:36:44,040
and this should work, right.

711
00:36:44,680 --> 00:36:48,660
So that gets today, cast it as a date, subtracting,

712
00:36:49,940 --> 00:36:53,040
taking the today's date and subtracting by the beginning of the year.

713
00:36:53,090 --> 00:36:55,680
And we get 241, which I assume is correct.

714
00:36:58,490 --> 00:37:03,510
So let's try the same thing now in, in MySQL,

715
00:37:04,500 --> 00:37:06,605
so again, since they don't have the NOW function,

716
00:37:06,605 --> 00:37:08,350
we'll do it for casting,

717
00:37:09,330 --> 00:37:11,290
so now we get a weird number, we get 729,

718
00:37:13,660 --> 00:37:13,950
what's that,

719
00:37:16,100 --> 00:37:16,960
and surprisingly, actually,

720
00:37:16,960 --> 00:37:19,350
somebody on Youtube in a comment of [] places,

721
00:37:20,240 --> 00:37:21,000
told me what it was,

722
00:37:22,430 --> 00:37:23,140
and this is weird,

723
00:37:23,140 --> 00:37:28,530
so the first number is today's current month subtracted by January,

724
00:37:28,910 --> 00:37:31,500
so 8 minus 1 is 7,

725
00:37:32,500 --> 00:37:35,450
then it's, today's what the 30th,

726
00:37:36,160 --> 00:37:40,400
so today's day subtracted by January first,

727
00:37:40,690 --> 00:37:41,535
so that's 29,

728
00:37:41,535 --> 00:37:42,740
you get 729,

729
00:37:45,100 --> 00:37:46,370
that's wrong, I can't do that.

730
00:37:48,330 --> 00:37:49,540
So what we can do instead is,

731
00:37:49,800 --> 00:37:54,870
we can, we can, sorry,

732
00:37:56,500 --> 00:37:57,290
we can get the,

733
00:38:04,850 --> 00:38:05,340
there we,

734
00:38:06,200 --> 00:38:07,915
so what we're doing here now is,

735
00:38:07,915 --> 00:38:12,810
we're getting the date of today and the beginning of the year,

736
00:38:13,190 --> 00:38:14,640
converting it to a UNIX_TIMESTAMP,

737
00:38:15,410 --> 00:38:21,240
UNIX_TIMESTAMP is the number of seconds since the UNIX epochs, like January first 1970,

738
00:38:22,610 --> 00:38:27,620
so we're converting it now to the number of seconds from today since 1970

739
00:38:28,150 --> 00:38:31,670
and then we subtract that from the number since January first

740
00:38:32,200 --> 00:38:36,650
and we divide that by 60 seconds times 60 minutes times 24 hours,

741
00:38:38,200 --> 00:38:39,060
and we get 241.

742
00:38:40,550 --> 00:38:42,660
So this, this is my original idea

743
00:38:43,160 --> 00:38:48,870
and then turns out there's a DATEDIFF function in MySQL,

744
00:38:48,920 --> 00:38:49,620
you can do this,

745
00:38:51,420 --> 00:38:52,790
but Postgres doesn't have it,

746
00:38:53,950 --> 00:38:54,975
DuckDB doesn't have it,

747
00:38:54,975 --> 00:39:00,830
see if Oracle has it, DUAL, right,

748
00:39:00,910 --> 00:39:01,640
they don't have it.

749
00:39:03,190 --> 00:39:04,850
All right, so that's a MySQL, that's a MySQL thing.

750
00:39:05,550 --> 00:39:08,410
All right, so now let's try in SQLite,

751
00:39:08,970 --> 00:39:10,420
so SQLite doesn't have DATEDIFF,

752
00:39:11,310 --> 00:39:13,870
we can't do that, that subtraction that we did in Postgres,

753
00:39:15,660 --> 00:39:18,050
the best solution I could come up with is

754
00:39:18,370 --> 00:39:23,450
the convert the timestamp for today and begin a year to the Julian calendar,

755
00:39:23,980 --> 00:39:26,780
which is the number of days since Julian Caesar's birthday,

756
00:39:26,950 --> 00:39:28,070
in whatever BC,

757
00:39:29,530 --> 00:39:33,680
you laugh, but a lot of the banks ran off that in the in the up until the 80s, right,

758
00:39:34,960 --> 00:39:36,440
and then you get 241,

759
00:39:36,850 --> 00:39:40,960
but we're getting it as a, as a floating point number,

760
00:39:41,310 --> 00:39:44,020
so we can cast it as an integer and then we get 241.

761
00:39:45,380 --> 00:39:48,340
I, I forget how to do this in Oracle,

762
00:39:48,340 --> 00:39:49,200
I'm not going to do in Oracle.

763
00:39:51,320 --> 00:39:53,910
The main point again is, seems like be a simple thing,

764
00:39:54,080 --> 00:39:57,810
but all these timestamp stuff is woefully different.

765
00:39:59,120 --> 00:40:00,240
Any questions about this so far?

766
00:40:06,970 --> 00:40:08,150
Why would you want a lower function?

767
00:40:14,230 --> 00:40:14,750
Good question.

768
00:40:15,860 --> 00:40:17,310
I mean, you might need it for data cleaning,

769
00:40:19,100 --> 00:40:20,460
you might want it for.

770
00:40:22,710 --> 00:40:23,500
Yeah, it's a good question,

771
00:40:23,610 --> 00:40:25,180
maintain the standard, right,

772
00:40:26,260 --> 00:40:26,960
it could be,

773
00:40:27,280 --> 00:40:28,035
it doesn't have to be,

774
00:40:28,035 --> 00:40:28,860
also in the WHERE clause,

775
00:40:28,860 --> 00:40:30,050
you can have it in the FROM clause.

776
00:40:30,670 --> 00:40:33,590
So if I go back to MySQL, right,

777
00:40:33,590 --> 00:40:41,340
so SELECT * FROM students WHERE name equals Tupac, right,

778
00:40:43,740 --> 00:40:45,400
student, right,

779
00:40:45,720 --> 00:40:50,260
so maybe I want to do this though, in my output,

780
00:40:50,880 --> 00:40:51,880
get a lowercase like that.

781
00:40:55,110 --> 00:40:55,900
Yes, sorry, yes.

782
00:41:10,300 --> 00:41:11,630
Yeah, so her question is,

783
00:41:12,580 --> 00:41:16,640
why do people have all these weird idioms in, in their, their SQL,

784
00:41:18,380 --> 00:41:21,085
when at a high level, they seem to be all sort doing the same thing,

785
00:41:21,085 --> 00:41:22,800
but it's these one-off things are different

786
00:41:22,850 --> 00:41:23,920
and that's related to his question,

787
00:41:23,920 --> 00:41:27,800
why, why are all these, why are all these different nuances for these different systems,

788
00:41:28,390 --> 00:41:31,130
because somebody was writing and thought it was cool, right,

789
00:41:31,600 --> 00:41:32,925
and then they showed their friends,

790
00:41:32,925 --> 00:41:33,740
like yeah, that's cool,

791
00:41:33,880 --> 00:41:35,385
So the double colon and Postgres,

792
00:41:35,385 --> 00:41:36,120
I agree, that's cool,

793
00:41:36,120 --> 00:41:39,360
that casting thing, but they only do it, right,

794
00:41:40,850 --> 00:41:42,570
the DUAL table, I don't know what.

795
00:41:47,720 --> 00:41:49,570
Yeah, so give another example,

796
00:41:49,570 --> 00:41:52,620
so there's a shortcut in SQL,

797
00:41:53,000 --> 00:41:54,210
to do basically SELECT *,

798
00:41:54,560 --> 00:42:00,180
so SELECT * FROM student, gives you all the tuples, right,

799
00:42:00,410 --> 00:42:02,890
But in postgres, which I think is also in the SQL standard,

800
00:42:02,890 --> 00:42:05,100
I can just write TABLE and get that right,

801
00:42:06,110 --> 00:42:11,470
in MySQL, I can do that, that's cool,

802
00:42:12,270 --> 00:42:16,560
SQLite,, doesn't like it,

803
00:42:17,220 --> 00:42:21,960
in DuckDB, they do it,

804
00:42:21,960 --> 00:42:22,970
but they also have another one,

805
00:42:23,200 --> 00:42:26,490
I think you just go, I think you just go FETCH,

806
00:42:26,750 --> 00:42:32,450
no, or is it FROM, right,

807
00:42:32,920 --> 00:42:33,770
you can just do that.

808
00:42:35,670 --> 00:42:37,355
So they all had their weird idioms,

809
00:42:37,355 --> 00:42:40,940
I mean, so some of these things were, are, are based on customer feedback,

810
00:42:40,940 --> 00:42:44,020
like the customer says, I want, you know, I need functions that operate on json,

811
00:42:44,040 --> 00:42:45,250
so somebody adds that,

812
00:42:45,690 --> 00:42:51,175
and a lot of times these features get added before they show up in the standard, right,

813
00:42:51,175 --> 00:42:53,430
so the json xml is a good example of this,

814
00:42:54,670 --> 00:42:56,640
that got out of the SQL standard 2006,

815
00:42:56,640 --> 00:42:57,920
but a lot of relational databases,

816
00:42:57,940 --> 00:43:00,980
at the time in the early 2000s had some support for xml.

817
00:43:01,740 --> 00:43:02,690
And so what happens is,

818
00:43:02,690 --> 00:43:06,230
like, the standards body is it's, it's a bunch of randos,

819
00:43:06,230 --> 00:43:07,510
it's the people at different companies,

820
00:43:07,950 --> 00:43:09,095
so in the SQL standards body,

821
00:43:09,095 --> 00:43:10,295
there's somebody from Oracle,

822
00:43:10,295 --> 00:43:11,735
there's somebody from Sybase,

823
00:43:11,735 --> 00:43:13,360
somebody from, you know, IBM,

824
00:43:14,210 --> 00:43:15,870
and they show up the standards committee,

825
00:43:16,100 --> 00:43:19,020
and they all try to get whatever they have, proprietary thing that they have,

826
00:43:19,070 --> 00:43:21,520
they try to get that into the standard, right,

827
00:43:21,960 --> 00:43:22,900
Oracle probably do this,

828
00:43:24,210 --> 00:43:25,220
the best example, more recently,

829
00:43:25,220 --> 00:43:29,770
the Oracle got their version of property graph queries in the SQL standard,

830
00:43:30,330 --> 00:43:33,010
they base theirs on cipher, which is in Neo4j,

831
00:43:33,210 --> 00:43:36,910
that's now the PGQ stuff in a SQL standard,

832
00:43:37,560 --> 00:43:42,100
so they got their extensions for graph queries in the SQL standard,

833
00:43:42,180 --> 00:43:44,170
because they were only ones ahead at the time.

834
00:43:44,280 --> 00:43:46,025
So that's how these things show up in the SQL standard,

835
00:43:46,025 --> 00:43:49,960
and so if everybody has competing ideas for how something should be done,

836
00:43:50,160 --> 00:43:52,715
you end up with the lowest common denominator or something could try to supports everyone,

837
00:43:52,715 --> 00:43:55,870
but then no one exactly supports the, supports the standard.

838
00:43:57,875 --> 00:43:59,200
I'm not saying it's a good thing, but like,

839
00:43:59,900 --> 00:44:01,955
it's we live in a different time also too,

840
00:44:01,955 --> 00:44:05,020
where there's so many different database companies

841
00:44:05,490 --> 00:44:09,280
and there's one, there isn't one company, I say that owns the market

842
00:44:09,300 --> 00:44:13,660
and and can bend people according to the will right.

843
00:44:13,740 --> 00:44:18,425
So, I said before in the 1980s, IBM was, was the huge company, right,

844
00:44:18,425 --> 00:44:20,260
IBM was the the computing company,

845
00:44:20,490 --> 00:44:23,890
so whatever IBM said, that was considered the de facto standard,

846
00:44:24,540 --> 00:44:27,350
and so that sort of how we ended up with SQL today.

847
00:44:28,130 --> 00:44:29,640
But there isn't a company like that now,

848
00:44:29,930 --> 00:44:35,370
like the closest thing would be Google put out their standard of SQL called ZetaSQL,

849
00:44:35,510 --> 00:44:36,520
internally it's called something else,

850
00:44:36,520 --> 00:44:41,970
but they open source a parser and, and, and the and the grammar file and and the spec

851
00:44:42,140 --> 00:44:43,920
for their version of SQL,

852
00:44:44,750 --> 00:44:45,720
nobody uses it

853
00:44:46,040 --> 00:44:47,190
and Google is huge, right,

854
00:44:48,090 --> 00:44:49,895
the closest you're going to get today is Postgres,

855
00:44:49,895 --> 00:44:50,990
a lot of these database companies,

856
00:44:50,990 --> 00:44:51,770
when you start out,

857
00:44:51,770 --> 00:44:53,830
instead of building the grammar file from scratch,

858
00:44:54,060 --> 00:44:55,400
you go take the Postgres one,

859
00:44:55,400 --> 00:44:57,520
hack it up and, and inject into your system,

860
00:44:57,750 --> 00:44:58,660
that's what we did,

861
00:44:59,250 --> 00:45:01,540
and DuckDB took our code and they put it DuckDB,

862
00:45:02,070 --> 00:45:05,020
like this bunch of systems are based on Postgres grammar,

863
00:45:05,040 --> 00:45:06,910
because because this open source and they use it,

864
00:45:06,930 --> 00:45:09,190
that's the closest you're going to get to a universal standard today.

865
00:45:09,620 --> 00:45:13,410
But again, I just showed you how there's FROM in DuckDB,

866
00:45:13,640 --> 00:45:17,550
but that's not in, in Postgres, right,

867
00:45:18,700 --> 00:45:19,410
they've adapted it.

868
00:45:22,190 --> 00:45:22,590
Yes.

869
00:45:27,580 --> 00:45:28,215
His question is,

870
00:45:28,215 --> 00:45:30,050
what's the point of having a standard, if no one's going to follow it?

871
00:45:31,860 --> 00:45:34,125
I mean, there's a speed limit, everyone drives over it, right,

872
00:45:34,125 --> 00:45:34,460
like,

873
00:45:39,180 --> 00:45:41,770
I showed you much of SELECT statements, like the,

874
00:45:42,780 --> 00:45:45,020
and that were slightly different from one system to the next,

875
00:45:45,280 --> 00:45:47,130
but you understood what it was doing,

876
00:45:47,130 --> 00:45:49,640
basically the nuances of different systems,

877
00:45:49,810 --> 00:45:52,700
yeah, you may have to go read the documentation or ask ChatGPT what to do,

878
00:45:52,930 --> 00:45:57,300
but like at a high level, the the concepts are the same, right,

879
00:46:00,370 --> 00:46:04,310
just you know the specifics, Each system is going to be different.

880
00:46:06,550 --> 00:46:07,665
Snowflake is a good outlier,

881
00:46:07,665 --> 00:46:09,900
actually Snowflake started from scratch in 2013,

882
00:46:09,900 --> 00:46:10,500
they didn't take Postgres,

883
00:46:10,500 --> 00:46:14,120
they said they just came up with their own grammar their Snowflake grammar,

884
00:46:14,140 --> 00:46:15,800
that has things that other systems don't support.

885
00:46:16,960 --> 00:46:19,425
If I was, if I was building a new database system scratch today,

886
00:46:19,425 --> 00:46:21,420
I would not do what Snowflake did,

887
00:46:21,420 --> 00:46:22,280
it was a different time,

888
00:46:22,570 --> 00:46:23,720
I would start with Postgres,

889
00:46:24,240 --> 00:46:26,210
and then expand upon it the way DuckDB did.

890
00:46:30,180 --> 00:46:33,860
Okay, keep going, because still a lot to cover,

891
00:46:36,130 --> 00:46:39,020
in the sake of time, I'm going to skip output redirection,

892
00:46:41,070 --> 00:46:43,150
because you're not really going to need that for the homework,

893
00:46:44,040 --> 00:46:45,610
let's jump ahead to window functions.

894
00:46:47,660 --> 00:46:49,890
All right, so before we showed aggregations,

895
00:46:51,110 --> 00:46:58,990
they were computing sort of one shot calculation across the entire input set

896
00:46:58,990 --> 00:47:07,030
to the relation, that was being inputted to the to, to, for the aggregate function,

897
00:47:07,200 --> 00:47:08,440
that you're operating on the FROM clause,

898
00:47:09,090 --> 00:47:10,730
but there's also times,

899
00:47:10,730 --> 00:47:13,480
where you may need to want to what is called a sliding calculation,

900
00:47:13,860 --> 00:47:17,335
where think of like a rolling tally

901
00:47:17,335 --> 00:47:19,135
as you go from one tuple to the next,

902
00:47:19,135 --> 00:47:20,100
as you're scanning along,

903
00:47:20,420 --> 00:47:23,010
you want to update some, some kind of aggregate function,

904
00:47:23,660 --> 00:47:28,080
so that for every single tuple, that you're output from your SELECT statement,

905
00:47:28,430 --> 00:47:34,080
the aggregate is sort of snapshot in time of when that tuple was processed, right,

906
00:47:34,080 --> 00:47:35,520
the way, it's like an aggregate function,

907
00:47:35,520 --> 00:47:40,630
where you're not grouping them into a single output, for every single final output,

908
00:47:40,770 --> 00:47:44,290
for every tuple, it's going to have its own computation for that aggregation.

909
00:47:45,330 --> 00:47:46,220
And so the way this works,

910
00:47:46,220 --> 00:47:48,670
you would have like a, a function here,

911
00:47:48,990 --> 00:47:50,105
this will be all your aggregate functions,

912
00:47:50,105 --> 00:47:53,290
Min, Max, Count, Avg, as we saw before,

913
00:47:54,000 --> 00:47:55,240
as well as some additional ones,

914
00:47:55,800 --> 00:48:02,920
and then you're going to specify what is the sort of scope or the range that you're going to compute this calculation for

915
00:48:03,360 --> 00:48:06,920
basically of how to slice up the data and source it and sort it.

916
00:48:09,020 --> 00:48:10,860
So let's look at some examples like this,

917
00:48:11,450 --> 00:48:14,190
so I can have all the aggregation functions that I had before,

918
00:48:16,530 --> 00:48:17,690
Min Max Count, so forth,

919
00:48:17,690 --> 00:48:18,950
but I have these these additional ones,

920
00:48:18,950 --> 00:48:23,830
like the ROW_NUMBER, that tell me what row my tuple is, is in my output,

921
00:48:24,180 --> 00:48:26,440
as well as a rank, if I'm, I'm sorting them,

922
00:48:26,670 --> 00:48:30,610
so if I have an ORDER BY clause, order students by gpa,

923
00:48:30,900 --> 00:48:33,670
I can tell you what your position is using the RANK function,

924
00:48:36,150 --> 00:48:37,880
you can't do that with a aggregation function,

925
00:48:37,880 --> 00:48:40,060
because there's things that get collapsed down.

926
00:48:41,520 --> 00:48:43,070
So in this case here, this example here,

927
00:48:43,070 --> 00:48:47,110
I can do SELECT * ROW_NUMBER OVER and then the empty parentheses,

928
00:48:47,730 --> 00:48:48,910
because I'm not partitioning it,

929
00:48:49,080 --> 00:48:50,390
and that'll give me output like this,

930
00:48:50,390 --> 00:48:51,220
what it'll tell me,

931
00:48:51,900 --> 00:48:53,300
again, for all my output tuples,

932
00:48:53,740 --> 00:48:57,360
where do I appear in the list for that, right.

933
00:49:02,170 --> 00:49:03,270
If you have the OVER clause,

934
00:49:03,270 --> 00:49:07,610
you can specify how you want to group, group tables together or group tuples together,

935
00:49:07,750 --> 00:49:08,870
when computing the window function,

936
00:49:09,370 --> 00:49:14,480
and then you can use the PARTITION BY, like GROUP BY, of how to how to group them up,

937
00:49:15,000 --> 00:49:16,550
so for this query here,

938
00:49:16,550 --> 00:49:19,060
we're doing SELECT the course id and the student id from the enrolled table,

939
00:49:19,530 --> 00:49:25,030
and I want to get the ROW_NUMBER of each, each student record in the enrolled table,

940
00:49:25,860 --> 00:49:28,400
but then I want to partition it by course id,

941
00:49:28,720 --> 00:49:29,970
so I would get an output like this,

942
00:49:29,970 --> 00:49:32,480
for every single course, it would tell me,

943
00:49:33,700 --> 00:49:37,850
for every student id what, what position they are in that, in that group,

944
00:49:39,130 --> 00:49:40,670
sort of [class] like this.

945
00:49:42,810 --> 00:49:44,045
Then, if you have an ORDER BY clause,

946
00:49:44,045 --> 00:49:46,720
you can then control how the tuples will be sorted

947
00:49:46,770 --> 00:49:50,595
within, within either a partition or with, within the window, right,

948
00:49:50,595 --> 00:49:51,410
so in this case here,

949
00:49:51,700 --> 00:49:54,130
now I can order the students by,

950
00:49:55,560 --> 00:49:57,230
from the enrolled table, based on the course id.

951
00:49:58,890 --> 00:50:00,320
So there's a more complicated example here,

952
00:50:00,320 --> 00:50:04,510
so we want to find the student with the second highest grade for each course.

953
00:50:05,420 --> 00:50:07,015
So for this one here,

954
00:50:07,015 --> 00:50:09,000
we're going to have a nested query, which we'll discuss in a second,

955
00:50:09,260 --> 00:50:13,210
but basically I have a SELECT statement that has a FROM clause,

956
00:50:13,210 --> 00:50:16,260
and inside that FROM clause, I have another query, right,

957
00:50:17,080 --> 00:50:19,315
and I can, inside this inner query,

958
00:50:19,315 --> 00:50:24,210
I can reference, here, I'm doing the lookup on the enrolled table

959
00:50:24,290 --> 00:50:26,395
and then the outer query can just do filtering

960
00:50:26,395 --> 00:50:28,830
based on the output of this nested query,

961
00:50:29,030 --> 00:50:30,600
I'm going to cover nest queries in a second.

962
00:50:31,860 --> 00:50:32,945
So the first thing we're going to do is going to

963
00:50:32,945 --> 00:50:35,080
group the tuples by the course id,

964
00:50:35,920 --> 00:50:37,920
and then sort them by the grade

965
00:50:38,150 --> 00:50:39,210
and then we'll get the rank,

966
00:50:39,410 --> 00:50:45,040
what is their position in the sort of list of grades, right,

967
00:50:45,040 --> 00:50:46,075
and then in my WHERE clause here,

968
00:50:46,075 --> 00:50:54,930
I can reference now the, the window, the window function calculation of column, right.

969
00:50:56,000 --> 00:50:57,150
So any questions about this?

970
00:51:05,940 --> 00:51:06,500
The question is,

971
00:51:06,500 --> 00:51:08,470
can I, can I make a window function using GROUP BYs,

972
00:51:13,400 --> 00:51:14,760
let try it what you're saying.

973
00:51:17,180 --> 00:51:18,000
All right, so.

974
00:51:25,870 --> 00:51:31,300
All right, so, is in Postgres, right,

975
00:51:31,300 --> 00:51:33,870
so again, SELECT FROM the enrolled table,

976
00:51:34,190 --> 00:51:38,700
and then we'll get the ROW_NUMBER where each student appears.

977
00:51:41,490 --> 00:51:44,260
And then the second, excuse me, the second example was,

978
00:51:45,120 --> 00:51:47,590
the course id, student id, and then the ROW_NUMBER,

979
00:51:47,820 --> 00:51:49,990
we're going to partition it by the course id,

980
00:51:50,370 --> 00:51:54,970
so then we're just going to order them and the output by the course id, right,

981
00:51:55,640 --> 00:51:57,820
so again, this case here, we see that we have,

982
00:51:58,410 --> 00:52:01,330
for each course, 15-445, 721 and 826,

983
00:52:01,980 --> 00:52:03,520
here's the students that enroll in them,

984
00:52:03,630 --> 00:52:06,220
and then this is their position within, within each group.

985
00:52:08,740 --> 00:52:10,280
And then my last example was like this,

986
00:52:10,600 --> 00:52:13,010
and this is where you were asking, whether you can do a GROUP BY,

987
00:52:14,960 --> 00:52:15,680
we're now here again,

988
00:52:15,680 --> 00:52:17,645
so I can get the first,

989
00:52:17,645 --> 00:52:22,540
the inner query is going to get me the rank position of every record,

990
00:52:22,860 --> 00:52:25,030
the rank where you are in the sorting output,

991
00:52:26,460 --> 00:52:31,215
let me remove this part here first, right,

992
00:52:31,215 --> 00:52:35,540
so here's, here's the output of the, of the, the inner query of the SELECT RANK,

993
00:52:35,920 --> 00:52:37,400
so for every course,

994
00:52:37,900 --> 00:52:41,780
I'm going to get the grades and I'm going to order them by the grades,

995
00:52:42,010 --> 00:52:44,030
and then the rank is just where their position is

996
00:52:44,440 --> 00:52:48,000
in the, you know, within the sort of list of the grades

997
00:52:48,620 --> 00:52:49,930
and the rank can have repeats,

998
00:52:49,930 --> 00:52:52,630
so if I say insert another record here,

999
00:52:52,630 --> 00:52:56,890
INSERT INTO enrolled VALUES,

1000
00:52:57,420 --> 00:53:04,350
so we need a student id, let's do, have tupac take,

1001
00:53:07,540 --> 00:53:11,480
VALUES, course id would be 15-721

1002
00:53:12,010 --> 00:53:17,200
and let's say he got a, let's give a name, he's [].

1003
00:53:23,290 --> 00:53:24,080
What about I create,

1004
00:53:25,760 --> 00:53:27,630
that order, by order by rank, maybe,

1005
00:53:28,410 --> 00:53:40,200
well, that that screws out the partition that, sorry, right.

1006
00:53:40,200 --> 00:53:43,120
So, here what we're doing is,

1007
00:53:44,250 --> 00:53:48,370
every single course, again, we're getting the grade and sort of in the rank,

1008
00:53:48,630 --> 00:53:52,210
and so we inserted this record here, Tupac, we gave an A,

1009
00:53:52,230 --> 00:53:55,280
but there was also another student who got an A in the same class

1010
00:53:55,510 --> 00:53:57,710
and therefore they both have the same rank position of 1,

1011
00:53:58,400 --> 00:54:00,450
and then for the student that got the C,

1012
00:54:00,710 --> 00:54:02,190
their rank position is 3,

1013
00:54:02,330 --> 00:54:04,290
so rank you can have duplicates. row numbers will not.

1014
00:54:07,240 --> 00:54:08,960
So, yeah, so you're proposing to do what,

1015
00:54:09,130 --> 00:54:10,010
bunch of rank group,

1016
00:54:11,940 --> 00:54:12,340
where,

1017
00:54:15,760 --> 00:54:17,390
at the inner query, or what, sorry.

1018
00:54:24,300 --> 00:54:24,830
The question is,

1019
00:54:24,830 --> 00:54:26,620
is it possible to recreate the same query using GROUP BY,

1020
00:54:29,200 --> 00:54:30,830
you wouldn't, you wouldn't be able to get the rank,

1021
00:54:32,260 --> 00:54:34,740
because you wouldn't be able to get what what is my sort position,

1022
00:54:34,740 --> 00:54:41,640
there isn't a concept of that in, in SQL, right,

1023
00:54:41,870 --> 00:54:44,700
so ROW_NUMBER is interesting, because it is,

1024
00:54:46,620 --> 00:54:47,930
let's do that ROW_NUMBER,

1025
00:54:56,260 --> 00:54:58,000
make the point, switch a ROW_NUMBER,

1026
00:54:58,000 --> 00:54:59,070
ROW_NUMBER,

1027
00:55:00,990 --> 00:55:02,410
so ROW_NUMBER is interesting, because,

1028
00:55:03,060 --> 00:55:05,470
it's calling it rank, but trust me, it's row_number,

1029
00:55:06,090 --> 00:55:08,930
it because, again it's bag algebra,

1030
00:55:08,930 --> 00:55:11,020
there is no sort order in in these relations

1031
00:55:11,190 --> 00:55:12,400
and that's a sort of weird concept,

1032
00:55:12,810 --> 00:55:13,940
we think about programming like,

1033
00:55:13,940 --> 00:55:14,480
what do you mean there,

1034
00:55:14,480 --> 00:55:15,400
there's not ordering,

1035
00:55:15,600 --> 00:55:17,720
like because we're used to programming and under x86

1036
00:55:17,720 --> 00:55:19,625
where there ordering,

1037
00:55:19,625 --> 00:55:20,770
how memory operations occur,

1038
00:55:21,240 --> 00:55:22,415
there isn't any of that here,

1039
00:55:22,415 --> 00:55:23,380
Everything can be unordered,

1040
00:55:23,730 --> 00:55:27,770
so without a window function, you can't get a row_number,

1041
00:55:27,770 --> 00:55:29,315
because there's no way to say,

1042
00:55:29,315 --> 00:55:32,980
where do I exist in this position, in my position, my output,

1043
00:55:35,100 --> 00:55:36,620
Oracle does have row_number,

1044
00:55:36,620 --> 00:55:37,445
they hide it from you,

1045
00:55:37,445 --> 00:55:41,040
you can't get it, but like it's, that's just an Oracle thing.

1046
00:55:42,710 --> 00:55:45,090
So, so the window functions allow you to

1047
00:55:45,170 --> 00:55:47,520
condition doing the averages and all the other aggregates,

1048
00:55:47,630 --> 00:55:50,850
it allows you to get the order of things,

1049
00:55:50,930 --> 00:55:52,650
in a way that you would not be able to do it otherwise.

1050
00:56:03,310 --> 00:56:04,740
So I should showed nested queries before,

1051
00:56:04,740 --> 00:56:06,410
but there just go through more, more detail.

1052
00:56:06,730 --> 00:56:09,200
So a nested query, nested queries, a really powerful concept,

1053
00:56:09,700 --> 00:56:10,940
sometimes called sub queries,

1054
00:56:11,080 --> 00:56:14,355
where it allows you to have a query inside of a query

1055
00:56:14,355 --> 00:56:15,690
inside, inside of a query,

1056
00:56:15,690 --> 00:56:18,620
you have multiple queries inside of overarching calling queries,

1057
00:56:19,220 --> 00:56:19,970
and you would need this,

1058
00:56:19,970 --> 00:56:22,000
because you want to be able to express certain computations,

1059
00:56:22,890 --> 00:56:25,720
it would be difficult to express certain computations without these nested queries,

1060
00:56:25,980 --> 00:56:28,130
without taking the data out, doing some computation

1061
00:56:28,130 --> 00:56:29,830
and then putting it back in the database system,

1062
00:56:30,150 --> 00:56:31,655
so it allows us to put these things together

1063
00:56:31,655 --> 00:56:34,870
to create more complex logic,

1064
00:56:35,190 --> 00:56:37,060
than we would not be able to otherwise do.

1065
00:56:37,800 --> 00:56:41,420
And these inner queries can appear almost anywhere inside of a SELECT [],

1066
00:56:41,420 --> 00:56:42,940
but actually really any query,

1067
00:56:43,170 --> 00:56:45,850
like you can have in the SELECT output, the FROM clause, the WHERE clause,

1068
00:56:46,230 --> 00:56:49,090
you can put an UPDATE queries and DELETE queries, right,

1069
00:56:50,390 --> 00:56:52,950
and they can now reference all the tables within your own query,

1070
00:56:53,420 --> 00:56:54,810
it's a very powerful construct.

1071
00:56:55,680 --> 00:56:56,985
So the basic idea is something like this,

1072
00:56:56,985 --> 00:56:59,270
so here we're doing SELECT FROM the student table

1073
00:56:59,800 --> 00:57:03,440
and then I want to get the name of a student,

1074
00:57:03,460 --> 00:57:05,420
that is at least enrolled in one course.

1075
00:57:05,740 --> 00:57:07,020
So you can think of,

1076
00:57:07,020 --> 00:57:09,090
this out, this SELECT [] in the top part,

1077
00:57:09,090 --> 00:57:10,100
that's called the Outer Query,

1078
00:57:10,330 --> 00:57:12,650
and then this inner part here, we would call this Inner Query.

1079
00:57:13,670 --> 00:57:18,860
So, nested queries are notoriously difficult for database systems to optimize,

1080
00:57:21,070 --> 00:57:23,600
because you think about the stupidest way to execute this query would be,

1081
00:57:23,920 --> 00:57:27,770
for every single tuple in my student table, rerun this thing,

1082
00:57:29,040 --> 00:57:31,630
get the list of all the student ids, then compute the IN,

1083
00:57:32,510 --> 00:57:33,985
the way to really execute this is,

1084
00:57:33,985 --> 00:57:36,480
this is just a JOIN, for this one example here,

1085
00:57:38,140 --> 00:57:39,145
this one's easy to do,

1086
00:57:39,145 --> 00:57:43,290
because, you know, you're looking for this, this thing to match something here,

1087
00:57:43,580 --> 00:57:46,020
so you can do convert that to a [quality] predicate,

1088
00:57:46,340 --> 00:57:47,280
things get more complicated,

1089
00:57:47,510 --> 00:57:51,180
when there's non-trivial relations between the inner query and the outer query,

1090
00:57:51,380 --> 00:57:53,965
we won't, we'll, we'll come into that later in the semester,

1091
00:57:53,965 --> 00:58:00,110
but, this is something, this is the hardest part of database systems

1092
00:58:00,490 --> 00:58:05,450
and the only system that does nested queries correctly is the system called Umbra,

1093
00:58:05,800 --> 00:58:08,810
which is a academic system out of Germany,

1094
00:58:10,450 --> 00:58:12,350
DuckDB does it correctly now,

1095
00:58:12,520 --> 00:58:13,220
for two reasons,

1096
00:58:13,270 --> 00:58:16,130
one, because they copied what Umbra did,

1097
00:58:16,180 --> 00:58:18,380
it in papers, it's not like they stole the ideas,

1098
00:58:19,180 --> 00:58:21,525
and then we also sent them patches last semester out of 721,

1099
00:58:21,525 --> 00:58:22,580
so we fixed it for them,

1100
00:58:22,960 --> 00:58:26,450
they can do some of these nested queries correctly with [],

1101
00:58:27,640 --> 00:58:29,390
DuckDB is probably the best imitation of this,

1102
00:58:29,530 --> 00:58:32,120
a lot of times there's a bunch of heuristics hacks,

1103
00:58:32,410 --> 00:58:33,500
again, we'll cover this later.

1104
00:58:34,910 --> 00:58:35,970
MySQL was always the worst,

1105
00:58:36,050 --> 00:58:37,080
it's gotten much better though.

1106
00:58:38,510 --> 00:58:40,720
So here's a query like this,

1107
00:58:40,720 --> 00:58:43,470
we want to get the name of the students enrolled in 15-445,

1108
00:58:43,760 --> 00:58:45,180
so we have the outer query,

1109
00:58:45,530 --> 00:58:47,670
that we say we want to get the name from the student table

1110
00:58:48,050 --> 00:58:49,375
and then we want to have this WHERE clause,

1111
00:58:49,375 --> 00:58:50,610
we want to specify the logic,

1112
00:58:50,810 --> 00:58:55,440
that will get us the student id of the set of people that are taking 445,

1113
00:58:55,610 --> 00:58:56,815
so this is a way to sort of think about,

1114
00:58:56,815 --> 00:58:57,955
how you want actually construct this,

1115
00:58:57,955 --> 00:58:58,645
start with the outer query

1116
00:58:58,645 --> 00:59:01,800
of what the overarching computation of the output you want to be

1117
00:59:02,000 --> 00:59:05,040
and then you figure out what the inner part needs to be separately.

1118
00:59:05,650 --> 00:59:06,435
So in this case here,

1119
00:59:06,435 --> 00:59:10,610
we can convert this English part here into a query like this,

1120
00:59:10,990 --> 00:59:12,530
but now we need to be able to reference it

1121
00:59:12,880 --> 00:59:15,260
or do the check that we want,

1122
00:59:15,520 --> 00:59:16,940
in the WHERE clause of the outer query

1123
00:59:17,290 --> 00:59:19,850
and we use that IN clause that we had before.

1124
00:59:21,560 --> 00:59:22,560
So in this case here,

1125
00:59:23,360 --> 00:59:25,800
now we see that the student id in the,

1126
00:59:26,640 --> 00:59:28,230
in this WHERE clause, here are the outer query,

1127
00:59:28,230 --> 00:59:30,770
that's referencing the student id from the the outer query,

1128
00:59:30,940 --> 00:59:32,810
but the second student id in the inner query,

1129
00:59:32,890 --> 00:59:36,260
that's referencing the student id in the, in the, in the enrolled table.

1130
00:59:36,840 --> 00:59:39,930
So the parser in the database system is smart enough

1131
00:59:39,930 --> 00:59:43,280
to recognize the context of where a column is being referenced

1132
00:59:43,360 --> 00:59:46,190
to know which table you're looking at,

1133
00:59:46,780 --> 00:59:48,495
in the cases where it doesn't know,

1134
00:59:48,495 --> 00:59:50,540
that two things have the same name,

1135
00:59:50,650 --> 00:59:51,495
it'll throw an error

1136
00:59:51,495 --> 00:59:56,240
and make you qualify the table name where a column is coming from.

1137
00:59:58,820 --> 01:00:01,500
So there's a bunch different ways you can interact with nested queries,

1138
01:00:01,940 --> 01:00:03,270
you can set WHERE clauses,

1139
01:00:03,650 --> 01:00:06,630
so you can have things like an ALL command or ALL operator,

1140
01:00:06,860 --> 01:00:10,650
that that every row in the nested query has to satisfy some kind of restraint,

1141
01:00:11,000 --> 01:00:11,730
you can have ANY,

1142
01:00:12,500 --> 01:00:15,910
or sometimes called SOME is the alias, SOME,

1143
01:00:16,050 --> 01:00:19,750
where you can say at least one row match my sub query,

1144
01:00:20,190 --> 01:00:22,160
the IN clause is that I showed before,

1145
01:00:22,160 --> 01:00:24,310
it's the same thing as is equals ANY

1146
01:00:24,810 --> 01:00:25,580
and then EXISTS,

1147
01:00:25,580 --> 01:00:27,200
just means that I want to find something,

1148
01:00:27,200 --> 01:00:29,590
where I know there's there's at least one match,

1149
01:00:29,910 --> 01:00:31,775
sorry, there's just one row being return,

1150
01:00:31,775 --> 01:00:33,040
but I don't actually care what's in it.

1151
01:00:35,300 --> 01:00:37,690
So I can rewrite the example I have before,

1152
01:00:37,690 --> 01:00:39,870
instead of using IN, I can use ANY

1153
01:00:40,040 --> 01:00:41,280
and it's considered equivalent.

1154
01:00:42,590 --> 01:00:44,005
And so we can show real quickly,

1155
01:00:44,005 --> 01:00:46,410
how postgres picks different plans for this,

1156
01:00:46,970 --> 01:00:48,510
and you see how it's actually being executed.

1157
01:00:57,510 --> 01:00:58,510
Right, so here's our query,

1158
01:01:00,010 --> 01:01:01,490
we have RZA and Tupac taking the class,

1159
01:01:02,770 --> 01:01:03,735
so in SQL,

1160
01:01:03,735 --> 01:01:05,660
you can put this EXPLAIN keyword in front of it

1161
01:01:06,070 --> 01:01:07,040
and of any query

1162
01:01:07,480 --> 01:01:08,630
and what that's going to do,

1163
01:01:08,860 --> 01:01:09,975
if the system supports it,

1164
01:01:09,975 --> 01:01:11,690
it'll come back with the query plan

1165
01:01:11,830 --> 01:01:15,230
and tell you what operations would it execute,

1166
01:01:15,340 --> 01:01:17,930
if it actually tried to execute this thing, right.

1167
01:01:19,510 --> 01:01:20,295
So when we run that,

1168
01:01:20,295 --> 01:01:21,260
we get something like this,

1169
01:01:21,670 --> 01:01:24,710
that's going to tell us basically as a tree structure,

1170
01:01:25,060 --> 01:01:26,505
so these are the leaf nodes

1171
01:01:26,505 --> 01:01:28,160
and then it builds up this the final output,

1172
01:01:28,360 --> 01:01:29,480
so this is telling us,

1173
01:01:29,890 --> 01:01:31,940
Postgres wants to do aential scan the enrolled table

1174
01:01:32,440 --> 01:01:33,620
and then it's going to hash it,

1175
01:01:33,850 --> 01:01:35,220
because it's doing a hash one up there,

1176
01:01:35,220 --> 01:01:36,920
which we'll cover what hash is later on,

1177
01:01:37,240 --> 01:01:39,800
and then does scan on the student table

1178
01:01:40,210 --> 01:01:42,800
and then now does by matching the student id,

1179
01:01:44,890 --> 01:01:46,430
student id with enrolled student id.

1180
01:01:46,750 --> 01:01:48,060
So Postgres was smart enough

1181
01:01:48,060 --> 01:01:51,635
to convert this nested query into a JOIN,

1182
01:01:51,635 --> 01:01:53,890
which is always going to be the fastest way to execute something,

1183
01:01:54,540 --> 01:01:55,780
when you have these kind of references.

1184
01:01:57,010 --> 01:01:58,670
We can try the same thing in MySQL,

1185
01:02:06,410 --> 01:02:08,430
but you get their explained output is terrible,

1186
01:02:10,370 --> 01:02:11,250
there's a way to get,

1187
01:02:12,740 --> 01:02:13,690
I forget the syntax,

1188
01:02:13,690 --> 01:02:15,570
you gotta put like an EXTENDED or something like that,

1189
01:02:17,170 --> 01:02:18,345
I forget how to do it in MySQL,

1190
01:02:18,345 --> 01:02:20,120
there's a way to get something a little bit better.

1191
01:02:22,200 --> 01:02:24,520
In SQLite, I don't think you can do this,

1192
01:02:25,170 --> 01:02:25,930
you can do this,

1193
01:02:32,165 --> 01:02:32,470
what's that,

1194
01:02:38,370 --> 01:02:40,060
all right, SQLite,

1195
01:02:43,660 --> 01:02:44,930
they don't like the SELECT statement,

1196
01:02:48,640 --> 01:02:49,460
which is surprising,

1197
01:02:49,720 --> 01:02:50,540
why doesn't that work.

1198
01:02:50,920 --> 01:02:51,920
See if DuckDB does it,

1199
01:02:53,550 --> 01:02:54,310
it give the output,

1200
01:02:54,420 --> 01:02:55,510
DuckDB has very pretty,

1201
01:02:57,470 --> 01:02:59,040
they give you, they give you nice little trees,

1202
01:03:04,040 --> 01:03:05,220
you guys are easily amused,

1203
01:03:07,340 --> 01:03:09,690
this impresses you, unicode output for,

1204
01:03:10,070 --> 01:03:10,710
oh my gosh,

1205
01:03:12,560 --> 01:03:15,570
but yeah, it gives, shows you what the physical plan is.

1206
01:03:17,390 --> 01:03:20,370
And then we can try it on Oracle,

1207
01:03:22,640 --> 01:03:23,970
right, has the right output,

1208
01:03:27,710 --> 01:03:30,190
well, we need this another time,

1209
01:03:30,190 --> 01:03:33,805
there's getting the plan out of Oracle and SQL Server is a huge pain.

1210
01:03:33,805 --> 01:03:35,160
But I'm surprised that,

1211
01:03:36,870 --> 01:03:38,020
SQLite doesn't support this,

1212
01:03:44,510 --> 01:03:45,600
I'm not going to debug this live,

1213
01:03:48,150 --> 01:03:49,450
yeah, I don't know why it doesn't like that,

1214
01:03:49,560 --> 01:03:50,290
let's try IN,

1215
01:03:55,030 --> 01:03:55,710
ah, there we go,

1216
01:03:55,710 --> 01:03:56,960
they didn't like ANY, like IN.

1217
01:03:57,520 --> 01:03:59,205
Alright, so in SQLite,

1218
01:03:59,205 --> 01:04:00,050
if I run EXPLAIN,

1219
01:04:04,670 --> 01:04:05,310
I get this,

1220
01:04:08,910 --> 01:04:10,160
so the way SQLite does,

1221
01:04:10,160 --> 01:04:12,780
which is, [genius], is that,

1222
01:04:15,230 --> 01:04:16,585
the way itutes your query plan,

1223
01:04:16,585 --> 01:04:21,115
it converts the query plan into its own DSL op codes,

1224
01:04:21,115 --> 01:04:24,000
and it has its own vm that runs the op codes,

1225
01:04:24,290 --> 01:04:25,150
like the JVM,

1226
01:04:25,150 --> 01:04:27,390
you take Java code, convert it into Java byte code,

1227
01:04:27,500 --> 01:04:29,640
and then the JVM executes it or interprets it,

1228
01:04:29,840 --> 01:04:30,900
that's what SQLite does.

1229
01:04:32,300 --> 01:04:35,170
All right, we'll discuss query compilations later in this semester.

1230
01:04:36,930 --> 01:04:38,530
So you got to put EXPLAIN PLAN,

1231
01:04:41,090 --> 01:04:43,230
PLAN, that EXTENDED,

1232
01:04:44,280 --> 01:04:46,300
there's some syntax to get the real plan, whatever,

1233
01:04:46,320 --> 01:04:47,050
Trust me, it's there.

1234
01:04:47,070 --> 01:04:47,560
All right,

1235
01:04:51,390 --> 01:04:54,100
so yeah, so they all do something slightly different

1236
01:04:55,020 --> 01:04:56,240
and then if the system is smart,

1237
01:04:56,240 --> 01:04:57,880
you can try to convert it into a JOIN.

1238
01:04:59,960 --> 01:05:01,450
So skip this and sake a time,

1239
01:05:01,450 --> 01:05:02,760
because we got to get through,

1240
01:05:05,470 --> 01:05:10,190
I want to get through LATERAL JOINs and and CTE.

1241
01:05:10,960 --> 01:05:14,480
So LATERAL JOINs are a newer concept,

1242
01:05:14,650 --> 01:05:17,490
but, and not all systems are going to support it,

1243
01:05:17,720 --> 01:05:19,470
but the basic idea is that,

1244
01:05:19,610 --> 01:05:21,390
it's going to allow you to have a,

1245
01:05:22,300 --> 01:05:31,380
a nested query reference data in in another query that is adjacent to it.

1246
01:05:31,820 --> 01:05:32,790
So normally,

1247
01:05:33,350 --> 01:05:34,620
if you have two nested queries,

1248
01:05:34,880 --> 01:05:37,290
one nested query can't reference what's inside the other nested query,

1249
01:05:37,490 --> 01:05:39,360
because it doesn't know about what's inside of it,

1250
01:05:39,830 --> 01:05:41,010
but with a LATERAL JOIN,

1251
01:05:41,840 --> 01:05:42,730
it allows you to do this,

1252
01:05:42,730 --> 01:05:44,760
you can almost think it's a for loop,

1253
01:05:45,230 --> 01:05:51,535
where one table, for every single, every single, every single tuple in the outer, outer for loop,

1254
01:05:51,535 --> 01:05:53,560
you can do some, you can run some query,

1255
01:05:53,560 --> 01:05:54,540
do some computation here.

1256
01:05:55,410 --> 01:05:56,680
So in this simple example here,

1257
01:05:57,390 --> 01:06:00,100
I have two, two nested queries,

1258
01:06:00,360 --> 01:06:02,000
I have a SELECT 1 AS x,

1259
01:06:02,000 --> 01:06:04,690
so this is turning back a single tuple that has one column with a value 1,

1260
01:06:05,070 --> 01:06:07,000
and then my LATERAL JOIN here,

1261
01:06:07,380 --> 01:06:11,920
can now reference the the output of this first query here

1262
01:06:12,150 --> 01:06:14,360
and just do plus 1 on it, right,

1263
01:06:14,360 --> 01:06:16,300
so I get I get 1 and 2 that way.

1264
01:06:17,830 --> 01:06:19,400
Without LATERAL, you can't do this,

1265
01:06:19,990 --> 01:06:23,120
because this would be treated as completely two separate queries,

1266
01:06:23,620 --> 01:06:25,580
which we can do this in Postgres and see real quickly.

1267
01:06:30,840 --> 01:06:32,380
So, SELECT * FROM,

1268
01:06:33,980 --> 01:06:35,610
in an inner query, like 1 AS,

1269
01:06:39,960 --> 01:06:42,250
sorry, yep, yep, yep,

1270
01:06:43,340 --> 01:06:43,860
AS x,

1271
01:06:45,400 --> 01:06:46,220
AS t1.

1272
01:06:48,720 --> 01:06:51,880
Right, so I can get back a single tuple, that has 1 in it, right,

1273
01:06:52,530 --> 01:06:55,150
but if I try to put another nested query next to it,

1274
01:06:57,270 --> 01:07:03,810
SELECT 2 AS y, AS t2, right,

1275
01:07:04,040 --> 01:07:05,110
I'm getting the cartesian product,

1276
01:07:05,110 --> 01:07:06,970
but I can't reference inside of this thing,

1277
01:07:06,970 --> 01:07:11,820
I can't go t1.x+1, right,

1278
01:07:12,410 --> 01:07:14,140
because it doesn't know about t1,

1279
01:07:14,140 --> 01:07:17,040
because those queries are running separately,

1280
01:07:17,550 --> 01:07:19,060
If I add the LATERAL keyword,

1281
01:07:22,630 --> 01:07:27,950
now, my my second nested query can reference whatever is in the first one, right,

1282
01:07:28,820 --> 01:07:32,580
and you can chain these things together as many times as you want.

1283
01:07:33,650 --> 01:07:34,495
Let's go back to it quickly

1284
01:07:34,495 --> 01:07:35,850
and see what the query plan for this one would be,

1285
01:07:35,960 --> 01:07:37,470
in theory, you should convert this to a JOIN,

1286
01:07:40,640 --> 01:07:44,580
oh, all right, it did a shortcut, ignore that,

1287
01:07:45,590 --> 01:07:48,055
because it basically says, I know what the answer is,

1288
01:07:48,055 --> 01:07:49,585
I don't have to run anything and just spits out the answer,

1289
01:07:49,585 --> 01:07:50,220
that's what it did,

1290
01:07:50,660 --> 01:07:53,940
like SELECT 1+1, it knows how to compute that without running a query.

1291
01:07:54,990 --> 01:07:56,900
Alright, let's have a more complicated example,

1292
01:07:56,900 --> 01:07:59,740
so say I want to calculate the number of students that enrolled in each course

1293
01:08:00,630 --> 01:08:03,250
and then I want to count the number of students enrolled in each course,

1294
01:08:03,300 --> 01:08:08,110
and then I also want to get all the, the average GPA of all the students in that course.

1295
01:08:09,630 --> 01:08:11,930
And so yes, you can write this without using doing a LATERAL JOIN,

1296
01:08:11,930 --> 01:08:13,450
I just want to show you how to do this with a LATERAL JOIN.

1297
01:08:13,680 --> 01:08:15,250
So, there's two going to be two nested queries,

1298
01:08:15,800 --> 01:08:18,190
where we had a SELECT statement on the the outer part,

1299
01:08:18,480 --> 01:08:21,310
and for every single tuple, that's in the course table,

1300
01:08:21,720 --> 01:08:23,530
I want then compute the number enrolled students,

1301
01:08:24,120 --> 01:08:26,110
and then again, for every single student in the course table,

1302
01:08:26,310 --> 01:08:30,925
I want to compute the average GPA of all the enrolled students, right.

1303
01:08:30,925 --> 01:08:31,945
So I could write it as this,

1304
01:08:31,945 --> 01:08:33,960
we have two and two nest queries,

1305
01:08:34,040 --> 01:08:36,000
that are that are with the LATERAL keyword,

1306
01:08:36,590 --> 01:08:40,500
where again the first one here I compute the, the, the COUNT,

1307
01:08:40,880 --> 01:08:45,900
again inside of it, I'm able to reference what's in the outer query here, the adjacent query,

1308
01:08:46,220 --> 01:08:48,220
and then for this one down here, same thing,

1309
01:08:48,220 --> 01:08:50,100
I can have this one referenced there,

1310
01:08:50,180 --> 01:08:51,870
now I'm not showing this example here,

1311
01:08:52,160 --> 01:08:53,575
because you can try,

1312
01:08:53,575 --> 01:08:55,665
but, in the second LATERAL query,

1313
01:08:55,665 --> 01:08:57,530
I can also reference was in the first one,

1314
01:08:57,730 --> 01:08:59,570
these things get changed, to get changed together.

1315
01:09:00,040 --> 01:09:02,220
And again, this is a different concept, when you think of SQL,

1316
01:09:02,220 --> 01:09:03,240
because SQL is unorder,

1317
01:09:03,240 --> 01:09:08,300
we're not specifying the or we don't specify the order in which the database system should, should execute anything,

1318
01:09:08,830 --> 01:09:09,960
we're not really doing that,

1319
01:09:09,960 --> 01:09:11,055
we're just telling it the [],

1320
01:09:11,055 --> 01:09:14,400
we we want the computation to to be performeded

1321
01:09:14,400 --> 01:09:15,680
to compute the answer that we want.

1322
01:09:16,320 --> 01:09:18,185
So the database system can decide,

1323
01:09:18,185 --> 01:09:20,165
do I want to rewrite this as a bunch of JOINs

1324
01:09:20,165 --> 01:09:21,790
and just execute them all concurrently,

1325
01:09:22,470 --> 01:09:24,640
or we can decide to do it one after another,

1326
01:09:26,340 --> 01:09:28,040
which we can then test Postgres real quickly

1327
01:09:28,040 --> 01:09:28,660
and see what it does.

1328
01:09:29,510 --> 01:09:30,520
I don't think I have copied here,

1329
01:09:35,270 --> 01:09:37,620
yeah, sorry, I don't have to copy paste it real quickly,

1330
01:09:39,330 --> 01:09:40,390
you can try it online later.

1331
01:09:42,520 --> 01:09:44,990
The last thing I want to show you is COMMON TABLE EXPRESSIONS,

1332
01:09:46,140 --> 01:09:50,290
and so CTE were added 10 20 years ago,

1333
01:09:51,660 --> 01:09:55,640
and this is similar to nested queries, or similar to,

1334
01:09:57,060 --> 01:09:59,480
if you're writing data to a temp table or something like that,

1335
01:09:59,920 --> 01:10:03,105
it's a way for us to specify a query,

1336
01:10:03,105 --> 01:10:04,340
that we want to get materialized,

1337
01:10:05,220 --> 01:10:06,080
maybe we don't want to use that word,

1338
01:10:06,400 --> 01:10:07,635
we want to specify a query,

1339
01:10:07,635 --> 01:10:12,330
that could be stored in quotation marks at some virtual table,

1340
01:10:13,200 --> 01:10:16,250
and then we can have another query of reference whatever is inside of it.

1341
01:10:18,790 --> 01:10:20,390
So in my really simple example here,

1342
01:10:20,620 --> 01:10:22,850
I have this WITH clause,

1343
01:10:23,320 --> 01:10:25,190
I give my CTE a name,

1344
01:10:25,750 --> 01:10:27,480
then I have my AS statement,

1345
01:10:27,480 --> 01:10:29,060
and then whatever's inside this parentheses,

1346
01:10:29,350 --> 01:10:30,350
whatever SELECT query here

1347
01:10:30,550 --> 01:10:35,410
is going to get bound to this, this name here,

1348
01:10:35,910 --> 01:10:39,040
and then anything that comes below after the WITH statement,

1349
01:10:39,800 --> 01:10:46,070
can then reference it as if it was a table, right.

1350
01:10:46,990 --> 01:10:49,070
So again, some like this,

1351
01:10:49,300 --> 01:10:54,705
so I essentially the AS clause is binding things to names

1352
01:10:54,705 --> 01:10:56,990
to whatever, whatever's inside my WITH statement here.

1353
01:10:57,160 --> 01:10:59,880
So I have again a no table query,

1354
01:10:59,880 --> 01:11:00,615
SELECT 1 and 2,

1355
01:11:00,615 --> 01:11:01,560
that's going to produce 1, 2,

1356
01:11:01,560 --> 01:11:04,100
has a one column of 1, one column of 2,

1357
01:11:04,480 --> 01:11:08,195
but then within my, within my WITH statement up here,

1358
01:11:08,195 --> 01:11:09,850
I can give now names the columns,

1359
01:11:10,080 --> 01:11:12,940
which then can be referenced down below in the query.

1360
01:11:16,270 --> 01:11:17,415
You can do weird things too,

1361
01:11:17,415 --> 01:11:21,350
like you can actually, in Postgres will let you actually name the columns the same thing,

1362
01:11:22,420 --> 01:11:24,560
but then when you actually try to reference it below,

1363
01:11:24,580 --> 01:11:25,460
it'll throw an error.

1364
01:11:26,770 --> 01:11:31,395
So again, this example where the syntax is, is roughly the same,

1365
01:11:31,395 --> 01:11:34,220
but the semantics can be different across across different systems.

1366
01:11:35,370 --> 01:11:35,855
Let's see,

1367
01:11:35,855 --> 01:11:37,220
so let's see how we actually want to use this,

1368
01:11:37,220 --> 01:11:38,080
so for this one, again,

1369
01:11:38,400 --> 01:11:42,070
we want to find the student record that has the highest id that's enrolled in at least one course,

1370
01:11:42,570 --> 01:11:46,270
again, you showed how examples how to do this with nested queries, that we do with JOINs,

1371
01:11:47,160 --> 01:11:48,670
but now we can do with the CTE,

1372
01:11:49,080 --> 01:11:50,330
where inside the CTE,

1373
01:11:50,330 --> 01:11:51,550
first thing I'm going to do is,

1374
01:11:51,900 --> 01:11:55,600
compute the MAX student id FROM the enrolled table,

1375
01:11:56,220 --> 01:11:58,040
and then now in my SELECT statement down below,

1376
01:11:58,450 --> 01:12:01,520
I can reference my CTE to get that maxId

1377
01:12:02,230 --> 01:12:04,280
and then do my JOIN on that,

1378
01:12:07,020 --> 01:12:09,310
again, the database should be smart enough to realize that,

1379
01:12:09,570 --> 01:12:13,630
oh, I only have to run this, the CTE once, materialize it,

1380
01:12:13,710 --> 01:12:16,540
and then now I can reference it as if it was a temp table,

1381
01:12:16,860 --> 01:12:19,420
in any query below that that calls it.

1382
01:12:23,130 --> 01:12:24,340
And any question about CTEs?

1383
01:12:27,930 --> 01:12:30,595
Okay, there to finish up, right.

1384
01:12:30,595 --> 01:12:32,920
So again, hopefully the main take away from all of this is that,

1385
01:12:32,920 --> 01:12:33,760
SQL is not a dead language,

1386
01:12:33,760 --> 01:12:35,100
there's a lot of cool things you can do with it,

1387
01:12:36,260 --> 01:12:40,770
you want to try to do as much computations as you can within a single statement,

1388
01:12:41,150 --> 01:12:42,535
now it can be, can be nested queries,

1389
01:12:42,535 --> 01:12:44,070
can do much of all the weird stuff inside of it,

1390
01:12:44,750 --> 01:12:48,840
we wouldn't avoid the round trips going back and forth between the client and and the server,

1391
01:12:49,010 --> 01:12:52,480
because again, the database system should in theory be smart enough

1392
01:12:52,480 --> 01:12:55,620
to know what's the best way to execute the query that you're giving to giving to it,

1393
01:12:56,270 --> 01:12:57,690
soon as you take stuff out of the database,

1394
01:12:58,700 --> 01:12:59,755
do some Python code on it,

1395
01:12:59,755 --> 01:13:01,860
that's obviously outside the purview of the database system,

1396
01:13:02,150 --> 01:13:04,740
so we can't optimize it, can't optimize that, that Python code,

1397
01:13:05,120 --> 01:13:06,600
if you keep everything inside of database system,

1398
01:13:07,010 --> 01:13:09,960
it should be able to make a good effort how to optimize it further.

1399
01:13:10,380 --> 01:13:12,110
And again, also the main takeaway from all of this is that,

1400
01:13:12,580 --> 01:13:15,020
there is a SQL standard, nobody follows exactly,

1401
01:13:15,370 --> 01:13:17,420
every single database system is going to be slightly different,

1402
01:13:19,220 --> 01:13:21,685
people claim that, oh, it's great if you support SQL,

1403
01:13:21,685 --> 01:13:23,140
because then you can go and be portable,

1404
01:13:23,140 --> 01:13:25,920
like if I write my application on on MySQL,

1405
01:13:26,150 --> 01:13:27,960
I could very easily just port it to Postgres,

1406
01:13:28,190 --> 01:13:29,070
that is not the case,

1407
01:13:30,410 --> 01:13:32,670
oftentimes whatever database system you pick at the beginning,

1408
01:13:32,960 --> 01:13:36,990
that's what you're going to be stuck with for a long time,

1409
01:13:37,520 --> 01:13:38,040
[].

1410
01:13:39,140 --> 01:13:40,530
All right, so last thing,

1411
01:13:40,700 --> 01:13:42,270
homework #1, it be out today,

1412
01:13:42,740 --> 01:13:43,915
it's gonna be writing SQL queries,

1413
01:13:43,915 --> 01:13:44,850
do basic data analysis,

1414
01:13:45,740 --> 01:13:48,690
this year we're gonna require you to do it on SQLite and DuckDB,

1415
01:13:53,210 --> 01:13:54,310
reason why is because,

1416
01:13:54,310 --> 01:13:55,710
you write, you write the same query,

1417
01:13:55,850 --> 01:13:57,660
syntax will be slightly different, it won't be too bad,

1418
01:13:57,950 --> 01:14:01,320
but you'll run the same query and SQLite and you're run the DuckDB

1419
01:14:01,490 --> 01:14:02,610
and you'll see which faster,

1420
01:14:05,450 --> 01:14:08,550
you have this epiphany, much faster than the other one,

1421
01:14:09,890 --> 01:14:10,890
guess which is faster?

1422
01:14:16,800 --> 01:14:17,410
More efficient.

1423
01:14:17,670 --> 01:14:23,020
He says more efficient queries, part reason, maybe.

1424
01:14:26,820 --> 01:14:28,120
That's not the answer either.

1425
01:14:35,375 --> 01:14:35,890
That's not the reason,

1426
01:14:35,910 --> 01:14:38,950
okay, so you run these queries, DuckDB should be faster,

1427
01:14:40,120 --> 01:14:41,130
you'll be like, okay why,

1428
01:14:41,330 --> 01:14:42,480
that's the rest of this semester,

1429
01:14:45,950 --> 01:14:46,560
be it for SQL,

1430
01:14:47,810 --> 01:15:10,285
next class we'll talking how you build a system.

