1
00:00:26,650 --> 00:00:30,590
2PL ，周六的演唱会怎么样？

2
00:00:31,030 --> 00:00:33,260
很好，会给一群演讲者[]。

3
00:00:33,260 --> 00:00:34,750
你说的[]演讲者是什么意思？

4
00:00:34,750 --> 00:00:38,450
我的意思是，如果演讲者可以 100% 地工作，

5
00:00:38,650 --> 00:00:40,040
你会让他们达到 200% 。

6
00:00:40,480 --> 00:00:41,030
你打破了吗？

7
00:00:42,040 --> 00:00:42,980
也许下一次可以。

8
00:00:43,090 --> 00:00:45,170
好的，有多少人？

9
00:00:45,490 --> 00:00:45,980
两百。

10
00:00:46,150 --> 00:00:47,265
两百，太令人惊讶了。

11
00:00:47,265 --> 00:00:48,710
好的，你的下一场演出是什么时候？

12
00:00:49,270 --> 00:00:49,670
十月份，在秋休之后。

13
00:00:51,130 --> 00:00:52,160
那是校外的事。

14
00:00:52,570 --> 00:00:53,870
我们会把它张贴在 Piazza 上。

15
00:00:53,980 --> 00:00:55,040
好的，大家，有很多东西要讲，

16
00:00:55,510 --> 00:00:57,050
一些快速管理的事情，我很快讲一下。

17
00:00:57,460 --> 00:01:01,160
所以家庭作业 #2 已经放出，

18
00:01:01,450 --> 00:01:04,010
我们把截止日期推迟到了 10 月 4 日，

19
00:01:04,030 --> 00:01:07,850
因为我们不想让它和项目 #1 的截止日期排在同一天，

20
00:01:09,070 --> 00:01:11,115
所以问题的材料部分，

21
00:01:11,115 --> 00:01:12,860
我也做的是劳动节的日程安排，

22
00:01:12,970 --> 00:01:15,855
所以家庭作业的材料讨论，我们下周讨论，

23
00:01:15,855 --> 00:01:17,120
我们把这推迟了一天，

24
00:01:17,440 --> 00:01:20,060
然后项目 #1 仍在正轨上，我们截止 10 月 2 日，

25
00:01:20,410 --> 00:01:21,500
也是在星期天，

26
00:01:21,820 --> 00:01:26,990
星期一下午 6：30 ，我们将举行问答会议，

27
00:01:27,220 --> 00:01:30,860
这将是在 Zoom 上，张贴在 Piazza 上，

28
00:01:31,120 --> 00:01:32,835
至于所有的项目，

29
00:01:32,835 --> 00:01:36,210
周日不会有任何办公时间，

30
00:01:36,210 --> 00:01:37,430
当项目到期时，

31
00:01:37,630 --> 00:01:41,690
但是会有一个特别的办公时间会议，在周六，在它到期之前，

32
00:01:42,070 --> 00:01:46,580
大约下午 3-5 点之间有 4 个助教，

33
00:01:47,050 --> 00:01:48,530
这就像是一种强制功能，

34
00:01:48,550 --> 00:01:50,415
让你们真正开始工作，

35
00:01:50,415 --> 00:01:52,890
而不是在到期日期的办公时间表示，

36
00:01:52,890 --> 00:01:54,480
说你没有编译，

37
00:01:54,480 --> 00:01:58,340
我们希望你尽快开始，好吗？

38
00:01:59,930 --> 00:02:03,400
我想有些人已经百分之百地完成了项目一，

39
00:02:03,400 --> 00:02:05,455
虽然今天的讲座讨论的是项目一，

40
00:02:05,455 --> 00:02:06,900
所以，令人印象深刻。

41
00:02:10,180 --> 00:02:11,360
抱歉，你期望什么是多少？

42
00:02:15,490 --> 00:02:16,095
他的问题是，

43
00:02:16,095 --> 00:02:18,590
我们应该花多长时间来完成整个项目，

44
00:02:19,840 --> 00:02:21,260
我想，这取决于你的背景，

45
00:02:21,400 --> 00:02:23,340
比如有些人用 C++ ，没有问题，

46
00:02:23,340 --> 00:02:25,070
而其他人在挣扎，

47
00:02:26,440 --> 00:02:27,950
项目一是，

48
00:02:28,510 --> 00:02:29,870
我的意思是它比项目零的工作量更大，

49
00:02:30,040 --> 00:02:31,430
它没有项目一那么糟糕，

50
00:02:31,510 --> 00:02:32,150
这是合理的，

51
00:02:32,860 --> 00:02:33,590
它不是很糟糕。

52
00:02:34,870 --> 00:02:35,450
还有其他问题吗？

53
00:02:38,060 --> 00:02:41,310
好的，还有一些其他课外活动，

54
00:02:41,510 --> 00:02:42,720
你们可以在课程中做，

55
00:02:43,280 --> 00:02:45,535
今天，我们将进行另一场研讨会演讲，

56
00:02:45,535 --> 00:02:48,090
来自 CMU 的 Dana Van Aken ，

57
00:02:48,500 --> 00:02:51,330
谈谈 OtterTune 和我参与的初创公司，

58
00:02:51,530 --> 00:02:54,840
下周，我们将有 PostgresML 的联合创始人之一，

59
00:02:55,220 --> 00:03:00,100
这是 Postgres 的[托管]版本，

60
00:03:00,100 --> 00:03:01,780
他们在那里放置 UDF ，

61
00:03:01,780 --> 00:03:04,890
或者你可以在直接使用 SQL 进行类似于 PyTorch 的调用，

62
00:03:05,390 --> 00:03:08,130
他们还做了 Postgres 代理，叫做 PgCat ，

63
00:03:08,870 --> 00:03:10,590
是用 Rust 写成的，很受欢迎，

64
00:03:10,670 --> 00:03:12,030
然后在接下来的一周，

65
00:03:12,170 --> 00:03:13,890
实际上不是 18 日，而是 10 月 2 日，

66
00:03:15,080 --> 00:03:17,590
我们将有 Weaviate 的 CTO 和联合创始人，

67
00:03:17,590 --> 00:03:18,810
Weaviate 是一个向量数据库，

68
00:03:19,400 --> 00:03:20,730
在 Zoom 上给我们演讲。

69
00:03:21,920 --> 00:03:22,320
好的。

70
00:03:23,300 --> 00:03:23,650
是的。

71
00:03:23,940 --> 00:03:26,990
它的问题是，

72
00:03:26,990 --> 00:03:28,810
这些公司中有没有实习机会，

73
00:03:29,310 --> 00:03:30,010
当然有，

74
00:03:33,540 --> 00:03:35,390
他们想出一种最好的联系方式，

75
00:03:35,390 --> 00:03:38,500
但是，没错，所有这些公司都是为了招聘。

76
00:03:41,490 --> 00:03:43,510
上周有两条重大的数据库新闻，

77
00:03:43,560 --> 00:03:44,470
自从我们上节课以来，

78
00:03:44,910 --> 00:03:46,120
有人知道它们是什么吗？

79
00:03:51,600 --> 00:03:52,870
Postgres 发布了版本 16 ，

80
00:03:54,660 --> 00:03:56,230
并不是一个很大的游戏规则改变者，

81
00:03:56,310 --> 00:03:58,730
他们没有令人惊叹的新功能，

82
00:03:58,730 --> 00:04:00,190
它有很多改进之处，

83
00:04:00,990 --> 00:04:05,680
很高兴他们有，它是，

84
00:04:05,910 --> 00:04:07,565
游戏规则的改变者的改进是，

85
00:04:07,565 --> 00:04:11,255
在我看来，是他们为 WHERE 子句增加及时编译时，

86
00:04:11,255 --> 00:04:13,180
我们将在几周内讨论，

87
00:04:13,590 --> 00:04:15,940
对 B 树重复数据删除是不错的，

88
00:04:16,290 --> 00:04:20,470
有一堆 I/O 的东西还没有准备好投入生产，

89
00:04:21,720 --> 00:04:22,750
我们今天会稍微讨论一下，

90
00:04:23,100 --> 00:04:25,005
但是，有是不错的，

91
00:04:25,005 --> 00:04:27,350
Postgres 每年发布一次，这是一件很好的事情。

92
00:04:27,520 --> 00:04:28,545
然后， Databricks 宣布，

93
00:04:28,545 --> 00:04:31,730
他们以 5 亿美元的价格融资了第 I 轮，

94
00:04:32,890 --> 00:04:35,960
估值为 430 亿美元，

95
00:04:37,060 --> 00:04:40,610
这么多钱是不言而喻的，

96
00:04:41,260 --> 00:04:42,270
是的，我没有，

97
00:04:42,270 --> 00:04:45,710
Snowflake 在 IPO 之前没有筹集到这个数额，

98
00:04:45,760 --> 00:04:48,020
但不管怎样，他们都在招人。

99
00:04:49,720 --> 00:04:51,260
好的，所以，好的。

100
00:04:52,570 --> 00:04:59,250
上一节课，我们结束了关于数据库系统存储方面的讨论，

101
00:04:59,250 --> 00:05:05,480
重点是数据库系统如何在磁盘中表示数据，

102
00:05:05,560 --> 00:05:09,260
我们讨论了面向 tuple 存储，日志结构存储和索引组织存储，

103
00:05:09,340 --> 00:05:11,805
现在我们知道这些文件在磁盘上是什么样子，

104
00:05:11,805 --> 00:05:12,770
它们是如何被分解成页面的，

105
00:05:13,550 --> 00:05:17,070
所以今天的课程和以后的课程是关于，

106
00:05:17,360 --> 00:05:19,980
我们如何从磁盘中获取这些页面，

107
00:05:20,330 --> 00:05:21,270
将这些页面放入内存，

108
00:05:21,290 --> 00:05:23,070
然后对它们进行一些操作。

109
00:05:24,050 --> 00:05:28,860
当然，我们试图在这个概念性系统中建立的整个目标是，

110
00:05:29,330 --> 00:05:31,645
拥有一个数据库系统，它给人一种错觉，

111
00:05:31,645 --> 00:05:33,870
我们拥有比实际拥有更多的内存，

112
00:05:34,400 --> 00:05:36,180
数据库比内存中的大小更大，

113
00:05:36,470 --> 00:05:38,910
我们想让它看起来像可以在内存中容纳一切。

114
00:05:39,380 --> 00:05:40,405
所以今天真正的主题是，

115
00:05:40,405 --> 00:05:43,080
我们如何从磁盘中获取我们需要的东西，那些页面，

116
00:05:43,550 --> 00:05:44,400
将它们带入内存，

117
00:05:44,420 --> 00:05:46,470
然后决定如何删除它们，

118
00:05:46,790 --> 00:05:49,470
以便在我们想要引入新东西时节省空间。

119
00:05:50,940 --> 00:05:51,340
好的。

120
00:05:53,070 --> 00:05:56,420
所以，我们必须考虑两个关键方面，

121
00:05:56,420 --> 00:05:59,950
在做出任何有关如何在磁盘中来回移动数据的决策时。

122
00:06:00,860 --> 00:06:03,880
第一个是，我们希望将页面写到磁盘上的什么位置，

123
00:06:03,900 --> 00:06:05,480
以及如何布局它们，

124
00:06:05,480 --> 00:06:08,500
以一种我们可以最大限度地增加执行顺序 I/O 的数量的方法，

125
00:06:08,640 --> 00:06:09,820
而不是执行随机 I/O 。

126
00:06:10,560 --> 00:06:13,065
这里的想法是，

127
00:06:13,065 --> 00:06:15,170
我们希望将要一起使用的页面保留在磁盘上，

128
00:06:15,910 --> 00:06:18,710
可能在物理上彼此接近，

129
00:06:18,940 --> 00:06:23,475
这样当查询运行或某个任务在我们的数据库系统内运行时，

130
00:06:23,475 --> 00:06:24,740
我们必须获取大量页面，

131
00:06:25,300 --> 00:06:26,550
我们希望这些页面是连续的，

132
00:06:26,550 --> 00:06:27,830
当我们把那些页面放入内存时。

133
00:06:29,300 --> 00:06:30,720
然后要考虑的下一件事是，

134
00:06:31,460 --> 00:06:33,090
我们何时必须读取内存中的内容，

135
00:06:33,470 --> 00:06:36,150
这通常是按需完成的，意思是，

136
00:06:36,560 --> 00:06:37,870
我们将在稍后看到预取，

137
00:06:37,870 --> 00:06:38,620
但你不仅仅是，

138
00:06:38,620 --> 00:06:40,375
系统只是随机地读取东西，

139
00:06:40,375 --> 00:06:41,130
因为它想要这样做，

140
00:06:42,290 --> 00:06:43,675
如果你插入了一堆数据，

141
00:06:43,675 --> 00:06:44,695
然后你从来没有去读它，

142
00:06:44,695 --> 00:06:47,280
它就不会读回内存，

143
00:06:47,540 --> 00:06:48,570
只是为了[]，

144
00:06:49,010 --> 00:06:50,740
所以，它将按需提供，

145
00:06:50,740 --> 00:06:54,090
我们必须从磁盘中获取东西，并将它们带到内存中。

146
00:06:54,770 --> 00:06:56,100
然后问题是，

147
00:06:56,330 --> 00:07:00,360
我们什么时候想要把它从内存中驱逐出去，

148
00:07:00,500 --> 00:07:02,650
它最后一次访问是什么时候，如何访问，

149
00:07:02,650 --> 00:07:04,645
自从我们把它放入内存后它是否更新了，

150
00:07:04,645 --> 00:07:05,760
所以我们需要将它写出去，

151
00:07:06,170 --> 00:07:07,200
我们不会谈论，

152
00:07:07,460 --> 00:07:09,840
如何确保我们能够，

153
00:07:10,670 --> 00:07:13,050
保存我们的更改，以防发生崩溃或故障，

154
00:07:13,520 --> 00:07:15,210
我们将在最后讨论这个，

155
00:07:15,560 --> 00:07:21,720
但这将是期中考试后一节课的主要关注点，

156
00:07:21,830 --> 00:07:22,690
这实际上是关于，

157
00:07:22,690 --> 00:07:25,200
好的，我必须决定要驱逐哪些数据，

158
00:07:25,400 --> 00:07:26,550
我该如何做出这个决定。

159
00:07:28,940 --> 00:07:30,870
这是我之前展示的同一张图，

160
00:07:31,760 --> 00:07:34,360
我们有数据库文件在磁盘上，

161
00:07:34,360 --> 00:07:35,520
它被分成了几个页面，

162
00:07:36,080 --> 00:07:38,140
然后我们今天要讨论的是，

163
00:07:38,140 --> 00:07:39,540
这个叫做缓冲池的部分，

164
00:07:40,160 --> 00:07:41,460
我称之为缓冲池管理器，

165
00:07:41,600 --> 00:07:49,620
某些地方或某些系统称为缓冲池缓存管理器，

166
00:07:49,880 --> 00:07:51,310
它们基本上都有相同的意思，

167
00:07:51,310 --> 00:07:55,770
它他是数据库系统从操作系统分配内存，并自行控制。

168
00:07:57,060 --> 00:07:58,870
所以当你有了你的执行引擎，

169
00:07:59,340 --> 00:08:00,425
它开始做一些事情，

170
00:08:00,425 --> 00:08:02,530
比如，它运行一个查询，

171
00:08:03,180 --> 00:08:04,390
它不一定非得这样，但它是有可能的，

172
00:08:05,100 --> 00:08:07,600
在某个点上，它说我需要获取第二页，

173
00:08:08,460 --> 00:08:10,655
所以我们从磁盘获取页面目录，

174
00:08:10,655 --> 00:08:11,345
并将其放入内存，

175
00:08:11,345 --> 00:08:12,370
如果它还不在那里，

176
00:08:12,660 --> 00:08:13,685
查看我们的页面目录，

177
00:08:13,685 --> 00:08:14,990
它将告诉我们第二页，

178
00:08:14,990 --> 00:08:18,250
这是在哪里找到该特定页面的文件和偏移量，

179
00:08:18,720 --> 00:08:19,900
我们将其放入内存中，

180
00:08:20,310 --> 00:08:23,350
放入缓冲池中的一个空闲空间，

181
00:08:23,760 --> 00:08:25,655
然后返回给执行引擎，

182
00:08:25,655 --> 00:08:28,780
一个指向位于缓冲池中的页面的指针。

183
00:08:31,210 --> 00:08:33,050
现在让我们假设，

184
00:08:33,430 --> 00:08:36,615
我们运行某种驱逐策略、替换政策，

185
00:08:36,615 --> 00:08:39,405
无论出于什么原因，我们决定删除第二页，

186
00:08:39,405 --> 00:08:40,460
因为我们需要更多空间，

187
00:08:40,750 --> 00:08:41,730
我们运行一堆其他数据，

188
00:08:41,730 --> 00:08:42,350
这都无关紧要，

189
00:08:43,270 --> 00:08:45,195
但是现在，当执行引擎回来，

190
00:08:45,195 --> 00:08:46,700
并说给我第二页时，

191
00:08:47,480 --> 00:08:48,080
它不在内存中，

192
00:08:48,080 --> 00:08:49,840
你必须到磁盘上获取它，

193
00:08:50,130 --> 00:08:54,970
但这一次它可能会落在我们的缓冲池中的不同位置，

194
00:08:55,950 --> 00:08:58,040
我们的系统，执行引擎，

195
00:08:58,040 --> 00:09:00,100
缓冲池之上的系统的所有其他部分，

196
00:09:00,480 --> 00:09:05,200
它们显然不应该，不关心它现在在不同的位置。

197
00:09:06,780 --> 00:09:08,705
这和 mmap 不一样，

198
00:09:08,705 --> 00:09:10,570
如果你 mmap 一个文件，内存映射文件，

199
00:09:11,100 --> 00:09:12,305
当你把它带到你的地址空间，

200
00:09:12,305 --> 00:09:15,790
任何时候你跳到那个 mmap 文件地址空间，

201
00:09:16,200 --> 00:09:17,710
你总是会得到相同的页面，

202
00:09:18,030 --> 00:09:20,980
或者操作系统会为你保证这一点，

203
00:09:21,120 --> 00:09:22,895
当你访问它时，它可能不在内存中，

204
00:09:22,895 --> 00:09:25,630
你安装它，获取它，

205
00:09:25,830 --> 00:09:27,430
但它总是在同一个地址空间中。

206
00:09:28,050 --> 00:09:29,630
在我们的系统中，我们不会这样做，

207
00:09:29,630 --> 00:09:31,355
相同的页面可以位于不同的位置，

208
00:09:31,355 --> 00:09:32,830
每次它调入和调出内存时，

209
00:09:34,290 --> 00:09:35,590
因为我们需要这种自由，

210
00:09:35,640 --> 00:09:37,490
因为谁知道内存中会有什么，

211
00:09:37,490 --> 00:09:38,800
下一次我们去取页面时。

212
00:09:40,630 --> 00:09:43,640
这与调用 malloc 有很大不同，

213
00:09:44,020 --> 00:09:44,990
你调用 malloc ，

214
00:09:45,370 --> 00:09:47,000
操作系统为你处理这一切，

215
00:09:47,470 --> 00:09:50,000
数据库系统管理所有这些内存，

216
00:09:50,740 --> 00:09:51,805
因为正如我们所看到的那样，

217
00:09:51,805 --> 00:09:53,190
它总是处于更好的位置，

218
00:09:53,600 --> 00:09:55,500
以做出如何优化这一点的最佳决定。

219
00:09:57,370 --> 00:09:58,485
好的，在今天的议程中，

220
00:09:58,485 --> 00:10:00,740
我们将从高级别讨论缓冲区管理器是什么，

221
00:10:01,000 --> 00:10:03,770
讨论一些我们可以添加的优化，

222
00:10:04,840 --> 00:10:05,760
顺序改变了，

223
00:10:05,760 --> 00:10:07,280
然后我们将讨论缓冲区替换策略，

224
00:10:07,900 --> 00:10:08,955
然后磁盘 I/O 调度，

225
00:10:08,955 --> 00:10:10,280
然后我们会简单地提到，

226
00:10:10,510 --> 00:10:14,820
还有其他内存池在我们的数据库系统中，

227
00:10:14,820 --> 00:10:17,390
可能并不总是得到缓冲池管理器，

228
00:10:17,600 --> 00:10:20,210
可能是某些东西的[临时缓存]。

229
00:10:21,660 --> 00:10:23,410
所以，我将它称为缓冲池管理器，

230
00:10:23,430 --> 00:10:24,790
教科书中称其为缓冲区管理器，

231
00:10:25,290 --> 00:10:28,270
我想 Oracle 可能会把它称为缓冲区缓存，

232
00:10:28,500 --> 00:10:29,680
我们都在讨论相同的东西。

233
00:10:32,220 --> 00:10:33,490
所以，在高级别上，看起来是这样的，

234
00:10:34,140 --> 00:10:37,990
这只是我们从操作系统分配的一个内存区域，

235
00:10:38,550 --> 00:10:42,130
我们将其逻辑地分成固定大小的页面，

236
00:10:42,600 --> 00:10:46,300
根据数据库系统的页面大小，

237
00:10:46,800 --> 00:10:49,085
我们说 Postgres 是 8 千字节，

238
00:10:49,085 --> 00:10:51,580
MySQL 是 16 千字节，可以有压缩大小，

239
00:10:52,080 --> 00:10:52,640
无关紧要，

240
00:10:52,640 --> 00:10:55,060
我们根据这些页面大小对其进行了细分。

241
00:10:56,120 --> 00:11:00,870
然后在我们的缓冲池内存中的一个条目或位置，

242
00:11:01,340 --> 00:11:03,480
我们可以用它来安装页面，

243
00:11:04,100 --> 00:11:05,250
我们把它称为 frame 。

244
00:11:06,420 --> 00:11:07,880
所以，考虑系统启动，

245
00:11:07,880 --> 00:11:09,820
它调用 malloc ，获取一堆内存，

246
00:11:10,230 --> 00:11:12,910
然后说将其拆分，并将其划分为 frame ，

247
00:11:13,260 --> 00:11:19,390
然后，随着数据库系统或执行引擎的其他部分或任何东西开始请求页面，

248
00:11:20,070 --> 00:11:24,430
我们要将这些页面从磁盘复制到内存中，

249
00:11:24,570 --> 00:11:26,080
然后放入其中一个 frame 中，

250
00:11:26,580 --> 00:11:28,145
我们之所以称之为 frame ，

251
00:11:28,145 --> 00:11:29,170
因为我们的术语快用完了，

252
00:11:29,640 --> 00:11:30,560
我不能称它为页面，

253
00:11:30,560 --> 00:11:31,280
也不能称其为块，

254
00:11:31,280 --> 00:11:32,110
因为我们已经使用过了，

255
00:11:32,490 --> 00:11:33,395
不能称之为插槽，

256
00:11:33,395 --> 00:11:34,630
因为我们有 slot array ，

257
00:11:34,950 --> 00:11:36,790
无论出于什么原因，我们称其为 frame 。

258
00:11:38,630 --> 00:11:40,560
好的，有人需要页面一，

259
00:11:40,790 --> 00:11:43,170
然后我们在缓冲池中找到一个空闲的 frame ，

260
00:11:43,310 --> 00:11:45,360
然后将磁盘上的页面复制到内存中，

261
00:11:46,290 --> 00:11:47,030
这里也是一样，

262
00:11:47,030 --> 00:11:48,010
我需要页面三，

263
00:11:48,270 --> 00:11:49,150
找一个空位，

264
00:11:49,290 --> 00:11:50,650
然后把它复制到内存中，

265
00:11:51,550 --> 00:11:53,300
但是，我们在这里可以看到，

266
00:11:53,620 --> 00:11:56,450
页面一和页面三在磁盘上不是连续的，

267
00:11:56,770 --> 00:11:58,280
因为页面二在它们之间，

268
00:11:58,390 --> 00:12:00,350
但当我们将其放入缓冲池并将其放入内存时，

269
00:12:01,090 --> 00:12:03,440
我们可以自由地将其放在我们想要的任何位置，

270
00:12:04,220 --> 00:12:04,980
这无所谓。

271
00:12:07,710 --> 00:12:09,190
所以，现在当出现脏页的时候，

272
00:12:09,270 --> 00:12:13,210
如果我们修改了这些页面中的一个，

273
00:12:14,310 --> 00:12:17,980
我们不需要立即将数据刷新回磁盘，

274
00:12:18,150 --> 00:12:22,030
我们将在期中考试结束后讨论耐久性和恢复，

275
00:12:22,260 --> 00:12:26,740
但这是透写缓存和回写缓存之间的关键区别，

276
00:12:27,120 --> 00:12:28,430
透写缓存在操作系统中，

277
00:12:28,430 --> 00:12:30,850
当你将某些内容写入缓存时，

278
00:12:31,020 --> 00:12:33,280
它也会立即被写出到磁盘，

279
00:12:33,780 --> 00:12:34,755
在回写缓存中，

280
00:12:34,755 --> 00:12:35,870
我们会将其写入内存，

281
00:12:36,760 --> 00:12:38,490
但我们不需要立即将其写回，

282
00:12:38,490 --> 00:12:40,620
我们将在以后的某个时候做这件事，

283
00:12:40,620 --> 00:12:42,860
一个后台线程或一个驱逐策略做这件事。

284
00:12:43,740 --> 00:12:45,305
所以我们今天不会讨论这个，

285
00:12:45,305 --> 00:12:46,420
但是这里会有，

286
00:12:46,680 --> 00:12:48,940
考虑有一个单独的日志文件，预写日志，

287
00:12:49,650 --> 00:12:51,490
它将跟踪我们所做的更改，

288
00:12:52,110 --> 00:12:53,915
我们将确保将它刷新到磁盘，

289
00:12:53,915 --> 00:12:55,120
在我们的脏页刷新之前，

290
00:12:56,540 --> 00:12:58,150
现在我们不必知道这个，

291
00:12:58,150 --> 00:13:01,440
只需记住，即使我们可以更新页面，

292
00:13:01,670 --> 00:13:03,720
我们也不需要立即将它们写回，在内存中。

293
00:13:06,490 --> 00:13:08,715
我说过，我们要使用的内部数据结构，

294
00:13:08,715 --> 00:13:11,150
用来跟踪 frame 中实际内容（的内部数据结构），

295
00:13:11,560 --> 00:13:12,890
将被称为页表，

296
00:13:13,660 --> 00:13:15,105
操作系统也有自己的页表，

297
00:13:15,105 --> 00:13:16,515
这是数据库页表，

298
00:13:16,515 --> 00:13:17,060
这样更好。

299
00:13:18,460 --> 00:13:21,110
它通常是一个固定大小的哈希表，

300
00:13:22,630 --> 00:13:23,715
它只是在跟踪，

301
00:13:23,715 --> 00:13:26,120
这是我所有的 frame ，

302
00:13:26,440 --> 00:13:27,440
由某个 frame ID 标识，

303
00:13:27,910 --> 00:13:31,440
然后这是页面信息，

304
00:13:31,440 --> 00:13:35,570
当前驻留在页面中，

305
00:13:35,860 --> 00:13:38,270
我可以只是指向该页面实际位置的指针，

306
00:13:39,120 --> 00:13:42,410
我们必须用 latch 来保护这个页表，

307
00:13:42,790 --> 00:13:43,830
稍后我会描述一下，

308
00:13:43,830 --> 00:13:45,200
把它想象成一个 mutex ，

309
00:13:45,610 --> 00:13:49,340
它允许我们有多个线程或多个 worker

310
00:13:50,620 --> 00:13:52,760
在同一时间访问页表，

311
00:13:53,110 --> 00:13:54,690
我不想使用术语线程，

312
00:13:54,690 --> 00:13:56,420
最好使用术语 worker ，

313
00:13:56,500 --> 00:13:58,610
因为比如在 Postgres 中，在旧的系统中，

314
00:13:59,110 --> 00:14:01,580
它们不是多线程的，它们是多进程的，

315
00:14:02,020 --> 00:14:04,035
但是想法仍然是一样的，

316
00:14:04,035 --> 00:14:04,770
我们想要确保，

317
00:14:04,770 --> 00:14:06,860
如果有多个 worker 访问和更新东西，

318
00:14:07,030 --> 00:14:08,240
他们没有，

319
00:14:09,130 --> 00:14:11,300
当我们处于临界区时，我们不会破坏东西。

320
00:14:13,290 --> 00:14:15,305
所以，除了跟踪，

321
00:14:15,305 --> 00:14:18,820
这里是指向缓冲池和 frame 中的页面的指针，

322
00:14:19,230 --> 00:14:20,750
我们还将拥有附加元数据，

323
00:14:20,750 --> 00:14:24,340
关于页面在整个系统中的使用方式。

324
00:14:25,300 --> 00:14:27,525
所以，我们首先有的是一个脏标志，

325
00:14:27,525 --> 00:14:30,380
它告诉我们查询是否更新了该页面，

326
00:14:30,400 --> 00:14:31,790
自从上次将页面放入内存以来，

327
00:14:32,620 --> 00:14:34,580
我们还将有一个 Pin 或引用计数器，

328
00:14:35,020 --> 00:14:38,540
用来跟踪 worker 的数量，

329
00:14:39,190 --> 00:14:41,510
它们需要该页面保留在内存中，

330
00:14:42,100 --> 00:14:46,350
因此它不能被驱逐，当我们运行驱逐策略时，

331
00:14:46,350 --> 00:14:48,860
所以每个页面，这里的页面三，

332
00:14:49,090 --> 00:14:52,370
比如在这个给定的时间有一些查询访问它，

333
00:14:52,780 --> 00:14:54,615
所以，在我们的页表中，我们有一个小的计数器，

334
00:14:54,615 --> 00:14:57,990
表示至少有一个 worker 在访问它，

335
00:14:59,740 --> 00:15:04,020
然后现在，如果一个出现了另一个查询，

336
00:15:04,310 --> 00:15:07,500
寻找不在我们的页表中的另一个页面，

337
00:15:08,420 --> 00:15:10,110
我们会放一个 latch 在它上面，保护它，

338
00:15:10,370 --> 00:15:11,550
去取我们需要的数据，

339
00:15:11,630 --> 00:15:12,930
在这种情况下，我们需要页面二，

340
00:15:13,100 --> 00:15:15,660
我们更新缓冲池中的空闲 frame ，

341
00:15:16,130 --> 00:15:18,450
更新页表以指向该缓冲池，

342
00:15:19,010 --> 00:15:21,280
更新任何我们需要了解的元数据，

343
00:15:21,280 --> 00:15:23,300
比如，谁访问了它，

344
00:15:23,300 --> 00:15:25,480
他们最后一次访问它的时间等等，

345
00:15:26,130 --> 00:15:30,610
然后，一旦该查询完成了对页表的更新所需的任何操作，

346
00:15:30,840 --> 00:15:31,840
我们就可以释放 latch ，

347
00:15:32,430 --> 00:15:35,110
将 worker 返回到正在执行的任何操作，

348
00:15:35,430 --> 00:15:38,140
然后现在任何其他查找页面二的 worker

349
00:15:38,280 --> 00:15:39,850
都将在此页表中找到它。

350
00:15:44,030 --> 00:15:44,820
很简单，对吧？

351
00:15:48,550 --> 00:15:50,390
所以我用了 latch 这个词，

352
00:15:51,430 --> 00:15:53,900
故意不说锁，

353
00:15:55,450 --> 00:15:56,330
有人猜猜为什么。

354
00:15:58,890 --> 00:15:59,290
是的。

355
00:15:59,670 --> 00:16:04,190
他说，我们拥有的标准锁，

356
00:16:04,780 --> 00:16:05,955
锁和 latch 是不同的，

357
00:16:05,955 --> 00:16:07,010
不同于谁或什么。

358
00:16:19,570 --> 00:16:20,240
所以他说，

359
00:16:20,590 --> 00:16:25,400
他说， latch 有一些数据库魔力，

360
00:16:25,990 --> 00:16:27,860
这比锁更适合我们的目的。

361
00:16:29,740 --> 00:16:30,290
不完全是。

362
00:16:31,720 --> 00:16:32,120
是的。

363
00:16:35,230 --> 00:16:36,680
他说有锁是用户空间的，

364
00:16:37,450 --> 00:16:39,855
我的意思是，数据库系统在用户空间运行，

365
00:16:39,855 --> 00:16:42,980
但是为了数据库中的逻辑内容，是的。

366
00:16:43,510 --> 00:16:44,670
所以这会让人们绊倒，

367
00:16:44,670 --> 00:16:46,910
当他们来自更像是操作系统背景的时候。

368
00:16:47,650 --> 00:16:49,020
所以，在数据库世界中，

369
00:16:49,020 --> 00:16:50,990
我们有锁和 latch 之间的区别，

370
00:16:51,580 --> 00:16:56,040
锁用来保护我们数据库中的这些更高级别的概念或对象，

371
00:16:56,420 --> 00:16:59,130
一个 tuple ，一张表，一个数据库，

372
00:16:59,720 --> 00:17:01,080
我在这些东西上使用锁，

373
00:17:01,820 --> 00:17:02,740
接下来会发生的是，

374
00:17:02,740 --> 00:17:04,150
我们还没有讨论什么是事务，

375
00:17:04,150 --> 00:17:05,940
但是想象一下，我想要进行多次更新，

376
00:17:06,140 --> 00:17:08,220
就像是 SQL 查询的多次往返，

377
00:17:08,450 --> 00:17:10,500
如果我对某个东西加锁，

378
00:17:10,880 --> 00:17:13,200
我想在事务期间持有它，

379
00:17:14,350 --> 00:17:16,290
因为，他说的是用户空间，

380
00:17:16,290 --> 00:17:20,025
但这就像是应用程序创建了这些锁，

381
00:17:20,025 --> 00:17:22,430
或者数据库系统代表应用程序创建了这些锁，

382
00:17:22,930 --> 00:17:24,410
我们假设他们是愚蠢的，

383
00:17:24,820 --> 00:17:28,190
因此我们需要确保它们不会出现死锁或其他问题，

384
00:17:28,900 --> 00:17:30,705
所以我们必须有这些额外的保护机制，

385
00:17:30,705 --> 00:17:35,270
以确保 Javascript 程序员不会做他们不应该做的事情。

386
00:17:36,170 --> 00:17:39,070
latch 是低级内部原语，

387
00:17:39,070 --> 00:17:43,375
我们使用它来保护数据库系统的关键部分，

388
00:17:43,375 --> 00:17:45,490
这些是数据库系统开发人员使用的，

389
00:17:45,490 --> 00:17:47,970
你项目零中使用了，

390
00:17:48,440 --> 00:17:50,305
你必须使用 mutex ，

391
00:17:50,305 --> 00:17:54,490
所以， latch 就像一个低级别的 mutex 。

392
00:17:55,170 --> 00:17:56,980
因为，这意味着，

393
00:17:57,060 --> 00:18:01,490
latch 被数据库系统开发人员使用，也就是我们，

394
00:18:01,490 --> 00:18:06,500
它不会有我们需要的死锁检测和其他保护机制，

395
00:18:06,500 --> 00:18:08,620
因为如果我们是构建数据库系统的人，

396
00:18:08,730 --> 00:18:11,110
我们需要足够聪明，以确保我们不会有死锁。

397
00:18:12,110 --> 00:18:15,535
所以， latch 意味着快速进出临界区，

398
00:18:15,535 --> 00:18:16,620
做一些事情，然后释放它，

399
00:18:16,790 --> 00:18:19,900
我们需要通过程序员[纪律]，我们必须，

400
00:18:19,900 --> 00:18:22,710
我们必须确保我们不会有死锁，

401
00:18:24,140 --> 00:18:25,030
现在，这是令人困惑的，

402
00:18:25,030 --> 00:18:27,900
因为在 C++ 标准库中，

403
00:18:28,190 --> 00:18:30,150
他们也使用术语 latch ，

404
00:18:30,350 --> 00:18:31,830
但只是一个 countdown barrier ，

405
00:18:31,970 --> 00:18:33,280
我们不想这样，我们不需要那个，

406
00:18:33,280 --> 00:18:34,680
我们要轮询 latch ，

407
00:18:34,880 --> 00:18:36,205
下周，我们会更多地看到这个，

408
00:18:36,205 --> 00:18:38,760
当我们讨论 B+ 树的索引并发控制时，

409
00:18:40,400 --> 00:18:42,820
但就目前而言，你可以将其视为 mutex ，

410
00:18:44,560 --> 00:18:45,735
我们不想使用操作系统的 mutex ，

411
00:18:45,735 --> 00:18:46,520
它有其他问题，

412
00:18:46,540 --> 00:18:47,360
我们稍后会讲到。

413
00:18:50,450 --> 00:18:52,000
好的，另一个重要的区别，

414
00:18:52,000 --> 00:18:52,710
我已经说过，

415
00:18:52,880 --> 00:18:54,360
在页面目录和页表之间（的区别）。

416
00:18:54,680 --> 00:18:59,230
页面目录只是磁盘的驻留映射，

417
00:18:59,230 --> 00:19:04,650
在页面 id 与它们在物理磁盘上、实际文件上的位置之间，

418
00:19:05,390 --> 00:19:08,760
但页表将是内存中的短暂映射，

419
00:19:09,170 --> 00:19:11,760
我们使用它来标识给定的页面 id ，

420
00:19:12,170 --> 00:19:14,550
这是 frame 实际所在的位置，

421
00:19:14,810 --> 00:19:16,390
如果它不在我们的页表中，

422
00:19:16,390 --> 00:19:17,935
我们知道我们必须在页面目录中查找，

423
00:19:17,935 --> 00:19:19,530
以找到它在磁盘上的位置，

424
00:19:19,730 --> 00:19:21,990
并将其带入进来。

425
00:19:23,500 --> 00:19:26,570
所以，在大多数情况下，查询将命中页表，

426
00:19:26,740 --> 00:19:28,730
但只有在页表表示不存在的情况下，

427
00:19:28,960 --> 00:19:31,230
然后需要有一些机制，

428
00:19:31,230 --> 00:19:32,280
比如磁盘调度器或其他东西，

429
00:19:32,280 --> 00:19:34,100
比如，好的，让我看看页面目录，

430
00:19:34,330 --> 00:19:36,075
让我去取磁盘上的页面，

431
00:19:36,075 --> 00:19:37,580
然后把它放到页表中。

432
00:19:38,590 --> 00:19:38,990
好的？

433
00:19:40,560 --> 00:19:42,910
到目前为止，我向你展示的是一个基本的页表，

434
00:19:43,410 --> 00:19:45,550
这是一个哈希表，一些额外的元数据，

435
00:19:46,140 --> 00:19:47,140
如果页面在那里，

436
00:19:47,820 --> 00:19:48,700
对于给定的页面 id ，

437
00:19:48,810 --> 00:19:50,080
你得到指向它的指针，

438
00:19:50,160 --> 00:19:51,020
如果它不在那里，

439
00:19:51,020 --> 00:19:53,380
有某种机制可以从磁盘获取它，

440
00:19:53,400 --> 00:19:55,570
然后将其安装到一个空闲的 frame 中，

441
00:19:55,950 --> 00:19:59,090
然后页表具有该条目。

442
00:19:59,920 --> 00:20:03,385
但这将是一个巨大的瓶颈，

443
00:20:03,385 --> 00:20:06,630
除非我们聪明地利用我们所知道的信息，

444
00:20:06,980 --> 00:20:09,330
关于数据库系统中发生的事情，

445
00:20:12,290 --> 00:20:13,135
对于我们来说，我们要决定，

446
00:20:13,135 --> 00:20:14,200
如何分配东西，

447
00:20:14,200 --> 00:20:18,390
决定谁得到什么页面，什么时间，什么位置，

448
00:20:19,010 --> 00:20:20,610
以及我们决定如何驱逐东西，

449
00:20:21,020 --> 00:20:22,975
因为如果我们不利用这些信息，

450
00:20:22,975 --> 00:20:24,630
我们知道我们的查询想要做什么，

451
00:20:24,800 --> 00:20:25,960
我们的数据是什么样子，

452
00:20:25,960 --> 00:20:27,030
我们的访问模式是什么，

453
00:20:27,620 --> 00:20:28,980
那么我们并不比操作系统更好。

454
00:20:29,680 --> 00:20:32,100
操作系统没有看到我们的数据系统内部发生任何事情，

455
00:20:32,510 --> 00:20:37,260
所以，如果我们只是盲目地接受请求，然后把它们拿出来，

456
00:20:38,060 --> 00:20:40,580
我们并不比操作系统好多少。

457
00:20:41,950 --> 00:20:45,380
所以，我们将讨论一些技术，一些优化，

458
00:20:47,710 --> 00:20:50,510
这将激励我们为什么需要编写自己的缓冲池管理器，

459
00:20:50,740 --> 00:20:51,920
为什么我们不想要使用操作系统，

460
00:20:53,020 --> 00:20:55,580
它将是一些策略的组合，

461
00:20:55,810 --> 00:20:58,790
影响所有同时运行的查询（的策略），

462
00:21:00,610 --> 00:21:05,000
或者，它可能只会帮助单个查询本身，

463
00:21:05,290 --> 00:21:08,210
可能不一定担心同时运行的其他查询，

464
00:21:08,560 --> 00:21:11,970
但我们可以隔离对该查询所做的决策，

465
00:21:11,970 --> 00:21:15,790
以便它们不会影响其他查询。

466
00:21:16,820 --> 00:21:20,250
我不会说这些方法中的一种会比另一种更好，

467
00:21:20,690 --> 00:21:22,500
但你会在我们进行的过程中看到，

468
00:21:23,440 --> 00:21:26,750
所有主流的数据库系统都将使用它们的某种组合，

469
00:21:26,950 --> 00:21:30,110
或者它们中的一些，或者大多数，

470
00:21:30,490 --> 00:21:34,280
我不能说哪一个是首先要实现的最重要的一个，

471
00:21:34,630 --> 00:21:37,010
但是随着我们进行，我们将会看到。

472
00:21:39,220 --> 00:21:40,500
好的。所以我要说的是，

473
00:21:41,330 --> 00:21:42,360
使用多缓冲池，

474
00:21:42,500 --> 00:21:44,035
这可能是我说的第一个，

475
00:21:44,035 --> 00:21:44,490
正如我所说的，

476
00:21:44,600 --> 00:21:46,680
首先，多缓冲池是明显要做的，

477
00:21:47,180 --> 00:21:48,060
我们看看它是什么样子的，

478
00:21:48,200 --> 00:21:51,330
预取是更复杂的，扫描共享，然后是缓冲池旁路。

479
00:21:53,630 --> 00:21:56,910
好的，我在开头分享的玩具例子，

480
00:21:57,020 --> 00:21:59,520
我们说只有一个页表，一组 frame ，

481
00:21:59,750 --> 00:22:02,160
整个系统就是这样。

482
00:22:02,750 --> 00:22:06,490
但又说回来，因为有多个 worker 同时运行，

483
00:22:06,490 --> 00:22:08,850
我们必须使用这些 latch 来保护数据结构，

484
00:22:09,260 --> 00:22:13,860
对于大量 CPU 核心或同时运行的大量 worker ，

485
00:22:14,210 --> 00:22:17,690
这些 latch 将成为瓶颈。

486
00:22:17,860 --> 00:22:19,580
我们可以，因为它是固定的，

487
00:22:20,230 --> 00:22:21,620
假设页表是固定大小，

488
00:22:22,270 --> 00:22:24,170
我们不必为整个页表设置 latch ，

489
00:22:24,700 --> 00:22:29,300
为单个页面或哈希表中的位置设置 latch ，

490
00:22:29,470 --> 00:22:30,120
但即使这样，

491
00:22:30,120 --> 00:22:33,290
如果每个人都想获取相同的少量页面，

492
00:22:33,880 --> 00:22:37,530
那么这些 latch 将成为一个瓶颈。

493
00:22:38,510 --> 00:22:44,245
所以缓解这种争用点的一个简单方法是，

494
00:22:44,245 --> 00:22:45,570
拥有多个缓冲池，

495
00:22:46,200 --> 00:22:47,780
所以我仍然分配相同数量的内存，

496
00:22:48,070 --> 00:22:49,880
所以我必须在启动时告知数据库系统，

497
00:22:49,930 --> 00:22:52,400
我想要 10GB 的内存，对我的缓冲池，

498
00:22:52,780 --> 00:22:54,135
但是我要用这 10GB ，

499
00:22:54,135 --> 00:22:58,820
我可以把它分成大小相等的块，

500
00:22:59,400 --> 00:23:01,640
然后，现在它们每个都有一个单独的页表。

501
00:23:04,360 --> 00:23:05,480
它还确保，

502
00:23:05,650 --> 00:23:10,410
对于特定数据结构上的特定访问模式，

503
00:23:10,410 --> 00:23:11,780
抱歉，数据库中的特定对象，

504
00:23:12,670 --> 00:23:14,000
我可以有不同的策略，

505
00:23:14,080 --> 00:23:16,010
可以影响一个缓冲池或另一个，

506
00:23:16,300 --> 00:23:18,650
根据我知道对象将被使用的方式。

507
00:23:19,600 --> 00:23:21,060
例如，在 DB2 中，

508
00:23:21,255 --> 00:23:25,730
DB2 可能具有最复杂的缓冲池管理配置，

509
00:23:26,290 --> 00:23:28,460
你可以定义一个表空间，

510
00:23:30,190 --> 00:23:31,310
与名称空间类似，

511
00:23:31,870 --> 00:23:33,830
并且由给定的缓冲池支持，

512
00:23:33,970 --> 00:23:36,650
你可以设置该缓冲池的页面大小，

513
00:23:36,850 --> 00:23:40,550
并且你可以知道该缓冲池将管理哪些表或哪些索引。

514
00:23:41,440 --> 00:23:46,790
假设你有一个主要用于随机访问的表，

515
00:23:47,140 --> 00:23:48,110
你可以有一些策略，

516
00:23:48,130 --> 00:23:52,580
驱逐政策基于最好的随机访问，

517
00:23:52,870 --> 00:23:54,180
然后，你有另一个缓冲池，

518
00:23:54,180 --> 00:23:56,130
用于其他进行顺序扫描的表，

519
00:23:56,130 --> 00:23:58,245
所以，你对该顺序扫描有不同的缓冲区策略，

520
00:23:58,245 --> 00:24:00,740
也许可以使用更大的页面大小。

521
00:24:01,630 --> 00:24:03,870
据我所知， DB2 是唯一一个允许你这样做的，

522
00:24:03,870 --> 00:24:06,170
我还没有看到 Postgres ， MySQL 肯定不能做这个，

523
00:24:07,780 --> 00:24:09,855
我不知道其他企业的情况，

524
00:24:09,855 --> 00:24:12,800
但像 DB2 是非常复杂的。

525
00:24:13,520 --> 00:24:16,660
同样，这允许你定义缓冲池管理，

526
00:24:16,890 --> 00:24:19,420
针对对象的确切使用方式。

527
00:24:21,370 --> 00:24:22,005
现在的问题是，

528
00:24:22,005 --> 00:24:27,080
如何在运行时发现应该使用哪个缓冲池管理器。

529
00:24:28,090 --> 00:24:29,130
让我们举一个非常简单的例子，

530
00:24:29,130 --> 00:24:30,290
这里我有两个缓冲池，

531
00:24:31,450 --> 00:24:33,170
所以我可以做的第一件事是，

532
00:24:33,280 --> 00:24:34,755
就像我说的，在 DB2 案例中，

533
00:24:34,755 --> 00:24:38,730
我可以分配一个缓冲池来支持给定的对象，

534
00:24:38,730 --> 00:24:39,920
根据某种标识符，

535
00:24:40,120 --> 00:24:43,440
比如表 1 2 3 等等，这是缓冲区一，

536
00:24:43,440 --> 00:24:45,590
所有其他的表是缓冲区二。

537
00:24:46,470 --> 00:24:48,880
所以，在运行时，当我有一个请求时，

538
00:24:48,960 --> 00:24:50,260
这显然不是 SQL ，

539
00:24:50,430 --> 00:24:53,465
但我通过索引查找，

540
00:24:53,465 --> 00:24:55,540
我想我要查找记录一二三，

541
00:24:56,260 --> 00:24:59,790
我们在前面看到了如何将记录 ID 分解为其单独的组成部分，

542
00:25:00,260 --> 00:25:02,430
通常如页面 ID 或插槽编号，

543
00:25:02,990 --> 00:25:04,030
但是对于 SQL Server ，

544
00:25:04,030 --> 00:25:07,380
它也有文件号或对象 ID ，

545
00:25:08,360 --> 00:25:10,260
我们可以对记录 ID 使用这个，

546
00:25:11,080 --> 00:25:12,025
然后你会查看说，

547
00:25:12,025 --> 00:25:16,540
好的，对象 4 5 6 ，它由缓冲区一管理，

548
00:25:16,540 --> 00:25:18,840
然后将请求发送到那个缓冲池，

549
00:25:19,450 --> 00:25:22,670
而对其他对象的所有请求可能会结束到另一个缓冲池，

550
00:25:22,720 --> 00:25:23,840
我已经将它们隔离，

551
00:25:24,130 --> 00:25:26,960
以便它们之间的最后争用较少。

552
00:25:29,110 --> 00:25:29,850
最简单的方法，

553
00:25:29,850 --> 00:25:32,310
MySQL 所做的那样，

554
00:25:32,310 --> 00:25:33,710
你只需获取记录 ID ，

555
00:25:34,150 --> 00:25:37,250
对其进行散列，修改你拥有的缓冲池管理器编号，

556
00:25:37,600 --> 00:25:40,710
这会告诉你要转到哪个（管理器），

557
00:25:41,870 --> 00:25:42,480
很简单。

558
00:25:42,800 --> 00:25:43,200
是的。

559
00:25:43,430 --> 00:25:48,995
是的，所以他说的问题是，

560
00:25:48,995 --> 00:25:52,840
你是否必须静态地分配每个缓冲池有多少内存，

561
00:25:53,430 --> 00:25:58,055
是的，在 Postgres MySQL 中，在大多数系统中，

562
00:25:58,055 --> 00:25:59,855
你无法更改缓冲池的大小，

563
00:25:59,855 --> 00:26:01,630
如果不重新启动整个系统，

564
00:26:02,400 --> 00:26:05,740
事实上，所有的开源系统都有这个限制，

565
00:26:06,120 --> 00:26:08,045
商业系统可以是一种聪明的，

566
00:26:08,045 --> 00:26:10,660
比如，我认为在 Oracle 中，

567
00:26:10,660 --> 00:26:12,030
你可以增加缓冲池大小，

568
00:26:12,560 --> 00:26:14,125
它将分配内存，

569
00:26:14,125 --> 00:26:19,080
然后缓慢增加并将页面从一页迁移到下一页，

570
00:26:19,250 --> 00:26:20,065
这是一件棘手的事情，

571
00:26:20,065 --> 00:26:22,230
但大多数系统都是静态分配的。

572
00:26:30,340 --> 00:26:32,390
是的，所以他的问题是，

573
00:26:32,470 --> 00:26:34,860
这是否意味着你潜在地浪费内存，

574
00:26:34,860 --> 00:26:36,290
如果你按表分区，

575
00:26:37,540 --> 00:26:39,080
例如，如果我，

576
00:26:39,430 --> 00:26:40,490
如果我创建了一个新的缓冲池，

577
00:26:40,630 --> 00:26:42,440
假设它有 10GB ，

578
00:26:42,460 --> 00:26:43,880
我说你要管理这个表，

579
00:26:44,350 --> 00:26:45,980
但我没有在那个表中放任何数据，

580
00:26:46,270 --> 00:26:47,210
这是在浪费空间吗，

581
00:26:47,620 --> 00:26:48,020
是的，

582
00:26:49,250 --> 00:26:51,360
但是数据库系统做的是你想做的，

583
00:26:52,250 --> 00:26:54,895
人类是愚蠢的，

584
00:26:54,895 --> 00:26:55,560
我是说，这里没有，

585
00:26:56,870 --> 00:26:58,530
是的，因为问题，它不知道，

586
00:26:58,760 --> 00:27:01,770
你在想，好的，只在需要需求的时候分配它，

587
00:27:02,060 --> 00:27:08,290
但是就像，为了容纳愚蠢的人而做出的工程努力的数量，

588
00:27:08,520 --> 00:27:10,390
那样的话可能就不值得了。

589
00:27:10,530 --> 00:27:11,810
如果你使用的是 DB2 ，

590
00:27:11,810 --> 00:27:12,910
理论上，你知道，

591
00:27:13,290 --> 00:27:15,335
如果你调用 create buffer pool 命令来执行它，

592
00:27:15,335 --> 00:27:18,250
你应该知道自己在做什么。

593
00:27:23,460 --> 00:27:25,265
好的，在我看来，

594
00:27:25,265 --> 00:27:26,120
我想我所说的，

595
00:27:26,120 --> 00:27:27,880
这是你做的第一个优化，

596
00:27:28,140 --> 00:27:29,590
以扩大你的缓冲池管理器，

597
00:27:29,760 --> 00:27:31,600
因为这不是那么多的工作，

598
00:27:31,770 --> 00:27:34,330
哈希可能也是最容易做的，

599
00:27:36,280 --> 00:27:37,965
因为没有中央数据结构可以说，

600
00:27:37,965 --> 00:27:39,915
好的，对于这个对象，转到这个，

601
00:27:39,915 --> 00:27:41,390
你只需对它进行哈希，就完成了。

602
00:27:44,320 --> 00:27:46,190
我们可以做的下一个优化是预取，

603
00:27:47,550 --> 00:27:48,910
操作系统也做预取，

604
00:27:50,310 --> 00:27:52,630
我们将看到，在简单的情况下，

605
00:27:52,680 --> 00:27:54,450
当你在执行顺序扫描时，

606
00:27:54,450 --> 00:27:56,230
我们将看到一个无法执行预取的情况。

607
00:27:56,520 --> 00:27:57,700
所以基本的想法是，

608
00:27:58,540 --> 00:27:59,820
如果你运行一个查询，

609
00:28:00,590 --> 00:28:04,320
它必须开始访问表中的数据，

610
00:28:05,570 --> 00:28:06,960
它将打开一个 cursor ，

611
00:28:07,460 --> 00:28:10,380
开始逐个扫描页面，

612
00:28:11,630 --> 00:28:14,065
所以，假设在我们的示例中，

613
00:28:14,065 --> 00:28:15,330
我们的缓冲池是空的，

614
00:28:15,680 --> 00:28:19,500
所以，它看到的第一个页面是 page0 ，

615
00:28:19,700 --> 00:28:20,760
它不在缓冲池中，

616
00:28:20,930 --> 00:28:22,890
所以，我们只是去复制并把它放进去，

617
00:28:23,430 --> 00:28:24,245
然后随着我们扫描，

618
00:28:24,245 --> 00:28:26,020
我们需要 page1 ， page1 不在那里，

619
00:28:26,340 --> 00:28:28,150
所以继续并复制它，

620
00:28:28,770 --> 00:28:30,725
但现在数据库系统可以聪明地说，

621
00:28:30,725 --> 00:28:33,680
好的，你已经读取 page0 page1 ，

622
00:28:33,680 --> 00:28:37,840
很可能你会读 page2, page3 等等，

623
00:28:38,460 --> 00:28:40,630
所以让我预取这些（页面），

624
00:28:41,870 --> 00:28:45,000
当数据库系统处理 page1 时，

625
00:28:46,090 --> 00:28:48,830
好的，去拿 page2 page3 ，把它放进去，

626
00:28:49,450 --> 00:28:53,420
这样当你处理完 page1 时，

627
00:28:53,710 --> 00:28:54,690
你来到 page2 ，

628
00:28:54,690 --> 00:28:56,000
你正在寻找的页面，

629
00:28:56,680 --> 00:29:00,770
你需要的下一页已经在那里了，

630
00:29:00,770 --> 00:29:02,920
从头到尾一直这样做。

631
00:29:03,060 --> 00:29:04,900
我们还没有讨论如何执行查询，

632
00:29:05,130 --> 00:29:06,970
但通常它的工作方式是，

633
00:29:07,530 --> 00:29:08,950
你请求一个页面，

634
00:29:09,480 --> 00:29:10,810
它在其中有一堆 tuple ，

635
00:29:10,980 --> 00:29:14,650
你在这 tuple 中的数据上进行某种计算，

636
00:29:14,940 --> 00:29:16,090
然后当你完成后，

637
00:29:16,620 --> 00:29:17,620
转到下一页，

638
00:29:18,510 --> 00:29:21,850
当你沿着查找计划树的叶子节点进行扫描时。

639
00:29:22,440 --> 00:29:25,370
所以，我们并不是盲目地翻阅页面，

640
00:29:25,870 --> 00:29:27,440
然后说，获取，获取，获取，获取，

641
00:29:27,910 --> 00:29:30,500
它得到一些思考时间，做一些计算，

642
00:29:31,180 --> 00:29:32,460
然后去拿下一页，

643
00:29:32,460 --> 00:29:34,635
所以思考时间就是数据库系统说的，

644
00:29:34,635 --> 00:29:35,760
我有一些时间继续，

645
00:29:35,760 --> 00:29:38,950
去预取你需要的东西。

646
00:29:39,960 --> 00:29:41,360
我这里没有图表，

647
00:29:41,360 --> 00:29:45,755
但这就是为什么我们以前有那个[钉住]机制，

648
00:29:45,755 --> 00:29:47,860
我显然不想取 page1 ，

649
00:29:48,540 --> 00:29:50,690
然后数据库系统说，在后台线程中，

650
00:29:50,690 --> 00:29:53,020
好的，让我去预取 page3 和 page2 ，

651
00:29:53,220 --> 00:29:54,695
它会交换 page1 ，

652
00:29:54,695 --> 00:29:56,240
当你仍然访问它时，

653
00:29:56,240 --> 00:29:59,230
[钉住]机制将防止这种情况发生。

654
00:30:00,290 --> 00:30:00,690
是的。

655
00:30:07,020 --> 00:30:07,520
这个问题，

656
00:30:07,520 --> 00:30:08,860
说得好，谢谢，

657
00:30:09,060 --> 00:30:09,790
他的问题是，

658
00:30:10,140 --> 00:30:13,690
不同的缓冲池是否可能保存相同的页面，

659
00:30:13,920 --> 00:30:14,320
不会。

660
00:30:14,940 --> 00:30:16,365
它总是多一个[匹配]，

661
00:30:16,365 --> 00:30:18,110
每个页面只能存在于一个缓冲池中，

662
00:30:18,520 --> 00:30:20,660
因为考虑一下如果你允许这个会发生什么，

663
00:30:23,070 --> 00:30:28,090
好的，你可以把页表指向相同的页面，

664
00:30:28,860 --> 00:30:30,310
不同的页面指向相同的页面，

665
00:30:30,540 --> 00:30:32,345
但取决于元数据的位置，

666
00:30:32,345 --> 00:30:35,380
如引用计数器、[插针]标记和类似的东西，

667
00:30:36,780 --> 00:30:38,315
如果这是单独的页面，

668
00:30:38,315 --> 00:30:40,340
那么一个缓冲池可能会说，

669
00:30:40,340 --> 00:30:41,525
好的，没有人访问它了，

670
00:30:41,525 --> 00:30:42,700
让我把它交换出去，

671
00:30:42,780 --> 00:30:44,825
但另一个页表被固定了，

672
00:30:44,825 --> 00:30:45,640
你可能会错过它。

673
00:30:46,500 --> 00:30:47,650
所以，出于这个原因，

674
00:30:48,690 --> 00:30:49,960
这是一对一的匹配。

675
00:30:52,430 --> 00:30:53,200
这是很好的观点，谢谢。

676
00:30:54,490 --> 00:30:54,840
是的。

677
00:30:54,840 --> 00:30:59,120
这个问题是，

678
00:30:59,120 --> 00:31:00,880
pin counter 和 latch 之间的关系是什么，

679
00:31:01,050 --> 00:31:02,680
一个 pin counter 只表示，

680
00:31:03,360 --> 00:31:06,570
这里有一些，

681
00:31:08,870 --> 00:31:10,885
所以， pin counter 表示，

682
00:31:10,885 --> 00:31:14,130
有一些 worker 正在访问这个页面，

683
00:31:14,510 --> 00:31:15,775
但我现在不在页表中，

684
00:31:15,775 --> 00:31:17,490
我正在做的，

685
00:31:17,600 --> 00:31:19,440
我会将指针指向页面，

686
00:31:19,700 --> 00:31:20,760
返回到我的原始图表。

687
00:31:25,050 --> 00:31:25,870
好的，回到这里，

688
00:31:26,250 --> 00:31:28,280
所以我不在页表上，

689
00:31:28,280 --> 00:31:29,750
但就像这个说的，

690
00:31:29,750 --> 00:31:30,670
给我页面二，

691
00:31:31,080 --> 00:31:32,950
我在页表中使用 latch ，

692
00:31:33,210 --> 00:31:36,100
去获取指向那个页面的指针，

693
00:31:37,020 --> 00:31:40,370
然后在我把指针放回我的执行引擎之前，

694
00:31:40,480 --> 00:31:41,420
我把它[钉住]，

695
00:31:42,390 --> 00:31:43,805
因为现在我不在页表中，

696
00:31:43,805 --> 00:31:46,520
因为 latch 保护数据结构，

697
00:31:46,520 --> 00:31:47,620
但我不在数据结构中，

698
00:31:47,940 --> 00:31:49,630
但我有一个对页面的引用，

699
00:31:49,950 --> 00:31:51,340
所以， pin 应该表明，

700
00:31:51,480 --> 00:31:52,810
有人读取这个页面，

701
00:31:53,160 --> 00:31:54,815
然后当我完成它时，

702
00:31:54,815 --> 00:31:57,550
我可以递减引用计数器，

703
00:31:57,720 --> 00:32:00,490
这可能会解锁或释放 pin ，

704
00:32:01,110 --> 00:32:03,490
然后现在缓冲池管理器可以决定，

705
00:32:03,540 --> 00:32:05,770
好的，我知道对于这个页面二，

706
00:32:06,000 --> 00:32:06,935
没有人将其钉住，

707
00:32:06,935 --> 00:32:07,775
没有人引用它，

708
00:32:07,775 --> 00:32:09,040
所以我可以自由地驱逐它。

709
00:32:10,160 --> 00:32:11,770
所以， latch 保护数据结构，

710
00:32:11,770 --> 00:32:13,320
pin 保护页面。

711
00:32:13,610 --> 00:32:13,915
是的。

712
00:32:20,740 --> 00:32:22,310
好的，问题是。

713
00:32:23,560 --> 00:32:25,610
页表是从缓冲池中分离出来的？

714
00:32:26,020 --> 00:32:26,990
它就是缓冲池。

715
00:32:27,310 --> 00:32:28,010
我想是。

716
00:32:29,270 --> 00:32:30,760
是的，这是一张图表，

717
00:32:30,760 --> 00:32:34,280
但它在这个盒子中，这个怎么样。

718
00:32:35,620 --> 00:32:37,820
这些是 frame ，

719
00:32:38,590 --> 00:32:40,550
这里还有一些其他的页表数据结构。

720
00:32:54,290 --> 00:32:55,170
所以，他的问题是，

721
00:32:55,610 --> 00:32:58,470
缓冲池管理器是否需要访问查询计划，

722
00:32:58,610 --> 00:33:01,530
不，因为我们有这些层，

723
00:33:01,730 --> 00:33:02,970
但你可以给它发提示，

724
00:33:03,800 --> 00:33:05,170
BusTub 不支持这些提示，

725
00:33:05,170 --> 00:33:06,010
但你可以向它发送提示，

726
00:33:06,010 --> 00:33:07,410
比如，我正在访问这个页面，

727
00:33:09,350 --> 00:33:12,030
这是我接下来要访问的页面，

728
00:33:12,440 --> 00:33:14,130
是的，然后你说了一些关于静态的事情？

729
00:33:19,460 --> 00:33:23,320
从[静态]角度看，可能知道什么？

730
00:33:34,560 --> 00:33:35,530
好的，所以他的问题是，

731
00:33:36,540 --> 00:33:37,540
如果我有一个 SELECT 查询，

732
00:33:39,540 --> 00:33:41,360
正在计算预取，

733
00:33:41,360 --> 00:33:42,430
也许这是你真正想问的，

734
00:33:43,260 --> 00:33:44,590
这必须对执行引擎，

735
00:33:46,000 --> 00:33:47,900
缓冲池管理器不知道，

736
00:33:50,610 --> 00:33:53,080
它只是，是的，这是一种[部门]职责，

737
00:33:53,160 --> 00:33:55,780
比如[]管理器不应该推断，

738
00:33:56,250 --> 00:33:59,530
比如对于这个表上的查询计划，我将要读取的页面，

739
00:33:59,550 --> 00:34:00,670
这一切都归结到下面，

740
00:34:00,900 --> 00:34:02,380
因为你也想过，那是，

741
00:34:02,490 --> 00:34:04,715
执行必须直到需要读取哪一页，

742
00:34:04,715 --> 00:34:05,470
因为这样才能读取它们，

743
00:34:06,170 --> 00:34:08,820
所以所有的逻辑都在系统的这一部分，

744
00:34:08,930 --> 00:34:09,900
我们将在两周内讨论。

745
00:34:13,430 --> 00:34:16,860
是的，执行引擎应该会说，

746
00:34:17,090 --> 00:34:18,895
我现在正在取回 page1 ，

747
00:34:18,895 --> 00:34:21,970
但顺便说一句，我也会取回 page2 和 page3 ，

748
00:34:21,970 --> 00:34:22,495
因为想象一下，

749
00:34:22,495 --> 00:34:23,940
你可以有一个，

750
00:34:25,430 --> 00:34:27,780
比如在你的 SELECT 语句中，在这个查询里，

751
00:34:27,920 --> 00:34:30,390
你可以有一个 LIMIT 10 ，

752
00:34:30,470 --> 00:34:31,560
没有 WHERE 语句，

753
00:34:31,970 --> 00:34:35,140
在第一页中，我得到五个 tuple ，

754
00:34:35,140 --> 00:34:36,000
在第二页中，

755
00:34:36,380 --> 00:34:37,980
或者在 page0 中，我获得五个 tuple ，

756
00:34:38,060 --> 00:34:39,870
在 page1 ，我得到五个 tuple ，

757
00:34:40,580 --> 00:34:42,205
因此，我知道我必须读取更多页面，

758
00:34:42,205 --> 00:34:44,700
这样你能提前发送提示或类似的东西。

759
00:34:46,310 --> 00:34:48,970
再次，这就是拥有像 SQL 这样的声明性语言的好处，

760
00:34:48,970 --> 00:34:52,575
你可以提前知道要做什么，

761
00:34:52,575 --> 00:34:54,770
至少在高级别上，

762
00:34:54,910 --> 00:34:58,850
你有足够的信息来做出这样的决定。

763
00:35:10,400 --> 00:35:11,460
所以问题是，

764
00:35:12,080 --> 00:35:13,470
你是否永远不预取页面，

765
00:35:14,720 --> 00:35:16,560
除非你绝对确定你会需要它们，

766
00:35:16,970 --> 00:35:17,790
也许这就是你要问的？

767
00:35:19,645 --> 00:35:23,020
事实上，我不知道他们有多激进，是的，

768
00:35:27,040 --> 00:35:28,905
商业系统在这方面做得要好得多，

769
00:35:28,905 --> 00:35:30,410
他们显然是闭源的，

770
00:35:34,130 --> 00:35:36,840
所以，对于索引扫描来说，计划扫描非常容易，

771
00:35:37,250 --> 00:35:37,860
下一张幻灯片，

772
00:35:38,740 --> 00:35:40,830
这个问题也可能有点棘手，

773
00:35:40,910 --> 00:35:44,570
因为，你可能无法预取，

774
00:35:45,450 --> 00:35:49,840
如果不跟着页面走，

775
00:35:50,220 --> 00:35:51,815
你可能就不会跳到前面去，

776
00:35:51,815 --> 00:35:54,710
我认为在索引扫描中，预取稍微保守一些，

777
00:35:54,710 --> 00:35:58,210
顺序扫描，你可以跳得更远。

778
00:36:00,080 --> 00:36:00,910
我们还没有讨论，

779
00:36:00,910 --> 00:36:03,340
还有一大堆其他因素，

780
00:36:03,340 --> 00:36:05,365
总是在数据库中，

781
00:36:05,365 --> 00:36:09,400
比如，有多版本控制，

782
00:36:09,400 --> 00:36:10,710
所以谁知道是不是，

783
00:36:10,730 --> 00:36:13,075
我要读的下一个页面有 10 个 tuple ，

784
00:36:13,075 --> 00:36:14,970
但可能只有三个是可见的，

785
00:36:15,290 --> 00:36:15,840
这很复杂。

786
00:36:18,380 --> 00:36:20,475
好的，回到这里，

787
00:36:20,475 --> 00:36:22,370
顺序扫描，操作系统可以在某种程度上做到这个，

788
00:36:23,080 --> 00:36:24,350
假设你的页面是连续的，

789
00:36:24,520 --> 00:36:27,290
操作系统预读可以在某种程度上解决这一问题，

790
00:36:27,640 --> 00:36:29,300
它不能做的是，

791
00:36:29,320 --> 00:36:34,280
推断页面物理表示的逻辑数据结构，

792
00:36:35,050 --> 00:36:36,470
并根据它进行预取，

793
00:36:37,240 --> 00:36:39,615
因为它不知道 B+ 树是什么，

794
00:36:39,615 --> 00:36:40,710
不知道哈希表是什么，

795
00:36:40,710 --> 00:36:42,020
至少在页面级别，

796
00:36:42,510 --> 00:36:44,110
但我们能，因为我们是数据库系统，

797
00:36:44,370 --> 00:36:46,840
我们真正运行它。

798
00:36:48,080 --> 00:36:48,835
假设我有一个查询，

799
00:36:48,835 --> 00:36:52,320
比如 SELECT * FORM A WHERE val BETWEEN 100 AND 250 ，

800
00:36:52,790 --> 00:36:57,480
我可以通过做索引扫描来实现这个，

801
00:36:58,160 --> 00:36:59,410
我们还没有讨论过 B+ 树，

802
00:36:59,410 --> 00:37:00,820
但是，它是一种树数据结构，

803
00:37:00,820 --> 00:37:02,340
对于这门课上的任何人来说都不应该是陌生的，

804
00:37:02,720 --> 00:37:04,830
然后假设沿着叶节点，

805
00:37:05,120 --> 00:37:09,020
基于键对值进行排序。

806
00:37:09,820 --> 00:37:13,010
所以，为了运行这个特定的查询，

807
00:37:13,240 --> 00:37:14,630
我必须对根节点进行排序，

808
00:37:14,650 --> 00:37:16,290
这是 page0 ，我去拿它，

809
00:37:16,290 --> 00:37:18,380
把它放到我的数据库里，放到我的缓冲池里，

810
00:37:18,880 --> 00:37:20,990
然后我向下走到树的这一边，

811
00:37:21,100 --> 00:37:24,140
我得到 page1 ，把它放到我的缓冲池里，

812
00:37:24,580 --> 00:37:27,020
但现在我要跳到这里的这个叶节点，

813
00:37:27,370 --> 00:37:29,715
因为我有这个 WHERE 子句，

814
00:37:29,715 --> 00:37:33,590
要读取这么多记录，

815
00:37:34,210 --> 00:37:38,420
我知道我至少要到 page5 ，

816
00:37:38,950 --> 00:37:42,470
所以，我得到，抱歉，我得到 page3 ，

817
00:37:42,550 --> 00:37:46,010
但也可以潜在地预取 page5 ，

818
00:37:46,840 --> 00:37:49,675
但是同样，操作系统不能做到这个，不能知道这个，

819
00:37:49,675 --> 00:37:52,670
因为， page3 和 page5 不是连续的，

820
00:37:53,760 --> 00:37:54,820
数据库系统知道，

821
00:37:54,840 --> 00:37:58,150
因为它知道如果我至少获得了 index-page3 ，

822
00:37:58,320 --> 00:38:01,690
我就有一个兄弟指针，一个页面 ID ，

823
00:38:01,830 --> 00:38:03,995
所以我知道我要读取的下一个页面，

824
00:38:03,995 --> 00:38:06,430
在我扫描时，沿着叶节点，

825
00:38:06,720 --> 00:38:08,320
所以我可以继续，并进行预取，

826
00:38:09,380 --> 00:38:12,420
即使它不是按其他页面的顺序排列的，

827
00:38:15,720 --> 00:38:16,790
这又是另一个例子，

828
00:38:16,790 --> 00:38:19,120
为什么我们要在数据库系统而不是操作系统端做这个。

829
00:38:24,050 --> 00:38:26,010
我们可以做的下一个优化是扫描共享，

830
00:38:26,880 --> 00:38:29,810
在一些较旧的系统中，有时称为同步扫描。

831
00:38:30,280 --> 00:38:33,170
这里的基本思想是显示一系列查询，

832
00:38:33,840 --> 00:38:35,150
他们想要访问同一张表，

833
00:38:36,190 --> 00:38:38,960
其中一个开始扫描页面，

834
00:38:39,880 --> 00:38:44,120
我们可以认识到，他们需要相同的数据，

835
00:38:44,500 --> 00:38:45,950
所以，我们返回给它们，

836
00:38:46,180 --> 00:38:47,930
我们的游标连接到他们的游标上，

837
00:38:48,010 --> 00:38:50,450
我们同时读取相同的页面，

838
00:38:51,570 --> 00:38:54,430
所以我们去掉了多余的 I/O 。

839
00:38:55,410 --> 00:38:57,070
所以这和结果缓存是不同的，

840
00:38:57,420 --> 00:38:59,300
我们不想在这个学期谈论，

841
00:38:59,300 --> 00:39:03,610
结果缓存，是查询出现，我计算出了一些答案，

842
00:39:04,200 --> 00:39:06,160
我将结果保存在缓存中，

843
00:39:06,720 --> 00:39:08,320
同样的查询再次出现，

844
00:39:08,880 --> 00:39:10,490
可能略有不同，这很难做到，

845
00:39:10,490 --> 00:39:11,800
但假设相同的查询再次出现，

846
00:39:12,030 --> 00:39:13,130
我必须重新运行查询，

847
00:39:13,130 --> 00:39:14,710
我只是把结果发回去，

848
00:39:15,440 --> 00:39:18,745
扫描共享实际上是在访问方法的低物理级别，

849
00:39:18,745 --> 00:39:19,920
我们扫描页面的方式，

850
00:39:20,240 --> 00:39:21,210
我们可以认识到，

851
00:39:21,350 --> 00:39:23,340
两个查询需要读取相同的内容，

852
00:39:23,600 --> 00:39:29,910
所以，我们可以在执行过程中重用任何页面并获取它们，

853
00:39:30,320 --> 00:39:33,540
这样就不会有试图同时读取相同页面的冲突游标。

854
00:39:36,510 --> 00:39:38,890
好的，这是重复我刚才所说的，

855
00:39:39,150 --> 00:39:43,330
对于 DB2, SQL Server, Teradata 和 Postgres ，

856
00:39:43,530 --> 00:39:47,950
他们支持完全扫描共享，

857
00:39:48,450 --> 00:39:50,440
对于不完全相同的查询，

858
00:39:50,880 --> 00:39:53,050
但至少它们正在读取相同的表。

859
00:39:54,370 --> 00:39:59,930
在 Oracle 中，它们只支持看起来完全相同的查询的游标共享，

860
00:40:00,070 --> 00:40:01,695
我的意思是字面上完全相同，

861
00:40:01,695 --> 00:40:05,480
因为他们是对字符串做哈希，看看是否有匹配，

862
00:40:06,250 --> 00:40:07,670
如果你查看文档，

863
00:40:08,110 --> 00:40:10,280
例如，如果你有 SELECT * FROM employees 这样的查询，

864
00:40:10,900 --> 00:40:12,650
SELECT * FROM Employees ，大写字母 E ，

865
00:40:12,910 --> 00:40:14,660
或者有额外的空格在 FROM 子句前，

866
00:40:15,220 --> 00:40:16,130
它们不会匹配，

867
00:40:16,180 --> 00:40:18,710
因为当你对字符串进行哈希时，它们并不相同，

868
00:40:18,820 --> 00:40:21,530
所以，它必须是完全相同的查询，在完全相同的时间运行，

869
00:40:21,850 --> 00:40:23,330
然后它们可以共享它。

870
00:40:25,360 --> 00:40:26,595
所以构思看起来是这样的，

871
00:40:26,595 --> 00:40:28,545
假设我有查询一，

872
00:40:28,545 --> 00:40:33,500
让我们对表 A 中的 val 列进行求和，

873
00:40:34,120 --> 00:40:36,765
所以将游标附加到页面上，

874
00:40:36,765 --> 00:40:38,660
开始读取它们，并将它们提取到缓冲池中，

875
00:40:39,850 --> 00:40:41,660
它首先获取 page0 ，它不在那里，

876
00:40:42,370 --> 00:40:46,350
所以把它放在内存中，转到 page2 ，等等，

877
00:40:46,350 --> 00:40:47,450
现在我们获取 page3 ，

878
00:40:47,770 --> 00:40:50,220
我们还没有讨论驱逐策略，

879
00:40:50,220 --> 00:40:51,950
但 page0 是最后一个用过的，

880
00:40:52,330 --> 00:40:55,280
所以我们继续，把 page0 逐出，然后放入 page3 ，

881
00:40:56,370 --> 00:40:57,760
但是现在， Q2 出现了，

882
00:40:58,480 --> 00:41:02,100
希望在同一张表上计算平均值而不是求和，

883
00:41:02,780 --> 00:41:04,660
所以简单的做法是，

884
00:41:04,660 --> 00:41:05,905
让它从开头开始，

885
00:41:05,905 --> 00:41:07,290
就像第一个光标一样，

886
00:41:07,430 --> 00:41:09,750
只需同时向下扫描，并读取页面，

887
00:41:11,510 --> 00:41:12,580
但这显然是愚蠢的，

888
00:41:12,580 --> 00:41:14,760
因为在这种情况下，

889
00:41:15,350 --> 00:41:17,970
我们只需要， Q2 需要读取 page0 ，

890
00:41:18,140 --> 00:41:21,710
但 Q1 刚刚将其从缓冲池中逐出，

891
00:41:21,710 --> 00:41:24,010
所以我们在这里要做的第一件事是，

892
00:41:24,930 --> 00:41:25,960
如果你想要 Q2 ，

893
00:41:26,010 --> 00:41:28,510
我们必须逐出 page2 ，放入 page0 ，

894
00:41:28,710 --> 00:41:30,790
但是，我们刚刚逐出了 page0 ，

895
00:41:31,580 --> 00:41:32,815
所以，更好的做法是，

896
00:41:32,815 --> 00:41:34,500
你将 Q2 附加到 Q1 上，

897
00:41:35,240 --> 00:41:38,250
在扫描表格时的最低级别，

898
00:41:39,060 --> 00:41:41,390
让 Q2 随着 Q1 ，

899
00:41:41,830 --> 00:41:44,600
看到它看到的所有页面，并相应地处理它们，

900
00:41:44,980 --> 00:41:46,515
然后 Q1 消失了，

901
00:41:46,515 --> 00:41:48,030
但是 Q2 意识到，

902
00:41:48,030 --> 00:41:50,630
哦，在表的顶部有一堆我遗漏的页面，

903
00:41:51,280 --> 00:41:53,300
让我返回并获取所有这些，

904
00:41:54,610 --> 00:41:55,670
然后计算我的查询。

905
00:41:57,640 --> 00:41:58,040
好的，

906
00:42:01,050 --> 00:42:02,060
这有什么潜在的问题？

907
00:42:05,480 --> 00:42:05,880
是的。

908
00:42:07,245 --> 00:42:10,450
所以，它很难实现，没那么难。

909
00:42:17,870 --> 00:42:20,010
说如果聚合函数依赖于数据的顺序，

910
00:42:20,600 --> 00:42:24,390
再次，关系模型不依赖于，如果没有函数，是的，

911
00:42:26,305 --> 00:42:26,725
你接近了，

912
00:42:26,725 --> 00:42:30,070
但是假如你有一个 LIMIT 子句，

913
00:42:30,330 --> 00:42:32,170
我想得到前 100 个 tuple ，

914
00:42:32,700 --> 00:42:33,880
然后计算它的平均值，

915
00:42:35,370 --> 00:42:36,880
再次，关系型模型是无序的，

916
00:42:37,110 --> 00:42:38,500
所以，从技术上讲，这是正确的，

917
00:42:38,640 --> 00:42:41,770
如果 Q2 从 page0 开始，而不是 page3 ，

918
00:42:41,970 --> 00:42:44,290
它获取 100 个 tuple 计算平均值，

919
00:42:44,910 --> 00:42:46,570
这两个答案在技术上都是正确的，

920
00:42:46,980 --> 00:42:49,055
从应用程序的角度来看，这看起来很糟糕，

921
00:42:49,055 --> 00:42:50,030
因为现在你收到查询，

922
00:42:50,030 --> 00:42:53,020
同一查询在两个不同的时间显示不同的结果。

923
00:42:53,780 --> 00:42:55,180
所以我是未经思考的说，

924
00:42:55,180 --> 00:42:56,245
哦，是的，这并不是很难实现，

925
00:42:56,245 --> 00:42:57,450
因为你附加了游标，

926
00:42:58,330 --> 00:43:02,420
如果没有排序约束，这很容易，

927
00:43:02,710 --> 00:43:04,080
但是，如果你需要确保，

928
00:43:04,080 --> 00:43:07,670
你的查询一遍又一遍地产生相同的结果，

929
00:43:07,780 --> 00:43:09,830
那么这可能有点棘手，

930
00:43:11,650 --> 00:43:12,495
这也是部分原因，

931
00:43:12,495 --> 00:43:13,880
我不是想抨击 Oracle ，

932
00:43:13,900 --> 00:43:15,090
比如，最容易做的事情是，

933
00:43:15,090 --> 00:43:17,000
如果是完全相同的查询，我会进行游标共享，

934
00:43:17,950 --> 00:43:19,340
棘手的事情是弄清楚，

935
00:43:19,540 --> 00:43:22,370
理解查询实际想要做的事情的语义，

936
00:43:22,660 --> 00:43:27,320
然后确定何时将一个游标连接到另一个游标是安全的，

937
00:43:28,060 --> 00:43:30,950
然后如何返回，并根据需要获得更多结果。

938
00:43:36,730 --> 00:43:38,180
所以这是一个，

939
00:43:41,320 --> 00:43:46,280
一种极端的扫描共享是一种称为连续扫描共享的想法，

940
00:43:46,720 --> 00:43:47,715
首先，我也要说，

941
00:43:47,715 --> 00:43:50,330
没有真正的系统做这个，

942
00:43:50,650 --> 00:43:51,435
但我只是喜欢它，

943
00:43:51,435 --> 00:43:53,120
因为这是一种思考如何构建系统的不同方式。

944
00:43:54,000 --> 00:43:55,730
所以，回到他的观点上，

945
00:43:55,730 --> 00:43:57,970
他说实施扫描共享是困难的，

946
00:43:58,410 --> 00:44:00,310
潜在的，是的，

947
00:44:00,870 --> 00:44:02,560
但是如果你只是做最简单的事情，

948
00:44:04,640 --> 00:44:06,810
所有的东西都应该扫描共享，

949
00:44:07,160 --> 00:44:09,570
因为游标一直在运行，

950
00:44:10,340 --> 00:44:12,360
所以它会一页接一页地读取，

951
00:44:12,800 --> 00:44:14,010
把它放到你的缓冲池里，

952
00:44:14,270 --> 00:44:16,350
然后当你完成了，

953
00:44:17,060 --> 00:44:19,290
就会回来，重新来一遍。

954
00:44:19,950 --> 00:44:21,700
所以现在当一个查询出现时，

955
00:44:22,140 --> 00:44:25,670
你只是在它进行的时候突然出现，

956
00:44:25,670 --> 00:44:26,555
然后得到你需要的东西，

957
00:44:26,555 --> 00:44:27,640
然后你离开，你就完成了。

958
00:44:32,080 --> 00:44:33,200
好主意还是坏主意，

959
00:44:34,970 --> 00:44:37,640
听起来很糟糕，为什么。

960
00:44:38,470 --> 00:44:45,630
所以，假设这是一个[]的实验，

961
00:44:45,630 --> 00:44:47,760
假设每个查询都在执行可能是全表扫描，

962
00:44:47,760 --> 00:44:49,160
或者几乎是全表扫描。

963
00:44:54,135 --> 00:44:54,950
所以，你会有一张表，

964
00:44:55,330 --> 00:44:56,480
所以你可能会说，

965
00:44:56,560 --> 00:44:58,110
游标不会被触发，

966
00:44:58,110 --> 00:44:59,780
直到查询显示它触及了表？

967
00:45:00,970 --> 00:45:01,370
那个。

968
00:45:06,800 --> 00:45:07,440
是的，但是，

969
00:45:11,340 --> 00:45:11,740
好的，

970
00:45:13,200 --> 00:45:14,825
假设你必须做全表扫描，

971
00:45:14,825 --> 00:45:16,030
因为表无论如何都无法放入内存中。

972
00:45:19,600 --> 00:45:20,000
所以。

973
00:45:21,430 --> 00:45:21,830
是的。

974
00:45:24,540 --> 00:45:25,510
所以，它很难跳过，

975
00:45:26,340 --> 00:45:27,605
好的，在一些方式中，

976
00:45:27,605 --> 00:45:30,425
它让你的运行时间有点确定性，

977
00:45:30,425 --> 00:45:33,275
因为你知道它至少是 n ，

978
00:45:33,275 --> 00:45:35,320
它在页面编号结束，

979
00:45:36,230 --> 00:45:37,200
那只是对于扫描，

980
00:45:37,340 --> 00:45:39,000
JOINs 或其他[]，我们还没有讨论。

981
00:45:41,180 --> 00:45:42,025
如果它在[]上，

982
00:45:42,025 --> 00:45:44,350
你已经支付了硬件费用，忽略能源成本，

983
00:45:44,350 --> 00:45:45,900
那么这是可以接受的，

984
00:45:46,220 --> 00:45:47,320
但如果它在云上运行，

985
00:45:47,320 --> 00:45:48,550
你实际上是按 IOP 付费的，

986
00:45:48,550 --> 00:45:50,515
那么这很糟糕，

987
00:45:50,515 --> 00:45:53,280
因为你最终读取的数据比你实际需要的要多，

988
00:45:53,780 --> 00:45:56,910
我是说，我知道只有一个原型做到这个，

989
00:45:56,930 --> 00:45:59,940
出自苏黎世联邦理工学院，叫做 Crescando ，

990
00:46:00,950 --> 00:46:03,715
他们专门为电信业务构建了它，

991
00:46:03,715 --> 00:46:06,000
在那里他们需要确定性的查询运行时，

992
00:46:06,600 --> 00:46:08,310
但这是几年前的事了，

993
00:46:08,310 --> 00:46:11,840
有另一个原型，它也有同样的事情。

994
00:46:12,040 --> 00:46:13,140
所以这是一个有趣的想法，

995
00:46:13,140 --> 00:46:16,010
这是一种不同的方式来思考一个非正统的系统，

996
00:46:16,630 --> 00:46:18,330
呈现一种不同的方式来考虑事情，

997
00:46:19,360 --> 00:46:20,175
我喜欢数据库，

998
00:46:20,175 --> 00:46:22,010
有很多不同的方法可以解决同样的问题。

999
00:46:22,090 --> 00:46:22,490
这是糟糕的。

1000
00:46:27,590 --> 00:46:29,760
最后讨论的优化称为缓冲池旁路，

1001
00:46:30,910 --> 00:46:32,450
这里的想法是，

1002
00:46:34,060 --> 00:46:36,680
如果我们有一个运行顺序扫描的查询，

1003
00:46:38,280 --> 00:46:40,420
我们必须把磁盘上的东西放到内存中，

1004
00:46:40,920 --> 00:46:43,810
但也许我们不想把它放到我们的缓冲池中，

1005
00:46:44,400 --> 00:46:47,200
因为人们需要支付缓冲池的维护成本，

1006
00:46:47,460 --> 00:46:50,980
在页面中，获取一个 latch ，更新东西，等等，

1007
00:46:51,570 --> 00:46:53,440
而且，如果我们进行顺序扫描，

1008
00:46:53,910 --> 00:46:56,710
我们刚刚读取的数据可能并不有用，

1009
00:46:57,360 --> 00:46:58,625
它对我们的查询没有用处，

1010
00:46:58,625 --> 00:46:59,945
因为我们将按顺序扫描，

1011
00:46:59,945 --> 00:47:03,910
我们通常只会访问一次表，

1012
00:47:05,250 --> 00:47:10,490
所以，不是拥有所有这些不同的 worker ，

1013
00:47:10,510 --> 00:47:13,700
在相同的时间运行，做顺序扫描和[污染]页表，

1014
00:47:14,480 --> 00:47:19,270
如果我们只给每个 worker 自己的一小部分内存，

1015
00:47:20,460 --> 00:47:22,060
比如一个工作内存，

1016
00:47:22,590 --> 00:47:24,640
然后，我们读到的任何页面，

1017
00:47:25,050 --> 00:47:26,890
我们都会放入那个 worker 的内存中，

1018
00:47:27,420 --> 00:47:29,390
是的，你可以有重复，它只工作，

1019
00:47:29,390 --> 00:47:30,880
如果它是只读的，你不能写入，

1020
00:47:32,440 --> 00:47:33,805
这样，它就像一个循环缓冲区，

1021
00:47:33,805 --> 00:47:35,400
我们只是不断地填满，绕来绕去。

1022
00:47:37,030 --> 00:47:38,570
所以很多系统都支持这个，

1023
00:47:38,980 --> 00:47:41,420
Oracle, SQL Server, Postgres 和 Informix ，

1024
00:47:41,470 --> 00:47:44,630
我认为这起源于 Informix ，他们称之为轻扫描，

1025
00:47:45,130 --> 00:47:48,680
轻的意思，因为，你不会触及缓冲池中的那种重量级页表。

1026
00:47:49,610 --> 00:47:50,890
这里的想法是，

1027
00:47:50,890 --> 00:47:53,845
我可能不会污染我的页表，

1028
00:47:53,845 --> 00:47:54,990
因为我需要的数据，

1029
00:47:56,090 --> 00:47:58,980
但我需要的数据是我本地的，

1030
00:47:59,700 --> 00:48:02,740
当然，这样做的缺点是你失去了共享的能力，

1031
00:48:02,760 --> 00:48:06,160
两个 worker 同时需要相同的页面，

1032
00:48:06,630 --> 00:48:08,290
或者一个接一个，

1033
00:48:08,670 --> 00:48:11,170
那么你就失去了重用的可能性，

1034
00:48:12,390 --> 00:48:14,570
但是，这是我们可以进行的另一种优化，

1035
00:48:14,570 --> 00:48:16,150
因为我们准确地控制了，

1036
00:48:16,930 --> 00:48:18,525
查询是什么，

1037
00:48:18,525 --> 00:48:21,110
它们实际执行和触及的是什么。

1038
00:48:24,150 --> 00:48:24,550
好的。

1039
00:48:26,060 --> 00:48:27,790
我们在某种程度上绕过了这个想法，

1040
00:48:27,790 --> 00:48:31,450
关于从我们的缓冲池中逐出数据或逐出页面，

1041
00:48:31,920 --> 00:48:33,970
现在我们要谈谈我们到底要怎么做，

1042
00:48:34,170 --> 00:48:36,280
你需要知道这个，因为这是项目一。

1043
00:48:37,930 --> 00:48:41,595
所以，当执行程序说，

1044
00:48:41,595 --> 00:48:43,250
好的，我要把一个页面放到内存中，

1045
00:48:43,720 --> 00:48:44,870
我要放进一个 frame ，

1046
00:48:46,450 --> 00:48:47,895
如果没有空闲的 frame ，

1047
00:48:47,895 --> 00:48:49,550
它必须决定要驱逐什么，

1048
00:48:50,500 --> 00:48:53,300
这是一个缓存，这不应该是开创性的。

1049
00:48:55,260 --> 00:49:02,390
所以，我们必须在驱逐策略中考虑的不同指标或目标的[预算]，

1050
00:49:02,890 --> 00:49:07,070
将取决于我们实施数据库系统的各种因素，

1051
00:49:07,980 --> 00:49:10,790
显然，我们希望我们的驱逐策略是正确的，

1052
00:49:10,790 --> 00:49:11,795
我们不想驱逐一页，

1053
00:49:11,795 --> 00:49:14,375
然后马上那一页是最常用的，

1054
00:49:14,375 --> 00:49:16,900
因此我们一遍又一遍地从磁盘上读写它，

1055
00:49:16,950 --> 00:49:17,650
这会是糟糕的，

1056
00:49:19,410 --> 00:49:22,810
我们希望我们的驱逐策略是快速的，

1057
00:49:22,810 --> 00:49:24,960
我们不想它是一个，

1058
00:49:25,280 --> 00:49:28,405
我们使用的是 NP 完全算法或指数算法，

1059
00:49:28,405 --> 00:49:30,790
我们不想花三秒钟来决定驱逐哪一页，

1060
00:49:30,790 --> 00:49:32,965
因为[监视器]会从磁盘上读取它，

1061
00:49:32,965 --> 00:49:34,500
一开始，这会快得多。

1062
00:49:35,520 --> 00:49:36,230
与此相关的是，

1063
00:49:36,230 --> 00:49:38,780
我们也不想花费很大的成本，

1064
00:49:38,780 --> 00:49:43,000
关于维护我们需要跟踪页面是如何被访问的元数据，

1065
00:49:43,170 --> 00:49:45,280
这样我们才能决定驱逐什么。

1066
00:49:47,800 --> 00:49:49,730
所以，这又是计算机科学中最古老的问题，

1067
00:49:50,750 --> 00:49:53,520
另一个计算机科学中最古老的问题是命名某个东西或命名一个系统，

1068
00:49:54,470 --> 00:49:55,675
我们可以谈谈 BusTub 是怎么命名的，

1069
00:49:55,675 --> 00:49:59,190
但是，就像每个人都有一张缓存[纸]，

1070
00:49:59,780 --> 00:50:00,660
我想我有两张。

1071
00:50:03,310 --> 00:50:07,940
所以最明显容易做的事情是 LRU ，最近最少使用，

1072
00:50:08,710 --> 00:50:12,890
这里的基本思想是维护一个时间戳或跟踪一个链表，

1073
00:50:12,910 --> 00:50:16,460
关于页面最后一次是什么时候访问的，

1074
00:50:17,330 --> 00:50:19,290
然后，当需要驱逐页面时，

1075
00:50:19,520 --> 00:50:21,510
我们只需转到链表的末尾，

1076
00:50:21,980 --> 00:50:23,785
然后弹出那里的任何内容，

1077
00:50:23,785 --> 00:50:26,070
那个有一段时间没人访问了，

1078
00:50:26,300 --> 00:50:27,300
我们继续前进，把它驱逐出去。

1079
00:50:28,260 --> 00:50:30,820
假设 Q1 想要访问 page1 ，

1080
00:50:32,250 --> 00:50:33,820
page1 已经在我们的链接列表中了，

1081
00:50:34,140 --> 00:50:36,310
所以，我们只是将其移到前面，移到头部，

1082
00:50:37,470 --> 00:50:40,955
然后现在假设另一个查询想要访问 page5 ，

1083
00:50:40,955 --> 00:50:42,190
但 page5 不在内存中，

1084
00:50:42,630 --> 00:50:45,970
所以，我们继续，驱逐 page2 ，

1085
00:50:46,750 --> 00:50:48,260
因为它在末尾，

1086
00:50:50,780 --> 00:50:52,680
这对任何人来说都不应该是新闻。

1087
00:50:54,450 --> 00:50:56,900
实现相同目的的另一种方法是，

1088
00:50:56,900 --> 00:51:00,410
在不跟踪该链表中的实际时间戳的情况下，

1089
00:51:00,410 --> 00:51:02,740
使用一种称为 CLOCK 的近似算法，

1090
00:51:03,580 --> 00:51:04,790
在座的谁以前听到过 CLOCK ，

1091
00:51:06,450 --> 00:51:07,450
不到五个，好的，

1092
00:51:09,180 --> 00:51:11,795
clock 也在使用一系列其他系统，

1093
00:51:11,795 --> 00:51:15,400
我认为 Linux 将其用于页面缓存或页表，

1094
00:51:16,530 --> 00:51:17,630
他们使用多指针 clock ，

1095
00:51:17,630 --> 00:51:20,230
我们不需要知道这个，

1096
00:51:20,250 --> 00:51:21,520
但这里的基本思想是，

1097
00:51:21,720 --> 00:51:26,680
不是像 LRU 中那样跟踪页面的确切顺序，

1098
00:51:27,480 --> 00:51:32,350
相反，我们只为我们每个页面提供一个简单的引用位，

1099
00:51:32,910 --> 00:51:34,150
我们用来跟踪，

1100
00:51:35,550 --> 00:51:37,280
每当它被访问时，我们就设置 1 ，

1101
00:51:37,280 --> 00:51:38,860
无论它是写入或读取。

1102
00:51:39,900 --> 00:51:40,940
这里的想法是，

1103
00:51:40,940 --> 00:51:44,350
我们有这个表针扫过查看我们所有的页面，

1104
00:51:45,000 --> 00:51:47,560
如果位设置为 1 ，将其设置为 0 ，

1105
00:51:47,940 --> 00:51:51,510
如果它被设置为 0 ，我们继续并驱逐它。

1106
00:51:51,510 --> 00:51:52,400
假设我们有四页，

1107
00:51:52,900 --> 00:51:55,340
我们有引用位，我们设置为 0 ，

1108
00:51:56,510 --> 00:51:59,310
然后，假设 page1 被一个查询访问，

1109
00:51:59,630 --> 00:52:01,260
我们继续，并将引用位设置为 1 ，

1110
00:52:02,190 --> 00:52:03,250
现在让我们假设，

1111
00:52:03,840 --> 00:52:06,430
另一个查询想要一个不在缓冲池中的页面，

1112
00:52:06,570 --> 00:52:08,830
所以我们必须决定这四个中的想要驱逐哪一个，

1113
00:52:09,560 --> 00:52:12,490
所以我们继续，时钟从某个起点开始，

1114
00:52:13,430 --> 00:52:14,455
它查看引用位，

1115
00:52:14,455 --> 00:52:16,350
如果它设置为 1 ，我们将其设置为 0 ，

1116
00:52:16,730 --> 00:52:18,000
然后转到下一个，

1117
00:52:18,320 --> 00:52:20,520
在这里， page2 引用位设置为 0 ，

1118
00:52:20,930 --> 00:52:24,720
所以，我们知道时钟最后一次扫过并寻找要驱逐的页面时，

1119
00:52:25,580 --> 00:52:26,460
它没有被访问，

1120
00:52:27,220 --> 00:52:29,490
所以，这是可以安全驱逐的，

1121
00:52:30,280 --> 00:52:32,070
我们继续，把它移走，用另一个取代它，

1122
00:52:32,760 --> 00:52:35,690
然后比如其他 page3 和 page4 ，它们都被访问，

1123
00:52:35,800 --> 00:52:38,060
时钟扫过，将它们的位设置为 0 ，

1124
00:52:38,590 --> 00:52:39,645
然后一直到这里，

1125
00:52:39,645 --> 00:52:41,450
然后现在我们回到 page1 ，

1126
00:52:41,800 --> 00:52:43,550
它不像你最后一次看到它时那样被访问，

1127
00:52:43,660 --> 00:52:44,870
所以我们继续，选择这个。

1128
00:52:48,620 --> 00:52:50,130
这是一个好主意，还是一个坏主意？

1129
00:52:53,630 --> 00:52:54,370
这似乎很好，

1130
00:52:54,370 --> 00:52:58,045
因为它允许我们拥有更少的存储空间，

1131
00:52:58,045 --> 00:52:59,370
因为我们只需要一个位，

1132
00:52:59,510 --> 00:53:02,185
但缺点似乎是它将驱逐，

1133
00:53:02,185 --> 00:53:03,690
即使我们不需要空间，

1134
00:53:04,700 --> 00:53:06,810
所以我们可能会有更少的命中。

1135
00:53:07,040 --> 00:53:08,605
所以，他的第一部分是正确的，

1136
00:53:08,605 --> 00:53:10,380
第一部分说这很好，

1137
00:53:10,430 --> 00:53:12,190
因为元数据的开销很低，

1138
00:53:12,190 --> 00:53:13,770
因为它只是每页一位，

1139
00:53:14,030 --> 00:53:16,380
你可以把它存储为一个连续的大的向量，

1140
00:53:16,520 --> 00:53:17,430
这很容易做到，

1141
00:53:17,900 --> 00:53:21,790
但是你说的第二个你可能会驱逐你不应该驱逐的东西，

1142
00:53:21,790 --> 00:53:24,750
时钟只会运行清扫，

1143
00:53:25,010 --> 00:53:25,950
在你需要驱逐的时候，

1144
00:53:26,300 --> 00:53:27,870
所以，它不是一直在运行在后台，

1145
00:53:28,220 --> 00:53:29,640
是的，我们不想这么做。

1146
00:53:32,630 --> 00:53:33,030
是的。

1147
00:53:39,380 --> 00:53:40,890
是的，他说的是，他说的没错，

1148
00:53:41,480 --> 00:53:45,045
在 clock 和 LRU 的情况下，

1149
00:53:45,045 --> 00:53:45,860
他们都有这个问题，

1150
00:53:46,330 --> 00:53:51,020
我们没有跟踪页面被访问的频率，

1151
00:53:52,030 --> 00:53:54,230
因此，这使得他们容易受到两个问题的影响。

1152
00:53:55,040 --> 00:53:57,040
第一个是他在这里说的，

1153
00:53:57,120 --> 00:53:58,790
在 clock 和 LRU 中，

1154
00:53:58,790 --> 00:54:00,380
我们只跟踪它们被访问的时间，

1155
00:54:00,380 --> 00:54:02,680
而不是它们被访问的频率，

1156
00:54:03,540 --> 00:54:05,030
在这两种情况下，

1157
00:54:05,030 --> 00:54:08,080
它们也容易受到一种称为顺序洪水的问题的影响，

1158
00:54:09,280 --> 00:54:10,550
这就是问题所在，

1159
00:54:11,760 --> 00:54:12,920
如果我们在进行顺序扫描，

1160
00:54:14,090 --> 00:54:16,890
我们必须从磁盘中获取页面，放入我们的缓冲池，

1161
00:54:17,420 --> 00:54:19,740
但如果我们跟踪它们最后一次被使用的时间，

1162
00:54:20,270 --> 00:54:23,610
我刚获得的用于顺序扫描的最后一个页面，

1163
00:54:23,930 --> 00:54:25,500
就是最近使用的那个，

1164
00:54:25,760 --> 00:54:30,000
但对于顺序扫描，它实际上是最有用的，抱歉，也是最不有用的，

1165
00:54:30,590 --> 00:54:31,825
因为这是正在读取的那一页，

1166
00:54:31,990 --> 00:54:35,270
我不打算回去再读取一遍。

1167
00:54:35,680 --> 00:54:37,425
在某些情况下，对于许多工作负载，

1168
00:54:37,425 --> 00:54:39,770
这有点像最近使用的那个，

1169
00:54:40,410 --> 00:54:42,495
这是一个粗略估计，

1170
00:54:42,495 --> 00:54:46,045
但是另一种方式思考它的方式。

1171
00:54:46,045 --> 00:54:46,830
比如，就像这样，

1172
00:54:47,180 --> 00:54:49,830
我有一个查询 SELECT * FROM 一张表，

1173
00:54:50,090 --> 00:54:52,140
但我们只获取一个 ID 或一条记录，

1174
00:54:52,370 --> 00:54:53,910
比如它在 page0 ，

1175
00:54:55,020 --> 00:54:58,030
所以我们把 page0 放入我们的缓冲池中，

1176
00:54:58,350 --> 00:54:59,675
然后，我们的 OLAP 查询，

1177
00:54:59,675 --> 00:55:01,480
将扫描整个表，

1178
00:55:01,740 --> 00:55:03,790
并获取整个表中的所有页面，

1179
00:55:04,380 --> 00:55:06,425
但当它到了 page3 ，

1180
00:55:06,425 --> 00:55:07,180
我们就没有空间了，

1181
00:55:07,500 --> 00:55:09,730
所以，对于这些页面，

1182
00:55:09,840 --> 00:55:13,720
最近最少使用的页面是 page0 ，

1183
00:55:14,250 --> 00:55:15,820
所以我要继续下去，把它驱逐出去，

1184
00:55:16,860 --> 00:55:17,860
放入 page3 ，

1185
00:55:18,450 --> 00:55:20,660
但如果出现另一个查询，

1186
00:55:20,660 --> 00:55:22,010
它会做第一个做的相同的事情，

1187
00:55:22,010 --> 00:55:24,880
获取 page1 或 page1 中的记录一，

1188
00:55:26,005 --> 00:55:28,710
这实际上就是我想要的页面，

1189
00:55:29,210 --> 00:55:30,240
但我刚刚驱逐了它，

1190
00:55:31,070 --> 00:55:35,270
所以这是你能做的最糟糕的事了。

1191
00:55:37,320 --> 00:55:39,100
所以，顺序洪水是一个问题，

1192
00:55:39,120 --> 00:55:41,980
因为，如果我们执行大多数这些点查询，

1193
00:55:42,390 --> 00:55:44,080
然后突然出现一个查询，

1194
00:55:44,370 --> 00:55:50,140
它将摧毁我们在 LRU 或 CLOCK 元数据中收集的任何有用信息。

1195
00:55:52,840 --> 00:55:55,880
解决这个问题的方法叫做 LRU-K ，

1196
00:55:56,920 --> 00:55:57,720
这里的想法是，

1197
00:55:57,720 --> 00:56:01,490
你跟踪页面最近 k 次的访问次数，

1198
00:56:02,130 --> 00:56:04,930
然后，当决定驱逐什么时，

1199
00:56:05,580 --> 00:56:12,460
你计算上次，抱歉， k 次访问之间的时间间隔，

1200
00:56:13,020 --> 00:56:17,480
任何一个有最大的间隔，也就是它被访问的时间，

1201
00:56:18,070 --> 00:56:19,700
k-1 或 k-2 次，

1202
00:56:20,260 --> 00:56:21,350
这个间隔就是最大的，

1203
00:56:21,370 --> 00:56:25,160
然后你知道它很可能在未来不会被使用，

1204
00:56:25,720 --> 00:56:28,010
因此你可以继续并移除它，

1205
00:56:29,610 --> 00:56:34,220
你可以认为普通的 LRU 就是 LRU-K ，其中 k 等于 1 。

1206
00:56:35,120 --> 00:56:37,495
对于 2 或 3 或其他任何东西，

1207
00:56:37,495 --> 00:56:38,320
大多数系统使用 2 ，

1208
00:56:38,320 --> 00:56:39,000
如果你能用这个的话，

1209
00:56:39,110 --> 00:56:41,305
它们只会记录最近两次的情况，

1210
00:56:41,305 --> 00:56:43,315
这两者之间的时间是多少，

1211
00:56:43,315 --> 00:56:44,730
我选最大的那个。

1212
00:56:46,630 --> 00:56:50,320
所以，当然，这很容易受到另一个问题的影响，

1213
00:56:50,430 --> 00:56:53,730
我取了一个页面，

1214
00:56:55,430 --> 00:56:57,535
但我还没有访问过它两次，

1215
00:56:57,535 --> 00:57:00,270
所以间隔是无穷大，

1216
00:57:01,970 --> 00:57:03,745
然后它继续，立即被驱逐，

1217
00:57:03,745 --> 00:57:05,365
但是加入这实际上是热门页面，

1218
00:57:05,365 --> 00:57:06,360
我想把它留在内存中，

1219
00:57:06,950 --> 00:57:09,150
但因为我一直在驱逐它，我失去了它，

1220
00:57:09,200 --> 00:57:10,440
我没有这方面的任何历史。

1221
00:57:11,100 --> 00:57:12,520
所以解决这个问题的方法是，

1222
00:57:12,540 --> 00:57:15,580
你在内存中维护一个哈希表

1223
00:57:16,110 --> 00:57:21,680
来跟踪，这是我驱逐的最后几个页面，在磁盘上，

1224
00:57:21,680 --> 00:57:24,040
这是它们被访问的时候，时间戳，

1225
00:57:24,330 --> 00:57:26,980
所以当我取回一个页面时，它刚刚被删除，

1226
00:57:27,180 --> 00:57:28,760
我现在至少有它的历史，

1227
00:57:28,760 --> 00:57:30,940
而不是假设它是无穷大的。

1228
00:57:32,600 --> 00:57:34,050
这意味着随着时间的推移，

1229
00:57:34,220 --> 00:57:37,890
你将能够获得计算页面正确间隔所需的信息，

1230
00:57:38,180 --> 00:57:40,260
当你知道页面第一次被放入内存的时间时，

1231
00:57:41,740 --> 00:57:43,035
它是自我修正的，

1232
00:57:43,035 --> 00:57:44,115
因为如果我把一些东西放入内存，

1233
00:57:44,115 --> 00:57:45,350
然后再也不去取它，

1234
00:57:45,910 --> 00:57:48,440
它就会从我的临时缓存中被删除，

1235
00:57:49,120 --> 00:57:50,625
每当我再次需要它的时候，

1236
00:57:50,625 --> 00:57:51,710
我就不会有那个历史，

1237
00:57:51,730 --> 00:57:53,480
我不知道我应该驱逐它。

1238
00:57:56,510 --> 00:57:58,020
这是一个简单问题的简单解决方案，

1239
00:57:58,100 --> 00:57:59,910
令人惊讶的是，这是直到 90 年代才发明的，

1240
00:58:01,640 --> 00:58:02,545
据我所知，

1241
00:58:02,545 --> 00:58:04,440
只有 Postgres 和 SQL Server 做到了这个，

1242
00:58:06,140 --> 00:58:08,125
这就是为什么我喜欢开放源码的东西，

1243
00:58:08,125 --> 00:58:13,150
因为在 2002 年有一篇给 Postgres 人的邮件列表记录帖子说，

1244
00:58:13,150 --> 00:58:15,160
嘿，这个 LRU-K 看起来是个好主意，

1245
00:58:15,160 --> 00:58:16,200
我们应该做它，

1246
00:58:17,150 --> 00:58:18,060
他们就实现了它。

1247
00:58:19,880 --> 00:58:22,720
MySQL 没有做我定义 LRU-K ，

1248
00:58:22,720 --> 00:58:24,180
但他们使用了一种近似的方法，

1249
00:58:25,010 --> 00:58:26,455
他们这样做的方式是，

1250
00:58:26,455 --> 00:58:33,990
他们逻辑地划分 LRU 页面列表的链表，

1251
00:58:35,630 --> 00:58:37,540
他们有两个不同的部分或区域，

1252
00:58:37,540 --> 00:58:40,650
他们有比如， young 区域， old 区域，

1253
00:58:41,350 --> 00:58:42,770
对于这两个不同的区域，

1254
00:58:42,790 --> 00:58:44,570
你有一个不同的头指针，

1255
00:58:45,360 --> 00:58:47,050
你可以在其中插入新条目。

1256
00:58:48,120 --> 00:58:49,940
假设我有一个问题，

1257
00:58:49,940 --> 00:58:50,920
我想要访问 page1 ，

1258
00:58:51,120 --> 00:58:51,860
它不在内存中，

1259
00:58:51,860 --> 00:58:54,670
因此，我必须将其放入我的缓冲池中，

1260
00:58:55,200 --> 00:58:57,100
当我想要将它添加到我的链表中时，

1261
00:58:57,840 --> 00:59:00,340
因为 page1 还不在链表中，

1262
00:59:00,630 --> 00:59:02,590
我会将它添加到旧区域中，

1263
00:59:03,090 --> 00:59:05,560
并将其插入到头指针所在的位置，

1264
00:59:05,910 --> 00:59:09,370
因此，它将驱逐 page8 ，并将 page1 放在那里，

1265
00:59:11,340 --> 00:59:15,260
现在，如果 page1 再也不被访问，

1266
00:59:15,260 --> 00:59:17,890
它将缓慢地到达链表的末尾，

1267
00:59:18,180 --> 00:59:19,990
然后被逐出，

1268
00:59:21,130 --> 00:59:22,395
但如果 Q2 出现了，

1269
00:59:22,395 --> 00:59:23,510
它又一次访问了 page1 ，

1270
00:59:24,360 --> 00:59:28,940
我们会发现它已经存在于我的链表中，

1271
00:59:29,110 --> 00:59:31,100
并且它位于旧区域中，

1272
00:59:31,780 --> 00:59:35,020
因此我将把它放在新列表的头部，

1273
00:59:35,020 --> 00:59:36,330
然后滑动每个（页面）。

1274
00:59:37,970 --> 00:59:39,325
所以，这近似于 LRU-K ，

1275
00:59:39,325 --> 00:59:40,510
因为我并没有真正跟踪，

1276
00:59:40,510 --> 00:59:43,380
比如它被访问的时间间隔，

1277
00:59:44,060 --> 00:59:47,065
但只是知道它是在新和旧之间的界限，

1278
00:59:47,065 --> 00:59:51,810
我就知道它很可能是最近才被访问的，

1279
00:59:53,110 --> 00:59:55,160
而在这里，你以前从未见过它，

1280
00:59:55,860 --> 00:59:58,910
在它被添加到列表之前，你还没有看到过。

1281
01:00:04,630 --> 01:00:05,030
所以。

1282
01:00:08,570 --> 01:00:10,680
我还要说，回到 LRU-K ，

1283
01:00:10,730 --> 01:00:12,930
你还可以做很多其他的优化，

1284
01:00:15,170 --> 01:00:17,130
SQL Server 做的，但我不认为 Postgres 做了，

1285
01:00:17,450 --> 01:00:19,770
你可以跟踪，

1286
01:00:19,910 --> 01:00:24,550
什么时候，谁访问或引用页面，

1287
01:00:25,140 --> 01:00:27,875
然后可以确定你是否会，

1288
01:00:27,875 --> 01:00:30,850
你可能会说，访问计入不同的引用，

1289
01:00:31,050 --> 01:00:32,590
所以应该更新时间间隔。

1290
01:00:32,820 --> 01:00:33,820
举个例子，

1291
01:00:34,170 --> 01:00:36,610
如果我在同一个事务中，

1292
01:00:37,800 --> 01:00:40,060
有两个不同的查询，访问相同的页面，

1293
01:00:40,740 --> 01:00:41,980
这两个查询在同一个事务中，

1294
01:00:42,210 --> 01:00:45,750
因此它们应该被认为是不同的还是相同的，

1295
01:00:46,740 --> 01:00:48,040
如果有两个独立的事务，

1296
01:00:48,270 --> 01:00:50,225
那么这个页面很可能是热门的，

1297
01:00:50,225 --> 01:00:51,940
因为有一堆事务在访问它，

1298
01:00:52,050 --> 01:00:52,750
我想是，

1299
01:00:55,190 --> 01:00:56,455
如果你登录 Amazon ，

1300
01:00:56,455 --> 01:00:59,190
更新你的账户信息，

1301
01:00:59,570 --> 01:01:03,060
不管出于什么原因，这个事务更新你的记录两次，

1302
01:01:03,410 --> 01:01:04,650
这是在同一个事务中完成的，

1303
01:01:04,670 --> 01:01:06,750
这考虑两次访问还是一次，

1304
01:01:07,880 --> 01:01:09,720
在 SQL Server 中，他们认为是一次，

1305
01:01:10,540 --> 01:01:12,450
我认为在 Postgres 中，他们认为是两次，

1306
01:01:14,660 --> 01:01:16,870
好的，再次，一大堆奇怪的东西，

1307
01:01:16,870 --> 01:01:21,690
因为你知道数据库系统是如何访问页面的。

1308
01:01:27,370 --> 01:01:28,935
有一堆策略你可以做，

1309
01:01:28,935 --> 01:01:32,680
用来决定，关于这个，

1310
01:01:33,940 --> 01:01:38,330
对于给定的查询，哪个页面应该逐出，

1311
01:01:38,710 --> 01:01:43,560
这与私有缓存相关，

1312
01:01:43,850 --> 01:01:45,625
在一些系统中，你可以说，

1313
01:01:45,625 --> 01:01:51,600
好的，这是我[]的页面的某个子集，

1314
01:01:51,600 --> 01:01:54,080
它们由缓冲池支持，

1315
01:01:54,190 --> 01:01:56,150
但我在追踪我访问的是哪几个，

1316
01:01:56,440 --> 01:01:58,455
然后我可以给缓冲池管理器一个提示，

1317
01:01:58,455 --> 01:02:00,525
如果你没有更多的空间，

1318
01:02:00,525 --> 01:02:02,690
这是我知道我正在访问的页面，

1319
01:02:03,640 --> 01:02:04,730
我不再需要它们了，

1320
01:02:05,050 --> 01:02:06,530
因此，你可以继续逐出他们，

1321
01:02:06,820 --> 01:02:10,160
现在，数据库系统决定是否逐出它们，

1322
01:02:10,450 --> 01:02:11,480
取决于实现情况。

1323
01:02:14,740 --> 01:02:16,260
你还可以维护优先级提示，

1324
01:02:16,260 --> 01:02:21,080
关于页面类型或页面代表的对象，

1325
01:02:21,850 --> 01:02:25,970
然后这个信息被提供给数据库系统缓冲池管理器，

1326
01:02:25,990 --> 01:02:27,290
决定是否应该逐出一些东西。

1327
01:02:27,910 --> 01:02:29,970
所以经典的例子是，

1328
01:02:29,970 --> 01:02:32,120
如果我有一堆页面的索引，

1329
01:02:33,580 --> 01:02:35,990
并且任何查询总是插入新的记录，

1330
01:02:36,640 --> 01:02:40,725
这些记录只是增加数据的大小，

1331
01:02:40,725 --> 01:02:43,340
或者索引所基于的值的大小，

1332
01:02:43,660 --> 01:02:47,720
那么我知道我将总是命中树的右侧，

1333
01:02:48,130 --> 01:02:50,630
因此，我可能希望将这些页面保留在内存中，

1334
01:02:50,860 --> 01:02:53,720
我不关心这里的 page2 会不会被逐出，

1335
01:02:53,800 --> 01:02:57,810
因为我主要会更新 page6 的内容，

1336
01:02:59,490 --> 01:03:02,080
或者类似地，如果我执行一系列 SELECT 查询，

1337
01:03:02,880 --> 01:03:03,970
必须使用索引，

1338
01:03:04,200 --> 01:03:08,860
我知道他们要访问的第一个东西是索引中的根页面，

1339
01:03:09,210 --> 01:03:12,340
因此，它应该得到比其他页面有更高的优先级。

1340
01:03:13,100 --> 01:03:17,940
现在，这些看起来像是 LRU-K 或其他机制，

1341
01:03:18,470 --> 01:03:20,250
它们是一种，

1342
01:03:20,600 --> 01:03:22,750
所以把它想象成一个[]，

1343
01:03:22,750 --> 01:03:25,825
或者说，嘿，你真的不应该驱逐这个，

1344
01:03:25,825 --> 01:03:27,210
但如果你必须这样做，是的，你可以，

1345
01:03:27,770 --> 01:03:29,790
但是，请不要这样做，

1346
01:03:31,290 --> 01:03:36,070
但是，这是系统已经在做的 LRU 跟踪之外的其他事情。

1347
01:03:38,650 --> 01:03:41,025
当涉及到逐出页面时最大的挑战是，

1348
01:03:41,025 --> 01:03:42,080
它们是否是脏页。

1349
01:03:43,050 --> 01:03:44,450
所以，最简单的做法是，

1350
01:03:44,450 --> 01:03:45,970
如果我所有的页面都是干净的，

1351
01:03:47,340 --> 01:03:48,910
把它们逐出缓冲池就是，

1352
01:03:49,680 --> 01:03:52,760
什么都不做，只需丢弃页表中的页面引用，

1353
01:03:53,140 --> 01:03:55,800
你需要覆盖以前存在的任何内容，

1354
01:03:55,800 --> 01:03:57,590
因为你不需要将其刷新回磁盘，

1355
01:03:58,770 --> 01:04:01,360
如果所有的页面都是脏的，

1356
01:04:01,830 --> 01:04:03,220
或者你想要逐出的那一页是脏的，

1357
01:04:03,720 --> 01:04:05,470
那么你必须把它写到磁盘上，

1358
01:04:05,490 --> 01:04:07,520
确保它是持久的和安全的，

1359
01:04:07,520 --> 01:04:08,680
我们将在本学期晚些时候讨论，

1360
01:04:09,000 --> 01:04:10,835
在你可以继续说（下面这些）之前，

1361
01:04:10,835 --> 01:04:12,460
好的，这个 frame 现在是空闲的，

1362
01:04:12,960 --> 01:04:14,800
你可以继续并重新使用它。

1363
01:04:16,310 --> 01:04:17,650
它实际上比这复杂得多，

1364
01:04:17,650 --> 01:04:20,790
因为你必须确保日志记录首先被刷新到磁盘，

1365
01:04:21,140 --> 01:04:24,720
然后才能刷新日志引用所述的脏页，

1366
01:04:25,610 --> 01:04:26,580
我们将在稍后讨论这个。

1367
01:04:27,470 --> 01:04:29,050
这很难做到的原因是，

1368
01:04:29,050 --> 01:04:30,145
因为它可能是这种情况，

1369
01:04:30,145 --> 01:04:31,315
考虑到我们刚刚谈到的所有事情，

1370
01:04:31,315 --> 01:04:35,370
这些优先顺序的暗示，不同的政策， LRU-K 的东西，

1371
01:04:35,480 --> 01:04:36,415
可能的情况是，

1372
01:04:36,415 --> 01:04:39,390
你想要逐出的页面是脏的，

1373
01:04:40,530 --> 01:04:43,420
所以，这将需要磁盘刷新，

1374
01:04:43,980 --> 01:04:47,890
但可能第二个你要逐出的页面是干净的，

1375
01:04:49,220 --> 01:04:51,790
那么，在这种情况下，你是否应该违反 LRU-K ，

1376
01:04:51,790 --> 01:04:55,400
因为你试图尽快把事情[弄清楚]。

1377
01:04:56,920 --> 01:04:58,035
不同的系统做不同的事情，

1378
01:04:58,035 --> 01:05:00,855
这就是为什么企业系统比开源系统要好得多，

1379
01:05:00,855 --> 01:05:02,550
因为它们有所有这些元数据，

1380
01:05:02,550 --> 01:05:04,940
它们有所有这些复杂的算法来做出这些决定，

1381
01:05:05,560 --> 01:05:08,490
因为这实际上取决于硬件的速度，

1382
01:05:08,490 --> 01:05:09,825
如果你的磁盘非常快，

1383
01:05:09,825 --> 01:05:10,980
是的，我会把它写出到磁盘，

1384
01:05:10,980 --> 01:05:12,680
我会马上写出脏页，

1385
01:05:12,940 --> 01:05:16,220
因为这将是相当便宜的操作，

1386
01:05:16,660 --> 01:05:18,075
但如果我的磁盘真的很慢，

1387
01:05:18,075 --> 01:05:20,240
或者我必须通过网络写入某个速度较慢的设备，

1388
01:05:20,800 --> 01:05:24,380
那么可能我想要最大限度地减少我必须执行的磁盘写入，

1389
01:05:24,640 --> 01:05:25,820
当我必须逐出一些东西，

1390
01:05:25,840 --> 01:05:29,580
在我需要空间的时刻。

1391
01:05:31,240 --> 01:05:33,110
所以这个问题没有简单的答案，

1392
01:05:35,220 --> 01:05:36,610
如果你所有的页面都是脏的，

1393
01:05:37,230 --> 01:05:38,800
你需要挑选一个你必须写入的，

1394
01:05:41,665 --> 01:05:42,750
但是，有什么方法可以避免这个问题呢，

1395
01:05:43,570 --> 01:05:45,380
在关键路径上没有写入[]，

1396
01:05:45,490 --> 01:05:46,520
当你想要访问页面时。

1397
01:05:52,530 --> 01:05:53,830
后台写入，对吧，

1398
01:05:55,950 --> 01:05:59,710
你可以在后台有一个单独的线程，

1399
01:05:59,730 --> 01:06:01,060
只需浏览你的页表，

1400
01:06:01,410 --> 01:06:05,470
找出什么是脏的，确保日志在磁盘上，

1401
01:06:05,520 --> 01:06:06,470
再次，我们稍后会讨论这个，

1402
01:06:06,470 --> 01:06:08,830
但是假设，你必须首先[]日志，

1403
01:06:09,540 --> 01:06:10,720
找到脏的页面，

1404
01:06:10,950 --> 01:06:12,460
然后继续，并将它们写出去，

1405
01:06:14,810 --> 01:06:15,880
然后你只需对位取反，

1406
01:06:15,880 --> 01:06:17,100
说这个页面现在是干净的，

1407
01:06:17,360 --> 01:06:19,110
这样当驱逐算法运行时，

1408
01:06:19,130 --> 01:06:20,670
它说，好的，我必须逐出一些东西，

1409
01:06:20,900 --> 01:06:23,640
现在有一堆干净的页面选项，可以写出去，

1410
01:06:24,500 --> 01:06:26,610
抱歉，不只是丢弃，可以写入任何东西。

1411
01:06:30,150 --> 01:06:31,340
但是现在存在这样的权衡，

1412
01:06:31,340 --> 01:06:34,235
比如，我的系统是否应该积极地写出脏页，

1413
01:06:34,235 --> 01:06:35,920
可能会干扰查询和事务，

1414
01:06:35,940 --> 01:06:38,440
试图运行应用程序，

1415
01:06:39,540 --> 01:06:42,380
或者我是否应该推迟一下，

1416
01:06:42,580 --> 01:06:43,485
但现在的问题是，

1417
01:06:43,485 --> 01:06:45,320
在某个时候，我需要获得空闲空间，

1418
01:06:45,700 --> 01:06:46,850
而我所有的页面都是脏的，

1419
01:06:48,950 --> 01:06:49,730
这是一个很难的问题，

1420
01:06:49,730 --> 01:06:51,430
没有简单的答案。

1421
01:06:54,580 --> 01:06:57,770
但所有的系统都会有某种机制来进行这种后台写入。

1422
01:07:00,540 --> 01:07:02,375
我们没有，检查点是一个完全不同的[]，

1423
01:07:02,375 --> 01:07:03,580
检查点，你把所有东西都刷新出去，

1424
01:07:04,230 --> 01:07:08,630
但这是发生在每分钟，

1425
01:07:10,380 --> 01:07:11,110
不是每秒钟。

1426
01:07:14,710 --> 01:07:15,110
好的？

1427
01:07:18,330 --> 01:07:19,000
好的，所以，

1428
01:07:20,440 --> 01:07:21,585
现在，我们开始讨论一下，

1429
01:07:21,585 --> 01:07:23,085
何时进行这些磁盘写入和读取，

1430
01:07:23,085 --> 01:07:23,690
我们得讨论一下，

1431
01:07:23,980 --> 01:07:25,700
我们到底要怎么做。

1432
01:07:27,540 --> 01:07:28,780
对于这个，

1433
01:07:29,220 --> 01:07:34,000
当我们对文件系统进行读写调用时，

1434
01:07:34,410 --> 01:07:36,910
假设我们在文件系统上运行，而不是在原始分区，

1435
01:07:38,390 --> 01:07:40,350
在我们的数据库系统下面有很多层，

1436
01:07:40,370 --> 01:07:43,170
比如操作系统、文件系统和硬件，

1437
01:07:44,620 --> 01:07:45,525
这将是聪明的，

1438
01:07:45,525 --> 01:07:49,350
并试图最大化我们可以实现的带宽量，

1439
01:07:49,350 --> 01:07:52,340
通过重新排序和批处理 I/O 请求，

1440
01:07:53,540 --> 01:07:58,770
现代磁盘驱动器或 SSD 或 NVMe 驱动器速度如此之快的部分原因是，

1441
01:07:58,820 --> 01:08:00,280
因为它们有很长的队列，

1442
01:08:00,280 --> 01:08:01,620
它们可以进行并行请求，

1443
01:08:02,060 --> 01:08:03,715
所以，如果你一次只读一次，

1444
01:08:03,715 --> 01:08:04,630
那会非常慢，

1445
01:08:04,630 --> 01:08:05,640
但你可以把事情分批处理，

1446
01:08:05,930 --> 01:08:07,890
并确保你读取一堆连续的数据，

1447
01:08:08,270 --> 01:08:09,240
事情会变得很快。

1448
01:08:10,940 --> 01:08:12,120
但挑战是，

1449
01:08:12,590 --> 01:08:14,910
数据库系统下面的这些不同的系统层，

1450
01:08:16,470 --> 01:08:19,090
不知道这些请求对应于什么，

1451
01:08:19,290 --> 01:08:22,120
它们只看到读写某个位置或某个地址的页面，

1452
01:08:22,590 --> 01:08:23,255
他们不知道，

1453
01:08:23,255 --> 01:08:24,580
哦，这是来自后台写入的，

1454
01:08:24,780 --> 01:08:25,790
或者这是索引的，

1455
01:08:25,790 --> 01:08:28,480
或者这是我现在需要运行的查询的。

1456
01:08:30,400 --> 01:08:32,660
所以，你可以玩一些游戏，

1457
01:08:33,430 --> 01:08:35,780
在 Linux 中，设置 I/O 优先级，

1458
01:08:36,280 --> 01:08:37,860
但这是一把[大锤]，

1459
01:08:37,860 --> 01:08:39,110
你唯一能做的是，

1460
01:08:39,250 --> 01:08:43,230
更改每个进程级别上的 I/O 优先级，

1461
01:08:43,670 --> 01:08:45,570
你不能对每个请求执行此操作，

1462
01:08:45,590 --> 01:08:46,710
这才是我们真正想要的。

1463
01:08:48,560 --> 01:08:50,845
如果你阅读了大量不同的数据库系统的文档，

1464
01:08:50,845 --> 01:08:53,670
他们会告诉你，所有人都放弃默认的 Linux 调度程序，

1465
01:08:54,380 --> 01:08:55,440
也就是 Fair 调度程序，

1466
01:08:55,550 --> 01:08:56,695
要么使用 deadline ，

1467
01:08:56,695 --> 01:08:58,860
要么使用简单的 FIFO 队列 noop ，

1468
01:09:00,710 --> 01:09:03,415
因为他们不想要数据库系统，

1469
01:09:03,415 --> 01:09:04,885
他们不想让操作系统做一堆数据，

1470
01:09:04,885 --> 01:09:08,520
数据库系统无法控制的事情。

1471
01:09:10,750 --> 01:09:11,325
这就是为什么，

1472
01:09:11,325 --> 01:09:12,270
在大多数据库系统中，

1473
01:09:12,270 --> 01:09:18,230
他们将在操作系统上方拥有自己的小[填充]层，

1474
01:09:19,320 --> 01:09:21,590
这将负责跟踪，

1475
01:09:21,880 --> 01:09:25,550
缓冲池管理器中哪些未完成的读写请求，

1476
01:09:26,890 --> 01:09:30,320
并决定如何将它们组合在一起以优化性能，

1477
01:09:31,840 --> 01:09:36,020
基本上，你考虑确定这些不同 I/O 请求的优先级，

1478
01:09:36,190 --> 01:09:38,180
基于多种不同的因素，

1479
01:09:38,680 --> 01:09:41,210
因为，我们知道查询试图做什么，

1480
01:09:41,350 --> 01:09:43,070
我们知道缓冲池中有哪些页面，

1481
01:09:43,120 --> 01:09:44,505
我们知道什么是脏的，什么不是脏的，

1482
01:09:44,505 --> 01:09:46,100
我们知道什么是未解决的请求。

1483
01:09:47,970 --> 01:09:49,355
所以，为了跟踪，

1484
01:09:49,355 --> 01:09:51,340
顺序 I/O 和随机 I/O 之类的东西，

1485
01:09:52,530 --> 01:09:54,350
请求是基于关键路径的，

1486
01:09:54,350 --> 01:09:55,960
比如查询现在就需要这个，

1487
01:09:56,640 --> 01:09:59,650
或者这是后台工作，后台写入，

1488
01:09:59,970 --> 01:10:02,080
所以，可能会有较低的优先级，

1489
01:10:03,370 --> 01:10:07,400
我们正在访问的表、索引、日志记录的数据，

1490
01:10:07,690 --> 01:10:09,470
我们希望尽可能快地刷新日志，

1491
01:10:10,330 --> 01:10:11,540
它是否针对临时数据的，

1492
01:10:12,670 --> 01:10:14,750
如果是对表的顺序扫描，

1493
01:10:15,550 --> 01:10:16,940
它将有较低的优先级，

1494
01:10:17,020 --> 01:10:19,070
可能会随机访问索引，

1495
01:10:19,090 --> 01:10:20,930
因为当你遍历 B+ 树时，

1496
01:10:21,070 --> 01:10:23,030
你会在向下移动时持有 latch ，

1497
01:10:23,620 --> 01:10:26,145
因此这将阻止其他线程同时运行，

1498
01:10:26,145 --> 01:10:28,970
但是，如果你的扫描队列查询速度稍慢一些，

1499
01:10:29,380 --> 01:10:32,600
从技术上讲，你可能不会干扰同时运行的其他查询，

1500
01:10:33,420 --> 01:10:34,295
这不是真的，

1501
01:10:34,295 --> 01:10:37,960
因为当你运行查询和事务时，你会拿到锁，

1502
01:10:38,280 --> 01:10:41,170
所以没有简单的答案，

1503
01:10:41,890 --> 01:10:43,830
当一个比另一个更快时，

1504
01:10:43,830 --> 01:10:44,385
你不能仅仅，

1505
01:10:44,385 --> 01:10:45,800
因为它是一个索引，因为它是一个表，

1506
01:10:46,180 --> 01:10:48,800
再次，操作系统不知道它是一个索引页还是一个表页。

1507
01:10:50,200 --> 01:10:51,705
有时，在一些系统中，

1508
01:10:51,705 --> 01:10:55,310
你可以有 SLA 服务级别协议或服务级别目标，

1509
01:10:55,540 --> 01:10:59,090
比如，我的查询必须在特定的最后期限内以特定的延迟运行，

1510
01:10:59,750 --> 01:11:01,060
这样做的典型方式是，

1511
01:11:01,060 --> 01:11:02,275
你有不同的用户帐户，

1512
01:11:02,275 --> 01:11:05,040
并为一个用户帐户赋予比另一个用户帐户更高的优先级，

1513
01:11:05,540 --> 01:11:09,960
比如，前端应用程序具有比夜间报告作业更高的优先级，

1514
01:11:10,850 --> 01:11:12,330
你可以根据用户角色来执行。

1515
01:11:16,860 --> 01:11:19,955
所以，我们可以获得更好的性能，

1516
01:11:19,955 --> 01:11:25,235
并试图避免操作系统的某些干扰的方法是，

1517
01:11:25,235 --> 01:11:26,620
使用所谓的直接 I/O ，

1518
01:11:28,040 --> 01:11:30,895
所以，在很大程度上，你的所有磁盘操作，

1519
01:11:30,895 --> 01:11:33,150
都必须通过 OS API ，

1520
01:11:33,590 --> 01:11:37,560
除非你执行类似于直接，绕过内核到硬件设备的操作，

1521
01:11:37,940 --> 01:11:39,330
但大多数系统不会这样做。

1522
01:11:41,100 --> 01:11:42,605
这里的想法是，

1523
01:11:42,605 --> 01:11:46,090
我们不希望操作系统维护自己的缓存，称为页面缓存，

1524
01:11:46,650 --> 01:11:49,900
因为我们不希望操作系统缓冲我们的读取和写入，

1525
01:11:50,770 --> 01:11:52,640
我们希望完全靠我们自己做这个，

1526
01:11:53,480 --> 01:11:56,010
因为，我们希望完全控制硬件。

1527
01:11:57,380 --> 01:11:58,225
所以这个想法是这样的，

1528
01:11:58,225 --> 01:12:01,530
如果我对文件系统执行读取，

1529
01:12:02,420 --> 01:12:03,580
那么操作系统会说，

1530
01:12:03,580 --> 01:12:08,370
哦，让我在操作系统中维护我自己的小缓冲池，

1531
01:12:08,900 --> 01:12:12,810
跨操作系统全局运行的所有进程，

1532
01:12:13,490 --> 01:12:17,190
然后我会将我需要的数据存储在我的页面缓存中，

1533
01:12:17,600 --> 01:12:18,870
然后下一次我进行读取时，

1534
01:12:18,950 --> 01:12:20,550
我会为我的页面缓存获取这些数据。

1535
01:12:21,610 --> 01:12:24,225
所以，我们想要绕过这个，绕过它，

1536
01:12:24,225 --> 01:12:25,850
直接进入硬件，

1537
01:12:26,440 --> 01:12:29,120
而不是让操作系统缓冲任何东西。

1538
01:12:30,880 --> 01:12:32,820
所以大多数系统使用直接 I/O ，

1539
01:12:32,820 --> 01:12:34,430
大多数系统默认使用直接 I/O ，

1540
01:12:35,560 --> 01:12:36,950
只有一个系统不是这样的，

1541
01:12:39,200 --> 01:12:40,110
有人猜猜是什么。

1542
01:12:41,840 --> 01:12:42,780
SingleStore ，不是。

1543
01:12:44,470 --> 01:12:45,230
MySQL ，不是。

1544
01:12:46,135 --> 01:12:47,830
它是 Postgres ，

1545
01:12:47,830 --> 01:12:49,860
Postgres ，因为它是八十年代的遗物，

1546
01:12:51,110 --> 01:12:52,860
他们严重依赖操作系统页面缓存，

1547
01:12:53,670 --> 01:12:54,190
它调用，

1548
01:12:54,690 --> 01:12:56,980
当你在 Postgres 中分配缓冲池时，

1549
01:12:57,150 --> 01:12:59,830
你设置，它大约是机器上内存量的 30-40% ，

1550
01:13:00,630 --> 01:13:04,570
MySQL 和所有其他数据库系统都会告诉你使用机箱中可用内存的 80% ，

1551
01:13:05,040 --> 01:13:05,825
因为在 Postgres 中，

1552
01:13:05,825 --> 01:13:08,440
他们想要一些内存用于页面缓存和操作系统，

1553
01:13:08,610 --> 01:13:09,970
一些内存用于数据库系统。

1554
01:13:11,130 --> 01:13:12,040
那么，这有什么问题，

1555
01:13:12,540 --> 01:13:14,230
现在我得到了我的页面的多余副本，

1556
01:13:14,790 --> 01:13:16,145
操作系统将拥有我的页面的副本，

1557
01:13:16,145 --> 01:13:17,830
我的数据库系统将拥有我的页面的副本，

1558
01:13:18,300 --> 01:13:19,750
读和写都是一样的，

1559
01:13:20,670 --> 01:13:24,250
然后，数据库系统将有自己的策略，

1560
01:13:24,780 --> 01:13:26,560
来决定如何逐出哪些页面，

1561
01:13:27,000 --> 01:13:30,310
但是，因为我在我的数据库系统中从我的缓冲池中逐出它，

1562
01:13:30,600 --> 01:13:33,070
操作系统就可以随心所欲地决定逐出它，

1563
01:13:33,680 --> 01:13:35,550
再说一次，它不知道页面实际上代表了什么，

1564
01:13:37,350 --> 01:13:40,925
然后，你也会失去控制，当东西刷新到磁盘时，

1565
01:13:40,925 --> 01:13:41,530
除非你很小心，

1566
01:13:44,670 --> 01:13:47,855
所以，让我们看看你们能在这里得到这些答案，

1567
01:13:47,855 --> 01:13:49,000
即使你没有上过操作系统课程。

1568
01:13:49,760 --> 01:13:51,310
所以，如果你调用 fwrite ，会发生什么？

1569
01:13:53,900 --> 01:13:55,260
我打开一个文件，

1570
01:13:55,370 --> 01:13:56,910
比如我的数据库文件，

1571
01:13:57,470 --> 01:13:59,305
我让我的缓冲池管理器带来一个页面，

1572
01:13:59,305 --> 01:14:02,010
在其他查询中更新它，

1573
01:14:02,270 --> 01:14:03,090
页面脏了，

1574
01:14:03,320 --> 01:14:05,110
我调用 fwrite 将那一页写出磁盘，

1575
01:14:05,110 --> 01:14:05,520
会发生什么事？

1576
01:14:08,590 --> 01:14:09,920
假设我们没有使用直接 I/O ，

1577
01:14:12,830 --> 01:14:14,460
页面位于操作系统页面缓存中，

1578
01:14:14,990 --> 01:14:16,330
因为操作系统试图变得更聪明，

1579
01:14:16,330 --> 01:14:17,970
并试图让事情变得更快，

1580
01:14:19,990 --> 01:14:21,230
那么它已经存储在磁盘上了吗，

1581
01:14:21,340 --> 01:14:23,660
当我得到，当 fwrite 返回时，

1582
01:14:23,740 --> 01:14:25,610
我的数据保存了吗，

1583
01:14:26,390 --> 01:14:28,650
不，因为它在操作系统页面缓存中，

1584
01:14:29,400 --> 01:14:30,740
它在什么时候刷新到磁盘，

1585
01:14:32,610 --> 01:14:34,690
当操作系统决定做它的时候，

1586
01:14:36,080 --> 01:14:38,485
但我们想要确保我们的东西在磁盘上，

1587
01:14:38,485 --> 01:14:39,690
所以我们调用 fsync ，

1588
01:14:41,330 --> 01:14:42,270
fsync 是做什么的？

1589
01:14:44,290 --> 01:14:44,720
刷新。

1590
01:14:45,250 --> 01:14:45,860
刷新什么？

1591
01:14:47,200 --> 01:14:48,495
磁盘上的脏页面，

1592
01:14:48,495 --> 01:14:50,720
你可以聪明，你会做[范围]，

1593
01:14:50,950 --> 01:14:51,680
并不总是起作用，

1594
01:14:52,930 --> 01:14:54,890
然后调用 fsync 将被阻塞，

1595
01:14:55,940 --> 01:14:59,310
直到硬件返回，说你的数据是持久的。

1596
01:15:00,130 --> 01:15:01,545
硬件也可以玩这个游戏，

1597
01:15:01,545 --> 01:15:03,530
因为有时硬件下面有一个小电池，

1598
01:15:03,910 --> 01:15:05,130
所以你会得到你的写入，

1599
01:15:05,130 --> 01:15:06,470
那仍然在易失性内存上，

1600
01:15:06,730 --> 01:15:09,465
但如果有电力，你可以发送回复，

1601
01:15:09,465 --> 01:15:10,520
我得到了你的写入，

1602
01:15:10,930 --> 01:15:11,970
但随后就会出现断电，

1603
01:15:11,970 --> 01:15:13,340
有足够的电池电量，

1604
01:15:13,360 --> 01:15:15,980
然后确保它被写入磁盘，

1605
01:15:16,570 --> 01:15:18,910
所以它不是，

1606
01:15:19,170 --> 01:15:20,890
在那个时刻，我总是在 NAND 闪存上，

1607
01:15:21,090 --> 01:15:22,900
但是，通常，这已经足够好了。

1608
01:15:24,230 --> 01:15:25,920
但是，如果 fsync 调用失败会发生什么，

1609
01:15:26,750 --> 01:15:28,530
如果 fync 说我不能为你做这个，

1610
01:15:30,630 --> 01:15:31,360
那是什么意思？

1611
01:15:36,030 --> 01:15:37,120
假设操作系统没有崩溃，

1612
01:15:38,040 --> 01:15:39,220
fsync 只是返回一个错误，

1613
01:15:44,660 --> 01:15:47,770
在 Linux 上，它会标记脏页是干净的，

1614
01:15:48,510 --> 01:15:49,610
这不是内核 panic ，

1615
01:15:49,610 --> 01:15:50,800
它说这些页面是干净的，

1616
01:15:51,240 --> 01:15:52,240
即使 fsync 失败了，

1617
01:15:52,890 --> 01:15:55,600
然后再次调用 fsync ，它将会，

1618
01:15:55,800 --> 01:15:58,450
在你想要通过 fwrite 写入磁盘的那些页面，

1619
01:15:58,740 --> 01:16:00,430
它会回来说，是的，我拿到了，

1620
01:16:01,190 --> 01:16:02,920
它们是干净的，在磁盘上，

1621
01:16:03,560 --> 01:16:05,840
但它对你撒谎了，

1622
01:16:06,900 --> 01:16:07,930
它为什么要对你撒谎，

1623
01:16:11,090 --> 01:16:15,060
因为内核开发人员担心有人拔出 U盘，

1624
01:16:15,440 --> 01:16:17,040
然后 fsync 失败，

1625
01:16:17,210 --> 01:16:22,140
在它的页表中有一堆脏页面被标记为脏的，

1626
01:16:22,460 --> 01:16:24,280
这些页面再也不会回来了，

1627
01:16:24,280 --> 01:16:26,790
因为你再也不会把 U盘 放回去了，

1628
01:16:27,630 --> 01:16:29,050
这对数据库来说是正确的吗，

1629
01:16:29,940 --> 01:16:33,580
不，是吧，我们不运行在 U盘上。

1630
01:16:35,150 --> 01:16:37,300
所以，我们需要完全控制一切，

1631
01:16:37,300 --> 01:16:38,310
以确保我们做的事情是正确的，

1632
01:16:39,220 --> 01:16:40,740
好的，事实证明，

1633
01:16:41,090 --> 01:16:44,880
二十年来，人们不知道 fsync 在这种情况下是坏掉的，

1634
01:16:45,890 --> 01:16:49,920
所以在 2018 年，有一起名为 fsyncgate 的丑闻，

1635
01:16:50,180 --> 01:16:53,545
在 Postgres 邮件列表上有人报告说，

1636
01:16:53,545 --> 01:16:55,650
嘿， Postgres 丢失了我的一些数据，

1637
01:16:56,570 --> 01:16:59,430
但是，我从来没有遇到过内核 panic ，我从来没有失败过，

1638
01:17:00,200 --> 01:17:02,290
事实证明，因为 fsync ，

1639
01:17:03,000 --> 01:17:04,010
在所有这些数据库系统上，

1640
01:17:04,060 --> 01:17:05,070
他们会调用 fsync ，

1641
01:17:05,070 --> 01:17:06,050
fsync 会返回错误，

1642
01:17:06,190 --> 01:17:08,780
他们只是将其放入 while 循环中，并再次调用它，

1643
01:17:09,250 --> 01:17:10,590
然后 fsync 回来说，

1644
01:17:10,590 --> 01:17:11,310
是的，我得到了它，

1645
01:17:11,310 --> 01:17:13,530
因为他们标记了你的页面从脏的到干净的，

1646
01:17:13,530 --> 01:17:14,540
尽管它们从来没有写入。

1647
01:17:15,460 --> 01:17:16,710
不仅是 Postgres 有这个问题，

1648
01:17:16,710 --> 01:17:17,520
MySQL 有这个问题，

1649
01:17:17,520 --> 01:17:18,450
MongoDB 有这个问题，

1650
01:17:18,450 --> 01:17:20,270
以及 WiredTiger ，很多其他系统。

1651
01:17:21,140 --> 01:17:22,120
那么现在他们怎么做，

1652
01:17:22,960 --> 01:17:25,510
如果 fsync 失败，那么系统就会崩溃，

1653
01:17:25,510 --> 01:17:27,270
然后你就得弄清楚到底是怎么回事，

1654
01:17:28,310 --> 01:17:33,410
但二十年来，人们并不知道这是一个问题。

1655
01:17:34,320 --> 01:17:37,100
所以这不是页面缓存的问题，

1656
01:17:37,210 --> 01:17:40,860
但是这是我们需要确保完全控制的例子，

1657
01:17:40,860 --> 01:17:43,910
从磁盘读取和写入内存，

1658
01:17:44,440 --> 01:17:46,515
当我们将内容写出磁盘时，

1659
01:17:46,515 --> 01:17:49,070
我们希望确保它是保存和正确的，

1660
01:17:49,930 --> 01:17:51,560
操作系统可能会对我们撒谎，

1661
01:17:51,610 --> 01:17:53,420
因为操作系统不关心数据库，

1662
01:17:53,890 --> 01:17:55,040
因为操作系统担心f

1663
01:17:55,570 --> 01:17:58,280
有人带着 U盘或其他什么东西，

1664
01:17:58,870 --> 01:18:00,500
因为它试图成为一个通用系统，

1665
01:18:01,210 --> 01:18:02,565
所以，我们需要确保，

1666
01:18:02,565 --> 01:18:03,860
我们作为操作库系统开发人员，

1667
01:18:04,600 --> 01:18:05,685
将机制放在适当的位置，

1668
01:18:05,685 --> 01:18:07,370
以确保我们不会被搞砸。

1669
01:18:10,590 --> 01:18:10,990
好的？

1670
01:18:12,370 --> 01:18:16,280
好的，所以还有其他的多种池，除了我们所说的以外，

1671
01:18:16,600 --> 01:18:18,735
想想 JOIN 用的临时缓存和之类的东西，

1672
01:18:18,735 --> 01:18:19,460
我们稍后会看到这个。

1673
01:18:19,870 --> 01:18:20,270
好的。

1674
01:18:20,820 --> 01:18:23,240
所以我们总是比操作系统更好，

1675
01:18:23,590 --> 01:18:26,270
不管 Linux 的人说什么，操作系统的人说什么，

1676
01:18:27,490 --> 01:18:30,825
因为我们知道查询计划要做什么，

1677
01:18:30,825 --> 01:18:32,690
我们知道查询如何访问数据，

1678
01:18:32,950 --> 01:18:34,670
我们总是可以做更好的事情。

1679
01:18:35,980 --> 01:18:36,870
下一节课是哈希表，

1680
01:18:37,070 --> 01:18:38,520
但让我非常快地谈谈项目一，

1681
01:18:38,870 --> 01:18:41,520
很明显，你将在 BusTub 中实现这个，

1682
01:18:41,750 --> 01:18:42,870
所以你有三个部分，

1683
01:18:43,460 --> 01:18:44,760
LRU-K 替换策略，

1684
01:18:45,470 --> 01:18:47,170
一个磁盘调度器，一个非常原始的，

1685
01:18:47,170 --> 01:18:49,200
然后是实际的缓冲池管理器实例本身。

1686
01:18:53,020 --> 01:18:54,230
对于第一个，

1687
01:18:54,610 --> 01:18:57,045
你需要一个单独的类来实现它，

1688
01:18:57,045 --> 01:18:58,640
基本上跟踪所有页面，

1689
01:18:59,050 --> 01:19:01,335
然后有要实现的 API ，

1690
01:19:01,335 --> 01:19:03,800
它说我需要，给我一个要逐出的页面，

1691
01:19:04,480 --> 01:19:05,785
所以，你可以先实现它，

1692
01:19:05,785 --> 01:19:10,960
然后有测试确保这个正确的工作，

1693
01:19:11,190 --> 01:19:14,435
如果在你检查时没有任何页面被访问，

1694
01:19:14,435 --> 01:19:16,090
则始终返回最低的页面 ID ，

1695
01:19:16,200 --> 01:19:17,740
同样，你必须修复一些东西，

1696
01:19:18,970 --> 01:19:20,810
所以，你可以根据这个来逐出什么。

1697
01:19:22,470 --> 01:19:24,970
接下来，实现一个磁盘调度器，

1698
01:19:24,990 --> 01:19:27,760
基本上，你将同时处理一组请求或不同的线程，

1699
01:19:28,020 --> 01:19:33,970
然后让单个队列决定读取和写入的顺序，

1700
01:19:35,510 --> 01:19:37,170
你实现这个 API 的方法，

1701
01:19:37,490 --> 01:19:38,760
这里有一个回调机制，

1702
01:19:38,870 --> 01:19:42,570
通过 C++ 的 promise API, promise 构造，

1703
01:19:42,920 --> 01:19:44,275
这是一个函数，你需要调用，

1704
01:19:44,275 --> 01:19:50,190
一旦请求者等待的页面、数据可用，

1705
01:19:50,780 --> 01:19:51,720
你就可以回调，

1706
01:19:52,070 --> 01:19:53,730
它不会是真正的异步 I/O ，

1707
01:19:55,280 --> 01:19:59,550
但是，因为发出请求的线程将在此回调上阻塞，

1708
01:20:00,050 --> 01:20:02,190
但这将是做更复杂事情的基石，

1709
01:20:02,760 --> 01:20:05,320
所以，请确保你在这里构建的代码是线程安全的。

1710
01:20:06,580 --> 01:20:08,270
最后一件事是缓冲池管理器本身，

1711
01:20:08,620 --> 01:20:12,020
这将建立在 LRU-K 实现和你的磁盘调度器的基础上，

1712
01:20:12,310 --> 01:20:16,665
你可以使用磁盘调度器维护内部数据结构，

1713
01:20:16,665 --> 01:20:18,800
并跟踪哪些页面是空闲的，以及何时访问这些页面，

1714
01:20:19,120 --> 01:20:20,910
而每年总是让人犯错的一件事是，

1715
01:20:20,910 --> 01:20:22,550
确保你得到了正确的顺序，

1716
01:20:23,380 --> 01:20:24,650
在你 pinning 和 unpinning 的时候。

1717
01:20:26,350 --> 01:20:30,980
所以，六可能不是正确的数字，但不要更改任何其他文件，

1718
01:20:31,900 --> 01:20:34,640
因为所有内容都会被覆盖，当你把它装入 GradeScope 时，

1719
01:20:34,810 --> 01:20:36,105
这些项目是累积性的，

1720
01:20:36,105 --> 01:20:41,150
我们不会编写解决方案，然后将所有内容发布到 Piazza 上，

1721
01:20:41,860 --> 01:20:44,150
就像在项目零中，你必须确保你有良好的代码质量，

1722
01:20:44,380 --> 01:20:47,840
所以，请确保你运行 make format ，然后 check-clang-tidy ，

1723
01:20:48,430 --> 01:20:51,830
因为如果你不这样做，你上传到 GradeScope ，你会得到零，

1724
01:20:52,470 --> 01:20:54,580
我们有，

1725
01:20:55,980 --> 01:20:58,070
这个项目和所有其他项目，将有额外的学分，

1726
01:20:58,070 --> 01:20:59,015
有一个排行榜，

1727
01:20:59,015 --> 01:21:01,990
有超出核心要求的额外任务，

1728
01:21:02,520 --> 01:21:05,650
当你的东西提交到 GradeScope 时，你会得到排名，

1729
01:21:06,000 --> 01:21:10,270
然后排名前 20 的学生将获得这个项目的加分，

1730
01:21:10,860 --> 01:21:12,350
这将适用于所有四个项目，

1731
01:21:12,820 --> 01:21:17,850
然后在学期末的学生有最高的奖励分数，

1732
01:21:17,850 --> 01:21:20,690
所有的学生都将获得一件限量版 BusTub 连帽衫，

1733
01:21:21,700 --> 01:21:23,870
所以你得填一张税单，因为是限量版，

1734
01:21:24,190 --> 01:21:25,320
他们花了 5000 美元，

1735
01:21:25,320 --> 01:21:28,520
CMU 将处理这方面的文书工作，

1736
01:21:28,540 --> 01:21:30,650
但这是非常值得的。

1737
01:21:31,330 --> 01:21:32,810
不要抄袭，

1738
01:21:32,920 --> 01:21:36,920
因为 GradeScope 有自动抄袭检查器，

1739
01:21:37,060 --> 01:21:38,930
我们去找 [] 在 GitHub 上，

1740
01:21:39,130 --> 01:21:40,215
我们把他们当作假学生，

1741
01:21:40,215 --> 01:21:41,210
如果你抄袭他们，

1742
01:21:41,440 --> 01:21:42,380
你会被标记。

