1
00:00:29,860 --> 00:00:31,940
我会在周三发布一些信息给你们，

2
00:00:32,200 --> 00:00:33,530
所以如果你有空的话，

3
00:00:33,730 --> 00:00:36,380
晚上 11 点到 1 点，

4
00:00:38,010 --> 00:00:40,895
好的，你说你有一个保镖，

5
00:00:40,895 --> 00:00:43,625
他会忽略身份证，或者你有假身份证，

6
00:00:43,625 --> 00:00:45,280
你会把它当做生意来分发，

7
00:00:45,960 --> 00:00:48,640
所有这些信息我都不能在课上说出来。

8
00:00:48,660 --> 00:00:50,980
好的，请不要那样做，请不要那样做。

9
00:00:51,800 --> 00:00:52,945
好的，很好，

10
00:00:52,945 --> 00:00:55,975
我们会为你们中的一些人准备一份旅行报告，

11
00:00:55,975 --> 00:00:57,030
所以。

12
00:00:57,410 --> 00:00:59,875
好的，很抱歉花了一点时间才开始，

13
00:00:59,875 --> 00:01:01,680
我在办公时间有一大群人，

14
00:01:02,750 --> 00:01:05,910
但我们今天要讨论的是并发控制。

15
00:01:06,480 --> 00:01:09,140
让我们直截了当地开始吧。

16
00:01:09,160 --> 00:01:11,330
好的，让我们开始这个。

17
00:01:11,860 --> 00:01:15,860
你已经看到了数据库引擎的示意图，

18
00:01:15,880 --> 00:01:18,350
作为不同组件的模块化体系结构。

19
00:01:18,880 --> 00:01:23,840
今天我们将讨论并发控制机制，

20
00:01:23,950 --> 00:01:25,950
影响这些不同层，

21
00:01:25,950 --> 00:01:29,360
这在很大程度上影响到操作执行层和访问方法层。

22
00:01:29,800 --> 00:01:30,925
从现在开始的两节课中，

23
00:01:30,925 --> 00:01:32,305
我们将讨论恢复方法，

24
00:01:32,305 --> 00:01:34,920
这在缓冲池层和磁盘管理器层。

25
00:01:35,120 --> 00:01:37,135
现在，所有这些都将变得更加清晰，

26
00:01:37,135 --> 00:01:40,230
随着我们深入了解事务管理的含义，

27
00:01:40,490 --> 00:01:41,700
恢复的含义。

28
00:01:41,840 --> 00:01:44,280
所以让我们直接开始吧。

29
00:01:45,370 --> 00:01:50,960
所以，事务管理允许我们在数据库系统中安全地做事情，

30
00:01:51,580 --> 00:01:56,330
在同时更新多个东西的情况下。

31
00:01:57,080 --> 00:01:58,270
让我们从一个简单的例子开始。

32
00:01:59,260 --> 00:02:03,920
这是一个数据库操作的示意图，

33
00:02:04,060 --> 00:02:05,900
这些可以通过一个 SQL 查询来触发，

34
00:02:06,340 --> 00:02:08,960
从事务管理组件的角度来看，

35
00:02:09,280 --> 00:02:13,700
我们将在很大程度上查看对象级别发生的操作。

36
00:02:13,840 --> 00:02:15,260
想象一下，我们启动了一个事务，

37
00:02:15,850 --> 00:02:17,840
它最终读取一个对象，

38
00:02:17,950 --> 00:02:19,650
可能是一个记录，也可能是一个页面，

39
00:02:19,650 --> 00:02:22,700
在这节课中，我们只将它们称为对象，

40
00:02:22,960 --> 00:02:24,830
对该值进行一些检查，

41
00:02:25,360 --> 00:02:26,690
执行一些操作，比如支付，

42
00:02:26,770 --> 00:02:30,135
然后通过从 A 中减去 25 来更新它，

43
00:02:30,135 --> 00:02:31,880
最终将其写入，

44
00:02:32,710 --> 00:02:35,240
为了讨论事务管理，

45
00:02:35,740 --> 00:02:39,495
我们主要关注读写操作，

46
00:02:39,495 --> 00:02:42,290
这些数据库对象中所发生的，

47
00:02:42,550 --> 00:02:45,975
你可以把它们想象成记录、页面、表等，

48
00:02:45,975 --> 00:02:46,520
这无关紧要，

49
00:02:46,900 --> 00:02:51,860
只是假设我们关心的是数据库中对象的读取和写入。

50
00:02:52,200 --> 00:02:55,185
我们希望有关于这些读写的某些属性。

51
00:02:55,185 --> 00:02:58,645
来确保我们定义的正确性概念，

52
00:02:58,645 --> 00:03:00,510
这就是事务管理所做的。

53
00:03:01,160 --> 00:03:02,350
那么，可能会出什么问题，

54
00:03:02,430 --> 00:03:04,540
这是一组简单的操作，

55
00:03:04,680 --> 00:03:05,980
它们被呈现给数据库，

56
00:03:06,360 --> 00:03:10,420
以响应应用程序可能发送的查询，

57
00:03:10,830 --> 00:03:12,515
可能出现的几个错误。

58
00:03:12,515 --> 00:03:14,555
所以在右边，

59
00:03:14,555 --> 00:03:18,360
你可以看到银行余额开始的值为 100 ，

60
00:03:18,950 --> 00:03:21,450
发生的第一件事是检查，

61
00:03:21,680 --> 00:03:23,070
一切看起来是正常的，

62
00:03:23,330 --> 00:03:25,470
它说是的，那个检查通过了，

63
00:03:25,490 --> 00:03:28,210
所以有足够的余额来支付 25 美元，

64
00:03:28,210 --> 00:03:31,290
所以这是你去自动取款机要求取款，

65
00:03:32,070 --> 00:03:34,340
然后付给你 25 美元，

66
00:03:34,340 --> 00:03:35,320
这样你就有了它，

67
00:03:35,520 --> 00:03:37,690
新的余额计算出来，

68
00:03:38,010 --> 00:03:40,300
现在，这些余额会记入你的银行账户。

69
00:03:40,590 --> 00:03:42,580
好的，在计算出新的余额后，

70
00:03:42,750 --> 00:03:45,620
银行余额为 75 的最后一个操作，

71
00:03:45,620 --> 00:03:49,540
是你在左侧代码中看到的写入操作。

72
00:03:50,120 --> 00:03:52,140
但是现在，如果，

73
00:03:52,780 --> 00:03:55,830
在 ATM 机吐出25美元后，

74
00:03:57,650 --> 00:04:00,130
你去拉了 ATM 机的电源线，

75
00:04:00,130 --> 00:04:01,560
这样它就不能把写入发回了，

76
00:04:02,450 --> 00:04:03,715
好的，想象一下你那么快，

77
00:04:03,715 --> 00:04:05,400
或者是自然停电了，

78
00:04:05,870 --> 00:04:07,980
所以支付操作，

79
00:04:09,070 --> 00:04:11,840
和对数据库的写入不是原子的，

80
00:04:11,860 --> 00:04:13,140
它们发生在不同的系统中，

81
00:04:13,140 --> 00:04:15,140
它们甚至可能在地理上分布得很广，

82
00:04:15,400 --> 00:04:18,260
在这些行动之间，可能会发生糟糕的事情。

83
00:04:18,850 --> 00:04:21,830
那么，我们如何确保这笔交易是正确的，

84
00:04:22,090 --> 00:04:23,265
显然，我们不希望这样，

85
00:04:23,265 --> 00:04:24,510
你的银行会非常不安，

86
00:04:24,510 --> 00:04:26,120
如果数据库系统是这样工作的，

87
00:04:26,500 --> 00:04:29,010
因为如果发生这个，他们会赔钱。

88
00:04:29,450 --> 00:04:31,435
那么我们希望这种类型的东西受到保护，

89
00:04:31,435 --> 00:04:32,490
我们将讨论如何保护。

90
00:04:33,130 --> 00:04:34,130
这是另一个场景，

91
00:04:34,240 --> 00:04:35,120
一个不同的场景，

92
00:04:35,980 --> 00:04:38,900
展示了一个我们也需要担心的不同类型的问题。

93
00:04:39,160 --> 00:04:42,110
所以，这不是停电或诸如此类的事情，

94
00:04:42,190 --> 00:04:43,340
而是同时发生的行动。

95
00:04:44,050 --> 00:04:44,580
所以想象一下，

96
00:04:44,580 --> 00:04:47,145
你和你的另一半都共享这个银行账户，

97
00:04:47,145 --> 00:04:49,130
你有个人借记卡，

98
00:04:49,390 --> 00:04:51,890
允许你从同一个银行账户借记，

99
00:04:52,320 --> 00:04:54,390
你们两个去两个不同的 ATM 机，

100
00:04:54,390 --> 00:04:57,390
同时执行这笔交易，

101
00:04:57,590 --> 00:05:02,130
你们两个都在运行取款 25 美元的操作序列，

102
00:05:02,960 --> 00:05:06,240
余额足够在两边检查通过，

103
00:05:06,800 --> 00:05:09,270
你得到付款， ATM 吐出了 25 美元，

104
00:05:09,770 --> 00:05:11,310
你的另一半也得到了付款，

105
00:05:11,570 --> 00:05:14,680
但是现在，因为他们两人都读取了原始的银行余额，

106
00:05:14,680 --> 00:05:17,430
他们都计算出了新的余额为 75 ，

107
00:05:18,780 --> 00:05:20,290
因为一切看起来都是对的，

108
00:05:20,610 --> 00:05:22,990
然后第一个写入，

109
00:05:23,610 --> 00:05:25,235
第二个覆盖了它，

110
00:05:25,235 --> 00:05:27,160
现在银行缺少了 25 美元。

111
00:05:27,870 --> 00:05:30,960
再说一次，对银行来说，这不是一个理想的局面，

112
00:05:31,100 --> 00:05:32,605
银行永远不会使用数据库系统，

113
00:05:32,605 --> 00:05:34,650
或者企业不会使用数据库系统，

114
00:05:34,940 --> 00:05:36,780
如果允许这种事情发生。

115
00:05:37,400 --> 00:05:38,150
所以，在语义上，

116
00:05:38,150 --> 00:05:39,170
我们希望的是，

117
00:05:39,170 --> 00:05:41,110
我们希望数据库，

118
00:05:41,850 --> 00:05:44,890
发送这个读写请求的应用，

119
00:05:45,060 --> 00:05:46,930
由一些应用程序代码编写的，

120
00:05:47,370 --> 00:05:50,080
向数据库系统发送 SQL 查询，

121
00:05:50,370 --> 00:05:53,320
现在应用程序代码编写者没有错误，

122
00:05:53,640 --> 00:05:55,570
这就是应用程序代码编写者做的事情，

123
00:05:55,770 --> 00:05:56,915
有效地编写代码，

124
00:05:56,915 --> 00:05:59,860
最终将这些读写操作发送给数据库，

125
00:06:00,210 --> 00:06:02,710
它感觉是数据库系统在破坏数据，

126
00:06:02,940 --> 00:06:06,155
这显然不是我们想要的数据库系统，

127
00:06:06,155 --> 00:06:07,660
我们希望它表现良好，

128
00:06:07,800 --> 00:06:10,900
我们想要最后的余额，在这种情况下，是 50 美元。

129
00:06:11,540 --> 00:06:16,410
好的，那么我们如何处理这些糟糕的系统行为，

130
00:06:17,250 --> 00:06:19,340
并使数据库保持一致，

131
00:06:19,340 --> 00:06:22,085
因为最终数据库是记录的保管者，

132
00:06:22,085 --> 00:06:25,250
这是你在银行账户中的主副本，

133
00:06:25,250 --> 00:06:26,530
它必须保持一致，

134
00:06:26,730 --> 00:06:29,080
尽管有这些不同的故障场景。

135
00:06:29,820 --> 00:06:31,180
所以，一种系统方法，

136
00:06:31,260 --> 00:06:32,800
假设你没有断电，

137
00:06:33,060 --> 00:06:36,460
是说，好的，我有的第二种选择是，

138
00:06:36,540 --> 00:06:38,350
并发操作相互破坏，

139
00:06:39,080 --> 00:06:39,785
就是说，

140
00:06:39,785 --> 00:06:41,620
我将拥有一个非常简单的数据库系统，

141
00:06:42,350 --> 00:06:44,890
即使两个人同时请求查询，

142
00:06:44,890 --> 00:06:47,320
我一次也只运行一个查询，

143
00:06:47,320 --> 00:06:49,980
我将把我收到的所有请求都放入队列，

144
00:06:50,120 --> 00:06:51,660
一次只运行一个查询，

145
00:06:51,920 --> 00:06:55,860
这样我就可以获得合理、正确的行为，

146
00:06:56,120 --> 00:06:57,750
针对我们刚才讨论的场景。

147
00:06:58,140 --> 00:06:59,475
我还可以开始做一些事情，

148
00:06:59,475 --> 00:07:00,870
比如在事务开始之前，

149
00:07:00,870 --> 00:07:02,750
我可以复制整个数据库，

150
00:07:03,310 --> 00:07:04,580
在那里进行所有更改，

151
00:07:04,930 --> 00:07:07,010
如果事务成功完成，

152
00:07:07,660 --> 00:07:10,340
所以没有停电，所有其他类型的事情，

153
00:07:10,780 --> 00:07:12,410
我将用新的副本覆盖它。

154
00:07:13,020 --> 00:07:14,290
这两种方法都非常糟糕，

155
00:07:14,580 --> 00:07:17,170
因为它们将给你提供某种形式的正确性，

156
00:07:17,250 --> 00:07:19,420
但从性能角度来看，它们非常糟糕，

157
00:07:19,920 --> 00:07:24,370
因为它将是一个非常非常慢的数据库系统，

158
00:07:24,720 --> 00:07:27,290
你甚至无法使用它。

159
00:07:27,290 --> 00:07:28,580
今天，当你去亚马逊，

160
00:07:28,580 --> 00:07:30,730
你在检查你的购物车时，

161
00:07:30,840 --> 00:07:34,720
最终一些事情会发生，发布数据库事务记录，

162
00:07:34,740 --> 00:07:35,890
从你的借记卡中扣除，

163
00:07:36,180 --> 00:07:37,720
添加到你的购物车中，

164
00:07:37,830 --> 00:07:39,640
最终，另一笔交易被发送到那里，

165
00:07:39,780 --> 00:07:42,185
发送给你的信用卡账户，记录下来，

166
00:07:42,185 --> 00:07:43,600
这笔金额需要借记，

167
00:07:43,680 --> 00:07:45,095
所有这些工作都是正确的，

168
00:07:45,095 --> 00:07:46,270
即使有多个人，

169
00:07:46,840 --> 00:07:48,960
同一张信用卡上的多个账户持有人，

170
00:07:49,190 --> 00:07:51,270
同时进行交易，

171
00:07:51,350 --> 00:07:53,100
创建多个购物车。

172
00:07:53,330 --> 00:07:55,410
所以，我们真的希望能够规模化地进行这项工作，

173
00:07:55,640 --> 00:07:57,660
我们不想一次只做一笔交易，

174
00:07:57,770 --> 00:08:00,025
你想要一次处理数千、数万，

175
00:08:00,025 --> 00:08:02,400
甚至数百万、数十亿的交易。

176
00:08:02,870 --> 00:08:03,835
好的，那我们该怎么做，

177
00:08:03,835 --> 00:08:05,010
这是个很难解决的问题。

178
00:08:05,420 --> 00:08:08,280
好的，如果我们希望更好地利用数据库硬件，

179
00:08:08,600 --> 00:08:11,160
我们需要更高的吞吐量和更快的响应时间，

180
00:08:11,330 --> 00:08:13,080
当然，我们希望它是正确的，

181
00:08:13,630 --> 00:08:14,930
让正确的事情发生，

182
00:08:14,950 --> 00:08:17,150
我们将定义正确的概念是什么。

183
00:08:18,190 --> 00:08:20,270
在许多情况下，你也希望这是公平的，

184
00:08:20,830 --> 00:08:23,210
所以如果同时有多个事务，

185
00:08:23,260 --> 00:08:26,280
你希望所有的事务都有平等的机会完成，

186
00:08:26,280 --> 00:08:29,270
而不是说我会永远把你们中的两个留在后面，

187
00:08:29,410 --> 00:08:31,755
让其他人继续前进，

188
00:08:31,755 --> 00:08:32,420
这不公平，

189
00:08:32,530 --> 00:08:34,850
你想要有一些公平的概念。

190
00:08:36,090 --> 00:08:37,625
有些系统可能不具备这一点，

191
00:08:37,625 --> 00:08:38,620
有时你有优先级，

192
00:08:38,730 --> 00:08:41,360
你说我想要高优先级的事务完成，

193
00:08:41,360 --> 00:08:43,115
但假设你想要公平，

194
00:08:43,115 --> 00:08:45,160
你至少想要拥有公平的能力，

195
00:08:45,180 --> 00:08:46,205
如何平衡，

196
00:08:46,205 --> 00:08:49,630
对工作负载进行分区，让优先级较高工作负载先执行，

197
00:08:50,100 --> 00:08:51,040
是另一个问题，

198
00:08:51,120 --> 00:08:55,660
但你确实希望将公平机制构建到数据库系统中。

199
00:08:56,870 --> 00:08:57,910
好的，到目前为止有什么问题，

200
00:08:57,910 --> 00:08:59,340
关于我们试图实现的目标。

201
00:09:02,240 --> 00:09:02,640
是的。

202
00:09:05,950 --> 00:09:06,705
我们试着，

203
00:09:06,705 --> 00:09:08,240
我们会解决所有的问题，

204
00:09:08,290 --> 00:09:09,620
除了停电问题，

205
00:09:10,030 --> 00:09:12,465
停电问题会解决，

206
00:09:12,465 --> 00:09:14,835
我们稍后将介绍所有的解决方案，

207
00:09:14,835 --> 00:09:18,770
在停电方面有一个非常微妙的问题，

208
00:09:18,940 --> 00:09:21,750
在接下来的几节课中将讨论的所有问题，

209
00:09:21,750 --> 00:09:25,400
我们可以确保数据库记录最终处于正确的状态。

210
00:09:25,860 --> 00:09:27,980
但如果银行向你支付了 25 美元，

211
00:09:28,030 --> 00:09:29,240
然后停电了，

212
00:09:29,980 --> 00:09:31,610
就需要采取额外的操作，

213
00:09:32,080 --> 00:09:34,910
因为这 25 美元是物理上的操作，

214
00:09:35,290 --> 00:09:36,620
其他一切都是数字上的操作，

215
00:09:36,970 --> 00:09:40,140
为了取消支付给你的 25 美元的操作，

216
00:09:40,140 --> 00:09:41,150
他们不应该支付的，

217
00:09:41,500 --> 00:09:45,090
银行必须在物理空间进行单独的事务，

218
00:09:45,090 --> 00:09:46,110
他们会给你发一封信，说，

219
00:09:46,110 --> 00:09:48,110
哎呀，我们不小心付给了你 25 美元，

220
00:09:48,370 --> 00:09:50,360
但这是你的银行账户。

221
00:09:50,680 --> 00:09:52,040
所以，还有其他方法可以做到这个，

222
00:09:52,120 --> 00:09:52,820
我们不会，

223
00:09:52,900 --> 00:09:55,275
我们将能够撤销所有读写，

224
00:09:55,275 --> 00:09:57,200
如果我们不希望它们发生。

225
00:09:57,670 --> 00:09:59,505
但是，如果事务是，

226
00:09:59,505 --> 00:10:01,215
支付 25 美元是一个物理操作，

227
00:10:01,215 --> 00:10:02,180
你不能撤销它，

228
00:10:02,380 --> 00:10:05,390
你可以通过在物理世界中做其他物理操作来撤销这个。

229
00:10:05,770 --> 00:10:06,435
好的，同样，

230
00:10:06,435 --> 00:10:08,220
如果有一个事务发射了一枚导弹，

231
00:10:08,220 --> 00:10:09,210
你就不能撤销那枚导弹，

232
00:10:09,210 --> 00:10:10,370
你不能撤回那枚导弹，

233
00:10:10,510 --> 00:10:13,185
你必须发一封道歉信或其他类似的东西。

234
00:10:13,185 --> 00:10:15,495
所以，或者一些非常糟糕的事情，

235
00:10:15,495 --> 00:10:16,460
所以就像是，

236
00:10:16,880 --> 00:10:22,180
事务中物理操作的撤消将需要在物理世界中撤消，

237
00:10:22,530 --> 00:10:23,440
我们不会讨论这个，

238
00:10:23,700 --> 00:10:25,145
而且有一些机制可以做到这个，

239
00:10:25,145 --> 00:10:26,650
那就是与业务相关的操作，

240
00:10:26,790 --> 00:10:29,270
你有时会收到公司发来的一封信，说，

241
00:10:29,270 --> 00:10:31,210
哎呀，我们搞错了，抱歉，

242
00:10:31,350 --> 00:10:32,435
事情的真相是这样的，

243
00:10:32,435 --> 00:10:35,830
哦，顺便说一句，这是一张 10 美元的礼品卡来弥补错误。

244
00:10:36,270 --> 00:10:38,980
但所有读写的数字操作，

245
00:10:39,180 --> 00:10:41,500
我们将把它们转换成一个非常严格的结构，

246
00:10:41,820 --> 00:10:46,300
以确保我们持有非常明确的正确性属性，

247
00:10:46,530 --> 00:10:49,930
通过我们将在今天和接下来的几节课讨论的机制。

248
00:10:50,700 --> 00:10:51,340
好问题。

249
00:10:52,770 --> 00:10:53,410
还有其他问题吗？

250
00:10:55,970 --> 00:10:56,520
好的。

251
00:10:57,270 --> 00:11:03,250
所以，我们希望这些操作的任意交错是正确的。

252
00:11:03,880 --> 00:11:05,430
所以在我们更进一步之前，

253
00:11:05,990 --> 00:11:08,160
只是想要巩固事务的概念，

254
00:11:08,840 --> 00:11:10,440
你要执行这些操作，

255
00:11:10,940 --> 00:11:13,615
我们刚才谈到的数据库

256
00:11:13,615 --> 00:11:17,185
只关心对数据库对象的读写操作，

257
00:11:17,185 --> 00:11:18,810
这些物理世界的操作，

258
00:11:19,340 --> 00:11:20,910
支付金额，

259
00:11:21,140 --> 00:11:25,980
或者开始发射导弹之类的东西，

260
00:11:26,270 --> 00:11:28,950
我们无法修复，

261
00:11:29,180 --> 00:11:30,810
如果发生了糟糕的事情。

262
00:11:32,290 --> 00:11:34,340
在高级数据库课程中，

263
00:11:34,420 --> 00:11:35,520
根据材料的不同，

264
00:11:35,520 --> 00:11:37,530
有时我们会谈论这样的事情，

265
00:11:37,530 --> 00:11:40,460
以及什么是补偿事务和可能发生的事情，

266
00:11:40,780 --> 00:11:43,185
以及人们可能会以其他方式做什么。

267
00:11:43,185 --> 00:11:44,760
所以，但为了这门课的目标，

268
00:11:44,760 --> 00:11:47,490
我们只会从很多方面来看这个，

269
00:11:47,490 --> 00:11:48,830
范围更有限。

270
00:11:49,770 --> 00:11:51,130
重申我们所讨论的内容，

271
00:11:51,270 --> 00:11:54,250
我们主要考虑读写操作，

272
00:11:54,690 --> 00:11:56,330
你注意到，在我的代码中，

273
00:11:56,330 --> 00:11:58,490
有一个检查，有一个减法，

274
00:11:58,490 --> 00:11:59,920
有数学之类的东西，

275
00:12:00,180 --> 00:12:03,280
从我们今天要讨论的事务管理的角度来看，

276
00:12:03,690 --> 00:12:04,685
我们所关心的是，

277
00:12:04,685 --> 00:12:06,850
是否有对象被写入，是否被读取，

278
00:12:07,280 --> 00:12:10,900
是否这些读写操作最终会以不好的方式相互干扰，

279
00:12:11,190 --> 00:12:12,140
这些不好的方式是什么，

280
00:12:12,140 --> 00:12:13,600
我们如何防止这些不好的方式？

281
00:12:15,510 --> 00:12:18,100
我们如何防止这些不好的方式，

282
00:12:18,270 --> 00:12:22,475
在允许最大数量的事务在系统上并发工作的同时，

283
00:12:22,475 --> 00:12:23,350
这正是难点。

284
00:12:24,170 --> 00:12:25,840
因为你已经看到有一种简单的方法，

285
00:12:25,840 --> 00:12:27,810
那就是一次只做一个事务，

286
00:12:28,280 --> 00:12:29,500
你想要做得更好。

287
00:12:30,420 --> 00:12:32,180
所以只有这些对象，

288
00:12:32,180 --> 00:12:34,600
我们称为变量 A B 和 C ，

289
00:12:34,950 --> 00:12:36,545
但如果你想有一个简单的模型，

290
00:12:36,545 --> 00:12:37,810
你可以把它想象成一个记录，

291
00:12:38,580 --> 00:12:40,030
但是在数据库系统内部，

292
00:12:40,140 --> 00:12:42,220
我们在高级数据库类中介绍，

293
00:12:42,450 --> 00:12:43,660
A 可以是列，

294
00:12:43,890 --> 00:12:47,390
以更精细的粒度执行操作，

295
00:12:47,390 --> 00:12:50,620
也可以是页，也可以是文件或数据库，

296
00:12:51,090 --> 00:12:52,900
一些较早版本的数据库，

297
00:12:53,490 --> 00:12:57,430
比如 Mongo ，在某一时刻执行并发操作时会锁住整个数据库，

298
00:12:57,780 --> 00:12:58,780
他们现在不这么做了，

299
00:12:59,070 --> 00:13:03,200
但是一组对象，

300
00:13:03,200 --> 00:13:07,070
或者 A B 和 C 只是指的是数据库对象。

301
00:13:07,070 --> 00:13:08,045
对于今天的目的，

302
00:13:08,045 --> 00:13:09,730
你可以把它们看作是记录。

303
00:13:10,300 --> 00:13:13,210
接下来两节课的内容会更有意义，

304
00:13:13,210 --> 00:13:15,060
如果你选择一个[]模型。

305
00:13:17,210 --> 00:13:17,790
好的。

306
00:13:19,710 --> 00:13:23,920
数据库系统如何知道事务开始和事务结束，

307
00:13:24,930 --> 00:13:29,440
在 SQL 中，你可以显式地放置一条开始事务语句和一条结束事务语句，

308
00:13:29,670 --> 00:13:30,905
告诉数据库系统，

309
00:13:30,905 --> 00:13:33,730
在这两条语句之间发生的所有事情都是一个事务，

310
00:13:34,170 --> 00:13:36,250
而这两条语句之间可能是多个 SQL 查询。

311
00:13:37,890 --> 00:13:39,460
如果你没有开始和结束事务，

312
00:13:39,570 --> 00:13:41,440
就像你在作业中所做的事情，

313
00:13:41,820 --> 00:13:43,115
当你启动一个 SQL 查询，

314
00:13:43,115 --> 00:13:44,660
数据库系统将隐式地，

315
00:13:44,660 --> 00:13:46,610
在查询的开始处放置一个开始，

316
00:13:46,610 --> 00:13:48,070
在查询的末尾放置一个结束。

317
00:13:48,520 --> 00:13:50,395
但是一个事务可以是多个查询，

318
00:13:50,395 --> 00:13:52,050
你可以显式地防止开始和结束。

319
00:13:52,620 --> 00:13:55,020
你还可以放置一个显式的 ABORT 语句，

320
00:13:55,020 --> 00:13:55,875
也就是说，

321
00:13:55,875 --> 00:13:57,920
不是最终调用 COMMIT ，

322
00:13:58,950 --> 00:14:01,630
是说，我从 BEGIN 到这里所做的一切，

323
00:14:01,950 --> 00:14:04,270
请提交它，让它的变更持久化，

324
00:14:04,900 --> 00:14:07,320
结束事务的另一种方式是 ABORT ，

325
00:14:07,920 --> 00:14:08,570
所以，它可能是，

326
00:14:08,740 --> 00:14:10,365
我可能正在制定度假计划，

327
00:14:10,365 --> 00:14:12,590
所以我做了一个事务来预订机票，

328
00:14:13,180 --> 00:14:14,985
然后我在代码中做一点搜索，

329
00:14:14,985 --> 00:14:16,575
找到酒店预订，

330
00:14:16,575 --> 00:14:18,200
发现没有酒店，

331
00:14:18,520 --> 00:14:19,095
所以我可以说，

332
00:14:19,095 --> 00:14:20,120
哦，取消这个事务，

333
00:14:20,380 --> 00:14:21,320
ABORT 表示，

334
00:14:21,340 --> 00:14:23,090
我做了一些工作，读取和写入，

335
00:14:23,720 --> 00:14:25,480
但我不认为我能走得更远，

336
00:14:25,530 --> 00:14:26,650
看起来有些不对劲，

337
00:14:26,670 --> 00:14:27,580
取消这个事务，

338
00:14:27,630 --> 00:14:29,980
应用程序可以再次尝试。

339
00:14:30,300 --> 00:14:32,200
你可以显式地中止事务，

340
00:14:32,850 --> 00:14:35,690
有时可能是数据库为你中止，

341
00:14:35,690 --> 00:14:37,960
因为多个事务同时发生，

342
00:14:38,190 --> 00:14:40,060
它检测到一些不安全的条件，

343
00:14:40,320 --> 00:14:42,650
并说，我要为你中止这个事务，

344
00:14:42,650 --> 00:14:44,020
你会得到 ABORT 代码。

345
00:14:45,000 --> 00:14:47,105
从事务管理器的角度来看，

346
00:14:47,105 --> 00:14:49,840
我们今天试图理解和构建的模块，

347
00:14:50,990 --> 00:14:52,770
它将被呈现一个 BEGIN 事务，

348
00:14:53,180 --> 00:14:54,240
一串读写操作，

349
00:14:54,740 --> 00:14:58,440
最终它将获得一个 COMMIT 或一个 ABORT 操作。

350
00:14:59,200 --> 00:15:01,980
这就是我们必须在系统代码中构建的，

351
00:15:02,180 --> 00:15:03,870
以进行事务，

352
00:15:04,310 --> 00:15:06,030
所以事务可以通过提交结束，

353
00:15:06,320 --> 00:15:07,705
或者可以通过中止结束，

354
00:15:07,705 --> 00:15:09,750
中止意味着取消可能完成的一切，

355
00:15:09,920 --> 00:15:11,970
提交是说我做的每一件事都让它持久化。

356
00:15:14,210 --> 00:15:15,660
所以他们可以以这两种方式结束。

357
00:15:16,300 --> 00:15:18,040
ABORT 可能是自己造成的，

358
00:15:18,040 --> 00:15:18,900
正如我们所讨论的，

359
00:15:19,370 --> 00:15:21,510
应用程序可以显式地放入 ABORT 调用，

360
00:15:21,680 --> 00:15:22,480
或者可能是，

361
00:15:22,480 --> 00:15:24,510
数据库系统由于某种原因而不得不中止，

362
00:15:24,890 --> 00:15:27,730
以完成我们所讨论的所有安全保证。

363
00:15:27,730 --> 00:15:29,380
我们将看到不同方式，

364
00:15:29,380 --> 00:15:31,290
在数据库系统中发生的 ABORT ，

365
00:15:31,400 --> 00:15:32,700
在接下来的几节课中。

366
00:15:34,600 --> 00:15:38,060
好的，你们中的很多人可能都听说过 ACID ，

367
00:15:38,440 --> 00:15:39,680
这是个很酷的首字母缩写，

368
00:15:39,910 --> 00:15:41,510
那是，

369
00:15:42,370 --> 00:15:43,455
社区想出来的，

370
00:15:43,455 --> 00:15:45,170
几个人想出来的，

371
00:15:45,280 --> 00:15:50,510
表示我们想要这些事务的属性是什么。

372
00:15:52,140 --> 00:15:57,130
属性是，原子性、一致性、隔离性和持久性。

373
00:15:57,750 --> 00:15:59,920
所以，让我们逐一查看这些内容，

374
00:16:00,480 --> 00:16:01,660
原子性表示，

375
00:16:02,560 --> 00:16:04,920
我有一个事务执行一大堆读写操作，

376
00:16:05,700 --> 00:16:08,430
当我说 COMMIT 时，

377
00:16:08,720 --> 00:16:11,220
一切都应该提交到数据库中，

378
00:16:11,450 --> 00:16:12,400
或者如果我说 ABORT ，

379
00:16:12,400 --> 00:16:13,225
则不应该发生任何事情。

380
00:16:13,225 --> 00:16:16,230
所以，就像我想要这个事务的全部或没有的属性，

381
00:16:16,640 --> 00:16:18,570
即使可能发生了很多读取和写入，

382
00:16:19,010 --> 00:16:21,565
在这个事务中，

383
00:16:21,565 --> 00:16:23,620
对它应该感觉到它是原子的，

384
00:16:23,620 --> 00:16:24,510
所以这非常像，

385
00:16:24,560 --> 00:16:29,275
你在处理器中看到的原子指令，

386
00:16:29,275 --> 00:16:31,260
但现在这是针对多个读取和写入的，

387
00:16:31,370 --> 00:16:34,240
这些读写可能会将数据溢出到磁盘，

388
00:16:34,240 --> 00:16:36,190
所以这是一个更高粒度的问题，

389
00:16:36,190 --> 00:16:37,110
所以是更难的问题。

390
00:16:38,640 --> 00:16:39,640
一致性表示，

391
00:16:40,910 --> 00:16:42,390
一致性是一个有点奇怪的问题，

392
00:16:42,560 --> 00:16:45,090
我将讨论最后讨论这个问题，

393
00:16:45,140 --> 00:16:46,150
让我去隔离性，

394
00:16:46,150 --> 00:16:47,700
我会回来一致性。

395
00:16:47,960 --> 00:16:49,080
隔离性表示，

396
00:16:49,550 --> 00:16:51,150
如果两个事务，

397
00:16:51,290 --> 00:16:53,250
比如我们有两个借记事务发生，

398
00:16:53,810 --> 00:16:57,630
从你和你的另一半的银行账户中提取 25 美元，

399
00:16:58,340 --> 00:17:00,625
我们希望这些不会相互干扰，

400
00:17:00,625 --> 00:17:02,940
它应该让人感觉每个事务都是自己发生的。

401
00:17:03,490 --> 00:17:06,020
所以，即使我们不想一次运行一个事务，

402
00:17:06,160 --> 00:17:10,095
我们也希望系统一次运行一个事务的错觉，

403
00:17:10,095 --> 00:17:10,935
这应该让我感觉，

404
00:17:10,935 --> 00:17:12,200
当我的事务运行时，

405
00:17:12,250 --> 00:17:13,820
整个系统都是我自己拥有的，

406
00:17:14,340 --> 00:17:15,980
也没有其他东西干扰我。

407
00:17:17,310 --> 00:17:18,100
这能理解吗？

408
00:17:18,420 --> 00:17:21,100
所以我应该觉得没有人干扰我的工作。

409
00:17:22,620 --> 00:17:24,010
持久性表示，

410
00:17:24,420 --> 00:17:26,825
如果数据库返回给我并说，

411
00:17:26,825 --> 00:17:27,880
我已经提交了你的事务，

412
00:17:29,650 --> 00:17:30,410
在这之后，

413
00:17:30,580 --> 00:17:34,370
即使出现故障，磁盘故障或内存故障，

414
00:17:34,750 --> 00:17:38,090
我也应该能够恢复数据库的该状态，

415
00:17:39,000 --> 00:17:43,690
带着其中所有的提交信息。

416
00:17:43,690 --> 00:17:47,250
所以，如果我将银行帐户的最终值更改为 75 ，

417
00:17:47,750 --> 00:17:50,350
数据库说我已经提交了你的事务，

418
00:17:50,350 --> 00:17:52,560
那个提交调用返回时发出绿色信号，

419
00:17:53,000 --> 00:17:54,360
然后出现停电，

420
00:17:54,920 --> 00:17:56,665
当我把机器拿回来时，

421
00:17:56,665 --> 00:17:58,320
我应该看到里面有 75 ，

422
00:17:58,460 --> 00:18:00,720
而不是它一开始的值 100 。

423
00:18:02,880 --> 00:18:04,760
现在，回到一致性上来，

424
00:18:04,760 --> 00:18:06,125
我一直在等待，

425
00:18:06,125 --> 00:18:07,810
因为我会贴上一些标签，

426
00:18:07,980 --> 00:18:10,150
我们如何做这样的事情。

427
00:18:10,470 --> 00:18:12,550
一致性是一个奇怪的东西，它表示，

428
00:18:13,400 --> 00:18:16,720
如果数据库开始是一致的，就像某些定义一样，

429
00:18:18,460 --> 00:18:21,230
那么它应该以同样的一致状态结束。

430
00:18:21,810 --> 00:18:23,680
现在，这看起来也很含糊，对吧？

431
00:18:24,260 --> 00:18:26,740
那么，数据库开始保持一致性是什么意思，

432
00:18:27,500 --> 00:18:29,000
在 SQL 中，有一些东西，

433
00:18:29,000 --> 00:18:31,325
比如你可以定义主键，外键，

434
00:18:31,325 --> 00:18:32,260
你已经做过了，

435
00:18:32,550 --> 00:18:34,715
SQL 也有这些称为约束的东西，

436
00:18:34,715 --> 00:18:39,130
其中你可以说，称为检查的东西，

437
00:18:39,210 --> 00:18:40,240
所以，检查可能会说，

438
00:18:40,380 --> 00:18:43,000
我在一张表里有一个 price 字段，

439
00:18:43,640 --> 00:18:45,850
这个 price 永远不应该超过 100 ，

440
00:18:47,470 --> 00:18:48,800
数据库需要，

441
00:18:49,300 --> 00:18:51,420
每当数据库系统发生任何更新时，

442
00:18:51,420 --> 00:18:53,360
以确保这些东西为真。

443
00:18:53,650 --> 00:18:55,250
所以一致性真正表示，

444
00:18:56,080 --> 00:19:00,000
如果应用程序已经在 SQL DDL 中指定了，

445
00:19:00,380 --> 00:19:03,450
它们希望数据库正确保存的所有内容，

446
00:19:05,340 --> 00:19:08,410
然后，数据库事务不应该弄乱这些。

447
00:19:09,030 --> 00:19:11,980
发生这种情况的主要方式是通过检查，主键，

448
00:19:12,090 --> 00:19:15,710
而且你还可以定义外部检查，

449
00:19:15,710 --> 00:19:18,790
表和其他定义约束的方式，

450
00:19:18,930 --> 00:19:21,010
你真的希望这一切都能保持下去。

451
00:19:21,960 --> 00:19:23,030
所以这有点奇怪，

452
00:19:23,030 --> 00:19:28,565
但它表明应用程序正确地定义了数据库的结构，

453
00:19:28,565 --> 00:19:31,270
并使用了 SQL 允许的所有这些检查，

454
00:19:31,700 --> 00:19:32,860
事务管理，

455
00:19:33,990 --> 00:19:35,890
我们在这里所做的一切都不应该弄乱。

456
00:19:36,060 --> 00:19:38,710
如果我说 A 加上 B 必须总是等于 100 ，

457
00:19:38,940 --> 00:19:40,270
有人修改了 A ，

458
00:19:41,270 --> 00:19:43,380
并以适当的方式修改了 B ，

459
00:19:44,210 --> 00:19:47,130
它在单个事务中仍然等于 100 ，

460
00:19:47,390 --> 00:19:51,580
事务不应违反任何内容，并更改该约束，

461
00:19:51,580 --> 00:19:53,280
所以，它应该保持这种正确性。

462
00:19:54,100 --> 00:19:55,035
我们会回到这个问题上来，

463
00:19:55,035 --> 00:19:56,000
这听起来有点含糊，

464
00:19:56,170 --> 00:19:57,720
但在很多方面，

465
00:19:57,720 --> 00:19:59,660
C 都符合 ACID 的定义，

466
00:20:00,070 --> 00:20:02,880
因为数据库真正做的关键事情是 AID ，

467
00:20:02,880 --> 00:20:04,500
但是如果首字母缩写是 AID ，

468
00:20:04,500 --> 00:20:06,050
那么它听起来就没有 ACID 那么好听了，

469
00:20:06,550 --> 00:20:10,215
这是在嬉皮士统治湾区和欧洲的时候做的，

470
00:20:10,215 --> 00:20:11,990
他们想要到处都是酸。

471
00:20:12,310 --> 00:20:17,660
这就是我对 C 是如何插入的理解。

472
00:20:18,580 --> 00:20:20,175
我们将讨论不同的机制，

473
00:20:20,175 --> 00:20:22,790
这些就是你在蓝色气泡中看到的。

474
00:20:23,380 --> 00:20:27,710
自主性和持久性将需要这种机制来重做和撤销东西，

475
00:20:27,970 --> 00:20:30,450
哦，我修改了 A ，我把它推到了磁盘上，

476
00:20:30,450 --> 00:20:32,390
我已经将它从我的缓冲池推送到磁盘，

477
00:20:32,410 --> 00:20:34,580
哦，但我需要取消那个事务，

478
00:20:35,620 --> 00:20:36,830
那么我怎么才能撤销这个呢？

479
00:20:37,400 --> 00:20:40,330
哦，我用 A 的新值提交了一个事务，

480
00:20:40,330 --> 00:20:41,620
但它仍然位于我的缓冲池中，

481
00:20:41,620 --> 00:20:42,685
它没有被放到磁盘上，

482
00:20:42,685 --> 00:20:44,160
我需要重做磁盘复制，

483
00:20:44,420 --> 00:20:48,190
所以 A 和 D 提供了重做和撤消机制，

484
00:20:48,190 --> 00:20:51,600
我们将使用，今天和下一节课中讨论的内容。

485
00:20:52,090 --> 00:20:52,790
正如我所说的，

486
00:20:53,260 --> 00:20:58,040
一致性是通过确保在你的 SQL DDL 中定义了完整性约束来提供的，

487
00:20:58,150 --> 00:21:01,070
并且事务管理系统不应该违反该约束。

488
00:21:01,390 --> 00:21:04,100
隔离是通过称为并发控制的东西来完成的，

489
00:21:04,210 --> 00:21:06,225
我们也将讨论这一点，

490
00:21:06,225 --> 00:21:09,170
锁和其他机制将在那里发挥作用。

491
00:21:09,220 --> 00:21:10,950
所以，我们将深入研究其中的每一个，

492
00:21:10,950 --> 00:21:11,810
让我们开始吧。

493
00:21:12,570 --> 00:21:13,960
好的，这就是我们的日程，

494
00:21:14,460 --> 00:21:16,330
深入研究这四个组成部分中的每一个。

495
00:21:17,500 --> 00:21:19,100
所以，事务的原子性，

496
00:21:20,990 --> 00:21:24,400
执行事务有两种可能的结果，

497
00:21:24,900 --> 00:21:27,065
它要么提交，要么被中止，

498
00:21:27,065 --> 00:21:28,720
中止可以是显示地，

499
00:21:29,360 --> 00:21:30,570
由应用程序触发，

500
00:21:30,920 --> 00:21:34,555
或者可能是数据库不安全，

501
00:21:34,555 --> 00:21:35,550
我需要中止你，

502
00:21:35,810 --> 00:21:39,480
然后事务可以重新启动并重新发出该 SQL 语句，

503
00:21:40,070 --> 00:21:45,240
DBMS 需要提供这些事务这种全部或没有的原子属性。

504
00:21:46,900 --> 00:21:48,555
所以让我们把它变得更具体一点，

505
00:21:48,555 --> 00:21:49,730
我们一直在举这个例子，

506
00:21:49,780 --> 00:21:52,820
所以我们在深入研究这个时，看几个场景，

507
00:21:52,900 --> 00:21:54,590
我们从一个账户中提取 100 美元，

508
00:21:55,270 --> 00:21:59,265
但在我们转账之前，数据库系统中止事务，

509
00:21:59,265 --> 00:22:03,410
所以我们要确保这是正确反映的。

510
00:22:03,850 --> 00:22:04,695
第二种场景是，

511
00:22:04,695 --> 00:22:06,230
我们从一个账户中提取 100 美元，

512
00:22:06,280 --> 00:22:07,470
但随后出现了停电，

513
00:22:07,470 --> 00:22:08,570
在我们转账之前。

514
00:22:08,590 --> 00:22:10,100
我们已经看到了这两个事务，

515
00:22:10,300 --> 00:22:13,545
但只是给你更多的例子来说明应该是什么，

516
00:22:13,545 --> 00:22:16,400
而且我们必须确定账户的正确状态，

517
00:22:16,420 --> 00:22:18,530
在这两个事务中止之后。

518
00:22:19,280 --> 00:22:22,180
所以，我们怎么能做一些这样的事情呢，

519
00:22:23,010 --> 00:22:25,510
原子性部分可以通过两种方式之一来完成，

520
00:22:25,800 --> 00:22:27,100
日志和跟踪，

521
00:22:27,510 --> 00:22:29,860
一种方法是记录我们所做的一切，

522
00:22:30,210 --> 00:22:32,500
所以，如果我记录我的所有操作，

523
00:22:33,330 --> 00:22:36,800
我修改某个值从 100 到 75 的那一刻，

524
00:22:36,880 --> 00:22:39,570
我可以记录我的值是 100 ，

525
00:22:39,570 --> 00:22:40,515
我把它改成 75 ，

526
00:22:40,515 --> 00:22:43,580
我之前的值是 100 ，之后的值是 75 ，

527
00:22:43,870 --> 00:22:45,350
现在我可以获取这些日志，

528
00:22:45,370 --> 00:22:47,120
我可以维护这些日志记录，

529
00:22:47,620 --> 00:22:51,530
我可以在内存中存储这些日志记录，

530
00:22:51,790 --> 00:22:54,350
然后适当的点将其移出到磁盘，

531
00:22:54,490 --> 00:22:55,860
一旦它移动到磁盘中，

532
00:22:55,860 --> 00:22:57,225
我知道它就会在那里，

533
00:22:57,225 --> 00:22:58,610
它将在停电后幸存下来。

534
00:22:59,280 --> 00:23:02,120
如果我认为我不能信任单个磁盘来保存日志，

535
00:23:02,170 --> 00:23:04,280
很多时候人们会使用磁盘镜像，

536
00:23:04,450 --> 00:23:06,980
还记得，我们在几节课前讨论过磁盘镜像，

537
00:23:07,090 --> 00:23:10,970
所以，如果有两个磁盘将具有我写入的同一文件的副本，

538
00:23:11,170 --> 00:23:13,580
但实际上它在两个位置被写入两次，

539
00:23:13,900 --> 00:23:16,040
所以如果其中一个出现故障，我还有另一个副本，

540
00:23:16,360 --> 00:23:19,050
如果两个都出现故障，你将不得不创建第三个副本，以此类推。

541
00:23:19,050 --> 00:23:21,320
所以你必须决定你能容忍什么样的失败。

542
00:23:21,430 --> 00:23:23,895
但是，一旦日志到达磁盘，

543
00:23:23,895 --> 00:23:25,665
你知道可以从中恢复，

544
00:23:25,665 --> 00:23:27,410
并重建数据库的状态。

545
00:23:28,300 --> 00:23:32,630
我们将在接下来的两节课中讨论协议，

546
00:23:32,770 --> 00:23:34,605
我们将如何实现这个。

547
00:23:34,605 --> 00:23:38,360
但是日志是大多数数据库系统将使用的机制，

548
00:23:39,160 --> 00:23:41,220
去记录发生的变化。

549
00:23:43,710 --> 00:23:44,110
好的。

550
00:23:45,160 --> 00:23:46,220
这能理解吗？有问题吗？

551
00:23:54,415 --> 00:23:57,160
不，不要将其与日志结构文件系统混淆，

552
00:23:57,160 --> 00:23:58,110
这是你认为的那样吗，

553
00:23:58,400 --> 00:23:59,820
它看起来方式是不同的。

554
00:23:59,840 --> 00:24:03,000
所以这个很多起源于 70 和 80 年代，

555
00:24:03,640 --> 00:24:05,460
这是一个记录的文件，

556
00:24:05,930 --> 00:24:07,860
但记录的长度是可变的，

557
00:24:08,180 --> 00:24:11,730
结构将有一组特定的通用字段，

558
00:24:12,650 --> 00:24:14,640
但可以将其视为一个文件，

559
00:24:14,660 --> 00:24:16,730
包含一堆可变的，

560
00:24:17,710 --> 00:24:20,430
具有固定长度[分量]和一大堆变量，

561
00:24:20,430 --> 00:24:23,270
它位于一个通常被称为日志文件的文件中，

562
00:24:23,620 --> 00:24:27,255
基本上它将从头到尾按顺序写入，

563
00:24:27,255 --> 00:24:29,600
它将拥有自己的缓冲区管理，

564
00:24:29,860 --> 00:24:33,110
所以最近的页面将位于缓冲池中，

565
00:24:33,220 --> 00:24:35,480
在这个点上，我们必须说出这个，

566
00:24:35,920 --> 00:24:36,940
缓冲池，

567
00:24:36,940 --> 00:24:37,440
也就是说，

568
00:24:37,520 --> 00:24:41,460
我不能将此事务提交到内存中，

569
00:24:41,780 --> 00:24:43,590
它需要命中磁盘，

570
00:24:44,040 --> 00:24:45,920
在我可以提交这个事务之前，

571
00:24:46,060 --> 00:24:48,135
所以我们可能会保留事务提交，

572
00:24:48,135 --> 00:24:49,590
我们不会返回，直到我们，

573
00:24:49,590 --> 00:24:51,860
但是你可以把它想象成一个记录文件，

574
00:24:52,630 --> 00:24:55,340
就像一个普通的文件，

575
00:24:55,450 --> 00:24:57,200
但它有特殊的结构。

576
00:24:57,580 --> 00:25:04,390
是的，所以问题是，

577
00:25:04,410 --> 00:25:06,790
如果我有一个日志结构的文件系统，

578
00:25:07,380 --> 00:25:08,500
我是否需要日志，

579
00:25:08,640 --> 00:25:10,970
一个日志结构文件系统只对那个文件有效，

580
00:25:10,970 --> 00:25:11,885
所以，在一个数据库系统中，

581
00:25:11,885 --> 00:25:12,970
我可能有 100 个表，

582
00:25:13,170 --> 00:25:15,550
我们在五个不同的位置更新了一个事务，

583
00:25:15,810 --> 00:25:19,330
我需要一个全局日志机制来处理这个问题。

584
00:25:19,590 --> 00:25:20,810
所以，传统上做的，

585
00:25:20,810 --> 00:25:21,790
我有一个日志文件，

586
00:25:21,930 --> 00:25:23,950
它将保留所有这些变更，

587
00:25:24,060 --> 00:25:26,300
为所有发生的更改，

588
00:25:26,300 --> 00:25:27,430
而不仅仅是单个文件。

589
00:25:27,750 --> 00:25:29,945
所以，日志结构化文件系统确实有意义，

590
00:25:29,945 --> 00:25:32,590
它们具有类似的元素到机制类型，

591
00:25:32,700 --> 00:25:35,050
与你尝试执行的重做和撤消类型的东西相比，

592
00:25:35,310 --> 00:25:37,060
但它们在的文件基础池中，

593
00:25:37,080 --> 00:25:39,005
它们可能不是适合它的结构，

594
00:25:39,005 --> 00:25:40,610
它们不一定拥有所有缓冲的东西，

595
00:25:40,610 --> 00:25:42,910
所以，它适用于某些应用程序和文件系统，

596
00:25:43,050 --> 00:25:45,130
但是对于数据库系统，我们需要一些不同的东西，

597
00:25:45,330 --> 00:25:47,290
我们需要跨不同的文件。

598
00:25:49,200 --> 00:25:50,780
你可能也会取消我们的所有操作，

599
00:25:50,780 --> 00:25:52,655
所以我们将在详细讨论时讨论所有这些操作，

600
00:25:52,655 --> 00:25:53,560
但这是一个很好的观点，

601
00:25:53,640 --> 00:25:57,820
为什么我，为什么操作系统的人谈论日志结构文件系统，

602
00:25:57,960 --> 00:25:59,735
它们是非常相似的元素，

603
00:25:59,735 --> 00:26:00,580
我们能用这个吗，

604
00:26:01,860 --> 00:26:07,205
我们需要担心跨多个不同表更新记录的事务，

605
00:26:07,205 --> 00:26:09,640
这些表可能位于文件系统中的多个不同文件中，

606
00:26:09,750 --> 00:26:11,860
并且这些文件之间仍然是原子的，

607
00:26:11,970 --> 00:26:12,605
所以这是不同的。

608
00:26:12,605 --> 00:26:13,595
所以，在许多方面，

609
00:26:13,595 --> 00:26:14,465
我们必须做一些事情，

610
00:26:14,465 --> 00:26:15,880
我们有一个更难解决的问题。

611
00:26:17,110 --> 00:26:18,020
不过，这是个很好的问题，

612
00:26:18,130 --> 00:26:18,770
还有其他问题吗？

613
00:26:21,400 --> 00:26:21,800
好的。

614
00:26:22,430 --> 00:26:27,570
好的，所以几乎每个数据库系统都在使用日志记录，

615
00:26:27,800 --> 00:26:29,430
你可能会问，还有其他选择吗，

616
00:26:29,720 --> 00:26:32,610
在日志之前的很早的日子里，

617
00:26:32,810 --> 00:26:35,490
以及所有关于日志真正有效的细节，

618
00:26:35,870 --> 00:26:39,870
做这些事情的一个非常简单的方法是进行影子分页，

619
00:26:39,950 --> 00:26:41,910
它就像是写入时复制的东西，

620
00:26:41,930 --> 00:26:45,480
顺便说一句，你们会在许多应用程序中看到类似的概念，

621
00:26:45,620 --> 00:26:47,050
你们中的那些人使用过操作系统，

622
00:26:47,050 --> 00:26:48,445
或者我已经深入研究过了，

623
00:26:48,445 --> 00:26:52,710
我要找出数据库系统和操作系统之间的许多共同之处，n

624
00:26:52,730 --> 00:26:54,715
我们已经遇到了 latch 和 lock ，

625
00:26:54,715 --> 00:26:55,810
它们试图做不同的事情，

626
00:26:55,810 --> 00:26:58,920
但许多数据库系统将存储更大的内容，

627
00:26:59,270 --> 00:27:01,050
大量的文件和大量的数据，

628
00:27:01,310 --> 00:27:05,400
在我看来，在某些情况下，机制将不同于，通常更丰富。

629
00:27:06,560 --> 00:27:07,890
所以影子是，

630
00:27:08,060 --> 00:27:11,650
好的，我要更改页面上的记录，

631
00:27:11,850 --> 00:27:12,365
你知道的，

632
00:27:12,365 --> 00:27:14,240
我只需要创建一个新的页面副本，

633
00:27:14,240 --> 00:27:15,310
然后在那里进行更改，

634
00:27:15,510 --> 00:27:16,925
这样，如果我需要撤消某些内容，

635
00:27:16,925 --> 00:27:18,220
我只需返回到旧页面，

636
00:27:18,840 --> 00:27:21,710
我有整个页面的前后副本。

637
00:27:21,970 --> 00:27:25,310
当然，现在一些系统仍然这样做，

638
00:27:25,420 --> 00:27:26,595
但这不是一个好主意，

639
00:27:26,595 --> 00:27:27,500
它的效率较低，

640
00:27:27,880 --> 00:27:31,580
如果我只想在一个页面中更改一个字节，

641
00:27:31,660 --> 00:27:33,765
我会创建整个页面的副本，

642
00:27:33,765 --> 00:27:35,090
这显然是浪费的。

643
00:27:35,500 --> 00:27:37,230
我仍然需要去清理东西，

644
00:27:37,310 --> 00:27:38,910
把东西合并到之前的上面，

645
00:27:39,110 --> 00:27:42,300
如果我有一个页面有一个热门记录，

646
00:27:42,800 --> 00:27:44,935
假设它是计数器，

647
00:27:44,935 --> 00:27:48,700
显示我的粉色芭比娃娃有多少 SKU ，

648
00:27:48,700 --> 00:27:49,530
那真的很受欢迎，

649
00:27:49,850 --> 00:27:51,750
每次有人买那个芭比娃娃，

650
00:27:51,830 --> 00:27:52,930
计数器就会改变，

651
00:27:52,930 --> 00:27:55,120
我要创建这个页面的副本一份又一份，

652
00:27:55,120 --> 00:27:56,665
所以如果我有一百万个芭比娃娃，

653
00:27:56,665 --> 00:27:57,690
我就会有一百万个副本。

654
00:27:58,860 --> 00:28:01,400
顺便说一句，数据库系统中的计数器不是以这种方式保存的，

655
00:28:01,400 --> 00:28:04,840
它们是用更多的语义成分来完成的，使用[交换]动作，

656
00:28:05,100 --> 00:28:06,310
这只是一个次要的评论，

657
00:28:06,660 --> 00:28:08,800
也是鼓励参加高级数据库课程，

658
00:28:09,120 --> 00:28:12,095
来讨论更复杂的机制，

659
00:28:12,095 --> 00:28:14,020
以使事务进行得更快、更好。

660
00:28:15,520 --> 00:28:18,975
但你会明白影子分页可以非常快，

661
00:28:18,975 --> 00:28:19,910
这是一种廉价的机制，

662
00:28:20,020 --> 00:28:22,490
易于实施，但存在问题，

663
00:28:22,570 --> 00:28:23,510
日志更好，

664
00:28:23,740 --> 00:28:25,580
这也是大多数数据库系统使用的。

665
00:28:27,190 --> 00:28:28,650
所以让我们来看看 C 部分，

666
00:28:28,650 --> 00:28:31,530
这部分一直很难解释，

667
00:28:31,530 --> 00:28:33,920
但是希望有了这张幻灯片会开始变得更好。

668
00:28:34,180 --> 00:28:35,130
这实质上是说，

669
00:28:35,130 --> 00:28:38,205
我和数据库系统之间有一个契约，

670
00:28:38,205 --> 00:28:39,860
作为一名应用程序程序员，

671
00:28:40,730 --> 00:28:42,550
与数据库系统签订契约，

672
00:28:42,550 --> 00:28:44,760
我将告诉你我想要在应用程序中实现什么，

673
00:28:45,050 --> 00:28:48,760
通过我的 SQL 语句，我的主键约束，我的检查，

674
00:28:48,760 --> 00:28:50,670
和其他我想要在系统中实现的东西，

675
00:28:51,080 --> 00:28:52,770
不要弄乱它。

676
00:28:53,330 --> 00:28:55,980
如果在事务开始之前持有这些约束，

677
00:28:56,690 --> 00:28:57,835
然后，事务运行，

678
00:28:57,835 --> 00:29:00,180
它可能已经触及了一百万个对象，

679
00:29:00,320 --> 00:29:03,270
读写数百个表中的数百万个对象，

680
00:29:03,860 --> 00:29:05,280
一旦你说它被提交了，

681
00:29:05,540 --> 00:29:07,380
所有这些约束必须仍然是真的。

682
00:29:08,860 --> 00:29:10,670
好的，如果我的约束之一是，

683
00:29:10,990 --> 00:29:18,780
价格字段中所有列的总和小于 100 ，

684
00:29:18,780 --> 00:29:19,610
它应该仍然是真的，

685
00:29:19,720 --> 00:29:23,250
如果我说所有的列 A 加起来应该是一百万，

686
00:29:23,250 --> 00:29:24,470
就应该是一百万，

687
00:29:24,610 --> 00:29:31,370
那个 A 列的两个不同的值发生了很大的变化，

688
00:29:31,420 --> 00:29:32,610
那应该仍然是真的，

689
00:29:32,610 --> 00:29:34,425
在它结束的时候，总和应该仍然是一百万。

690
00:29:34,425 --> 00:29:36,440
我已经通过我的约束规定了这个，

691
00:29:36,520 --> 00:29:38,030
这个应该仍然是真的。

692
00:29:39,760 --> 00:29:44,375
现在，事务管理不会做任何不同的事情，

693
00:29:44,375 --> 00:29:45,250
如你所见，

694
00:29:45,330 --> 00:29:48,520
我们只需要确保保持原子性，

695
00:29:48,870 --> 00:29:50,630
保持 AID 组件，

696
00:29:50,630 --> 00:29:53,560
约束一致性将得到正确处理，

697
00:29:53,670 --> 00:29:54,950
如果我们不弄乱的话。

698
00:29:54,950 --> 00:29:58,360
这就是为什么 C 是连接这些东西的原因，

699
00:29:58,530 --> 00:30:01,450
我们今天将在接下来的两节课中讨论的事务机制，

700
00:30:01,620 --> 00:30:03,140
不会直接涉及 C ，

701
00:30:03,140 --> 00:30:07,180
正确定义这些约束是应用程序程序员的责任。

702
00:30:08,420 --> 00:30:10,170
让事情变得更加混乱，

703
00:30:11,580 --> 00:30:13,870
回到大约十年前的一段时间，

704
00:30:14,010 --> 00:30:19,900
所有这些关于最终一致性的东西都很令人兴奋，

705
00:30:20,600 --> 00:30:22,180
尽管它有一致性这个词，

706
00:30:22,180 --> 00:30:25,440
但与我们在这里 ACID 中定义的的 C 的一致性无关，

707
00:30:26,530 --> 00:30:28,460
那个一致性是一个模型表示，

708
00:30:28,690 --> 00:30:31,545
这些事务在分布式系统中很难实现，

709
00:30:31,545 --> 00:30:33,140
要做到这个变得非常困难，

710
00:30:33,250 --> 00:30:34,725
尽管现在我们已经弄清楚了，

711
00:30:34,725 --> 00:30:36,920
以及如何在分布式系统中做事情，

712
00:30:37,060 --> 00:30:37,755
但在那个时候，

713
00:30:37,755 --> 00:30:39,860
当人们在构建这些系统时，

714
00:30:39,940 --> 00:30:43,760
这些系统主要是由没有学习过数据库课程的人构建的，

715
00:30:43,960 --> 00:30:44,780
这就是问题所在。

716
00:30:45,430 --> 00:30:48,470
他们说，我们能做到这个的最好方法是最终一致性，

717
00:30:48,790 --> 00:30:50,150
所以，让更改发生，

718
00:30:50,500 --> 00:30:55,010
然后最终如果两个事务对 A 进行更改，

719
00:30:55,240 --> 00:30:56,780
最终它们将是相同的。

720
00:30:56,800 --> 00:31:00,735
所以，如果从两个账户同时提取 25 美元，

721
00:31:00,735 --> 00:31:02,930
最终它们就会变成 50 美元，

722
00:31:03,160 --> 00:31:06,110
但有一段时间，即使两人都获得了 25 美元，

723
00:31:06,280 --> 00:31:08,180
你读到的值，你会看到 75 ，

724
00:31:08,200 --> 00:31:10,070
所以最终的一致性模型是，

725
00:31:10,970 --> 00:31:13,380
不要相信它的值，最终它会是正确的，

726
00:31:13,520 --> 00:31:15,660
但从应用程序的角度来看，问题是，

727
00:31:15,800 --> 00:31:17,400
我需要等待多长时间，

728
00:31:17,480 --> 00:31:20,130
我怎么知道什么是对的，什么是错的，

729
00:31:20,360 --> 00:31:24,010
在早期，人们还在构建这些应用程序，

730
00:31:24,010 --> 00:31:26,640
有了 Facebook 应用程序的[风险]一致性，

731
00:31:26,960 --> 00:31:27,900
你发布一条消息，

732
00:31:28,580 --> 00:31:30,110
你的朋友会看到，

733
00:31:30,110 --> 00:31:32,170
你在这里刷新，它会消失，

734
00:31:32,220 --> 00:31:33,670
因为它最终会在那里，

735
00:31:34,050 --> 00:31:36,910
但只是从没有收到你的消息的不同服务器获取，

736
00:31:37,320 --> 00:31:39,190
你的第一个连接连接到服务器一，

737
00:31:39,360 --> 00:31:41,380
第二个刷新的连接是另一个，

738
00:31:41,400 --> 00:31:42,790
它还没有得到更新。

739
00:31:43,260 --> 00:31:43,910
所以，正如你可以想象的，

740
00:31:44,110 --> 00:31:46,965
这对应用程序程序员来说变得非常困难，

741
00:31:46,965 --> 00:31:51,840
让数据库系统或数据平台处理事务的全部意义在于，

742
00:31:51,840 --> 00:31:54,620
我作为一名应用程序程序员，我不必处理它。

743
00:31:55,110 --> 00:31:58,990
所以，现在人们普遍认为这是一个非常糟糕的想法，

744
00:31:59,310 --> 00:32:02,525
除非你对性能有非常严格的要求，

745
00:32:02,525 --> 00:32:04,660
要求你只做这件事。

746
00:32:06,030 --> 00:32:09,430
但这不是构建数据平台的方法说，

747
00:32:09,570 --> 00:32:11,920
你作为应用程序人员开始担心事务。

748
00:32:15,530 --> 00:32:17,490
很多系统仍然使用最终一致性，

749
00:32:17,720 --> 00:32:20,190
但我将简单地展示一下 Spanner 论文，

750
00:32:20,420 --> 00:32:22,975
它在全球范围内使用，

751
00:32:22,975 --> 00:32:24,300
甚至比 ACID 更强。

752
00:32:24,960 --> 00:32:27,230
再说一次，如果你上了高级数据库课，

753
00:32:27,310 --> 00:32:29,990
我们会在那里讨论类似的东西。

754
00:32:30,010 --> 00:32:32,690
所以，这并不是说今天的系统不使用它，

755
00:32:32,980 --> 00:32:33,920
我只是说，

756
00:32:34,330 --> 00:32:35,780
在我看来，这不是一个好主意，

757
00:32:35,980 --> 00:32:38,450
将它作为构建数据平台的默认方式。

758
00:32:39,120 --> 00:32:41,090
你可能想这么做还是有一些原因的，

759
00:32:41,090 --> 00:32:42,560
但这不是你应该说的方式，

760
00:32:42,560 --> 00:32:45,605
我要让我的数据库在设计上保持最终一致性，

761
00:32:45,605 --> 00:32:49,180
因为，我没有想过做其他方式来做完整的事务，

762
00:32:49,800 --> 00:32:50,500
它们的性能，

763
00:32:50,550 --> 00:32:52,835
显然，最终一致性可以获得更高的性能，

764
00:32:52,835 --> 00:32:53,830
这一点是毫无疑问的。

765
00:32:54,300 --> 00:32:55,970
对于这个问题我很抱歉，但是。

766
00:32:56,330 --> 00:32:58,465
我闭上耳朵。大家都闭上耳朵，没有。

767
00:32:58,465 --> 00:33:03,445
基本上，什么是最终一致性？

768
00:33:03,445 --> 00:33:04,290
最终一致性是指，

769
00:33:04,490 --> 00:33:06,570
最终所有的值都会是正确的值。

770
00:33:07,510 --> 00:33:09,020
所以，它就像你获得了你的事务，

771
00:33:09,190 --> 00:33:11,190
但在一段时间内，你可能会看到不一致的值，

772
00:33:11,190 --> 00:33:12,950
这就是最终一致性。

773
00:33:13,060 --> 00:33:16,725
所以，就像应用程序到达那里，

774
00:33:16,725 --> 00:33:17,540
而它可能是错误的。

775
00:33:17,590 --> 00:33:18,450
是的，就像我说的，

776
00:33:18,450 --> 00:33:19,830
你可能会短期看到 75 美元，

777
00:33:19,830 --> 00:33:20,600
然后它应该是 50 美元，

778
00:33:21,100 --> 00:33:24,920
你们并排站在两台并排的 ATM 机边上，

779
00:33:25,090 --> 00:33:26,910
你们两个都拿到了 25 美元，

780
00:33:26,910 --> 00:33:29,030
你们会说，哦， 75 美元在银行里，

781
00:33:29,480 --> 00:33:30,275
但事实并非如此，

782
00:33:30,275 --> 00:33:31,280
银行会说，

783
00:33:31,280 --> 00:33:33,530
实际上我们寄给你的是 50 美元，

784
00:33:33,530 --> 00:33:34,870
最终会是正确的金额。

785
00:33:35,800 --> 00:33:37,400
但如你所见，这很难，

786
00:33:37,510 --> 00:33:39,060
你不希望在你的应用程序中出现这种情况。

787
00:33:39,060 --> 00:33:39,440
是的。

788
00:33:40,460 --> 00:33:41,790
是的，还有问题吗？

789
00:33:46,210 --> 00:33:48,555
不，还有其他[]有最终的致性，

790
00:33:48,555 --> 00:33:51,350
其他系统也有最终一致性模型。

791
00:33:56,350 --> 00:33:57,620
把这个词拿出来，是的。

792
00:33:57,790 --> 00:34:01,580
但是有一段时间人们说，

793
00:34:01,660 --> 00:34:02,700
我们不需要 SQL ，

794
00:34:02,700 --> 00:34:03,470
我们不需要事务，

795
00:34:04,000 --> 00:34:08,240
没有 SQL ，最终一致性对这些人来说并不是很有效。

796
00:34:09,830 --> 00:34:12,730
所以，我并不是说没有必要保持最终的一致性，

797
00:34:12,730 --> 00:34:15,480
我的意思是，默认情况下，这不是你应该为之设计的，

798
00:34:16,010 --> 00:34:17,250
除非你知道你要面对的是什么，

799
00:34:17,450 --> 00:34:19,710
而现在你将不得不将复杂性放在应用程序中。

800
00:34:20,850 --> 00:34:21,250
好的？

801
00:34:22,670 --> 00:34:24,100
所以，它仍然有一些位置，

802
00:34:24,100 --> 00:34:25,860
但这并不是默认设置。

803
00:34:26,450 --> 00:34:29,640
所以，好的，让我们再去找我的鼠标，

804
00:34:29,720 --> 00:34:30,360
我们走吧。

805
00:34:32,650 --> 00:34:34,760
好的，事务的隔离性。

806
00:34:34,930 --> 00:34:35,960
所以我们仍然在 I ，

807
00:34:36,310 --> 00:34:37,220
用户提交事务，

808
00:34:37,420 --> 00:34:39,950
每个事务的执行方式就像它自己运行一样，

809
00:34:40,630 --> 00:34:43,340
正如我们所说的，显然它是一种更容易的编程模型，

810
00:34:43,600 --> 00:34:45,770
而 DBMS 将做它的事情，

811
00:34:45,910 --> 00:34:50,150
给这个每次一个或隔离的原则。

812
00:34:50,320 --> 00:34:53,580
所以，它是如果做到这个的？

813
00:34:54,590 --> 00:34:56,725
这里有两类方法，

814
00:34:56,725 --> 00:34:59,710
再次，今天我从高层次上概述它，

815
00:34:59,710 --> 00:35:02,310
我们将在下次课程中详细介绍。

816
00:35:02,660 --> 00:35:03,450
两节课，

817
00:35:03,500 --> 00:35:05,820
一个是悲观的，也就是说，

818
00:35:06,520 --> 00:35:08,340
即使在我允许读写发生之前，

819
00:35:08,540 --> 00:35:09,865
我是悲观的，

820
00:35:09,865 --> 00:35:11,430
如果我认为会发生一些不好的事情，

821
00:35:11,510 --> 00:35:12,640
我会阻止你，

822
00:35:12,640 --> 00:35:16,080
阻止我认为会开始这个不好的操作的事务，

823
00:35:16,730 --> 00:35:20,610
我们将通过几个机制来看看这是如何发生的。

824
00:35:21,600 --> 00:35:30,605
第二种方式基本上就是做一个叫乐观并发的事情，

825
00:35:30,605 --> 00:35:31,210
也就是说，

826
00:35:31,470 --> 00:35:33,370
我觉得每个生活都是好的，

827
00:35:33,750 --> 00:35:35,830
我要让每一个事务都通过，

828
00:35:36,400 --> 00:35:37,950
我仍然会提供隔离原则，

829
00:35:38,000 --> 00:35:40,200
这样它们就不会相互干扰，

830
00:35:40,670 --> 00:35:42,390
但我会通过检查来做到这个，

831
00:35:42,590 --> 00:35:44,110
假设一切都会顺利进行，

832
00:35:44,110 --> 00:35:45,970
所以，就像每个人都去你的读写，

833
00:35:45,970 --> 00:35:47,730
我会跟踪它，去做你的变更，

834
00:35:48,230 --> 00:35:49,470
但在你准备提交之前，

835
00:35:49,520 --> 00:35:50,545
我会做一些检查，

836
00:35:50,545 --> 00:35:52,195
看看你们是否相互干扰，

837
00:35:52,195 --> 00:35:52,920
你们所有的人，

838
00:35:53,030 --> 00:35:55,890
你们所有同时运行的事务。

839
00:35:56,340 --> 00:36:00,220
所以，乐观是，大多数事务并不相互冲突，

840
00:36:00,390 --> 00:36:03,910
所以，我可以通过乐观获得更高性能的系统，

841
00:36:04,110 --> 00:36:05,500
大多数事情都会解决，

842
00:36:05,640 --> 00:36:06,730
它仍然是正确的，

843
00:36:07,050 --> 00:36:08,530
所以它将确保不会发生不好的事情，

844
00:36:08,640 --> 00:36:09,640
但这是一种不同的哲学。

845
00:36:12,890 --> 00:36:14,680
好的，所以。

846
00:36:20,440 --> 00:36:22,190
让我们开始深入研究几个例子。

847
00:36:22,300 --> 00:36:27,020
现在，我们知道，事务将被转换为这些读写操作，

848
00:36:27,280 --> 00:36:31,170
现在你开始看到一些 BEGIN 和 COMMIT 调用进入。

849
00:36:31,170 --> 00:36:32,210
所以， T1 是一个事务，

850
00:36:32,740 --> 00:36:33,855
那个减法，

851
00:36:33,855 --> 00:36:36,890
它将 100 美元从银行帐户 A 转移到银行帐户 B ，

852
00:36:37,210 --> 00:36:39,110
T2 是一个事务，

853
00:36:39,220 --> 00:36:42,540
为所有银行帐户增加 6% 利息，

854
00:36:42,540 --> 00:36:44,310
假设这是一家小银行，

855
00:36:44,310 --> 00:36:45,680
所以它只有两个银行帐户，

856
00:36:47,860 --> 00:36:49,100
还可以使示例保持简单。

857
00:36:50,300 --> 00:36:52,440
这两个事务可能的结果是什么？

858
00:36:53,320 --> 00:36:54,620
两种可能的结果。

859
00:36:55,340 --> 00:36:55,950
一个是，

860
00:36:57,780 --> 00:36:59,770
假设 A 和 B 都是，从 1000 美元开始，

861
00:37:00,660 --> 00:37:05,410
如果我运行 A 在 B 之前或 B 在 A 之前，

862
00:37:05,550 --> 00:37:09,610
我会得到两种不同的执行策略，

863
00:37:10,110 --> 00:37:15,050
但最终 A 加上 B 应该是 2000 6% ，

864
00:37:15,050 --> 00:37:17,800
这意味着总的银行账户，

865
00:37:18,380 --> 00:37:19,380
跨越这两家银行，

866
00:37:20,170 --> 00:37:22,160
应该是 2120 。

867
00:37:23,470 --> 00:37:26,290
所以，这就是我们想要的结果。

868
00:37:26,740 --> 00:37:30,790
现在，接下来我们要看的是，

869
00:37:30,810 --> 00:37:32,770
我将跳到这里是，

870
00:37:34,080 --> 00:37:35,530
只有这两个事务，

871
00:37:36,420 --> 00:37:39,760
我可以保持正确的隔离属性，

872
00:37:40,200 --> 00:37:43,210
通过无论先运行第一个事务，

873
00:37:43,920 --> 00:37:46,390
和先运行第二个事务，

874
00:37:46,440 --> 00:37:47,570
这里有两种可能的结果，

875
00:37:47,570 --> 00:37:50,710
T1 在 T2 之前运行，或者相反。

876
00:37:50,880 --> 00:37:52,240
所以，在这里你可以看到，

877
00:37:52,350 --> 00:37:57,820
一个例子， A 的值是 954 ， B 是 1166 ，

878
00:37:57,900 --> 00:38:02,230
这相当于首先完成了 100 美元的转账，然后加上 6% ，

879
00:38:02,790 --> 00:38:04,930
另一个是反过来做的。

880
00:38:06,350 --> 00:38:09,490
所以，根据隔离原则，这两种中的任何一种都是正确的，

881
00:38:09,490 --> 00:38:12,210
如果两个事务同时在系统中，

882
00:38:12,530 --> 00:38:13,350
我们没有问题，

883
00:38:13,370 --> 00:38:15,030
作为一个事务管理系统，

884
00:38:15,140 --> 00:38:16,465
我们可以选择那个顺序，

885
00:38:16,465 --> 00:38:18,900
所以，让我们更直观地看待它，

886
00:38:19,070 --> 00:38:20,220
这可能是有意义的。

887
00:38:21,320 --> 00:38:23,280
有一种串行执行的概念，

888
00:38:23,940 --> 00:38:27,860
我们将在接下来的 10 到 15 张幻灯片中看到的串行执行图，

889
00:38:28,150 --> 00:38:31,400
所有都有时间从上到下，

890
00:38:31,840 --> 00:38:33,470
想象一下，你是机器，

891
00:38:33,640 --> 00:38:35,570
你看着事务向你过来。

892
00:38:36,100 --> 00:38:38,300
隔离性基本上是说，

893
00:38:38,470 --> 00:38:40,580
如果这个执行是这样的，

894
00:38:40,840 --> 00:38:43,035
你可以向我展示，向我证明，

895
00:38:43,035 --> 00:38:44,180
无论你做什么，

896
00:38:44,500 --> 00:38:45,840
无论你允许了哪一个事务，

897
00:38:45,840 --> 00:38:47,780
比如一个发生在另一个之前，

898
00:38:48,040 --> 00:38:49,910
一个发生在另一个之前可以是，

899
00:38:49,930 --> 00:38:52,640
T1 发生在 T2 之前，在这个例子中，

900
00:38:53,020 --> 00:38:54,300
这是左边的例子，

901
00:38:54,300 --> 00:38:58,280
当你最终得到 A 等于 954 ， B 等于 1166 ，

902
00:38:58,540 --> 00:39:00,240
或 T2 在前，

903
00:39:00,240 --> 00:39:01,160
它们都是正确的。

904
00:39:01,580 --> 00:39:04,980
但是，如果你要干预这两个事务的这些读写操作，

905
00:39:05,810 --> 00:39:09,870
数据库最好以这两个正确的结束状态之一结束，

906
00:39:10,500 --> 00:39:12,750
哪一个，并不重要，

907
00:39:12,860 --> 00:39:14,160
但它应该是那两个中的一个，

908
00:39:14,210 --> 00:39:15,510
而不是别的。

909
00:39:15,800 --> 00:39:16,200
问题？

910
00:39:16,340 --> 00:39:28,770
不，这才是重点。

911
00:39:28,770 --> 00:39:29,510
所以问题是，

912
00:39:29,620 --> 00:39:30,945
为什么我们要并行做这件事，

913
00:39:30,945 --> 00:39:31,760
这就是重点。

914
00:39:32,230 --> 00:39:33,720
现在，这是一个串行执行，

915
00:39:33,720 --> 00:39:35,600
所以在时间上 T1 发生在 T2 之后，

916
00:39:35,680 --> 00:39:36,780
但我们想要做的是，

917
00:39:36,780 --> 00:39:40,520
假设我在这台服务器中有两个核心，

918
00:39:40,750 --> 00:39:42,435
而今天的服务器有 40 个核心，

919
00:39:42,435 --> 00:39:44,690
数据库机器有时有数百台机器，

920
00:39:45,210 --> 00:39:47,180
我不想一次只运行一个事务，

921
00:39:47,180 --> 00:39:50,890
我希望能够在任何给定的时间点执行尽可能多的操作，

922
00:39:51,030 --> 00:39:52,540
我想做尽可能多的事情，

923
00:39:53,590 --> 00:39:55,815
因为我想使用我有权访问的所有硬件，

924
00:39:55,815 --> 00:39:57,800
所以我可以在系统中获得更多事务，

925
00:39:58,030 --> 00:40:00,530
更高的吞吐量和更低的潜在延迟。

926
00:40:03,660 --> 00:40:05,330
不，不，不，我们不会降低标准，

927
00:40:05,330 --> 00:40:07,270
所以等等，我们不会降低标准，

928
00:40:07,620 --> 00:40:11,230
我们肯定会稍微改变一下标准，

929
00:40:11,280 --> 00:40:16,180
说 T1 和 T2 的任何排列都是允许的，

930
00:40:16,320 --> 00:40:17,750
T1 和 T2 可以互换，

931
00:40:17,750 --> 00:40:21,980
只要我们能证明一个在另一个之前做了所有的工作。

932
00:40:21,980 --> 00:40:23,170
所以等待两张幻灯片，

933
00:40:23,400 --> 00:40:26,630
你是对的，就像为什么不是只有一种可能的方式，

934
00:40:26,630 --> 00:40:28,330
T1 在 T2 之前，

935
00:40:28,470 --> 00:40:29,315
如果我们这样做了，

936
00:40:29,315 --> 00:40:32,530
那么我们就会减少系统中的并行性。

937
00:40:33,090 --> 00:40:36,425
所以你要放松严格的概念，什么是正确的，

938
00:40:36,425 --> 00:40:41,290
这就是可串行化的严格概念，

939
00:40:41,370 --> 00:40:42,130
这意味着，

940
00:40:42,360 --> 00:40:44,375
事务应该感觉像是，

941
00:40:44,375 --> 00:40:47,890
它们在物理世界中发生的那样[]，

942
00:40:47,940 --> 00:40:50,650
我们将在下一节课中讨论一点这个，

943
00:40:50,760 --> 00:40:53,590
我们将在高级数据库课上更详细地讨论这个。

944
00:40:54,560 --> 00:40:56,460
首先，让我们做一点写入，

945
00:40:56,930 --> 00:40:59,460
顺便说一句，这就是今天大多数数据库系统所做的事情，

946
00:40:59,630 --> 00:41:03,055
他们会稍微冒昧地[]一下，

947
00:41:03,055 --> 00:41:05,275
因为就像 T1 和 T2 同时发出，

948
00:41:05,275 --> 00:41:07,650
同时发出意味着什么，

949
00:41:07,700 --> 00:41:09,510
他们可能在不同的城市，

950
00:41:09,710 --> 00:41:10,945
如果你们坐在一起，

951
00:41:10,945 --> 00:41:14,125
你们不会在同一时间按下按钮，

952
00:41:14,125 --> 00:41:15,180
因为这不会发生，

953
00:41:15,950 --> 00:41:17,640
所以这就像同时是什么意思。

954
00:41:17,780 --> 00:41:19,375
所以我们会稍微放松一点，

955
00:41:19,375 --> 00:41:20,815
我们所能说的是，

956
00:41:20,815 --> 00:41:23,070
如果我们有这种适当的隔离，

957
00:41:23,180 --> 00:41:25,350
最终的值应该是这两个值中的一个，

958
00:41:25,800 --> 00:41:26,555
不是第三个值。

959
00:41:26,555 --> 00:41:28,210
首先看看这张幻灯片，是的，

960
00:41:28,800 --> 00:41:34,390
在这里 T1 开始，减去 100 ，

961
00:41:34,710 --> 00:41:37,690
现在 A 已经把 100 美元去掉了，

962
00:41:37,860 --> 00:41:42,310
T2 启动，产生 6% 的利息到两个银行账户，

963
00:41:42,600 --> 00:41:47,770
但它查看的 A 的银行账户价值还差 100 美元，

964
00:41:48,030 --> 00:41:51,790
所以它最终的值是 2114 作为总和，

965
00:41:52,200 --> 00:41:55,750
这比原来应该是的值少了 6 美元。

966
00:41:56,550 --> 00:41:58,810
所以我们想要允许的是这两个，

967
00:41:58,830 --> 00:42:01,720
前一张幻灯片中的交错是安全的，

968
00:42:01,950 --> 00:42:04,900
即使有交错，你最终也会得到正确的值，

969
00:42:04,980 --> 00:42:08,020
但这是一个不安全交错的例子，

970
00:42:08,040 --> 00:42:10,525
你最终得到了错误的值。

971
00:42:10,525 --> 00:42:11,790
所以这是好的，

972
00:42:12,320 --> 00:42:15,330
抱歉，我看错幻灯片了，

973
00:42:16,160 --> 00:42:16,825
这是好的，

974
00:42:16,825 --> 00:42:19,500
问题是，我们如何确定这是可以的，

975
00:42:20,160 --> 00:42:23,770
这种跨不同事务的操作交错是可以的，

976
00:42:24,090 --> 00:42:25,420
但这个不可以。

977
00:42:27,070 --> 00:42:27,470
好的？

978
00:42:28,205 --> 00:42:29,770
那么让我们来看看，我们是如何做到这个的。

979
00:42:30,300 --> 00:42:32,360
所以有一个正式的串行调度的概念，

980
00:42:32,740 --> 00:42:36,870
它指的是一个不会交错任何操作的调度。

981
00:42:36,870 --> 00:42:37,890
所以我们看到，

982
00:42:37,890 --> 00:42:40,935
一个串行调度的例子是，

983
00:42:40,935 --> 00:42:44,030
你只有所有的 T1 ，

984
00:42:44,410 --> 00:42:45,890
就像这是一个串行调度，

985
00:42:46,210 --> 00:42:46,965
所以如果我们回去，

986
00:42:46,965 --> 00:42:48,020
这是一个串行调度，

987
00:42:48,310 --> 00:42:52,460
T1 在 T2 之前，或者 T2 在 T1 之前。

988
00:42:53,090 --> 00:42:56,800
好的，现在我们要做的是，

989
00:42:56,800 --> 00:42:59,970
更难的部分是一个等效调度。

990
00:43:01,800 --> 00:43:06,550
所以这是我们看到的一个正确的调度，

991
00:43:07,260 --> 00:43:08,270
它不是串行的，

992
00:43:08,940 --> 00:43:10,160
但如你所见，这是正确的，

993
00:43:10,480 --> 00:43:12,470
我们想看看这个调度，

994
00:43:12,790 --> 00:43:18,675
并说左边的那个等同于右边的串行调度，

995
00:43:18,675 --> 00:43:21,420
我们希望能够证明这一点，

996
00:43:21,420 --> 00:43:22,215
在这种情况下，

997
00:43:22,215 --> 00:43:24,290
我们说调度是安全的，这是允许的。

998
00:43:24,550 --> 00:43:27,830
所以，等效调度的概念是说，

999
00:43:27,940 --> 00:43:29,090
允许一些交错，

1000
00:43:30,330 --> 00:43:32,950
只要你能证明交错是安全的，

1001
00:43:34,450 --> 00:43:36,740
而安全的证据是，

1002
00:43:36,970 --> 00:43:40,400
所有这些操作都等效于某个串行调度，

1003
00:43:40,660 --> 00:43:42,285
在这种情况下，其中一个，

1004
00:43:42,285 --> 00:43:44,900
T1 在 T2 之前，或者 T2 在 T1 之前，

1005
00:43:45,160 --> 00:43:45,945
都是可以的，

1006
00:43:45,945 --> 00:43:47,300
你最终可以得到正确的答案。

1007
00:43:48,250 --> 00:43:49,400
这听起来像是魔术，

1008
00:43:50,020 --> 00:43:54,740
但有一个非常简单的方法来解决这个问题。

1009
00:43:55,510 --> 00:43:57,465
这就是你所问的部分，

1010
00:43:57,465 --> 00:44:00,170
就是，好的，但是为什么数据库的两种状态是正确的，

1011
00:44:00,670 --> 00:44:04,880
这就是我们在这个可串行化中放松的一点，

1012
00:44:04,900 --> 00:44:05,535
正如我所说的，

1013
00:44:05,535 --> 00:44:07,140
有两种严格的串行化，

1014
00:44:07,140 --> 00:44:09,050
在那里，现实世界的效果发生了，

1015
00:44:09,190 --> 00:44:10,190
它更严格了，

1016
00:44:10,330 --> 00:44:12,525
但是为了这门课的目的，

1017
00:44:12,525 --> 00:44:14,000
我们将使用这个概念，

1018
00:44:14,380 --> 00:44:18,990
我们只需要证明它等效于许多串行调度之一。

1019
00:44:18,990 --> 00:44:19,790
如果你有两个事务，

1020
00:44:20,200 --> 00:44:21,740
那么只有两种可能的结果，

1021
00:44:21,790 --> 00:44:23,930
如果有三个， T1, T2, T3 ，

1022
00:44:24,070 --> 00:44:24,830
它可能是，

1023
00:44:25,310 --> 00:44:27,270
第一个事务可能是其中之一，

1024
00:44:27,530 --> 00:44:28,830
有三种可能的组合，

1025
00:44:29,240 --> 00:44:30,895
然后是两种，然后是一种，

1026
00:44:30,895 --> 00:44:33,120
所以你得到了阶乘效应。

1027
00:44:34,300 --> 00:44:36,110
我们将考虑这些读写，

1028
00:44:36,160 --> 00:44:41,470
从可以发生在这些对象之间的冲突操作的角度，

1029
00:44:42,090 --> 00:44:43,960
比如 A B 和 C 。

1030
00:44:44,520 --> 00:44:46,090
所以我们将会有，

1031
00:44:46,880 --> 00:44:48,810
我们称这些东西为异常，

1032
00:44:49,160 --> 00:44:50,880
有三种不同的类型，

1033
00:44:51,230 --> 00:44:52,630
读操作可能会干扰，

1034
00:44:52,630 --> 00:44:57,210
在一个事务中，读取对象，其他人向其写入内容，

1035
00:44:57,810 --> 00:45:01,570
或者，一个事务写入一个对象，其他人读取该对象，

1036
00:45:02,140 --> 00:45:03,980
第三种是两个事务，

1037
00:45:04,120 --> 00:45:08,180
一个事务写入对象，另一个事务也写入该对象。

1038
00:45:08,640 --> 00:45:10,640
这种组合中缺少的是读读，

1039
00:45:11,260 --> 00:45:12,560
这显然不是冲突，

1040
00:45:12,880 --> 00:45:14,660
如果我只是在读这两个事务，

1041
00:45:14,830 --> 00:45:16,550
如果我只有一份只读的副本，

1042
00:45:17,080 --> 00:45:18,405
那么许多事务都能读到它，

1043
00:45:18,405 --> 00:45:19,880
你们不会互相冲突的，

1044
00:45:20,080 --> 00:45:21,560
这是只读副本。

1045
00:45:22,350 --> 00:45:27,940
好的，让我们来看看这些读写冲突。

1046
00:45:28,540 --> 00:45:29,220
这是一个调度，

1047
00:45:30,060 --> 00:45:33,320
有一个读取对象 A ，

1048
00:45:33,460 --> 00:45:35,640
随后是写入对象 A ，

1049
00:45:35,640 --> 00:45:37,580
这些操作相互交错，

1050
00:45:37,720 --> 00:45:43,880
这就是读写冲突的一个例子。

1051
00:45:44,560 --> 00:45:46,440
调度中还存在其他冲突，

1052
00:45:47,090 --> 00:45:51,000
但是，这个读写对象冲突事务的缺点是什么，

1053
00:45:51,530 --> 00:45:53,550
事务一读取 A 的值，

1054
00:45:54,680 --> 00:45:55,470
T2 运行，

1055
00:45:56,850 --> 00:45:59,410
然后 T1 读取该值，并得到一个不同的值，

1056
00:45:59,550 --> 00:46:00,700
所以它之前是 10 ，

1057
00:46:01,170 --> 00:46:02,290
T2 把它改为 19 ，

1058
00:46:03,000 --> 00:46:04,240
T1 再次读取它。

1059
00:46:04,260 --> 00:46:06,730
显然，它没有看到隔离性原则，

1060
00:46:06,960 --> 00:46:07,810
在同一个事务中，

1061
00:46:08,250 --> 00:46:09,610
如果我读取值两次，

1062
00:46:09,750 --> 00:46:10,960
我应该看到相同的值，

1063
00:46:11,100 --> 00:46:12,700
除非其他人干扰我。

1064
00:46:12,780 --> 00:46:15,220
所以，它违反了隔离性原则。

1065
00:46:15,750 --> 00:46:16,810
就是这样。

1066
00:46:21,190 --> 00:46:24,920
好的，我们来看一下，

1067
00:46:25,990 --> 00:46:27,735
这被称为不可重复读，

1068
00:46:27,735 --> 00:46:29,090
因为当你有读写冲突时，

1069
00:46:29,440 --> 00:46:31,200
同一事务读取该值两次，

1070
00:46:31,200 --> 00:46:32,330
它将看到不同的值。

1071
00:46:33,100 --> 00:46:34,135
脏读是指，

1072
00:46:34,135 --> 00:46:36,240
我读了一个值，假设这个 10 ，

1073
00:46:36,650 --> 00:46:38,100
将其写为 12 ，

1074
00:46:38,600 --> 00:46:40,950
其他人读取值，即 12 ，

1075
00:46:41,960 --> 00:46:42,900
到目前为止，没有问题，

1076
00:46:43,310 --> 00:46:45,580
但稍晚发生的是，

1077
00:46:45,580 --> 00:46:46,770
事务 T1 中止，

1078
00:46:47,240 --> 00:46:48,925
当事务 T1 中止，

1079
00:46:48,925 --> 00:46:50,815
值 12 永远不应该被读取，

1080
00:46:50,815 --> 00:46:52,555
因为它没有提交到数据库，

1081
00:46:52,555 --> 00:46:55,720
这是一个被丢弃的中间值，

1082
00:46:55,720 --> 00:46:57,360
这就是中止应该做的事情。

1083
00:46:57,560 --> 00:46:59,880
所以现在事务 T2 ，

1084
00:47:00,050 --> 00:47:01,560
当它读取值 A 时，

1085
00:47:01,700 --> 00:47:03,000
读取了一个脏值，

1086
00:47:03,230 --> 00:47:04,860
不应该存在于数据库中，

1087
00:47:06,170 --> 00:47:07,020
因为那个中止。

1088
00:47:07,040 --> 00:47:08,280
所以这就是所谓的脏读。

1089
00:47:10,350 --> 00:47:11,740
写写冲突是，

1090
00:47:11,970 --> 00:47:13,540
T1 写入一个值，

1091
00:47:14,760 --> 00:47:17,260
T2 也在写入那个值，

1092
00:47:17,730 --> 00:47:22,915
当 T1 写入另一个值 B ，

1093
00:47:22,915 --> 00:47:25,200
T1 感觉就像写入了 10 美元，

1094
00:47:25,730 --> 00:47:27,780
想象 A 和 B 现在是列，

1095
00:47:27,980 --> 00:47:32,010
它更新 Alice 帐户中 10 美元的记录，

1096
00:47:32,700 --> 00:47:37,900
它的第一列是 10 ，账户金额，

1097
00:47:38,070 --> 00:47:39,580
而 B 是人名，

1098
00:47:39,810 --> 00:47:41,260
它认为它给 Alice 增加了 10 ，

1099
00:47:41,490 --> 00:47:43,700
但这里的另一个冲突是，

1100
00:47:43,700 --> 00:47:45,700
写入相同的记录，19 和 Bob 。

1101
00:47:45,810 --> 00:47:47,500
所以这里你有 10 ，

1102
00:47:47,580 --> 00:47:50,320
19 和 Bob 也被写进了同一个记录，

1103
00:47:50,550 --> 00:47:53,800
然后你就有了这个 Alice B 被写入，

1104
00:47:53,910 --> 00:47:56,770
19 和 Bob 的更新刚刚被覆盖。

1105
00:47:57,460 --> 00:47:59,625
所以，事务二完成了它的工作，

1106
00:47:59,625 --> 00:48:01,310
但它的值刚刚被覆盖，

1107
00:48:01,390 --> 00:48:02,820
所以它丢失了更新，

1108
00:48:02,820 --> 00:48:04,520
它从未没有进入数据库。

1109
00:48:06,050 --> 00:48:06,450
好的？

1110
00:48:08,040 --> 00:48:13,180
所以，我们使用这些属性来定义，

1111
00:48:13,710 --> 00:48:17,950
如何使这个等效调度工作。

1112
00:48:18,550 --> 00:48:23,240
这两种类型的冲突可串行化，

1113
00:48:23,240 --> 00:48:24,340
这是我们接下来要讨论的，

1114
00:48:24,750 --> 00:48:26,440
有时称为视图可串行化，

1115
00:48:26,760 --> 00:48:27,815
由于我们的时间不多了，

1116
00:48:27,815 --> 00:48:29,870
我可能会完全跳过这一部分，

1117
00:48:29,870 --> 00:48:31,720
但我会简要地暗示一下它的作用。

1118
00:48:31,980 --> 00:48:36,160
好的，我不会拿视图可视化的考试试题来盘问你，

1119
00:48:36,360 --> 00:48:38,300
所以如果你不完全理解，也没有关系，

1120
00:48:38,300 --> 00:48:41,170
冲突可串行化是数据库系统实现的，

1121
00:48:41,430 --> 00:48:42,850
让我们直接跳到这个上面。

1122
00:48:44,190 --> 00:48:46,505
让我在这里使用这个图表形式，

1123
00:48:46,505 --> 00:48:48,640
以使它更容易理解。

1124
00:48:48,840 --> 00:48:50,230
所以我们要做的是以下几点。

1125
00:48:50,920 --> 00:48:52,740
我们采取我们已有的操作，

1126
00:48:53,620 --> 00:48:56,490
这是我们有的调度，

1127
00:48:57,210 --> 00:48:58,700
我们将开始经历这一过程，

1128
00:48:58,700 --> 00:49:01,690
并列举所有可能的冲突，

1129
00:49:02,040 --> 00:49:04,810
读写，写写，写读，

1130
00:49:05,160 --> 00:49:06,430
好的，这三种冲突。

1131
00:49:06,720 --> 00:49:10,070
我们创建一个称为依赖图的图，

1132
00:49:10,640 --> 00:49:13,000
所以我在图中有两个节点， T1 和 T2 ，

1133
00:49:13,080 --> 00:49:15,400
每次有事务进入时，都会添加新的节点，

1134
00:49:15,660 --> 00:49:17,080
所以，该图将具有尽可能多的事务，

1135
00:49:17,220 --> 00:49:19,840
在任何时间点系统中处于活动状态的（事务）。

1136
00:49:20,610 --> 00:49:22,960
现在我将开始遍历调度，

1137
00:49:23,460 --> 00:49:25,720
并开始标记所有的冲突，

1138
00:49:26,280 --> 00:49:29,940
我从我看到的第一个冲突开始，

1139
00:49:29,940 --> 00:49:30,830
这是一个读写，

1140
00:49:31,850 --> 00:49:33,480
是什么冲突并不重要，

1141
00:49:33,530 --> 00:49:36,060
一旦我有了这三种冲突中的一种，

1142
00:49:36,230 --> 00:49:38,250
读写，写写或写读，

1143
00:49:38,600 --> 00:49:40,290
我就会在那里放一个箭头，

1144
00:49:40,670 --> 00:49:45,920
所以第一个冲突在这个对象 A 上，

1145
00:49:46,150 --> 00:49:48,645
它从 T1 到 T2 ，

1146
00:49:48,645 --> 00:49:51,830
因为在调度中 T1 在 T2 之前，

1147
00:49:52,340 --> 00:49:55,180
所以我会画一条从 T1 到 T2 的有向弧线。

1148
00:49:56,360 --> 00:49:57,180
这能理解吗？

1149
00:49:57,530 --> 00:49:58,440
所以，真的很简单，

1150
00:49:58,760 --> 00:50:01,350
我将遍历这个，

1151
00:50:01,490 --> 00:50:03,000
对所遇到的每一个冲突，

1152
00:50:03,050 --> 00:50:06,600
按照冲突发生的顺序绘制一个有向图。

1153
00:50:09,130 --> 00:50:13,190
现在我要去寻找下一个冲突，

1154
00:50:14,040 --> 00:50:16,160
它是写后面跟着读，

1155
00:50:16,510 --> 00:50:18,110
我会这样做。

1156
00:50:19,610 --> 00:50:21,870
所以，证明非常简单，

1157
00:50:22,890 --> 00:50:23,890
你拿到一个调度，

1158
00:50:25,130 --> 00:50:26,670
如果你遍历它，

1159
00:50:26,930 --> 00:50:33,450
为每一个读写、写写或写读冲突画一条线，

1160
00:50:35,150 --> 00:50:38,270
如果这张图里有一个环，

1161
00:50:38,560 --> 00:50:40,700
你的调度是糟糕的，

1162
00:50:41,550 --> 00:50:44,710
这个调度将会违反隔离性原则，

1163
00:50:45,180 --> 00:50:49,180
这个调度永远不应该被允许在数据库系统中运行。

1164
00:50:49,790 --> 00:50:50,605
在下一节课中，

1165
00:50:50,605 --> 00:50:54,300
我们将看到可以用来防止这种情况发生的机制。

1166
00:50:55,980 --> 00:50:56,830
这能理解吗，

1167
00:50:57,180 --> 00:50:59,645
如果你因为幻灯片中的那个错误而没有得到任何其他东西，

1168
00:50:59,645 --> 00:51:02,740
这就是我希望你从这个隔离性原则中得到的主要东西。

1169
00:51:03,740 --> 00:51:04,360
方向是什么？

1170
00:51:05,960 --> 00:51:08,215
这些边是按时间顺序排列的，

1171
00:51:08,215 --> 00:51:10,930
请看写入后面跟着读取，

1172
00:51:10,930 --> 00:51:12,720
现在这里显示的红线，

1173
00:51:13,910 --> 00:51:15,895
它是从 T1 到 T2 ，

1174
00:51:15,895 --> 00:51:19,380
对 A 的写入发生在 T2 读取之前，

1175
00:51:20,110 --> 00:51:22,725
所以我将从 T1 到 T2 画一条有向线，

1176
00:51:22,725 --> 00:51:27,820
表示在 T1 中的一些动作发生在 T2 中的动作之前，

1177
00:51:28,320 --> 00:51:30,755
这意味着 T2 最好不要做事情，

1178
00:51:30,755 --> 00:51:31,835
这是相反的，

1179
00:51:31,835 --> 00:51:34,400
因为现在我有一个矛盾的状态，

1180
00:51:34,400 --> 00:51:35,560
我将以此结束。

1181
00:51:36,460 --> 00:51:36,860
好的？

1182
00:51:37,460 --> 00:51:40,030
所以，串行调度是，调度是，

1183
00:51:40,050 --> 00:51:41,345
左侧的时间是，

1184
00:51:41,345 --> 00:51:43,420
数据库看到这些操作的顺序。

1185
00:51:43,920 --> 00:51:45,440
让我们来构建这张图，

1186
00:51:45,440 --> 00:51:47,110
我们将在下一节课中看到的是，

1187
00:51:47,460 --> 00:51:48,940
开始说的是，

1188
00:51:48,960 --> 00:51:51,785
第二件事将导致这个图完成，

1189
00:51:51,785 --> 00:51:52,445
它会停下来，

1190
00:51:52,445 --> 00:51:53,470
它不会让，

1191
00:51:53,640 --> 00:51:56,530
它不会让这件事执行，

1192
00:51:57,060 --> 00:51:58,100
下面的对 B 的写入，

1193
00:51:58,100 --> 00:52:00,250
因为它说，如果我允许这个写入发生，

1194
00:52:00,780 --> 00:52:02,060
这条弧线形成，

1195
00:52:02,140 --> 00:52:03,030
我就会有冲突，

1196
00:52:03,030 --> 00:52:03,890
这一行，

1197
00:52:03,910 --> 00:52:04,935
它将暂停它，

1198
00:52:04,935 --> 00:52:08,265
它将停止事务 T1 继续执行，

1199
00:52:08,265 --> 00:52:10,220
使用我们将在下一节课中讨论的技术。

1200
00:52:13,030 --> 00:52:13,350
是的。

1201
00:52:13,350 --> 00:52:16,680
它需要什么？

1202
00:52:18,800 --> 00:52:21,630
是的，然后它可能需要放弃一些东西或推迟一些东西，

1203
00:52:21,680 --> 00:52:23,280
所以我们会讨论这个，

1204
00:52:23,360 --> 00:52:25,405
所以有时它可能只会说，

1205
00:52:25,405 --> 00:52:26,550
你知道吗，我需要放弃，

1206
00:52:27,440 --> 00:52:28,710
我不能再继续了。

1207
00:52:29,640 --> 00:52:31,240
好的，就是这么简单。

1208
00:52:31,940 --> 00:52:33,935
我们将构建这个图，

1209
00:52:33,935 --> 00:52:36,395
现在我们有了这个漂亮的证明，它说，

1210
00:52:36,395 --> 00:52:40,420
我如何才能拥有正确的隔离性。

1211
00:52:41,860 --> 00:52:44,390
好的，这是三个事务，

1212
00:52:45,760 --> 00:52:48,650
只是想用一种稍微复杂一点的方式来说明这一点。

1213
00:52:50,530 --> 00:52:51,500
当我走下去的时候，

1214
00:52:51,520 --> 00:52:54,470
第一个冲突就是读写，

1215
00:52:54,520 --> 00:52:55,845
这里面还有其他的冲突，

1216
00:52:55,845 --> 00:52:58,280
这里有 T1 的 W(A) 到读取 A ，

1217
00:52:58,420 --> 00:53:00,830
我没有展示所有可能的冲突，

1218
00:53:01,000 --> 00:53:04,730
但是它们都会引出从 T1 到 T2 的弧线，

1219
00:53:06,040 --> 00:53:07,190
这只是一种[危险]，

1220
00:53:07,930 --> 00:53:09,870
然后还有其他的冲突，

1221
00:53:09,870 --> 00:53:11,570
但这只会重做同样的线，

1222
00:53:11,770 --> 00:53:13,820
你不必多次重新画这条线，

1223
00:53:14,020 --> 00:53:16,245
一条弧线就够了。

1224
00:53:16,245 --> 00:53:17,240
这就是这一切所显示的，

1225
00:53:17,530 --> 00:53:18,590
当你继续往下走，

1226
00:53:18,730 --> 00:53:22,100
我们看到另一个从 T2 到 T1 的冲突，

1227
00:53:25,420 --> 00:53:27,640
这就是这里所有的东西。

1228
00:53:28,570 --> 00:53:29,840
所以这基本上是在说，

1229
00:53:30,750 --> 00:53:32,110
在这个调度中，

1230
00:53:33,450 --> 00:53:37,120
尽管这三个事务之间存在大量交错，

1231
00:53:37,830 --> 00:53:39,490
你可以证明这个是正确的。

1232
00:53:40,890 --> 00:53:44,050
你可以猜猜正确的串行调度是什么，

1233
00:53:46,950 --> 00:53:47,740
看这张图。

1234
00:53:49,970 --> 00:53:52,350
使得，这将是图的顺序，

1235
00:53:52,670 --> 00:53:55,370
比如 T2 最先发生，

1236
00:53:56,600 --> 00:53:58,050
然后 T1 发生，

1237
00:53:58,850 --> 00:53:59,920
然后 T3 发生，

1238
00:53:59,920 --> 00:54:04,675
这就像这是它们被执行的顺序，

1239
00:54:04,675 --> 00:54:06,810
而我们一次只运行一个事务。

1240
00:54:08,310 --> 00:54:09,580
这就是整个想法，

1241
00:54:10,020 --> 00:54:11,870
现在，如果你明白为什么这张图是有意义的，

1242
00:54:11,870 --> 00:54:12,485
它是微不足道的，

1243
00:54:12,485 --> 00:54:14,315
但人们花了一小段时间才弄明白这一点，

1244
00:54:14,315 --> 00:54:15,340
它并不是那么微不足道，

1245
00:54:15,480 --> 00:54:17,500
这就是这些美丽的想法中的许多，

1246
00:54:17,550 --> 00:54:19,360
回想起来，它们看起来很简单。

1247
00:54:22,170 --> 00:54:24,640
所以，忘记我在幻灯片中对那个错误所说的一切，

1248
00:54:24,990 --> 00:54:26,030
如果你明白了，

1249
00:54:26,030 --> 00:54:27,850
你就会明白隔离性是如何工作的。

1250
00:54:39,790 --> 00:54:43,010
是的，我们将在那里讨论中止和其他类型的特殊处理，

1251
00:54:43,030 --> 00:54:44,270
但事实是，

1252
00:54:44,290 --> 00:54:45,510
即使在中止之前，

1253
00:54:45,510 --> 00:54:46,590
如果你开始看到环，

1254
00:54:46,590 --> 00:54:48,530
你知道你会陷入糟糕的境地，

1255
00:54:48,640 --> 00:54:49,700
所以你需要阻止它。

1256
00:54:52,960 --> 00:54:54,530
因为时间在发展，

1257
00:54:54,880 --> 00:54:56,960
我作为数据库事务管理者，

1258
00:54:57,670 --> 00:54:59,300
如果我在这个时间点上，

1259
00:54:59,470 --> 00:55:00,270
并且我被告知，

1260
00:55:00,270 --> 00:55:01,575
我是否应该接受 B 的这个读取，

1261
00:55:01,575 --> 00:55:02,570
我必须做出决定，

1262
00:55:03,040 --> 00:55:05,660
如果我是个悲观的事务管理系统，

1263
00:55:05,890 --> 00:55:07,400
悲观的隔离性管理，

1264
00:55:07,690 --> 00:55:10,935
我将不得不决定是否让这种情况发生，

1265
00:55:10,935 --> 00:55:12,615
如果我是乐观的，我会让它继续，

1266
00:55:12,615 --> 00:55:13,950
最终，我会弄明白，

1267
00:55:13,950 --> 00:55:16,550
这就是悲观和乐观的区别。

1268
00:55:21,760 --> 00:55:23,790
它在发生的时候被创造出来，

1269
00:55:23,840 --> 00:55:26,580
所以你可以想象这样的事情正在系统中发生，

1270
00:55:26,960 --> 00:55:28,800
[]步运行，

1271
00:55:29,510 --> 00:55:31,735
我们从 T1 开始，

1272
00:55:31,735 --> 00:55:34,105
然后读取 A 完成，写入 A 完成，

1273
00:55:34,105 --> 00:55:35,340
系统说我可以让你继续，

1274
00:55:35,840 --> 00:55:37,930
然后，当写入 A 到来，

1275
00:55:38,160 --> 00:55:40,810
系统会说，你知道吗，我需要在这个图表中画一条弧线，

1276
00:55:40,860 --> 00:55:42,230
所以，随着时间的推移，

1277
00:55:42,230 --> 00:55:43,595
这些弧线正在被完成，

1278
00:55:43,595 --> 00:55:48,010
读写被呈现给发展的系统。

1279
00:55:51,890 --> 00:55:55,500
这就是悲观的方法和乐观的区别，

1280
00:55:55,700 --> 00:55:56,880
悲观的会说，

1281
00:55:57,050 --> 00:55:59,250
当我第一次认为有问题时，我会阻止你，

1282
00:56:00,490 --> 00:56:02,450
我们将在下一节课上看到，

1283
00:56:02,800 --> 00:56:04,635
乐观的是，我让一切都过去，

1284
00:56:04,635 --> 00:56:06,330
但我知道如何把你带回一个安全的地方，

1285
00:56:06,330 --> 00:56:07,250
如果发生了糟糕的事情。

1286
00:56:10,490 --> 00:56:11,440
这不是乐观的，

1287
00:56:11,440 --> 00:56:12,100
它只是在说，

1288
00:56:12,100 --> 00:56:14,430
我如何才能检测到某件事是好的还是坏的，

1289
00:56:14,600 --> 00:56:15,540
但这就是机制。

1290
00:56:15,920 --> 00:56:16,320
是的。

1291
00:56:16,400 --> 00:56:22,630
如果是环的话，就不行了，

1292
00:56:22,630 --> 00:56:23,970
我怎么找到环，

1293
00:56:24,110 --> 00:56:27,240
我什么时候找到环是不同之处，

1294
00:56:27,260 --> 00:56:29,520
我是不是在环形成就尽快找到它，

1295
00:56:29,720 --> 00:56:32,460
或者，在我让在一切继续之后找到环。

1296
00:56:34,190 --> 00:56:36,540
所以，整个理论基本上就是说，

1297
00:56:36,680 --> 00:56:39,660
这是否等同于那个顺序。

1298
00:56:40,260 --> 00:56:43,940
这是另一个例子，

1299
00:56:44,080 --> 00:56:46,850
这就是我们进入这种新的串行化，

1300
00:56:47,320 --> 00:56:50,300
这里正在发生的事情，

1301
00:56:51,370 --> 00:56:52,520
这里正在发生的事情是，

1302
00:56:52,630 --> 00:56:55,550
A 拿出 10 美元，

1303
00:56:55,720 --> 00:57:00,590
有一个正在计算中的 sum 在这里打印出来，

1304
00:57:00,640 --> 00:57:03,650
当然，这个事务也有问题，

1305
00:57:03,970 --> 00:57:06,650
因为这导致从 T1 到 T2 的弧线，

1306
00:57:07,000 --> 00:57:08,510
然后你有这个事务，

1307
00:57:08,650 --> 00:57:10,400
所以这是不可串行化的，

1308
00:57:10,600 --> 00:57:11,480
但如果不是，

1309
00:57:11,920 --> 00:57:14,340
第二个事务做两个事务的 sum ，

1310
00:57:14,600 --> 00:57:17,020
如果其中的代码只是，

1311
00:57:17,020 --> 00:57:21,120
查找值帐户值大于 100 的事务的数量，

1312
00:57:21,500 --> 00:57:23,490
这是一个环的事实并不重要，

1313
00:57:23,810 --> 00:57:26,220
从第二个事务的语义来看，

1314
00:57:26,750 --> 00:57:27,670
在一个高级别的层次上，

1315
00:57:27,670 --> 00:57:30,030
这就是视图可串行化的含义。

1316
00:57:30,110 --> 00:57:33,000
如果你对正在发生的事情的语义有所了解，

1317
00:57:33,380 --> 00:57:36,960
你将会承认更多类型的调度，否则你将不会这样做。

1318
00:57:37,370 --> 00:57:38,005
正如我所说的，

1319
00:57:38,005 --> 00:57:40,045
这就是我想知道的这节课的全部内容，

1320
00:57:40,045 --> 00:57:41,820
如果你不明白，那也没关系。

1321
00:57:41,960 --> 00:57:42,660
随它去吧，

1322
00:57:42,800 --> 00:57:45,480
我们不会过多地谈论视图的可串行化，

1323
00:57:45,980 --> 00:57:48,685
它只是允许某些类型的环，

1324
00:57:48,685 --> 00:57:50,910
因为它说我认为应用程序是好的。

1325
00:57:51,570 --> 00:57:52,120
好的。

1326
00:57:52,620 --> 00:57:54,300
这里有一个对它的正式的定义，

1327
00:57:54,300 --> 00:57:57,225
如果你有兴趣从它允许的方面来看它，

1328
00:57:57,225 --> 00:58:02,330
它基本上允许比严格的串行调度允许的多的调度。

1329
00:58:03,080 --> 00:58:08,550
好的，所以冲突可串行化是我们想让你知道的主要事情。

1330
00:58:09,850 --> 00:58:11,330
好的，图画形式，

1331
00:58:12,040 --> 00:58:14,150
以下是所有可能的调度，

1332
00:58:14,230 --> 00:58:15,230
包括糟糕的调度，

1333
00:58:15,550 --> 00:58:16,880
那些我们不希望发生的。

1334
00:58:18,290 --> 00:58:21,430
抱歉，是的，串行调度是严格串行内容，

1335
00:58:21,430 --> 00:58:22,450
T1 在 T2 之前，

1336
00:58:22,450 --> 00:58:25,090
这是唯一允许冲突可串行化的事情，

1337
00:58:25,090 --> 00:58:27,210
如果我们允许更多的组合，

1338
00:58:27,590 --> 00:58:31,860
而视图可串行化是通过应用程序性能可能会有更多的东西。

1339
00:58:34,650 --> 00:58:36,665
这里还有更多的层次，

1340
00:58:36,665 --> 00:58:38,915
我们将在后面的课程中发现其中的一些，

1341
00:58:38,915 --> 00:58:41,050
在细节课中也会有更多的内容。

1342
00:58:42,340 --> 00:58:44,330
所以我们还有一个字母要讲，

1343
00:58:44,500 --> 00:58:46,305
那就是 D ，也就是持久性，

1344
00:58:46,305 --> 00:58:49,960
我们说了原子性、一致性、隔离性，

1345
00:58:50,130 --> 00:58:51,940
这是我们今天花的大部分时间，

1346
00:58:52,170 --> 00:58:53,590
最后一个是持久性，

1347
00:58:53,760 --> 00:58:55,090
这将会讲得非常快。

1348
00:58:55,720 --> 00:58:58,830
持久性，我们会有一个完整的课程讲它，

1349
00:58:58,910 --> 00:59:01,980
在从现在的第二节课上，

1350
00:59:02,420 --> 00:59:08,600
关于确保我们对系统所做的更改，

1351
00:59:09,160 --> 00:59:13,190
我们对 A B 和 C 之类的内容进行更改，

1352
00:59:13,540 --> 00:59:14,390
只是在内存中，

1353
00:59:15,010 --> 00:59:17,270
如果你更新列值或记录，

1354
00:59:17,470 --> 00:59:18,800
它位于缓冲池中，

1355
00:59:19,630 --> 00:59:22,670
但是如果你断电了，

1356
00:59:22,720 --> 00:59:25,370
内存是不稳定的，

1357
00:59:25,600 --> 00:59:27,225
这些更改从未到磁盘，

1358
00:59:27,225 --> 00:59:28,700
但你可能已经提交了该事务。

1359
00:59:29,670 --> 00:59:31,780
所以持久性是指，

1360
00:59:32,370 --> 00:59:35,180
如果数据库提交了事务，

1361
00:59:35,980 --> 00:59:38,715
顺便说一句，允许数据库使用缓冲池，

1362
00:59:38,715 --> 00:59:42,290
因为这是一种有效的方式来构建数据处理系统，

1363
00:59:42,940 --> 00:59:44,400
你不会希望每次访问磁盘，

1364
00:59:44,400 --> 00:59:45,330
你想要缓冲池，

1365
00:59:45,330 --> 00:59:50,090
因为访问缓冲池中的数据比访问磁盘上的数据要快得多。

1366
00:59:51,050 --> 00:59:53,485
但是如果数据库已经提交，

1367
00:59:53,485 --> 00:59:55,050
你需要确保，

1368
00:59:55,190 --> 00:59:56,550
如果出现电源故障，

1369
00:59:57,050 --> 00:59:59,545
你可以在数据库中获得正确的值。

1370
00:59:59,545 --> 01:00:00,900
所以，持久性会做这个，

1371
01:00:01,280 --> 01:00:04,260
通过确保提交发生时，

1372
01:00:04,970 --> 01:00:07,795
它将确保将某些内容写入磁盘，

1373
01:00:07,795 --> 01:00:11,940
它将尝试对磁盘执行非常少的[]写入，

1374
01:00:12,110 --> 01:00:14,460
以便提供这种持久性属性。

1375
01:00:15,950 --> 01:00:16,930
正如我说的，

1376
01:00:16,930 --> 01:00:18,780
在之后的两节课中，我们将讨论这个。

1377
01:00:19,610 --> 01:00:24,210
所以，这基本上就是 ACID 看起来的样子。

1378
01:00:24,720 --> 01:00:27,650
是的，我们可以在线下讨论这个，

1379
01:00:27,650 --> 01:00:30,160
答案是，可能会应用的原则，

1380
01:00:30,420 --> 01:00:33,520
就像我有易失性存储和非易失性存储，

1381
01:00:33,900 --> 01:00:37,480
我可以将这个持久性原则应用于其中任何一个系统。

1382
01:00:37,740 --> 01:00:39,950
是的，同样的原则也适用。

1383
01:00:39,950 --> 01:00:40,295
是的。

1384
01:00:40,295 --> 01:00:44,050
日志，抱歉。

1385
01:00:46,440 --> 01:00:48,005
是的，日志将保存在内存中，

1386
01:00:48,005 --> 01:00:49,720
从现在开始，我们将在两节课中讲到这个，

1387
01:00:49,890 --> 01:00:52,720
我们创建的日志记录也将保存在内存中，

1388
01:00:52,860 --> 01:00:54,110
但在适当的时候，

1389
01:00:54,110 --> 01:00:55,775
我们会将它们刷新到磁盘上，

1390
01:00:55,775 --> 01:00:57,640
以保证持久性。

1391
01:01:00,370 --> 01:01:01,305
我们将会谈过这个问题，

1392
01:01:01,305 --> 01:01:02,730
如果日志失败，会发生什么情况，

1393
01:01:02,730 --> 01:01:05,210
这就是从现在开始的两节课。

1394
01:01:05,350 --> 01:01:06,105
这是一节完整的课，

1395
01:01:06,105 --> 01:01:07,580
我可以给你十秒钟的回答，

1396
01:01:07,870 --> 01:01:09,135
十秒钟的答案是，

1397
01:01:09,135 --> 01:01:13,370
我们将确保绝对必须写入磁盘的内容被写入，

1398
01:01:13,720 --> 01:01:15,060
如果我们写错了东西，

1399
01:01:15,060 --> 01:01:17,330
我们会查看它的值，然后如果我们需要的话，撤销它。

1400
01:01:17,350 --> 01:01:19,635
我们将用我们写在磁盘上的东西做两件事中的一件，

1401
01:01:19,635 --> 01:01:23,595
要么重做操作，因为它与内存中的内容不一致，

1402
01:01:23,595 --> 01:01:26,750
要么撤销它，因为我们写了不应该写的东西。

1403
01:01:28,180 --> 01:01:31,070
所以，我们将对它们进行重做和撤消逻辑。

1404
01:01:32,400 --> 01:01:34,235
好的，这是总结。

1405
01:01:34,235 --> 01:01:38,380
并发控制和恢复是事务最重要的功能之一，

1406
01:01:39,000 --> 01:01:39,970
是非常重要的，

1407
01:01:40,800 --> 01:01:44,480
但这是数据库系统的一个陈旧的、定义的组件，

1408
01:01:44,480 --> 01:01:46,690
如果你回到数据库系统的早期，

1409
01:01:47,010 --> 01:01:49,750
这就是为什么它们开始在企业中被采用，

1410
01:01:50,070 --> 01:01:51,790
因为它们允许所有这些记录保存。

1411
01:01:52,270 --> 01:01:55,515
我需要五分钟来回顾一些事情，

1412
01:01:55,515 --> 01:01:57,800
但在此之前，我们已经谈过几次了，

1413
01:01:58,270 --> 01:02:02,630
对于事务，你还可以做更多的事情，

1414
01:02:03,220 --> 01:02:06,320
Google 发布了一篇突破性的论文，名为 Spanner ，

1415
01:02:06,580 --> 01:02:09,810
顺便说一句，在此之前，他们在许多部分都在做最终一致性工作，

1416
01:02:09,810 --> 01:02:13,220
他们意识到，哇，应用程序程序员不能完全做到这一点，

1417
01:02:13,420 --> 01:02:15,800
所以他们实际上构建了一个非常难的东西，

1418
01:02:16,260 --> 01:02:19,280
它是一个全球分布式系统，可以做事务，

1419
01:02:19,960 --> 01:02:24,730
事务可以是访问分布式数据库中的对象，

1420
01:02:25,140 --> 01:02:28,030
所以它可以访问伦敦的对象，访问美国的对象，

1421
01:02:28,470 --> 01:02:32,020
并将该事务作为一个事务提交到全球各地，

1422
01:02:32,520 --> 01:02:34,300
并快速高效地完成这一操作。

1423
01:02:34,580 --> 01:02:36,155
他们这样做的原因是，

1424
01:02:36,155 --> 01:02:38,380
如果他们保持最终一致性，

1425
01:02:38,460 --> 01:02:41,470
各种应用程序编程错误就会出现，

1426
01:02:41,580 --> 01:02:43,490
比如广告系统会报告错误的东西，

1427
01:02:43,490 --> 01:02:47,170
它会告诉同一个广告商，例如，在伦敦的宝洁公司，

1428
01:02:47,430 --> 01:02:49,030
这就是我们展示的印象，

1429
01:02:49,200 --> 01:02:51,550
而在美国同样的活动会显示一个不同的数字，

1430
01:02:51,750 --> 01:02:53,360
这两个人拿起电话说，

1431
01:02:53,360 --> 01:02:54,100
到底发生了什么，

1432
01:02:54,680 --> 01:02:56,200
我们到底展示了什么印象，

1433
01:02:56,250 --> 01:02:57,580
你想要准确的答案，

1434
01:02:57,900 --> 01:02:59,320
因为有人为它付钱，

1435
01:03:00,120 --> 01:03:02,410
这是他们去构建这个的主要原因之一。

1436
01:03:02,490 --> 01:03:03,550
这是一个美丽的系统，

1437
01:03:03,840 --> 01:03:05,260
需要原子钟，

1438
01:03:05,400 --> 01:03:07,960
你需要在数据中心之间进行卫星同步，

1439
01:03:08,370 --> 01:03:10,480
这样两个时钟才不会不同步，

1440
01:03:10,560 --> 01:03:16,090
CockroachDB 是由 Google 的工作人员创建的，

1441
01:03:16,140 --> 01:03:19,475
他们有一个不需要卫星时钟的版本，

1442
01:03:19,475 --> 01:03:20,770
但令人着迷的是，

1443
01:03:20,940 --> 01:03:22,960
仍然有很多新事物正在发生。

1444
01:03:24,140 --> 01:03:26,820
奖励环节，我在幻灯片中留下这个链接，如果你想要。

1445
01:03:26,870 --> 01:03:30,565
我们已经讨论了各种不同的模型和一致性级别，

1446
01:03:30,565 --> 01:03:31,440
但还有更多，

1447
01:03:31,670 --> 01:03:33,175
你可以玩弄那张图表。

1448
01:03:33,175 --> 01:03:36,445
但我想在项目 #3 上花几分钟时间，

1449
01:03:36,445 --> 01:03:37,920
它是关于查询执行的。

1450
01:03:38,560 --> 01:03:41,640
这个项目的概况是，

1451
01:03:42,140 --> 01:03:43,320
我们基本上有，

1452
01:03:45,200 --> 01:03:46,980
这些都是 Bustub 的不同组成部分，

1453
01:03:47,060 --> 01:03:49,140
随着时间的推移你逐渐了解和热爱，

1454
01:03:49,460 --> 01:03:53,850
项目 #3 与优化器和查询执行有关，

1455
01:03:54,080 --> 01:03:58,050
而即将到来的项目 #4 将是事务管理部分中的查询执行。

1456
01:03:58,640 --> 01:04:00,270
好的，那么项目 #3 是什么，

1457
01:04:00,590 --> 01:04:02,970
你将添加访问方法，

1458
01:04:03,020 --> 01:04:04,170
两种不同的访问方法，

1459
01:04:04,280 --> 01:04:05,880
顺序扫描和索引扫描，

1460
01:04:06,880 --> 01:04:10,280
你还将做插入、删除和更新，

1461
01:04:10,300 --> 01:04:12,735
这些是你要添加的运算符，

1462
01:04:12,735 --> 01:04:16,700
你将把它们添加为系统中的新运算符，

1463
01:04:17,480 --> 01:04:20,820
两种不同类型的 Join ，嵌套循环 Join 和哈希 Join ，

1464
01:04:21,320 --> 01:04:26,430
还有一些其他的窗口聚合函数， Limit Sort 和 Top-k 。

1465
01:04:27,010 --> 01:04:28,965
你还将接触到优化器，

1466
01:04:28,965 --> 01:04:31,040
所以 Bustub 中已经有了一个优化器，

1467
01:04:31,360 --> 01:04:34,130
用来转换查询，

1468
01:04:34,150 --> 01:04:36,470
如果查询同时具有 ORDER BY 和 LIMIT ，

1469
01:04:36,670 --> 01:04:40,400
你可以通过简单的转换，转换为 Top-k 查询。

1470
01:04:40,780 --> 01:04:44,060
所以，这将给你一个机会来查看优化器是如何工作的。

1471
01:04:44,870 --> 01:04:46,060
如果你看到嵌套的循环，

1472
01:04:46,060 --> 01:04:47,220
这通常不是一个好主意，

1473
01:04:47,450 --> 01:04:48,355
所以，在优化器中，

1474
01:04:48,355 --> 01:04:50,910
你将编写一个规则，将嵌套循环转换为哈希 Join ，

1475
01:04:51,950 --> 01:04:53,340
因为这通常要快得多。

1476
01:04:53,870 --> 01:04:55,990
同样，顺序扫描到索引扫描，

1477
01:04:55,990 --> 01:04:58,345
如果存在索引，请不要执行顺序扫描，

1478
01:04:58,345 --> 01:04:59,430
而是使用索引扫描。

1479
01:04:59,630 --> 01:05:00,100
这些就是，

1480
01:05:00,100 --> 01:05:01,765
把它想象成启发式的东西，

1481
01:05:01,765 --> 01:05:04,600
我们在优化的东西里谈到的，

1482
01:05:04,600 --> 01:05:07,500
不是基于成本的启发式，而是基于规则的。

1483
01:05:09,390 --> 01:05:13,805
排行榜将需要对优化器进行更深层次的更改，

1484
01:05:13,805 --> 01:05:16,390
所以，即使你有来自项目 #1 和项目 #2 的令人惊叹的代码，

1485
01:05:16,530 --> 01:05:19,630
你也肯定不会在排行榜上获得好的高的统计数据，

1486
01:05:19,860 --> 01:05:21,850
除非你添加新的优化规则，

1487
01:05:22,200 --> 01:05:24,760
这在项目中都有描述，

1488
01:05:24,810 --> 01:05:28,120
你将向窗口聚合和 top-k 添加规则。

1489
01:05:28,610 --> 01:05:31,750
小贴士，从简单的事情开始，

1490
01:05:31,750 --> 01:05:33,340
插入和顺序扫描，

1491
01:05:33,340 --> 01:05:34,470
这是最简单的事情，

1492
01:05:34,700 --> 01:05:35,400
先把它弄好，

1493
01:05:35,720 --> 01:05:39,210
在你用它做其他事情之前。

1494
01:05:39,470 --> 01:05:41,940
关键的事情是，

1495
01:05:42,830 --> 01:05:50,230
现在你可以真的在浏览器中运行 Bustub 了。

1496
01:05:50,880 --> 01:05:52,900
所以我要在这里结束了。

1497
01:05:53,700 --> 01:06:00,120
然后，不再需要 Powerpoint 了。

1498
01:06:00,800 --> 01:06:04,900
如果你现在去看 Bustub ，

1499
01:06:05,040 --> 01:06:09,870
你实际上可以在浏览器中运行 Bustub 。

1500
01:06:10,670 --> 01:06:12,300
让我找到这里的链接。

1501
01:06:13,500 --> 01:06:13,900
是的。

1502
01:06:15,360 --> 01:06:17,710
Chi ，他是一个很棒的程序员，

1503
01:06:18,220 --> 01:06:19,945
编写了这个版本，

1504
01:06:19,945 --> 01:06:22,320
它完全在浏览器中以 VASM 代码运行，

1505
01:06:22,880 --> 01:06:25,440
并且已经在其中加载了一些表，

1506
01:06:25,670 --> 01:06:27,145
你可以开始做一些事情，

1507
01:06:27,145 --> 01:06:32,070
比如 SELECT * FROM _mock_table_，

1508
01:06:32,450 --> 01:06:33,750
然后做这样的事情，

1509
01:06:33,770 --> 01:06:35,310
糟糕，我的分号在哪里，

1510
01:06:35,510 --> 01:06:36,970
你就可以开始运行东西了。

1511
01:06:36,970 --> 01:06:38,970
你可以使用它来测试你的代码是否工作，

1512
01:06:39,520 --> 01:06:41,005
我们的解决方案就在这之后。

1513
01:06:41,005 --> 01:06:41,340
是的。

1514
01:06:59,560 --> 01:07:01,220
是的，所以，

1515
01:07:02,280 --> 01:07:03,310
将这个作为参考，

1516
01:07:03,960 --> 01:07:07,090
不要使用大范围作为进行调试的方法，

1517
01:07:07,260 --> 01:07:08,080
编写你的测试，

1518
01:07:08,490 --> 01:07:10,810
否则，你在这个项目中不会做得很好。

1519
01:07:12,350 --> 01:07:13,560
所以希望这是一个有趣的项目，

1520
01:07:13,700 --> 01:07:14,755
从简单的事情开始，

1521
01:07:14,755 --> 01:07:15,720
这可能看起来很多，

1522
01:07:15,770 --> 01:07:16,735
从简单的事情开始，

1523
01:07:16,735 --> 01:07:18,930
你会惊讶于你开始快速完成事情。

1524
01:07:19,250 --> 01:07:22,410
好的，谢谢， DJ []，点击它。

