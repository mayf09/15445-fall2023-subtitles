1
00:00:31,750 --> 00:00:34,700
生活怎么样？

2
00:00:42,320 --> 00:00:45,875
我的意思是，是的，所有的 Wu-Tang Clan 都很年轻，

3
00:00:51,930 --> 00:00:54,640
这是一种[]， Wu-Tang 。

4
00:00:55,990 --> 00:00:58,010
今年的考试没有 Wu-Tang 的问题，

5
00:00:58,150 --> 00:00:59,085
之前的年份有，

6
00:00:59,085 --> 00:01:01,005
所以不要感觉你需要知道这些事情。

7
00:01:01,005 --> 00:01:03,830
好的，太棒了， 2PL 。

8
00:01:05,530 --> 00:01:07,130
你们有很多事要做，

9
00:01:07,540 --> 00:01:08,450
列表越来越长。

10
00:01:08,620 --> 00:01:11,930
所以项目 #1 在本周日午夜截止，

11
00:01:12,220 --> 00:01:16,160
再次，我们周六有特别的办公时间，是面对面的，

12
00:01:17,110 --> 00:01:18,135
他们在 Piazza 上宣布了这个消息，

13
00:01:18,135 --> 00:01:19,190
我想是在五楼，

14
00:01:20,230 --> 00:01:21,320
一个是给[]。

15
00:01:21,460 --> 00:01:25,640
家庭作业 #2 被推迟到了 10 月 4 日，星期三，

16
00:01:26,470 --> 00:01:29,660
确保截止日期和项目 #1 不同。

17
00:01:30,130 --> 00:01:31,640
作业 #3 将在本周发布，

18
00:01:31,690 --> 00:01:33,170
截止日期是四天以后。

19
00:01:33,810 --> 00:01:34,985
再次，这很糟糕，

20
00:01:34,985 --> 00:01:36,095
这么快就把它塞进去了，

21
00:01:36,095 --> 00:01:38,180
但是因为期中考试，

22
00:01:38,180 --> 00:01:43,570
它将涵盖家庭作业 #3 的内容，

23
00:01:43,770 --> 00:01:46,690
我们想把它带回给你们，并评分，

24
00:01:47,460 --> 00:01:49,910
在星期三的期中考试之前。

25
00:01:50,260 --> 00:01:54,480
所以期中考试将在 10 月 11 日在这里，

26
00:01:54,480 --> 00:01:56,840
它是星期三，在正常的上课时间，

27
00:01:57,730 --> 00:01:59,840
如果你需要住宿，请给我们发邮件，

28
00:01:59,860 --> 00:02:04,245
这样我们就可以开始组织和照顾后勤，

29
00:02:04,245 --> 00:02:05,000
不要贴在 Piazza 上。

30
00:02:08,860 --> 00:02:10,130
我们现在正试着把作业 #3 放出来，

31
00:02:10,660 --> 00:02:11,610
今天应该就能出来了，

32
00:02:11,610 --> 00:02:12,500
我不知道今天会不会放出。

33
00:02:13,000 --> 00:02:14,120
是的，这就是计划，

34
00:02:14,710 --> 00:02:16,260
但问题是，它并不包括，

35
00:02:16,260 --> 00:02:18,255
它不包括排序和 Join ，

36
00:02:18,255 --> 00:02:19,400
我将在下周介绍。

37
00:02:21,660 --> 00:02:23,500
对这些东西有什么问题吗？

38
00:02:24,720 --> 00:02:25,120
是的。

39
00:02:30,450 --> 00:02:33,940
现在网站上的任何内容都是当前的计划，是的。

40
00:02:34,970 --> 00:02:35,370
是的。

41
00:02:41,580 --> 00:02:42,640
在秋假结束时，

42
00:02:43,290 --> 00:02:45,880
我们会仔细检查这个，

43
00:02:46,140 --> 00:02:47,050
我以为我们把它移走了，

44
00:02:47,070 --> 00:02:49,360
这样我们就不用在秋假做了，

45
00:02:49,620 --> 00:02:50,500
我们会处理好的。

46
00:02:51,650 --> 00:02:52,260
还有其他问题吗？

47
00:02:55,420 --> 00:02:56,120
好的，酷。

48
00:02:57,140 --> 00:02:57,870
好的，那么，

49
00:02:58,680 --> 00:03:01,395
最后两节课，我们讨论了数据结构，

50
00:03:01,395 --> 00:03:02,390
我们讨论了哈希表，

51
00:03:02,410 --> 00:03:03,650
然后我们讨论了 B+ 树，

52
00:03:03,970 --> 00:03:07,040
我之前说过，

53
00:03:07,210 --> 00:03:09,705
在开始讨论哈希表和 B+ 树时，

54
00:03:09,705 --> 00:03:13,670
为了简化讨论，

55
00:03:13,720 --> 00:03:17,730
以及对这些数据结构和算法的解释，

56
00:03:17,730 --> 00:03:21,140
那些用于操作它们或使用它们的，

57
00:03:21,670 --> 00:03:23,120
我们假设它是单线程的，

58
00:03:23,740 --> 00:03:25,400
因为这只会让你的生活更轻松，

59
00:03:25,900 --> 00:03:28,490
但是当然，在任何现代系统中，

60
00:03:29,140 --> 00:03:31,100
在今天的硬件中，

61
00:03:31,480 --> 00:03:34,820
你需要支持多个线程或多个 worker 同时运行，

62
00:03:35,170 --> 00:03:36,440
同样，我将尝试使用 worker 一词，

63
00:03:36,580 --> 00:03:38,330
因为它可以表示线程或进程，

64
00:03:38,740 --> 00:03:40,550
Postgres 不是多线程，而是多进程，

65
00:03:41,080 --> 00:03:42,810
大多数现代系统都是多线程的，

66
00:03:42,810 --> 00:03:43,730
但理念是一样的。

67
00:03:44,140 --> 00:03:48,345
不过，我们还是希望能够让多个 worker 同时运行，

68
00:03:48,345 --> 00:03:49,910
能够访问这些数据结构，

69
00:03:50,710 --> 00:03:53,390
这样，如果其中一个必须停顿，

70
00:03:53,530 --> 00:03:54,885
因为它们要访问磁盘，

71
00:03:54,885 --> 00:03:57,060
我们可以让其他 worker 同时运行，

72
00:03:57,060 --> 00:03:59,290
并做一些有用的事情。

73
00:03:59,820 --> 00:04:01,325
系统将看起来非常迟钝，

74
00:04:01,325 --> 00:04:02,650
如果你只有一个 worker ，

75
00:04:03,240 --> 00:04:04,420
再次，假设它是一个线程，

76
00:04:04,620 --> 00:04:07,540
然后我将运行一些查询，

77
00:04:07,680 --> 00:04:09,590
然后当我必须去我的页表时，

78
00:04:09,590 --> 00:04:10,660
我不需要的东西是，

79
00:04:10,830 --> 00:04:11,980
我需要的页面不在那里，

80
00:04:12,120 --> 00:04:12,815
我必须停顿，

81
00:04:12,815 --> 00:04:14,050
因为我必须去磁盘上获取它。

82
00:04:14,640 --> 00:04:16,230
当我们停滞不前时，

83
00:04:16,230 --> 00:04:17,385
CPU 基本上也停滞不前了，

84
00:04:17,385 --> 00:04:19,580
我们可以让其他线程，其他 worker 做有用的事情。

85
00:04:20,020 --> 00:04:22,440
这就是我们今天要讨论的目标，

86
00:04:22,440 --> 00:04:25,640
就是我们如何真正使这些数据结构线程安全。

87
00:04:26,590 --> 00:04:27,770
所以我要说的是，

88
00:04:27,940 --> 00:04:30,050
这就是大多数系统将会实现的，

89
00:04:30,520 --> 00:04:33,500
大多数系统都会尝试利用多线程，

90
00:04:34,450 --> 00:04:36,555
有一种[分类]系统，

91
00:04:36,555 --> 00:04:38,720
不会做我们今天所说的任何事情，

92
00:04:39,490 --> 00:04:41,000
最著名的是 Redis ，

93
00:04:41,260 --> 00:04:43,250
它是一个单进程、单线程，

94
00:04:43,510 --> 00:04:45,350
所以我们今天要讨论的所有锁的东西，

95
00:04:45,400 --> 00:04:46,310
他们都不需要做，

96
00:04:47,020 --> 00:04:49,170
因为它们不知道没有其他线程同时运行。

97
00:04:50,390 --> 00:04:51,990
还会有其他系统，它们有，

98
00:04:53,060 --> 00:04:54,310
它们仍然是多线程的，

99
00:04:54,310 --> 00:04:56,940
但它们可能只有一个写线程，

100
00:04:56,960 --> 00:04:58,945
但是有多个读线程同时运行，

101
00:04:58,945 --> 00:05:00,240
这简化了很多事情，

102
00:05:00,470 --> 00:05:03,180
但你仍然需要我们今天要讨论的锁保护。

103
00:05:06,300 --> 00:05:08,830
所以，我们将使用的东西，

104
00:05:08,880 --> 00:05:14,170
强制线程或 worker 以特定方式运行，

105
00:05:14,730 --> 00:05:18,790
这样我们最终就不会出现损坏的数据和无效的数据结构，

106
00:05:19,200 --> 00:05:21,040
将被称为并发控制协议。

107
00:05:21,950 --> 00:05:23,140
再次，在今天的课上，

108
00:05:23,140 --> 00:05:24,900
我们将看到我们如何为 worker 做这件事，

109
00:05:25,550 --> 00:05:26,290
期中考试结束后，

110
00:05:26,290 --> 00:05:30,300
我们将讨论如何使用并发控制来协调事务。

111
00:05:31,770 --> 00:05:32,840
所以你可以这样想，

112
00:05:32,840 --> 00:05:35,560
这种并发控制协议就像系统的交通警察，

113
00:05:35,970 --> 00:05:38,950
允许告诉不同的 worker ，

114
00:05:39,390 --> 00:05:43,670
谁被允许在给定的时间做什么。

115
00:05:44,200 --> 00:05:44,865
我们的想法是，

116
00:05:44,865 --> 00:05:47,130
它们将在某个共享对象或某个临界区上操作，

117
00:05:47,130 --> 00:05:49,610
我们不想让它们相互干扰并造成问题。

118
00:05:50,760 --> 00:05:55,280
你可能会遇到的两种问题是逻辑正确性和物理正确性，

119
00:05:55,280 --> 00:05:58,150
我想我上周也提到过这个。

120
00:05:58,500 --> 00:06:00,580
所以逻辑正确性的想法是，

121
00:06:01,110 --> 00:06:04,235
如果我把一个键插入到我的 B+ 树中，

122
00:06:04,235 --> 00:06:05,260
我插入键 5 ，

123
00:06:05,820 --> 00:06:08,050
然后如果我回来，试着查找键 5 ，

124
00:06:08,340 --> 00:06:09,340
我应该会看到它。

125
00:06:10,160 --> 00:06:11,280
好的，我说的另一个例子是，

126
00:06:11,960 --> 00:06:13,200
如果我删除键 5 ，

127
00:06:13,490 --> 00:06:14,890
然后我回来尝试查找键 5 ，

128
00:06:14,890 --> 00:06:16,750
我应该看不到它。

129
00:06:16,750 --> 00:06:17,830
所以，在逻辑层面上，

130
00:06:17,830 --> 00:06:19,135
我们希望确保，

131
00:06:19,135 --> 00:06:21,750
我们看到的是我们应该在数据结构中看到的东西。

132
00:06:22,590 --> 00:06:25,750
我们在今天的课程中关心的是物理正确性，

133
00:06:26,040 --> 00:06:28,030
这意味着我们如何确保，

134
00:06:28,530 --> 00:06:32,140
如果我们遍历哈希表或遍历 B+ 树，

135
00:06:32,460 --> 00:06:34,295
在某些点上，我们必须跟随指针，

136
00:06:34,295 --> 00:06:35,180
比如页面 ID ，

137
00:06:35,180 --> 00:06:36,130
将我们带到其他地方，

138
00:06:36,390 --> 00:06:38,195
那个页面 ID 是正确的，

139
00:06:38,195 --> 00:06:42,490
比如它不会把我们带到一个有一堆垃圾的表页。

140
00:06:43,890 --> 00:06:45,790
因为如果跟随一个页面，

141
00:06:45,930 --> 00:06:49,300
并开始查看这些看起来并不像你希望看到的数据，

142
00:06:49,590 --> 00:06:50,570
那样会出现段错误，

143
00:06:50,570 --> 00:06:52,235
因为你要尝试读取一些过去的缓冲区，

144
00:06:52,235 --> 00:06:53,990
或者东西会崩溃，

145
00:06:53,990 --> 00:06:54,790
或者获得损坏的数据。

146
00:06:55,660 --> 00:06:57,980
所以再次，逻辑正确性，我们会在期中考试之后担心，

147
00:06:58,060 --> 00:06:59,780
今天的课程是关于物理正确性的。

148
00:07:01,490 --> 00:07:02,520
所以，我首先想要介绍，

149
00:07:03,380 --> 00:07:06,570
快速介绍一下什么是 latch ，

150
00:07:06,590 --> 00:07:09,060
以及如何在我们的数据库系统中实现它们。

151
00:07:09,380 --> 00:07:10,620
再次，这里的要点是，

152
00:07:11,660 --> 00:07:13,740
理想情况下，我们不想依赖操作系统，

153
00:07:14,390 --> 00:07:15,780
在 latch 方面提供给我们的东西。

154
00:07:16,310 --> 00:07:18,270
然后我们将看到一个简单的例子，

155
00:07:18,470 --> 00:07:20,250
如何进行哈希表 latch ，

156
00:07:20,570 --> 00:07:22,890
我们大部分时间都在进行 B+ 树 latch ，

157
00:07:23,060 --> 00:07:26,490
我们将看到一个基本版本和一个优化版本，

158
00:07:26,900 --> 00:07:30,330
然后我们将以讨论如何处理叶子节点扫描结束。

159
00:07:31,290 --> 00:07:31,690
好的？

160
00:07:34,670 --> 00:07:36,460
好的，我想我之前展示了这张幻灯片，

161
00:07:36,460 --> 00:07:37,980
我想再次重温一下，

162
00:07:39,260 --> 00:07:41,700
lock 和 latch 之间的[]。

163
00:07:41,990 --> 00:07:44,820
再说一次，如果你来自操作系统世界或分布式世界，

164
00:07:45,080 --> 00:07:47,310
他们可能是指，

165
00:07:47,900 --> 00:07:50,420
当我说 latch 时，他们可能会认为是 lock 。

166
00:07:50,420 --> 00:07:51,010
但是在数据库中，

167
00:07:51,120 --> 00:07:54,970
这是我们在这门课中最关心的，

168
00:07:55,140 --> 00:07:56,075
所以我们需要确保，

169
00:07:56,075 --> 00:07:57,020
我们理解我们在说什么，

170
00:07:57,020 --> 00:07:58,300
当我们说到 lock 与 latch 时。

171
00:07:59,330 --> 00:08:03,235
所以 lock 是一个高级的保护原语，

172
00:08:03,235 --> 00:08:07,560
它允许我们保护数据库的逻辑内容，

173
00:08:08,120 --> 00:08:12,010
比如一个 tuple ，一个数据库，一个表，

174
00:08:12,690 --> 00:08:13,900
还有，

175
00:08:14,990 --> 00:08:17,190
当我们获得这些 lock 中的一个时，

176
00:08:17,420 --> 00:08:21,330
事务将在该事务的持续时间内持有这个 lock ，

177
00:08:22,300 --> 00:08:23,200
这并不总是正确的，

178
00:08:23,200 --> 00:08:25,380
我们将看到可以提前释放锁的示例，

179
00:08:25,880 --> 00:08:27,000
但出于我们今天的目的，

180
00:08:27,020 --> 00:08:28,020
我们假设情况就是这样。

181
00:08:29,050 --> 00:08:33,410
然后在我们的并发协议中会有一些更高级别的机制，

182
00:08:33,640 --> 00:08:36,200
来确保我们不会有任何死锁，

183
00:08:36,800 --> 00:08:38,380
然后，如果真的出现死锁，

184
00:08:38,820 --> 00:08:42,010
那么数据库将具有一种机制，

185
00:08:42,090 --> 00:08:45,040
能够回滚事务所做的更改，

186
00:08:45,210 --> 00:08:47,795
使其看起来就像没有进行任何更改，

187
00:08:47,795 --> 00:08:49,360
所以我们没有任何部分更新。

188
00:08:51,310 --> 00:08:52,635
今天我们关注的是 latch ，

189
00:08:52,635 --> 00:08:55,035
所以 latch 是低级原语，

190
00:08:55,035 --> 00:08:58,130
我们用来保护我们的数据结构中的临界区，

191
00:08:58,630 --> 00:09:01,370
从一个 worker 到另一个 worker 。

192
00:09:02,170 --> 00:09:06,500
所以，我们将持有 latch 的生命周期将非常短，

193
00:09:06,850 --> 00:09:08,325
比如，考虑一个临界区，

194
00:09:08,325 --> 00:09:10,130
我在页面上放一个 latch ，

195
00:09:10,360 --> 00:09:11,130
做一些修改，

196
00:09:11,130 --> 00:09:12,410
然后立即释放那个 latch 。

197
00:09:13,930 --> 00:09:17,385
因为这将是非常简单的，

198
00:09:17,385 --> 00:09:20,750
我们最大限度地减少了为这些 latch 所做的记账的数量，

199
00:09:21,130 --> 00:09:22,820
我们不想拥有，

200
00:09:22,960 --> 00:09:25,880
数据库系统不会自动为我们回滚任何更改，

201
00:09:26,540 --> 00:09:27,665
我们不会避免死锁，

202
00:09:27,665 --> 00:09:29,200
我们不会进行任何更改，

203
00:09:29,250 --> 00:09:30,550
除非我们获得了某个东西的 latch ，

204
00:09:31,310 --> 00:09:32,700
这样我们就不必回滚，

205
00:09:32,810 --> 00:09:34,180
我们将有最小限度的协调，

206
00:09:34,180 --> 00:09:37,050
在同时运行的不同 worker 之间。

207
00:09:38,080 --> 00:09:39,675
而在锁的情况下，

208
00:09:39,675 --> 00:09:40,605
我跳到了前面，

209
00:09:40,605 --> 00:09:43,310
但是会有一个表，在内部被称为锁表，

210
00:09:43,570 --> 00:09:44,445
你去看看里面，

211
00:09:44,445 --> 00:09:47,150
你可以看到对于不同的对象谁持有锁，

212
00:09:47,590 --> 00:09:49,455
在 latch 中，我们不想维护这些，

213
00:09:49,455 --> 00:09:50,330
因为这太昂贵了，

214
00:09:51,040 --> 00:09:52,650
相对于我们希望的工作量，

215
00:09:52,650 --> 00:09:54,410
在数据结构中的临界区中。

216
00:09:56,720 --> 00:09:58,495
所以有这张表，

217
00:09:58,495 --> 00:10:00,805
来自上一次我推荐的书，

218
00:10:00,805 --> 00:10:02,550
来自这个人的 B 树书，

219
00:10:03,560 --> 00:10:06,420
他展示了锁和 latch 之间的变化，

220
00:10:06,650 --> 00:10:08,640
看这个表的方法是，

221
00:10:08,720 --> 00:10:10,720
在一个列中，向下看，

222
00:10:10,720 --> 00:10:12,925
你知道它在保护什么，

223
00:10:12,925 --> 00:10:13,690
如何保护它，

224
00:10:13,690 --> 00:10:15,360
以及保护东西的不同方法。

225
00:10:15,650 --> 00:10:16,225
例如，

226
00:10:16,225 --> 00:10:18,300
一个锁将事务彼此分开，

227
00:10:19,010 --> 00:10:21,370
它将保护逻辑数据库内容，

228
00:10:21,370 --> 00:10:24,510
页面，抱歉， tuple ，表，数据库,

229
00:10:25,020 --> 00:10:27,290
我们可以在整个事务期间持有它们，

230
00:10:28,090 --> 00:10:29,445
我们将在稍后讨论模式，

231
00:10:29,445 --> 00:10:32,000
我们可以在不同的模式下给对象加锁，

232
00:10:32,230 --> 00:10:35,325
比如独占、共享、意图、更新，

233
00:10:35,325 --> 00:10:36,200
我们稍后将到达那里，

234
00:10:36,730 --> 00:10:40,640
数据库系统提供死锁检测或死锁预防机制，

235
00:10:41,240 --> 00:10:42,550
内置以避免这些问题，

236
00:10:43,170 --> 00:10:45,070
这些都是实现这个的机制。

237
00:10:45,300 --> 00:10:47,810
然后我们要跟踪的什么锁被持有的信息，

238
00:10:47,810 --> 00:10:52,180
被保存在锁管理器中，一个集中的数据结构。

239
00:10:53,630 --> 00:10:55,950
今天，我们专注于 latch ，

240
00:10:56,120 --> 00:10:58,320
所以 latch 将保护 worker 免受彼此的干扰，

241
00:10:58,670 --> 00:11:00,570
这将仅在内存数据结构中使用，

242
00:11:01,250 --> 00:11:04,380
所以这是字面上的， B+ 树在内存中，

243
00:11:04,760 --> 00:11:10,450
但是，一旦 B+ 树中的一个页面刷新到磁盘中，

244
00:11:10,450 --> 00:11:12,625
我就不会持有那个东西的 latch ，

245
00:11:12,625 --> 00:11:13,495
当它到磁盘上时，

246
00:11:13,495 --> 00:11:14,580
因为这是没有意义的。

247
00:11:15,970 --> 00:11:17,240
它是在保护临界区，

248
00:11:17,590 --> 00:11:18,795
只有两种模式，

249
00:11:18,795 --> 00:11:20,180
我们可以持有 latch 在读写中，

250
00:11:21,430 --> 00:11:24,650
我们处理死锁的方法是通过编码准则，

251
00:11:24,940 --> 00:11:26,300
我们作为系统开发人员，

252
00:11:26,350 --> 00:11:28,430
必须编写良好的代码来确保没有死锁。

253
00:11:28,920 --> 00:11:29,970
说起来容易做起来难，

254
00:11:29,970 --> 00:11:33,465
但不会有什么系统的其他部分，

255
00:11:33,465 --> 00:11:34,490
会帮助我们摆脱困境。

256
00:11:35,480 --> 00:11:38,410
我们将保留有关这些 latch 的信息，

257
00:11:38,410 --> 00:11:40,710
实际上嵌入在数据结构本身中，

258
00:11:41,440 --> 00:11:43,770
所以不会有一个集中的东西。

259
00:11:45,180 --> 00:11:46,115
再次，这会更有意义，

260
00:11:46,115 --> 00:11:48,310
当我们开始讨论不同的数据结构类型时，

261
00:11:48,810 --> 00:11:49,715
关于锁的内容，

262
00:11:49,715 --> 00:11:51,880
我们将在期中考试后的第 15 节课讨论。

263
00:11:55,150 --> 00:11:57,350
所以我们的 latch 只有两种模式，

264
00:11:57,880 --> 00:11:59,870
它可以是读模式或写模式。

265
00:12:00,040 --> 00:12:02,570
所以，读模式，在交替操作中，

266
00:12:02,620 --> 00:12:07,200
你可以让多个 worker 同时在读模式下获取 latch ，

267
00:12:07,200 --> 00:12:08,510
因为，无论它们正在做什么，

268
00:12:08,530 --> 00:12:12,945
都不会破坏任何数据结构，

269
00:12:12,945 --> 00:12:15,290
引起冲突。

270
00:12:16,520 --> 00:12:19,680
如果两个 worker 需要读取同一个页面，

271
00:12:19,910 --> 00:12:21,300
我可以在读取模式下进行，

272
00:12:22,020 --> 00:12:23,730
它们没有做任何写入，

273
00:12:23,730 --> 00:12:24,650
它不会破坏任何东西，

274
00:12:24,850 --> 00:12:27,500
这样我就可以继续，让它们同时运行。

275
00:12:28,730 --> 00:12:30,310
写模式或独占模式是，

276
00:12:30,310 --> 00:12:35,250
当你知道一个线程想要访问对象并对其进行更改时，

277
00:12:35,510 --> 00:12:40,290
我不希望任何其他线程同时运行相同的线程来操作我的对象，

278
00:12:40,880 --> 00:12:45,030
所以，只有一个 worker 可以将 latch 保持在写模式下，

279
00:12:45,080 --> 00:12:48,080
这会阻止其他所有线程进入。

280
00:12:48,610 --> 00:12:50,990
一个非常简单的兼容性矩阵将看起来像这样。

281
00:12:51,130 --> 00:12:52,640
如果我有一个读模式，

282
00:12:52,720 --> 00:12:53,870
如果我有一个处于读模式的 latch ，

283
00:12:53,890 --> 00:12:55,580
如果有人想要在读模式下获得一个 latch ，

284
00:12:55,780 --> 00:12:56,960
我可以这样做，这是允许的，

285
00:12:57,130 --> 00:12:58,460
但是任何其他组合，

286
00:12:58,540 --> 00:13:01,280
如果至少有一个 latch 将其保持在写模式，

287
00:13:01,330 --> 00:13:02,780
或希望使其进入写模式，

288
00:13:03,340 --> 00:13:04,460
我必须拒绝这个。

289
00:13:06,540 --> 00:13:09,280
再次，回到我之前所说的编码规则，

290
00:13:09,690 --> 00:13:12,680
最愚蠢的事情就是让每一个 latch 在写模式，

291
00:13:12,680 --> 00:13:13,870
即使你只会读取它，

292
00:13:14,040 --> 00:13:15,580
它将保护你的所有数据结构，

293
00:13:15,750 --> 00:13:20,050
但是，基本上会被降级到单线程系统，

294
00:13:20,790 --> 00:13:23,110
同样，如果我在读模式下使用 latch ，

295
00:13:23,190 --> 00:13:25,720
但我开始对它所保护的东西进行更改，

296
00:13:25,920 --> 00:13:27,970
那就是我们的错，这是程序员的错，

297
00:13:28,170 --> 00:13:29,710
然后系统就会崩溃，这是我们的责任。

298
00:13:33,530 --> 00:13:34,350
而这里没有任何，

299
00:13:36,080 --> 00:13:38,970
如果不进入可验证的语言，

300
00:13:39,290 --> 00:13:42,310
在 C++ 或 Rust 中没有任何机制，

301
00:13:42,310 --> 00:13:44,800
可以保护我们免受这些事情的影响，

302
00:13:46,010 --> 00:13:47,670
因为编译器无法知道。

303
00:13:50,650 --> 00:13:52,260
所以，让我们来看看你想要如何实现 latch 。

304
00:13:53,380 --> 00:13:57,760
所以，理想情况下，我们需要一个内存占用较小的 latch ，

305
00:13:57,760 --> 00:14:01,345
因为我们不想为 latch 存储大量附加元数据，

306
00:14:01,345 --> 00:14:03,900
因为我们希望这些元数据嵌入到数据结构本身中，

307
00:14:05,390 --> 00:14:06,810
理想情况下，我们希望它成为，

308
00:14:07,740 --> 00:14:09,320
当系统中没有争用时，

309
00:14:09,430 --> 00:14:12,860
意味着没有两个线程或 worker 试图同时获取 latch ，

310
00:14:13,300 --> 00:14:16,280
我们希望以最小的开销尽可能快地运行，

311
00:14:16,660 --> 00:14:18,380
我拿到 latch ，马上做我的事。

312
00:14:19,410 --> 00:14:20,980
如果我们必须，

313
00:14:21,300 --> 00:14:22,570
我们不能获取我们需要的 latch ，

314
00:14:22,890 --> 00:14:24,260
然后我们必须决定，

315
00:14:24,260 --> 00:14:25,595
我们应该等待多长时间，

316
00:14:25,595 --> 00:14:26,500
以及我们想要如何等待，

317
00:14:27,400 --> 00:14:30,020
我们将看到我们想要如何做到这个的不同场景。

318
00:14:32,390 --> 00:14:38,880
在理想情况下，我们也不希望每个 latch 都有一堆元数据，

319
00:14:39,170 --> 00:14:40,740
关于谁在等待这个 latch ，

320
00:14:41,060 --> 00:14:44,800
因为这基本上是每一个 latch 的提示，

321
00:14:44,800 --> 00:14:45,670
你可以包含在你的数据结构中，

322
00:14:45,670 --> 00:14:48,690
比如有一棵巨大的 B+ 树，有十亿个条目，

323
00:14:49,190 --> 00:14:50,860
你要在里面放多少页，

324
00:14:50,860 --> 00:14:55,350
其中每一个都有自己的优先队列。

325
00:14:56,580 --> 00:14:58,850
所以，再次，来自数据库世界，

326
00:14:58,850 --> 00:14:59,860
我们说我们不，

327
00:15:00,030 --> 00:15:01,690
我们不想依赖操作系统来做任何这些事情，

328
00:15:02,100 --> 00:15:03,340
但操作系统人员表示，

329
00:15:03,480 --> 00:15:04,955
数据库系统不知道他们在做什么，

330
00:15:04,955 --> 00:15:06,640
他们不应该实现自己的 latch ，

331
00:15:07,170 --> 00:15:09,335
你可以在 Linux 邮件列表中看到这个，

332
00:15:09,335 --> 00:15:12,680
所以这里有一个来自 Linus 的帖子说，

333
00:15:12,680 --> 00:15:17,225
哦，是的，你不应该写你自己的 latch 东西，

334
00:15:17,225 --> 00:15:18,005
它基本上是这样说的，

335
00:15:18,005 --> 00:15:19,160
比如你不应该使用自旋锁，

336
00:15:19,160 --> 00:15:20,410
我会在稍后解释，

337
00:15:20,490 --> 00:15:21,880
在用户空间，这就是我们，

338
00:15:21,990 --> 00:15:23,530
数据库系统运行在用户空间，

339
00:15:24,050 --> 00:15:26,215
说你不应该使用自旋锁，让自己自旋，

340
00:15:26,215 --> 00:15:26,920
除非你知道你在做什么，

341
00:15:26,920 --> 00:15:29,010
而且你做的变更是[底层]的。

342
00:15:30,395 --> 00:15:32,770
他错了，尽管他是 Linus 。

343
00:15:34,480 --> 00:15:37,080
好的，我将介绍三个基本实现，

344
00:15:37,790 --> 00:15:39,720
关于如何实现 latch 。

345
00:15:39,920 --> 00:15:41,830
还有更先进的，

346
00:15:41,830 --> 00:15:43,350
比如 Apple 的 ParkingLot ，

347
00:15:43,370 --> 00:15:45,180
这可能是目前使用的最好的一个，

348
00:15:45,740 --> 00:15:47,250
然后有 MCS 锁，

349
00:15:48,020 --> 00:15:49,530
它是队列的东西，

350
00:15:50,660 --> 00:15:52,090
我们将在高级课程中讨论，

351
00:15:52,090 --> 00:15:52,960
但就我们这里的目的而言，

352
00:15:52,960 --> 00:15:53,815
我们不需要知道这个，

353
00:15:53,815 --> 00:15:57,600
但我们需要了解 latch 实际做什么的基本实现，

354
00:15:57,860 --> 00:15:59,910
当你开始将它们分散在代码中时，

355
00:16:00,050 --> 00:16:01,710
你了解了它们的后果。

356
00:16:06,580 --> 00:16:07,640
你是说 pthread mutex ，

357
00:16:07,960 --> 00:16:09,210
我们很快就会讲到这个，是的。

358
00:16:09,210 --> 00:16:09,830
她的问题是，

359
00:16:09,910 --> 00:16:11,150
C++ mutex 有什么问题。

360
00:16:11,800 --> 00:16:13,215
所以，如果在 C++ 中调用 mutex ，

361
00:16:13,215 --> 00:16:13,940
你实际上得到了什么？

362
00:16:18,400 --> 00:16:20,210
是的，但是谁实现了那个？

363
00:16:21,700 --> 00:16:24,230
Pthread ，但是 pthread 是如何工作的？

364
00:16:25,840 --> 00:16:26,990
再多几张幻灯片，好的。

365
00:16:33,670 --> 00:16:36,080
好的，所以，也许这就是那个幻灯片。

366
00:16:36,310 --> 00:16:37,850
好的，所以最基本的，

367
00:16:38,680 --> 00:16:40,275
回来一下，这是数据库世界，

368
00:16:40,275 --> 00:16:41,390
下一个我们再讨论操作系统的。

369
00:16:41,710 --> 00:16:45,405
所以你实现的最基本的 latch 是，

370
00:16:45,405 --> 00:16:49,110
调用 test-and-set 自旋锁，

371
00:16:49,110 --> 00:16:49,590
抱歉，自旋锁，

372
00:16:49,590 --> 00:16:51,830
我意识到我调用的是自旋锁，其实应该是自旋 latch 。

373
00:16:53,400 --> 00:16:55,485
但这是实现这一点最简单的方法，

374
00:16:55,485 --> 00:16:59,450
因为它实际上是一个 64 位的内存地址，

375
00:16:59,920 --> 00:17:03,020
你只需要做原子比较和交换，

376
00:17:03,130 --> 00:17:04,320
看看你是否可以设置它，

377
00:17:04,320 --> 00:17:05,190
如果你不能设置它，

378
00:17:05,190 --> 00:17:07,250
那么你就旋转，一直试着一遍又一遍地设置它，

379
00:17:07,330 --> 00:17:09,140
代码看起来像这样，

380
00:17:09,460 --> 00:17:11,540
我声明一个原子布尔型，

381
00:17:11,650 --> 00:17:15,050
这只是一个声明原子的东西的语法糖，

382
00:17:15,340 --> 00:17:17,720
然后现在我有了这个，我的 latch 在这里，

383
00:17:17,770 --> 00:17:18,825
我调用 test-and-set ，

384
00:17:18,825 --> 00:17:20,985
字面上只是试图设置一个检查，

385
00:17:20,985 --> 00:17:22,880
看看它是否为当前的值为 0 ，

386
00:17:23,680 --> 00:17:26,970
如果是的，我可以设置 1 ，

387
00:17:27,170 --> 00:17:29,610
我可以在单个指令中原子地完成该操作，

388
00:17:29,630 --> 00:17:31,330
所以这不像是 if, then this, then that ，

389
00:17:31,330 --> 00:17:35,340
其他人可以突然出现，并在我之前修改它，

390
00:17:35,480 --> 00:17:37,980
它是字面意义上的一条指令来应用这个改变，

391
00:17:38,180 --> 00:17:39,930
如果我拿不到，我就旋转，

392
00:17:40,590 --> 00:17:43,660
因为我们是在用户空间的数据库级别中操作，

393
00:17:43,830 --> 00:17:45,760
我们可以决定是要重试多少次，

394
00:17:46,020 --> 00:17:47,890
还是要让出线程给操作系统，

395
00:17:48,120 --> 00:17:49,630
还是放弃并重新开始。

396
00:17:50,970 --> 00:17:53,980
好的，为什么这很糟糕？

397
00:17:56,860 --> 00:18:01,910
是什么，等待，你说的，忙等待。

398
00:18:02,170 --> 00:18:04,700
所以你基本上是在旋转周期，旋转 CPU ，

399
00:18:04,870 --> 00:18:06,200
检查，检查，检查，一遍又一遍。

400
00:18:06,970 --> 00:18:08,030
我可以这么说，

401
00:18:08,660 --> 00:18:11,795
我可以把指数放回去说，

402
00:18:11,795 --> 00:18:12,365
好的，我试着获取，

403
00:18:12,365 --> 00:18:15,520
我获取不到，等一毫秒，两毫秒，四毫秒。

404
00:18:18,210 --> 00:18:20,350
事实上，这是一个挑战，

405
00:18:20,520 --> 00:18:22,210
你只是一遍又一遍地旋转，

406
00:18:22,380 --> 00:18:24,995
另一个问题将是缓存一致性[流量]。

407
00:18:24,995 --> 00:18:27,250
所以，假设我有一个双插槽 CPU ，

408
00:18:27,630 --> 00:18:31,750
我想要获取的 latch 在这个 NUMA 区域上，

409
00:18:32,370 --> 00:18:35,850
知道 NUMA 是什么，非一致内存访问，

410
00:18:35,850 --> 00:18:37,730
比如我的 [] 中有两个插槽，

411
00:18:37,780 --> 00:18:40,310
我的主板上有两个插槽或更多个插槽，

412
00:18:40,810 --> 00:18:44,240
每个 CPU 插槽都会有接近它的 DRAM ，

413
00:18:44,500 --> 00:18:46,130
与之交互很快，

414
00:18:46,680 --> 00:18:50,780
但我也可以与另一个插座上的内存交互，

415
00:18:50,950 --> 00:18:52,280
它称为 NUMA 区域，

416
00:18:52,480 --> 00:18:54,285
但是这个流量要慢得多，

417
00:18:54,285 --> 00:18:57,620
因为我必须通过一个插槽到另一个插槽之间的互连，

418
00:18:58,260 --> 00:19:00,120
所以， Intel 做了很多工作，

419
00:19:00,120 --> 00:19:01,580
以确保当你编写程序时，

420
00:19:01,600 --> 00:19:06,710
你不知道，从技术上讲，你不需要知道内存的实际位置，

421
00:19:07,030 --> 00:19:10,935
但是当然，现在你可以让你的程序访问另一个插槽上的东西，

422
00:19:10,935 --> 00:19:12,020
它变得非常慢，

423
00:19:12,130 --> 00:19:14,430
硬件试图使用技巧，为你移动东西，

424
00:19:14,430 --> 00:19:15,170
试图加快速度，

425
00:19:15,400 --> 00:19:16,485
我们可以暂时忽略这个，

426
00:19:16,485 --> 00:19:17,745
对于这门课，我们不必担心 NUMA ，

427
00:19:17,745 --> 00:19:19,130
我只是想解释一下。

428
00:19:19,750 --> 00:19:23,810
这个 CPU 上运行的 worker ，

429
00:19:24,070 --> 00:19:27,800
想要获取这个另一个插槽 CPU 内存中的 latch ，

430
00:19:28,930 --> 00:19:30,330
所以它会不停地旋转，

431
00:19:30,330 --> 00:19:32,900
但是现在，这个互连上的所有流量

432
00:19:33,970 --> 00:19:36,440
将使我的整个数据库系统变慢。

433
00:19:37,630 --> 00:19:38,445
所以这是低效的，

434
00:19:38,445 --> 00:19:39,015
因为我在旋转，

435
00:19:39,015 --> 00:19:42,500
而且实际硬件上的流量本身也很昂贵。

436
00:19:44,830 --> 00:19:45,950
所以现在她的问题是，

437
00:19:46,180 --> 00:19:47,445
为什么，出了什么问题，

438
00:19:47,445 --> 00:19:50,870
或者 C++ mutex 实际上是如何工作的？

439
00:19:51,410 --> 00:19:53,280
所以，这被称为阻塞 mutex ，

440
00:19:53,480 --> 00:19:54,720
它是最容易使用的，

441
00:19:54,740 --> 00:19:56,370
因为它是内置在 C++ 中的，

442
00:19:59,670 --> 00:20:01,090
基本上，你获取和释放，

443
00:20:01,530 --> 00:20:03,160
它没有太多的机制，

444
00:20:04,140 --> 00:20:05,680
你使用它的方式，就像这样，

445
00:20:05,820 --> 00:20:06,940
你对它加锁，再解锁，

446
00:20:07,200 --> 00:20:08,230
在中间做你想做的任何事情。

447
00:20:09,280 --> 00:20:12,330
所以我问她，这个东西是如何实现的，

448
00:20:12,330 --> 00:20:13,010
有人知道吗，

449
00:20:14,660 --> 00:20:15,955
所以，如果你调用 std::mutex ，

450
00:20:15,955 --> 00:20:16,980
你在 C++ 中得到了什么，

451
00:20:20,340 --> 00:20:21,160
pthread_mutex ，

452
00:20:22,350 --> 00:20:23,710
pthread_mutex 是如何实现的，

453
00:20:26,570 --> 00:20:28,350
它调用 futex ，它在 Linux 中，

454
00:20:29,480 --> 00:20:30,360
大家之前都听说过 futex 吗，

455
00:20:31,670 --> 00:20:33,120
快速用户空间 mutex 。

456
00:20:33,530 --> 00:20:34,770
所以它的工作方式是。

457
00:20:35,660 --> 00:20:37,850
它有我在上一张幻灯片中展示的自旋锁，

458
00:20:37,850 --> 00:20:41,080
在用户空间，他们会有自己的 test-and-set ，你可以做，

459
00:20:41,460 --> 00:20:44,020
如果你试图获取它，但你不能，

460
00:20:45,180 --> 00:20:49,060
然后，你将退回到内核中的重量级 mutex ，

461
00:20:49,740 --> 00:20:54,100
所以，如果没有人持有一个 latch ，有我会尝试获取的 futex ，

462
00:20:54,120 --> 00:20:55,025
如果没有人持有它，

463
00:20:55,025 --> 00:20:58,300
那么我只需在用户空间中快速进行比较和交换，

464
00:20:58,350 --> 00:20:58,940
我就完成了，

465
00:20:58,940 --> 00:21:01,150
我的程序，我的线程一直在运行，

466
00:21:01,320 --> 00:21:02,555
如果我不能得到它，

467
00:21:02,555 --> 00:21:04,825
那么操作系统从我们接管控制，

468
00:21:04,825 --> 00:21:06,720
我们现在进入内核，

469
00:21:06,980 --> 00:21:08,335
然后我们会被取消调度，

470
00:21:08,335 --> 00:21:09,925
因为它知道我不能运行，

471
00:21:09,925 --> 00:21:11,820
直到我等待的东西可用。

472
00:21:12,925 --> 00:21:13,705
但是内核里到底有什么，

473
00:21:13,705 --> 00:21:14,910
他们是如何跟踪线程的，

474
00:21:16,890 --> 00:21:17,410
是什么。

475
00:21:18,590 --> 00:21:19,230
抱歉，再说一遍，

476
00:21:20,020 --> 00:21:21,390
阻塞队列，但是什么，

477
00:21:22,510 --> 00:21:23,040
还有，

478
00:21:24,560 --> 00:21:26,995
调度器有自己的哈希表

479
00:21:26,995 --> 00:21:28,410
来跟踪哪些线程正在运行，

480
00:21:28,880 --> 00:21:31,920
所以它们使用自己的 latch 来保护数据结构。

481
00:21:32,150 --> 00:21:33,730
所以，如果我不能获得这个，

482
00:21:33,730 --> 00:21:34,750
我会进入内核，

483
00:21:34,750 --> 00:21:35,545
我会被取消调度，

484
00:21:35,545 --> 00:21:36,415
这是非常非常昂贵的，

485
00:21:36,415 --> 00:21:37,240
系统调用是昂贵的，

486
00:21:37,240 --> 00:21:38,850
我们想避免它们。

487
00:21:39,710 --> 00:21:41,580
好的，就是像这样的图表。

488
00:21:41,720 --> 00:21:44,700
所以，同样，我有两个 worker 运行在不同的插槽上，

489
00:21:45,020 --> 00:21:46,290
它们都试图在同一时间[]，

490
00:21:46,520 --> 00:21:48,090
其中一个将获得用户空间 latch ，

491
00:21:48,230 --> 00:21:49,870
另一个试图下去拿操作系统 latch ，

492
00:21:49,870 --> 00:21:51,600
它们被取消调度。

493
00:21:52,830 --> 00:21:54,320
再次，这是缓慢的，

494
00:21:54,320 --> 00:21:56,440
因为任何时候你涉及到操作系统，这是糟糕的。

495
00:22:00,040 --> 00:22:02,850
所以我展示的前两个 latch ，

496
00:22:02,850 --> 00:22:04,035
它们并没有模式，

497
00:22:04,035 --> 00:22:05,300
只是全有或全无，

498
00:22:05,980 --> 00:22:08,240
所以，你实现这个的方式，

499
00:22:09,790 --> 00:22:12,230
加上读写 latch ，

500
00:22:12,460 --> 00:22:13,605
你可以使用 shared_mutex ，

501
00:22:13,605 --> 00:22:17,240
我想我们在 BusTub 做读写锁，

502
00:22:17,530 --> 00:22:19,340
只是一个 pthread 读写锁。

503
00:22:19,870 --> 00:22:21,825
这个工作的方式是，

504
00:22:21,825 --> 00:22:24,320
latch 本身将有自己的优先队列，

505
00:22:24,370 --> 00:22:26,660
它自己的计数器，记录有多少线程在等待，

506
00:22:27,040 --> 00:22:33,080
实际上，你可以找到 latch 本身的调度策略。

507
00:22:33,610 --> 00:22:34,880
所以这里的想法是，

508
00:22:35,200 --> 00:22:38,480
如果我有一个读器线程出现，

509
00:22:38,770 --> 00:22:39,830
一旦获取 latch ，

510
00:22:40,030 --> 00:22:42,720
我去检查是否有人在等待读 latch

511
00:22:42,720 --> 00:22:45,170
或 latch 在读模式或写模式，

512
00:22:46,090 --> 00:22:46,820
如果它可用，

513
00:22:46,930 --> 00:22:48,075
那么我递增我的计数器，

514
00:22:48,075 --> 00:22:50,400
说现在有人在持有读 latch ，

515
00:22:50,400 --> 00:22:51,950
我继续做我想做的事情。

516
00:22:52,360 --> 00:22:53,605
现在，如果其他人也出现，

517
00:22:53,605 --> 00:22:54,870
也想获取读模式，

518
00:22:55,010 --> 00:22:56,080
系统知道我，

519
00:22:56,080 --> 00:22:58,710
latch 知道我现在处于读模式，

520
00:22:58,850 --> 00:23:00,810
这样它就可以让其他人也运行。

521
00:23:01,220 --> 00:23:04,140
但是现在，如果出现写入 worker ，

522
00:23:04,400 --> 00:23:05,340
尝试获取 latch ，

523
00:23:05,690 --> 00:23:09,390
我们有两个读取 worker 已经持有 latch 在读模式，

524
00:23:09,590 --> 00:23:10,615
所以，它将不得不停止，

525
00:23:10,615 --> 00:23:12,880
它们维护一个内部优先级队列，

526
00:23:12,880 --> 00:23:14,700
以跟踪哪些线程正在等待这个。

527
00:23:15,290 --> 00:23:16,585
然后，根据策略，

528
00:23:16,585 --> 00:23:17,850
你可以在 latch 中配置，

529
00:23:18,140 --> 00:23:19,470
如果出现另一个线程，

530
00:23:19,760 --> 00:23:20,850
然后再次在读模式下，

531
00:23:20,990 --> 00:23:23,310
理论上，我可以获取它，

532
00:23:23,510 --> 00:23:27,180
因为它与所有其他持有在读模式下的 worker 是可交换的，

533
00:23:27,410 --> 00:23:28,560
我可以马上查询，

534
00:23:28,700 --> 00:23:29,905
但是你可以设置策略，

535
00:23:29,905 --> 00:23:32,730
我知道另一个线程正在以读模式等待它，

536
00:23:32,930 --> 00:23:36,690
所以让我继续，并将它睡眠。

537
00:23:37,510 --> 00:23:38,340
在 C++ 中，

538
00:23:38,340 --> 00:23:40,485
我认为它们都是在用户空间中完成的，

539
00:23:40,485 --> 00:23:41,565
不是在内核中，

540
00:23:41,565 --> 00:23:45,855
但是，当你不得不阻塞并等待你要寻找的 latch 时，

541
00:23:45,855 --> 00:23:48,230
那将是一个操作系统 mutex ，

542
00:23:48,520 --> 00:23:49,430
这是我们不想做的。

543
00:23:50,970 --> 00:23:54,125
所以，我刚刚向你们高级别的概述，

544
00:23:54,125 --> 00:23:56,705
test-and-set 操作， compare-and-swap ，

545
00:23:56,705 --> 00:24:02,190
是你用来构建更复杂的 latch 原语的基础构建块。

546
00:24:03,470 --> 00:24:04,120
取决于这个，

547
00:24:04,120 --> 00:24:05,520
你是否希望操作系统这样做，

548
00:24:07,260 --> 00:24:08,350
大多数系统，

549
00:24:10,710 --> 00:24:13,040
大多数大的数据库系统，企业级的，

550
00:24:13,040 --> 00:24:14,710
将不会依赖于操作系统的任何东西，

551
00:24:15,060 --> 00:24:16,600
它是可移植性的[组合]，

552
00:24:16,650 --> 00:24:19,420
而且它避免操作系统是更快地，

553
00:24:19,800 --> 00:24:20,800
Linus 是错的。

554
00:24:24,390 --> 00:24:25,330
好的，那么现在让我们，

555
00:24:25,680 --> 00:24:26,075
是的。

556
00:24:26,075 --> 00:24:26,915
我只想确认，

557
00:24:26,915 --> 00:24:29,500
阻塞 mutex 也是建立在 test-and-set 上的吗？

558
00:24:30,100 --> 00:24:32,810
问题是，是否阻塞 mutex 建立在 test-and-set 之上，

559
00:24:32,920 --> 00:24:33,830
所有这些都是，是的，

560
00:24:34,000 --> 00:24:35,085
是的，就像，

561
00:24:35,085 --> 00:24:36,350
你们知道什么是 compare-and-swap 吗？

562
00:24:38,400 --> 00:24:43,240
不，好的，我有幻灯片，一张幻灯片。

563
00:24:43,650 --> 00:24:46,550
好的， compare-and-swap 是一种原子指令，

564
00:24:46,550 --> 00:24:48,730
现代 CPU 提供的，

565
00:24:48,960 --> 00:24:50,920
允许你检查内存位置，

566
00:24:51,210 --> 00:24:52,450
以查看它是否是当前的，

567
00:24:52,560 --> 00:24:56,650
该内存地址的当前值是否为你预期的值，

568
00:24:56,970 --> 00:24:59,390
如果是，那么我可以继续，

569
00:24:59,390 --> 00:25:00,910
用我的新值覆盖它，

570
00:25:01,500 --> 00:25:02,710
在一条单独的指令中，

571
00:25:03,540 --> 00:25:05,075
如果你必须在 C++ 代码中这样做，

572
00:25:05,075 --> 00:25:07,150
比如，如果这个值等于这个，

573
00:25:07,790 --> 00:25:09,390
那么把它设置为那个，

574
00:25:09,740 --> 00:25:12,490
但是，如果这只是完成这一任务的实际指令，

575
00:25:12,490 --> 00:25:13,525
那将是多条指令，

576
00:25:13,525 --> 00:25:15,870
当你去检查这个值是否，

577
00:25:16,040 --> 00:25:18,000
标志是否设置为 true 时，

578
00:25:18,470 --> 00:25:20,050
当你去更新它的时候，

579
00:25:20,050 --> 00:25:23,820
其他人可能已经在你之前偷偷进入并在之前更新了。

580
00:25:24,520 --> 00:25:25,750
所以，在现代 CPU 上，

581
00:25:25,750 --> 00:25:27,040
你可以在一条单独的指令中做到这个，

582
00:25:27,040 --> 00:25:28,560
这是原子的，保证，

583
00:25:28,700 --> 00:25:30,450
当你检查并设置它时，

584
00:25:30,470 --> 00:25:32,040
其他人不能比你先进去。

585
00:25:32,560 --> 00:25:35,280
这是基本的原语，允许我们做更复杂的事情。

586
00:25:36,220 --> 00:25:39,780
所以在 C 和 C++ 中，有一堆不同的内在函数，

587
00:25:39,780 --> 00:25:41,180
你可以用来做这个，

588
00:25:41,590 --> 00:25:42,690
它们有不同的版本，

589
00:25:42,690 --> 00:25:47,390
比如，如果 test-and-set 成功，或者 compare-and-swap 成功，

590
00:25:47,530 --> 00:25:50,240
它们将返回旧值或新值或 ture 和 false ，

591
00:25:50,380 --> 00:25:51,980
但它们基本上都在做同样的事情，

592
00:25:52,420 --> 00:25:53,660
所以，在这种情况下，

593
00:25:53,860 --> 00:25:54,660
对于这个内部函数，

594
00:25:54,660 --> 00:25:56,150
我说这是我想检查的地址，

595
00:25:56,260 --> 00:25:57,830
假设它是一个 64 位整数，

596
00:25:58,000 --> 00:26:01,280
这是我想要查看当前是否设置的值，

597
00:26:01,450 --> 00:26:04,250
如果是，这是我希望现在设置的值。

598
00:26:04,630 --> 00:26:06,105
所以我们跳到这个内存地址，

599
00:26:06,105 --> 00:26:09,050
它是 20 ， 20 等于 20 ，是的，

600
00:26:09,340 --> 00:26:11,120
然后，我继续，并用 30 覆盖。

601
00:26:13,010 --> 00:26:13,620
很简单，

602
00:26:14,540 --> 00:26:16,770
但是，这是我们需要的构建块，

603
00:26:16,850 --> 00:26:19,050
来构建所有更复杂的 latch 。

604
00:26:21,290 --> 00:26:23,635
我不知道这个 compare-and-swap 的东西是什么时候加的，

605
00:26:23,635 --> 00:26:24,810
我认为是在 90 年代末，

606
00:26:25,310 --> 00:26:26,430
至少在 1986 。

607
00:26:28,600 --> 00:26:29,150
我们好了吗。

608
00:26:29,760 --> 00:26:31,070
好的，酷，好的。

609
00:26:32,880 --> 00:26:34,810
现在，让我们看看如何对哈希表做这个，

610
00:26:34,860 --> 00:26:36,100
或者在哈希表上使用 latch 。

611
00:26:37,120 --> 00:26:39,435
所以哈希表将很容易被支持，

612
00:26:39,435 --> 00:26:42,890
因为，假设线性探测哈希是，

613
00:26:43,270 --> 00:26:45,980
你只有确定的很多方法可以访问哈希表，

614
00:26:46,930 --> 00:26:49,610
假设它是线性探测哈希，

615
00:26:49,720 --> 00:26:53,505
我哈希到我的哈希数组或哈希表中的某个位置，

616
00:26:53,505 --> 00:26:56,210
然后我从上到下扫描，

617
00:26:56,560 --> 00:26:59,120
寻找我寻找的条目，我所需要的。

618
00:27:00,520 --> 00:27:01,515
在这个例子中，

619
00:27:01,515 --> 00:27:03,380
因为所有线程都朝着相同的方向移动，

620
00:27:03,790 --> 00:27:04,980
从上到下，

621
00:27:04,980 --> 00:27:07,490
即使它们可能从哈希表中的不同位置开始，

622
00:27:07,990 --> 00:27:09,470
我不会有任何死锁，

623
00:27:10,030 --> 00:27:14,690
因为没有一个线程自上而下，另一个线程自下而上。

624
00:27:15,860 --> 00:27:18,310
所以，问题将会是，

625
00:27:18,310 --> 00:27:19,810
我们要做的是什么粒度，

626
00:27:19,810 --> 00:27:21,660
我们希望有我们的 latch 来保护我们的数据结构，

627
00:27:21,950 --> 00:27:25,380
因为这将决定我们能够支持的并行度。

628
00:27:26,440 --> 00:27:27,320
对于这节课，

629
00:27:27,400 --> 00:27:29,780
我们将忽略如何处理表的大小调整，

630
00:27:30,400 --> 00:27:32,115
处理这一问题的最简单方法是，

631
00:27:32,115 --> 00:27:38,930
你有一个写入 latch 来保护对数据结构本身的访问，

632
00:27:39,220 --> 00:27:42,110
所以如果我满了，我需要把它的大小增加一倍，

633
00:27:42,220 --> 00:27:44,000
我只需将 latch 切换到写入模式，

634
00:27:44,200 --> 00:27:45,770
然后进行我的大小调整，

635
00:27:45,880 --> 00:27:48,170
这样就会阻止其他人进入，

636
00:27:48,760 --> 00:27:49,970
这是做这个最简单的方法。

637
00:27:51,960 --> 00:27:56,030
所以，我们的 latch 的作用域可以在 page 或 slot ，

638
00:27:56,030 --> 00:27:57,910
再次，这将决定我们的并行度，

639
00:27:58,350 --> 00:28:02,890
所以，很明显，页面 latch 用 latch 保护整个页面本身，

640
00:28:03,360 --> 00:28:06,820
无论你想要读取页面中的一个条目还是所有条目，

641
00:28:07,080 --> 00:28:08,980
你都会持有整个内容的 latch 。

642
00:28:09,750 --> 00:28:13,780
另一种选择是，页面中的每个单独 slot 都有一个 latch ，

643
00:28:14,540 --> 00:28:16,340
这将允许更细粒度的访问，

644
00:28:16,340 --> 00:28:18,340
但是，现在的挑战是，

645
00:28:18,720 --> 00:28:19,715
我要占用更多的空间，

646
00:28:19,715 --> 00:28:21,820
因为每个单独的 slot 都需要有一个 latch ，

647
00:28:22,290 --> 00:28:25,330
现在，当我扫描我的哈希表时，

648
00:28:25,470 --> 00:28:28,510
我在前进的过程中需要获取每个 slot 的 latch 。

649
00:28:29,350 --> 00:28:32,600
所以，再次，在系统或计算机科学领域，没有免费的午餐，

650
00:28:32,860 --> 00:28:35,450
它要么是我每页只有一个 latch ，

651
00:28:35,680 --> 00:28:37,580
我只为页面获取一次，

652
00:28:38,290 --> 00:28:39,285
它不会占用太多空间，

653
00:28:39,285 --> 00:28:41,390
但它会阻止其他所有在整个页面之外，

654
00:28:41,710 --> 00:28:44,120
或者我对每个单独的 slot 有一个（latch）。

655
00:28:46,620 --> 00:28:48,730
假设像这样的哈希表，

656
00:28:50,340 --> 00:28:51,430
T1 想要[出现]，

657
00:28:51,600 --> 00:28:53,230
线程 1 想要出现并查找 D ，

658
00:28:53,370 --> 00:28:55,210
我们哈希 D ，我们落在这个位置，

659
00:28:55,410 --> 00:28:58,930
我们让整个页面处于写模式（这里应该是读模式），

660
00:28:59,340 --> 00:29:02,260
试着通过向下扫描来找到我们寻找的条目，

661
00:29:02,430 --> 00:29:04,460
但是同时，另一个线程想要出现，

662
00:29:04,460 --> 00:29:05,440
想要插入 E ，

663
00:29:05,880 --> 00:29:07,205
相同的东西，我哈希到这个页面，

664
00:29:07,205 --> 00:29:10,840
但是页面已经 latch 在读模式下，

665
00:29:10,980 --> 00:29:14,170
这与写模式 latch 是不可交换的，需要进行插入，

666
00:29:14,620 --> 00:29:16,680
所以，我们必须停顿线程 2 ，

667
00:29:17,490 --> 00:29:20,890
无论它是在用户空间旋转还是被内核重新调度，

668
00:29:21,000 --> 00:29:22,330
这取决于你的 latch 实现。

669
00:29:23,730 --> 00:29:28,570
所以现在，当线程 1 扫描完这个页面时，

670
00:29:28,830 --> 00:29:30,130
它可以跳到下一页面，

671
00:29:30,360 --> 00:29:33,110
它仍然持有它开始的页面的 latch ，

672
00:29:33,110 --> 00:29:36,710
因为它需要知道如何查看下一页面，

673
00:29:36,710 --> 00:29:38,380
确保没人移动东西。

674
00:29:39,060 --> 00:29:42,340
然后我们可以释放页面 1 上的 latch ，

675
00:29:42,930 --> 00:29:44,225
获取页面 2 上的 latch ，

676
00:29:44,225 --> 00:29:46,690
然后线程 2 可以开始运行，

677
00:29:46,740 --> 00:29:48,760
并试图找出想要插入的位置。

678
00:29:50,240 --> 00:29:52,860
同样的事情一旦下来这里做写入，

679
00:29:53,270 --> 00:29:56,520
读 latch 不能与写 latch 交换，

680
00:29:56,990 --> 00:29:58,230
所以它必须等待，

681
00:29:58,580 --> 00:29:59,820
然后，一旦线程 1 完成，

682
00:30:00,860 --> 00:30:03,990
线程 2 就可以获取 latch ，并进行更新，插入它的条目。

683
00:30:08,730 --> 00:30:09,340
是的，问题。

684
00:30:21,740 --> 00:30:22,360
你的问题是，

685
00:30:22,360 --> 00:30:24,840
如果我持有一个读 latch ，

686
00:30:27,540 --> 00:30:28,955
再说一遍，抱歉。

687
00:30:39,610 --> 00:30:42,030
所以回到最开始这里？

688
00:30:51,500 --> 00:30:54,600
所以，假设这里的场景，

689
00:30:54,680 --> 00:30:56,550
假设 T2 出现在 T1 之前，

690
00:30:58,350 --> 00:31:00,880
那么你想要处理的竞态条件是什么？

691
00:31:12,160 --> 00:31:13,670
好的，所以你说的读写，

692
00:31:13,780 --> 00:31:15,080
读，然后写，然后读，

693
00:31:15,340 --> 00:31:19,640
第二次读，是不是另一个查找键？

694
00:31:30,030 --> 00:31:30,760
但这是错的吗？

695
00:31:39,430 --> 00:31:41,480
是的，所以，所以。

696
00:31:46,670 --> 00:31:49,110
所以，是的，所以，

697
00:31:50,820 --> 00:31:53,530
这是逻辑上的正确性。

698
00:31:55,630 --> 00:31:57,980
如果我做一个 SELECT ，

699
00:31:58,150 --> 00:32:00,440
我运行一个小的 SELECT 查询，

700
00:32:00,610 --> 00:32:01,830
它在这个哈希表中查找，

701
00:32:01,830 --> 00:32:03,980
我找到了 D ，

702
00:32:04,330 --> 00:32:05,480
我就得到了答案，

703
00:32:06,370 --> 00:32:11,175
现在其他事务，另一个线程出现并删除 D ，

704
00:32:11,175 --> 00:32:12,200
[]在哈希表中，

705
00:32:12,430 --> 00:32:15,735
然后第一个线程运行另一个 SELECT 查询来查找 D ，

706
00:32:15,735 --> 00:32:17,240
并且不会返回它。

707
00:32:17,350 --> 00:32:19,550
从数据结构的角度来看，

708
00:32:19,900 --> 00:32:21,860
这对于我们今天讨论的内容来说是好的。

709
00:32:22,670 --> 00:32:24,030
当我们在期中考试之后讨论，

710
00:32:24,320 --> 00:32:29,820
这就是不一致读的反常现象。

711
00:32:30,460 --> 00:32:34,320
这是系统的机制将在事务级别处理的事情，

712
00:32:34,610 --> 00:32:36,840
在数据结构的低级别，我们不关心，

713
00:32:37,610 --> 00:32:38,250
这是正确的，

714
00:32:38,450 --> 00:32:43,170
谁决定我们应该看到或不看到什么写入，

715
00:32:43,490 --> 00:32:44,880
这是一个在后面发生的更高层次的事情。

716
00:32:45,480 --> 00:32:45,770
是的，

717
00:32:46,060 --> 00:32:49,070
关于数据库或这些事务的伟大之处在于，

718
00:32:49,240 --> 00:32:52,370
有多个潜在的技术上正确的答案，

719
00:32:54,110 --> 00:32:55,350
但我们会在晚些时候讨论。

720
00:32:58,470 --> 00:33:00,740
不，好的，在 SQL 的规范中，

721
00:33:00,740 --> 00:33:06,995
有关于在不同的隔离级别上被认为是正确或不正确的描述，

722
00:33:06,995 --> 00:33:08,870
我们还没有讨论，

723
00:33:09,100 --> 00:33:14,920
最简单、最严格的正确级别是，隔离级别是，

724
00:33:15,150 --> 00:33:18,130
称为严格可串行化或强可串行化，

725
00:33:18,180 --> 00:33:19,150
基本上就是，

726
00:33:20,140 --> 00:33:22,260
无论谁先来，都应该看到，

727
00:33:22,260 --> 00:33:24,830
系统就像它自己运行一样，

728
00:33:25,060 --> 00:33:28,130
它的修改首先得到应用。

729
00:33:28,570 --> 00:33:30,140
然后其他的一切都在那之后。

730
00:33:30,280 --> 00:33:34,050
但是我们继续，从数据库的角度来看，

731
00:33:34,050 --> 00:33:37,010
我不关心你的线程进入，删除 D ，

732
00:33:37,300 --> 00:33:39,105
查找 D ，然后 D 被删除，

733
00:33:39,105 --> 00:33:40,400
然后你再去查找它，它不见了，

734
00:33:40,840 --> 00:33:42,260
这不是数据结构的问题，

735
00:33:42,910 --> 00:33:43,880
那是别人的问题，

736
00:33:44,260 --> 00:33:46,460
这是我们的问题，但不是今天的课程。

737
00:33:49,825 --> 00:33:50,640
这真的很难，是的。

738
00:33:53,100 --> 00:33:55,445
哦，这就是为什么所有 NoSQL 的人一开始没有使用事务，

739
00:33:55,445 --> 00:33:56,890
因为这很难。

740
00:33:59,300 --> 00:34:00,190
好的，我们稍后再谈这个。

741
00:34:01,410 --> 00:34:02,890
很多事情他们没有做，因为这很难，

742
00:34:03,480 --> 00:34:04,960
然后他们不得不在晚些时候这样做。

743
00:34:06,690 --> 00:34:08,590
好的，让我演示一下如何使用 slot latch 。

744
00:34:10,520 --> 00:34:12,505
同样，现在我在每个 slot 本身都有一个 latch ，

745
00:34:12,505 --> 00:34:13,140
以及我的哈希表。

746
00:34:13,520 --> 00:34:14,910
所以现在，当我执行查找 D ，

747
00:34:14,960 --> 00:34:18,120
我得到 slot 本身的读 latch ，

748
00:34:18,680 --> 00:34:20,370
我可以继续，读取我查找的内容，

749
00:34:20,450 --> 00:34:22,230
然后说这个想要跳到这个页面，

750
00:34:22,400 --> 00:34:27,420
他想要获取 C 的写 latch ，

751
00:34:27,980 --> 00:34:28,945
忽略他是如何发现的，

752
00:34:28,945 --> 00:34:30,000
因为他哈希到那里。

753
00:34:31,440 --> 00:34:35,620
现在，当第一个线程试图获取下一个 slot 上的读 latch 时，

754
00:34:35,670 --> 00:34:36,455
他不能，

755
00:34:36,455 --> 00:34:38,590
因为另一个线程持有 latch ，

756
00:34:38,760 --> 00:34:39,730
所以他有一个停滞，

757
00:34:40,140 --> 00:34:40,930
但在这一点，

758
00:34:41,760 --> 00:34:43,150
即使他停滞并等待，

759
00:34:43,320 --> 00:34:46,210
对他来说，释放前一个 slot 上的 latch 是安全的，

760
00:34:46,620 --> 00:34:49,920
因为，他有他的，

761
00:34:50,690 --> 00:34:52,120
这里没有问题，

762
00:34:52,120 --> 00:34:55,780
他没有理由一直持有这个 latch ，

763
00:34:55,780 --> 00:34:57,600
因为他只是旋转，在这里等待这个东西，

764
00:34:57,710 --> 00:35:00,420
一切都在[]那里。

765
00:35:00,950 --> 00:35:04,800
我提到了哈希表本身的重组，

766
00:35:05,180 --> 00:35:06,420
例如，如果你必须调整它的大小，

767
00:35:06,740 --> 00:35:10,050
假设有一些其他的 latch 在读模式保护整个东西，

768
00:35:10,130 --> 00:35:11,070
所以这是可以的，

769
00:35:11,520 --> 00:35:12,800
我们只需要设置为写模式，

770
00:35:12,800 --> 00:35:14,030
如果我们必须调整整个东西大小，

771
00:35:14,030 --> 00:35:16,270
所以，全局的 latch ，

772
00:35:16,740 --> 00:35:18,790
T2 将持有全局 latch 在读模式。

773
00:35:19,890 --> 00:35:20,290
是的。

774
00:35:20,700 --> 00:35:24,710
不，这是，

775
00:35:25,420 --> 00:35:28,620
把它想象成我们的哈希表的某个页面中的某个偏移量，

776
00:35:28,700 --> 00:35:29,700
所以它的长度都是固定的。

777
00:35:30,600 --> 00:35:31,000
是的。

778
00:35:32,070 --> 00:35:32,645
所以这个。

779
00:35:32,645 --> 00:35:35,680
是的，没错，是的，是的，

780
00:35:36,480 --> 00:35:39,260
基本上你想要细粒度 latch 还是粗粒度 latch ，

781
00:35:39,260 --> 00:35:39,850
仅此而已。

782
00:35:41,550 --> 00:35:41,950
好的。

783
00:35:43,150 --> 00:35:44,510
所以，这应该是相当简单的。

784
00:35:45,330 --> 00:35:45,730
好的。

785
00:35:46,360 --> 00:35:47,155
让我们去 B+ 树，

786
00:35:47,155 --> 00:35:49,410
因为这更难，也更有趣。

787
00:35:51,230 --> 00:35:52,350
所以，就像前面一样，

788
00:35:52,850 --> 00:35:54,175
在我们的哈希表和 B+ 树中，

789
00:35:54,175 --> 00:35:55,800
希望同时有多个线程读取。

790
00:35:57,380 --> 00:35:58,920
这里的挑战现在是，

791
00:35:59,210 --> 00:36:01,590
在使用线性探测的哈希表中，

792
00:36:01,910 --> 00:36:03,540
页面的数量是固定的，

793
00:36:04,290 --> 00:36:07,090
并且数据结构的组织是固定的，

794
00:36:07,970 --> 00:36:09,265
意思是，

795
00:36:09,265 --> 00:36:11,490
如果我创建我的哈希表，

796
00:36:11,630 --> 00:36:13,680
我说有一百万个 slot ，

797
00:36:13,970 --> 00:36:14,635
这都无关紧要，

798
00:36:14,635 --> 00:36:16,705
不管我有一千个线程在它上面，

799
00:36:16,705 --> 00:36:17,935
还是一个线程在它上面，

800
00:36:17,935 --> 00:36:19,140
我永远都会有一百万个 slot ，

801
00:36:19,340 --> 00:36:19,855
事实上，

802
00:36:19,855 --> 00:36:22,020
不管我有没有一百万个键，

803
00:36:22,220 --> 00:36:23,700
数据结构都是一样的。

804
00:36:24,570 --> 00:36:25,655
在 B+ 树中，

805
00:36:25,655 --> 00:36:29,500
数据结构是自组织或自平衡的，

806
00:36:29,730 --> 00:36:31,450
当我向其中插入内容时，

807
00:36:31,680 --> 00:36:33,130
抱歉，删除其中的内容，

808
00:36:33,450 --> 00:36:35,560
它将开始自我重组。

809
00:36:36,530 --> 00:36:37,465
所以，我需要确保，

810
00:36:37,465 --> 00:36:39,730
在我重新组织事物时，拆分，合并，

811
00:36:39,730 --> 00:36:42,055
我必须确保，

812
00:36:42,055 --> 00:36:43,200
数据结构是正确的。

813
00:36:45,230 --> 00:36:46,530
好的，让我们看看事情如何变得糟糕。

814
00:36:46,880 --> 00:36:48,090
假设我们这里有一个线程，

815
00:36:48,290 --> 00:36:51,210
他们想要删除底部的键 44 ，

816
00:36:51,740 --> 00:36:52,500
那我该怎么做，

817
00:36:52,640 --> 00:36:55,255
我向下遍历，查看路标标记，

818
00:36:55,255 --> 00:36:56,965
确定我是否想要向左或向右，

819
00:36:56,965 --> 00:37:00,750
然后向下到达我的叶子节点，

820
00:37:01,010 --> 00:37:02,160
然后我继续，并删除它。

821
00:37:02,570 --> 00:37:03,685
但现在我必须重新平衡，

822
00:37:03,685 --> 00:37:04,450
我必须做一个合并，

823
00:37:04,450 --> 00:37:08,340
因为这个叶子节点不到半满，

824
00:37:08,450 --> 00:37:12,535
所以也许我会从我的兄弟节点偷走一个条目，

825
00:37:12,535 --> 00:37:14,520
把 41 移过来，

826
00:37:14,780 --> 00:37:16,410
但在我这么做之前，

827
00:37:17,410 --> 00:37:19,665
我的线程被取消调度，

828
00:37:19,665 --> 00:37:20,280
不管出于什么原因，

829
00:37:20,280 --> 00:37:22,215
操作系统决定做一些事情，[]下来，

830
00:37:22,215 --> 00:37:23,360
这无关紧要，

831
00:37:23,740 --> 00:37:24,950
我的线程不再运行。

832
00:37:25,840 --> 00:37:28,580
现在，当线程 1 睡眠的时候，

833
00:37:28,630 --> 00:37:29,475
线程 2 出现了，

834
00:37:29,475 --> 00:37:30,680
他们想要查找 41 ，

835
00:37:31,090 --> 00:37:34,130
他们开始像以前一样向下遍历，他们到达了这里，

836
00:37:34,480 --> 00:37:35,955
再次，现在他们查看路标，

837
00:37:35,955 --> 00:37:37,310
他们沿着，

838
00:37:37,450 --> 00:37:40,940
他们意识到他们想要下到节点 H 的右边，

839
00:37:41,680 --> 00:37:43,980
但是现在，它被取消调度，无论出于什么原因。

840
00:37:44,670 --> 00:37:48,370
然后线程 1 醒来，移动了 41 ，

841
00:37:49,250 --> 00:37:51,030
线程 2 醒来，

842
00:37:51,170 --> 00:37:53,490
下到节点，以为是需要去的，

843
00:37:53,720 --> 00:37:55,050
现在键不在那里了。

844
00:37:57,490 --> 00:37:58,280
最好的情况是，

845
00:37:58,330 --> 00:37:59,570
你会得到一个假[]，

846
00:37:59,950 --> 00:38:00,740
最坏的情况是，

847
00:38:00,790 --> 00:38:01,370
你会崩溃，

848
00:38:02,200 --> 00:38:05,160
系统出现故障，你可能会损坏你的数据。

849
00:38:07,550 --> 00:38:09,120
所以我们需要 latch 来保护这个东西。

850
00:38:10,820 --> 00:38:13,765
所以，我们将使用的技术称为 latch 抓取或 latch 耦合，

851
00:38:13,765 --> 00:38:15,355
我想教科书把它叫做 latch 耦合，

852
00:38:15,355 --> 00:38:18,270
我认为维基百科称其为 latch 耦合，

853
00:38:18,770 --> 00:38:22,320
但这基本上是我们要用来决定的协议，

854
00:38:23,510 --> 00:38:25,290
在向下遍历树时，

855
00:38:26,020 --> 00:38:28,500
我们想要获取什么 latch ，

856
00:38:28,940 --> 00:38:31,920
然后什么时候释放我们上面的 latch 。

857
00:38:32,710 --> 00:38:35,310
因为再次，保护整个数据结构的最简单方法是，

858
00:38:35,310 --> 00:38:37,130
在顶部放一个巨大的 latch ，

859
00:38:37,420 --> 00:38:39,045
然后每个人都必须通过[门禁]，

860
00:38:39,045 --> 00:38:41,030
但是随后，这就成为了一个瓶颈。

861
00:38:41,480 --> 00:38:42,640
所以我们想变得更聪明，

862
00:38:42,690 --> 00:38:45,760
有选择地释放我们的 latch ，

863
00:38:46,020 --> 00:38:47,110
当我们知道可以的时候。

864
00:38:48,280 --> 00:38:49,370
所以基本的协议是，

865
00:38:49,600 --> 00:38:51,770
为了进入 B+ 树，

866
00:38:51,940 --> 00:38:54,720
你总是给 root 设置 latch ，

867
00:38:54,720 --> 00:38:56,960
但是，一旦我在我的 root 上，

868
00:38:57,130 --> 00:38:59,510
我找出我想要向左或向右，

869
00:38:59,860 --> 00:39:01,670
然后我拿到子节点的 latch ，

870
00:39:01,750 --> 00:39:03,410
我要向下的当前所在的父节点，

871
00:39:03,700 --> 00:39:05,180
然后一旦我知道我可以了，

872
00:39:05,440 --> 00:39:06,620
我可以去那里，

873
00:39:06,700 --> 00:39:09,890
我可以释放我当前所在节点的父节点的 latch ，

874
00:39:10,210 --> 00:39:11,510
如果我知道它是安全的。

875
00:39:12,910 --> 00:39:14,810
安全的定义将是，

876
00:39:15,130 --> 00:39:19,430
基于我们试图执行的操作，插入或删除，

877
00:39:20,140 --> 00:39:21,750
如果它是插入，

878
00:39:21,920 --> 00:39:24,150
我们知道子节点没有填满，

879
00:39:24,350 --> 00:39:28,290
因此，如果我必须拆分，

880
00:39:30,140 --> 00:39:31,050
抱歉，当我插入我的键时，

881
00:39:31,160 --> 00:39:33,565
它不会导致在那个子节点进行拆分，

882
00:39:33,565 --> 00:39:35,220
这可能会传播到父节点。

883
00:39:35,870 --> 00:39:37,020
如果我要执行删除，

884
00:39:37,670 --> 00:39:39,130
如果我知道它已经半满，

885
00:39:39,130 --> 00:39:40,345
那么，如果我删除一个键，

886
00:39:40,345 --> 00:39:41,785
我知道我不会执行合并，

887
00:39:41,785 --> 00:39:46,330
我们将事情向上传播到我的父节点。

888
00:39:47,810 --> 00:39:48,955
所以，基本的协议是，

889
00:39:48,955 --> 00:39:50,130
我从 root 开始，向下遍历，

890
00:39:50,450 --> 00:39:52,000
获取每个子节点的读 latch ，

891
00:39:52,000 --> 00:39:52,765
随着我向下，

892
00:39:52,765 --> 00:39:54,420
因为我是在做读操作，

893
00:39:54,500 --> 00:39:55,590
我不是在做更新，

894
00:39:56,030 --> 00:39:57,360
然后我只是 unlatch 父节点，

895
00:39:58,010 --> 00:39:59,770
对于执行插入或删除，

896
00:39:59,770 --> 00:40:00,505
我从 root 开始，

897
00:40:00,505 --> 00:40:02,130
获取写 latch ，随着我向下，

898
00:40:02,510 --> 00:40:05,095
然后一旦我有我的子节点，

899
00:40:05,095 --> 00:40:07,170
知道我将进入写模式，

900
00:40:07,820 --> 00:40:09,280
然后我去检查它是否安全，

901
00:40:09,570 --> 00:40:10,520
如果它是安全的，

902
00:40:10,520 --> 00:40:12,760
我可以去释放任何我上面的 latch 。

903
00:40:15,200 --> 00:40:16,470
所以让我们回到这里的例子。

904
00:40:16,640 --> 00:40:18,060
所以我想查找键 38 ，

905
00:40:18,650 --> 00:40:19,620
我从 root 开始，

906
00:40:19,760 --> 00:40:23,970
把 root 节点放入写 latch 模式，

907
00:40:25,190 --> 00:40:26,230
我向下，

908
00:40:26,230 --> 00:40:29,220
抱歉，然后我获取 B 上的读 latch ，

909
00:40:29,450 --> 00:40:30,240
然后我向下移动，

910
00:40:30,470 --> 00:40:31,405
在这里，

911
00:40:31,405 --> 00:40:34,350
我可以安全地释放 A 上的 latch ，

912
00:40:34,790 --> 00:40:36,360
因为它执行读操作，

913
00:40:36,710 --> 00:40:37,915
我已经到达了 B ，

914
00:40:37,915 --> 00:40:38,545
我需要去的地方，

915
00:40:38,545 --> 00:40:39,480
所以我要去那里，

916
00:40:39,740 --> 00:40:41,460
这样我就可以继续，释放 B 上的 latch ，

917
00:40:42,030 --> 00:40:43,840
获取 D 上的读 latch ，

918
00:40:43,980 --> 00:40:45,890
同样的事情，对我来说，释放 B 上的 latch 是安全的，

919
00:40:45,890 --> 00:40:46,660
所以我会继续这样做，

920
00:40:46,980 --> 00:40:48,755
我下到 H ，依此类推，

921
00:40:48,755 --> 00:40:49,910
我最终拿到了我要找的键，

922
00:40:49,910 --> 00:40:50,410
我就完成了。

923
00:40:55,040 --> 00:40:55,840
好的，现在是删除 38 。

924
00:40:56,400 --> 00:40:57,200
再次，从 root 开始，

925
00:40:57,200 --> 00:41:01,150
我把 root 节点放入写 latch 模式，

926
00:41:02,480 --> 00:41:05,190
我获取 B 的写 latch ，向下移动到这里，

927
00:41:05,920 --> 00:41:07,500
再次，在这一点上，

928
00:41:08,840 --> 00:41:10,260
如果我做，

929
00:41:10,310 --> 00:41:12,450
我不知道在我下面的树中，在 B 下面会发生什么，

930
00:41:12,950 --> 00:41:17,610
因为如果我知道必须从当前所在的节点删除一个键，在 B 上面，

931
00:41:17,930 --> 00:41:19,560
我将不得不进行合并，

932
00:41:19,760 --> 00:41:22,950
所以，我不能释放我父节点 A 上的 latch ，

933
00:41:23,510 --> 00:41:26,280
因为我可能不得不去更改上面的 A ，

934
00:41:26,850 --> 00:41:29,950
所以我将持有 B 和 A 的写 latch ，

935
00:41:30,210 --> 00:41:31,150
下到 D ，

936
00:41:31,680 --> 00:41:33,080
现在在 D 上，我看到，

937
00:41:33,080 --> 00:41:35,950
无论我在树的下面发生了什么，

938
00:41:36,870 --> 00:41:38,600
如果我必须从 D 中删除一个键，

939
00:41:38,600 --> 00:41:40,780
D ，它将不会进行合并，

940
00:41:41,260 --> 00:41:43,320
所以，它不会在它上面做任何改变，

941
00:41:43,670 --> 00:41:47,880
所以，我可以安全地释放 A 和 B 上的 latch 。

942
00:41:49,890 --> 00:41:50,800
顺序重要吗？

943
00:41:50,880 --> 00:41:51,460
抱歉，请提问。

944
00:41:52,170 --> 00:41:56,200
不管你现在在什么上面，

945
00:41:57,280 --> 00:41:59,220
所以如果我在 B 上面，

946
00:42:00,120 --> 00:42:02,290
我需要去 D 上面，

947
00:42:02,610 --> 00:42:04,870
我将 latch 设置为写模式，

948
00:42:05,600 --> 00:42:06,815
现在我有了写模式，

949
00:42:06,815 --> 00:42:08,140
然后我检查一下，我安全吗。

950
00:42:15,510 --> 00:42:22,300
这个问题是，

951
00:42:22,300 --> 00:42:26,280
半满是是看它是否安全唯一的检查吗，

952
00:42:26,720 --> 00:42:31,950
还有什么会导致合并，在删除的情况下。

953
00:42:34,790 --> 00:42:37,150
这是我们唯一关心的事情，拆分、合并，

954
00:42:37,150 --> 00:42:39,060
我们努力确保我们不会把自己搞砸。

955
00:42:43,330 --> 00:42:43,970
好的，所以，

956
00:42:45,860 --> 00:42:47,370
所以在 D 这个位置上，

957
00:42:47,840 --> 00:42:49,590
我们必须释放 A 和 B 上的 latch ，

958
00:42:50,360 --> 00:42:51,630
因为， D 是安全的。

959
00:42:52,420 --> 00:42:54,450
我们释放这些 latch 的顺序重要吗？

960
00:43:01,300 --> 00:43:04,305
他说，从底部到顶部这样做更有意义，

961
00:43:04,305 --> 00:43:06,320
先释放 B ，再释放 A ，为什么？

962
00:43:18,000 --> 00:43:21,850
所以如果我释放 B ，有人在等待 A 。

963
00:43:25,040 --> 00:43:25,440
是的。

964
00:43:30,840 --> 00:43:34,680
所以，他说，如果你释放 B ，然后它，

965
00:43:35,480 --> 00:43:37,230
抱歉，另一个线程，等待 B 或 A ，抱歉。

966
00:43:38,600 --> 00:43:39,660
是的，在同一[路径]上。

967
00:43:43,970 --> 00:43:47,130
一个 latch ，是的，是的，好的。

968
00:43:48,020 --> 00:43:49,045
但是如果我在 B 上释放它，

969
00:43:49,045 --> 00:43:49,950
它仍在等待 A 。

970
00:43:52,870 --> 00:43:55,785
同样，如果我有一个线程正在等待 A ，

971
00:43:55,785 --> 00:43:57,530
但我想从树的这一边下来怎么办，

972
00:43:58,430 --> 00:43:59,550
但我会释放 B ，

973
00:44:00,390 --> 00:44:00,950
它还是阻塞的。

974
00:44:02,470 --> 00:44:03,740
所以从正确的理由来看，

975
00:44:04,000 --> 00:44:05,090
从正确的角度来看，

976
00:44:05,140 --> 00:44:06,080
这实际上并不重要。

977
00:44:06,780 --> 00:44:09,345
就像系统，数据结构都是正确的，

978
00:44:09,345 --> 00:44:12,170
无论你从底部到顶部，从底部的顶部。

979
00:44:12,490 --> 00:44:13,545
出于性能原因，

980
00:44:13,545 --> 00:44:14,660
我们想要自上而下，

981
00:44:15,490 --> 00:44:16,370
因为我们想要释放，

982
00:44:16,570 --> 00:44:17,760
比如你想象它是，

983
00:44:17,760 --> 00:44:20,120
latch 是在保护它下面的一切，

984
00:44:20,320 --> 00:44:22,190
所以，如果我在 root 上持有写 latch ，

985
00:44:22,210 --> 00:44:25,410
我就是在以写模式保护整个数据结构。

986
00:44:28,860 --> 00:44:32,620
现在，这里可能有一堆读线程和其他线程在做一些事情，

987
00:44:33,030 --> 00:44:35,110
但这没有关系，因为它会这样，

988
00:44:35,690 --> 00:44:39,630
如果他们的修改会导致我们进行拆分或合并，

989
00:44:39,770 --> 00:44:41,790
然后向上整个到 root ，

990
00:44:41,900 --> 00:44:44,040
他们仍然必须在这上面持有写 latch 。

991
00:44:45,450 --> 00:44:47,765
所以，主要的结论是，

992
00:44:47,765 --> 00:44:49,210
我们希望尽快释放 latch ，

993
00:44:49,740 --> 00:44:51,320
所以，我们希望释放 latch ，

994
00:44:51,320 --> 00:44:52,510
它会最大地，

995
00:44:52,770 --> 00:44:57,820
释放我们数据结构中的最大多数的 worker ，

996
00:44:58,110 --> 00:45:00,040
所以我们总是希望从上到下释放。

997
00:45:03,660 --> 00:45:04,715
好的，然后我们下到这里，

998
00:45:04,715 --> 00:45:06,550
我们得到 H 上的写 latch ，

999
00:45:06,900 --> 00:45:09,790
继续，做我们的删除，我们就完成了。

1000
00:45:12,710 --> 00:45:13,950
好的，让我们来看另一个例子，

1001
00:45:13,970 --> 00:45:15,090
我将插入 45 ，

1002
00:45:15,110 --> 00:45:15,750
相同的想法，

1003
00:45:15,920 --> 00:45:18,030
我获得 root 上的写 latch ，在 A 上面，

1004
00:45:18,290 --> 00:45:19,110
向下到 B ，

1005
00:45:19,340 --> 00:45:20,260
在这一点上，

1006
00:45:20,260 --> 00:45:23,310
我知道如果，

1007
00:45:23,600 --> 00:45:25,200
树上我下面的任何东西，

1008
00:45:25,430 --> 00:45:26,610
如果它必须拆分，

1009
00:45:26,780 --> 00:45:30,120
我在 B 中有空间容纳另一个键，

1010
00:45:30,440 --> 00:45:32,970
所以我可以释放 A 上面的 latch ，

1011
00:45:33,870 --> 00:45:35,170
下到这里的 D ，

1012
00:45:35,430 --> 00:45:37,060
现在，D 完全满了，

1013
00:45:37,320 --> 00:45:39,040
我不知道在树上我下面是什么，

1014
00:45:39,120 --> 00:45:40,210
因为我还没有去过那里，

1015
00:45:40,890 --> 00:45:43,360
所以这一点上，释放是不安全的，

1016
00:45:43,380 --> 00:45:44,540
释放 D 上的 latch ，

1017
00:45:44,540 --> 00:45:45,190
直到我向下，

1018
00:45:45,420 --> 00:45:46,840
现在我可以看到，

1019
00:45:48,270 --> 00:45:51,520
插入到 I ，不会在节点 I 上引起拆分，

1020
00:45:51,690 --> 00:45:54,400
所以我可以继续，释放 B 和 D 上的 latch ，

1021
00:45:55,020 --> 00:45:55,840
从上到下，

1022
00:45:57,600 --> 00:45:58,510
我可以插入我的键。

1023
00:46:02,060 --> 00:46:04,630
好的，让我们看一个有拆分的。

1024
00:46:05,070 --> 00:46:07,570
为了简单起见，我们可以忽略兄弟指针，

1025
00:46:07,860 --> 00:46:11,915
所以我做的是插入 25 ， B 是安全的，

1026
00:46:11,915 --> 00:46:13,550
我要释放 A 上的 latch ，

1027
00:46:13,550 --> 00:46:15,110
我要下到 C ， C 是安全的，

1028
00:46:15,110 --> 00:46:16,450
释放 B 上的 latch ，

1029
00:46:17,100 --> 00:46:19,100
然后我下到 F ， F 不是安全的，

1030
00:46:20,340 --> 00:46:23,510
所以我不能释放 C 上的 latch ，

1031
00:46:24,130 --> 00:46:25,310
现在我需要进行拆分，

1032
00:46:25,720 --> 00:46:30,290
这个拆分将导致我在节点 C 中插入一个新条目，

1033
00:46:31,500 --> 00:46:32,530
所以我会继续，

1034
00:46:32,910 --> 00:46:36,320
添加我的新节点 J ，

1035
00:46:36,320 --> 00:46:37,750
我没有空间了，因为这个幻灯片，

1036
00:46:38,010 --> 00:46:40,060
再次，我们现在忽略兄弟指针，

1037
00:46:40,470 --> 00:46:42,860
继续，现在更新 C ，

1038
00:46:42,860 --> 00:46:44,320
现在可以包括这个指针，

1039
00:46:44,900 --> 00:46:47,840
然后，一旦我应用了所有这些更改，

1040
00:46:47,840 --> 00:46:49,750
然后我释放从上到下的 latch 。

1041
00:46:53,150 --> 00:46:54,370
我之前已经给出了这个答案，

1042
00:46:54,370 --> 00:46:56,635
但是对于所有这些场景，我做的第一件事是什么，

1043
00:46:56,635 --> 00:46:58,165
当我想要进行更新、插入和删除时，

1044
00:46:58,165 --> 00:46:59,490
你必须做的第一件事是什么？

1045
00:47:01,700 --> 00:47:06,900
获取 root 节点的 latch 。

1046
00:47:08,500 --> 00:47:09,990
是的，没错，

1047
00:47:09,990 --> 00:47:11,250
但这现在是一个瓶颈，

1048
00:47:11,250 --> 00:47:14,060
因为它基本上一个单线程数据结构，

1049
00:47:14,380 --> 00:47:16,100
几乎每个都必须进入系统，

1050
00:47:16,970 --> 00:47:18,240
抱歉，进入我们的数据结构，

1051
00:47:18,320 --> 00:47:19,800
首先要做的是，

1052
00:47:20,270 --> 00:47:22,790
获取 root 节点上写模式的 latch ，

1053
00:47:23,140 --> 00:47:25,140
如果你做读取，它是不兼容的，

1054
00:47:25,140 --> 00:47:26,420
所以它也会阻塞所有读取者。

1055
00:47:28,630 --> 00:47:29,415
再次，它是正确的，

1056
00:47:29,415 --> 00:47:30,435
但是出于性能的原因，

1057
00:47:30,435 --> 00:47:32,860
它不是很理想。

1058
00:47:33,830 --> 00:47:37,020
所以大家常用的技术就是，

1059
00:47:37,550 --> 00:47:40,530
我现在要谈的这个乐观的 latch 方案，

1060
00:47:41,480 --> 00:47:42,805
我不认为这个算法有名字，

1061
00:47:42,805 --> 00:47:43,600
它来自这篇论文，

1062
00:47:43,600 --> 00:47:46,375
来自于 70 年代，

1063
00:47:46,375 --> 00:47:47,220
上面有日期吗，

1064
00:47:48,570 --> 00:47:49,900
7 ，它显示 77 ，是的，

1065
00:47:49,980 --> 00:47:51,860
来自两个 IBM 的人， Bayer 和 Schkolnick ，

1066
00:47:51,860 --> 00:47:53,435
有时它被称为 Bayer-Schkolnick 算法，

1067
00:47:53,435 --> 00:47:54,910
这说起来有点麻烦，

1068
00:47:54,960 --> 00:47:57,330
但是，它基于这种观察，

1069
00:47:57,410 --> 00:48:00,210
你的大多数线程和你的大多数 worker ，

1070
00:48:00,260 --> 00:48:06,870
他们的操作不会导致你的 B+ 树节点的拆分或合并，

1071
00:48:07,220 --> 00:48:08,545
同样，我在这里的例子中，

1072
00:48:08,545 --> 00:48:10,375
我展示了带有两个键的节点，

1073
00:48:10,375 --> 00:48:11,490
因为这是适合幻灯片的，

1074
00:48:11,690 --> 00:48:13,050
但在实际系统中，

1075
00:48:13,670 --> 00:48:16,195
节点的大小将是数据库的页面大小，

1076
00:48:16,195 --> 00:48:18,030
比如 8 千字节， 16 千字节，

1077
00:48:18,350 --> 00:48:19,435
你可以存储很多键，

1078
00:48:19,435 --> 00:48:21,085
大多数情况下，你做一堆插入，

1079
00:48:21,085 --> 00:48:23,460
这不会导致任何拆分，

1080
00:48:23,960 --> 00:48:25,060
对于删除也是如此。

1081
00:48:26,110 --> 00:48:29,300
所以，如果你假设拆分合并是罕见的，

1082
00:48:29,920 --> 00:48:33,290
那么，不是一直向下持有写 latch ，

1083
00:48:33,820 --> 00:48:36,920
即使你使用 latch 耦合方案，

1084
00:48:37,865 --> 00:48:39,490
你要一直向下持有读 latch ，

1085
00:48:40,550 --> 00:48:44,220
直到到达叶子节点，叶子节点的正上方，

1086
00:48:44,300 --> 00:48:45,745
然后现在检查，

1087
00:48:45,745 --> 00:48:48,780
不会进行拆分或合并的假设是否正确，

1088
00:48:49,690 --> 00:48:50,660
如果是这样，

1089
00:48:51,460 --> 00:48:53,660
那么你继续，获取叶子节点为写模式，

1090
00:48:53,860 --> 00:48:55,250
然后进行更改，

1091
00:48:55,600 --> 00:48:56,360
但是如果你错了，

1092
00:48:56,830 --> 00:48:59,625
你只需重新开始，然后采取悲观的方法，

1093
00:48:59,625 --> 00:49:01,100
你一直向下持有写 latch 。

1094
00:49:02,480 --> 00:49:04,180
所以，这将是一个共同的主题，

1095
00:49:04,180 --> 00:49:06,780
不仅是在数据库，而且在一系列不同的系统中，

1096
00:49:07,310 --> 00:49:09,205
这是一种乐观的方案，

1097
00:49:09,205 --> 00:49:11,610
你假设不会有任何问题，

1098
00:49:12,050 --> 00:49:13,980
你会以一种快速的方式，

1099
00:49:14,210 --> 00:49:17,610
在你的系统中做出一些改变或做一些事情，

1100
00:49:18,260 --> 00:49:18,860
然后，如果你错了，

1101
00:49:18,860 --> 00:49:21,160
你就把它倒回去，然后处理它。

1102
00:49:22,760 --> 00:49:25,750
Intel 有这个，它被称为 TSX ，

1103
00:49:25,750 --> 00:49:28,800
我们在 CPU 本身就有这个，

1104
00:49:28,820 --> 00:49:29,340
我想，

1105
00:49:29,960 --> 00:49:31,265
这是一个 bug ，我想他们把它关掉了，

1106
00:49:31,265 --> 00:49:32,330
它可能重新打开，

1107
00:49:32,330 --> 00:49:34,715
但它就像这种乐观内存的东西，

1108
00:49:34,715 --> 00:49:36,910
你可以有一个临界区，

1109
00:49:36,930 --> 00:49:42,340
假设你不会在某个临界区有任何冲突，

1110
00:49:42,840 --> 00:49:45,335
然后当你去应用更改时，

1111
00:49:45,335 --> 00:49:46,370
然后你只需检查，

1112
00:49:46,370 --> 00:49:49,640
查看那个假设是否正确，

1113
00:49:49,810 --> 00:49:51,560
如果不正确，它会自动回退。

1114
00:49:52,900 --> 00:49:54,315
但是同样，我们会看到这个，

1115
00:49:54,315 --> 00:49:55,880
当我们讨论[]事务时，

1116
00:49:56,320 --> 00:49:57,440
这是一种非常常见的技术，

1117
00:49:57,550 --> 00:49:58,545
你做快速的事情，

1118
00:49:58,545 --> 00:50:00,380
因为大多数时候不会有任何问题，

1119
00:50:00,760 --> 00:50:01,440
如果你错了，

1120
00:50:01,440 --> 00:50:03,890
那么你必须回滚并再次尝试。

1121
00:50:05,430 --> 00:50:07,685
好的，所以，有了这个更好的 latch 方案，

1122
00:50:07,685 --> 00:50:10,510
对于查找，这与以前是相同的，

1123
00:50:10,950 --> 00:50:12,130
对于插入和删除，

1124
00:50:12,330 --> 00:50:16,235
我们使用，我们基本上做搜索，

1125
00:50:16,235 --> 00:50:18,700
持有写 latch ，抱歉，读 latch 一直向下，

1126
00:50:19,260 --> 00:50:22,090
直到我们位于叶子节点的上一级别，

1127
00:50:22,550 --> 00:50:25,450
我的意思是，我们知道我们在数据结构中的位置，

1128
00:50:25,450 --> 00:50:29,340
因为，我们可以跟踪我们向下的级别，

1129
00:50:30,770 --> 00:50:33,000
不论是在页面中或者一个简单的计数器也可以。

1130
00:50:34,650 --> 00:50:38,210
你可以获取叶子节点正上方的级别，

1131
00:50:38,210 --> 00:50:40,330
你在写模式下获取叶子节点，

1132
00:50:40,860 --> 00:50:42,220
然后你检查它是否安全，

1133
00:50:42,540 --> 00:50:43,325
如果它是安全的，

1134
00:50:43,325 --> 00:50:45,790
然后你释放你以前拿到的所有读 latch ，

1135
00:50:47,260 --> 00:50:48,440
应用你的更改，你就完成了，

1136
00:50:48,640 --> 00:50:49,430
如果你错了，

1137
00:50:49,570 --> 00:50:51,270
那么你只要释放你所有的 latch ，

1138
00:50:51,270 --> 00:50:53,420
然后回去持有写 latch 一直向下。

1139
00:50:54,100 --> 00:50:56,150
你可以再使用乐观的方案，

1140
00:50:56,230 --> 00:50:57,920
因为你假设下次你回来的时候，

1141
00:50:58,060 --> 00:50:58,820
一切都会安全的，

1142
00:50:59,110 --> 00:51:00,050
这取决于实现。

1143
00:51:00,920 --> 00:51:03,080
所以，这在争用较少的环境中工作得非常好，

1144
00:51:03,080 --> 00:51:06,520
因为你显然认为不会有任何冲突，

1145
00:51:06,540 --> 00:51:07,810
而且大多数情况下你是正确的，

1146
00:51:07,830 --> 00:51:09,130
所以，事情运行得更快。

1147
00:51:11,570 --> 00:51:12,900
所以让我们回到前面的例子，

1148
00:51:13,010 --> 00:51:14,580
让我们删除键 38 ，

1149
00:51:15,260 --> 00:51:19,980
不是以写 latch 模式持有根节点，

1150
00:51:20,600 --> 00:51:22,590
持有读模式，继续向下，

1151
00:51:22,880 --> 00:51:24,000
所以我下到了 D ，

1152
00:51:24,440 --> 00:51:27,840
现在 D 意识到它比叶子节点高一级，

1153
00:51:27,980 --> 00:51:32,520
所以我想从节点 H 中删除键 38 ，

1154
00:51:32,750 --> 00:51:34,470
所以我将 H 放入写模式，

1155
00:51:34,730 --> 00:51:35,760
检查它是否安全，

1156
00:51:36,050 --> 00:51:37,980
它是的，我可以删除它，

1157
00:51:38,630 --> 00:51:40,320
我知道我不会做任何，

1158
00:51:41,000 --> 00:51:42,840
我不会做任何合并。

1159
00:51:43,880 --> 00:51:44,910
所以，再次，最好的情况是，

1160
00:51:45,110 --> 00:51:46,770
我遍历数据结构，

1161
00:51:46,880 --> 00:51:49,590
几乎就像我在做读取，

1162
00:51:50,440 --> 00:51:52,770
所以，我可以有最大的并行度，

1163
00:51:52,970 --> 00:51:54,235
但只有在底部，

1164
00:51:54,235 --> 00:51:56,340
我才会检查这个假设是否正确。

1165
00:51:58,790 --> 00:52:00,750
看看如何做插入 25 ，

1166
00:52:01,100 --> 00:52:03,210
再次，把 root 放入读模式，

1167
00:52:03,350 --> 00:52:04,380
把 B 放入读模式，

1168
00:52:04,610 --> 00:52:07,590
当我释放 latch 向下时，做 latch 耦合，

1169
00:52:07,970 --> 00:52:09,750
现在我在这里进入 F ，

1170
00:52:10,130 --> 00:52:10,920
在 F 的情况下，

1171
00:52:11,450 --> 00:52:12,720
因为我们要做插入，

1172
00:52:12,980 --> 00:52:14,850
F 没有更多的空间，所以它是不安全的，

1173
00:52:15,290 --> 00:52:17,280
所以，我们必须重新启动整个操作，

1174
00:52:17,660 --> 00:52:19,650
然后在下降的过程中持有写 latch 。

1175
00:52:24,050 --> 00:52:24,810
巧妙的方法，对吧？

1176
00:52:27,720 --> 00:52:28,120
好的。

1177
00:52:30,810 --> 00:52:34,280
所以，在我到目前为止展示的所有这些例子中，

1178
00:52:34,960 --> 00:52:36,540
我们只朝一个方向走，

1179
00:52:38,100 --> 00:52:39,490
我们只是从上到下，

1180
00:52:40,220 --> 00:52:42,430
就像我说的，这里没有任何死锁，

1181
00:52:42,430 --> 00:52:44,610
因为每个人都会到顶部，

1182
00:52:44,750 --> 00:52:46,530
它们总是从同一个点开始，然后向下，

1183
00:52:46,940 --> 00:52:48,625
这里没有，就像我上一节课说的，

1184
00:52:48,625 --> 00:52:50,100
没有指向你父节点的指针，

1185
00:52:50,760 --> 00:52:51,950
你不能向上回去，

1186
00:52:52,240 --> 00:52:54,200
因为那样可能会发生冲突。

1187
00:52:55,270 --> 00:52:56,990
再次，因为我们是 B+ 树，

1188
00:52:57,820 --> 00:52:59,210
我们可以有兄弟指针。

1189
00:53:00,090 --> 00:53:01,220
现在我们有一个挑战，

1190
00:53:01,220 --> 00:53:05,240
我们可以让一个线程走一条路，

1191
00:53:05,240 --> 00:53:06,430
另一个线程走另一条路，

1192
00:53:06,540 --> 00:53:11,610
它们都持有用于另一个线程想要的东西的 latch 。

1193
00:53:12,730 --> 00:53:14,390
所以现在我们要处理那个场景，

1194
00:53:15,610 --> 00:53:17,450
原始的 B+ 树论文，这不是一个问题，

1195
00:53:18,600 --> 00:53:20,585
但是来自 CMU 的 B-Link 的东西，

1196
00:53:20,585 --> 00:53:21,755
这就是他们添加兄弟指针的地方，

1197
00:53:21,755 --> 00:53:22,930
这就是你可能会有死锁的地方。

1198
00:53:24,710 --> 00:53:25,840
让我们来看一个简单的例子。

1199
00:53:26,970 --> 00:53:28,480
所以我想要线程 1 ，

1200
00:53:28,710 --> 00:53:30,460
他们想要找到所有小于 4 的键，

1201
00:53:31,350 --> 00:53:33,820
所以我将在读模式中获取 root ，

1202
00:53:34,260 --> 00:53:36,100
然后在读模式中获取 C ，

1203
00:53:36,540 --> 00:53:37,510
然后我们假设，

1204
00:53:39,600 --> 00:53:41,650
然后一旦扫描完毕，

1205
00:53:41,700 --> 00:53:43,330
所以，它将跟随兄弟指针，

1206
00:53:43,530 --> 00:53:45,310
所以，就像以前一样，我持有，

1207
00:53:45,390 --> 00:53:46,480
无论我在哪个节点，

1208
00:53:46,650 --> 00:53:49,420
我持有它在当前我有的 latch 模式下，

1209
00:53:50,130 --> 00:53:54,100
然后试着获取我想去的地方的 latch ，

1210
00:53:54,420 --> 00:53:55,310
所以，在这种情况下，

1211
00:53:55,310 --> 00:53:57,730
再次，从 C 到 B ，

1212
00:53:58,080 --> 00:53:59,380
所以我持有 C 上的 latch ，

1213
00:53:59,610 --> 00:54:00,610
获取 B 上的 latch ，

1214
00:54:00,960 --> 00:54:02,900
移动到这里，然后我可以释放 C 上的 latch ，

1215
00:54:02,900 --> 00:54:06,330
然后做任何我需要做的事情。

1216
00:54:07,040 --> 00:54:08,435
所以协议基本上是一样的，

1217
00:54:08,435 --> 00:54:12,580
尽管我们现在是水平移动而不是垂直移动。

1218
00:54:13,630 --> 00:54:14,030
是的。

1219
00:54:14,200 --> 00:54:25,170
我们马上就到那里，是的，

1220
00:54:25,220 --> 00:54:26,070
相同的调度，是的。

1221
00:54:27,260 --> 00:54:29,910
所以，读模式是可交换的，

1222
00:54:29,960 --> 00:54:32,070
所以我可以有两个线程在同一时间读取，

1223
00:54:32,510 --> 00:54:35,740
首先，线程往下到 C ，

1224
00:54:35,740 --> 00:54:36,750
第二，线程下到 B ，

1225
00:54:36,920 --> 00:54:38,220
它们想要彼此交叉，

1226
00:54:38,450 --> 00:54:39,430
在这种情况下，

1227
00:54:39,430 --> 00:54:42,390
它们拿着的两个 latch 是可交换的，

1228
00:54:43,180 --> 00:54:46,850
所以，它们都可以做任何它们需要做的事情。

1229
00:54:49,335 --> 00:54:49,670
那是好的。

1230
00:54:51,710 --> 00:54:52,525
所以我们现在做，

1231
00:54:52,525 --> 00:54:53,460
当我们有一个，

1232
00:54:55,170 --> 00:54:57,160
其中一个想要写入，一个想要读取。

1233
00:54:57,860 --> 00:54:59,820
所以 T1 想要删除键 4 ，

1234
00:54:59,990 --> 00:55:02,010
T2 想要找到所有大于 1 的键。

1235
00:55:02,870 --> 00:55:04,200
所以，它们同时启动，

1236
00:55:04,430 --> 00:55:06,625
假设我们进行乐观锁耦合，

1237
00:55:06,625 --> 00:55:08,430
我刚才说的是 latch 耦合，

1238
00:55:08,510 --> 00:55:16,120
它们都以读模式从 root 开始，

1239
00:55:16,410 --> 00:55:19,270
线程 2 向下，把 B 带入读模式，

1240
00:55:19,500 --> 00:55:22,930
线程 C 向下，

1241
00:55:23,280 --> 00:55:26,920
抱歉，线程 1 向下，把 C 放入写模式，

1242
00:55:27,240 --> 00:55:29,540
这是它想要删除的键。

1243
00:55:30,010 --> 00:55:33,710
但是现在线程 2 在叶子节点上扫描，

1244
00:55:34,120 --> 00:55:37,700
它想要在读模式下获取 C 的 latch ，

1245
00:55:38,020 --> 00:55:38,930
但它不能，

1246
00:55:39,220 --> 00:55:42,260
因为 T1 在写模式下持有它，

1247
00:55:44,270 --> 00:55:46,950
所以我们必须决定我们想要在这里做什么。

1248
00:55:48,000 --> 00:55:50,740
T2 对 T1 一无所知，

1249
00:55:51,620 --> 00:55:53,995
因为我说过，没有集中化的数据结构来说明，

1250
00:55:53,995 --> 00:55:54,955
这是正在运行的线程，

1251
00:55:54,955 --> 00:55:56,490
这是他们正在做的，

1252
00:55:56,900 --> 00:55:58,780
它所知道的是，

1253
00:55:58,780 --> 00:56:01,380
在我想要访问的另一个节点上有一个 latch ，

1254
00:56:01,580 --> 00:56:02,665
它目前处于写模式，

1255
00:56:02,665 --> 00:56:04,440
与我想要设置的模式不兼容，

1256
00:56:04,880 --> 00:56:06,000
所以你必须做些什么。

1257
00:56:08,070 --> 00:56:09,640
那么 T2 能在这里做些什么？

1258
00:56:13,160 --> 00:56:14,730
等待，那是一个选项，还有什么？

1259
00:56:17,940 --> 00:56:18,230
那是什么？

1260
00:56:19,375 --> 00:56:26,190
杀死自己，你在看幻灯片吗，好的，

1261
00:56:26,190 --> 00:56:26,780
第三种选择是什么？

1262
00:56:30,180 --> 00:56:33,010
去另一个线程，试图杀死它，

1263
00:56:34,410 --> 00:56:35,470
从它上面取下 latch 。

1264
00:56:37,870 --> 00:56:39,290
那么，你认为在这里什么是一个好主意？

1265
00:56:40,540 --> 00:56:42,470
是什么，等待，等待多久？

1266
00:56:48,740 --> 00:56:49,410
好的，永远，

1267
00:56:52,820 --> 00:56:53,370
多久，

1268
00:56:54,000 --> 00:56:54,665
但你怎么知道。

1269
00:56:58,940 --> 00:56:59,840
但那只是等待，

1270
00:56:59,840 --> 00:57:02,570
它只是旋转，直到 latch 可用，就像，

1271
00:57:06,030 --> 00:57:06,670
这话怎么说呢？

1272
00:57:08,030 --> 00:57:11,850
你知道 T1 在做什么吗，

1273
00:57:13,130 --> 00:57:15,070
不，我们什么都不知道。

1274
00:57:20,390 --> 00:57:20,970
你知道吗，

1275
00:57:21,350 --> 00:57:23,130
你知道它是在写模式，

1276
00:57:23,270 --> 00:57:24,150
但它将需要多长时间？

1277
00:57:32,130 --> 00:57:32,530
怎么做?

1278
00:57:34,240 --> 00:57:34,680
哪个，

1279
00:57:34,680 --> 00:57:35,925
比如，从你的调度中杀死自己，

1280
00:57:35,925 --> 00:57:36,960
从你的调度中杀死其他线程，

1281
00:57:36,960 --> 00:57:37,580
你想做什么，

1282
00:57:39,390 --> 00:57:40,990
她说关掉杀死自己，太棒了，

1283
00:57:41,970 --> 00:57:42,730
你怎么做，

1284
00:57:45,580 --> 00:57:46,100
是什么？

1285
00:57:55,220 --> 00:57:55,645
你是什么意思，

1286
00:57:55,645 --> 00:57:56,760
把你过去做的每一件事都记下来。

1287
00:58:08,990 --> 00:58:10,590
是的，听起来很昂贵，

1288
00:58:14,660 --> 00:58:15,750
正常的时间是多少？

1289
00:58:20,520 --> 00:58:22,750
他说，等待写入发生的平均时间。

1290
00:58:26,680 --> 00:58:29,180
但是你没有，

1291
00:58:29,350 --> 00:58:30,840
在我这个简单的例子中，

1292
00:58:30,840 --> 00:58:32,000
因为[]和幻灯片，

1293
00:58:32,410 --> 00:58:33,890
这里有两个叶子节点，

1294
00:58:34,680 --> 00:58:37,270
如果这里有很多叶子节点一直到这里，

1295
00:58:37,980 --> 00:58:41,405
我得让所有的人都保持在写模式，

1296
00:58:41,405 --> 00:58:42,820
因为我希望我的更改自动发生，

1297
00:58:42,900 --> 00:58:45,670
所以我不知道其他线程是否继续朝着相反的方向前进，

1298
00:58:45,990 --> 00:58:47,830
我不喜欢什么是正常时间，你不知道。

1299
00:58:53,320 --> 00:58:55,410
他说放弃你的写锁，让另一个线程来读，

1300
00:58:56,460 --> 00:58:57,245
但你怎么知道，

1301
00:58:57,245 --> 00:58:58,420
你怎么知道它们在等你，

1302
00:58:59,040 --> 00:59:00,140
比如，如果你是 T1 ，

1303
00:59:00,490 --> 00:59:02,420
你怎么知道其他线程想获取你的 latch 。

1304
00:59:04,340 --> 00:59:04,740
是的。

1305
00:59:11,270 --> 00:59:12,030
是的，就是这样，太棒了。

1306
00:59:12,980 --> 00:59:17,035
所以你应该杀死自己，

1307
00:59:17,035 --> 00:59:18,865
杀死其他线程是很困难的，

1308
00:59:18,865 --> 00:59:20,820
因为你如何实现它，

1309
00:59:20,840 --> 00:59:22,855
你能发送中断[]吗，

1310
00:59:22,855 --> 00:59:24,360
那很昂贵，那是一个系统调用，

1311
00:59:25,730 --> 00:59:26,965
有没有一个标志，

1312
00:59:26,965 --> 00:59:28,590
你会说，我应该杀死自己吗，

1313
00:59:28,910 --> 00:59:30,250
你必须每隔一段时间检查一次，

1314
00:59:30,250 --> 00:59:30,960
这怎么工作，

1315
00:59:32,840 --> 00:59:34,860
检查其他内存位置，

1316
00:59:34,860 --> 00:59:35,985
然后，你得到了什么，

1317
00:59:35,985 --> 00:59:36,500
你得到，

1318
00:59:36,520 --> 00:59:40,250
你不知道另一个线程做了多少工作，

1319
00:59:40,570 --> 00:59:45,165
你不知道他是否会中止和回退，

1320
00:59:45,165 --> 00:59:47,930
这比你自己中止代价要高得多，

1321
00:59:48,540 --> 00:59:50,630
在这一点上你什么都不知道。

1322
00:59:51,390 --> 00:59:55,690
所以最好的办法就是杀死自己，

1323
00:59:56,940 --> 00:59:59,660
然后也许你也可以在开始的时候等待一段时间，

1324
00:59:59,660 --> 01:00:01,000
然后立即放弃，

1325
01:00:01,380 --> 01:00:04,070
取决于你需要做什么。

1326
01:00:05,430 --> 01:00:07,115
所以这是最简单的事情，

1327
01:00:07,115 --> 01:00:09,070
事实证明，这是最好的事情，

1328
01:00:09,210 --> 01:00:11,195
在大多数情况下，所有情况下，

1329
01:00:11,195 --> 01:00:14,030
因为再次，你对线程一无所知，

1330
01:00:14,030 --> 01:00:16,150
你不能与另一个线程通信，因为这很昂贵，

1331
01:00:17,365 --> 01:00:19,530
你最好放弃，然后重新开始。

1332
01:00:20,870 --> 01:00:21,270
是的。

1333
01:00:31,870 --> 01:00:32,660
所以他的说法是，

1334
01:00:34,790 --> 01:00:37,360
你也必须等待或杀死自己，

1335
01:00:37,360 --> 01:00:40,470
当你在做树的自上而下的遍历时，

1336
01:00:40,700 --> 01:00:43,885
如果我试图获取下一个节点上的 latch ，

1337
01:00:43,885 --> 01:00:45,660
但它已经被持有了，我应该做什么，

1338
01:00:45,770 --> 01:00:47,130
这里是同样的情况，

1339
01:00:47,690 --> 01:00:49,800
同样的情况，但在这种情况下，你不是，

1340
01:00:52,070 --> 01:00:53,230
你不会死锁。

1341
01:00:54,160 --> 01:00:54,700
问题是，

1342
01:00:54,700 --> 01:00:57,870
如果 T2 想要获取 latch ，

1343
01:00:58,460 --> 01:00:59,850
T1 想要获取 B 的 latch ，

1344
01:01:00,110 --> 01:01:02,160
T2 想要获取 C 的 latch ，

1345
01:01:02,840 --> 01:01:03,720
这是一个死锁，

1346
01:01:03,890 --> 01:01:09,455
你不知道，这是一个死锁或者只是争抢了一些 latch ，

1347
01:01:09,455 --> 01:01:13,060
所以最好的办法就是立即放弃。

1348
01:01:13,640 --> 01:01:14,860
这意味着你可能会有这样一种情况，

1349
01:01:14,860 --> 01:01:16,840
你持有 latch ，我持有 latch ，

1350
01:01:16,840 --> 01:01:18,025
我们中的只有一个人应该放弃，

1351
01:01:18,025 --> 01:01:20,430
但我们最终既放弃又杀死自己。

1352
01:01:21,100 --> 01:01:28,530
但是，维护关于谁在以何种方式等待什么的元数据的成本，

1353
01:01:28,940 --> 01:01:33,060
在假设没有争用的常规情况下要更昂贵。

1354
01:01:42,300 --> 01:01:43,750
是的，所以就是这个，

1355
01:01:43,890 --> 01:01:45,140
所以它们都在读取，

1356
01:01:45,140 --> 01:01:47,150
但假设他们都在写入，

1357
01:01:47,150 --> 01:01:51,510
我需要更新所有的大于 1 的键，

1358
01:01:51,680 --> 01:01:53,700
他需要更新小于 4 的键，

1359
01:01:53,750 --> 01:01:55,410
我要往这边走，他要往那边走，

1360
01:01:55,940 --> 01:01:57,480
我们有一个死锁。

1361
01:01:57,980 --> 01:02:03,415
就 latch 而言，

1362
01:02:03,415 --> 01:02:05,620
我试图在这个方向上获取 latch ，

1363
01:02:05,620 --> 01:02:07,110
试图在那个方向上获取 latch ，

1364
01:02:07,340 --> 01:02:08,160
我们死锁了。

1365
01:02:11,500 --> 01:02:13,280
你的问题是如何防止他们两个都杀死自己。

1366
01:02:14,130 --> 01:02:16,240
所以，你不能，

1367
01:02:17,050 --> 01:02:18,435
因为我不知道你的存在，

1368
01:02:18,435 --> 01:02:19,610
我不知道你做了什么，

1369
01:02:22,100 --> 01:02:25,000
如果你只考虑一般的计算机，

1370
01:02:25,000 --> 01:02:26,845
比如，不太可能，

1371
01:02:26,845 --> 01:02:29,220
你和我在我们的线程步调一致，

1372
01:02:29,420 --> 01:02:31,945
以及完全相同的周期数量，

1373
01:02:31,945 --> 01:02:35,230
我们都会试图获得一个 latch ，然后就会死锁，

1374
01:02:35,230 --> 01:02:35,970
我们要杀死对方，

1375
01:02:36,170 --> 01:02:37,885
这是一种竞态条件，

1376
01:02:37,885 --> 01:02:39,235
但它是罕见的，

1377
01:02:39,235 --> 01:02:40,140
但你无法预防它，

1378
01:02:40,190 --> 01:02:42,600
因为预防它的成本太高了。

1379
01:02:48,610 --> 01:02:49,370
这种说法是，

1380
01:02:50,200 --> 01:02:51,530
从哲学的角度来看，

1381
01:02:52,060 --> 01:02:53,595
杀死另一个会更有效率，

1382
01:02:53,595 --> 01:02:54,290
这会更好吗？

1383
01:02:57,010 --> 01:02:58,125
这不是一个哲学问题，

1384
01:02:58,125 --> 01:02:59,210
它是，直截了当地，是不是更好，

1385
01:03:00,850 --> 01:03:04,010
比如，你拿走他们的钱包，无论你喜欢的什么。

1386
01:03:06,260 --> 01:03:07,480
这是一个玩具例子，

1387
01:03:07,480 --> 01:03:08,665
它只有一个节点，

1388
01:03:08,665 --> 01:03:09,840
如果你想一想，

1389
01:03:10,370 --> 01:03:13,390
我不知道你做了什么，

1390
01:03:13,390 --> 01:03:14,770
你不知道我做了什么，

1391
01:03:14,770 --> 01:03:16,410
如果我们能追踪到这个，

1392
01:03:16,940 --> 01:03:18,940
那么我们可能会决定，

1393
01:03:18,940 --> 01:03:22,020
好的，你持有五个 latch ，我持有一个，

1394
01:03:22,280 --> 01:03:23,460
最好杀死我，

1395
01:03:23,780 --> 01:03:26,190
因为你需要等好长时间才能拿到那五个 latch ，

1396
01:03:26,390 --> 01:03:30,240
这是高级别的，当我们在做事务时，

1397
01:03:31,010 --> 01:03:32,980
他们会确定谁获得优先权，

1398
01:03:32,980 --> 01:03:34,710
根据到目前为止完成的工作量，

1399
01:03:34,880 --> 01:03:35,815
在这个最低级别，

1400
01:03:35,815 --> 01:03:38,470
latch 应该是细粒度和小的，

1401
01:03:38,470 --> 01:03:39,810
最好杀死自己。

1402
01:03:40,290 --> 01:03:40,780
好的。

1403
01:03:58,690 --> 01:03:59,220
这是可能的，

1404
01:03:59,220 --> 01:03:59,900
所以问题是，

1405
01:04:00,100 --> 01:04:02,600
你能不能饿着一个线程，

1406
01:04:03,070 --> 01:04:04,095
你是想用这个词吗，

1407
01:04:04,095 --> 01:04:05,055
你能饿着一个线程，

1408
01:04:05,055 --> 01:04:06,320
因为每一次你试图得到某样东西的时候，

1409
01:04:06,730 --> 01:04:08,010
它都不能，

1410
01:04:08,010 --> 01:04:08,670
因为里面有别的东西，

1411
01:04:08,670 --> 01:04:09,530
你能饿着它吗，是的。

1412
01:04:10,680 --> 01:04:11,080
所以，

1413
01:04:12,580 --> 01:04:13,910
我想我有一个关于这个的幻灯片。

1414
01:04:16,060 --> 01:04:16,820
是的，所以，

1415
01:04:19,300 --> 01:04:19,910
这里有，

1416
01:04:20,080 --> 01:04:22,785
我稍等一下回答你的问题，

1417
01:04:22,785 --> 01:04:26,990
latch 不会有任何东西来为我们处理死锁，

1418
01:04:27,160 --> 01:04:30,530
它也不会有任何防止饥饿的东西，

1419
01:04:31,210 --> 01:04:32,780
在读写 latch 中，

1420
01:04:33,160 --> 01:04:35,580
你可以给写入者或读取者设置优先级，

1421
01:04:35,580 --> 01:04:38,210
或者你想要执行先进先出或循环调度，

1422
01:04:39,190 --> 01:04:42,140
但是在内部有一个高级别构造调度器，

1423
01:04:42,370 --> 01:04:46,820
哦，这个 worker 试图运行这个查询，

1424
01:04:47,230 --> 01:04:48,830
试图访问这个数据结构，

1425
01:04:49,120 --> 01:04:50,190
但它一直被中止，

1426
01:04:50,190 --> 01:04:51,500
我知道它被中止，

1427
01:04:52,870 --> 01:04:55,400
因为它会返回一个重试消息，

1428
01:04:55,840 --> 01:04:59,535
所以，也许我想取消其他同时运行的 worker 的调度，

1429
01:04:59,535 --> 01:05:00,710
以确保我总是能通过，

1430
01:05:01,510 --> 01:05:03,080
它有了一种处理这一问题的方法，

1431
01:05:04,410 --> 01:05:06,670
大多数系统都会，

1432
01:05:07,530 --> 01:05:09,425
让耶稣掌舵吧，不管你想用什么短语，

1433
01:05:09,425 --> 01:05:11,800
让它去吧，

1434
01:05:12,780 --> 01:05:16,220
因为最终你会通过的。

1435
01:05:16,220 --> 01:05:17,680
现在，如果我有一个，

1436
01:05:18,630 --> 01:05:22,130
一千个查询试图同时运行，

1437
01:05:22,130 --> 01:05:23,620
试图全部更新相同的键，

1438
01:05:23,940 --> 01:05:26,620
没有神奇的调度器能够处理这个，

1439
01:05:27,060 --> 01:05:28,390
所有东西都会冲突，

1440
01:05:28,590 --> 01:05:30,490
最终变成了一个单线程系统。

1441
01:05:31,380 --> 01:05:33,890
所以，我们希望针对这种情况进行优化，

1442
01:05:33,890 --> 01:05:39,210
我们假设冲突会很低，

1443
01:05:39,860 --> 01:05:43,045
我们希望很快失败，没有等待策略，

1444
01:05:43,045 --> 01:05:44,515
我们只是检查一下，我能做吗，

1445
01:05:44,515 --> 01:05:45,870
不，好的，让我再试一次，

1446
01:05:46,280 --> 01:05:48,420
因为到那时，当我去重试的时候，

1447
01:05:49,190 --> 01:05:51,120
然后我就可以做我需要做的事情了。

1448
01:05:55,240 --> 01:05:55,970
他的问题是，

1449
01:05:56,170 --> 01:05:56,790
当你杀死自己时，

1450
01:05:56,790 --> 01:05:58,370
你是否必须回滚所做的任何更改，

1451
01:05:58,750 --> 01:05:59,660
是的，在代码中。

1452
01:06:00,730 --> 01:06:04,755
所以，再次，回到写入者的例子，

1453
01:06:04,755 --> 01:06:09,280
如果，如果这个线程杀死自己，

1454
01:06:09,280 --> 01:06:10,440
它们已经更新了一大堆东西，

1455
01:06:10,520 --> 01:06:12,840
你持有那些你更新的东西的 latch ，你更新了，

1456
01:06:12,950 --> 01:06:14,460
所以你就可以回去，撤销那些更改。

1457
01:06:19,650 --> 01:06:20,620
它可能会陷入死锁，

1458
01:06:20,730 --> 01:06:21,575
不，为什么你会陷入死锁，

1459
01:06:21,575 --> 01:06:22,520
如果你已经持有了 latch ，

1460
01:06:22,520 --> 01:06:23,410
为什么你会陷入死锁。

1461
01:06:41,460 --> 01:06:42,095
所以他的问题是，

1462
01:06:42,095 --> 01:06:44,870
在什么情况下，你需要在兄弟节点中使用向后指针，

1463
01:06:44,870 --> 01:06:47,380
因为这似乎给我们带来了麻烦。

1464
01:06:47,940 --> 01:06:49,250
你的查询是这样的，

1465
01:06:49,250 --> 01:06:51,040
查找小于 4 的键，查找大于 1 的键。

1466
01:06:58,440 --> 01:07:01,000
就像你可以从 1 开始直到找到 4 ，

1467
01:07:05,220 --> 01:07:07,770
我有十亿个键，

1468
01:07:07,770 --> 01:07:09,740
而且我。

1469
01:07:11,410 --> 01:07:12,405
是的，那只是昂贵了很多。

1470
01:07:12,405 --> 01:07:13,640
没人会这么做，是的。

1471
01:07:17,680 --> 01:07:19,725
是的，我们没有讨论过跳表，

1472
01:07:19,725 --> 01:07:21,680
这里有一个，

1473
01:07:22,150 --> 01:07:24,560
SingleStore ，在它是 SingleStore 之前是 MemSQL ，

1474
01:07:24,820 --> 01:07:27,200
他们有这些跳表，跳表只有，

1475
01:07:27,490 --> 01:07:29,760
因为这是一个非常自由的数据结构，

1476
01:07:29,760 --> 01:07:30,465
这是一个坏主意，

1477
01:07:30,465 --> 01:07:31,440
这是另一个话题，

1478
01:07:31,440 --> 01:07:35,460
但是他们的跳表只能往一个方向走，

1479
01:07:35,960 --> 01:07:37,540
所以他们不得不做一系列技巧，

1480
01:07:37,540 --> 01:07:40,080
比如有办法跳到数据结构中，

1481
01:07:40,460 --> 01:07:41,740
尝试进行反向操作，

1482
01:07:41,740 --> 01:07:43,110
然后对其进行排序和反向，

1483
01:07:43,670 --> 01:07:45,210
在你把它拿出来之后，

1484
01:07:45,500 --> 01:07:46,500
它只会让生活变得更难，

1485
01:07:47,120 --> 01:07:50,520
你可以做这个，并避免这种死锁问题。

1486
01:07:54,400 --> 01:07:55,820
但它仍然是一个例子，

1487
01:07:56,080 --> 01:07:57,170
如果你在向下遍历，

1488
01:07:57,430 --> 01:07:59,460
如果我在下落的时候拿不到 latch ，

1489
01:07:59,460 --> 01:08:00,225
那就不是死锁，

1490
01:08:00,225 --> 01:08:02,510
我可能通常还是想杀死自己。

1491
01:08:06,270 --> 01:08:06,850
它仍然。

1492
01:08:08,250 --> 01:08:11,630
是的，所以你仍然，

1493
01:08:11,630 --> 01:08:12,620
你不会有死锁，

1494
01:08:12,620 --> 01:08:13,990
如果你按照你提议的去做，

1495
01:08:14,070 --> 01:08:15,530
但你仍然可能会有 latch 争用，

1496
01:08:15,530 --> 01:08:16,450
我拿不到 latch ，

1497
01:08:17,070 --> 01:08:18,190
因为其他人也持有它。

1498
01:08:18,660 --> 01:08:19,650
在这种情况下，

1499
01:08:19,650 --> 01:08:22,070
你会想要旋转一小段时间，然后杀死自己。

1500
01:08:23,270 --> 01:08:24,510
是的，你还是想杀死自己，

1501
01:08:25,100 --> 01:08:26,110
这听起来很奇怪，但你知道我的意思。

1502
01:08:28,430 --> 01:08:28,830
是的。

1503
01:08:41,880 --> 01:08:44,810
是的，所以他是对的，

1504
01:08:45,190 --> 01:08:45,830
重复他所说的话，

1505
01:08:45,880 --> 01:08:46,820
他基本上是说，

1506
01:08:48,520 --> 01:08:50,180
我们知道我们做了多少工作，

1507
01:08:50,650 --> 01:08:52,785
我们做了很多更新，

1508
01:08:52,785 --> 01:08:54,500
我们知道，这样做的成本很高，

1509
01:08:55,810 --> 01:08:58,065
那么，我们能不能有一个经验法说，

1510
01:08:58,065 --> 01:08:59,370
当我们旋转时，

1511
01:08:59,370 --> 01:09:00,620
我们想要等待多长时间，

1512
01:09:00,910 --> 01:09:02,060
可以根据我们做了多少工作来确定，

1513
01:09:02,350 --> 01:09:03,380
是的，你可以这么做，

1514
01:09:03,800 --> 01:09:07,200
我不认为 Postgres MySQL 这么做了。

1515
01:09:07,200 --> 01:09:08,000
我可能是错的。

1516
01:09:08,170 --> 01:09:15,560
会是这样吗？

1517
01:09:15,640 --> 01:09:16,370
我的意思是，你可以想象，

1518
01:09:16,510 --> 01:09:17,540
非常简单的经验式方法，

1519
01:09:18,160 --> 01:09:18,660
一个计数器，

1520
01:09:18,950 --> 01:09:21,640
我在我的本地地址有一个计数器，

1521
01:09:21,640 --> 01:09:22,680
我的 worker 的本地内存，

1522
01:09:24,340 --> 01:09:25,850
我更新了多少页面，

1523
01:09:26,260 --> 01:09:27,410
对于我更新的每个页面，

1524
01:09:27,790 --> 01:09:31,910
等待，也许是额外的几百微秒左右，

1525
01:09:32,770 --> 01:09:33,525
简单的经验法，

1526
01:09:33,525 --> 01:09:35,300
我不知道这样做是否真的有意义，

1527
01:09:36,160 --> 01:09:37,740
这对所有情况和数据库的一种[]，

1528
01:09:37,740 --> 01:09:38,580
这取决于工作量，

1529
01:09:38,580 --> 01:09:42,105
这取决于，如果每个人都在更新一堆东西，

1530
01:09:42,105 --> 01:09:43,080
那么也许这不是一个好主意，

1531
01:09:43,080 --> 01:09:44,970
但你有一个线程，一个 worker ，

1532
01:09:44,970 --> 01:09:46,190
它更新了一些事情，

1533
01:09:46,390 --> 01:09:47,900
是的，这可能是有意义的。

1534
01:09:48,710 --> 01:09:50,790
但是一旦我尝试更新相同的键，

1535
01:09:50,870 --> 01:09:54,450
所有东西都会陷入单线程系统，

1536
01:09:55,100 --> 01:09:56,250
不过，这只是个极端的例子。

1537
01:09:56,720 --> 01:09:57,100
是的。

1538
01:10:06,680 --> 01:10:07,530
你怎么处理那个，

1539
01:10:08,505 --> 01:10:10,340
他们都死了，我是说，他们会重新开始。

1540
01:10:11,170 --> 01:10:11,570
是的。

1541
01:10:13,130 --> 01:10:15,660
是的，所以，非常清楚，

1542
01:10:16,130 --> 01:10:16,950
我用幻灯片来说明这一点，

1543
01:10:16,970 --> 01:10:20,190
重新开始机制对用户是透明的。

1544
01:10:22,510 --> 01:10:24,080
是的，我没有这样的幻灯片。

1545
01:10:24,700 --> 01:10:25,620
比如我运行一个查询，

1546
01:10:26,300 --> 01:10:28,195
我必须遍历一个 B+ 树，

1547
01:10:28,195 --> 01:10:30,550
然后我去查看主键，

1548
01:10:30,550 --> 01:10:32,280
当我向下移动时，我得不到 latch ，

1549
01:10:32,420 --> 01:10:34,450
我不想中止查询，并返回到用户，

1550
01:10:34,450 --> 01:10:35,760
嘿，听着，我不能获得 latch ，

1551
01:10:35,840 --> 01:10:37,705
因为他们不知道什么是 latch ，

1552
01:10:37,705 --> 01:10:40,630
然后重新启动，我们为你透明地这样做，

1553
01:10:40,630 --> 01:10:42,690
所以你提交一个查询，

1554
01:10:42,920 --> 01:10:47,100
它可能会多次重新开始遍历 B+ 树，

1555
01:10:47,840 --> 01:10:49,760
但是从应用程序的最终用户那里看不到这一点，

1556
01:10:49,760 --> 01:10:50,735
我们是在内部进行的，

1557
01:10:50,735 --> 01:10:52,690
只是因为这个，查询速度变慢了一点。

1558
01:10:56,700 --> 01:10:57,590
很多问题，抱歉。

1559
01:11:00,490 --> 01:11:00,890
是的。

1560
01:11:00,940 --> 01:11:08,730
是的，当然，

1561
01:11:08,730 --> 01:11:09,620
所以问题是，

1562
01:11:09,700 --> 01:11:10,425
有没有这样一种情况，

1563
01:11:10,425 --> 01:11:12,090
某个线程在 root 上有一个写 latch ，

1564
01:11:12,090 --> 01:11:14,120
如果你重新启动，你会回来并取消，

1565
01:11:15,510 --> 01:11:16,060
当然，是的，

1566
01:11:16,875 --> 01:11:17,510
这是不可避免的。

1567
01:11:20,660 --> 01:11:24,280
我的意思是，你插入的键越多，树就越高，

1568
01:11:26,360 --> 01:11:32,550
所以，有线程在 root 上持有写 latch 向下。

1569
01:11:38,410 --> 01:11:40,640
回到停滞的东西上，

1570
01:11:42,030 --> 01:11:45,380
不仅仅是另一个线程做了多少工作，

1571
01:11:45,850 --> 01:11:50,610
比如，你必须对等待排序，

1572
01:11:51,170 --> 01:11:57,180
记的，这些数据结构由位于磁盘上的缓冲池中的页面支持，

1573
01:11:57,650 --> 01:11:59,400
所以，即使我更新一个键，

1574
01:11:59,750 --> 01:12:02,305
我需要更新的键可能不在内存中，

1575
01:12:02,305 --> 01:12:03,840
我必须从磁盘中取出它，

1576
01:12:05,130 --> 01:12:05,840
这就是为什么，

1577
01:12:05,840 --> 01:12:06,755
你不想停滞，

1578
01:12:06,755 --> 01:12:08,465
你不会想要永远旋转很长一段时间，

1579
01:12:08,465 --> 01:12:09,275
因为你不知道，

1580
01:12:09,275 --> 01:12:11,140
比如，它必须得到一个磁盘，

1581
01:12:11,660 --> 01:12:12,785
这只是一个非常慢的磁盘，

1582
01:12:12,785 --> 01:12:14,170
这将是一个很长的时间，

1583
01:12:14,460 --> 01:12:19,470
你可以等待 100 毫秒， 500 毫秒。

1584
01:12:20,320 --> 01:12:22,040
所以他说，哦，等待平均时间，

1585
01:12:22,060 --> 01:12:23,415
我的意思是，这取决于太多因素，

1586
01:12:23,415 --> 01:12:24,830
不可能跟踪这些东西。

1587
01:12:27,730 --> 01:12:28,860
再次，这就是为什么，

1588
01:12:28,860 --> 01:12:31,545
它不同于常规的数据结构算法类，

1589
01:12:31,545 --> 01:12:33,380
因为这些东西是由磁盘支持的，

1590
01:12:34,780 --> 01:12:36,280
我们有多个线程同时运行，

1591
01:12:36,280 --> 01:12:40,740
我们需要做一系列的事情来隐藏这些[]，

1592
01:12:43,530 --> 01:12:44,840
SQL Server ，一个完全不同的[] ，

1593
01:12:44,840 --> 01:12:50,030
SQL Server ，他们有自己的用户空间例程，

1594
01:12:50,620 --> 01:12:52,940
所以如果你在遍历数据结构，

1595
01:12:55,010 --> 01:12:57,060
而我需要的，我拿不到 latch ，

1596
01:12:57,890 --> 01:13:01,270
不只是旋转，而是回到它们自己的用户空间调度器，

1597
01:13:01,270 --> 01:13:02,875
并说，我不能运行，

1598
01:13:02,875 --> 01:13:03,870
因为我在等待这个 latch ，

1599
01:13:04,620 --> 01:13:06,600
然后他们拿走你的线程，

1600
01:13:06,600 --> 01:13:07,620
让它做一些其他的工作，

1601
01:13:07,620 --> 01:13:09,495
然后他们可能知道你在等待什么 latch ，

1602
01:13:09,495 --> 01:13:10,790
它们实际上在做一些跟踪，

1603
01:13:11,350 --> 01:13:13,400
谁在等待里面的什么 latch ，

1604
01:13:14,180 --> 01:13:15,085
他们能够做到这个，

1605
01:13:15,085 --> 01:13:16,770
因为用户空间中的一切都是[]例程，

1606
01:13:18,750 --> 01:13:20,045
很少有人，没有人这么做，

1607
01:13:20,045 --> 01:13:22,180
SQL Server 做了一些非常酷的事情。

1608
01:13:24,130 --> 01:13:25,400
好的，酷。还有其他问题吗？

1609
01:13:27,050 --> 01:13:27,450
是的。

1610
01:13:47,320 --> 01:13:48,195
是的，所以他的问题是，

1611
01:13:48,195 --> 01:13:48,720
让我回到这里，

1612
01:13:48,720 --> 01:13:49,230
他的问题是，

1613
01:13:49,230 --> 01:13:52,300
如果我遍历兄弟节点，

1614
01:13:56,690 --> 01:13:57,540
这里这个，

1615
01:13:59,800 --> 01:14:00,630
如果它们想要通过，

1616
01:14:01,630 --> 01:14:04,010
所以 T2 是 B ，

1617
01:14:04,660 --> 01:14:05,660
T1 是 C ，

1618
01:14:06,280 --> 01:14:10,940
为什么 T2 需要持有 B 的 latch 为了获取 C ，

1619
01:14:11,590 --> 01:14:12,735
因为你需要知道，

1620
01:14:12,735 --> 01:14:14,085
兄弟指针仍然有效，

1621
01:14:14,085 --> 01:14:15,950
那么这就是正确的节点，

1622
01:14:16,210 --> 01:14:18,590
这就是你要寻找的正确节点，

1623
01:14:18,760 --> 01:14:20,580
如果有更新，

1624
01:14:20,580 --> 01:14:21,930
因为你把它保持在读模式，

1625
01:14:21,930 --> 01:14:23,000
没有人可以更新它，

1626
01:14:23,050 --> 01:14:26,030
所以，没有人会用一些东西替换 B ，

1627
01:14:26,560 --> 01:14:28,215
使用一些其他新版本的东西，

1628
01:14:28,215 --> 01:14:29,270
它们现在指向其他东西，

1629
01:14:29,590 --> 01:14:31,380
但你仍然要沿着指针，

1630
01:14:31,380 --> 01:14:34,300
指向你以前认为在那里的任何东西，

1631
01:14:34,470 --> 01:14:35,630
所以你必须持有 latch ，

1632
01:14:35,630 --> 01:14:37,180
直到你知道你在另一边是安全的，

1633
01:14:37,440 --> 01:14:38,590
然后你就可以继续，并释放它。

1634
01:14:39,420 --> 01:14:41,420
同样，它是自上而下的，

1635
01:14:41,420 --> 01:14:42,245
你需要知道，

1636
01:14:42,245 --> 01:14:44,800
我接下来要跳到的东西是我应该跳到的。

1637
01:14:48,000 --> 01:14:48,400
是的。

1638
01:15:01,250 --> 01:15:01,650
是的。

1639
01:15:24,300 --> 01:15:26,210
是的，所以，这个问题，就像，

1640
01:15:26,210 --> 01:15:28,180
这是一个问题，

1641
01:15:28,990 --> 01:15:34,220
上一次，我谈到了像 Postgres 这样的系统如何在内部节点上有兄弟指针，

1642
01:15:34,450 --> 01:15:36,800
尽管我在这里只显示了叶子节点，

1643
01:15:37,120 --> 01:15:41,300
如果我使用这些内部节点的兄弟指针来水平地跳转，

1644
01:15:42,280 --> 01:15:43,530
我怎么才能获取这些上面的 latch ，

1645
01:15:43,530 --> 01:15:44,870
并确保一切正常，

1646
01:15:45,250 --> 01:15:47,720
所以协议，我在这里描述的一切，仍然有效，

1647
01:15:49,480 --> 01:15:49,880
如果，

1648
01:15:51,530 --> 01:15:52,555
对于读取，它是简单的，

1649
01:15:52,555 --> 01:15:54,150
你只需获取读 latch 通过，

1650
01:15:56,920 --> 01:15:58,635
因为任何高于你的人，

1651
01:15:58,635 --> 01:15:59,270
一旦你是写入，

1652
01:15:59,470 --> 01:16:01,190
他们就会看到你的读 latch ，他们会停止，

1653
01:16:01,630 --> 01:16:04,815
树下面的任何东西做更新，

1654
01:16:04,815 --> 01:16:06,830
你被阻塞，获取读 latch 向下，

1655
01:16:07,030 --> 01:16:07,760
所以这是可以的，

1656
01:16:08,080 --> 01:16:09,105
对于更新，

1657
01:16:09,105 --> 01:16:11,450
我认为它的工作方式，像你[]一样，

1658
01:16:13,340 --> 01:16:16,330
如果你在下面尝试做的事情不安全，

1659
01:16:16,830 --> 01:16:18,490
然后你仍然持有那些东西的 latch ，

1660
01:16:18,540 --> 01:16:19,595
协议仍然有效，

1661
01:16:19,595 --> 01:16:21,850
即使你必须水平地通过并向下。

1662
01:16:23,530 --> 01:16:24,740
你仍然会有死锁，

1663
01:16:24,820 --> 01:16:27,830
如果每个人都试图垂直通过你或水平通过你，

1664
01:16:27,880 --> 01:16:29,480
然后你做我在这里描述的同样的事情。

1665
01:16:31,000 --> 01:16:31,970
还有其他问题吗？

1666
01:16:34,780 --> 01:16:35,390
好的，酷。

1667
01:16:38,410 --> 01:16:39,320
所以，好的。

1668
01:16:40,380 --> 01:16:41,170
做个总结。

1669
01:16:42,980 --> 01:16:43,590
这很难，

1670
01:16:44,870 --> 01:16:47,260
我向你展示的是最简单的版本，

1671
01:16:47,260 --> 01:16:49,830
latch 抓取和[]，

1672
01:16:53,300 --> 01:16:54,325
我们不会在这节课中讨论这个，

1673
01:16:54,325 --> 01:16:56,245
但还有更复杂的方案，

1674
01:16:56,245 --> 01:16:57,360
你可以有[] latch ，

1675
01:16:57,800 --> 01:17:00,900
你可以延迟更新，

1676
01:17:01,190 --> 01:17:02,650
你可以做 Bε 树的事情，

1677
01:17:02,650 --> 01:17:03,330
在那里你延迟事情，

1678
01:17:03,650 --> 01:17:05,100
你还可以做很多其他的事情，

1679
01:17:06,410 --> 01:17:09,210
Bε 是来自微软的无锁的 B+ 树，

1680
01:17:09,770 --> 01:17:10,800
这是另一个噩梦。

1681
01:17:13,040 --> 01:17:14,575
再次，这很难，但这很好，

1682
01:17:14,575 --> 01:17:16,570
因为这你上这门课，

1683
01:17:16,570 --> 01:17:17,550
这就是为什么，

1684
01:17:17,900 --> 01:17:20,370
你不想让你的随机的 Javascript 程序员

1685
01:17:20,600 --> 01:17:23,580
在你的数据库系统中构建你的 B+ 树数据结构，

1686
01:17:23,900 --> 01:17:26,880
你们希望像你们这样 CMU 学生知道他们在做什么，

1687
01:17:26,930 --> 01:17:28,710
并确保他们不会造成问题。

1688
01:17:29,900 --> 01:17:31,855
所以我们再次讨论哈希表，

1689
01:17:31,855 --> 01:17:33,510
我们今天讨论 B+ 树，

1690
01:17:33,770 --> 01:17:35,350
但是这种想法的技巧，

1691
01:17:35,350 --> 01:17:36,720
比如一切都朝着同一个方向走，

1692
01:17:36,740 --> 01:17:39,420
或者我一旦拿不到东西就杀死自己并重新启动，

1693
01:17:39,650 --> 01:17:45,750
这也与系统中的很多其他数据结构相关。

1694
01:17:47,520 --> 01:17:50,260
我觉得我们应该把这门课叫作杀死你自己，

1695
01:17:50,490 --> 01:17:54,260
我让 CMU 涉及其中，

1696
01:17:54,260 --> 01:17:54,490
我不想有这个麻烦，抱歉，

1697
01:17:55,920 --> 01:17:57,110
有一年，有人抱怨，

1698
01:17:57,110 --> 01:18:00,250
说了很多杀死你自己，抱歉。

1699
01:18:00,390 --> 01:18:01,000
好的，所以，

1700
01:18:01,680 --> 01:18:05,230
所以，下一节课我们将讨论排序或排序聚合，

1701
01:18:05,280 --> 01:18:07,660
在这一点上，我们要向上移动，

1702
01:18:08,010 --> 01:18:09,730
现在我们可以开始执行查询了，

1703
01:18:09,960 --> 01:18:10,810
太棒了，对吧，

1704
01:18:11,850 --> 01:18:15,005
所以我星期一不会在这里讲课，

1705
01:18:15,005 --> 01:18:17,255
Jignesh Patel 是另一位教授，

1706
01:18:17,255 --> 01:18:18,910
他将于星期一开始讲课，

1707
01:18:19,680 --> 01:18:21,130
然后是下星期三，

1708
01:18:21,390 --> 01:18:22,550
他和我都走了，

1709
01:18:22,550 --> 01:18:24,230
我要去纽约参加 Postgres 会议，

1710
01:18:24,230 --> 01:18:25,780
我将在那里做一个关于数据库主题演讲，

1711
01:18:27,480 --> 01:18:28,720
可能必须和[]讨论，

1712
01:18:31,120 --> 01:18:32,485
但是我们有一个我的博士生，

1713
01:18:32,485 --> 01:18:33,925
我的头号博士生 Matt butucevic ，

1714
01:18:33,925 --> 01:18:36,600
将在下周三教授有关 Join 方面的课程。

1715
01:18:36,920 --> 01:18:40,120
然后 Jignesh 是很棒的，

1716
01:18:40,120 --> 01:18:42,870
Jignesh ，问他关于在印度长大的事情，

1717
01:18:42,950 --> 01:18:45,400
因为在他加入 CMU 之前，

1718
01:18:45,400 --> 01:18:46,165
他讲了一些疯狂的故事，

1719
01:18:46,165 --> 01:18:48,600
他过去每天早上在上学的公交车上打架，

1720
01:18:49,345 --> 01:18:52,060
我想他带着小刀，问他这件事。

1721
01:18:52,060 --> 01:18:57,400
好的，我们也将在下周谈论期中考试。

