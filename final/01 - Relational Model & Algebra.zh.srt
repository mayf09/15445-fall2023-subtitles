1
00:00:25,880 --> 00:00:27,840
显然违反了这里的消防法规。

2
00:00:29,420 --> 00:00:33,510
我想你可以坐在前面，也可以坐在地板上，

3
00:00:34,880 --> 00:00:37,150
好的，所以有很多话要说，

4
00:00:37,150 --> 00:00:40,500
首先，我们又有了一位 DJ ， 2PL ，

5
00:00:45,530 --> 00:00:47,940
你们凶猛的 DJ 现在在监狱里，

6
00:00:49,340 --> 00:00:50,580
你想不想做个快速演示，

7
00:00:50,930 --> 00:00:51,330
为大家来一个。

8
00:00:59,020 --> 00:01:00,495
另一个重要的宣布是，

9
00:01:00,495 --> 00:01:02,990
我们第一次有了两名导师，

10
00:01:04,390 --> 00:01:06,110
Jingnesh Patel 坐在这里的前排，

11
00:01:12,070 --> 00:01:12,920
威斯康星州，

12
00:01:13,000 --> 00:01:16,590
我们很高兴他在这里，

13
00:01:16,590 --> 00:01:18,590
所以他将在整个讲座中帮助我。

14
00:01:18,910 --> 00:01:23,130
好的，正如我在 Piazza 上发布的那样，

15
00:01:23,210 --> 00:01:25,440
我们还有另一门课程，

16
00:01:26,680 --> 00:01:27,780
他们让 Mooshoo 出狱，

17
00:01:29,450 --> 00:01:30,120
当然，

18
00:01:30,560 --> 00:01:33,270
所以我们不会像一堆这样的事情再来一次，

19
00:01:33,320 --> 00:01:35,280
我只想覆盖一些你可能会错过的事情，

20
00:01:35,820 --> 00:01:37,170
在整门课中要理解的重要内容，

21
00:01:37,170 --> 00:01:39,050
然后我们将直接进入材料。

22
00:01:39,840 --> 00:01:40,775
好的，那么第一件事，

23
00:01:40,775 --> 00:01:42,820
我们有一个课程赞助商 SingleStore ，

24
00:01:44,700 --> 00:01:45,815
基于云的数据库系统，

25
00:01:45,815 --> 00:01:48,730
支持混合工作负载事务分析，

26
00:01:48,990 --> 00:01:50,140
正如我在第一节课中所说，

27
00:01:50,460 --> 00:01:52,310
它是一个内存中的列存储，

28
00:01:52,310 --> 00:01:54,700
使用跳过列表和即时查询，

29
00:01:56,245 --> 00:01:57,150
分发，什么都不分享，

30
00:01:57,530 --> 00:02:00,990
如果现在这些对你来说没有任何意义，那也没关系，

31
00:02:02,090 --> 00:02:03,870
本学期末有一场客座讲座，

32
00:02:05,410 --> 00:02:10,440
很长时间，你可以称它为 MemSQL ，

33
00:02:10,440 --> 00:02:11,900
然后他们将其更名为 SingleStore ，

34
00:02:12,280 --> 00:02:14,070
这是一个最先进的数据库系统，

35
00:02:14,070 --> 00:02:14,720
它将涵盖，

36
00:02:14,830 --> 00:02:18,680
将与我们在整个学期讨论的大量想法有关。

37
00:02:19,850 --> 00:02:21,660
人群很多，显然不是每个人，

38
00:02:22,370 --> 00:02:24,060
如果你听说，你想要得到等待名单，

39
00:02:24,440 --> 00:02:26,580
坏消息是，等待名单太大了，

40
00:02:27,080 --> 00:02:28,590
部门把它从我们手中拿走了，

41
00:02:28,760 --> 00:02:30,270
我们无法控制它，

42
00:02:31,230 --> 00:02:32,225
他们试图弄清楚，

43
00:02:32,225 --> 00:02:33,340
比如谁需要毕业，

44
00:02:33,390 --> 00:02:35,290
谁将获得系统选修课，以及所有这些东西，

45
00:02:35,490 --> 00:02:37,400
所以如果你来问我们，

46
00:02:37,400 --> 00:02:38,315
嘿，他们能从等待名单上除名吗，

47
00:02:38,315 --> 00:02:40,660
坏消息是，我们我们不再控制它了，

48
00:02:41,550 --> 00:02:43,600
好消息是，因为我们现在有了 Jignesh ，

49
00:02:43,950 --> 00:02:46,790
他将每学期教一次这门课，

50
00:02:46,790 --> 00:02:48,130
所以，如果你这学期进不去，

51
00:02:48,870 --> 00:02:50,080
下个学期你就能拿到，

52
00:02:50,310 --> 00:02:52,355
然后管理员会把人们从等待名单上移走，

53
00:02:52,355 --> 00:02:56,090
因为人们下降了，这个可以了。

54
00:03:11,640 --> 00:03:12,190
地方，

55
00:03:12,780 --> 00:03:14,200
我从[]教员那里发现的东西。

56
00:03:14,490 --> 00:03:16,085
所以，第一个坏消息是，

57
00:03:16,085 --> 00:03:16,870
如果你现在没有注册，

58
00:03:17,160 --> 00:03:19,860
你会在春天变得不同。

59
00:03:21,430 --> 00:03:24,450
好的，尽管如此，重要的公告，

60
00:03:24,450 --> 00:03:25,490
一切都将在 Piazza 上，

61
00:03:25,990 --> 00:03:29,000
项目0 ，我们应该在第一堂课中少讲一些，

62
00:03:29,170 --> 00:03:31,940
现在可以在 Gradescope 和网站上看到，

63
00:03:32,380 --> 00:03:34,160
我们通过 Canvas 展示的期末成绩，

64
00:03:34,450 --> 00:03:37,490
所有的东西都将通过 Gradescope 提交，

65
00:03:37,720 --> 00:03:40,850
再次，因为人们在 CMU 外面观看这些课程，

66
00:03:40,930 --> 00:03:44,460
他们在我们的大学外面，

67
00:03:45,140 --> 00:03:49,500
如果你想用和 CMU 学生一样的方式测试你的项目，

68
00:03:49,700 --> 00:03:53,190
你可以去一个单独的 Gradescope 账户，使用那里的代码，

69
00:03:53,840 --> 00:03:56,070
你可以开始测试，然后测试，

70
00:03:56,180 --> 00:03:57,780
我们会发布这些项目。

71
00:04:01,350 --> 00:04:05,600
作为看到这些的人们的交换，

72
00:04:06,510 --> 00:04:08,680
在向你提供这一切的过程中，

73
00:04:09,420 --> 00:04:10,150
我们需要一些，

74
00:04:11,360 --> 00:04:12,690
我想你还没有，

75
00:04:13,010 --> 00:04:14,020
我的被禁了，

76
00:04:14,020 --> 00:04:16,350
因为第一个在某种程度上是真的，

77
00:04:17,780 --> 00:04:19,630
但他们说我出生在巴尔的摩的街头，

78
00:04:19,630 --> 00:04:20,940
我来自巴尔的摩，

79
00:04:27,350 --> 00:04:32,080
不管怎样，总有人能把它做完，

80
00:04:32,080 --> 00:04:32,700
那太好了。

81
00:04:33,590 --> 00:04:34,300
我做了，

82
00:04:34,300 --> 00:04:37,410
我评论说，嘿，我不是从街头来的。

83
00:04:38,710 --> 00:04:41,460
所以，为了覆盖后勤，

84
00:04:42,200 --> 00:04:43,170
这是一个大班，

85
00:04:43,400 --> 00:04:46,410
显然，这里有很多人可能有不同的背景，

86
00:04:46,490 --> 00:04:47,905
所以我们希望你们能打断我们，

87
00:04:47,905 --> 00:04:49,050
因为我们整个学期都在，

88
00:04:50,430 --> 00:04:57,580
如果谈论关于[]的问题，那是很好的问题。

89
00:04:57,990 --> 00:05:01,070
我也很兴奋谈到这个，

90
00:05:01,070 --> 00:05:03,760
我的生活，我的妻子，我的亲生女儿，是第一的，

91
00:05:04,020 --> 00:05:05,860
还有数据库，然后什么都没有，

92
00:05:05,910 --> 00:05:08,180
比如我不谈论爱好，

93
00:05:08,180 --> 00:05:12,485
从字面上看，这只是数据库，确认这只是数据库，

94
00:05:12,485 --> 00:05:14,240
是的，我的父母是特朗普的支持者，

95
00:05:14,240 --> 00:05:14,990
我们不讨论这个，

96
00:05:14,990 --> 00:05:17,320
它只是数据库，

97
00:05:19,790 --> 00:05:21,070
你们觉得很好笑。

98
00:05:22,360 --> 00:05:27,560
再说一次，如果速度快，或者如果你有问题，打断我们，

99
00:05:27,850 --> 00:05:29,715
我们不会做的是，

100
00:05:29,715 --> 00:05:31,100
在课程结束时，

101
00:05:31,390 --> 00:05:34,370
让大家排成一排，问幻灯片 5 怎么样，

102
00:05:36,670 --> 00:05:38,760
我们在讲课中讨论的材料，

103
00:05:38,760 --> 00:05:41,870
因为我想让你们打断我们，

104
00:05:42,190 --> 00:05:44,720
因为如果你们有问题，其他人也可能有问题，

105
00:05:45,520 --> 00:05:48,200
让我们来讨论这些事情，

106
00:05:48,340 --> 00:05:49,845
从教育学的角度来看，

107
00:05:49,845 --> 00:05:51,030
这对我们也更好，

108
00:05:51,030 --> 00:05:52,550
因为我会回去看，

109
00:05:53,000 --> 00:05:54,190
我看到人们在哪里提问，

110
00:05:54,720 --> 00:05:57,790
我看到，哦，这不太对劲，去解决问题，

111
00:05:57,900 --> 00:05:58,780
所以有问题。

112
00:06:03,420 --> 00:06:05,350
好的，对这些后勤有什么问题吗？

113
00:06:08,390 --> 00:06:09,940
所以，让我们直奔主题。

114
00:06:09,940 --> 00:06:12,810
好的，所以我们要谈的是，

115
00:06:13,660 --> 00:06:15,405
围绕什么是数据库，为什么它很重要，

116
00:06:15,405 --> 00:06:16,610
为什么我们需要数据库管理系统，

117
00:06:16,900 --> 00:06:18,080
为什么这门课会存在，

118
00:06:18,550 --> 00:06:20,685
不仅是因为我们做了愚蠢的 Niche ，

119
00:06:20,685 --> 00:06:23,180
这是一个非常重要的话题，

120
00:06:23,470 --> 00:06:24,560
然后我们会讨论，

121
00:06:25,490 --> 00:06:30,240
在我看来，在数据库中如何构建或使用的主要模型，

122
00:06:30,950 --> 00:06:32,170
然后让我们讨论关系型代数，

123
00:06:32,170 --> 00:06:37,050
我们用来与关系模型数据库交互的机制或运算符，

124
00:06:37,490 --> 00:06:38,425
我们结束，

125
00:06:38,425 --> 00:06:40,350
因为我们必须讨论替代模型，

126
00:06:40,880 --> 00:06:43,180
人们发展模型，

127
00:06:43,530 --> 00:06:45,970
我对为什么他们错了有强烈的看法，好吗？

128
00:06:47,200 --> 00:06:51,800
好的，数据库是我生命中第二重要的事情。

129
00:07:01,030 --> 00:07:01,430
是的。

130
00:07:04,050 --> 00:07:05,840
是的，问题是，如果你在等待名单上，

131
00:07:05,840 --> 00:07:06,965
你能进入 Piazza 吗，

132
00:07:06,965 --> 00:07:10,570
是的，我们让它变得可用。

133
00:07:11,645 --> 00:07:12,850
所以这有 SQL server ，

134
00:07:15,540 --> 00:07:18,350
MySQL ，是的，

135
00:07:19,530 --> 00:07:21,400
还有没有人知道，

136
00:07:22,440 --> 00:07:23,380
Cassandra ，好的。

137
00:07:25,860 --> 00:07:28,360
所有人列出的 SQL server, Postgres, mongo ，

138
00:07:28,440 --> 00:07:32,480
这些都是数据库管理系统，

139
00:07:32,480 --> 00:07:33,550
我们谈论的是数据库，

140
00:07:34,220 --> 00:07:35,285
不要感到难过，

141
00:07:35,285 --> 00:07:36,910
因为不是唯一一个犯这个错误的人，

142
00:07:37,320 --> 00:07:40,210
这是 Jeff ，我想是今年，

143
00:07:41,800 --> 00:07:42,440
看看能不能播放，

144
00:07:43,950 --> 00:07:45,010
科技挑战，谢谢，

145
00:07:45,690 --> 00:07:51,220
这些系统中的一个关系型系统以行和列的形式提供要存储和检索的信息，

146
00:07:51,900 --> 00:07:52,400
Justin ，

147
00:07:52,400 --> 00:07:53,140
是不是矩阵，

148
00:07:53,730 --> 00:07:54,130
不是。

149
00:08:01,010 --> 00:08:03,280
情况会变得更糟，好的，

150
00:08:04,110 --> 00:08:06,620
数据库不是，再次这里是迂腐的，

151
00:08:06,620 --> 00:08:08,260
但理解两者之间的区别是很好的，

152
00:08:08,880 --> 00:08:10,280
因为当我们只谈论数据模型时，

153
00:08:10,280 --> 00:08:10,700
你不会理解，

154
00:08:10,700 --> 00:08:15,410
好吧，我们还不关心系统实现，数据实际上是什么，

155
00:08:15,410 --> 00:08:16,570
以及我们将如何与它交互。

156
00:08:16,830 --> 00:08:22,940
所以，有组织的相互关联的数据集合，

157
00:08:22,940 --> 00:08:24,940
这意味着对某些方面进行建模，

158
00:08:26,420 --> 00:08:27,990
每个人都在系统中生活，

159
00:08:28,460 --> 00:08:31,975
一个数据库的例子是大学的数据库，

160
00:08:31,975 --> 00:08:36,285
跟踪哪些学生注册了哪些班级和你的成绩，

161
00:08:36,285 --> 00:08:39,980
因为这是在试图模拟真实的大学互动，

162
00:08:40,150 --> 00:08:42,890
学生们上课并获得回报。

163
00:08:47,620 --> 00:08:48,565
这门课程非常重要，

164
00:08:48,565 --> 00:08:53,910
因为数据库将是基础组件，

165
00:08:55,330 --> 00:08:56,835
任何应用程序的基础，

166
00:08:56,835 --> 00:08:58,670
或者任何你将在你的余生中做的事情，

167
00:08:59,050 --> 00:09:00,450
所以，如果你是一名 CS 学生，

168
00:09:00,450 --> 00:09:04,110
无论你去做了一份与 CS 相关的工作，

169
00:09:04,110 --> 00:09:06,650
或者你不是程序员，

170
00:09:06,820 --> 00:09:09,320
归根结底，你将始终与数据库交互，

171
00:09:10,000 --> 00:09:12,900
即使它是 Excel 电子表格数据库，

172
00:09:14,950 --> 00:09:15,530
是其中之一。

173
00:09:16,930 --> 00:09:19,250
这门课程很重要，

174
00:09:19,270 --> 00:09:22,640
因为你最终将与数据库系统交互，

175
00:09:22,870 --> 00:09:24,830
你需要了解其中实际包含的内容，

176
00:09:25,690 --> 00:09:28,520
即使是在手机上运行的小应用程序，

177
00:09:28,630 --> 00:09:31,250
或者有大量数据的应用程序，

178
00:09:31,660 --> 00:09:33,990
理解查询也是很重要的，

179
00:09:33,990 --> 00:09:36,830
或者当你看数据库系统时，它实际上是什么。

180
00:09:38,040 --> 00:09:39,725
你会做出哪些权衡，

181
00:09:39,725 --> 00:09:41,710
在使用一种数据模型与另一种数据模型，

182
00:09:41,790 --> 00:09:43,840
或一种数据库与另一种数据库。

183
00:09:45,700 --> 00:09:47,655
世界上部署最广泛的数据库系统是什么，

184
00:09:47,655 --> 00:09:48,380
你可以猜猜看，

185
00:09:51,970 --> 00:09:52,970
每个人都有一部手机，

186
00:09:53,880 --> 00:09:55,600
每一部手机上都有 SQLite ，

187
00:09:56,580 --> 00:09:59,110
它是由北卡罗来纳州的一个家伙写的，

188
00:09:59,940 --> 00:10:02,394
但帮手没有地址，

189
00:10:02,315 --> 00:10:03,430
他就像一个游牧民族。

190
00:10:05,510 --> 00:10:06,670
让我们举一个数据库的例子，

191
00:10:06,670 --> 00:10:09,055
我们讨论了大学应用，

192
00:10:09,055 --> 00:10:12,210
我们谈论一些与这里的每个人更相关的事情，

193
00:10:13,220 --> 00:10:17,880
与 Spotify Bandcamp iTunes 或 KeepMusic 类似的东西。

194
00:10:18,510 --> 00:10:20,290
所以我们可以创建一个非常简单的数据库，

195
00:10:20,460 --> 00:10:22,450
它有两个实体，

196
00:10:22,710 --> 00:10:25,900
有艺人出现在专辑中。

197
00:10:26,560 --> 00:10:28,300
所以我们需要存储在我们的数据中的东西是，

198
00:10:28,300 --> 00:10:29,700
比如对于每个艺术家，

199
00:10:30,050 --> 00:10:33,030
他们的名字是什么，他们是从哪个国家开始的，

200
00:10:33,440 --> 00:10:34,420
专辑可能是这样的，

201
00:10:34,420 --> 00:10:36,270
专辑的名字是什么，它是什么时候推出的，

202
00:10:36,560 --> 00:10:37,800
有哪些艺术家出现在里面。

203
00:10:38,810 --> 00:10:42,200
所以，我们现在讨论的是，

204
00:10:42,340 --> 00:10:46,510
一个数据库的稻草人实现，

205
00:10:47,220 --> 00:10:48,515
我们将看到为什么它是愚蠢的，

206
00:10:48,515 --> 00:10:50,350
我们会看到它将会有的所有问题，

207
00:10:50,970 --> 00:10:52,850
然后，这将有助于激励，

208
00:10:52,850 --> 00:10:54,640
我们为什么想要建立一个成熟的数据库，

209
00:10:54,720 --> 00:10:56,170
或者依赖一个成熟的数据库。

210
00:10:58,520 --> 00:11:02,220
所以，实现管理数据的数据库系统的最简单方法是，

211
00:11:02,300 --> 00:11:05,990
只使用磁盘上的文件，

212
00:11:05,990 --> 00:11:06,940
所以对于每个，

213
00:11:07,470 --> 00:11:09,460
对于我的两个实体， Album 和 Artist ，

214
00:11:09,870 --> 00:11:12,340
我有一个 CSV 文件，逗号分隔值文件，

215
00:11:13,040 --> 00:11:19,580
那份文件里的每一行，

216
00:11:21,320 --> 00:11:24,990
我想要在我的[]找到[]，

217
00:11:26,090 --> 00:11:30,145
我要打开它，解析它，排成一行，

218
00:11:30,145 --> 00:11:33,099
试着找到我正在寻找的数据。

219
00:11:33,919 --> 00:11:34,829
所以，假设我想做一件事，

220
00:11:45,359 --> 00:11:47,629
对于 CSV 魔法词的部分，

221
00:11:47,629 --> 00:11:50,829
就是用逗号分开，

222
00:11:51,609 --> 00:11:55,429
然后如果我发现这个名字是 (GZA) ，

223
00:11:56,859 --> 00:11:57,689
然后我把它打印出来。

224
00:12:01,129 --> 00:12:03,199
好的，它起作用了，

225
00:12:06,249 --> 00:12:07,639
但这很糟糕，为什么？

226
00:12:11,089 --> 00:12:11,409
好的。

227
00:12:11,409 --> 00:12:16,250
它会变得非常缓慢，随着成员的增加。

228
00:12:16,390 --> 00:12:19,820
是的，所以在软件中总是要考虑极端的情况，

229
00:12:21,140 --> 00:12:22,020
这里有三条记录，

230
00:12:22,160 --> 00:12:24,840
是的，我可以将它加载到一个页面中，并很快进行解析，

231
00:12:25,100 --> 00:12:26,730
但如果我有 30 条记录，

232
00:12:27,950 --> 00:12:30,400
而且如果 GZA 是最后一个条目，

233
00:12:30,400 --> 00:12:32,100
那么我必须逐行解析每一个条目。

234
00:12:33,330 --> 00:12:33,730
好的。

235
00:12:43,750 --> 00:12:47,270
她说，考虑到系统的限制，插入删除将非常可怕，

236
00:12:47,590 --> 00:12:50,370
所以插入不会那么糟糕，

237
00:12:50,370 --> 00:12:52,550
因为如果我只是附加到它的末尾，谁会在乎呢。

238
00:13:00,200 --> 00:13:02,940
是的，她说，如果我按发行年份分类，会怎么样，

239
00:13:03,560 --> 00:13:06,490
那么，是的，我得去找它应该在哪里，

240
00:13:07,850 --> 00:13:08,520
那会很糟糕，

241
00:13:09,770 --> 00:13:12,240
你也说过更新或删除，

242
00:13:12,380 --> 00:13:13,345
如果我想删除条目，

243
00:13:13,345 --> 00:13:14,515
我会得到与查找相同的问题，

244
00:13:14,515 --> 00:13:16,110
我必须找到正在寻找的东西并将其删除。

245
00:13:17,350 --> 00:13:18,560
这些都是[]问题，

246
00:13:19,720 --> 00:13:21,080
但还有一些其他问题。

247
00:13:33,910 --> 00:13:34,905
所以你的说法是，

248
00:13:34,905 --> 00:13:36,740
我把所有的东西都表示为，比如说，字符串，

249
00:13:36,760 --> 00:13:37,730
然后如果有什么。

250
00:13:49,170 --> 00:13:49,670
是的，没错，

251
00:13:49,670 --> 00:13:50,749
所以她的说法是，

252
00:13:51,129 --> 00:13:55,335
我在这种情况下 year 是文本文件，

253
00:13:55,335 --> 00:13:56,780
所以它是 ASCII 文本，

254
00:13:57,130 --> 00:13:59,240
但我的魔术解析函数，我还没有定义，

255
00:13:59,440 --> 00:14:02,420
不知何故知道，哦，这应该是一个整数，

256
00:14:02,530 --> 00:14:04,190
它将调用 atoi ，

257
00:14:05,050 --> 00:14:08,780
它将把字符串成一个整数，

258
00:14:09,470 --> 00:14:10,800
而且它是最好的，

259
00:14:12,235 --> 00:14:13,500
如果它只是磁盘上的一堆文件，

260
00:14:14,740 --> 00:14:16,400
一个解析错误，就崩溃了，

261
00:14:17,170 --> 00:14:17,610
这是个好想法。

262
00:14:21,930 --> 00:14:22,660
还有其他一些问题吗？

263
00:14:26,110 --> 00:14:27,290
你说读取，写入文件，

264
00:14:27,580 --> 00:14:28,670
我们在某种程度上涵盖了这些，

265
00:14:30,310 --> 00:14:31,560
如果你要插入到尾部，没什么问题，

266
00:14:33,210 --> 00:14:36,110
读取，能够很好吗？

267
00:14:40,760 --> 00:14:42,840
我们说过，名字中的一条评论可能会破坏，

268
00:14:43,250 --> 00:14:46,680
这点类似 Python 包。

269
00:14:47,020 --> 00:14:47,420
好的。

270
00:14:51,110 --> 00:14:53,190
是的，你说你不能使用这份文件，

271
00:14:55,260 --> 00:14:57,310
写入作为字符串有点危险，是的。

272
00:15:04,360 --> 00:15:04,760
是的。

273
00:15:30,590 --> 00:15:31,630
文件中，

274
00:15:31,630 --> 00:15:35,460
数据库的关联方案是隐式的，

275
00:15:37,520 --> 00:15:39,420
我们一会儿会看到。

276
00:15:40,840 --> 00:15:42,170
所以我们覆盖了这些。

277
00:15:43,380 --> 00:15:44,680
所以，我如何确保，

278
00:15:49,850 --> 00:15:50,790
很快返回。

279
00:15:54,300 --> 00:15:55,420
是的，所以，我有[]，

280
00:16:01,360 --> 00:16:02,310
但我会修好它的,

281
00:16:02,450 --> 00:16:04,800
我要确保我所拥有的每一行，

282
00:16:05,880 --> 00:16:07,720
所以所有的更新同时发生，

283
00:16:08,730 --> 00:16:10,060
它们是在磁盘上，

284
00:16:10,560 --> 00:16:12,550
操作系统或文件系统不知道，

285
00:16:14,090 --> 00:16:17,100
它只知道，你想读什么，

286
00:16:18,220 --> 00:16:20,390
所以我们现在在应用程序，

287
00:16:21,370 --> 00:16:24,530
我们要确保所有的条目都会[]。

288
00:16:26,500 --> 00:16:27,435
她提出了一个问题，

289
00:16:27,435 --> 00:16:29,450
如果有人用无效字符串写入 year ，

290
00:16:29,710 --> 00:16:30,770
我们会抛出一个解析错误，

291
00:16:31,330 --> 00:16:33,525
在我的示例中，我只有，

292
00:16:33,525 --> 00:16:36,110
我假设两者之间有一对一的对应关系，

293
00:16:38,120 --> 00:16:39,000
专辑只能有一个艺术家，

294
00:16:39,650 --> 00:16:41,410
但显然我们知道情况并非如此，

295
00:16:41,410 --> 00:16:42,210
很多专辑都是如此，

296
00:16:42,920 --> 00:16:46,660
那么，我现在如何更改我的文件以说明这一点呢，

297
00:16:49,070 --> 00:16:50,850
拥有专辑的首席艺人，

298
00:16:53,680 --> 00:16:56,490
在我的例子中，什么都不会发生，

299
00:16:56,490 --> 00:16:57,870
现在我有一堆专辑，

300
00:16:57,870 --> 00:17:00,230
其中的艺术家的名字没有任何匹配，

301
00:17:01,700 --> 00:17:04,320
所以，基准完整性被破坏。

302
00:17:05,890 --> 00:17:07,770
我们已经带来了很多实现问题，

303
00:17:07,770 --> 00:17:08,510
比如你如何查找，

304
00:17:09,310 --> 00:17:12,770
在我的例子中，它是 O(n) ，

305
00:17:13,510 --> 00:17:16,680
我必须对整个文件进行穷举扫描，

306
00:17:16,680 --> 00:17:17,810
才能找到我正在寻找的东西，

307
00:17:18,600 --> 00:17:21,310
现在如果我假设在那里，

308
00:17:22,090 --> 00:17:25,160
只有一个人有给定的名字，

309
00:17:25,510 --> 00:17:27,110
然后我就可以停下来，因为我已经完成了，

310
00:17:28,570 --> 00:17:29,690
一直都是同一个名字，

311
00:17:30,380 --> 00:17:33,160
那张专辑 GZA 找出来，

312
00:17:34,000 --> 00:17:35,900
比如佛罗里达州的 GZA 或类似的，

313
00:17:35,980 --> 00:17:37,460
我得继续扫描整个文件，

314
00:17:38,860 --> 00:17:40,650
这将是 n 或 [n 阶]。

315
00:17:42,780 --> 00:17:46,900
我的例子，再一次，那是在文件中运行的，

316
00:17:47,700 --> 00:17:49,630
但是假设我想重写它，现在运行，

317
00:17:50,010 --> 00:17:52,265
我想要编写一个使用相同数据库的新应用程序，

318
00:17:52,265 --> 00:17:53,230
但我想使用 Rust 编写，

319
00:17:53,790 --> 00:17:54,730
因为这是最热门的东西，

320
00:17:55,340 --> 00:17:56,800
现在我必须确保，

321
00:17:57,210 --> 00:18:00,370
我的 Python 代码中的任何信息或隐式方案

322
00:18:00,570 --> 00:18:02,500
现在都映射到了我的 Rust 代码，

323
00:18:02,790 --> 00:18:04,145
但是，如果我的文件发生了更改，

324
00:18:04,145 --> 00:18:07,030
我必须确保同时更改了 Python 代码和 Rust 代码，

325
00:18:07,610 --> 00:18:10,740
也许，比如，写 Python 代码的这个家伙在监狱里，

326
00:18:11,180 --> 00:18:14,230
我们无法更新它，

327
00:18:14,280 --> 00:18:15,400
现在，我该怎么办，

328
00:18:16,650 --> 00:18:17,200
快要崩溃了。

329
00:18:18,380 --> 00:18:20,920
如果这个应用程序即使在同一台机器上，

330
00:18:20,920 --> 00:18:22,750
我的 Python 代码运行的机器，

331
00:18:22,750 --> 00:18:24,540
比如作为一个单独的机器上的微服务运行，

332
00:18:24,920 --> 00:18:26,610
我如何访问另一个，

333
00:18:27,140 --> 00:18:28,410
我如何才能访问那个文件。

334
00:18:30,730 --> 00:18:37,230
然后，如果你有两个线程试图写入相同的文件，

335
00:18:38,360 --> 00:18:40,590
好的，你可以依靠操作系统来做，

336
00:18:42,470 --> 00:18:43,855
但同样的，如果我有 10 亿条记录，

337
00:18:43,855 --> 00:18:44,965
我想要更新其中的一条记录，

338
00:18:44,965 --> 00:18:46,930
不想锁定 10 亿条记录，

339
00:18:46,930 --> 00:18:47,730
只需更新这条记录，

340
00:18:48,230 --> 00:18:49,950
理想情况下，当我完成更多的细粒度时，

341
00:18:50,000 --> 00:18:51,840
可以有多个线程。

342
00:18:58,120 --> 00:19:00,630
如果发生崩溃，如何确保我们的数据安全，

343
00:19:06,460 --> 00:19:09,710
然后我在 fsync 之前崩溃了，

344
00:19:10,480 --> 00:19:12,560
其中一些数据可能已经到了那张磁盘，

345
00:19:12,970 --> 00:19:14,540
所以当我的，

346
00:19:15,350 --> 00:19:16,650
我必须再来一次，

347
00:19:18,530 --> 00:19:19,840
这不是我想要的，

348
00:19:19,840 --> 00:19:20,760
因为现在我破坏了数据，

349
00:19:22,760 --> 00:19:25,315
或者现在我的数据库真的很大，

350
00:19:25,315 --> 00:19:27,210
有很多人想访问它，

351
00:19:27,530 --> 00:19:31,500
我如何确保可以跨多台计算机进行复制，

352
00:19:31,850 --> 00:19:33,750
以便它们可以同时为所有读取提供服务，

353
00:19:34,210 --> 00:19:35,690
这样我的应用程序就可以向上扩展，

354
00:19:37,160 --> 00:19:38,190
文件不会帮我做到这一点。

355
00:19:39,780 --> 00:19:44,940
所以这只是数据库管理系统的一小部分，

356
00:19:45,230 --> 00:19:47,040
在我看来，为什么会有这门课。

357
00:19:48,390 --> 00:19:50,960
所以，作为我们的数据库管理系统是，

358
00:19:50,960 --> 00:19:56,170
允许应用程序在数据库中存储和分析信息的软件，

359
00:19:57,040 --> 00:20:01,220
理想情况下，不必担心我们刚刚谈到的所有事情，

360
00:20:01,780 --> 00:20:02,960
但情况并不总是这样，

361
00:20:03,130 --> 00:20:05,630
这其中有很多取舍，

362
00:20:09,590 --> 00:20:11,790
[保证]换来的是性能，

363
00:20:13,210 --> 00:20:16,140
而通用系统通常允许你，

364
00:20:16,140 --> 00:20:18,710
调整这些权衡是什么。

365
00:20:21,590 --> 00:20:29,200
所以，数据库管理系统将定义或指定实现，

366
00:20:29,200 --> 00:20:31,720
如何创建数据库，

367
00:20:31,720 --> 00:20:32,640
如何查询数据库，

368
00:20:32,840 --> 00:20:35,980
如何更改，如何管理数据库，

369
00:20:35,980 --> 00:20:37,500
进行更改以及其他事情，

370
00:20:38,630 --> 00:20:41,430
插入某种数据模型的对应关系。

371
00:20:42,610 --> 00:20:44,360
我也要再次说，

372
00:20:44,650 --> 00:20:46,850
不管你是否真的去构建数据库系统，

373
00:20:47,860 --> 00:20:49,190
在你的日常工作中，

374
00:20:49,720 --> 00:20:51,660
这是很重要的，知道你去哪里，

375
00:20:51,660 --> 00:20:53,940
因为在某个时候，你会构建一些应用程序，

376
00:20:53,940 --> 00:20:56,510
你必须决定我想要使用哪种数据库管理系统，

377
00:20:56,950 --> 00:20:58,460
这应该始终是你的第一选择，

378
00:20:58,600 --> 00:21:01,380
如果不想做我在这里的[]，

379
00:21:04,520 --> 00:21:05,190
有很多问题。

380
00:21:06,410 --> 00:21:08,220
想象你在一家创业公司，

381
00:21:08,730 --> 00:21:11,200
你尝试构建一个应用程序，

382
00:21:13,360 --> 00:21:14,355
初创公司没有很多钱，

383
00:21:14,355 --> 00:21:17,115
你有压力，也没有时间试着把东西拿出来，

384
00:21:17,115 --> 00:21:18,350
把第一个版本推出来，

385
00:21:18,610 --> 00:21:20,625
你真的想花时间确保

386
00:21:20,625 --> 00:21:22,100
你的数据是安全的，当发生崩溃时，

387
00:21:23,560 --> 00:21:27,080
因为归根结底，这并不是你的业务或应用程序的一个显著特征，

388
00:21:27,100 --> 00:21:29,030
没有人关心，如果你真的丢失了数据，

389
00:21:29,200 --> 00:21:31,400
所以如果你崩溃了，你不会丢失数据，

390
00:21:31,600 --> 00:21:37,430
这样考虑，在现代计算系统中，

391
00:21:37,960 --> 00:21:41,900
所以，与其花费所有时间试图租用你自己的定制数据库系统，

392
00:21:42,400 --> 00:21:43,460
你应该只用一些上面的东西，

393
00:21:44,680 --> 00:21:46,190
变更是可能的，

394
00:21:46,810 --> 00:21:49,140
在一百种情况下，

395
00:21:49,430 --> 00:21:51,090
这是你应该使用的第一选择，

396
00:21:51,650 --> 00:21:52,650
也许是 SQLite ，

397
00:21:53,550 --> 00:21:56,050
但 Postgres 会让你走得很远，

398
00:21:59,835 --> 00:22:00,590
我在这里说的。

399
00:22:03,610 --> 00:22:06,270
再次，数据模型将是，

400
00:22:06,270 --> 00:22:11,870
我们将如何表示数据库中的实体或数据集合，

401
00:22:12,970 --> 00:22:19,790
所以，数据模型就是这种高级抽象，

402
00:22:21,100 --> 00:22:25,970
指定我们如何表示各个实体以及可能与之相关的[]，

403
00:22:26,670 --> 00:22:28,955
再次，我们试图对真实世界的某些方面进行建模，

404
00:22:28,955 --> 00:22:31,150
学生上课，学生拿到成绩，

405
00:22:31,650 --> 00:22:33,250
他们在自己的内政部门。

406
00:22:35,090 --> 00:22:40,740
然后，模式将表示、定义或描述，

407
00:22:41,540 --> 00:22:46,540
我们的数据库数据模型中的这些实体是什么样子，

408
00:22:47,770 --> 00:22:51,440
学生姓名，有出生日期，电子邮件地址等等，

409
00:22:51,880 --> 00:22:54,500
你将在我们的模式中指定所有这些，

410
00:22:54,610 --> 00:22:57,230
然后我们将根据该模式实例化，

411
00:22:57,910 --> 00:23:00,620
基于数据模型的数据库实例。

412
00:23:02,730 --> 00:23:04,840
市场上有很多不同的数据模型，

413
00:23:04,950 --> 00:23:07,745
这可以追溯到数据库的最开始，

414
00:23:07,745 --> 00:23:11,650
人们意识到，我们需要一个在数据库中。

415
00:23:13,310 --> 00:23:15,750
今天的大多数系统，

416
00:23:16,980 --> 00:23:20,530
看起来像关系数据库，关系关系数据模型，

417
00:23:21,270 --> 00:23:22,750
有一种叫做对象关系，

418
00:23:23,310 --> 00:23:25,690
Postgres 是意味着你可以用用户定义的类型

419
00:23:25,830 --> 00:23:27,490
来扩展你的关系，

420
00:23:29,580 --> 00:23:33,550
但在高层次上，大多数数据系统都将是关系型的，

421
00:23:33,930 --> 00:23:36,250
我认为那个 DB Engines 排名，

422
00:23:36,860 --> 00:23:37,800
最流行的数据库，

423
00:23:38,270 --> 00:23:41,580
我认为五个最流行的数据库中有四个都是关系型的，

424
00:23:42,020 --> 00:23:43,590
Mongo 是其他的。

425
00:23:45,320 --> 00:23:46,800
然后还有一堆其他的数据模型，

426
00:23:47,630 --> 00:23:49,470
在某种程度上属于这个总括术语，

427
00:23:51,790 --> 00:23:53,055
一种 NoSQL 系统，

428
00:23:53,055 --> 00:23:57,290
它通常是文档数据模型或 json 其中之一，

429
00:23:57,610 --> 00:23:59,630
Cassandra 是其中之一，

430
00:24:00,100 --> 00:24:03,140
但有键值存储数据库，

431
00:24:03,700 --> 00:24:06,500
然后[]类型的家族是什么？

432
00:24:23,610 --> 00:24:26,290
有数组矩阵和矢量数据数据模型，

433
00:24:26,550 --> 00:24:31,330
它们主要用于机器学习或科学应用，

434
00:24:32,010 --> 00:24:34,150
比如一颗卫星绕着拍了一大堆照片，

435
00:24:34,320 --> 00:24:35,710
你可以将其存储为数组，

436
00:24:37,800 --> 00:24:39,490
训练某种模型的张量，

437
00:24:39,780 --> 00:24:41,740
你也会把它表示为[]，

438
00:24:41,910 --> 00:24:46,000
所以有专门的数据库可以表示原生的数组。

439
00:24:47,510 --> 00:24:49,440
然后这些最后的是为以前的人，

440
00:24:50,090 --> 00:24:51,570
分层，网络和多值，

441
00:24:53,970 --> 00:24:55,990
现在，这些被认为是过时的，

442
00:24:57,860 --> 00:24:59,760
因为我每一次都能赚很多钱，

443
00:25:01,740 --> 00:25:03,490
分层模型在 IMS 中使用，

444
00:25:05,240 --> 00:25:07,020
IBM 构建的第一个数据库系统，

445
00:25:07,960 --> 00:25:13,170
所有[]的组成部分，在 1960 年代，

446
00:25:18,050 --> 00:25:19,530
每个 ATM 都使用，

447
00:25:20,090 --> 00:25:21,370
我的意思是不是盒子本身，

448
00:25:21,370 --> 00:25:23,130
而是当你与银行沟通时，

449
00:25:24,020 --> 00:25:25,390
很多这些系统都在使用 IMS ，

450
00:25:26,140 --> 00:25:30,500
美国社会保障部仍在使用 IMS 。

451
00:25:32,090 --> 00:25:33,630
所以，这些东西是存在的，

452
00:25:33,710 --> 00:25:35,020
但如果你是全新的，

453
00:25:35,020 --> 00:25:36,580
你不会说我会使用 IMS ，

454
00:25:36,580 --> 00:25:37,765
或我将使用 IMS ，

455
00:25:37,765 --> 00:25:39,780
你要是那样做肯定是疯了，

456
00:25:39,890 --> 00:25:41,970
但是再次，不用管，

457
00:25:42,945 --> 00:25:43,790
它在这里并不相关。

458
00:25:44,110 --> 00:25:45,020
在本课程中，

459
00:25:46,970 --> 00:25:48,480
关系数据模型中的一些数据库。

460
00:25:49,940 --> 00:25:51,715
这就是为什么我对[]的事情很生气，

461
00:25:51,715 --> 00:25:52,590
因为我们回到这里，

462
00:25:53,510 --> 00:25:57,870
Justin ，评委审查了你在科技挑战类别中的矩阵的回答，

463
00:25:57,950 --> 00:26:00,180
他们认为这是正确的，

464
00:26:00,560 --> 00:26:02,575
我们已经在你的分数上增加了 800 美元，

465
00:26:02,575 --> 00:26:05,880
你所有的赌注都是在调整后的分数上进行的。

466
00:26:06,670 --> 00:26:08,510
没有关系矩阵这回事，

467
00:26:10,040 --> 00:26:11,640
我给他们发了一封电子邮件，他们没有回应。

468
00:26:14,840 --> 00:26:17,120
无论如何，拿到博士学位，

469
00:26:17,120 --> 00:26:18,310
我认为这就像神经科学，

470
00:26:18,960 --> 00:26:20,890
但就像，随便什么。

471
00:26:21,300 --> 00:26:24,520
所以希望，如果这门课没有其他内容，

472
00:26:25,170 --> 00:26:26,110
你可以回答这个问题。

473
00:26:29,120 --> 00:26:30,720
让我们回到 1960 年代，

474
00:26:31,400 --> 00:26:34,290
这再次激发了为什么关系模型的产生，

475
00:26:34,610 --> 00:26:38,020
它将为我们建立为什么它仍然流行，

476
00:26:38,020 --> 00:26:39,060
为什么今天的仍在使用，

477
00:26:39,970 --> 00:26:42,800
对于任何新的。

478
00:26:45,370 --> 00:26:47,780
回到 1960 年代早期，

479
00:26:51,310 --> 00:26:53,715
没有关系模型，没有关系数据库，

480
00:26:53,715 --> 00:26:56,270
也没有 Postgres MySQL SQLite 模型，

481
00:26:58,330 --> 00:27:03,300
最开始，人们构建的不是通用的，

482
00:27:03,300 --> 00:27:04,305
但是他们意识到，

483
00:27:04,305 --> 00:27:09,560
哦，不是只为这一个应用程序构建这些定制的数据库应用程序或数据库系统，

484
00:27:10,030 --> 00:27:11,250
我可以做得更通用一些，

485
00:27:11,250 --> 00:27:13,460
现在我可以支持任何可能的应用程序，

486
00:27:14,080 --> 00:27:17,360
目前，第一个存在的数据库系统，

487
00:27:17,890 --> 00:27:20,500
是由通用电气构建的，

488
00:27:20,700 --> 00:27:24,700
后来被出售给霍尼韦尔 1960 年代，

489
00:27:24,930 --> 00:27:28,800
他们最初构建的 IDS 是为了保留[]，在西雅图，

490
00:27:29,060 --> 00:27:31,860
然后他们意识到，哦，不只是为了[]，

491
00:27:32,640 --> 00:27:33,915
我们可以做一些调整，然后使它，

492
00:27:33,915 --> 00:27:37,040
这样我们造纸公司就可以使用它，或者电话公司可以使用它，

493
00:27:37,390 --> 00:27:40,700
这可以说是有史以来最早的通用数据库系统之一。

494
00:27:51,940 --> 00:27:53,640
哦，我们可以把它用在其他应用程序上，

495
00:27:53,640 --> 00:27:55,130
他们推广了它。

496
00:27:55,940 --> 00:28:02,640
而 CODASYL 是一种标准，定义于六十年代末或七十年代，

497
00:28:02,960 --> 00:28:07,440
作为一种与数据库系统交互的方式，

498
00:28:08,120 --> 00:28:10,290
人们意识到，与其拥有这些标准，

499
00:28:11,900 --> 00:28:13,650
当时正在构建的数据系统，

500
00:28:14,000 --> 00:28:15,660
我们将有标准化的方式，

501
00:28:21,330 --> 00:28:22,900
不到 5% 或 5% 。

502
00:28:24,450 --> 00:28:26,320
我猜你在这里听到过 CODASYL 。

503
00:28:27,530 --> 00:28:29,970
一个，好的，那是为什么，

504
00:28:31,910 --> 00:28:35,610
在书里，在书里，是的。

505
00:28:38,440 --> 00:28:38,840
人们，

506
00:28:40,170 --> 00:28:41,830
在这些早期系统中，

507
00:28:42,570 --> 00:28:45,340
这是你与数据库系统交互的方式，

508
00:28:45,750 --> 00:28:50,020
而在这些最初的影响中固有的许多事情

509
00:28:50,520 --> 00:28:52,150
是你今天不想做的事情，

510
00:28:52,740 --> 00:28:54,080
最重要的一件事是，

511
00:28:54,080 --> 00:28:54,800
在这些第一批系统中，

512
00:28:54,800 --> 00:28:56,060
它们有紧密的耦合，

513
00:28:56,060 --> 00:29:01,900
在逻辑层、模式，拥有什么实体、它们的属性，

514
00:29:02,190 --> 00:29:03,850
以及系统中的物理层之间，

515
00:29:04,300 --> 00:29:07,640
这意味着，如何在磁盘或内存中表示，

516
00:29:07,810 --> 00:29:10,280
以及我将如何与它们交互，

517
00:29:10,690 --> 00:29:11,910
发生的情况是，

518
00:29:11,910 --> 00:29:13,910
如果你当时是一名程序员，

519
00:29:14,140 --> 00:29:16,005
你想要使用其中一个数据库系统，

520
00:29:16,005 --> 00:29:19,310
你必须确切地知道数据库如何存储你的数据库，

521
00:29:20,020 --> 00:29:23,810
因为这将向你公开一个不同的 API 来与其交互。

522
00:29:24,760 --> 00:29:26,730
在 IMS 上，你可以将数据存储为

523
00:29:26,730 --> 00:29:29,480
哈希表或 B+ 树或树结构，

524
00:29:29,800 --> 00:29:31,610
然后你有不同的 API ，

525
00:29:31,780 --> 00:29:34,370
因为，取决于我们使用的数据结构，

526
00:29:34,690 --> 00:29:36,980
因为哈希表，你不能进行扫描，

527
00:29:37,660 --> 00:29:39,890
但是在树形结构中（可以）。

528
00:29:42,170 --> 00:29:43,590
所以，现在的问题是，

529
00:29:43,910 --> 00:29:48,990
每当我想要同时更改逻辑层和物理层的模式时，

530
00:29:49,100 --> 00:29:50,850
我都必须重写我的应用程序，

531
00:29:52,380 --> 00:29:53,140
几乎是从头开始，

532
00:29:53,160 --> 00:29:56,290
因为，数据库在磁盘上的表示方式发生了变化，

533
00:29:57,440 --> 00:29:58,890
数据模型的其他问题，

534
00:29:59,270 --> 00:30:00,180
我们不需要真正的，

535
00:30:01,370 --> 00:30:04,510
比如在更高的模型中，

536
00:30:04,510 --> 00:30:06,990
你必须有循环遍历，

537
00:30:07,460 --> 00:30:09,870
一个集合与另一个集合，

538
00:30:10,280 --> 00:30:13,860
这是与数据库系统交互非常低效的方式。

539
00:30:16,020 --> 00:30:18,100
事情发生在 1960 年代末，

540
00:30:18,450 --> 00:30:20,770
有一个人， Ted Codd ，他是，

541
00:30:26,630 --> 00:30:30,250
他来到纽约，[大实验室]所在地，

542
00:30:30,250 --> 00:30:34,770
他看到了所有这些 IBM 开发人员的主要工作，

543
00:30:35,620 --> 00:30:39,075
看到他们一遍又一遍地重写数据库应用程序，

544
00:30:39,075 --> 00:30:40,650
每一次 schema 改变，

545
00:30:40,650 --> 00:30:44,860
都是物理布局的改变，

546
00:30:47,210 --> 00:30:48,000
人类的反应很快，

547
00:30:48,830 --> 00:30:51,910
所以人们，我们只是把这个问题上给人类，

548
00:30:51,910 --> 00:30:54,870
这比买一个[]更好，

549
00:30:56,760 --> 00:30:59,020
所以，我的例子是，他指出，

550
00:30:59,710 --> 00:31:00,440
嵌入我的（例子），

551
00:31:01,800 --> 00:31:03,220
所以， name 列，

552
00:31:03,600 --> 00:31:06,950
现在把它当成艺术家的 ID ，

553
00:31:08,730 --> 00:31:09,460
我必须，

554
00:31:13,270 --> 00:31:13,980
一个微不足道的例子，

555
00:31:13,980 --> 00:31:15,740
但这是他们以前做的那种垃圾。

556
00:31:17,900 --> 00:31:20,970
所以， Codd 看到这个，说一定有更好的方法，

557
00:31:21,350 --> 00:31:25,885
他（构建）了一个模型作为抽象，

558
00:31:25,885 --> 00:31:30,270
关于如何表示数据库，

559
00:31:30,950 --> 00:31:34,020
以及数据库中实体之间的关系，

560
00:31:34,550 --> 00:31:40,110
避免了物理层和逻辑层之间的紧密耦合，

561
00:31:40,370 --> 00:31:42,570
意味着用数学术语定义它，

562
00:31:42,890 --> 00:31:43,860
我有这些关系，

563
00:31:43,880 --> 00:31:46,410
这是我可以对它们进行的操作、更改或查找，

564
00:31:46,580 --> 00:31:48,150
我不知道，我不在乎，

565
00:31:48,500 --> 00:31:51,240
隐藏在幕后的数据库系统将如何存储这些数据，

566
00:31:51,820 --> 00:31:53,610
因为数据系统知道数据是什么，

567
00:31:53,610 --> 00:31:54,440
知道查询是什么，

568
00:31:54,490 --> 00:31:57,170
所以它可以更好地决定如何（处理），

569
00:32:01,250 --> 00:32:04,320
IBM 第一次提出关系数据模型是在 1969 年，

570
00:32:05,030 --> 00:32:06,480
这是一份科技报告。

571
00:32:16,980 --> 00:32:18,370
再说一次，数学家，

572
00:32:18,900 --> 00:32:21,875
他当时并没有定义编程语言，

573
00:32:21,875 --> 00:32:23,530
他没有说你如何实现这一点，

574
00:32:23,730 --> 00:32:26,830
他只是在定义什么是关系，

575
00:32:27,090 --> 00:32:31,000
以及操纵它们的代数。

576
00:32:32,650 --> 00:32:34,850
所以，有三个关键的原则，

577
00:32:36,870 --> 00:32:38,350
但这三个是受最关心的。

578
00:32:39,970 --> 00:32:40,905
所以，第一个是，

579
00:32:41,010 --> 00:32:45,480
我们要存储所有的数据在简单的数据结构中，

580
00:32:47,210 --> 00:32:50,760
这是数学术语，和表格是一样的，

581
00:32:51,230 --> 00:32:52,390
如果你来自 Mongo 世界，

582
00:32:52,390 --> 00:32:54,960
他们称之为 collection ，这是同样的想法，

583
00:32:56,570 --> 00:32:57,840
所有这些简单的数据结构，

584
00:32:58,880 --> 00:33:01,015
我考虑所有的成员关系集，

585
00:33:01,015 --> 00:33:02,130
而不是所有其他的数据集。

586
00:33:04,170 --> 00:33:04,760
第二个是，

587
00:33:04,760 --> 00:33:08,990
你将保留物理表示在数据库本身，

588
00:33:08,990 --> 00:33:11,740
比如磁盘或内存中的实际位和字节，

589
00:33:12,210 --> 00:33:13,360
你将留着它，

590
00:33:13,960 --> 00:33:16,600
你不[]它在你的关系数据模型中，

591
00:33:17,450 --> 00:33:18,475
把这个留给数据库系统，

592
00:33:18,475 --> 00:33:21,045
然后找出最好的方法，

593
00:33:21,045 --> 00:33:22,430
因为现在的想法可能是，

594
00:33:22,450 --> 00:33:24,255
如果我以一种方式存储数据，

595
00:33:24,255 --> 00:33:26,540
但当我看到我要放入什么样的数据，

596
00:33:27,010 --> 00:33:29,325
把数据放入什么样的设备，

597
00:33:29,325 --> 00:33:32,115
哦，我想把它存储在两台机器或文件上，

598
00:33:32,115 --> 00:33:34,910
或者用不同的方式拆分，或者用一种方式分类，

599
00:33:35,350 --> 00:33:37,250
再次，现在你的应用程序没有改变，

600
00:33:37,900 --> 00:33:40,520
因为你只是在很高的级别编写查询，

601
00:33:41,100 --> 00:33:46,005
你不会在乎在下面的情况，

602
00:33:46,005 --> 00:33:49,065
这就是你要在高级别上定义的，

603
00:33:49,065 --> 00:33:50,540
你将通过高级语言访问数据，

604
00:33:50,890 --> 00:33:52,610
然后让数据系统找出，

605
00:33:52,870 --> 00:33:56,780
检索你在寻找的数据的最佳方式，

606
00:33:56,830 --> 00:33:58,550
做任何你想做的操作。

607
00:34:00,470 --> 00:34:03,570
所以， Codd 在 1981 年获得了图灵奖，

608
00:34:04,190 --> 00:34:06,270
[]说他会在 72 岁获得，

609
00:34:06,680 --> 00:34:08,970
但人们花了十年时间意识到他是错的.

610
00:34:09,640 --> 00:34:11,100
直到他获得图灵奖，

611
00:34:12,470 --> 00:34:13,230
Codd 去世了，

612
00:34:17,450 --> 00:34:22,380
然后，在数据库中获得图灵奖的另一个人 Jim Gray ，

613
00:34:22,580 --> 00:34:24,210
他获得[]，

614
00:34:24,500 --> 00:34:29,640
最后，数据库中的获得图灵奖的是 Michael Stonebraker 和他的 Postgres ，

615
00:34:29,960 --> 00:34:31,830
他是 IBM 的顾问，

616
00:34:32,090 --> 00:34:33,060
好的，我们会说到 Stonebraker 。

617
00:34:35,120 --> 00:34:37,140
所以，数据模型有三个关键方面。

618
00:34:37,340 --> 00:34:38,520
其中的结构是，

619
00:34:39,110 --> 00:34:42,570
我们如何定义数据库是什么，

620
00:34:42,830 --> 00:34:44,280
我们的关系中有什么，

621
00:34:44,750 --> 00:34:46,140
它们的属性和类型是什么。

622
00:34:46,940 --> 00:34:48,900
有一些完整性方法，

623
00:34:48,920 --> 00:34:52,745
指定允许将哪些数据存储在数据库中，

624
00:34:52,745 --> 00:34:53,980
确保每一个，

625
00:34:55,200 --> 00:34:57,340
邮箱会出错，如果记录没有邮箱地址，

626
00:34:57,630 --> 00:34:58,570
或者，在我的例子中，

627
00:34:59,360 --> 00:35:00,840
我不能有一张专辑，

628
00:35:01,370 --> 00:35:03,510
有一个不存在于 artist 表的艺术家。

629
00:35:06,010 --> 00:35:08,955
然后，操纵机制允许我们定义，

630
00:35:08,955 --> 00:35:10,970
如何访问和更新数据，

631
00:35:11,660 --> 00:35:15,250
最后一个，我们在开始讨论的时候会讲到。

632
00:35:20,540 --> 00:35:23,170
一组无序数据，

633
00:35:23,170 --> 00:35:27,120
将包含代表现实世界中某个实体的属性之间的关系，

634
00:35:27,620 --> 00:35:30,990
所以，该模型并不意味着表之间的关系，

635
00:35:31,370 --> 00:35:33,090
它实际上是属性之间的关系，

636
00:35:33,890 --> 00:35:34,290
在表里面。

637
00:35:36,200 --> 00:35:38,165
所以，再次，学生有一个电子邮件地址，

638
00:35:38,165 --> 00:35:39,250
他们有一个电话号码，

639
00:35:40,920 --> 00:35:43,240
一个生日，一个家庭地址，

640
00:35:43,530 --> 00:35:47,620
这些属性组合在一起的关系代表了一些（学生）。

641
00:35:50,450 --> 00:35:53,070
所以，我们将拥有一组属性，

642
00:35:53,360 --> 00:35:54,360
我会用 tuple 这个词，

643
00:35:54,620 --> 00:35:57,360
但它也意味着记录或列，

644
00:35:58,490 --> 00:36:01,290
在更高的级别上，它们的意思都是一样的。

645
00:36:02,620 --> 00:36:09,490
所以，对于关系数据模型的原始定义中的每一个，

646
00:36:09,840 --> 00:36:12,010
所有值都必须是原子值或标量值，

647
00:36:12,580 --> 00:36:14,990
但是再次，随着时间的推移，事情发生了变化，

648
00:36:19,640 --> 00:36:21,835
Codd 在 70 年代没有预见到这些事情，

649
00:36:21,835 --> 00:36:22,320
这是，

650
00:36:23,770 --> 00:36:24,440
今天支持这一点。

651
00:36:25,170 --> 00:36:27,100
当然，所有都在那里，

652
00:36:27,870 --> 00:36:30,250
所以我们可以，在某些情况下，

653
00:36:30,420 --> 00:36:33,860
某些属性的值可能为空，

654
00:36:33,860 --> 00:36:35,110
这意味着它在当时是未知的，

655
00:36:35,490 --> 00:36:39,700
而且你可以在模式中指定是否希望支持。

656
00:36:43,740 --> 00:36:45,130
所以在每个关系中，

657
00:36:45,300 --> 00:36:47,320
都会有一个主键，

658
00:36:47,820 --> 00:36:50,800
它将被用来唯一标识一个 tuple ，

659
00:36:51,240 --> 00:36:54,640
想象一下你的学生证，你在大学里的 Andrew ID ，

660
00:36:56,920 --> 00:36:58,730
这让我们可以确切地知道，

661
00:37:01,300 --> 00:37:02,600
或者我们想要的记录，

662
00:37:03,040 --> 00:37:03,620
当我们操作的时候。

663
00:37:05,730 --> 00:37:06,460
这里有个例子，

664
00:37:20,950 --> 00:37:25,070
我们数据库中的特定条目，

665
00:37:25,570 --> 00:37:27,320
但是你的 Andrew ID 是唯一的，

666
00:37:27,910 --> 00:37:31,820
所以，这是大学数据库的主键。

667
00:37:32,760 --> 00:37:36,540
在你没有的主键情况下，你能做些什么，

668
00:37:42,240 --> 00:37:42,940
标识列，

669
00:37:45,640 --> 00:37:46,490
主键。

670
00:37:47,310 --> 00:37:48,815
你会在 ORM 中看到很多这个，

671
00:37:48,815 --> 00:37:53,150
比如 SQLite ，如果你使用的是 NodeJS ，

672
00:37:53,380 --> 00:37:58,430
很多时候这些框架将把这些主键当为存在的。

673
00:38:00,540 --> 00:38:04,180
所以，主键是一个约束，

674
00:38:04,530 --> 00:38:07,450
数据库管理系统将对你的关系数据强制执行，

675
00:38:07,560 --> 00:38:09,520
确保在任何给定关系中，

676
00:38:09,750 --> 00:38:14,440
不存在具有相同主键的多个记录。

677
00:38:17,350 --> 00:38:20,205
在这个学期讨论如何做自动身份列，

678
00:38:20,205 --> 00:38:23,810
但是数据系统有方法可以为你生成这些列。

679
00:38:27,400 --> 00:38:30,660
外键，这是为了强制引用完整性，

680
00:38:30,660 --> 00:38:36,740
以确保，如果我有一个二对一的关系，

681
00:38:37,490 --> 00:38:40,140
与另一个 tuple 关系关联，

682
00:38:40,790 --> 00:38:45,930
数据库系统评估一个孤儿或一个坏了的，

683
00:38:46,250 --> 00:38:48,870
因为你从一行中删除了记录，

684
00:38:49,250 --> 00:38:51,120
仍然有一个[悬挂点]和另一行。

685
00:38:52,470 --> 00:38:53,890
回到我们的数据库，

686
00:39:07,230 --> 00:39:08,410
在它的表中。

687
00:39:09,570 --> 00:39:12,490
但是假设我们这里有一盘混音磁带，

688
00:39:12,690 --> 00:39:14,230
我们有一群艺术家出现在上面，

689
00:39:15,060 --> 00:39:18,670
我们该怎么做，在这盘混音磁带上，

690
00:39:19,280 --> 00:39:23,320
对于[关系支持数组]，最少是它的原始版本。

691
00:39:29,170 --> 00:39:31,370
所以，在数据模型中，

692
00:39:31,630 --> 00:39:34,100
执行这个操作，你将拥有一个交叉引用表，

693
00:39:34,920 --> 00:39:40,210
我可以在那里跟踪艺术家和专辑之间独特的关系对。

694
00:39:57,500 --> 00:39:59,340
现在，再次，

695
00:40:21,230 --> 00:40:22,900
同样，它会为你做这件事，

696
00:40:22,900 --> 00:40:24,240
所以你只需编写相同的删除命令，

697
00:40:26,510 --> 00:40:29,120
关键并不是为你做事情，

698
00:40:29,810 --> 00:40:32,250
我自己的 Python 代码中，

699
00:40:32,660 --> 00:40:35,275
我必须自己在我的应用程序代码中完成所有这些工作，

700
00:40:35,275 --> 00:40:36,250
跟踪这些指针，

701
00:40:36,250 --> 00:40:37,360
找到我正在寻找的东西，

702
00:40:37,360 --> 00:40:40,800
确保我没有这些依赖项。

703
00:40:44,300 --> 00:40:45,360
你这样做的方式是，

704
00:41:05,030 --> 00:41:07,260
如果违反，抛出错误。

705
00:41:10,360 --> 00:41:15,740
最后，你可以有约束或保护机制，

706
00:41:16,180 --> 00:41:17,385
你可以使强制数据系统，

707
00:41:17,385 --> 00:41:23,600
以确保数据遵循符合某些域的值，

708
00:41:25,060 --> 00:41:25,730
或者，

709
00:41:27,630 --> 00:41:28,740
你没有值或 tuple ，

710
00:41:28,740 --> 00:41:31,640
给你带来其他东西。

711
00:41:32,280 --> 00:41:37,910
可以为指定给定属性或全局的概念，

712
00:41:38,620 --> 00:41:41,150
具有给定属性或跨多个表的给定表，

713
00:41:41,440 --> 00:41:44,420
我可以每一次我进行修改，

714
00:41:44,950 --> 00:41:46,700
或任何这些约束被违反，

715
00:41:47,200 --> 00:41:49,520
如果是，那么我抛出一个错误，

716
00:41:49,630 --> 00:41:51,170
不让你做任何改变。

717
00:41:51,700 --> 00:41:53,265
所以，再次回到这个例子，

718
00:41:53,265 --> 00:41:53,900
她之前提到过的，

719
00:41:53,920 --> 00:41:56,960
如果有人在你的列中写了一个字符串字符怎么办，

720
00:41:57,440 --> 00:41:58,720
对于我的 CSV 文件，

721
00:41:59,930 --> 00:42:01,615
数据库系统可能会阻止你这样做，

722
00:42:01,615 --> 00:42:02,890
如果你遇到这些约束，

723
00:42:02,890 --> 00:42:04,920
因为我们会知道你试图保存一些东西，

724
00:42:05,510 --> 00:42:07,740
试图将字符保存到整型列中，

725
00:42:07,850 --> 00:42:09,450
我不能让你这样做，并抛出错误，

726
00:42:10,770 --> 00:42:11,555
你可以执行其他操作，

727
00:42:11,555 --> 00:42:16,360
如确保年份必须大于 100 或大于 0 ，

728
00:42:17,830 --> 00:42:19,550
操作系统将为你强制执行这个。

729
00:42:20,710 --> 00:42:22,220
最常见的限制在这里，

730
00:42:26,210 --> 00:42:27,210
事情可能会发生在你身上，

731
00:42:44,760 --> 00:42:45,820
不让你做出改变。

732
00:42:52,800 --> 00:42:54,725
但是再次，我们在我们的方案中发现，

733
00:42:54,725 --> 00:42:57,400
原始的数据库系统是不能确保强制的。

734
00:42:57,540 --> 00:42:59,980
所以现在你知道了，

735
00:43:01,240 --> 00:43:03,020
Python 代码是[]，

736
00:43:03,430 --> 00:43:04,580
你必须开始做出改变，

737
00:43:04,750 --> 00:43:06,410
他们知道数据库里发生了什么，

738
00:43:07,150 --> 00:43:09,290
数据库将阻止你[搬起石头砸自己的脚]，

739
00:43:09,550 --> 00:43:10,340
做出改变，

740
00:43:11,450 --> 00:43:12,240
（使用）这些约束。

741
00:43:19,510 --> 00:43:20,700
好的，现在我们要谈谈，

742
00:43:20,700 --> 00:43:21,950
我们想要如何与数据库交互，

743
00:43:22,450 --> 00:43:24,765
假设我们建立了，我们定义了，

744
00:43:24,765 --> 00:43:26,990
我们的数据库和关系将是什么样子的，

745
00:43:28,360 --> 00:43:32,800
我们想谈谈我们想怎么对其进行查询。

746
00:43:33,430 --> 00:43:34,980
所以，在比较高的层面上，

747
00:43:34,980 --> 00:43:36,440
有两种基本的方法来做到这个，

748
00:43:36,730 --> 00:43:38,930
有过程性语言和非过程性语言，

749
00:43:50,560 --> 00:43:54,275
非过程性的是，

750
00:43:54,275 --> 00:43:57,100
你说，这就是答案，我想让你计算，

751
00:43:57,300 --> 00:43:59,950
我不知道怎么算，你自己解决。

752
00:44:01,460 --> 00:44:08,900
所以， SQL 或关系型演算是非过程的，声明式的，

753
00:44:09,280 --> 00:44:10,770
我们不会讨论关系演算，

754
00:44:10,770 --> 00:44:12,080
因为你不知道它，

755
00:44:13,610 --> 00:44:16,020
我从来没有用过关系演算，你用过吗，

756
00:44:16,310 --> 00:44:16,710
从来没有，

757
00:44:18,230 --> 00:44:20,460
只有理论论文，我们不会做，我们不关心。

758
00:44:21,860 --> 00:44:23,590
但它是如何工作的方式，

759
00:44:24,120 --> 00:44:26,795
如果你提出一个查询，优化演算，

760
00:44:26,795 --> 00:44:28,480
但在现实世界中，

761
00:44:29,290 --> 00:44:31,190
但关系代数并不是什么东西，

762
00:44:31,900 --> 00:44:32,640
你得不到程序，

763
00:44:33,530 --> 00:44:34,410
但这将会是，

764
00:44:35,670 --> 00:44:39,425
我们想要运行查询和建立执行引擎，

765
00:44:39,425 --> 00:44:40,750
我们以后要做的事情。

766
00:44:41,100 --> 00:44:42,800
我们在高层次上称为关系，

767
00:44:42,800 --> 00:44:45,460
然后，是的，我们将学习[]，

768
00:44:45,840 --> 00:44:48,980
这门课是它的现代变种。

769
00:44:51,310 --> 00:44:58,090
好的，所以关系代数是 1969 年（建立的），

770
00:44:58,350 --> 00:45:03,035
他们还定义了用于与数据库系统交互的代数，

771
00:45:03,035 --> 00:45:05,800
这是从其中提取数据的方法，

772
00:45:08,430 --> 00:45:10,480
并计算出你想要的答案。

773
00:45:11,110 --> 00:45:14,420
所以在最初的论文中，他定义了七个基本运算符，

774
00:45:14,740 --> 00:45:15,225
它一直存在，

775
00:45:15,225 --> 00:45:19,390
直到在现代应用程序中，你需要更多运算符，

776
00:45:19,650 --> 00:45:21,040
比如，这个没有排序，

777
00:45:21,830 --> 00:45:24,240
显然，应用程序需要排序，所以后面加入了。

778
00:45:24,910 --> 00:45:27,410
但所有这些都将建立在，

779
00:45:30,000 --> 00:45:33,400
对重复记录列表排序，

780
00:45:34,470 --> 00:45:37,990
tuple 的无序列表，但是没有重复。

781
00:45:38,850 --> 00:45:40,810
现在，有一点令人困惑的是，

782
00:45:40,920 --> 00:45:45,070
在 SQL 中，默认情况下它会使用袋代数，

783
00:45:45,540 --> 00:45:48,670
这基本上是一个无序集合，有重复的，

784
00:45:49,170 --> 00:45:50,710
或者有时它被称为多重集合，

785
00:45:50,970 --> 00:45:54,395
为什么 SQL 想要使用袋而不是集合，

786
00:45:54,395 --> 00:45:56,225
因为实际上你会更有效率，

787
00:45:56,225 --> 00:45:58,360
如果你不关心以后删除重复项，

788
00:45:59,800 --> 00:46:00,860
但是我们在这里关心的代数，

789
00:46:01,060 --> 00:46:02,300
我们假设要去掉重复。

790
00:46:03,180 --> 00:46:05,435
所以所有这些运算符的基本思想是，

791
00:46:05,435 --> 00:46:08,950
你要把一些关系作为你的输入，

792
00:46:09,330 --> 00:46:11,590
或者你的一个或多个输入，

793
00:46:11,730 --> 00:46:13,730
然后你要对它们进行一些运算，

794
00:46:13,730 --> 00:46:16,060
然后产生一个新的关系作为输出，

795
00:46:16,620 --> 00:46:19,900
你可以开始把所有这些运算符链接在一起，

796
00:46:19,980 --> 00:46:21,250
来做更复杂的事情。

797
00:46:23,030 --> 00:46:24,130
所以，我们将逐一介绍这些内容。

798
00:46:25,440 --> 00:46:27,275
动画没有工作，我不知道为什么，

799
00:46:27,275 --> 00:46:30,910
但是没有问题，一次展示所有的东西。

800
00:46:39,010 --> 00:46:40,275
第一个是 SELECT ，

801
00:46:40,275 --> 00:46:44,450
但我想原始论文称之为 restrict ，

802
00:46:44,800 --> 00:46:47,150
你试图限制 tuple ，

803
00:46:47,740 --> 00:46:49,995
在 SELECT 运算符的想法中，

804
00:46:49,995 --> 00:46:51,950
你将定义一阶谓词逻辑，

805
00:46:52,540 --> 00:46:55,130
以指定哪个 tuple 将匹配，

806
00:46:55,390 --> 00:46:57,710
SELECT 运算符想要做什么，

807
00:46:59,150 --> 00:47:00,160
这是布尔逻辑，

808
00:47:00,160 --> 00:47:02,880
比如某事等于某事或某事小于某事，

809
00:47:03,320 --> 00:47:06,000
但你可以有逻辑与 AND 或逻辑或 OR ，

810
00:47:52,850 --> 00:47:54,420
不管你的目标表是什么。

811
00:47:58,790 --> 00:48:00,660
下一个运算符是 PROJECTION ，

812
00:48:01,460 --> 00:48:02,575
我不擅长希腊符号，

813
00:48:02,575 --> 00:48:03,490
对于这个，它很容易记住，

814
00:48:03,490 --> 00:48:05,340
因为它的小写是 pi 符号，

815
00:48:07,220 --> 00:48:08,190
这里的想法是，

816
00:48:10,440 --> 00:48:15,490
只要你的输入和指定你想要的输出，

817
00:48:15,870 --> 00:48:17,410
运算符的输出，

818
00:48:17,730 --> 00:48:20,140
这样你就可以重新安排属性的顺序，

819
00:48:20,550 --> 00:48:23,320
你可以删除（你不需要的）属性，

820
00:48:24,100 --> 00:48:29,450
然后，你可以操作属性的值以生成派生值，

821
00:48:30,560 --> 00:48:35,430
但它只在任何给它的东西上操作，

822
00:48:53,600 --> 00:48:55,350
减去 100 。

823
00:49:05,020 --> 00:49:05,690
现在我们讨论，

824
00:49:05,890 --> 00:49:12,250
把多重关系作为它们的输入的操作符。

825
00:49:13,110 --> 00:49:16,355
UNION 运算符，它是一个二元运算符，

826
00:49:16,355 --> 00:49:18,940
所以你可以使用集合中的运算，

827
00:49:19,930 --> 00:49:21,740
生成包含包含所有 tuple 的关系，

828
00:49:21,850 --> 00:49:25,910
出现在一个关系或两个关系上，

829
00:49:26,890 --> 00:49:27,530
所以在这里。

830
00:49:44,350 --> 00:49:45,170
UNION 调用，

831
00:49:47,200 --> 00:49:49,950
所以 UNION 加入 SQL ，会去掉重复的，

832
00:49:49,950 --> 00:49:51,800
如果你想保留复制并使其运行得更快，

833
00:49:52,570 --> 00:49:54,590
你可以添加 UNION ALL ， A L L ，

834
00:49:56,640 --> 00:49:57,730
我们不需要担心这一点。

835
00:49:59,470 --> 00:50:00,890
就像 UNION 一样，我们也有 INTERSECTION ，

836
00:50:01,120 --> 00:50:04,820
一样的东西，我们可以使用两个[]，

837
00:50:10,900 --> 00:50:11,540
必须出现。

838
00:50:15,600 --> 00:50:17,860
DIFFERENCE 是使用所有两个关系，

839
00:50:17,970 --> 00:50:21,820
输出在第一个而不在第二个的结果，

840
00:50:23,390 --> 00:50:25,230
你可以使用这个[]，

841
00:50:28,040 --> 00:50:29,095
这是基本的集合论，

842
00:50:29,095 --> 00:50:32,010
并不应该让任何人感到惊讶。

843
00:50:33,560 --> 00:50:36,090
那么在我们进入有趣的话题之前，还有什么问题吗？

844
00:50:45,730 --> 00:50:48,980
好的，他的问题是，谢谢你提到这个，

845
00:50:49,360 --> 00:50:50,055
问题是，

846
00:50:50,055 --> 00:50:52,280
在到目前为止的所有这些示例中，

847
00:50:52,480 --> 00:50:55,340
这两个输入关系是否必须具有完全相同的 schema ，

848
00:50:55,420 --> 00:51:03,720
是的，你必须[]，是的。

849
00:51:09,520 --> 00:51:11,750
好的，接下来，

850
00:51:11,890 --> 00:51:16,700
我们开始研究如何将这些关系结合在一起，

851
00:51:17,320 --> 00:51:20,060
并看看它们的值中包含了什么。

852
00:51:21,220 --> 00:51:23,840
所以我们要看的第一个是 PRODUCT 运算符，

853
00:51:25,990 --> 00:51:27,200
或者在 SQL 中，它被称为 CROSS JOIN ，

854
00:51:28,980 --> 00:51:29,990
这里的想法是，

855
00:51:30,080 --> 00:51:39,570
你要连接第一个关系和[] tuple ，

856
00:51:40,040 --> 00:51:42,565
它适用于两个独立的 tuple ，

857
00:51:42,565 --> 00:51:44,280
来自一个关系和另一个关系，

858
00:51:44,570 --> 00:51:46,530
所以你开始想两个 for 循环，

859
00:51:46,700 --> 00:51:48,330
有 for 循环在 R 上循环，

860
00:51:48,920 --> 00:51:50,520
对于 tuple R 上的每行，

861
00:51:50,750 --> 00:51:53,040
你将与 tuple S 的每行连接，

862
00:51:53,760 --> 00:51:54,230
而且你[]，

863
00:52:10,880 --> 00:52:13,050
我想，我猜为什么这会真正有用，

864
00:52:13,340 --> 00:52:14,370
为什么我们真的想要这样。

865
00:52:20,520 --> 00:52:22,850
我能想到的是测试，

866
00:52:22,850 --> 00:52:25,475
如果你尝试找到两个输入的所有唯一组合

867
00:52:25,475 --> 00:52:29,110
来测试某个软件或某些东西，

868
00:52:31,250 --> 00:52:32,400
那你就可以用这个，

869
00:52:34,310 --> 00:52:35,160
但除此之外，

870
00:52:35,180 --> 00:52:37,500
据我所知，这一点没有被广泛使用，

871
00:52:37,820 --> 00:52:39,325
通常情况下，出现这个，

872
00:52:39,325 --> 00:52:40,375
因为你出现错误，

873
00:52:40,375 --> 00:52:41,455
比如你忘了 WHERE 从句，

874
00:52:41,455 --> 00:52:42,930
你意外得到了这个。

875
00:52:46,360 --> 00:52:48,230
或者其中一个人说，你知道些什么，

876
00:52:50,290 --> 00:52:50,840
你是什么意思？

877
00:52:54,810 --> 00:52:56,270
哦，是的，

878
00:52:56,270 --> 00:52:58,180
比如在枚举表中，他们想要，

879
00:52:58,200 --> 00:52:59,270
但是对于输入，

880
00:52:59,270 --> 00:53:04,150
他们试图获取所有可能的枚举作为输入或其他内容。

881
00:53:09,300 --> 00:53:13,650
做 JOIN 非常有用，

882
00:53:14,370 --> 00:53:15,470
这里的想法是，

883
00:53:15,470 --> 00:53:23,160
当你要产生两个输入关系的组合，

884
00:53:23,510 --> 00:53:26,220
[]两个 tuple ，它是一个二元运算符，

885
00:53:26,420 --> 00:53:28,000
有多种方式的 JOIN ，

886
00:53:28,000 --> 00:53:30,450
我们可以接受多种输入、多种关系，

887
00:53:30,650 --> 00:53:31,650
我们可以忽略它，

888
00:53:32,390 --> 00:53:34,650
你希望生成一个新的输出，

889
00:53:34,730 --> 00:53:36,985
它将包含所有元组，

890
00:53:36,985 --> 00:53:44,310
与第一个关系中的重叠属性以及与第二个关系的重叠属性相匹配。

891
00:53:45,290 --> 00:53:50,625
与 INTERSECTION 不同，

892
00:53:50,625 --> 00:53:52,010
INTERSECTION 必须有精确的，

893
00:53:52,630 --> 00:53:54,290
而在这种情况下，我不需要这么做，

894
00:53:55,930 --> 00:53:58,790
我想找出它们重叠的属性，

895
00:53:58,900 --> 00:54:00,470
我去查一下。

896
00:54:24,590 --> 00:54:27,475
所以在在原始的关系代数中，

897
00:54:27,475 --> 00:54:30,805
你不会显示重复的列，

898
00:54:30,805 --> 00:54:33,540
比如来自 R 的 id 和来自 S 的 id 。

899
00:54:40,410 --> 00:54:42,850
所以，在 SQL 中有很多不同的编写方法，

900
00:54:45,000 --> 00:54:48,280
在 SQL 中有一个 NATURAL JOIN 关键词，

901
00:55:03,700 --> 00:55:04,400
或者如果你想的话，

902
00:55:48,250 --> 00:55:49,920
就像这样，这是一种方法，

903
00:55:49,920 --> 00:55:52,880
它会让你的应用程序看起来很脆弱，

904
00:55:56,230 --> 00:55:58,610
问题是，在这种情况下， R 和 S 的顺序很重要，

905
00:55:59,110 --> 00:55:59,780
这有什么关系？

906
00:56:43,670 --> 00:56:45,000
在这一点上，

907
00:57:37,800 --> 00:57:38,950
两个都是，是的。

908
00:57:40,000 --> 00:57:40,400
好的。

909
00:58:23,110 --> 00:58:24,020
所以他的问题是[]。

910
00:59:02,140 --> 00:59:05,820
这些是我展示给你们的，

911
00:59:05,820 --> 00:59:09,420
Ted 在 1970 年代末定义的基本运算符，

912
00:59:09,420 --> 00:59:11,060
它被扩展了一些额外的东西，

913
00:59:13,440 --> 00:59:14,440
构建真正的应用程序，

914
00:59:14,460 --> 00:59:20,060
你需要的比原始的关系模型、关系代数中的更多。

915
00:59:20,140 --> 00:59:22,250
Rename 就像 PROJECTION 。

916
00:59:22,980 --> 00:59:30,190
Assignment 将值分配给[]，很重要。

917
00:59:30,870 --> 00:59:36,330
Duplicat Elimination 不同的子句[]。

918
00:59:53,480 --> 00:59:54,985
过去教它，现在我们不再教了，

919
00:59:54,985 --> 00:59:56,370
因为你永远找不到它。

920
00:59:56,690 --> 00:59:58,015
Division 是一种方式，

921
00:59:58,015 --> 01:00:05,180
查找与另一个关系中的所有 tuple 匹配的运行关系的 tuple ，

922
01:00:07,650 --> 01:00:10,325
它不会出现在现实世界中，这并不常见，

923
01:00:10,325 --> 01:00:10,925
我们也不用担心它。

924
01:00:10,925 --> 01:00:12,610
总结一下，

925
01:00:14,030 --> 01:00:18,090
每个关系数据系统的核心都将建立在这些代数上，

926
01:00:18,410 --> 01:00:20,220
然后我们可以定义一个，

927
01:00:22,350 --> 01:00:23,920
围绕着一种，

928
01:00:24,960 --> 01:00:28,720
使我们能够支持非常有表现力、非常复杂的 SQL 查询。

929
01:00:35,480 --> 01:00:36,210
那么我们为什么需要，

930
01:00:38,320 --> 01:00:41,450
因为你可以在主键上找到 Duplicate Elimination 。

931
01:00:48,750 --> 01:01:04,590
所以，关系代数查询仍然是软件的一部分，

932
01:01:04,760 --> 01:01:06,330
一个系统来执行它，

933
01:01:08,490 --> 01:01:08,890
非常，

934
01:01:10,110 --> 01:01:12,040
一个顺序对比另一个，

935
01:01:12,880 --> 01:01:18,840
比如我做， where S ，

936
01:01:51,940 --> 01:02:01,960
马上到十亿 tuple 一起。

937
01:02:02,720 --> 01:02:06,150
所以，关系代数展示的是指定你希望数据系统如何执行操作，

938
01:02:07,210 --> 01:02:08,300
一种更好的方法，

939
01:02:08,560 --> 01:02:09,410
这是[]的激励，

940
01:02:10,210 --> 01:02:12,410
是我们想告诉数据库系统，

941
01:02:13,360 --> 01:02:14,600
这是我们想要的答案，

942
01:02:15,340 --> 01:02:18,070
我们不知道，我们不在乎你如何去为我们找，

943
01:02:18,070 --> 01:02:19,440
但这就是我们希望你为我们做的，

944
01:02:20,440 --> 01:02:22,410
不是精确的代数步骤，

945
01:02:22,410 --> 01:02:26,790
我想要计算机获取 R 和 S 的 tuple ，

946
01:02:28,150 --> 01:02:29,990
帮我找出所有在 b_id 的，

947
01:02:31,980 --> 01:02:34,810
然后数据系统可以考虑，

948
01:02:35,010 --> 01:02:36,790
数据是如何存储的，是哪种类型的数据，

949
01:02:37,800 --> 01:02:39,550
数据实际所在的物理位置，

950
01:02:40,060 --> 01:02:42,210
什么样 CPU 能支持，

951
01:02:42,410 --> 01:02:44,290
我的 CPU 是什么类型的，

952
01:02:44,290 --> 01:02:45,070
我有 GPU 吗，

953
01:02:45,070 --> 01:02:45,775
有没有 FPGA ，

954
01:02:45,775 --> 01:02:46,560
我还有其他东西吗，

955
01:02:46,910 --> 01:02:50,170
所有这些可以，

956
01:02:51,040 --> 01:02:54,560
决定如何以这种方式执行查询，而不是以另一种。

957
01:02:55,930 --> 01:02:58,275
现在，再想一想，如果我是一名开发人员，

958
01:02:58,275 --> 01:03:00,150
我可以在我的笔记本电脑上编写一堆代码，

959
01:03:00,150 --> 01:03:02,120
编写一些 SQL 在我的小测试数据库，

960
01:03:02,980 --> 01:03:05,990
然后相同的 SQL 语句将完全相同地工作，

961
01:03:06,190 --> 01:03:08,480
或者它也会产生相同的正确结果，

962
01:03:09,010 --> 01:03:13,280
当我在具有大量内存的巨型计算机上进行生产部署时，

963
01:03:14,200 --> 01:03:15,810
而且我不需要更改我的应用程序代码，

964
01:03:17,170 --> 01:03:18,020
这就是它的美妙之处，

965
01:03:18,130 --> 01:03:20,180
这就是为什么你会想要声明语言的原因，

966
01:03:20,860 --> 01:03:25,460
但是，声明性语言如何工作的核心概念，

967
01:03:25,570 --> 01:03:27,740
是在关系代数基础上预测的。

968
01:03:31,350 --> 01:03:33,740
所以， SQL 成为事实上的标准，

969
01:03:33,740 --> 01:03:34,750
正如我们所讨论的。

970
01:03:51,290 --> 01:03:51,690
好的？

971
01:03:54,120 --> 01:03:56,110
在我们结束之前，我想快速谈谈其他数据模型。

972
01:04:11,940 --> 01:04:14,720
因为矢量数据库是黑客新闻上的热门话题，

973
01:04:14,720 --> 01:04:16,420
值得讨论它们到底是什么，

974
01:04:16,710 --> 01:04:19,300
你们明白为什么你可以在现实世界中看到它。

975
01:04:22,190 --> 01:04:23,940
所以文档数据模型是老的，

976
01:04:24,620 --> 01:04:27,985
MongoDB 在 2008 年问世，这一切都是开创性的，

977
01:04:27,985 --> 01:04:29,130
我们是以 json 的形式存储东西，

978
01:04:29,540 --> 01:04:33,460
但这种想法可以追溯到 1980 年代， 1990 年代初，

979
01:04:33,460 --> 01:04:36,530
面向对象编程是热门的东西，

980
01:04:36,910 --> 01:04:38,630
所以人们说，与其存储东西的关系，

981
01:04:38,740 --> 01:04:40,730
不如像存储对象一样存储东西，

982
01:04:41,320 --> 01:04:43,440
然后他们有了这些专门的编程语言，

983
01:04:43,440 --> 01:04:47,900
知道如何写写代码，就像在，

984
01:04:50,210 --> 01:04:53,070
它会[]，数据库系统。

985
01:04:53,780 --> 01:04:56,820
但是那些对象和 json 是一样的，

986
01:04:57,140 --> 01:04:58,240
它们和 xml 是一样的，

987
01:04:58,240 --> 01:05:00,660
xml 数据库是 90 年代末， 2000 年的热门事物，

988
01:05:00,890 --> 01:05:02,820
但是在高级别上，它们是对等的。

989
01:05:04,260 --> 01:05:08,570
所以，它是一种分层数据结构，

990
01:05:08,860 --> 01:05:10,190
我们有这些命名字段，

991
01:05:10,630 --> 01:05:18,140
并且命名字段的值可以是数组、标量类型或其他，

992
01:05:19,240 --> 01:05:21,740
所有的现代系统都使用 json 。

993
01:05:21,970 --> 01:05:26,175
所以为什么这些文档数据库系统存在的原因是，

994
01:05:26,175 --> 01:05:31,670
这个叫做阻抗不匹配的问题的出现，

995
01:05:32,540 --> 01:05:33,930
这里的问题是，

996
01:05:34,130 --> 01:05:37,590
如果我把我的数据分解成这些不同的关系，

997
01:05:38,390 --> 01:05:42,900
但我使用比如 Python 或其他面向对象来编写我的应用程序代码，

998
01:05:43,580 --> 01:05:45,850
现在，当我想要检索数据时，

999
01:05:45,850 --> 01:05:49,200
有很多 JOIN 一起，

1000
01:05:49,720 --> 01:05:51,810
我想要在我的应用程序上操作，

1001
01:05:52,190 --> 01:05:55,390
但数据库想要[]或者分开。

1002
01:05:56,250 --> 01:05:57,130
所以。

1003
01:06:05,790 --> 01:06:08,140
我会争辩说，是的，有些事情是合理的，

1004
01:06:08,610 --> 01:06:10,595
但在其他方面，这实际上是一个坏主意，

1005
01:06:10,595 --> 01:06:12,700
因为现在你会有一堆重复的数据，

1006
01:06:12,930 --> 01:06:14,230
你有我们以前解决的所有问题，

1007
01:06:14,250 --> 01:06:20,380
我要确保如果我改变在我的数据库的文件中重复的东西，

1008
01:06:20,580 --> 01:06:21,970
我会在所有地方进行改变。

1009
01:06:25,890 --> 01:06:29,170
所以我们回到前面的例子，

1010
01:06:31,980 --> 01:06:32,710
所以高级别上，

1011
01:06:37,030 --> 01:06:38,070
如果我有一个对象，

1012
01:06:38,070 --> 01:06:39,690
为某个给定的艺术家，

1013
01:06:39,690 --> 01:06:41,930
这是他们出现在上面的所有专辑，

1014
01:06:50,080 --> 01:06:52,450
现在，你可以在一条 SQL 语句中做到这一点，

1015
01:06:52,450 --> 01:06:52,890
但是，是的，

1016
01:06:55,075 --> 01:06:55,660
这不是完美的，

1017
01:06:55,660 --> 01:07:00,290
但是，是有办法的。

1018
01:07:00,610 --> 01:07:02,400
所以文档数据模型说，

1019
01:07:02,400 --> 01:07:04,580
你这里不需要这个，

1020
01:07:05,200 --> 01:07:07,580
如果你的应用程序代码是，

1021
01:07:27,370 --> 01:07:28,395
和以前一样的问题，

1022
01:07:28,395 --> 01:07:32,390
如果艺术家出现在同一张专辑中，

1023
01:07:32,740 --> 01:07:35,060
我可能会在他们的所有 json 文档中有重复的条目，

1024
01:07:35,230 --> 01:07:36,060
如果我更新了，

1025
01:07:36,060 --> 01:07:37,400
我必须确保我改变了所有的。

1026
01:07:38,660 --> 01:07:39,060
所以。

1027
01:07:48,170 --> 01:07:49,650
所以，从本质上说。

1028
01:07:55,770 --> 01:08:00,610
所以，数据库市场出现了有趣的拐点，

1029
01:08:00,750 --> 01:08:04,820
几乎所有的 JSON 数据库都说，

1030
01:08:04,820 --> 01:08:05,615
我们不想使用 SQL ，

1031
01:08:05,615 --> 01:08:06,730
我们不想使用关系数据模型，

1032
01:08:07,110 --> 01:08:10,630
他们中的许多已经汇聚在一起，变得更像是关系型，

1033
01:08:13,270 --> 01:08:15,470
你可以运行，你可以在[]上写 SQL 。

1034
01:08:16,330 --> 01:08:17,870
随着时间的推移，

1035
01:08:18,520 --> 01:08:19,395
我们看到的是，

1036
01:08:19,395 --> 01:08:26,870
文档数据库、 SQL 数据库和关系数据库之间的智力差异已经缩小，

1037
01:08:27,280 --> 01:08:29,420
现在，它们基本上都是关系数据库，

1038
01:08:30,340 --> 01:08:31,500
Mongo 是最后一个抵抗的，

1039
01:08:31,500 --> 01:08:34,610
Mongo 在 2021 年增加了对 SQL 的支持，

1040
01:08:34,960 --> 01:08:36,975
但多年来，因为我们知道创始人说，

1041
01:08:36,975 --> 01:08:38,060
哦，我们永远不会支持 SQL ，

1042
01:08:38,110 --> 01:08:38,660
他们这样做，

1043
01:08:39,840 --> 01:08:40,570
然后得到[]，

1044
01:08:41,810 --> 01:08:43,200
它们还支持 JSON 。

1045
01:08:44,110 --> 01:08:49,200
所以我认为文档数据库是扭曲的东西，

1046
01:08:49,200 --> 01:08:52,500
当你只是数据库 Postgres 时，它看起来像是关系数据库。

1047
01:08:58,170 --> 01:09:01,120
他们出现在新闻中，是因为显然 ChatGPT 是热门话题，

1048
01:09:01,440 --> 01:09:06,180
所以，思考这件事的方式是，

1049
01:09:07,170 --> 01:09:10,330
10 15 年前，在纯 Web 应用程序中，

1050
01:09:10,620 --> 01:09:11,770
一切都是 json ，

1051
01:09:13,140 --> 01:09:14,260
所以，我需要一个 JSON 数据库，

1052
01:09:14,280 --> 01:09:15,910
NoSQL 系统就是这样开始的，

1053
01:09:16,320 --> 01:09:20,120
现在就像，好的，我有所有这些向量回来，

1054
01:09:20,120 --> 01:09:23,590
来自 transformer ChatGPT 或无论我使用的什么，

1055
01:09:24,350 --> 01:09:26,580
把它存储在一个可以原生存储向量的数据库中，

1056
01:09:27,320 --> 01:09:28,020
所以我可以这样做，

1057
01:09:30,630 --> 01:09:36,530
我会争辩说，这些系统它们的功能有限，

1058
01:09:36,530 --> 01:09:39,730
随着时间的推移，它们将不得不转变为一个关系型数据库。

1059
01:09:40,320 --> 01:09:44,180
所以向量数据模型，向量只是一个，

1060
01:09:44,900 --> 01:09:48,815
在这种情况下，

1061
01:09:48,815 --> 01:09:51,130
它是一个一维的浮点数数组，

1062
01:09:52,270 --> 01:09:54,200
整个系统都在，

1063
01:09:55,860 --> 01:09:58,060
邻居搜索可以是精确搜索，也可以是近似搜索，

1064
01:09:58,230 --> 01:10:00,250
让你可以对数据进行语义搜索，

1065
01:10:00,870 --> 01:10:02,270
所以在我之前展示的所有早期数据中，

1066
01:10:02,270 --> 01:10:05,650
比如 a_id 等于 2 ， a_id 等于 102 ，

1067
01:10:05,670 --> 01:10:06,520
精确匹配，

1068
01:10:08,500 --> 01:10:13,850
但这些向量允许你嵌入数据神奇地通过转换器，

1069
01:10:14,770 --> 01:10:17,010
一种你的数据的样子的更深层含义，

1070
01:10:17,010 --> 01:10:18,680
所以你可以问更高层次的问题，

1071
01:10:18,760 --> 01:10:23,000
比如，给我看看与这个相关的东西，

1072
01:10:27,710 --> 01:10:29,910
不是做关键字 CMU 的精确匹配，

1073
01:10:30,200 --> 01:10:32,610
我可以学习这样的东西，

1074
01:10:34,680 --> 01:10:38,680
谈谈匹兹堡的一所大学，它是[]，

1075
01:10:40,320 --> 01:10:42,610
就像你可以了解，

1076
01:10:43,410 --> 01:10:46,270
数据中隐含的东西，而不是进行精确的查找。

1077
01:10:47,160 --> 01:10:47,560
是的。

1078
01:10:51,360 --> 01:10:54,010
问题是什么是图形数据库和矢量数据库，

1079
01:10:54,090 --> 01:10:55,780
让我们把它[]，这是不同的，

1080
01:10:55,860 --> 01:11:00,010
但是向量从字面上来说只是一个一维的数组，

1081
01:11:00,360 --> 01:11:02,555
图形数据库存储对象之间的关系，

1082
01:11:02,555 --> 01:11:06,065
比如边和节点等东西。

1083
01:11:09,580 --> 01:11:12,320
如果你从当前节点看一个度数，它听起来很相似，

1084
01:11:12,640 --> 01:11:17,210
但是，比如，这个该怎么说，

1085
01:11:18,130 --> 01:11:21,890
在图形数据库中，你显式地存储该结构，

1086
01:11:22,390 --> 01:11:24,710
你遍历它以找到正在寻找的东西，

1087
01:11:24,910 --> 01:11:27,090
这就像我把它编码成一个向量，

1088
01:11:27,090 --> 01:11:29,600
而我不知道这个向量实际上代表了什么。

1089
01:11:32,430 --> 01:11:35,050
所以 Pinecone ，很多[]，

1090
01:11:39,210 --> 01:11:40,480
两年前给我们做了一次演讲，

1091
01:11:47,260 --> 01:11:47,770
两周后，

1092
01:11:47,770 --> 01:11:49,680
所以如果你想更多地了解这一点，请查看。

1093
01:11:50,430 --> 01:11:53,530
在它们的核心，所有这些矢量数据库将只是一个，

1094
01:11:54,710 --> 01:11:58,740
索引，很多最近的邻居搜索要做，

1095
01:11:58,740 --> 01:12:00,170
所以看起来就像这样，

1096
01:12:26,580 --> 01:12:28,460
正确地解释这些东西，

1097
01:12:28,460 --> 01:12:31,235
数字，不需要它出现，

1098
01:12:31,235 --> 01:12:32,020
我们不知道这是什么，

1099
01:13:14,210 --> 01:13:15,810
作为我的排名表。

1100
01:13:18,070 --> 01:13:21,090
这是在高级别上，矢量数据库所做的核心。

1101
01:13:27,710 --> 01:13:29,305
问题，这类似于关系演算吗，

1102
01:13:29,305 --> 01:13:30,600
这是什么意思，哪一部分，

1103
01:13:31,420 --> 01:13:31,820
好的，

1104
01:13:58,510 --> 01:13:59,330
或者我们，

1105
01:14:16,930 --> 01:14:18,500
我只是在试着让他们，

1106
01:14:19,590 --> 01:14:20,470
他们关心的是，

1107
01:14:27,170 --> 01:14:28,050
所以我会争辩说，

1108
01:14:30,220 --> 01:14:32,960
这些问题的核心就在于，

1109
01:14:52,740 --> 01:14:54,310
不是，

1110
01:14:54,310 --> 01:14:57,000
你可以做一堆数据库，他们都加了这个，

1111
01:14:57,770 --> 01:15:00,390
有 pgvector SingleStore Clickhouse ，

1112
01:15:03,660 --> 01:15:06,130
就目前而言，这是最重要的。

1113
01:15:07,940 --> 01:15:08,340
好的。

1114
01:15:09,810 --> 01:15:11,380
我只是想展示给你看。

1115
01:15:13,600 --> 01:15:14,840
所以，数据库是无处不在的，

1116
01:15:15,940 --> 01:15:19,500
关系代数定义了数据库系统原语，

1117
01:15:20,330 --> 01:15:25,100
关系代数是[]的核心，进行这些交互，

1118
01:15:25,390 --> 01:15:30,170
然后就定义了我们希望如何构建系统组件来运行查询。

1119
01:15:31,690 --> 01:15:34,340
所以周三的课将在 SQL 上，

1120
01:15:34,720 --> 01:15:35,930
项目0已经放出了，

1121
01:15:36,400 --> 01:15:38,330
请现在就开始，截止时间是 11 号，

1122
01:15:38,890 --> 01:15:40,190
然后家庭作业1也放出了。

1123
01:15:42,340 --> 01:15:42,890
开始吧。

