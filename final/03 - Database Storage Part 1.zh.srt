1
00:00:32,530 --> 00:00:33,680
我听到谣言，

2
00:00:34,660 --> 00:00:36,980
我听说你曾经和 Larry Ellison 的女朋友约会。

3
00:00:44,640 --> 00:00:45,850
发生了什么，他从你那里偷走的。

4
00:00:53,880 --> 00:00:54,910
我们稍后再来讨论这一点，

5
00:00:56,730 --> 00:00:58,400
Larry Ellison ， Oracle 的创始人，

6
00:00:58,400 --> 00:01:00,820
他是世界第五大富豪，

7
00:01:01,230 --> 00:01:02,530
他拥有一座夏威夷小岛，

8
00:01:03,120 --> 00:01:04,630
所有费用都由数据库支付，

9
00:01:05,070 --> 00:01:06,580
这就是这个班级存在的原因。

10
00:01:09,570 --> 00:01:10,390
行政方面的事，

11
00:01:10,530 --> 00:01:12,250
家庭作业 #1 ，

12
00:01:13,020 --> 00:01:15,070
我们在星期天， 10 号做，

13
00:01:15,390 --> 00:01:16,870
项目 #0 也是在 10 号截止，

14
00:01:17,100 --> 00:01:18,850
在这里谁还没有开始项目 #0 ？

15
00:01:20,150 --> 00:01:22,320
一个，为什么不（开始），两个。

16
00:01:24,030 --> 00:01:24,910
你知道 C++ 吗？

17
00:01:26,480 --> 00:01:28,320
那就是不，你知道 C++ 吗？

18
00:01:29,670 --> 00:01:31,235
好的，你真的应该开始了，

19
00:01:31,235 --> 00:01:34,840
因为如果你的 C++ 为零，

20
00:01:35,160 --> 00:01:35,945
这将是一个[斗争]，

21
00:01:35,945 --> 00:01:38,260
我们这么做不是为了折磨你，

22
00:01:38,310 --> 00:01:39,370
这真的意味着，

23
00:01:40,050 --> 00:01:41,495
这就是课程的其他部分，

24
00:01:41,495 --> 00:01:42,370
就项目而言，

25
00:01:42,780 --> 00:01:44,720
如果你不知道如何编写 C++ ，

26
00:01:44,720 --> 00:01:45,760
也不知道如何调试它，

27
00:01:46,170 --> 00:01:46,930
你就会有问题，

28
00:01:47,910 --> 00:01:50,950
printf 或标准 cout 不是调试方法，

29
00:01:53,370 --> 00:01:54,335
你希望使用调试器，

30
00:01:54,335 --> 00:01:55,990
然后项目 #1 将发布，

31
00:01:57,030 --> 00:01:57,910
我们今天应该放出，

32
00:01:58,080 --> 00:01:59,050
可能会在星期五出来，

33
00:02:00,210 --> 00:02:01,520
这将在缓冲池上，

34
00:02:01,520 --> 00:02:03,520
一周半之后开始教学。

35
00:02:04,650 --> 00:02:06,580
关于家庭作业 #1 或项目 #0 有什么问题吗？

36
00:02:09,860 --> 00:02:12,370
好的，跳到材料。

37
00:02:12,370 --> 00:02:15,360
上一节课，我们讨论了 SQL ，

38
00:02:16,130 --> 00:02:17,875
以及所有现代的东西，

39
00:02:17,875 --> 00:02:21,540
你可以做 CTE ，横向连接，嵌套查询，窗口函数等。

40
00:02:22,580 --> 00:02:25,470
在此之前，我们讨论了关系模型和关系代数，

41
00:02:25,850 --> 00:02:27,780
在这一点上，

42
00:02:27,920 --> 00:02:32,155
这就是我们将要看到的数据库系统的逻辑视图，

43
00:02:32,155 --> 00:02:35,100
在这学期剩下的时间里，我们在某种程度上是在构思，

44
00:02:35,690 --> 00:02:37,870
所以我们不会回到这些，讨论这些事情，

45
00:02:37,870 --> 00:02:40,860
但我们将看到，我们需要知道 SQL 是什么样子的关系模型，

46
00:02:40,970 --> 00:02:42,870
为了构建系统的各个部分，

47
00:02:43,340 --> 00:02:44,550
我们将继续讨论。

48
00:02:44,840 --> 00:02:46,390
就像我在上节课结束时说的，

49
00:02:46,390 --> 00:02:51,100
在感恩节之前，这学期的重点将是，

50
00:02:51,100 --> 00:02:56,850
如何构建一种经典的或规范的关系数据库管理系统。

51
00:02:58,730 --> 00:03:01,210
所以，前进的概述，

52
00:03:01,210 --> 00:03:03,390
我们已经讨论了什么是关系数据库，

53
00:03:04,670 --> 00:03:07,360
但这里的前四个主题是，

54
00:03:07,360 --> 00:03:09,060
存储、执行、并发控制、恢复，

55
00:03:09,500 --> 00:03:12,895
这些都是你需要的方面，

56
00:03:12,895 --> 00:03:18,980
为了构建一个功能齐全、安全、可靠的数据库管理系统。

57
00:03:19,700 --> 00:03:22,810
我们假设它会在一个节点上运行，

58
00:03:23,310 --> 00:03:24,400
因为它让我们的生活变得更容易，

59
00:03:24,420 --> 00:03:25,870
不在必须的情况下不要去分布式。

60
00:03:26,340 --> 00:03:29,860
然后一旦我们了解了单节点数据库系统是什么样子，

61
00:03:30,060 --> 00:03:33,460
然后我们将讨论如何扩展它，做分布式数据库。

62
00:03:33,600 --> 00:03:34,595
在学期结束时，

63
00:03:34,595 --> 00:03:36,215
我们还将讨论，

64
00:03:36,215 --> 00:03:39,310
什么其他功能和优化可以应用，

65
00:03:39,660 --> 00:03:42,110
这将是高级课程的一部分，

66
00:03:42,110 --> 00:03:43,690
如果你想在春季学习的话。

67
00:03:44,580 --> 00:03:46,540
所以，思考数据库管理系统的方式

68
00:03:46,620 --> 00:03:50,290
和（思考）课程布局的方式是有一些层，

69
00:03:50,880 --> 00:03:54,910
不同的层将为数据库系统的功能提供不同的功能，

70
00:03:55,500 --> 00:03:59,560
它们将把 API 暴露给它上面的层。

71
00:04:00,130 --> 00:04:02,265
我们要讨论的主题，

72
00:04:02,265 --> 00:04:04,190
是如何构建这些层，

73
00:04:04,240 --> 00:04:05,025
将它们放在一起，

74
00:04:05,025 --> 00:04:07,220
并拥有一个功能齐全的数据库管理系统。

75
00:04:07,750 --> 00:04:09,165
所以，考虑这个的方法是，

76
00:04:09,165 --> 00:04:11,540
最简单的观点是，

77
00:04:11,950 --> 00:04:13,190
应用程序出现，

78
00:04:13,960 --> 00:04:15,440
你将发出一个 SQL 查询，

79
00:04:15,610 --> 00:04:17,570
这个查询将首先显示并被解析，

80
00:04:18,100 --> 00:04:20,360
SQL 查询的文本字符串被解析，

81
00:04:20,710 --> 00:04:23,685
然后运行下面的查询优化器，

82
00:04:23,685 --> 00:04:25,430
然后，我们将开始执行查询计划，

83
00:04:25,630 --> 00:04:26,565
将有一些访问方法，

84
00:04:26,565 --> 00:04:31,280
可以与表或索引或我们试图访问的任何内容进行交互，

85
00:04:31,750 --> 00:04:32,780
这将是一个缓冲池管理器，

86
00:04:32,830 --> 00:04:34,970
用于管理我们数据库系统的内存，

87
00:04:35,380 --> 00:04:37,160
然后在最低级别将是一个磁盘管理器，

88
00:04:37,750 --> 00:04:41,150
负责将数据读写到磁盘。

89
00:04:42,090 --> 00:04:43,685
所以今天的课程，

90
00:04:43,685 --> 00:04:44,200
我们将，

91
00:04:44,970 --> 00:04:48,400
这一学期从下面开始，然后努力向上，

92
00:04:49,000 --> 00:04:50,790
当我们达到比如并发控制、恢复的时候，

93
00:04:51,230 --> 00:04:53,220
这将[渗透]到整个系统，

94
00:04:53,480 --> 00:04:55,350
所以，我们必须回来，重新审视所有这些事情，

95
00:04:56,150 --> 00:04:59,430
当我们运行事务时，我们需要知道磁盘上有什么，

96
00:04:59,720 --> 00:05:02,490
我们需要知道我们正在访问什么，我们如何访问它，

97
00:05:03,020 --> 00:05:05,255
我们正在执行什么查询，

98
00:05:05,255 --> 00:05:08,350
所以，存储、执行将帮助我们完成整个[堆栈]，

99
00:05:08,880 --> 00:05:10,780
然后我们将返回并再次触摸它，

100
00:05:11,670 --> 00:05:12,350
这听起来很奇怪，

101
00:05:12,350 --> 00:05:13,960
但我们将重新审视它。

102
00:05:18,060 --> 00:05:18,460
对于分布式数据库，也有相同的事情，

103
00:05:18,690 --> 00:05:24,160
我们需要知道所有这些信息在一个可靠、安全、分布式的数据库中。

104
00:05:24,960 --> 00:05:25,280
好的？

105
00:05:27,090 --> 00:05:31,190
好的，对于我们要讨论的系统，

106
00:05:31,570 --> 00:05:33,380
我们在本学期要讨论的方法。

107
00:05:33,910 --> 00:05:36,980
我们假设我们尝试构建的体系结构，

108
00:05:37,270 --> 00:05:39,110
在概念上出现在我们的脑海中，

109
00:05:39,310 --> 00:05:40,250
一个数据库管理系统，

110
00:05:40,360 --> 00:05:42,320
Bustub 是这个的一种实现。

111
00:05:42,950 --> 00:05:44,290
我们将会说，我们正在构建的是，

112
00:05:44,290 --> 00:05:47,070
基于磁盘的数据库系统或面向磁盘的体系结构。

113
00:05:48,410 --> 00:05:51,625
这就是数据库管理系统本身将假设，

114
00:05:51,625 --> 00:05:57,180
数据库的主存储位置将位于某个非易失性磁盘上，

115
00:05:57,560 --> 00:05:59,790
可以是固态硬盘，可能是旋转磁盘硬盘，

116
00:06:00,080 --> 00:06:01,890
如果你运行在云上，则可能是 S3 ，

117
00:06:02,990 --> 00:06:04,620
假设它是基于磁盘的。

118
00:06:05,770 --> 00:06:08,510
我们要在我们的数据库系统中构建的所有东西

119
00:06:08,770 --> 00:06:10,220
都已经设计好，

120
00:06:11,360 --> 00:06:16,500
协调数据在磁盘和内存之间的来回移动。

121
00:06:17,720 --> 00:06:19,900
这对任何人来说都不应该是新闻，

122
00:06:19,900 --> 00:06:21,300
这是经典的[]架构，

123
00:06:21,860 --> 00:06:24,360
其中数据位于磁盘上，

124
00:06:24,410 --> 00:06:25,560
我们不能操作它，

125
00:06:25,610 --> 00:06:26,640
除非我们把它放入内存，

126
00:06:26,660 --> 00:06:28,680
然后 CPU 可以对它做任何它需要的事情。

127
00:06:29,370 --> 00:06:32,740
所以这是我们试图建立的总体主题，

128
00:06:32,940 --> 00:06:34,540
显然这将是非常困难的，

129
00:06:34,860 --> 00:06:37,000
同样，如果你是一名应用程序开发人员，

130
00:06:37,170 --> 00:06:39,610
你不会希望自己在应用程序代码中执行此操作，

131
00:06:40,350 --> 00:06:41,390
你想要一个数据库系统，

132
00:06:41,390 --> 00:06:45,130
知道如何可靠、安全、正确、高效地做到这个，

133
00:06:46,560 --> 00:06:47,440
为你做到这个。

134
00:06:49,240 --> 00:06:52,010
所以，考虑存储是什么样子的，

135
00:06:52,360 --> 00:06:54,890
从我们作为数据库系统的角度是，

136
00:06:54,940 --> 00:06:56,130
从这个层次结构的角度，

137
00:06:56,130 --> 00:06:59,540
你可能在其他课程或其他教科书中看到过这个，

138
00:07:00,550 --> 00:07:01,880
思考这一点的方法是，

139
00:07:02,260 --> 00:07:03,890
从下到上，

140
00:07:04,270 --> 00:07:09,740
存储设备将变得更快，但更小，更贵，

141
00:07:10,490 --> 00:07:11,905
所以，在最底层，

142
00:07:11,905 --> 00:07:13,260
你可以使用类似网络存储的东西，

143
00:07:14,060 --> 00:07:15,960
这应该是 EBS 或 S3 ，

144
00:07:16,640 --> 00:07:18,445
我想在教科书中，

145
00:07:18,445 --> 00:07:19,390
这下面有一层，

146
00:07:19,390 --> 00:07:20,305
他们有磁带机，

147
00:07:20,305 --> 00:07:23,070
但现在没有人再使用它来运行数据库系统。

148
00:07:24,110 --> 00:07:25,750
随着你向上，

149
00:07:25,750 --> 00:07:26,545
在网络存储之后，

150
00:07:26,545 --> 00:07:28,770
你有一个本地连接的旋转磁盘硬盘，

151
00:07:29,030 --> 00:07:30,450
然后你可能有 SSD ，

152
00:07:30,800 --> 00:07:32,095
然后你有 DRAM ，

153
00:07:32,095 --> 00:07:33,100
然后 CPU 缓存，

154
00:07:33,100 --> 00:07:35,490
然后 CPU 寄存器，

155
00:07:35,490 --> 00:07:37,430
CPU 寄存器速度超级快，

156
00:07:38,320 --> 00:07:39,600
这是你能拥有的最快的[]，

157
00:07:39,600 --> 00:07:40,590
但就像我们谈论的那样，

158
00:07:40,590 --> 00:07:41,700
你可能有，我不知道，

159
00:07:41,700 --> 00:07:43,460
CPU 上有 32 个寄存器，

160
00:07:43,750 --> 00:07:46,110
每个寄存器是 64 位，

161
00:07:46,110 --> 00:07:47,360
你不能在那里储存很多空间，

162
00:07:47,440 --> 00:07:48,530
在那里储存很多东西，

163
00:07:50,750 --> 00:07:51,660
但它们的速度会非常快。

164
00:07:52,780 --> 00:07:54,890
所以，从我们这学期的角度来看，

165
00:07:55,390 --> 00:07:58,010
我们真正关心的是这里的分界线，

166
00:07:59,105 --> 00:08:00,970
这介于易失性存储和非易失性存储之间，

167
00:08:02,020 --> 00:08:03,140
显然，易失性是什么意思，

168
00:08:03,280 --> 00:08:04,190
我们有易失性存储器。

169
00:08:06,610 --> 00:08:06,900
那是什么？

170
00:08:09,190 --> 00:08:11,340
是的，它说当你断电时，数据就会消失，

171
00:08:11,340 --> 00:08:13,970
你拔下你的 DRAM 或 CPU 寄存器的插头，

172
00:08:14,020 --> 00:08:15,170
所有的东西都被抹去了，

173
00:08:15,340 --> 00:08:16,455
当你重新启动系统时，

174
00:08:16,455 --> 00:08:17,300
什么都没有了。

175
00:08:17,830 --> 00:08:21,170
非易失性意味着你将数据写入设备，

176
00:08:21,940 --> 00:08:25,150
假设你进行调用告诉他们，

177
00:08:25,150 --> 00:08:27,570
被刷新或得到确认，

178
00:08:27,740 --> 00:08:28,770
我们将在稍后讨论这一点，

179
00:08:29,090 --> 00:08:31,710
然后我们假设数据将是持久的，

180
00:08:32,290 --> 00:08:35,720
不管我们重新启动系统，拔下电源，

181
00:08:36,130 --> 00:08:38,300
取出机器，把它放到另一个位置，不管是什么，

182
00:08:38,470 --> 00:08:40,220
当我们回来的时候，我们的数据都会在那里。

183
00:08:41,060 --> 00:08:43,050
当然，数据库系统，我们不信任硬件，

184
00:08:43,400 --> 00:08:44,290
我们也不信任操作系统，

185
00:08:44,290 --> 00:08:44,970
我们很快就会讲到，

186
00:08:45,320 --> 00:08:46,140
我们对任何一个都不信任，

187
00:08:46,190 --> 00:08:47,560
所以我们要做一堆额外的工作，

188
00:08:47,560 --> 00:08:49,200
以确保如果我们写东西，

189
00:08:49,460 --> 00:08:50,970
也许我们会写到多个位置，

190
00:08:51,110 --> 00:08:52,440
我们为它写备份，

191
00:08:52,580 --> 00:08:53,515
我们将做一系列的事情，

192
00:08:53,515 --> 00:08:56,310
来确保我们得到真正的非易失性存储。

193
00:08:56,510 --> 00:08:59,640
但是从架构本身的设计来看，

194
00:08:59,840 --> 00:09:03,750
我们会假设它是易失性的，而不是非易失性的。

195
00:09:05,010 --> 00:09:07,930
我们将看到易失性和非易失性之间的另一个关键区别是，

196
00:09:08,550 --> 00:09:09,880
我们如何访问数据，

197
00:09:10,690 --> 00:09:13,790
非易失性存储被认为是字节可寻址的，

198
00:09:14,690 --> 00:09:15,420
那是什么意思？

199
00:09:19,830 --> 00:09:22,780
他说，你可以询问每个单独的字节，正确。

200
00:09:22,800 --> 00:09:24,910
假设我有一兆字节的文件，

201
00:09:27,240 --> 00:09:29,950
我想在某个随机偏移量上获得 64 位，

202
00:09:30,270 --> 00:09:31,420
我可以在内存中做到这个，

203
00:09:32,640 --> 00:09:34,340
有高速缓存行，并不完全正确，

204
00:09:34,340 --> 00:09:35,890
但现在我们可以忽略这个，

205
00:09:36,300 --> 00:09:38,075
在非易失性存储中，

206
00:09:38,075 --> 00:09:39,160
比如，想象一下 SSD ，

207
00:09:39,510 --> 00:09:42,550
你不能在一个 1 兆字节的文件中获得准确的 64 位，

208
00:09:43,280 --> 00:09:46,150
你必须去获取 64 位所在的块，

209
00:09:46,470 --> 00:09:47,285
把它放到内存中，

210
00:09:47,285 --> 00:09:48,700
然后在它上做任何你需要的事情，

211
00:09:49,420 --> 00:09:53,540
所以，你只能寻址块，而不能寻址单个字节。

212
00:09:54,710 --> 00:09:56,640
这个很重要的原因是，

213
00:09:57,200 --> 00:10:01,050
在我们的系统设计中，我们会选择某些算法，

214
00:10:01,070 --> 00:10:05,700
我们知道我们读取的是块，而不是单个字节或字节偏移量，

215
00:10:05,930 --> 00:10:09,150
所以我们将选择一种更适合于块可调整数据的算法，

216
00:10:10,160 --> 00:10:12,325
与此相关，我们还将选择潜在的算法，

217
00:10:12,325 --> 00:10:17,700
以最大化对数据的顺序访问量。

218
00:10:18,870 --> 00:10:19,960
那么我这么说是什么意思？

219
00:10:28,970 --> 00:10:32,100
他说，访问相邻块的成本更低，

220
00:10:32,300 --> 00:10:33,625
所以，我们希望尽可能地做到这个，

221
00:10:33,625 --> 00:10:38,020
所以，比如，我想要获取 10 兆字节，

222
00:10:38,130 --> 00:10:41,590
我有[程序]到 1 兆字节，

223
00:10:41,880 --> 00:10:44,170
如果这些 1 兆字节的数据块分散在不同的位置，

224
00:10:44,520 --> 00:10:46,085
那么它被称为随机访问，

225
00:10:46,085 --> 00:10:48,010
去那些不同的地方去获取数据，

226
00:10:48,660 --> 00:10:52,010
或者，如果它们都连续排列在一起，

227
00:10:52,210 --> 00:10:54,200
那么理论上，我可以执行一个 FETCH 命令，

228
00:10:54,640 --> 00:10:55,830
我不是说这个设备是什么，

229
00:10:55,830 --> 00:10:59,420
但只需一个 fetch 命令就可以获取 10 个 1 兆字节块，

230
00:10:59,890 --> 00:11:02,550
这样效率会高得多。

231
00:11:03,500 --> 00:11:06,295
如果你只是，想像在一个网站上或下载一些关于互联网的东西，

232
00:11:06,295 --> 00:11:09,295
如果我可以打开一个单一的连接，并获得我需要的所有数据，

233
00:11:09,295 --> 00:11:10,800
而不是打开不同的连接，

234
00:11:11,690 --> 00:11:13,260
一次 fetch ，这将是更快的。

235
00:11:14,510 --> 00:11:15,370
在硬件层面，

236
00:11:15,370 --> 00:11:16,645
可以把它想像成一个旋转磁盘硬盘，

237
00:11:16,645 --> 00:11:18,175
笔记本电脑不再附带这些，

238
00:11:18,175 --> 00:11:19,800
它们仍然存在于企业界，

239
00:11:20,090 --> 00:11:23,290
有一只有形的手臂在盘上旋转，

240
00:11:23,290 --> 00:11:24,850
就像一张黑胶唱片，

241
00:11:24,850 --> 00:11:25,890
就像老人所有的，

242
00:11:26,120 --> 00:11:29,130
所以，如果你必须通过移动手臂来获得数据，

243
00:11:29,600 --> 00:11:31,855
移动手臂是一件物理上的事情，

244
00:11:31,855 --> 00:11:32,395
它很昂贵，

245
00:11:32,395 --> 00:11:36,100
你实际上是在通过[氦]移动一些东西，

246
00:11:36,100 --> 00:11:39,120
但你移动一些东西，在盘上移动手臂。

247
00:11:40,730 --> 00:11:42,760
如果我只需移动手臂一次，

248
00:11:42,760 --> 00:11:44,880
然后不再移动一次就可以读取一大堆数据，

249
00:11:45,020 --> 00:11:45,955
这就是顺序访问，

250
00:11:45,955 --> 00:11:46,620
这会更快，

251
00:11:46,880 --> 00:11:49,020
如果我必须拿起手臂，一遍又一遍地移动它，

252
00:11:49,100 --> 00:11:50,160
那么速度会慢得多。

253
00:11:50,330 --> 00:11:51,600
我们将看到这一点，

254
00:11:51,620 --> 00:11:55,110
当执行算法出现时，

255
00:11:55,490 --> 00:11:59,430
某些算法将被选择以最大化顺序访问。

256
00:12:00,160 --> 00:12:02,110
我们会选择那些，而不是更随机访问的东西，

257
00:12:02,110 --> 00:12:05,790
这可能不同于你在入门课程中对算法的看法，

258
00:12:05,840 --> 00:12:07,225
因为在那个世界里，

259
00:12:07,225 --> 00:12:10,830
他们假设一切都是内存，访问总是相同的，

260
00:12:11,960 --> 00:12:13,435
在我们的世界里，我们处理的是真正的硬件，

261
00:12:13,435 --> 00:12:14,820
所以我们不能做出这样的假设。

262
00:12:16,960 --> 00:12:19,120
好的，所以，让我讨论，

263
00:12:19,380 --> 00:12:20,980
所以我们思考这个问题的方式是，

264
00:12:21,390 --> 00:12:23,165
我会在这节课上使用术语内存，

265
00:12:23,165 --> 00:12:25,630
我的意思只是 DRAM ，

266
00:12:26,610 --> 00:12:27,710
当我说磁盘的时候，

267
00:12:27,710 --> 00:12:29,530
我的意思是这下面的所有，

268
00:12:29,820 --> 00:12:34,090
SSD ，旋转磁盘硬盘或网络云存储。

269
00:12:35,080 --> 00:12:37,460
上面的 CPU 寄存器，

270
00:12:37,780 --> 00:12:39,290
我们不会在这门课上讨论这些，

271
00:12:39,580 --> 00:12:40,920
在高级课程中，

272
00:12:40,920 --> 00:12:42,800
我们将讨论不同算法的方法，

273
00:12:42,910 --> 00:12:48,920
试图最大限度地处理 CPU 寄存器或 L3 L2 缓存中的数据，

274
00:12:49,420 --> 00:12:50,880
在那个世界里，你可以做出巨大的改变。

275
00:12:52,860 --> 00:12:53,810
还值得注意的是，

276
00:12:53,810 --> 00:12:56,570
现在有一些新兴的硬件设备或硬件，

277
00:12:56,570 --> 00:12:59,740
可以跨不同的层使用，

278
00:13:00,890 --> 00:13:05,280
你可以获得某种快速网络存储或分散存储或分散内存，

279
00:13:05,600 --> 00:13:06,840
就像这样，

280
00:13:08,480 --> 00:13:10,645
它可能是可寻址的，

281
00:13:10,645 --> 00:13:13,045
但你是通过物理网络进行的，

282
00:13:13,045 --> 00:13:13,890
所以速度会稍微慢一些，

283
00:13:15,110 --> 00:13:17,100
所以它横跨在这之间。

284
00:13:18,230 --> 00:13:19,980
然后有一种叫做持久内存的东西，

285
00:13:20,540 --> 00:13:23,610
人们梦想了很长时间，

286
00:13:23,900 --> 00:13:28,830
这将具有 DRAM 的可寻址能力，

287
00:13:29,000 --> 00:13:32,790
以及 SSD 的持久性，

288
00:13:33,200 --> 00:13:34,675
并且它实际上将位于[暗槽]中，

289
00:13:34,675 --> 00:13:38,065
所以你可以把它当做内存来写，

290
00:13:38,065 --> 00:13:40,230
但如果你拔下插头，一切都会保留下来。

291
00:13:41,250 --> 00:13:46,000
这是 10 年前，我刚在 CMU 的时候，

292
00:13:46,950 --> 00:13:48,590
我们花了很多时间研究的东西，

293
00:13:48,590 --> 00:13:50,020
这是一件非常有趣的事情，

294
00:13:50,100 --> 00:13:52,120
因为如果我们有这种持久内存，

295
00:13:52,830 --> 00:13:56,225
基本上我两周时间要谈论的所有东西，

296
00:13:56,225 --> 00:13:59,950
实际上，这门课的项目 #1 就基本结束了，

297
00:13:59,950 --> 00:14:02,010
因为我不需要担心将东西移入和移出磁盘，

298
00:14:02,810 --> 00:14:03,810
内存中的任何东西是持久的。

299
00:14:05,250 --> 00:14:07,450
他们可能知道有没有人实现这个，

300
00:14:07,620 --> 00:14:08,950
这个持久的非易失性内存。

301
00:14:09,830 --> 00:14:15,450
是的，砰，这就对了。

302
00:14:18,140 --> 00:14:20,485
是的，他说，你可以用 SSD 来尝试，

303
00:14:20,485 --> 00:14:21,145
要求人们这样做，

304
00:14:21,145 --> 00:14:22,440
但那不是真正的持久内存。

305
00:14:22,910 --> 00:14:24,420
或者你说的 Intel OPTANE ，

306
00:14:24,560 --> 00:14:26,245
Intel OPTANE 实际上是一种 SSD ，

307
00:14:26,245 --> 00:14:27,730
这实际上是相变内存，

308
00:14:27,730 --> 00:14:29,110
它实际上是一个物理设备，

309
00:14:29,110 --> 00:14:31,730
可以做的是持久内存，

310
00:14:32,140 --> 00:14:33,405
HP 有内存寄存器，

311
00:14:33,405 --> 00:14:35,090
有传闻 IBM 有一些东西，

312
00:14:35,440 --> 00:14:37,220
Intel 是唯一一家真正做到这个的公司。

313
00:14:38,420 --> 00:14:39,990
在座的谁听说过 Intel OPTANE？

314
00:14:40,370 --> 00:14:42,360
嗯，他显然是，非常非常少。

315
00:14:44,030 --> 00:14:45,150
它已经死了，

316
00:14:45,590 --> 00:14:46,890
Intel 去年杀死了它，

317
00:14:48,080 --> 00:14:50,155
Intel 聘请了一位新的 CEO ，

318
00:14:50,155 --> 00:14:51,580
他们削减了一大批部门，

319
00:14:51,580 --> 00:14:53,320
不幸的是，他们削减了这个，

320
00:14:53,320 --> 00:14:53,920
这很糟糕，

321
00:14:53,920 --> 00:14:54,505
因为对我来说，

322
00:14:54,505 --> 00:14:56,815
这就像是，这本来可以改变游戏规则，

323
00:14:56,815 --> 00:14:59,160
但 Intel 无法从中获利，

324
00:14:59,270 --> 00:15:00,565
同样糟糕的是，

325
00:15:00,565 --> 00:15:02,310
现在没有人会在下一个十年里尝试这一技术，

326
00:15:02,870 --> 00:15:05,130
因为如果 Intel 不能从中获利，

327
00:15:05,480 --> 00:15:06,700
谁又能呢。

328
00:15:07,650 --> 00:15:10,550
但是不同的数据库公司有不同的项目，

329
00:15:10,550 --> 00:15:14,710
他们试图围绕持久内存构建数据库系统，

330
00:15:14,970 --> 00:15:16,655
因为同样，我们必须做的一大堆事情，

331
00:15:16,655 --> 00:15:20,440
在磁盘和内存之间来回移动数据会随之消失。

332
00:15:21,060 --> 00:15:21,880
所以这是一种遗憾。

333
00:15:23,340 --> 00:15:27,005
好的，我们必须了解，

334
00:15:27,005 --> 00:15:28,550
存储是什么样子的原因是，

335
00:15:28,550 --> 00:15:30,220
因为性能特征，

336
00:15:30,840 --> 00:15:34,030
正如我所说的，这些不同设备之间截然不同，

337
00:15:35,140 --> 00:15:38,985
我们将尝试最大限度地提高数据的工作量，

338
00:15:38,985 --> 00:15:40,650
当数据存储在内存中时，

339
00:15:40,650 --> 00:15:42,620
当我们将数据从磁盘移入内存时，

340
00:15:42,850 --> 00:15:45,560
我们希望尽可能多地处理这些数据，

341
00:15:45,820 --> 00:15:48,940
在丢弃数据并将其他数据放入内存之前，

342
00:15:48,940 --> 00:15:51,480
在理想情况下，我们的数据库应该完全存储在内存中，

343
00:15:52,040 --> 00:15:53,470
即使这样，你也必须写出磁盘，

344
00:15:53,470 --> 00:15:55,200
但在某些情况下，这并不总是可能的。

345
00:15:56,570 --> 00:15:57,820
实现这个的方法是，

346
00:15:57,820 --> 00:16:03,000
在 CPU 级别，缓存未命中基本上是一纳秒，

347
00:16:03,410 --> 00:16:05,820
走出 DRAM 是数百纳秒，

348
00:16:05,960 --> 00:16:09,835
而 SSD 大约是 16 微秒或 16000 纳秒，

349
00:16:09,835 --> 00:16:10,770
这真的很不错，

350
00:16:11,120 --> 00:16:13,770
旋转磁盘硬盘是两百万纳秒，

351
00:16:13,790 --> 00:16:15,685
然后 EBS 可能会波动，

352
00:16:15,685 --> 00:16:18,300
有时是 50 毫秒，有时是 500 毫秒，

353
00:16:18,350 --> 00:16:20,010
这取决于数据的热度，

354
00:16:20,120 --> 00:16:23,580
然后是磁带存档，再说一次，这是[冰冷的]，

355
00:16:23,580 --> 00:16:25,400
你不想在它上面构建任何系统。

356
00:16:25,870 --> 00:16:27,735
所以这个数据来自，

357
00:16:27,735 --> 00:16:29,685
这个特殊数据来自，

358
00:16:29,685 --> 00:16:31,190
这里有一个伯克利的网站和一个链接，

359
00:16:31,360 --> 00:16:33,260
他向你展示了硬件性能的趋势

360
00:16:33,400 --> 00:16:35,480
或这些设备随着时间的推移的速度，

361
00:16:35,890 --> 00:16:40,860
这张表被认为是 Jeff Dean 在 2000 年早期的贡献，

362
00:16:40,860 --> 00:16:43,970
我认为它可能早于他之前。

363
00:16:44,350 --> 00:16:47,540
所以作为人类，我们很难推理纳秒，

364
00:16:47,860 --> 00:16:49,530
比如一纳秒，这是什么意思，

365
00:16:49,530 --> 00:16:51,920
或者你知道 200 万纳秒，那是很长的时间吗？

366
00:16:52,320 --> 00:16:55,955
所以有一个简单的技巧可以让你意识到，

367
00:16:55,955 --> 00:16:57,995
这到底有多大，有多糟糕，

368
00:16:57,995 --> 00:16:59,320
或者事情实际上会变慢多少，

369
00:16:59,640 --> 00:17:03,520
如果你把一纳秒改为一秒，

370
00:17:04,170 --> 00:17:04,910
这是一个小把戏，

371
00:17:04,910 --> 00:17:08,530
Jim Gray 在上世纪 90 年代经常做的，

372
00:17:09,000 --> 00:17:11,500
如果你把一纳秒改为一秒，

373
00:17:11,670 --> 00:17:15,070
现在你可以看到其他设备的速度慢了很多，

374
00:17:15,150 --> 00:17:18,670
你知道为什么要尽可能地将所有内容都保存在内存中了，

375
00:17:19,140 --> 00:17:20,240
所以你可以想，

376
00:17:20,240 --> 00:17:22,090
如果我必须从一本书上读一页，

377
00:17:22,890 --> 00:17:27,790
然后说， L1 缓存未命中就像走到桌边，查着书，

378
00:17:27,930 --> 00:17:30,365
或者，如果我必须从 SSD 或 DRAM 中读取，

379
00:17:30,365 --> 00:17:32,350
可能它会走到图书馆，然后找到那本书，

380
00:17:33,420 --> 00:17:34,910
但如果我必须从磁带档案中读取，

381
00:17:34,910 --> 00:17:38,380
那就是 31 年，这相当于飞到冥王星，

382
00:17:38,610 --> 00:17:39,610
然后读一本书。

383
00:17:39,840 --> 00:17:41,890
所以，我们希望尽可能地避免这一切。

384
00:17:43,170 --> 00:17:43,570
好的？

385
00:17:45,300 --> 00:17:46,400
所以顺序访问和随机访问，

386
00:17:46,400 --> 00:17:48,305
我们已经讨论过了，

387
00:17:48,305 --> 00:17:51,965
但在整个学期中，这将是一个反复出现的主题，

388
00:17:51,965 --> 00:17:56,375
数据库系统倾向于顺序访问，而不是随机访问，

389
00:17:56,375 --> 00:17:57,250
无论是读还是写，

390
00:17:58,590 --> 00:18:00,610
当是旋转磁盘硬盘时，这会产生巨大的不同，

391
00:18:00,660 --> 00:18:01,780
但是即使是在 SSD 上，

392
00:18:02,280 --> 00:18:04,910
因为它们在幕后工作使用[]，

393
00:18:04,910 --> 00:18:06,250
然后进行压缩等，

394
00:18:06,510 --> 00:18:12,270
你尽可能地按顺序进行批处理区域写入，

395
00:18:15,720 --> 00:18:17,620
好的，所以，我们将拥有的其他系统设计目标，

396
00:18:17,880 --> 00:18:21,730
以及我们如何选择，如何构建我们的系统是，

397
00:18:21,870 --> 00:18:23,020
我们想要给人一种错觉，

398
00:18:23,250 --> 00:18:26,800
我们完全在内存中操作数据库，

399
00:18:27,820 --> 00:18:30,255
再说一次，因为大多数数据库都没有那么大，

400
00:18:30,255 --> 00:18:32,870
大多数数据库的容量都不到 10 GB，

401
00:18:33,070 --> 00:18:37,700
但是非常庞大的数据库，比如 TB ，GB 和 TB PB ，

402
00:18:37,750 --> 00:18:41,030
理想情况下你想要给人一种，

403
00:18:41,870 --> 00:18:42,670
一切都已经在内存中了，

404
00:18:42,670 --> 00:18:43,980
尽管它实际上并不是，

405
00:18:44,890 --> 00:18:47,070
我们可以做一些小把戏来隐藏磁盘[]等等。

406
00:18:48,160 --> 00:18:51,170
然后，由于读写磁盘是如此昂贵，

407
00:18:52,750 --> 00:18:55,550
我们想在我们的系统设计中做一些其他的技巧，

408
00:18:55,630 --> 00:19:01,520
来避免长时间停顿或使系统显示为无响应，

409
00:19:01,520 --> 00:19:03,905
因为这会使应用程序或用户感到沮丧，

410
00:19:03,905 --> 00:19:05,710
因为他们认为系统卡住了，

411
00:19:06,540 --> 00:19:08,050
但你实际上是在从磁盘获取数据，

412
00:19:08,370 --> 00:19:09,905
但这也会导致其他问题，

413
00:19:09,905 --> 00:19:12,785
因为如果我们比如对某个东西加锁而停滞，

414
00:19:12,785 --> 00:19:15,100
因为我们必须从磁盘读取东西或从磁盘写入东西，

415
00:19:15,360 --> 00:19:17,560
这将减慢我们后面的其他操作的速度，

416
00:19:18,480 --> 00:19:19,475
并产生护航效应。

417
00:19:19,475 --> 00:19:20,315
所以有一堆，

418
00:19:20,315 --> 00:19:23,050
出于这个原因，我们想要尽可能地避免这种情况，

419
00:19:23,990 --> 00:19:27,390
再说一次，因为随机访问比顺序访问慢，

420
00:19:27,740 --> 00:19:29,190
所以我们希望最大化顺序访问。

421
00:19:31,580 --> 00:19:32,790
那么，这一切听起来像什么，

422
00:19:35,180 --> 00:19:37,650
有了我们比实际拥有更多的内存的[现象]，

423
00:19:39,380 --> 00:19:39,990
虚拟内存，

424
00:19:40,850 --> 00:19:41,760
所以我们稍后会讲到这个，

425
00:19:42,230 --> 00:19:44,610
我将解释为什么我们不想从操作系统获得虚拟内存，

426
00:19:44,810 --> 00:19:48,870
以及为什么作为数据库系统开发人员和构建实际系统的工程师，

427
00:19:49,340 --> 00:19:51,895
我们总是想自己做尽可能多的事情，

428
00:19:51,895 --> 00:19:53,730
而不是依赖操作系统来做任何事情。

429
00:19:55,070 --> 00:19:57,040
所以，从高级别上看，这是我们的图，

430
00:19:57,040 --> 00:19:57,600
这是我们正在构建的，

431
00:19:58,070 --> 00:20:01,350
所以我们有一些数据库文件，

432
00:20:02,000 --> 00:20:02,700
无所谓，

433
00:20:03,290 --> 00:20:04,440
我们可以讨论不同之处，

434
00:20:04,880 --> 00:20:07,200
我们有一些数据库文件在磁盘上，

435
00:20:07,460 --> 00:20:08,940
我们将把它拆分成页，

436
00:20:09,730 --> 00:20:11,810
我稍后会描述一个页，

437
00:20:12,160 --> 00:20:13,830
然后会有一些目录显示，

438
00:20:13,830 --> 00:20:15,660
这是我拥有的页，这是找到它们的位置，

439
00:20:15,660 --> 00:20:16,730
一切都安排好了，以此类推。

440
00:20:17,670 --> 00:20:19,840
然后会有一些缓冲池，

441
00:20:20,250 --> 00:20:23,140
数据库系统分配的内存，

442
00:20:23,310 --> 00:20:25,810
对操作系统调用 malloc ，获得一些内存，

443
00:20:26,370 --> 00:20:28,480
然后，我们将把它用作中转区，

444
00:20:28,530 --> 00:20:30,580
从磁盘调入页。

445
00:20:31,540 --> 00:20:32,820
所以现在，如果执行引擎，

446
00:20:32,820 --> 00:20:34,760
即将运行我们的查询的东西出现，

447
00:20:35,110 --> 00:20:37,700
它想要获得第二页，

448
00:20:38,360 --> 00:20:42,550
我们现在可以忽略它是如何知道的想要第二页，

449
00:20:42,690 --> 00:20:44,530
但假设这就是它想要的那个，第二页。

450
00:20:45,160 --> 00:20:47,515
所以我们要做的第一件事是引入页面目录，

451
00:20:47,515 --> 00:20:51,480
因为这将告诉我们页面在磁盘哪里，

452
00:20:51,950 --> 00:20:54,120
然后它会调用操作系统，

453
00:20:54,560 --> 00:20:57,630
或存储数据库文件的任何设备，

454
00:20:57,800 --> 00:20:59,640
它会把那一页放入内存中。

455
00:21:00,200 --> 00:21:05,915
现在，缓冲池将返回给执行引擎一个内存中的指针，

456
00:21:05,915 --> 00:21:10,300
内存中的一个 64 位指针，表明页所在的位置，

457
00:21:11,410 --> 00:21:14,060
现在，这取决于执行引擎或访问方法，即操作者，

458
00:21:14,260 --> 00:21:15,950
然后解释页面中的内容，

459
00:21:16,740 --> 00:21:19,995
因为所有这些对系统的其他部分来说都是不透明的，

460
00:21:19,995 --> 00:21:20,480
他们不会，

461
00:21:21,205 --> 00:21:21,760
这并不完全是真的，

462
00:21:21,760 --> 00:21:23,220
但在这一点上，他们并不真正需要知道。

463
00:21:23,980 --> 00:21:25,645
然后假设一旦你做了一系列更新，

464
00:21:25,645 --> 00:21:28,200
它就会对第二页中的内容进行更改，

465
00:21:28,340 --> 00:21:29,500
我不是说它是否是一个 tuple ，

466
00:21:29,500 --> 00:21:30,400
我不是说它是否是一个索引，

467
00:21:30,400 --> 00:21:30,990
这并不重要。

468
00:21:31,950 --> 00:21:35,645
然后，数据库系统负责将其写回磁盘，

469
00:21:35,645 --> 00:21:37,330
以确保任何更改都是持久的。

470
00:21:38,990 --> 00:21:42,270
这就是我们接下来三四节课要讲的内容，

471
00:21:43,010 --> 00:21:44,790
这就是我们要构建的架构，

472
00:21:45,380 --> 00:21:47,610
我们将讨论页面是什么样子的，

473
00:21:48,110 --> 00:21:50,190
在接下来的三节课中， 3 4 5 ，

474
00:21:50,630 --> 00:21:53,640
我们将讨论如写出磁盘在第 6 节课，

475
00:21:54,740 --> 00:21:56,730
以及如何管理内存在第 6 节课，

476
00:21:57,200 --> 00:22:00,660
然后我们将讨论如何执行查询，在第 12, 13 节课中。

477
00:22:03,590 --> 00:22:05,100
所以我们今天真正关注的是，

478
00:22:06,450 --> 00:22:08,020
磁盘上的这些东西是什么？

479
00:22:09,030 --> 00:22:09,430
好的。

480
00:22:10,670 --> 00:22:12,390
所以我之前说过，这听起来像什么？

481
00:22:13,160 --> 00:22:14,040
每个人都说虚拟记忆，

482
00:22:14,630 --> 00:22:18,895
你说，好的，为什么，为什么接下来的三节课，

483
00:22:18,895 --> 00:22:23,580
你需要这节课，为什么还需要接下来的两节课，

484
00:22:23,720 --> 00:22:25,830
讨论如何在磁盘之间来回管理内存，

485
00:22:25,850 --> 00:22:27,150
当操作系统可以为我们做这件事时。

486
00:22:28,250 --> 00:22:31,770
你知道以这种方式使用虚拟内存的系统调用是什么吗，

487
00:22:33,510 --> 00:22:35,080
mmap ，漂亮，很棒，

488
00:22:35,610 --> 00:22:36,460
所以答案是内存映射文件，

489
00:22:36,840 --> 00:22:38,140
这是在 POSIX 标准中，

490
00:22:38,640 --> 00:22:40,030
Windows 有自己的版本，

491
00:22:40,290 --> 00:22:43,840
但这允许你获取磁盘上文件的内容，

492
00:22:44,070 --> 00:22:47,710
并将其映射到进程中的虚拟内存中，

493
00:22:47,940 --> 00:22:49,210
在你的进程的地址中，

494
00:22:49,860 --> 00:22:55,390
现在，该进程可以跳转到内存中该地址空间中的任何偏移量，

495
00:22:56,100 --> 00:22:58,065
操作系统负责决定，

496
00:22:58,065 --> 00:22:59,930
哦，你需要的东西是否在内存中，

497
00:23:00,160 --> 00:23:02,430
如果不是，那么它会获取你需要的页面，

498
00:23:02,430 --> 00:23:04,750
并将其放入内存中。

499
00:23:05,530 --> 00:23:07,880
所以数据库系统没有做任何写入，

500
00:23:08,200 --> 00:23:09,800
它只是使用 mmap 打开文件，

501
00:23:10,270 --> 00:23:12,740
操作系统完成所有数据的管理，

502
00:23:12,790 --> 00:23:14,150
为我们将数据来回移动。

503
00:23:15,460 --> 00:23:16,320
所以它看起来有点像这样，

504
00:23:16,320 --> 00:23:17,175
我们有一个磁盘上的文件，

505
00:23:17,175 --> 00:23:17,840
我们有一大堆页面，

506
00:23:19,700 --> 00:23:21,040
我们调用 mmap 来打开它，

507
00:23:21,420 --> 00:23:24,670
然后我们就有了虚拟内存和物理内存的概念，

508
00:23:24,810 --> 00:23:27,640
虚拟内存将是我在进程地址空间中看到的，

509
00:23:28,770 --> 00:23:32,470
在某个起始位置，我会得到 mmap 文件，

510
00:23:33,460 --> 00:23:35,865
然后，这些虚拟内存必须由物理页面支持，

511
00:23:35,865 --> 00:23:37,040
所以，当我[触摸]页面时，

512
00:23:37,600 --> 00:23:40,580
操作系统必须将其放入物理内存中的某个空间，

513
00:23:40,840 --> 00:23:44,440
然后更新虚拟内存表的连接。

514
00:23:45,000 --> 00:23:47,620
所以我的进程想要接触第一页，

515
00:23:48,120 --> 00:23:49,670
这样我们就会出现页面错误，

516
00:23:49,670 --> 00:23:51,220
因为操作系统会意识到，

517
00:23:51,270 --> 00:23:52,900
我在物理内存中没有第一页，

518
00:23:53,640 --> 00:23:55,520
它会取出磁盘，为我取出，放入，

519
00:23:56,020 --> 00:23:57,540
更新虚拟内存，指向它，

520
00:23:57,540 --> 00:24:00,740
然后我的进程可以[接触]它或对它做任何想做的事情。

521
00:24:01,650 --> 00:24:03,340
一样的东西，现在，如果我想要第三页，

522
00:24:03,570 --> 00:24:04,265
它不在那里，

523
00:24:04,265 --> 00:24:05,110
我收到一个页面错误，

524
00:24:05,160 --> 00:24:06,310
操作系统会阻止我的进程，

525
00:24:07,050 --> 00:24:08,500
当我这样做，当我访问它时，

526
00:24:08,790 --> 00:24:11,825
它会从磁盘获取我需要的页面，更新连接，

527
00:24:11,825 --> 00:24:15,395
然后我的进程可以再次开始运行，

528
00:24:15,395 --> 00:24:16,450
我的线程可以重新开始运行。

529
00:24:17,660 --> 00:24:19,710
如果我想[接触]第二页，怎么办？

530
00:24:22,550 --> 00:24:23,070
那是什么？

531
00:24:24,060 --> 00:24:24,940
它会丢掉它，

532
00:24:25,380 --> 00:24:27,040
但是当我丢掉它的时候，会发生什么？

533
00:24:28,710 --> 00:24:30,100
我的进程停止了，

534
00:24:30,390 --> 00:24:32,110
操作系统会阻止我，

535
00:24:32,520 --> 00:24:35,020
它会说，好的，我没有更多的物理内存，

536
00:24:35,250 --> 00:24:38,045
让我找出应该页面 1 还是页面 3 ，

537
00:24:38,045 --> 00:24:40,490
我应该扔掉哪一个，

538
00:24:41,350 --> 00:24:43,820
但操作系统会有自己的内部统计数据，

539
00:24:43,960 --> 00:24:46,850
关于这些页面是如何被访问的，

540
00:24:47,050 --> 00:24:50,300
它将决定驱逐哪个页面，

541
00:24:51,430 --> 00:24:54,140
但它不知道我们在数据库系统中做了什么，

542
00:24:54,190 --> 00:24:55,575
因为它只能看到读、写，

543
00:24:55,575 --> 00:24:57,620
它没有[课程屏幕]，

544
00:24:57,670 --> 00:24:58,820
不知道什么是查询，

545
00:24:58,930 --> 00:25:00,230
不知道这些数据页面中有什么，

546
00:25:01,360 --> 00:25:02,150
这些文件中有什么，

547
00:25:02,770 --> 00:25:05,450
所以，操作系统将尝试就如何将东西换出做出决定。

548
00:25:06,850 --> 00:25:08,265
这只是为了驱逐，

549
00:25:08,265 --> 00:25:10,995
我们将面临一大堆其他问题，

550
00:25:10,995 --> 00:25:12,890
如果我们依赖操作系统来为我们做这件事。

551
00:25:15,170 --> 00:25:16,885
所以，在我的第一个示例中，

552
00:25:16,885 --> 00:25:20,070
我共享了一个线程或一个进程来访问它。

553
00:25:20,560 --> 00:25:21,940
同样，我们将尝试建立一个数据库，

554
00:25:21,940 --> 00:25:25,980
一个可以利用多核或多 CPU 的现代数据库系统，

555
00:25:26,840 --> 00:25:28,680
所以，我们需要让多个线程访问它们，

556
00:25:29,440 --> 00:25:30,680
但是，如果它们中的一个，

557
00:25:32,280 --> 00:25:34,500
其中一个线程创建了一些东西，写入它，

558
00:25:34,500 --> 00:25:35,790
然后另一个线程试图读取它，

559
00:25:35,790 --> 00:25:37,640
但它被停滞了，因为它被驱逐了，

560
00:25:38,350 --> 00:25:40,140
顺序可能会变得有点古怪，

561
00:25:40,140 --> 00:25:43,130
同样，操作系统不知道正在发生的任何事情，

562
00:25:43,150 --> 00:25:44,840
也不知道同时在系统内运行的是什么。

563
00:25:46,130 --> 00:25:47,910
所以如果一切都是只读的，没有问题，

564
00:25:48,880 --> 00:25:50,120
因为我们没有弄脏任何页面，

565
00:25:50,350 --> 00:25:51,590
操作系统可以把东西换出来，

566
00:25:52,360 --> 00:25:53,210
这已经足够好了，

567
00:25:53,410 --> 00:25:54,300
而且也有一些案例，

568
00:25:54,300 --> 00:25:59,180
有一些数据库系统确实只将 mmap 用于系统的只读部分。

569
00:26:00,740 --> 00:26:02,370
但是如果你现在需要多个写入者，

570
00:26:03,230 --> 00:26:05,130
在真实系统中，我们将需要这个，

571
00:26:06,430 --> 00:26:07,400
然后还有一堆其他的问题。

572
00:26:09,120 --> 00:26:10,805
所以，第一个问题是事务安全，

573
00:26:10,805 --> 00:26:12,130
这就是我提到的问题，

574
00:26:13,050 --> 00:26:16,150
如果我有一个更新多个页面的事务，

575
00:26:17,080 --> 00:26:20,250
我要确保这些页面是以正确的顺序写出的，

576
00:26:20,630 --> 00:26:21,970
并且操作系统不知道这一点，

577
00:26:21,970 --> 00:26:23,490
因为它只解决脏页，

578
00:26:23,780 --> 00:26:24,990
它完全不知道，

579
00:26:25,750 --> 00:26:27,710
这一页是否需要在另一页之前写入，

580
00:26:29,710 --> 00:26:30,855
你可以做一些事情，

581
00:26:30,855 --> 00:26:32,420
比如你可以使用 mlock 锁定页面，

582
00:26:32,890 --> 00:26:35,030
但这只会阻止操作系统将其换出，

583
00:26:35,230 --> 00:26:36,560
而不会阻止它写出，

584
00:26:36,910 --> 00:26:39,200
现在它可能会写出一个它不应该写出的脏页，

585
00:26:39,310 --> 00:26:40,380
我崩溃了，然后又回来了，

586
00:26:40,380 --> 00:26:42,920
现在我有了一些不应该写在磁盘上的更改，

587
00:26:43,640 --> 00:26:45,750
我不得不想办法如何扭转这一局面，

588
00:26:46,250 --> 00:26:50,640
或者处理坏数据，不一致的数据。

589
00:26:52,180 --> 00:26:53,720
我们已经讨论过做停滞的事，

590
00:26:54,820 --> 00:26:56,655
同样，如果你尝试访问不在内存中的内容，

591
00:26:56,655 --> 00:26:57,795
会出现严重的页面错误，

592
00:26:57,795 --> 00:26:58,710
它阻塞你的线程，

593
00:26:58,710 --> 00:26:59,480
阻止调度你，

594
00:26:59,980 --> 00:27:02,715
磁盘调度器去获取你的页面，把它带进来，

595
00:27:02,715 --> 00:27:03,330
当它可用时，

596
00:27:03,330 --> 00:27:05,300
你的线程会再次重新调度。

597
00:27:05,970 --> 00:27:09,410
但是现在你的线程被阻塞，无法执行任何操作，

598
00:27:09,790 --> 00:27:11,990
你可能还可以运行其他查询，

599
00:27:13,420 --> 00:27:15,650
当你在等待那个东西从磁盘获取时。

600
00:27:16,440 --> 00:27:19,805
然后你会说，好的，也许我会做一个调度器，

601
00:27:19,805 --> 00:27:21,770
这样只有一个线程去处理和获取东西，

602
00:27:21,770 --> 00:27:22,580
并且有一个页面错误，

603
00:27:22,580 --> 00:27:25,030
他被阻塞了，然后我就可以再运行其他线程。

604
00:27:25,720 --> 00:27:30,170
但是现在，你围绕 mmap 的限制建立了更多的基础设施。

605
00:27:32,030 --> 00:27:36,665
你遇到的下一个问题是，如何处理错误，

606
00:27:36,665 --> 00:27:38,410
如果我在 mmap 中，

607
00:27:38,430 --> 00:27:40,330
如果我试图访问一个页面，

608
00:27:40,890 --> 00:27:43,720
不管是什么原因，它被损坏或不可用，

609
00:27:43,950 --> 00:27:45,250
那么就会出现一些硬件问题，

610
00:27:46,210 --> 00:27:47,730
你不会得到异常，

611
00:27:47,730 --> 00:27:49,460
像在用户空间编写的代码，

612
00:27:49,930 --> 00:27:51,410
你会得到一个 SIGBUS 和中断。

613
00:27:52,420 --> 00:27:55,010
现在，你需要一个贯穿整个系统其余部分的信号处理程序，

614
00:27:55,360 --> 00:27:58,480
因为你可能正在执行一些临界区中的操作，

615
00:27:58,960 --> 00:28:01,740
你不希望被中断或打断，

616
00:28:01,740 --> 00:28:03,290
所以，你必须有一个中断处理程序，

617
00:28:03,490 --> 00:28:05,720
以确保你可以返回到之前在做的事情，

618
00:28:07,900 --> 00:28:09,390
为了处理这个中断，

619
00:28:10,100 --> 00:28:11,250
因为这是唯一的，

620
00:28:12,740 --> 00:28:15,840
这是操作系统告诉你，事情正在变坏，

621
00:28:16,430 --> 00:28:17,575
你不能返回错误码，

622
00:28:17,575 --> 00:28:18,900
你可以返回并中断。

623
00:28:22,240 --> 00:28:24,500
需要说的是，这需要大量的工程技术来处理，

624
00:28:24,520 --> 00:28:25,400
你不会想要这样做。

625
00:28:25,870 --> 00:28:28,100
然后，显然会出现性能问题，

626
00:28:29,410 --> 00:28:33,165
这是因为操作系统将有自己的内部数据结构，

627
00:28:33,165 --> 00:28:34,490
关于什么在内存中，不在内存中，

628
00:28:35,320 --> 00:28:36,770
什么正在调度或未调度，

629
00:28:37,090 --> 00:28:40,100
它还必须保护自己数据结构中的那些临界部分，

630
00:28:40,920 --> 00:28:42,130
使用 mutex 或其他什么，

631
00:28:43,560 --> 00:28:45,640
现在这将是一个争议点，

632
00:28:46,500 --> 00:28:48,065
因为在数据库系统中，

633
00:28:48,065 --> 00:28:49,700
因为我们知道查询要做什么，

634
00:28:49,700 --> 00:28:51,100
因为 SQL 是声明性的，

635
00:28:51,180 --> 00:28:52,655
所以我们知道查询要做什么，

636
00:28:52,655 --> 00:28:53,650
因为我们有物理计划，

637
00:28:53,910 --> 00:28:55,600
我们知道试图访问什么数据，

638
00:28:55,860 --> 00:28:59,140
因此我们可以更好地决定如何调度事情。

639
00:29:00,420 --> 00:29:00,820
好的。

640
00:29:06,170 --> 00:29:06,805
他的问题是，

641
00:29:06,805 --> 00:29:08,910
数据库系统是否有权直接与硬件一起工作，

642
00:29:09,350 --> 00:29:11,070
有一些称为内核旁路的方法，

643
00:29:11,510 --> 00:29:12,600
你可以，

644
00:29:14,080 --> 00:29:15,265
或者 NVMe 是这样的，

645
00:29:15,265 --> 00:29:19,260
有一些方法可以在不依赖操作系统的情况下调用硬件。

646
00:29:20,420 --> 00:29:21,815
这些东西的问题是，

647
00:29:21,815 --> 00:29:25,810
你必须在数据库系统中实现一系列操作系统备份，

648
00:29:26,340 --> 00:29:29,830
这就是所谓的 tangent ，

649
00:29:30,120 --> 00:29:33,910
如果你不想使用操作系统的 TCP 协议栈进行网络，

650
00:29:34,080 --> 00:29:40,015
有一个叫做 DPDK 的东西，来自 Intel ，

651
00:29:40,015 --> 00:29:41,790
数据平面开发套件，

652
00:29:41,900 --> 00:29:43,830
基本上，这是一种直接连接到硬件中的方法，

653
00:29:44,000 --> 00:29:45,480
你可以获得原始数据包，

654
00:29:45,740 --> 00:29:47,020
但同样，它是原始数据包，

655
00:29:47,020 --> 00:29:48,210
如果它是一个 TCP 连接，

656
00:29:48,530 --> 00:29:52,230
那么现在你必须跟踪 TCP 头。

657
00:29:53,840 --> 00:29:55,195
很少有数据库系统能做到这个，

658
00:29:55,195 --> 00:29:56,010
我只知道两个，

659
00:29:56,500 --> 00:29:58,740
一个是 Yellowbrick ，

660
00:29:59,000 --> 00:30:00,640
我们在整个学期中都会讨论这些，

661
00:30:00,640 --> 00:30:01,705
他们有很多令人惊叹的东西，

662
00:30:01,705 --> 00:30:03,360
他们基本上重写了自己的，

663
00:30:04,130 --> 00:30:06,630
他们基本上只使用操作系统来打开，

664
00:30:06,770 --> 00:30:08,215
然后他们永远不会再调用 malloc ，

665
00:30:08,215 --> 00:30:10,020
他们分配所有的内存，一切都开始了，

666
00:30:10,280 --> 00:30:12,300
他们编写了自己的 PCIe 驱动程序，

667
00:30:12,530 --> 00:30:14,160
他们做了一堆令人惊叹的工程，

668
00:30:14,390 --> 00:30:15,300
很少有人会这么做。

669
00:30:15,590 --> 00:30:17,010
另一家是 ScyllaDB ，

670
00:30:17,120 --> 00:30:19,420
但 DPDK 太难处理了，

671
00:30:19,420 --> 00:30:21,840
这是巨大的痛苦，他们不会这么做。

672
00:30:21,920 --> 00:30:23,730
所以这个问题的答案是，

673
00:30:25,560 --> 00:30:27,310
对于某些事情，你必须通过操作系统，

674
00:30:30,460 --> 00:30:32,150
在 80 年代，他们变得非常疯狂，

675
00:30:32,200 --> 00:30:35,160
他们不再使用文件系统，

676
00:30:35,160 --> 00:30:38,150
而是在原始数据块设备上编写自己的存储层，

677
00:30:38,380 --> 00:30:40,100
人们每年都会尝试这种方法，

678
00:30:40,390 --> 00:30:41,570
从工程学的角度来看，

679
00:30:43,110 --> 00:30:45,215
通常情况下，你确实必须依赖操作系统，

680
00:30:45,215 --> 00:30:47,140
但你想尽量减少与它的接触，

681
00:30:47,640 --> 00:30:48,710
因为操作系统将成为你的敌人。

682
00:30:51,550 --> 00:30:52,100
还有其他问题吗？

683
00:30:54,660 --> 00:30:55,870
我没有在 mmap 上花太多时间，

684
00:30:56,460 --> 00:30:58,510
这是个坏的想法，不要这样做，

685
00:30:59,640 --> 00:31:02,530
如果我死了，你可以把它放在我的墓碑上，

686
00:31:02,790 --> 00:31:03,880
永远不要在你的数据库上使用 mmap 。

687
00:31:05,130 --> 00:31:08,200
我之所以想提出这一点是因为，

688
00:31:08,640 --> 00:31:12,130
我们邀请了很多数据库公司和初创公司来 CMU 演讲，

689
00:31:12,360 --> 00:31:14,270
令人惊讶的是，在过去的几年里，

690
00:31:14,270 --> 00:31:15,970
他们中的许多人提到他们使用了 mmap ，

691
00:31:16,230 --> 00:31:17,200
我们问他们为什么，

692
00:31:17,250 --> 00:31:19,360
他们说，哦，因为它又快又容易使用，

693
00:31:19,680 --> 00:31:21,335
然后当我们几年后与他们交谈时，

694
00:31:21,335 --> 00:31:22,415
他们说，哦，是的，这是一个巨大的错误，

695
00:31:22,415 --> 00:31:23,285
我们不应该使用 mmap ，

696
00:31:23,285 --> 00:31:26,140
我们应该做第 6 节课要教你们的。

697
00:31:26,670 --> 00:31:28,940
下面是我所知道的一些使用 mmap 的系统的列表，

698
00:31:28,940 --> 00:31:30,440
我肯定还有其他几个我错过了，

699
00:31:30,440 --> 00:31:31,300
有一堆业余爱好项目。

700
00:31:32,620 --> 00:31:34,165
所以，在上面的那些，这些是完全使用，

701
00:31:34,165 --> 00:31:34,765
在这些系统中，

702
00:31:34,765 --> 00:31:39,570
它们完全使用 mmap 来处理所有数据在磁盘和内存中的来回。

703
00:31:41,300 --> 00:31:42,910
其中最著名的大概就是 Elastic ，

704
00:31:44,010 --> 00:31:49,720
MonetDB 是由 CWI 构建的，

705
00:31:49,720 --> 00:31:50,940
也是构建[]数据库的地方，

706
00:31:51,440 --> 00:31:53,860
LMDB 做的可能与我相反，

707
00:31:53,860 --> 00:31:55,165
我的意思是永远不要使用 mmap ，

708
00:31:55,165 --> 00:31:56,790
他喜欢一直使用 mmap ，

709
00:31:57,020 --> 00:31:59,530
他在一堆不同的数据库邮件列表上被禁止，

710
00:31:59,530 --> 00:32:00,340
因为他会给他们发电子邮件，

711
00:32:00,340 --> 00:32:01,500
说你们应该使用，

712
00:32:01,700 --> 00:32:04,380
你们应该使用 LMDB ，应该使用 mmap ，

713
00:32:04,430 --> 00:32:07,100
他错了，他[]。

714
00:32:09,490 --> 00:32:12,410
但这是部分使用它的人，

715
00:32:13,270 --> 00:32:14,625
实际上，我应该把 Mongo 放在完全使用，

716
00:32:14,625 --> 00:32:15,560
他们应该在上面，

717
00:32:15,880 --> 00:32:17,120
但是下面的这些，

718
00:32:17,380 --> 00:32:19,345
他们都摆脱了它，

719
00:32:19,345 --> 00:32:21,090
由于我前面提到的所有问题，

720
00:32:21,290 --> 00:32:24,715
如果你使用 mmap ，你可以很快启动和运行一些东西，

721
00:32:24,715 --> 00:32:26,190
因为你不必构建自己的缓冲池管理器，

722
00:32:26,690 --> 00:32:29,370
但因为你依赖操作系统上来回移动数据，

723
00:32:29,510 --> 00:32:31,680
它将做出可怕的决定。

724
00:32:32,420 --> 00:32:34,390
我不想选择 Mongo ，

725
00:32:34,390 --> 00:32:35,695
但 Mongo 就是最好的例子，

726
00:32:35,695 --> 00:32:39,060
Mongo 从一个基于 mmap 的存储引擎、存储管理器开始，

727
00:32:39,590 --> 00:32:41,970
他们是 2010 年代的热门数据库，

728
00:32:42,230 --> 00:32:44,250
他们筹集了大量的投资者资金，

729
00:32:44,630 --> 00:32:45,850
而且他们有非常优秀的工程师，

730
00:32:45,850 --> 00:32:47,970
他们是基于 mmap ，

731
00:32:48,170 --> 00:32:49,590
如果 mmap 是正确的选择，

732
00:32:50,460 --> 00:32:52,840
他们就可以使它工作，

733
00:32:53,600 --> 00:32:54,570
但他们做了什么，

734
00:32:54,620 --> 00:32:55,570
他们把所有的东西都扔掉了，

735
00:32:55,570 --> 00:32:56,485
然后购买了 WiredTiger ，

736
00:32:56,485 --> 00:32:59,430
它有一个不使用 mmap 的存储管理器。

737
00:33:00,290 --> 00:33:01,920
所以，再次重申，

738
00:33:02,030 --> 00:33:04,860
永远不要使用，我们不想使用操作系统来管理内存，

739
00:33:05,120 --> 00:33:07,860
因为数据库系统总是更适合这样做，

740
00:33:08,460 --> 00:33:09,780
而且它不仅仅用于管理内存，

741
00:33:09,780 --> 00:33:11,060
它基本上适用于所有事情，

742
00:33:11,170 --> 00:33:12,585
我们不需要操作系统来调度，

743
00:33:12,585 --> 00:33:15,080
我们不想让操作系统来缓存写入，

744
00:33:15,940 --> 00:33:18,110
我们不需要使用操作系统来，

745
00:33:19,740 --> 00:33:21,605
以及你在某些情况下需要的网络东西，

746
00:33:21,605 --> 00:33:23,165
但这是有技巧的，

747
00:33:23,165 --> 00:33:25,240
但操作系统总是会是一个问题。

748
00:33:26,040 --> 00:33:28,965
再次，对于 mmap ，

749
00:33:28,965 --> 00:33:30,620
我将在 Piazza 上发送这个链接，

750
00:33:30,670 --> 00:33:31,485
我们写了一篇关于这个的论文，

751
00:33:31,485 --> 00:33:32,340
那么为什么你不想用这个，

752
00:33:32,340 --> 00:33:34,695
然后有一段 10 分钟的 Youtube 视频卡通片，

753
00:33:34,695 --> 00:33:36,200
讲述了所有的问题。

754
00:33:37,920 --> 00:33:40,310
所以，操作系统将成为我们的问题，

755
00:33:40,310 --> 00:33:42,220
我们必须设计自己的系统来处理它。

756
00:33:45,300 --> 00:33:46,840
好的，对于数据库存储，

757
00:33:47,585 --> 00:33:48,640
有两个问题要处理。

758
00:33:50,060 --> 00:33:53,700
我们如何在磁盘的这些文件上表示数据库，

759
00:33:53,960 --> 00:33:55,770
然后，一旦我们有了这些，

760
00:33:55,940 --> 00:33:58,650
我们如何在磁盘和内存之间来回移动数据，

761
00:33:59,300 --> 00:34:02,130
所以今天的课程将讨论第一个问题，

762
00:34:02,360 --> 00:34:06,900
然后我们将在接下来的课程中讨论第二个问题。

763
00:34:10,140 --> 00:34:10,540
好的。

764
00:34:11,190 --> 00:34:13,415
所以，这里可以分为三层，

765
00:34:13,415 --> 00:34:16,270
关于磁盘页面上的数据是什么样子的。

766
00:34:18,030 --> 00:34:18,970
所以第一个问题是，

767
00:34:19,320 --> 00:34:20,950
这些文件实际上是什么样子的，

768
00:34:22,620 --> 00:34:24,950
然后在一个文件中，有页面，

769
00:34:25,000 --> 00:34:27,230
因为我们需要将它分成不同的块，

770
00:34:27,370 --> 00:34:29,630
然后我们将讨论这些页面的样子，

771
00:34:30,100 --> 00:34:32,120
然后在页面中，我们将拥有 tuple ，

772
00:34:32,290 --> 00:34:34,040
数据本身，也就是表，

773
00:34:35,020 --> 00:34:36,350
我们现在可以忽略索引，

774
00:34:36,790 --> 00:34:39,440
并且你必须确定 tuple 是什么样子的。

775
00:34:39,790 --> 00:34:43,790
所以从顶部开始，然后深入到这些文件的内部，

776
00:34:43,990 --> 00:34:46,040
以了解它们实际包含的内容。

777
00:34:48,790 --> 00:34:49,545
正如我前面所说的，

778
00:34:49,545 --> 00:34:53,120
数据库系统将数据库作为磁盘上的一个或多个文件进行维护，

779
00:34:53,260 --> 00:34:55,970
SQLite, DuckDB ，这些都是单文件数据库，

780
00:34:56,260 --> 00:34:58,650
所有企业数据库或 Postgres MySQL ，

781
00:34:58,650 --> 00:35:01,130
每个其他功能更全的系统，

782
00:35:01,630 --> 00:35:06,740
都运行，为你的表和数据库维护多个文件。

783
00:35:07,810 --> 00:35:14,440
所以，这些文件基于的格式通常是，

784
00:35:14,440 --> 00:35:18,990
数据库系统的专有或定制格式，

785
00:35:18,990 --> 00:35:21,830
这意味着你不能使用 Postgres 数据库文件，

786
00:35:22,210 --> 00:35:24,140
然后在 MySQL 中打开它们，

787
00:35:24,340 --> 00:35:25,640
或者在 SQLite 中打开它们。

788
00:35:25,900 --> 00:35:30,030
现在 DuckDB ，因为他们想要可移植并与 SQLite 兼容，

789
00:35:30,030 --> 00:35:33,320
他们有连接器，你可以读取 SQLite 文件和其他东西，

790
00:35:33,760 --> 00:35:37,250
但总的来说，所有主要的数据库系统都拥有自己的专有格式。

791
00:35:38,070 --> 00:35:40,360
操作系统不知道这些文件中有什么，

792
00:35:40,740 --> 00:35:41,885
不知道页面中有什么，

793
00:35:41,885 --> 00:35:43,625
也不知道索引和表在哪里，

794
00:35:43,625 --> 00:35:45,040
它什么都不知道，只看到一堆文件。

795
00:35:46,330 --> 00:35:48,560
下一节课我们将讨论可移植文件格式，

796
00:35:48,820 --> 00:35:51,380
比如 Parquet, Avro, ORC, Arrow ，

797
00:35:51,790 --> 00:35:57,470
这些将是数据库文件样子的开放源码规范，

798
00:35:57,910 --> 00:35:59,115
然后有一堆数据库系统，

799
00:35:59,115 --> 00:36:01,730
知道如何读取、访问和写入它们。

800
00:36:03,050 --> 00:36:03,930
但我们以后会讨论这些。

801
00:36:04,950 --> 00:36:05,830
就像我之前说的，

802
00:36:06,240 --> 00:36:11,075
在 1980 年代，有很多早期的数据库系统决定，

803
00:36:11,075 --> 00:36:14,590
他们不仅会有定制的文件格式，

804
00:36:15,210 --> 00:36:17,020
他们还会有定制的文件系统，

805
00:36:17,550 --> 00:36:20,860
他们不会使用， ext3 不存在，

806
00:36:20,880 --> 00:36:22,745
btrfs 当时还不存在，

807
00:36:22,745 --> 00:36:24,490
但他们，无论 80 年代的设备是什么，

808
00:36:24,570 --> 00:36:27,400
他们甚至不依赖于操作系统所说的文件系统是什么，

809
00:36:27,840 --> 00:36:29,200
他们想要自己做所有的事情。

810
00:36:29,760 --> 00:36:31,295
但这是大量的工程工作，

811
00:36:31,295 --> 00:36:32,615
而且今天没有人这样做。

812
00:36:32,615 --> 00:36:34,630
而且这通常是一种边际收益。

813
00:36:35,880 --> 00:36:37,205
唯一仍能做到这一点的系统，

814
00:36:37,205 --> 00:36:38,830
应该是我称之为企业系统的系统，

815
00:36:39,150 --> 00:36:42,100
这个有 Oracle DB2 Teradata ，

816
00:36:42,360 --> 00:36:43,910
这些是数百万美元的数据库系统，

817
00:36:43,910 --> 00:36:46,300
它们试图获得尽可能多的性能，

818
00:36:47,430 --> 00:36:48,820
这些系统还支持这个，

819
00:36:48,990 --> 00:36:52,510
除了运行通用操作系统文件系统，

820
00:36:57,740 --> 00:37:00,385
然后，数据库系统中的部分，

821
00:37:00,385 --> 00:37:03,960
负责维护和协调这些不同文件（的部分），

822
00:37:04,160 --> 00:37:06,270
我们通常称为存储管理器，

823
00:37:08,135 --> 00:37:09,070
有时它被称为存储引擎，

824
00:37:10,175 --> 00:37:10,840
这是同样的想法。

825
00:37:11,650 --> 00:37:13,695
它将成为系统的一部分，

826
00:37:13,695 --> 00:37:16,820
与硬件通信，

827
00:37:17,410 --> 00:37:21,015
或与硬件或任何存储设备通信，

828
00:37:21,015 --> 00:37:23,870
通过操作系统或使用直接访问，

829
00:37:24,460 --> 00:37:30,350
来检索数据，并将其带入数据库系统的内存。

830
00:37:31,430 --> 00:37:32,815
所以我们将在下一节课讨论这个，

831
00:37:32,815 --> 00:37:33,475
我一直这么说，

832
00:37:33,475 --> 00:37:34,890
但有太多的事情要讨论。

833
00:37:36,080 --> 00:37:40,410
许多这样的系统将维护它们自己的磁盘调度器，

834
00:37:40,640 --> 00:37:43,500
以决定何时读取哪些页面以及读取的顺序，

835
00:37:44,300 --> 00:37:46,690
否则，如果你去对操作系统做更多的努力，

836
00:37:46,690 --> 00:37:48,300
操作系统会找到如何排序的方法，

837
00:37:48,620 --> 00:37:50,710
但是，再次，数据库系统是更好的地方，

838
00:37:50,710 --> 00:37:53,280
了解它需要什么，以及以什么顺序，

839
00:37:54,710 --> 00:37:57,220
所以，各种系统可以有它们自己的线程，

840
00:37:57,220 --> 00:37:58,980
决定如何调度它们自己的磁盘读取。

841
00:37:59,600 --> 00:38:00,400
你想这样做，

842
00:38:00,400 --> 00:38:02,770
是因为你想要最大限度地减少颠簸的次数，

843
00:38:02,770 --> 00:38:05,010
把东西带入内存，以及如何丢弃它。

844
00:38:05,300 --> 00:38:07,170
如果两个查询需要相同的页面，

845
00:38:07,640 --> 00:38:10,050
你可能会先将其放在其他页面之前，

846
00:38:10,580 --> 00:38:14,070
然后你丢弃第一个页面，在知道这两个查询完成后。

847
00:38:15,870 --> 00:38:18,610
所以数据库文件将被分解成所谓的页面，

848
00:38:19,580 --> 00:38:22,300
数据系统负责跟踪，

849
00:38:22,890 --> 00:38:26,110
哪些数据已被读取和写入这些不同的页面，

850
00:38:27,690 --> 00:38:30,070
然后跟踪每个页面中有多少可用空间。

851
00:38:30,830 --> 00:38:33,660
因为，如果我插入一个新的 tuple ，

852
00:38:33,860 --> 00:38:35,700
我需要找到一个有空间的页面，

853
00:38:35,960 --> 00:38:37,465
所以，我将跟踪某个目录，

854
00:38:37,465 --> 00:38:39,990
显示这个页面有空间，然后将其放入其中。

855
00:38:41,590 --> 00:38:44,840
现在，数据系统本身，存储管理器层，

856
00:38:45,100 --> 00:38:46,160
也就是我们在这里讨论的部分，

857
00:38:46,390 --> 00:38:51,590
不会出于冗余复制的目的维护这些页面的多个副本，

858
00:38:52,120 --> 00:38:57,200
我们假设这将在堆栈中系统的这一部分的上方和下方发生，

859
00:38:57,670 --> 00:38:59,270
所以，上面就像是某种东西，

860
00:39:00,340 --> 00:39:02,810
它知道查询是否出现并想要进行写入，

861
00:39:03,040 --> 00:39:05,610
将其发送到另一个物理盒子或另一个节点，

862
00:39:05,610 --> 00:39:07,280
并让这两台机器都正确地执行写入。

863
00:39:07,800 --> 00:39:08,910
然后在下面，它就像是，

864
00:39:08,910 --> 00:39:12,500
如果你运行的是 RAID 或某种知道如何复制页面的存储设备，

865
00:39:12,790 --> 00:39:14,660
然后在下面，它也会这样做。

866
00:39:15,250 --> 00:39:18,045
通常，数据库系统本身不会维护多个副本，

867
00:39:18,045 --> 00:39:19,370
因为这是一大堆额外的工作，

868
00:39:20,490 --> 00:39:22,420
理想情况下，你不会想这么做。

869
00:39:25,300 --> 00:39:26,060
那么，什么是页面呢，

870
00:39:26,590 --> 00:39:28,380
在我们看来，从数据的角度来看，

871
00:39:28,380 --> 00:39:30,590
页面是一个固定大小的数据块，

872
00:39:32,080 --> 00:39:35,570
它可以包含来自数据库本身任何部分的数据，

873
00:39:35,980 --> 00:39:39,200
对于这节课，我们假设它只有 tuple 或记录，

874
00:39:39,760 --> 00:39:45,890
但它可以包含索引，日志信息，附加元数据，目录统计，

875
00:39:45,940 --> 00:39:46,700
这无关紧要，

876
00:39:47,590 --> 00:39:51,000
但它仍然会被分解成这些固定大小的块。

877
00:39:52,150 --> 00:39:54,140
大多数系统不会混合页面类型，

878
00:39:54,580 --> 00:39:57,030
这意味着你不会使用 1 兆字节，

879
00:39:57,030 --> 00:40:01,520
放入这个表和索引等内容的数据，

880
00:40:02,440 --> 00:40:07,070
为了简单起见，你将假设一个页面属于数据库中的某个对象，

881
00:40:07,540 --> 00:40:09,080
表或索引等，

882
00:40:09,280 --> 00:40:11,630
并且它只包含特定对象的数据。

883
00:40:13,540 --> 00:40:16,010
一些系统将要求每个页面都是自包含的，

884
00:40:16,360 --> 00:40:19,410
这意味着所有信息、所有元数据，

885
00:40:19,410 --> 00:40:21,440
以便理解页面内部的内容，

886
00:40:21,730 --> 00:40:23,240
都必须包含在页面中。

887
00:40:24,250 --> 00:40:27,105
Oracle 可能是做这个的最著名的公司，

888
00:40:27,105 --> 00:40:29,325
所以，在一个页面中，你必须跟踪，

889
00:40:29,325 --> 00:40:33,320
它属于这个表，以及具有这些类型的列等。

890
00:40:34,320 --> 00:40:36,130
他们这样做的原因是，

891
00:40:36,600 --> 00:40:40,180
如果数据库文件中有一些损坏，

892
00:40:41,040 --> 00:40:45,755
你不希望包含有关表的元数据的某个页面丢失，

893
00:40:45,755 --> 00:40:50,130
然后现在你无法理解任何其他页面中的内容。

894
00:40:51,020 --> 00:40:53,250
复制可以解决这个问题，

895
00:40:53,390 --> 00:40:57,570
硬件在现代肯定比以前可靠得多，

896
00:40:57,950 --> 00:41:00,210
比如硬盘驱动器，以前超级脆弱，

897
00:41:00,590 --> 00:41:04,050
它们仍然不理想，但它们比过去好多了。

898
00:41:04,430 --> 00:41:08,550
所以，让每个页面都自包含在今天可能不是什么问题，

899
00:41:09,800 --> 00:41:13,050
但这是 Oracle 很早就做出的设计选择。

900
00:41:14,940 --> 00:41:17,950
现在，我们的数据库文件中的每一页都将被赋予一个唯一的标识符，

901
00:41:18,720 --> 00:41:19,845
比如 page ID ，

902
00:41:19,845 --> 00:41:23,030
一些 64 位整数或 32 位整数，

903
00:41:23,830 --> 00:41:27,410
然后，数据库系统将使用某种方法或某种机制，

904
00:41:27,820 --> 00:41:33,080
将 page ID 映射到存储设备上的某个物理位置，

905
00:41:33,490 --> 00:41:37,130
这可能是某个偏移量上一个目录中的文件名，

906
00:41:37,480 --> 00:41:38,970
如果我们在云存储上运行，

907
00:41:38,970 --> 00:41:42,970
它可能是一个 S3 桶，在某个偏移量等。

908
00:41:43,290 --> 00:41:44,375
出于这个目的，这并不重要，

909
00:41:44,375 --> 00:41:45,545
我们只是有一种方法可以说，

910
00:41:45,545 --> 00:41:47,170
如果我们看第一页、第二页、第三页，

911
00:41:47,490 --> 00:41:49,510
有一些方法可以说，这是找到它的地方。

912
00:41:52,830 --> 00:41:56,290
所以现在常量数据库中令人困惑的是，

913
00:41:56,370 --> 00:41:58,450
对于页面的实际是什么，有三种不同的概念。

914
00:42:00,120 --> 00:42:02,440
所以在最低层，你有一个所谓的硬件页面，

915
00:42:04,220 --> 00:42:05,790
这通常是 4 千字节，

916
00:42:06,870 --> 00:42:08,410
而这将是，

917
00:42:10,490 --> 00:42:16,740
最大尺寸的数据块，

918
00:42:17,180 --> 00:42:19,860
硬件可以保证其具有原子写入，

919
00:42:21,660 --> 00:42:22,445
那么我是什么意思，

920
00:42:22,445 --> 00:42:23,380
我所说的原子写入是什么意思？

921
00:42:27,360 --> 00:42:28,715
他说，全部或没有，正确，

922
00:42:28,715 --> 00:42:29,500
所以，这意味着，

923
00:42:29,970 --> 00:42:32,800
如果我告诉硬件我要写入 4 千字节，

924
00:42:33,240 --> 00:42:36,190
然后我得到确认，是的，我写入了 4 千字节，

925
00:42:36,420 --> 00:42:38,230
那么，我就可以假设它成功了，

926
00:42:38,610 --> 00:42:40,390
如果我需要写入 8 千字节，

927
00:42:41,580 --> 00:42:45,820
然后我将其作为两个 4 千字节块向下发送到硬件，

928
00:42:46,590 --> 00:42:48,350
我可能会写入前 4 千字节，

929
00:42:48,350 --> 00:42:50,600
然后崩溃，然后回来，

930
00:42:50,600 --> 00:42:53,740
然后，第二个 4 千字节没有成功，

931
00:42:54,430 --> 00:42:57,860
硬件不能保证我能在那里以原子方式做到，

932
00:42:58,000 --> 00:42:58,670
全部或没有。

933
00:42:59,430 --> 00:43:00,515
正因为如此，

934
00:43:00,515 --> 00:43:04,240
我们不得不在数据库系统中做很多其他额外的工作来处理这个，

935
00:43:05,895 --> 00:43:06,500
我们稍后再谈这个。

936
00:43:07,430 --> 00:43:09,040
然后在硬件上面，

937
00:43:09,040 --> 00:43:12,330
操作系统拥有自己的页面概念，

938
00:43:13,170 --> 00:43:15,340
在 Linux 中，默认情况下，这是 4 千字节，

939
00:43:16,620 --> 00:43:21,130
这就像是将硬件上的东西映射到虚拟内存中的东西，

940
00:43:22,200 --> 00:43:26,660
现在，在 x64 中，它们也支持两种不同的模式，

941
00:43:26,660 --> 00:43:28,840
或者所谓的大页面，

942
00:43:29,190 --> 00:43:31,810
所以你可以得到页面大小，是 2MB 和 1GB ，

943
00:43:31,830 --> 00:43:36,200
同样，硬件不能保证它原子地写入超过 4 千字节，

944
00:43:36,280 --> 00:43:39,110
只是为了减少操作系统所做的[记录量]，

945
00:43:39,700 --> 00:43:41,540
对于从内存中借来的页面。

946
00:43:43,160 --> 00:43:45,180
然后，在它的上面，

947
00:43:45,590 --> 00:43:49,470
数据库系统也有自己的页面概念，

948
00:43:50,540 --> 00:43:55,290
通常，这将是 512 字节范围，

949
00:43:55,460 --> 00:43:56,520
这是 SQLite 所做的，

950
00:43:56,810 --> 00:43:58,570
向上到，我想是 32 千字节，

951
00:43:58,570 --> 00:44:01,650
有些系统最高可达 64 千字节。

952
00:44:02,630 --> 00:44:06,150
页面大小是我们表示的方式，

953
00:44:06,380 --> 00:44:07,110
在哪里找到，

954
00:44:08,630 --> 00:44:10,650
抱歉， page ID 是一种表示方式，

955
00:44:12,030 --> 00:44:16,090
对于给定的页面大小，在某个文件中的偏移量，

956
00:44:16,440 --> 00:44:18,580
我们可以找到我们要查找的数据。

957
00:44:19,780 --> 00:44:20,460
所以，好的，这里是说，

958
00:44:20,460 --> 00:44:22,910
大多数系统的默认大小是 4 千字节，

959
00:44:23,770 --> 00:44:27,470
在 SQL Server 和 Postgres 中，页面大小是 8 千字节，

960
00:44:27,790 --> 00:44:31,070
然后在 MySQL 中，它们会上升到 16 千字节，

961
00:44:31,270 --> 00:44:33,140
对于 DB2 和企业之类的东西，

962
00:44:33,160 --> 00:44:35,790
实际上对于 DB2 ，在每个表上，

963
00:44:35,790 --> 00:44:37,490
你可以更改页面大小。

964
00:44:39,700 --> 00:44:40,520
我猜一猜，

965
00:44:40,810 --> 00:44:41,670
有没有人猜一猜，

966
00:44:41,670 --> 00:44:43,590
为什么一个更大的页面尺寸，

967
00:44:43,590 --> 00:44:44,510
可能是一个更好的想法？

968
00:44:48,700 --> 00:44:49,640
我一开始是怎么说的，

969
00:44:49,660 --> 00:44:50,810
我们想要最大化的是什么？

970
00:44:51,580 --> 00:44:52,660
顺序访问，正确，是的。

971
00:44:52,660 --> 00:44:58,530
所以，如果我在磁盘上组织 16 千字节的块，

972
00:44:59,480 --> 00:45:01,810
我需要读取 16 千字节的数据，

973
00:45:02,490 --> 00:45:08,860
然后这是在数据库系统中我们的调度器进行一次调用，

974
00:45:09,060 --> 00:45:13,420
对操作系统进行一次调用，以获取连续的 16 千字节，

975
00:45:14,320 --> 00:45:15,690
如果我使用 4 千字节的页面，

976
00:45:15,690 --> 00:45:19,500
那么我必须进行单独的调用或进行单独的查找，

977
00:45:19,500 --> 00:45:21,620
以便在可能随机的位置获取数据。

978
00:45:23,170 --> 00:45:27,680
你可以对操作系统和设备本身进行一些系统调用，

979
00:45:27,820 --> 00:45:31,860
当你分配你想要连续排列的数据时，

980
00:45:31,860 --> 00:45:33,315
你可以预分配一个数据区，

981
00:45:33,315 --> 00:45:36,770
比如给我分配一个 10 兆字节的数据块，

982
00:45:37,060 --> 00:45:40,730
然后数据库系统可以把这 10 兆字节的数据块分成，

983
00:45:41,290 --> 00:45:44,300
8 千字节块或任何它想要的块大小。

984
00:45:44,320 --> 00:45:44,720
是的。

985
00:45:49,240 --> 00:45:50,640
好的，他说的，他是对的，

986
00:45:51,320 --> 00:45:54,120
这难道不意味着大页面会让写入变得更昂贵吗，

987
00:45:54,140 --> 00:45:56,430
因为现在，如果我只需要写入 1 千字节，

988
00:45:56,450 --> 00:45:58,090
但我存储为 16 千字节页，

989
00:45:58,090 --> 00:45:59,490
我就必须全部写入 16 千字节，

990
00:45:59,810 --> 00:46:00,420
绝对是，

991
00:46:00,620 --> 00:46:01,620
所以这是一个很好的观点，

992
00:46:01,880 --> 00:46:03,870
这是我整个学期都会说的话，

993
00:46:04,370 --> 00:46:06,985
我的意思是那不只是对于数据库，

994
00:46:06,985 --> 00:46:08,850
对于一般的计算机科学，天下没有免费的午餐，

995
00:46:09,140 --> 00:46:11,320
每一种都有利弊，

996
00:46:11,320 --> 00:46:14,430
不同情况下，一种方法可能比另一种更好，

997
00:46:14,940 --> 00:46:16,650
如果我的工作负载完全是只读的，

998
00:46:16,650 --> 00:46:17,900
只要我从来不写任何东西，

999
00:46:17,920 --> 00:46:19,250
那么，是的，我想要大的页面大小，

1000
00:46:19,390 --> 00:46:20,990
假设我进行大的顺序扫描，

1001
00:46:21,310 --> 00:46:23,600
如果我写入很多次，也许我想要更小的东西，

1002
00:46:23,860 --> 00:46:26,460
取决于写入的数量是多少。

1003
00:46:46,110 --> 00:46:46,510
是的，所以他的说法是，

1004
00:46:47,900 --> 00:46:49,620
如果我做 16 千字节的读取，

1005
00:46:49,790 --> 00:46:51,990
我仍然使用 4 千字节的数据，

1006
00:46:52,670 --> 00:46:54,630
假设 16 千字节是连续的，

1007
00:46:55,300 --> 00:46:59,425
那么我能不能一个调用，

1008
00:46:59,425 --> 00:47:00,870
来获得连续的 16 千字节，

1009
00:47:01,250 --> 00:47:04,510
然后，如果我在 4 千字节中有写入，

1010
00:47:04,510 --> 00:47:05,280
我还可以把它们写出，

1011
00:47:05,570 --> 00:47:06,180
绝对是的，

1012
00:47:06,350 --> 00:47:07,240
这就是我之前所说的，

1013
00:47:07,240 --> 00:47:09,025
然后，我们将选择算法或方法，

1014
00:47:09,025 --> 00:47:10,920
尝试写出该数据，

1015
00:47:12,140 --> 00:47:13,210
它是连续的，

1016
00:47:13,210 --> 00:47:15,820
我们就可以进行这些获取。

1017
00:47:16,710 --> 00:47:18,950
同样，这是数据库系统可以为我们做的事情，

1018
00:47:18,950 --> 00:47:20,240
因为我们知道查询是什么，

1019
00:47:20,240 --> 00:47:21,880
我们知道你可能要读取的数据，

1020
00:47:22,080 --> 00:47:23,345
所以我们可以为你提前读取，

1021
00:47:23,345 --> 00:47:26,950
尝试在你实际需要之前获取它们。

1022
00:47:27,330 --> 00:47:29,680
操作系统也可以使用预先获取来实现这个，

1023
00:47:30,060 --> 00:47:31,990
但它只能预取连续的内容，

1024
00:47:33,210 --> 00:47:34,990
我想是在两个方向上，在 Linux 中，是的，

1025
00:47:35,100 --> 00:47:38,390
但是它不能，如果我必须预先获取不连续的东西，

1026
00:47:38,390 --> 00:47:39,340
它不能为我做到这个。

1027
00:47:42,580 --> 00:47:43,170
所以，这个很清楚。

1028
00:47:43,170 --> 00:47:44,390
这里还有一些 page ID ，

1029
00:47:44,740 --> 00:47:45,615
我们马上就会看到，

1030
00:47:45,615 --> 00:47:46,460
它是如何被使用的，

1031
00:47:46,690 --> 00:47:49,820
这将允许我们，第 103 页，

1032
00:47:49,930 --> 00:47:50,930
这里是找到它的地方。

1033
00:47:54,630 --> 00:47:57,120
好的，所以，现在，我们必须讨论，

1034
00:47:57,120 --> 00:48:01,400
如何跟踪 page ID 到位置的映射，

1035
00:48:02,170 --> 00:48:05,600
这将最大区别之一，

1036
00:48:05,620 --> 00:48:08,660
数据库系统如何组织页面。

1037
00:48:10,120 --> 00:48:12,620
再说一次，我不是说一种方式比另一种方式更好。

1038
00:48:12,880 --> 00:48:15,740
我将描述，堆文件方法是最常见的方法，

1039
00:48:16,960 --> 00:48:19,370
但当然还有许多其他系统在做不同的事情，

1040
00:48:20,630 --> 00:48:21,900
所有这些都需要权衡取舍。

1041
00:48:23,190 --> 00:48:24,875
所以，在这一点上，

1042
00:48:24,875 --> 00:48:25,810
我们正在讨论的地方，

1043
00:48:26,100 --> 00:48:28,000
我们不需要知道任何关于我们的页面内部的内容，

1044
00:48:28,200 --> 00:48:30,610
比如，我们不关心它是索引还是 tuple ，

1045
00:48:30,810 --> 00:48:31,610
我们只需要知道，

1046
00:48:31,610 --> 00:48:34,070
对于给定的页面，我如何找到它，

1047
00:48:34,070 --> 00:48:35,920
以及如何跟踪我实际拥有的页面。

1048
00:48:37,430 --> 00:48:38,970
所以树文件基本上就是，

1049
00:48:39,020 --> 00:48:42,290
你存储，你可以存储，

1050
00:48:43,000 --> 00:48:45,260
在叶节点中，你可以存储页面本身，

1051
00:48:45,700 --> 00:48:47,000
或者你也可以有哈希表。

1052
00:48:47,380 --> 00:48:50,390
ISAM 或按顺序排序文件，

1053
00:48:50,770 --> 00:48:52,520
这是 70 年代的东西，

1054
00:48:52,720 --> 00:48:54,470
MySQL 默认这样做，

1055
00:48:54,610 --> 00:48:56,060
这不再那么常见了，

1056
00:48:56,290 --> 00:48:58,280
但这也是另一种跟踪事物的方式。

1057
00:48:58,300 --> 00:49:00,950
然后哈希表文件使用哈希表来查找。

1058
00:49:01,000 --> 00:49:02,720
堆文件是最常见的一种，

1059
00:49:03,910 --> 00:49:05,570
但是这些其他方法是存在的。

1060
00:49:06,010 --> 00:49:07,365
然后对于日志结构的内容，

1061
00:49:07,365 --> 00:49:08,270
我们将在下一节课看到。

1062
00:49:12,700 --> 00:49:14,660
目录是在跟踪，

1063
00:49:14,710 --> 00:49:17,150
你仍然想要跟踪东西在哪里，

1064
00:49:18,070 --> 00:49:20,570
因为我们不在乎页面里有什么。

1065
00:49:22,840 --> 00:49:26,660
好的，所以，堆文件是一个无序页面的集合，

1066
00:49:27,580 --> 00:49:29,120
我们的 tuple 将以随机顺序存储，

1067
00:49:29,290 --> 00:49:31,220
关系模型允许我们这样做，

1068
00:49:31,240 --> 00:49:34,020
因为关系模型没有定义，

1069
00:49:34,020 --> 00:49:36,980
数据不必指定确切的顺序，

1070
00:49:37,700 --> 00:49:39,240
一些系统可能会为它们预先排序，

1071
00:49:39,950 --> 00:49:42,280
以使操作更快，为了其他效果，

1072
00:49:42,280 --> 00:49:45,330
但关系模型不要求你这样做。

1073
00:49:46,250 --> 00:49:51,355
所以，我们的存储管理器中支持堆文件的唯一 API 基本上是，

1074
00:49:51,355 --> 00:49:55,680
创建页面、获取页面、写入页面、删除页面，

1075
00:49:56,060 --> 00:49:58,195
然后是一个迭代的 API ，

1076
00:49:58,195 --> 00:50:00,990
允许按顺序读取页面，

1077
00:50:01,580 --> 00:50:03,415
以获得我们拥有的所有 page ID 的列表，

1078
00:50:03,415 --> 00:50:04,230
并对它们进行读取。

1079
00:50:05,410 --> 00:50:09,050
所以，管理这个堆文件是很容易的，

1080
00:50:09,310 --> 00:50:10,875
如果你的数据库是单个文件，

1081
00:50:10,875 --> 00:50:14,755
比如在 DuckDB 中或在 SQLite 中。

1082
00:50:14,755 --> 00:50:17,545
因为要找到给定的页面，

1083
00:50:17,545 --> 00:50:19,140
只需知道页面编号是多少，

1084
00:50:19,520 --> 00:50:21,085
你知道页面的大小，

1085
00:50:21,085 --> 00:50:22,350
因为它们都必须是相同的大小，

1086
00:50:22,850 --> 00:50:24,310
现在你只需要做一个简单的算术运算，

1087
00:50:24,310 --> 00:50:26,730
比如取我要找的任何 ID ，

1088
00:50:27,080 --> 00:50:29,610
乘以页面的大小，

1089
00:50:29,900 --> 00:50:32,070
然后我就可以跳到文件中的任何偏移量，

1090
00:50:32,830 --> 00:50:34,160
我很清楚我在找什么。

1091
00:50:36,470 --> 00:50:38,590
如果你去看 SQLite 的文档，

1092
00:50:38,590 --> 00:50:39,870
他们谈到，

1093
00:50:40,520 --> 00:50:42,900
在他们的数据文件的头部中，

1094
00:50:43,010 --> 00:50:46,650
他们跟踪的所有元数据都使用了这个技巧。

1095
00:50:48,570 --> 00:50:49,730
问题变得棘手的是，

1096
00:50:49,730 --> 00:50:50,585
如果你有多个文件，

1097
00:50:50,585 --> 00:50:52,010
大多数系统都是，

1098
00:50:52,010 --> 00:50:53,680
Postgres 是， MySQL 是， Oracle 是。

1099
00:50:54,360 --> 00:50:55,850
然后现在我们需要一种方法来说明，

1100
00:50:56,110 --> 00:50:57,350
对于给定的第二页，

1101
00:50:57,910 --> 00:51:07,640
什么目录，什么文件，什么偏移量有我需要的页面。

1102
00:51:07,960 --> 00:51:10,400
这就是堆文件页目录可以为我们获得的，

1103
00:51:10,510 --> 00:51:12,080
把它想象成一个哈希表，

1104
00:51:12,700 --> 00:51:13,815
你只是在跟踪，

1105
00:51:13,815 --> 00:51:17,990
它是从 page ID 到数据文件中的页面的映射。

1106
00:51:18,850 --> 00:51:21,390
这通常是一种特殊的文件，

1107
00:51:21,390 --> 00:51:24,110
你有单个数据库文件的头部，

1108
00:51:24,250 --> 00:51:28,250
或者位于数据库系统和目录内的某个特殊位置。

1109
00:51:28,780 --> 00:51:30,195
你可以把它想象成一个数据库，

1110
00:51:30,195 --> 00:51:33,290
它是数据库跟踪数据库中的内容，

1111
00:51:35,080 --> 00:51:36,375
目录也是其中的一部分，

1112
00:51:36,375 --> 00:51:38,720
但这就像是跟踪物理位置的东西。

1113
00:51:39,690 --> 00:51:44,060
所以，这必须与磁盘上的实际文件保持同步，

1114
00:51:44,060 --> 00:51:46,150
因为我不想创建一堆页面，

1115
00:51:46,590 --> 00:51:48,100
没有更新我的页面目录，

1116
00:51:48,300 --> 00:51:49,340
我崩溃了，然后又回来，

1117
00:51:49,340 --> 00:51:51,730
现在我的页面目录不知道这些其他页面，

1118
00:51:52,260 --> 00:51:54,640
我也不能访问它们。

1119
00:51:54,640 --> 00:51:56,560
所以，我们必须采取一系列额外的技巧，

1120
00:51:56,560 --> 00:51:59,370
为了确保这些东西保持同步。

1121
00:52:00,200 --> 00:52:02,310
好的，所以考虑我有一大堆页面，

1122
00:52:02,390 --> 00:52:05,400
它们在某个位置，一堆文件，在哪里并不重要，

1123
00:52:05,870 --> 00:52:07,450
然后它只是一个映射，

1124
00:52:07,450 --> 00:52:08,550
告诉我去哪里找它。

1125
00:52:09,640 --> 00:52:11,145
我们跟踪的其他元数据，

1126
00:52:11,145 --> 00:52:14,210
比如每一个页面，我们可以跟踪一个重要的位置，

1127
00:52:14,500 --> 00:52:16,160
它们实际拥有的空闲空间的数量，

1128
00:52:16,390 --> 00:52:17,780
或者他们拥有的空闲空间，

1129
00:52:18,130 --> 00:52:19,970
现在，如果我想要插入一个 tuple ，

1130
00:52:20,230 --> 00:52:21,740
我必须找到一个页面来放入它，

1131
00:52:21,850 --> 00:52:22,980
我不想必须扫描所有的页面，

1132
00:52:22,980 --> 00:52:24,230
并计算出谁有空闲空间，

1133
00:52:24,730 --> 00:52:27,520
我的页面目录会告诉我这个。

1134
00:52:28,810 --> 00:52:30,260
然后，如果我用完了页面，

1135
00:52:30,400 --> 00:52:31,425
我知道如何分配它们，

1136
00:52:31,425 --> 00:52:33,440
然后更新我的页面目录以指出这里。

1137
00:52:35,820 --> 00:52:38,570
只是想想一个写入磁盘的哈希表，

1138
00:52:38,570 --> 00:52:39,790
它跟踪我拥有的页面，

1139
00:52:39,870 --> 00:52:42,400
但我也可以迭代或扫描，然后说，

1140
00:52:42,570 --> 00:52:44,510
这是第一页，这是第二页，这是第三页，

1141
00:52:44,510 --> 00:52:45,340
因为我们需要这个，

1142
00:52:45,570 --> 00:52:48,070
如果我们有一种访问方法，比如顺序扫描操作符，

1143
00:52:48,770 --> 00:52:49,630
如果我们没有索引，

1144
00:52:49,630 --> 00:52:52,410
我们需要能够迭代表中的每个 tuple 。

1145
00:52:52,940 --> 00:52:55,855
所以页面目录需要公开为那个 API 。

1146
00:52:55,855 --> 00:52:56,245
是的。

1147
00:52:56,245 --> 00:53:06,110
是的，所以他的问题是，

1148
00:53:06,430 --> 00:53:09,830
因为目录必须被带入内存才能读取，

1149
00:53:10,690 --> 00:53:12,120
它是一个非易失性内存，

1150
00:53:12,120 --> 00:53:15,000
所以现在如果我崩溃了，我不想失去它，

1151
00:53:15,000 --> 00:53:17,310
这是否意味着我对它所做的任何更改都必须写入磁盘。

1152
00:53:17,310 --> 00:53:17,600
是的。

1153
00:53:18,540 --> 00:53:21,700
但是，这并没有那么糟糕，

1154
00:53:21,870 --> 00:53:25,265
你不是一直在更新东西，

1155
00:53:25,265 --> 00:53:27,065
所以你不会，

1156
00:53:27,065 --> 00:53:29,135
如果你的数据库文件中的空间用完了，

1157
00:53:29,135 --> 00:53:30,130
并分配了更多的页面，

1158
00:53:30,510 --> 00:53:32,920
你不会只分配一个页面，

1159
00:53:33,240 --> 00:53:34,930
因为这样你就可能对每个查询执行此操作，

1160
00:53:35,100 --> 00:53:37,330
你分配 1 吉字节的数据，

1161
00:53:37,860 --> 00:53:39,845
更新写入磁盘的页面目录，

1162
00:53:39,845 --> 00:53:41,800
在确保被持久保存且安全之后，

1163
00:53:42,760 --> 00:53:44,090
然后继续运行查询。

1164
00:53:47,530 --> 00:53:50,690
是的，所以，任何对目录页面的更新必须写入磁盘，

1165
00:53:50,710 --> 00:53:51,260
完全正确，

1166
00:53:51,610 --> 00:53:53,450
因为否则你不知道你有什么。

1167
00:53:54,070 --> 00:53:54,470
是的。

1168
00:54:01,940 --> 00:54:02,530
问题是，

1169
00:54:02,530 --> 00:54:05,400
这种排序是在特殊的数据库文件中还是与其他页面一起排序，

1170
00:54:05,870 --> 00:54:06,780
你说的特殊是什么意思，

1171
00:54:07,540 --> 00:54:09,080
就像一个单独的文件，

1172
00:54:09,730 --> 00:54:11,450
是的，在某些系统中，会作为一个单独的文件，

1173
00:54:12,220 --> 00:54:14,630
SQLite 会将其存储在文件的头部中，

1174
00:54:16,320 --> 00:54:17,870
通常是单独存储。

1175
00:54:29,110 --> 00:54:29,880
所以他的问题是，

1176
00:54:29,880 --> 00:54:31,800
当我说一个数据系统可以使用多个文件时，

1177
00:54:31,800 --> 00:54:34,940
我是指在一个表中，它包含多个文件，

1178
00:54:35,020 --> 00:54:37,010
还是在数据库中，包含多个文件。

1179
00:54:38,760 --> 00:54:39,160
有人知道吗？

1180
00:54:40,200 --> 00:54:44,400
是的， DuckDB 使用一个文件，对于所有表格，

1181
00:54:44,400 --> 00:54:45,110
SQLite 也是，

1182
00:54:45,490 --> 00:54:46,125
但我的意思是，

1183
00:54:46,125 --> 00:54:48,420
我们可以弹出 Postgres 并查看数据目录，

1184
00:54:48,420 --> 00:54:49,340
里面有一堆文件，

1185
00:54:49,420 --> 00:54:50,810
里面有数字，

1186
00:54:51,300 --> 00:54:52,425
各种各样的数据文件，

1187
00:54:52,425 --> 00:54:53,685
有时是索引，

1188
00:54:53,685 --> 00:54:54,650
有时是表。

1189
00:54:56,540 --> 00:54:58,620
不同的系统做不同的事情，

1190
00:54:58,760 --> 00:55:01,200
不断地重复我自己，

1191
00:55:01,370 --> 00:55:02,970
这就是 SQL 的美妙之处，

1192
00:55:03,410 --> 00:55:04,555
我不知道，我不在乎，

1193
00:55:04,555 --> 00:55:07,230
在 MySQL 查询中，我是有一个文件还是一千个文件，

1194
00:55:08,030 --> 00:55:10,140
数据库系统可以决定如何做到，

1195
00:55:10,430 --> 00:55:12,120
它知道如何为你运行查询。

1196
00:55:12,910 --> 00:55:14,780
所以，不同的数据库系统做不同的事情。

1197
00:55:20,000 --> 00:55:20,620
他的问题是，

1198
00:55:20,620 --> 00:55:23,400
如何知道是否要为一个表使用多个文件，

1199
00:55:25,010 --> 00:55:25,975
同样，这要视情况而定，

1200
00:55:25,975 --> 00:55:30,130
所以如果我们还不讨论[大列]，

1201
00:55:30,130 --> 00:55:34,035
但是比如你有一个表，

1202
00:55:34,035 --> 00:55:37,040
它有一个 BLOB 字段或一个 TEXT 字段，

1203
00:55:37,300 --> 00:55:39,200
大约有 10 兆字节，

1204
00:55:39,820 --> 00:55:41,880
你可能希望将其存储在单独的页面中，

1205
00:55:42,410 --> 00:55:43,860
但可能需要将其压缩存储，

1206
00:55:43,880 --> 00:55:45,300
因为它是一堆文本数据，

1207
00:55:45,410 --> 00:55:48,390
所以你有常规的整型和浮点型列，

1208
00:55:48,650 --> 00:55:49,645
存储在一个文件中，

1209
00:55:49,645 --> 00:55:52,770
然后你的大件东西存储在另一个文件中。

1210
00:55:53,120 --> 00:55:54,265
所以这是一种方法，

1211
00:55:54,265 --> 00:55:55,240
但是你也可以想象，

1212
00:55:55,240 --> 00:55:58,325
也许你只是，你在一个单独的文件中有一些空间，

1213
00:55:58,325 --> 00:56:00,370
在固定[东西]的顶部，[]的底部，

1214
00:56:01,020 --> 00:56:01,580
视情况而定。

1215
00:56:04,370 --> 00:56:06,990
我想 MySQL 直到 5.6 使用存储，

1216
00:56:08,470 --> 00:56:12,475
我想它使用一个文件对于所有表或者所有数据库，

1217
00:56:12,475 --> 00:56:13,630
他们没有，

1218
00:56:13,630 --> 00:56:15,450
不，每个数据库一个文件，

1219
00:56:15,830 --> 00:56:17,760
他们把它分成一个文件，而不是每个表，

1220
00:56:19,130 --> 00:56:20,430
以及单独的对于索引的文件。

1221
00:56:24,160 --> 00:56:24,560
好的。

1222
00:56:26,060 --> 00:56:29,065
所以，现在我们大致了解了文件的外观，

1223
00:56:29,065 --> 00:56:30,415
文件的布局，

1224
00:56:30,415 --> 00:56:31,800
以及我们如何跟踪它们的存在位置。

1225
00:56:33,050 --> 00:56:35,910
所以，让我们讨论一下页面本身的内容。

1226
00:56:37,610 --> 00:56:39,360
所以每个页面都会有一个 header ，

1227
00:56:40,315 --> 00:56:44,130
这将告诉你一些关于数据实际是什么的信息。

1228
00:56:45,060 --> 00:56:50,225
所以，常见的东西应该是页面大小或校验和，

1229
00:56:50,225 --> 00:56:53,150
所以，如果你崩溃并回来或重新启动系统，

1230
00:56:53,150 --> 00:56:55,420
或者任何时候你从磁盘获取东西，

1231
00:56:55,560 --> 00:56:58,630
你都会计算快速校验和以确保数据没有损坏。

1232
00:57:00,280 --> 00:57:04,010
也许可以跟踪创建页面的数据库系统的版本，

1233
00:57:04,030 --> 00:57:06,800
你推出了一个破坏兼容性的新版本，

1234
00:57:07,150 --> 00:57:09,710
你有一些代码，知道如何读取旧数据。

1235
00:57:10,610 --> 00:57:13,090
我们不会谈论事务，直到期中考试之后，

1236
00:57:13,090 --> 00:57:14,590
但是，你可以跟踪，

1237
00:57:14,590 --> 00:57:17,965
什么线程或什么事务写到这个文件中的什么数据，

1238
00:57:17,965 --> 00:57:20,640
以及它是否对你正在运行的查询是可见的。

1239
00:57:21,700 --> 00:57:23,060
如果数据被压缩，

1240
00:57:24,090 --> 00:57:25,460
或者以某种方式进行编码，

1241
00:57:25,460 --> 00:57:26,980
我们将在下周讨论，

1242
00:57:27,210 --> 00:57:30,130
将会有关于压缩方案的实际情况的元数据。

1243
00:57:31,590 --> 00:57:35,225
为了提供关于模式是什么或表模式是什么的信息，

1244
00:57:35,225 --> 00:57:36,340
在我们讨论 Oracle 时。

1245
00:57:36,900 --> 00:57:38,380
有时还会有附加统计信息，

1246
00:57:38,820 --> 00:57:40,600
关于数据中有什么，

1247
00:57:41,100 --> 00:57:42,665
比如，对于给定列，

1248
00:57:42,665 --> 00:57:44,890
最小值和最大值是什么，

1249
00:57:45,210 --> 00:57:47,050
因为也许我只需要读取它，

1250
00:57:47,190 --> 00:57:51,840
而不是真正地读取数据来找出是否有我需要的东西。

1251
00:57:51,840 --> 00:57:52,785
正如我们已经讨论过的，

1252
00:57:52,785 --> 00:57:55,100
Oracle 以自包含而闻名，

1253
00:57:55,210 --> 00:57:56,750
但并不是所有的系统都这样做的。

1254
00:57:59,990 --> 00:58:01,320
所以，现在，在页面本身内，

1255
00:58:02,390 --> 00:58:06,620
我们需要决定我们想要如何组织 tuple 数据。

1256
00:58:07,300 --> 00:58:08,660
所以在这节课的这一点上，

1257
00:58:09,070 --> 00:58:11,270
我们将假设我们只在页面中存储 tuple ，

1258
00:58:12,100 --> 00:58:13,280
我们稍后将讨论索引，

1259
00:58:13,630 --> 00:58:16,670
然后我们将假设以面向行的方式存储 tuple ，

1260
00:58:17,710 --> 00:58:18,330
意思是，

1261
00:58:18,330 --> 00:58:21,260
如果我有五个属性，我会有一个 tuple ，

1262
00:58:21,400 --> 00:58:23,250
我会有这五个属性是连续的，

1263
00:58:23,250 --> 00:58:24,410
在我看到下一个 tuple 之前。

1264
00:58:25,170 --> 00:58:27,425
下周我们将看看列存储，

1265
00:58:27,425 --> 00:58:28,610
我们存储这个略有不同，

1266
00:58:28,610 --> 00:58:29,650
但出于我们的目的，

1267
00:58:30,630 --> 00:58:32,470
我们假设它是面向行的，

1268
00:58:32,640 --> 00:58:34,300
我们将在下周讨论这个问题。

1269
00:58:35,540 --> 00:58:36,475
所以有三种不同的方法，

1270
00:58:36,475 --> 00:58:38,160
它在我们的页面上可能是什么。

1271
00:58:38,900 --> 00:58:40,150
在面向 tuple 的存储中，

1272
00:58:40,150 --> 00:58:43,650
我们只存储 tuple 和 tuple 拥有的值。

1273
00:58:44,240 --> 00:58:45,430
这是一种日志结构方法，

1274
00:58:45,430 --> 00:58:50,760
我们只存储上次 tuple 更新以来更改的增量。

1275
00:58:51,990 --> 00:58:54,070
然后是面向索引的，

1276
00:58:54,450 --> 00:58:55,690
面向索引的存储是，

1277
00:58:57,300 --> 00:58:58,900
它类似于树结构，

1278
00:58:59,460 --> 00:59:02,140
在叶节点中，存储了数据本身。

1279
00:59:02,910 --> 00:59:05,470
所以今天的课程，我们只会讨论第一个，

1280
00:59:06,030 --> 00:59:06,850
面向 tuple 的存储，

1281
00:59:07,170 --> 00:59:09,610
下周我们会讨论另外两种方法。

1282
00:59:12,630 --> 00:59:13,580
好的，让我们考虑一下，

1283
00:59:13,580 --> 00:59:16,265
我们想要如何在我们的页面中存储 tuple 。

1284
00:59:16,265 --> 00:59:17,705
让我们假设我们有一个非常简单的方法，

1285
00:59:17,705 --> 00:59:19,580
在我们的页面 header 中，

1286
00:59:19,580 --> 00:59:22,510
我们只跟踪我们拥有的 tuple 的数量，

1287
00:59:22,950 --> 00:59:25,510
任何时候我们想插入一个新的 tuple ，

1288
00:59:26,320 --> 00:59:29,020
我们只是追加到末尾。

1289
00:59:29,400 --> 00:59:30,910
所以我们可以假设我们的数据是固定长度的，

1290
00:59:31,260 --> 00:59:32,480
所以，如果我想插入一个新的 tuple ，

1291
00:59:32,480 --> 00:59:33,700
我只需查看 header ，

1292
00:59:33,810 --> 00:59:34,810
查看 tuple 的数量，

1293
00:59:36,060 --> 00:59:38,320
乘以 tuple 的大小，

1294
00:59:38,400 --> 00:59:40,450
这就告诉我我想要写入页面的偏移量。

1295
00:59:43,935 --> 00:59:44,240
怎么了，

1296
00:59:46,310 --> 00:59:47,730
哦，苍蝇，杀了它吧，

1297
00:59:53,030 --> 00:59:54,540
有人想要它活着吗，

1298
00:59:58,970 --> 01:00:01,110
对于 Youtube 上的人，我们有苍蝇出没。

1299
01:00:02,610 --> 01:00:07,120
好的，所以，这是个好主意还是坏主意，

1300
01:00:09,320 --> 01:00:10,195
我说的是 strawman ，

1301
01:00:10,195 --> 01:00:11,245
所以这显然是个坏主意，

1302
01:00:11,245 --> 01:00:12,120
为什么这是个坏主意？

1303
01:00:17,530 --> 01:00:18,720
是的，所以如果我删除 tuple ，

1304
01:00:18,720 --> 01:00:20,570
我删除 tuple 2 ，

1305
01:00:21,190 --> 01:00:23,635
它把所有的东西都打乱了，

1306
01:00:23,635 --> 01:00:28,495
因为现在我想要做的是插入一个新的 tuple ，

1307
01:00:28,495 --> 01:00:29,410
我不会把它放在最后，

1308
01:00:29,410 --> 01:00:30,840
我想用这里的位置，

1309
01:00:31,810 --> 01:00:33,590
所以， tuple 的数量是足够的，

1310
01:00:33,790 --> 01:00:36,390
也许我会记着东西放在哪里，

1311
01:00:36,390 --> 01:00:38,210
第二方面，把它们放在哪里。

1312
01:00:38,830 --> 01:00:41,270
但是，它超出了我在这里展示的范围。

1313
01:00:42,420 --> 01:00:43,250
另一个明显的问题是什么？

1314
01:00:44,080 --> 01:00:48,720
他说，如果一个 tuple 太大，不能在页面上开始。

1315
01:00:49,400 --> 01:00:52,020
是的，但如果它们不是固定长度，

1316
01:00:52,430 --> 01:00:54,900
大多数数据都是，不是固定长度，

1317
01:00:55,630 --> 01:00:56,900
电子邮件地址大小不同，

1318
01:00:58,510 --> 01:01:00,140
Andrew ID 并不相同，几乎总是相同的大小。

1319
01:01:00,610 --> 01:01:02,040
现在我可以作为[char]类型进行排序，

1320
01:01:02,040 --> 01:01:02,670
但这会做什么，

1321
01:01:02,670 --> 01:01:04,400
预先分配我所需的空间，

1322
01:01:04,870 --> 01:01:09,290
如果最大的电子邮件地址是 1 千字节，

1323
01:01:09,310 --> 01:01:11,580
那么我必须为每个电子邮件地址存储 1 千字节，

1324
01:01:11,580 --> 01:01:14,300
即使它不会使用这个空间，

1325
01:01:14,710 --> 01:01:15,465
他的评论是，

1326
01:01:15,465 --> 01:01:18,620
如果表不能放在一个页面怎么办，

1327
01:01:19,150 --> 01:01:20,300
如何拆分到多个页面中。

1328
01:01:21,140 --> 01:01:22,175
我们下周将讨论这个，

1329
01:01:22,175 --> 01:01:24,930
但这也不会奏效。

1330
01:01:25,810 --> 01:01:27,585
所以很明显，这对我们来说是不够的，

1331
01:01:27,585 --> 01:01:29,360
我们需要额外的元数据来跟踪，

1332
01:01:31,120 --> 01:01:33,860
跟踪我们将如何存储这些内容，

1333
01:01:34,060 --> 01:01:35,145
另一个问题是，

1334
01:01:35,145 --> 01:01:38,970
如果 #4 去了这里，

1335
01:01:38,970 --> 01:01:42,290
我可以填充删除 #2 时的空隙，

1336
01:01:42,370 --> 01:01:45,470
如果 #4 要到这里（#3 下面），那我就是在浪费空间，

1337
01:01:45,820 --> 01:01:47,510
但是也许我可以把 #3 往上移，

1338
01:01:48,550 --> 01:01:52,970
但现在我必须告诉系统的其余部分，我移动了 #3 ，

1339
01:01:52,970 --> 01:01:55,480
因为我已经告诉过你们我是如何指向 #3 的，如何找到 #3 ，

1340
01:01:57,090 --> 01:02:00,310
假设这一页中会有一些偏移量，

1341
01:02:00,540 --> 01:02:01,750
但是现在如果我移动 #3 ，

1342
01:02:02,590 --> 01:02:04,545
然后我就得去更新所有可能的索引，

1343
01:02:04,545 --> 01:02:05,720
那些指向它的（索引）。

1344
01:02:06,370 --> 01:02:07,290
这将是非常昂贵的。

1345
01:02:09,910 --> 01:02:14,060
所以，处理这个问题的最常见方法称为插槽页面，

1346
01:02:14,770 --> 01:02:18,710
我在这里描述的并不是每个系统是如何做到这一点的，

1347
01:02:18,910 --> 01:02:20,805
但从更高的层面来看，这就是每个系统都在做的事情，

1348
01:02:20,805 --> 01:02:22,400
如果你是一个面向行的数据库系统，

1349
01:02:23,530 --> 01:02:26,810
它使用面向 tuple 的页面，不是日志结构，

1350
01:02:27,425 --> 01:02:28,690
然后他们在做一些看起来像这样的事情。

1351
01:02:29,870 --> 01:02:32,320
所以我们会有一个 header ，

1352
01:02:32,320 --> 01:02:34,470
跟踪我们讨论过的所有的元数据，

1353
01:02:34,850 --> 01:02:38,040
但在 header 之后，我们有这个 slot array ，

1354
01:02:38,840 --> 01:02:42,600
在 slot array 中的每个位置，

1355
01:02:42,890 --> 01:02:47,220
将指向我们页面中的一些 tuple ，

1356
01:02:48,060 --> 01:02:51,910
tuple 将从页面末尾开始，

1357
01:02:51,910 --> 01:02:54,990
所以在底部，我们会有固定长度和可变长度的 tuple 数据，

1358
01:02:55,520 --> 01:02:58,600
现在，假设一切都放在一起，

1359
01:02:58,600 --> 01:03:00,030
所以意思是，这里没有，

1360
01:03:00,110 --> 01:03:01,270
如果你有一个非常大的值，

1361
01:03:01,270 --> 01:03:02,910
它不会存储在单独的页面中，

1362
01:03:03,170 --> 01:03:05,550
整个表必须存储在这个页面中。

1363
01:03:07,420 --> 01:03:10,340
所以， slot arry 将存储固定长度的偏移量，

1364
01:03:11,020 --> 01:03:14,480
以找到单个 tuple 的起始位置，

1365
01:03:15,190 --> 01:03:17,730
也许你也可以存储 tuple 的大小和 header ，

1366
01:03:17,730 --> 01:03:20,190
如果你愿意的话。

1367
01:03:21,380 --> 01:03:22,590
所以现在要发生的事情是，

1368
01:03:22,730 --> 01:03:26,720
我们需要更新表，

1369
01:03:27,040 --> 01:03:28,010
并添加新页面，

1370
01:03:28,570 --> 01:03:30,500
抱歉，在页面内添加新的 tuple ，

1371
01:03:30,880 --> 01:03:33,770
slot array 将从头到尾增长，

1372
01:03:34,560 --> 01:03:38,180
然后我们所有的 tuple 数据都将从尾到头增长。

1373
01:03:39,430 --> 01:03:43,760
每当我添加新的 tuple 时，对于我的 slot array ，

1374
01:03:43,780 --> 01:03:47,070
我都会更新 slot array ，

1375
01:03:47,070 --> 01:03:49,250
告诉我在哪里可以找到它。

1376
01:03:50,920 --> 01:03:52,365
现在回到我之前的问题，

1377
01:03:52,365 --> 01:03:53,900
我说我删除了 tuple #3 ，

1378
01:03:55,570 --> 01:03:57,045
好的，这是可以的，

1379
01:03:57,045 --> 01:03:59,540
因为我没有移动任何其他 tuple ，

1380
01:04:00,340 --> 01:04:03,180
slot array 的 #4 仍然指向它，

1381
01:04:03,410 --> 01:04:06,980
所以我不用告诉系统的任何其他部分，我移动了 #4 。

1382
01:04:07,360 --> 01:04:10,425
但是，如果我现在想要收回这个空间，

1383
01:04:10,425 --> 01:04:13,760
#3 曾经拥有的，我删除了的，

1384
01:04:13,900 --> 01:04:18,350
如果我想把 #4 滑动到，压缩它，

1385
01:04:19,510 --> 01:04:20,865
他们现在需要做的就是，

1386
01:04:20,865 --> 01:04:22,760
更新 slot array ，指向新的偏移量，

1387
01:04:24,580 --> 01:04:25,520
这很容易做到，

1388
01:04:27,430 --> 01:04:28,290
我没必要这么做，

1389
01:04:28,290 --> 01:04:29,780
关系模型说他们不必这样做，

1390
01:04:29,950 --> 01:04:31,590
有些系统做了，有些系统没有，

1391
01:04:31,590 --> 01:04:33,110
我们很快就会看到这一点，

1392
01:04:33,860 --> 01:04:34,800
这一切都很好。

1393
01:04:37,220 --> 01:04:39,940
这就是 SQLite ，实际上我不知道 SQLite 做了这个，

1394
01:04:39,940 --> 01:04:40,980
但这是 Postgres 所做的，

1395
01:04:42,080 --> 01:04:42,540
MySQL 所做， MySQL 没有这样做，

1396
01:04:42,800 --> 01:04:43,285
SQL Server 是这样做的，

1397
01:04:43,285 --> 01:04:45,790
这个插槽页面页面是最常见的方法，

1398
01:04:45,790 --> 01:04:46,650
这是每个系统都会做的。

1399
01:04:50,910 --> 01:04:51,310
是的。

1400
01:04:56,200 --> 01:04:56,720
所以，他的问题是，

1401
01:04:56,860 --> 01:04:58,820
我可以重复使用插槽位置 #3 吗，

1402
01:04:58,820 --> 01:05:01,030
如果我插入一个新的 tuple ，是的，

1403
01:05:01,030 --> 01:05:03,915
但我没必要把这个放在 #4 前面，

1404
01:05:03,915 --> 01:05:04,670
我可以把它放在任何地方。

1405
01:05:08,310 --> 01:05:08,860
还有其他问题吗？

1406
01:05:10,830 --> 01:05:11,230
是的。

1407
01:05:18,370 --> 01:05:20,055
是的，所以她的陈述，她的问题是，

1408
01:05:20,055 --> 01:05:23,690
如果 tuple 是长度可变的，这不是在浪费空间吗，

1409
01:05:23,980 --> 01:05:25,160
是的，所以，

1410
01:05:26,130 --> 01:05:30,040
我的 tuple 是从[]开始增长的，

1411
01:05:30,270 --> 01:05:31,930
tuple 数据是从尾到头的，

1412
01:05:32,580 --> 01:05:33,880
slot array 是从头到尾的，

1413
01:05:34,140 --> 01:05:35,690
在每个时间，我会用完空间，

1414
01:05:35,690 --> 01:05:36,790
可能会有一点，

1415
01:05:37,140 --> 01:05:40,385
中间的一点空间我不能用来做任何事情，

1416
01:05:40,385 --> 01:05:41,290
这是浪费吗，是的。

1417
01:05:42,660 --> 01:05:44,060
但我们获得的优势是，

1418
01:05:44,060 --> 01:05:50,290
不必更新其他东西，当我们重新排序 slot array 时，

1419
01:05:50,550 --> 01:05:51,880
成本是值得的。

1420
01:05:58,470 --> 01:05:58,870
好的。

1421
01:06:00,010 --> 01:06:02,780
所以现在，假设我们考虑插槽页面，

1422
01:06:04,450 --> 01:06:07,070
现在我们需要一种方法来识别 tuple 。

1423
01:06:09,190 --> 01:06:12,290
这一次，我们将使用 record ID 的概念，

1424
01:06:12,910 --> 01:06:15,950
不同的数据系统可能会将其称为 row ID 或 row number ，

1425
01:06:16,600 --> 01:06:18,350
但是一种更高层次的思考方式，

1426
01:06:18,370 --> 01:06:22,790
这是一种唯一识别逻辑 tuple 的方式，

1427
01:06:23,530 --> 01:06:27,140
基于其在页面内文件中的物理位置，

1428
01:06:28,140 --> 01:06:32,800
它通常是文件编号， ID 编号，页面编号的组合，

1429
01:06:33,620 --> 01:06:36,670
然后是对应于它们在 slot array 中存在的位置的 slot 编号。

1430
01:06:37,390 --> 01:06:39,045
所以当你想查找一下，

1431
01:06:39,045 --> 01:06:41,120
比如我需要这个 tuple ，

1432
01:06:41,260 --> 01:06:42,380
如果你有 record ID ，

1433
01:06:42,850 --> 01:06:44,145
你可以查看页面目录，

1434
01:06:44,145 --> 01:06:45,500
找出那个页面包含它，

1435
01:06:45,820 --> 01:06:46,910
然后获取那个页面，

1436
01:06:47,170 --> 01:06:48,975
然后使用 slot array 内的 slot 编号，

1437
01:06:48,975 --> 01:06:53,120
找出你要查找的数据在页面内的偏移量。

1438
01:06:54,510 --> 01:06:56,480
所以大多数数据库不会存储这个 record ID ，

1439
01:06:56,480 --> 01:06:58,270
这是一个合成的，具体化的东西，

1440
01:06:58,440 --> 01:07:01,060
基于页面目录，

1441
01:07:02,430 --> 01:07:04,540
或者跟踪如何找到东西，

1442
01:07:04,650 --> 01:07:07,930
意思是，在 tuple 数据本身中，我没有存储这个 record ID 。

1443
01:07:08,640 --> 01:07:11,300
SQLite 确实将它存储为一个单独的列，

1444
01:07:11,300 --> 01:07:13,600
你不应该看到它，但你可以访问它，

1445
01:07:13,980 --> 01:07:15,905
而他们这样做的原因是，

1446
01:07:15,905 --> 01:07:17,320
因为这是他们要，

1447
01:07:18,480 --> 01:07:20,555
他们要使用这个作为主键，

1448
01:07:20,555 --> 01:07:22,840
以允许他们识别单独的 tuple 。

1449
01:07:23,340 --> 01:07:25,370
所以，如果，我们还没有讨论过二级索引，

1450
01:07:25,370 --> 01:07:26,450
如果我有一个索引，

1451
01:07:26,450 --> 01:07:27,700
那不是主键索引，

1452
01:07:28,750 --> 01:07:33,330
当我查找一个键时，我的值将是那个 row ID ，

1453
01:07:33,330 --> 01:07:36,740
然后我使用主键 row ID 索引来查找我需要的数据。

1454
01:07:37,900 --> 01:07:39,110
不同的系统做不同的事情。

1455
01:07:40,720 --> 01:07:44,090
这个的大小根据实现的不同而不同，

1456
01:07:44,350 --> 01:07:46,610
Postgres 是 6 个字节，

1457
01:07:47,200 --> 01:07:48,950
SQLite 是 8 个字节或 64 位，

1458
01:07:49,930 --> 01:07:51,210
SQL Server 有 8 字节，

1459
01:07:51,210 --> 01:07:55,070
然后 Oracle 有一个 10 字节的 record ID 。

1460
01:07:56,150 --> 01:07:58,260
你可以在数据库系统中直接看到这一点，

1461
01:07:59,000 --> 01:07:59,845
所以我们可以做一个快速演示，

1462
01:07:59,845 --> 01:08:00,960
来向你展示所有这些。

1463
01:08:04,890 --> 01:08:07,270
所以你不应该在你的应用程序中使用这个，

1464
01:08:07,530 --> 01:08:11,940
尽管这将唯一地识别一个 tuple ，

1465
01:08:12,230 --> 01:08:14,190
但这是它的物理位置，

1466
01:08:14,880 --> 01:08:15,790
而且它可能会改变，

1467
01:08:16,320 --> 01:08:18,910
意思是，比如我插入一个 tuple ，

1468
01:08:19,320 --> 01:08:20,380
我得到一个 record ID ，

1469
01:08:21,900 --> 01:08:24,250
如果我的应用程序引用了它，

1470
01:08:24,570 --> 01:08:25,355
问题可能是，

1471
01:08:25,355 --> 01:08:27,275
比如我可以运行压缩或垃圾回收，

1472
01:08:27,275 --> 01:08:28,600
在 Postgres 中，这被称为 Vacuum ，

1473
01:08:28,830 --> 01:08:30,860
我可以在其中重新组织页面，

1474
01:08:30,860 --> 01:08:33,440
现在可能会更改 slog 编号或页面编号，

1475
01:08:33,440 --> 01:08:35,320
现在我要找的东西已经不在那里了。

1476
01:08:35,520 --> 01:08:37,895
所以，这是数据库系统的一个物理方面，

1477
01:08:37,895 --> 01:08:40,360
我们不应该在我们的应用程序中使用它，

1478
01:08:40,620 --> 01:08:42,365
但它对我们是公开的，

1479
01:08:42,365 --> 01:08:44,530
因为如果我们需要管理和维护这些系统，

1480
01:08:44,820 --> 01:08:46,720
我们需要知道数据实际在哪里。

1481
01:08:51,160 --> 01:08:52,460
所以让我快速登录，抱歉，

1482
01:09:01,680 --> 01:09:02,560
我可能需要重新连接。

1483
01:09:04,710 --> 01:09:05,920
好的，我先做 Postgres 。

1484
01:09:08,135 --> 01:09:09,850
所以我们要创建一个非常简单的表 r ，

1485
01:09:11,730 --> 01:09:18,380
它只有三个 tuple ， 100 101 102 。

1486
01:09:19,520 --> 01:09:21,330
所以， Postgres 有一种叫做 ctid 的东西，

1487
01:09:23,510 --> 01:09:25,680
现在，这将是一个 tuple ，

1488
01:09:26,090 --> 01:09:29,670
它将给你页面编号，然后是 slot 编号，

1489
01:09:30,290 --> 01:09:35,320
所以，这些 tuple 在页面 0 ，插槽 1 ，插槽 2 ，插槽 3 ，

1490
01:09:37,770 --> 01:09:42,620
所以现在，如果我删除第二个 tuple ，我删除 101 ，

1491
01:09:43,630 --> 01:09:45,440
现在当我再次扫描的时候，

1492
01:09:46,420 --> 01:09:49,430
现在你可以看到， Postgres 删除了那个 tuple ，

1493
01:09:51,630 --> 01:09:53,080
但它并没有移动东西，

1494
01:09:54,200 --> 01:09:57,180
并让数据位于其实际存储的位置。

1495
01:09:59,810 --> 01:10:01,770
但我可以运行垃圾收集，

1496
01:10:03,650 --> 01:10:05,100
让我再插入一个 tuple ，

1497
01:10:06,430 --> 01:10:07,460
所以我插入 103 ，

1498
01:10:09,400 --> 01:10:10,305
现在你可以再次看到，

1499
01:10:10,305 --> 01:10:13,260
它没有使用那个 (0,2) 插槽，

1500
01:10:13,260 --> 01:10:14,480
从我删除的第一个 tuple 那里，

1501
01:10:15,100 --> 01:10:18,490
它被附加到末尾，放在插槽 4 中。

1502
01:10:20,830 --> 01:10:22,430
那么我现在可以运行，

1503
01:10:23,950 --> 01:10:25,490
在 Postgres 中，它被称为 Vacuum ，

1504
01:10:29,040 --> 01:10:30,350
所以命令是 VACUUM ，

1505
01:10:30,350 --> 01:10:31,570
这是 Postgres 的习语，

1506
01:10:31,980 --> 01:10:33,650
所以 VACUMM FULL 基本上就是，

1507
01:10:33,650 --> 01:10:39,280
让 Postgres 压缩每个页面，写出新的页面，新的文件，

1508
01:10:40,120 --> 01:10:42,540
所以我有一大堆空白的页面，

1509
01:10:42,890 --> 01:10:45,810
它将在创建新版本时释放它们。

1510
01:10:47,130 --> 01:10:49,720
所以现在，当我以前做同样的查询时，

1511
01:10:49,920 --> 01:10:54,730
现在，你看到它的压缩， (0,1) (0,2) (0,3) 。

1512
01:10:58,410 --> 01:10:59,590
能理解吗，是的。

1513
01:10:59,670 --> 01:11:02,230
那么这个 ctid 指的是？

1514
01:11:03,550 --> 01:11:06,480
页码和偏移量，插槽编号。

1515
01:11:11,980 --> 01:11:12,950
位于 slot array 中，

1516
01:11:13,330 --> 01:11:14,550
因为如果您使用 slot array ，

1517
01:11:14,550 --> 01:11:17,270
表示我找到我需要的内容在页面中的偏移量。

1518
01:11:18,130 --> 01:11:18,530
是的。

1519
01:11:18,730 --> 01:11:24,720
问题是，

1520
01:11:25,100 --> 01:11:26,980
slot array 从 0 索引开始，

1521
01:11:26,980 --> 01:11:28,705
即使页面 0 索引，

1522
01:11:28,705 --> 01:11:30,360
抱歉， slot array 从 1 索引开始，

1523
01:11:30,740 --> 01:11:31,885
页面从 0 索引开始，

1524
01:11:31,885 --> 01:11:34,170
有什么东西在 1 里面吗，

1525
01:11:34,310 --> 01:11:35,010
让我们来看一下，

1526
01:11:35,330 --> 01:11:36,475
所以你不应该这么做，

1527
01:11:36,475 --> 01:11:37,830
但你可以这么做，

1528
01:11:38,330 --> 01:11:39,330
你实际上可以查询这个，

1529
01:11:40,220 --> 01:11:43,130
ctid = '(0,0)'

1530
01:11:46,400 --> 01:11:47,250
里面什么都没有，

1531
01:11:48,520 --> 01:11:49,550
但我可以拿到另一个，

1532
01:11:49,960 --> 01:11:51,290
所以我不知道他们为什么这么做。

1533
01:11:52,710 --> 01:11:53,110
是的。

1534
01:12:02,010 --> 01:12:05,380
问题是，当我们说一个 slot 时，

1535
01:12:06,090 --> 01:12:08,135
ctid 将是 6 个字节，

1536
01:12:08,135 --> 01:12:11,560
所以它可能是一个 4 字节的页面编号，然后是 2 个字节的偏移量，

1537
01:12:11,910 --> 01:12:14,650
这不是限制了我们在一个页面中可以拥有的插槽数量吗，

1538
01:12:14,730 --> 01:12:17,260
是的， Postgres 的默认页面大小是 8 千字节，

1539
01:12:17,280 --> 01:12:19,330
所以你不能在一个页面中有 10 亿个 tuple 。

1540
01:12:21,290 --> 01:12:22,800
好的，让我们来看看其他系统。

1541
01:12:24,760 --> 01:12:27,080
所以， SQLite 是不同的，

1542
01:12:27,610 --> 01:12:30,350
SQLite 有这个 rowid ，

1543
01:12:30,670 --> 01:12:32,570
它实际上会存储这个，

1544
01:12:33,190 --> 01:12:34,250
这是 64 位，

1545
01:12:34,450 --> 01:12:35,450
它实际上存储了这个，

1546
01:12:35,560 --> 01:12:38,570
它使用这个作为主键。

1547
01:12:41,440 --> 01:12:41,955
问题是，

1548
01:12:41,955 --> 01:12:43,040
tuple 的大小会在某个地方，

1549
01:12:43,180 --> 01:12:44,630
通常是在 tuple 的 header 中，是的。

1550
01:12:48,410 --> 01:12:50,490
好的，所以，如果我们删除，

1551
01:12:53,790 --> 01:12:54,940
我们删除一个 tuple ，

1552
01:12:55,700 --> 01:12:56,440
运行相同的查询，

1553
01:12:58,140 --> 01:12:59,680
它不会重用 rowid ，

1554
01:13:01,095 --> 01:13:02,750
因为它实际上是一个物理的东西，主键。

1555
01:13:03,720 --> 01:13:06,970
好的，我们现在做 SQL Server ，

1556
01:13:10,630 --> 01:13:13,430
所以 SQL Server 有这个不同的语法，

1557
01:13:14,260 --> 01:13:15,110
它有一个双重，

1558
01:13:15,370 --> 01:13:16,190
它很难看到，

1559
01:13:17,050 --> 01:13:18,260
如果我高亮显示，我可以看到它，

1560
01:13:21,610 --> 01:13:23,910
不能，这里有两个百分号，相信我，

1561
01:13:27,945 --> 01:13:28,430
抱歉，让我们回去，

1562
01:13:34,990 --> 01:13:36,260
这就对了，这就对了，

1563
01:13:36,460 --> 01:13:37,730
这里有百分号，抱歉，

1564
01:13:39,250 --> 01:13:40,395
所以当你运行这个的时候，

1565
01:13:40,395 --> 01:13:43,130
你会得到一些像这样的十六进制数据，

1566
01:13:43,850 --> 01:13:44,640
这是什么意思，

1567
01:13:45,490 --> 01:13:48,830
所以有一个未经记录的命令，

1568
01:13:48,850 --> 01:13:51,980
这是你不该做的事，你不能，

1569
01:13:53,740 --> 01:13:54,735
它是无记录的，

1570
01:13:54,735 --> 01:13:56,570
这意味着微软不正式支持它，

1571
01:13:56,650 --> 01:14:00,650
但这里有一个命令叫做，就是这个函数，

1572
01:14:00,910 --> 01:14:02,390
你可以传递物理位置，

1573
01:14:03,100 --> 01:14:04,440
然后，你现在将得到，

1574
01:14:05,030 --> 01:14:09,310
格式化的文件编号，页面编号，然后是插槽编号。

1575
01:14:10,960 --> 01:14:11,700
你可以，

1576
01:14:11,700 --> 01:14:13,980
今天学到这个很有趣，

1577
01:14:13,980 --> 01:14:17,270
你可以找回那个函数的实际功能，

1578
01:14:17,830 --> 01:14:21,555
所以你可以让它输出它的实际功能，

1579
01:14:21,555 --> 01:14:24,110
你可以看到它们获取物理位置，

1580
01:14:24,310 --> 01:14:25,665
以及它们如何跳转到不同的字节，

1581
01:14:25,665 --> 01:14:28,280
以获取页面 ID ，文件编号和插槽编号。

1582
01:14:31,035 --> 01:14:32,090
所以，让我们做之前做过的同样的事情，

1583
01:14:32,650 --> 01:14:33,770
我们删除 101 ，

1584
01:14:36,140 --> 01:14:37,230
然后我们运行相同的查询，

1585
01:14:38,230 --> 01:14:40,590
以获得页码偏移量，

1586
01:14:40,590 --> 01:14:44,060
所以在这种情况下，它没有移动任何东西。

1587
01:14:44,880 --> 01:14:49,180
所以现在如果插入一个新的 tuple ，

1588
01:14:50,080 --> 01:14:50,960
运行相同的查询，

1589
01:14:53,560 --> 01:14:54,380
现在看看它做了什么。

1590
01:14:56,510 --> 01:15:00,840
当我的 id 为 102 的 tuple ，之前在 slot 2 中，

1591
01:15:01,310 --> 01:15:03,150
但当我插入新的 tuple 时，

1592
01:15:03,560 --> 01:15:07,200
它把第二个 tuple 102 移动到 slot 2 中，

1593
01:15:07,920 --> 01:15:10,550
然后把新的 tuple 放入 slot 3 中，

1594
01:15:12,115 --> 01:15:13,020
Postgres 没有这么做，

1595
01:15:13,490 --> 01:15:14,910
Postgres 只是追加到末尾，

1596
01:15:16,810 --> 01:15:20,550
这是错的吗，谁知道呢，

1597
01:15:20,780 --> 01:15:23,930
这是更好的吗，谁知道呢，

1598
01:15:24,650 --> 01:15:26,730
之所以可以这样做是因为，

1599
01:15:27,080 --> 01:15:29,340
因为当你获取一个页面并将其放入内存时，

1600
01:15:29,870 --> 01:15:32,160
你开始向其中插入一个 tuple ，

1601
01:15:32,390 --> 01:15:34,770
你就持有了那个页面上的锁，

1602
01:15:35,480 --> 01:15:38,970
数据库决定它是否想要进行压缩或任何优化想要做的事情，

1603
01:15:39,440 --> 01:15:42,070
因为它知道没有其他线程可以同时写入那个页面，

1604
01:15:42,780 --> 01:15:47,210
所以我们可以决定我们是否想要压缩它，

1605
01:15:47,290 --> 01:15:47,865
当我们做的时候，

1606
01:15:47,865 --> 01:15:49,670
Postgres 没有做， SQL Server 做了。

1607
01:15:50,750 --> 01:15:52,650
好的，让我们来看看大家最喜欢的 Oracle 。

1608
01:15:56,310 --> 01:15:57,790
我想，我需要先创建一张表，

1609
01:16:04,650 --> 01:16:06,160
我不认为它会，让我来做，不，它做了，

1610
01:16:07,390 --> 01:16:13,630
所以，在 Oracle 中，他们有一个 rowid ，

1611
01:16:13,630 --> 01:16:16,530
但是你在这里又得到了一些二进制数据，

1612
01:16:18,480 --> 01:16:21,770
这是来自 stack overflow ，不是我，

1613
01:16:22,270 --> 01:16:23,690
但这里你可以做很多函数，

1614
01:16:24,580 --> 01:16:25,130
运行这个，

1615
01:16:26,890 --> 01:16:29,835
你可以看到它们存储的是 OBJID FILENUM ，

1616
01:16:29,835 --> 01:16:31,130
BLOCKNUM 或页面编号，

1617
01:16:31,300 --> 01:16:32,300
然后是 ROWSLOT 。

1618
01:16:34,290 --> 01:16:37,670
再说一次，这是在教科书中定义的东西，

1619
01:16:37,670 --> 01:16:41,380
在逻辑层面或理论层面上进行描述，

1620
01:16:41,460 --> 01:16:42,820
这是如何组织你的数据库系统，

1621
01:16:43,350 --> 01:16:45,100
然后你可以看到它的不同实现。

1622
01:16:45,620 --> 01:16:47,240
通过 SQL ，你可以看到如何，

1623
01:16:47,240 --> 01:16:50,110
它们是某种插槽页面的东西。

1624
01:16:51,180 --> 01:16:51,620
好的。

1625
01:16:53,370 --> 01:16:54,940
好的，为了时间着想。

1626
01:16:58,930 --> 01:17:00,080
我想我要跳过。

1627
01:17:02,900 --> 01:17:04,990
这将进入下一节课，

1628
01:17:04,990 --> 01:17:10,640
但是， tuple 本身只是一个字节序列，

1629
01:17:12,370 --> 01:17:14,720
有一些头，然后是字节序列，

1630
01:17:15,160 --> 01:17:17,090
然后是数据库系统知道，

1631
01:17:17,170 --> 01:17:22,760
如何根据类型和你正在查看的值来解释这些字节。

1632
01:17:23,300 --> 01:17:24,890
我们将在下一节课上讲，

1633
01:17:24,890 --> 01:17:25,960
但是思考这个问题的方法是，

1634
01:17:26,790 --> 01:17:27,575
这里有一些头，

1635
01:17:27,575 --> 01:17:30,160
其中包含关于 tuple 是否[]的信息，

1636
01:17:30,900 --> 01:17:32,530
我们可以存储，

1637
01:17:32,550 --> 01:17:34,150
跟踪哪些列具有空值，

1638
01:17:34,560 --> 01:17:41,530
然后执行引擎将知道如何根据模式跳到 tuple 中的不同偏移量。

1639
01:17:42,130 --> 01:17:44,600
我们将在下一节课中讨论这个，

1640
01:17:45,220 --> 01:17:46,160
但只是作为结束。

1641
01:17:49,400 --> 01:17:50,850
我们今天讨论了什么，

1642
01:17:51,260 --> 01:17:53,815
有一个数据库系统来维护一个数据库，

1643
01:17:53,815 --> 01:17:58,290
数据将被不同的文件跟踪，并分解成页面，

1644
01:17:58,940 --> 01:18:00,750
然后我们有不同的方法来跟踪这些页面，

1645
01:18:01,040 --> 01:18:03,180
跟踪哪些以及如何在这些页面中存储内容，

1646
01:18:03,500 --> 01:18:04,225
然后下一节课，

1647
01:18:04,225 --> 01:18:05,880
我们将讨论如何存储 tuple 。

1648
01:18:06,980 --> 01:18:08,485
所以，下一节课会有很多讨论，

1649
01:18:08,485 --> 01:18:09,250
周末愉快，再见。

