1
00:00:42,640 --> 00:00:44,750
她想找到你在哪里。

2
00:00:50,800 --> 00:00:51,480
所以，很快，

3
00:00:51,480 --> 00:00:54,450
事实上，设施的人刚刚来找我，

4
00:00:54,450 --> 00:00:58,610
他们说州长在这里， Shapiro ，

5
00:00:59,800 --> 00:01:01,070
我支持他，他不是 Trump 的支持者，

6
00:01:01,900 --> 00:01:03,860
但主入口被封锁了，

7
00:01:04,000 --> 00:01:04,995
所以当课程结束时，

8
00:01:04,995 --> 00:01:06,180
你不能通过那个入口，

9
00:01:06,180 --> 00:01:07,700
你得乘电梯上楼，

10
00:01:09,090 --> 00:01:11,230
所以联邦探员和警察都在外面。

11
00:01:11,430 --> 00:01:16,480
好的，对于课程，

12
00:01:16,920 --> 00:01:20,050
我们在星期一有一次复习课，

13
00:01:20,160 --> 00:01:21,850
作为一个视频发布在了 Piazza 上，

14
00:01:23,040 --> 00:01:26,470
项目一截止 10 月 2 日，

15
00:01:26,850 --> 00:01:29,650
然后，我们将在 10 月 1 日星期六有特殊办公时间，

16
00:01:29,910 --> 00:01:33,245
然后作业二推迟到 10 月 4 日，

17
00:01:33,245 --> 00:01:34,540
那是星期三，而不是星期天。

18
00:01:37,210 --> 00:01:39,620
关于作业和项目有什么问题吗？

19
00:01:44,180 --> 00:01:47,730
好的，它是星期天截止，

20
00:01:48,260 --> 00:01:50,760
然后办公时间在星期六，

21
00:01:50,870 --> 00:01:53,430
所以不论真正的日期是什么？

22
00:01:53,840 --> 00:01:54,240
是的。

23
00:01:56,160 --> 00:01:59,550
网站和 GradeScope 应该是正确的，不是我。

24
00:02:00,370 --> 00:02:00,950
还有其他问题吗？

25
00:02:02,850 --> 00:02:03,520
好的，酷。

26
00:02:03,600 --> 00:02:07,910
所以，有一个有趣的事情，

27
00:02:07,910 --> 00:02:10,930
有人说，嘿，实习怎么样，这些公司在招人吗，

28
00:02:11,250 --> 00:02:12,070
答案是肯定的，

29
00:02:12,780 --> 00:02:15,940
事实上，有人在推特上发帖说，

30
00:02:17,250 --> 00:02:20,950
你知道如果你上我的课，他们就会招人，

31
00:02:22,230 --> 00:02:26,315
spacetime_db ，我想它是另一个时间序列数据库系统，

32
00:02:26,315 --> 00:02:27,310
我想是在欧洲，

33
00:02:27,900 --> 00:02:28,780
我不认识这家伙，

34
00:02:29,100 --> 00:02:30,700
如果你愿意，你可以联系他，

35
00:02:31,170 --> 00:02:32,860
但我们会在 Piazza 上张贴，

36
00:02:33,810 --> 00:02:37,505
如何给我你的简历，

37
00:02:37,505 --> 00:02:40,340
然后我们可以把它发送给我们认识的各种数据库公司，

38
00:02:40,340 --> 00:02:41,140
以及与我们是朋友的公司，

39
00:02:41,250 --> 00:02:43,630
如果你还没有，请向 SingleStore 申请，

40
00:02:44,010 --> 00:02:46,330
那里有一个专门针对 CMU 学生的特殊电子邮件地址，

41
00:02:47,070 --> 00:02:49,960
它会直接发给招聘者，而不是招聘人员。

42
00:02:51,210 --> 00:02:52,660
如果你不想做实习，

43
00:02:53,250 --> 00:02:55,420
另一种通过数据库赚钱的方法是，

44
00:02:55,710 --> 00:02:58,330
有人在 upwork 上发布，这是真实的，

45
00:02:58,620 --> 00:03:02,620
他们正在寻找人来设计数据库项目，

46
00:03:02,790 --> 00:03:06,130
基本上就是 BusTub 和课程项目，

47
00:03:07,260 --> 00:03:08,470
所以，如果你喜欢你正在做的事情，

48
00:03:08,640 --> 00:03:10,450
你可以从这个人那里得到 100 美元的报酬，

49
00:03:12,120 --> 00:03:13,840
让你去重新实现它。

50
00:03:15,060 --> 00:03:16,355
我们发现这件事的方式是，

51
00:03:16,355 --> 00:03:19,265
有人给我和 TA Chi 发了电子邮件，

52
00:03:19,265 --> 00:03:20,960
说，嘿，我可以为你做这份工作，

53
00:03:20,960 --> 00:03:22,210
他就像是，你在说什么，

54
00:03:22,470 --> 00:03:23,890
因为他们以为我们发了这个，

55
00:03:24,000 --> 00:03:25,450
这不是我们，这是[]，

56
00:03:27,150 --> 00:03:28,450
一百美元肯定不够，

57
00:03:31,500 --> 00:03:33,735
每小时一百美元在数据库上，

58
00:03:33,735 --> 00:03:34,430
如果不是更多的话。

59
00:03:36,620 --> 00:03:39,750
好的，我们课程的哪里，

60
00:03:40,940 --> 00:03:45,510
我们花了大约一周的时间讨论了存储层，

61
00:03:45,740 --> 00:03:47,815
然后将缓冲池放在它的上面，

62
00:03:47,815 --> 00:03:51,180
以便在我们将页面传入和传出磁盘时管理内存，

63
00:03:51,380 --> 00:03:53,850
所以，现在我们继续向上，

64
00:03:54,260 --> 00:03:56,790
现在将讨论系统的不同部分，

65
00:03:57,050 --> 00:04:01,080
这些部分可以操作、执行和处理这些页面，

66
00:04:01,130 --> 00:04:04,020
我们从磁盘检索到的缓冲池中的（页面）。

67
00:04:04,440 --> 00:04:06,920
所以，我们处于中间层，在访问方法，

68
00:04:07,300 --> 00:04:08,445
现在我们将开始讨论，

69
00:04:08,445 --> 00:04:10,340
如何构建执行引擎，

70
00:04:10,630 --> 00:04:13,760
负责执行这些查询。

71
00:04:14,230 --> 00:04:19,130
访问方法是访问数据的机制，

72
00:04:19,660 --> 00:04:23,270
它可以通过索引或通过表本身，

73
00:04:23,530 --> 00:04:25,130
也可以通过其他机制。

74
00:04:25,870 --> 00:04:27,840
要做到这个，我们需要讨论，

75
00:04:27,840 --> 00:04:32,120
我们将在系统的这一部分拥有什么样的数据结构，

76
00:04:33,520 --> 00:04:35,300
所以这节课将是哈希表，

77
00:04:35,650 --> 00:04:38,210
这是一种无序数据结构，

78
00:04:38,530 --> 00:04:42,050
然后我们将在整个下周讨论树形数据结构，

79
00:04:42,460 --> 00:04:45,740
它会给你排序，给你自己的键排序。

80
00:04:46,490 --> 00:04:48,240
所以，我们是在慢慢地积累，

81
00:04:48,560 --> 00:04:49,450
通过我们的方式达到顶端，

82
00:04:49,450 --> 00:04:52,170
为我们的查询产生结果。

83
00:04:54,160 --> 00:04:56,875
所以，我的意思是，

84
00:04:56,875 --> 00:04:59,370
我假设这里的每个人都学习了数据结构课程或算法课程，

85
00:04:59,600 --> 00:05:02,280
数据结构将在整个系统中使用，

86
00:05:02,570 --> 00:05:05,635
到目前为止，我们已经在某些方面涵盖了系统的一些部分，

87
00:05:05,635 --> 00:05:07,140
我们将在哪里使用这些东西。

88
00:05:08,330 --> 00:05:10,150
但还有其他方面的原因，

89
00:05:10,150 --> 00:05:14,420
我们需要有高性能，安全和正确的数据结构，

90
00:05:14,590 --> 00:05:17,570
来表示系统状态或系统数据。

91
00:05:18,410 --> 00:05:20,850
我们已经了解了如何将其用于内部元数据，

92
00:05:21,350 --> 00:05:23,610
我们谈到了页目录或页表，

93
00:05:24,560 --> 00:05:25,720
这或多或少是一个哈希表，

94
00:05:25,720 --> 00:05:31,050
用于将页面 ID 映射到磁盘上的某个位置或内存中的某个位置。

95
00:05:31,980 --> 00:05:35,410
我们可以将数据结构用于表本身的核心存储，

96
00:05:36,030 --> 00:05:39,130
我们谈到了索引组织的表，

97
00:05:39,240 --> 00:05:43,390
其中 tuple 本身将位于 B+ 树的叶节点中，

98
00:05:43,770 --> 00:05:47,680
所以，你可以将表直接表示在数据结构中，

99
00:05:48,060 --> 00:05:50,200
而不是无序的[]文件中。

100
00:05:51,280 --> 00:05:54,140
我们还可以将这些数据结构用于查询执行，

101
00:05:54,160 --> 00:05:58,370
以生成临时数据集合，

102
00:05:58,570 --> 00:06:00,470
允许更高效地执行查询，

103
00:06:00,910 --> 00:06:03,615
这就是我们将如何实现 hash join 很快，

104
00:06:03,615 --> 00:06:06,260
或者如何使用 hash join 实现 join 很快，

105
00:06:06,340 --> 00:06:07,910
我们动态构建一个哈希表，

106
00:06:08,230 --> 00:06:10,910
使用表或扫描中的数据进行填充，

107
00:06:11,320 --> 00:06:13,760
执行 join ，然后丢弃哈希表，

108
00:06:15,250 --> 00:06:16,770
所以，因为们构建哈希[]，

109
00:06:16,770 --> 00:06:18,920
不意味着它会长期存在，

110
00:06:19,300 --> 00:06:21,330
然后，你最熟悉的可能是，

111
00:06:21,330 --> 00:06:24,080
将这些数据结构用于表索引，

112
00:06:24,430 --> 00:06:25,520
当调用 CREATE INDEX 时，

113
00:06:25,540 --> 00:06:27,860
实质上将创建一个这样的数据结构，

114
00:06:28,600 --> 00:06:30,295
然后用键填充它，

115
00:06:30,295 --> 00:06:31,720
并将它们映射到 tuple ，

116
00:06:31,720 --> 00:06:32,850
这样你就可以更快地进行查找，

117
00:06:32,930 --> 00:06:34,800
就像教科书中的词汇表一样。

118
00:06:36,050 --> 00:06:40,140
所以，我们将看到这些数据结构被使用，

119
00:06:40,400 --> 00:06:41,440
在本学期余下的时间里，

120
00:06:41,440 --> 00:06:44,190
在这个列表中涵盖的不同场景中。

121
00:06:45,820 --> 00:06:48,140
那么，当我们设计数据结构时，我们关心的是什么，

122
00:06:48,190 --> 00:06:49,940
我们需要认识到什么，

123
00:06:50,170 --> 00:06:52,940
以确保我们拥有一个有效的数据库系统，

124
00:06:53,170 --> 00:06:56,860
而且也是正确的，这是非常重要的。

125
00:06:57,330 --> 00:06:58,780
所以你要担心的第一件事是，

126
00:06:59,010 --> 00:07:02,860
我们如何组织数据本身，

127
00:07:03,060 --> 00:07:04,060
无论在内存中，

128
00:07:04,470 --> 00:07:09,100
或者在内存中但由缓冲池中的磁盘支持的页面。

129
00:07:09,680 --> 00:07:10,655
我在一开始就说过，

130
00:07:10,655 --> 00:07:14,560
我们希望在如何实现我们的系统做出设计选择，

131
00:07:15,630 --> 00:07:18,400
如果我们知道它将由磁盘上的页面支持，

132
00:07:18,510 --> 00:07:20,740
我们就会最大限度地增加顺序 I/O 的数量。

133
00:07:21,400 --> 00:07:23,635
所以，我们可能会以这样一种方式布局页面，

134
00:07:23,635 --> 00:07:24,550
这种方式的数据结构，

135
00:07:24,550 --> 00:07:28,110
这样我们就可以通过多个页面读取和写入数据，

136
00:07:28,460 --> 00:07:30,510
而不是进行随机 I/O 。

137
00:07:32,170 --> 00:07:35,270
然后我们将讨论如何使我们的数据结构是线程安全的，

138
00:07:35,740 --> 00:07:37,860
在这节课上，我们不用担心这个问题，

139
00:07:37,860 --> 00:07:42,380
但我们会在下周的周四或周三花一整节课的时间，

140
00:07:42,610 --> 00:07:47,570
讨论如何确保数据结构是正确的，

141
00:07:47,830 --> 00:07:51,405
如果我们有多个工作线程或进程进来，

142
00:07:51,405 --> 00:07:56,500
同时读取，写入或修改数据结构。

143
00:07:57,090 --> 00:07:58,520
最后一个比较棘手，

144
00:07:58,520 --> 00:08:03,430
因为我们要关注数据结构中两种类型的正确性，

145
00:08:03,840 --> 00:08:05,140
如果你想让它们成为多线程的，

146
00:08:05,340 --> 00:08:07,660
很明显，物理的正确性，

147
00:08:08,010 --> 00:08:10,400
确保我们没有一个无处可去的指针，

148
00:08:10,400 --> 00:08:13,460
或者一个不存在的页面 ID ，

149
00:08:13,460 --> 00:08:16,510
如果我们有一个线程访问一个页面，

150
00:08:16,830 --> 00:08:17,840
另一个线程正在更新它，

151
00:08:17,840 --> 00:08:20,620
并且访问线程读取了这个写的东西，

152
00:08:21,220 --> 00:08:25,230
但它还没有安全地提交或它没有正确保存，

153
00:08:25,460 --> 00:08:27,930
然后我们可能会结束到一个无处可去的指针，

154
00:08:28,100 --> 00:08:29,160
系统将崩溃，

155
00:08:29,240 --> 00:08:30,450
所以我们必须避免这种情况。

156
00:08:31,330 --> 00:08:32,940
但是还有另一种正确性，

157
00:08:32,940 --> 00:08:34,670
我们将在期中考试后进行讨论，

158
00:08:35,260 --> 00:08:36,620
在逻辑层面上，

159
00:08:36,970 --> 00:08:41,510
以确保如果我们对数据结构进行更改，

160
00:08:41,890 --> 00:08:44,270
我们自己的线程可以看到这些更改，

161
00:08:44,890 --> 00:08:46,760
它看起来是正确的，

162
00:08:46,780 --> 00:08:49,700
这意味着如果我的线程从索引中删除了一个键，

163
00:08:49,990 --> 00:08:51,525
如果我回到同一个线程，

164
00:08:51,525 --> 00:08:53,780
尝试读取该索引中的键，

165
00:08:54,100 --> 00:08:55,310
我不应该还看到它，

166
00:08:56,020 --> 00:08:58,620
这些比特可能还在，

167
00:08:58,620 --> 00:09:00,210
因为我们还没有运行垃圾收集，

168
00:09:00,210 --> 00:09:02,720
也许有一个小标记，表明这个东西已经被删除了，

169
00:09:02,800 --> 00:09:04,970
所以物理上它还在，但逻辑上它不在了，

170
00:09:05,080 --> 00:09:08,550
我们要确保我们不会看到不该看到的东西。

171
00:09:08,960 --> 00:09:12,210
再说一次，本周我们不会太关注并发的事情，

172
00:09:12,410 --> 00:09:15,190
但我们将在下周更详细地讨论这一点，

173
00:09:15,190 --> 00:09:19,260
当我们讨论并发控制时，这将是一个大问题，

174
00:09:19,400 --> 00:09:21,150
在逻辑层面上，使用事务，

175
00:09:21,890 --> 00:09:24,510
并确保我们提供 ACID 保证，

176
00:09:24,620 --> 00:09:26,280
但是，这将在期中之后。

177
00:09:28,240 --> 00:09:30,135
好的，所以今天的课程，

178
00:09:30,135 --> 00:09:31,460
我们将重点放在哈希表上，

179
00:09:31,840 --> 00:09:35,055
因为它是一个低级别的构建块，

180
00:09:35,055 --> 00:09:37,850
我们可以在系统的其余部分中重复使用，

181
00:09:38,440 --> 00:09:40,520
再次，这对这里的任何人来说都不是什么新闻，

182
00:09:40,720 --> 00:09:42,980
哈希表只是一个关联数组，

183
00:09:43,240 --> 00:09:45,290
可以将键映射到值。

184
00:09:46,560 --> 00:09:47,560
你们还好吗？

185
00:09:50,190 --> 00:09:50,740
那是什么？

186
00:10:11,320 --> 00:10:12,915
哈希表的工作方式是，

187
00:10:12,915 --> 00:10:16,280
它将是键到值的映射，

188
00:10:16,660 --> 00:10:18,720
我们将使用哈希函数，

189
00:10:18,720 --> 00:10:22,790
它将允许我们计算数组中的一些偏移量，

190
00:10:24,250 --> 00:10:30,440
然后基本上减少这个整型域的任意键，

191
00:10:30,700 --> 00:10:34,230
然后我们可以跳到哈希表中的某个位置，

192
00:10:34,230 --> 00:10:36,340
以找到我们寻找的东西。

193
00:10:37,120 --> 00:10:40,650
这个哈希函数必须能够接受任何可能的键，

194
00:10:40,650 --> 00:10:43,490
因为，考虑到你可以在数据库系统中定义的任何列类型，

195
00:10:44,110 --> 00:10:47,240
还有任何我们在系统本身中拥有的内部元数据，

196
00:10:47,530 --> 00:10:48,800
我们需要能够，

197
00:10:49,000 --> 00:10:51,530
哈希函数需要把它降低到一个整数。

198
00:10:52,570 --> 00:10:57,140
所以在哈希表中，空间复杂性将大致为 O(n) ，

199
00:10:57,490 --> 00:11:04,010
因为我们必须为我们想要的每个可能的键存储一个槽，

200
00:11:04,660 --> 00:11:05,910
时间复杂性很好，

201
00:11:05,910 --> 00:11:07,700
因为平均而言，我们只需要 O(1) 查找，

202
00:11:08,050 --> 00:11:12,470
这意味着我们对一个键做哈希，跳转到这个哈希表数组中的某个位置，

203
00:11:12,730 --> 00:11:16,220
然后理想地，在那里找到仍然在那里的东西。

204
00:11:16,920 --> 00:11:17,510
或者干脆杀了它，

205
00:11:19,970 --> 00:11:20,550
这就对了。

206
00:11:21,420 --> 00:11:24,770
好的，那么这学期就是两次击杀，这还不错。

207
00:11:26,580 --> 00:11:29,170
再说一次，平均是 1 ，

208
00:11:29,220 --> 00:11:31,090
因为这就像是哈希，

209
00:11:31,740 --> 00:11:33,305
使用你的键，哈希到某个位置，

210
00:11:33,305 --> 00:11:35,650
然后你找到一个东西，就是你要找的东西，

211
00:11:36,320 --> 00:11:38,130
最坏的情况会是 O(n) ，

212
00:11:38,330 --> 00:11:41,340
因为我们将不得不处理冲突，

213
00:11:41,360 --> 00:11:42,325
这可能是这样的情况，

214
00:11:42,325 --> 00:11:45,660
我们对键的哈希在某个位置，

215
00:11:45,680 --> 00:11:47,310
然后我们要寻找的东西不在那里，

216
00:11:47,480 --> 00:11:49,350
我们必须扫描我们的哈希表，

217
00:11:49,820 --> 00:11:51,130
找到我们要找的东西，

218
00:11:51,130 --> 00:11:53,790
可能是哈希表中的所有槽都满了，

219
00:11:53,900 --> 00:11:57,670
我们必须绕过一个又一个，

220
00:11:57,670 --> 00:11:58,800
我们位于哈希函数上，

221
00:11:59,030 --> 00:12:01,470
但我们必须循环才能找到它。

222
00:12:02,360 --> 00:12:03,850
所以你处理这个问题的方式，

223
00:12:03,850 --> 00:12:04,660
我们会在接下来的过程中看到，

224
00:12:04,660 --> 00:12:08,670
你将哈希表的大小调整为大约是你期望的键数量的 2n 。

225
00:12:09,280 --> 00:12:10,360
现在，你可能会说，好吧， Andy ，

226
00:12:10,360 --> 00:12:11,850
你怎么知道 n 是什么，

227
00:12:12,410 --> 00:12:14,425
这是，我们会度过整个学期，

228
00:12:14,425 --> 00:12:16,165
数据库系统会试图做出决定，

229
00:12:16,165 --> 00:12:18,450
或者试图预测你将拥有多少键，

230
00:12:18,740 --> 00:12:20,130
并相应地调整大小。

231
00:12:21,420 --> 00:12:22,780
所以 O(1) 听起来很棒，

232
00:12:23,520 --> 00:12:25,095
如果你要上一门算法课，

233
00:12:25,095 --> 00:12:26,625
这就是圣杯，你想要这个，

234
00:12:26,625 --> 00:12:28,520
你想要 O(1) ，因为它是恒定的时间，

235
00:12:29,050 --> 00:12:31,640
但事实上，在一个真实的系统中，

236
00:12:33,670 --> 00:12:35,420
常量实际上很重要，

237
00:12:35,590 --> 00:12:36,770
所以即使它是 O(1) ，

238
00:12:37,270 --> 00:12:40,350
你可以有一个哈希函数，它可能需要 10 毫秒的计算时间，

239
00:12:40,350 --> 00:12:42,470
另一个哈希函数的计算时间为 1 毫秒，

240
00:12:42,550 --> 00:12:45,350
显然，1 毫秒的速度要快得多，

241
00:12:45,370 --> 00:12:48,500
如果你在数十亿个键这样的大规模表中思考。

242
00:12:49,340 --> 00:12:54,450
所以，仅仅因为算法的复杂度是理想的，平均为 1 ，

243
00:12:54,920 --> 00:12:56,400
我们仍然必须关心实现，

244
00:12:56,450 --> 00:12:58,200
并确保我们尽可能地高效。

245
00:13:00,260 --> 00:13:03,865
让我们来看看这个玩具例子，

246
00:13:03,865 --> 00:13:04,890
哈希表是什么样子的，

247
00:13:05,120 --> 00:13:06,955
我们会看到你可能会遇到的所有问题，

248
00:13:06,955 --> 00:13:09,810
然后我们将介绍更复杂的方案，

249
00:13:10,040 --> 00:13:12,270
但实际上在现实世界的数据库系统中使用。

250
00:13:13,610 --> 00:13:15,900
所以最容易构建的哈希表是一个静态哈希表，

251
00:13:16,310 --> 00:13:18,840
你只需要调用 malloc 生成一个巨大的数组，

252
00:13:19,070 --> 00:13:24,150
对于我可能拥有的每个键，你都有一个槽在数组中，

253
00:13:24,840 --> 00:13:27,340
然后要找到给定键的条目，

254
00:13:27,660 --> 00:13:30,400
你可以根据你拥有的元素的数量来获得键，

255
00:13:30,750 --> 00:13:33,885
然后你落在数组中的某个偏移量上，

256
00:13:33,885 --> 00:13:34,910
这是我的偏移量，

257
00:13:35,260 --> 00:13:38,840
然后任何键出现，我知道到哪里去找它，

258
00:13:39,900 --> 00:13:41,675
你没有把键存储在这个数组中，

259
00:13:41,675 --> 00:13:45,635
它本质上只是一个指向其他位置的指针，

260
00:13:45,635 --> 00:13:50,340
将键和值放在一起，

261
00:13:51,770 --> 00:13:53,575
你需要存储原始键的原因是，

262
00:13:53,575 --> 00:13:58,225
因为哈希可能，你可能会有冲突，

263
00:13:58,225 --> 00:13:58,980
我们稍后会了解到，

264
00:13:59,780 --> 00:14:03,145
你需要检查你通过哈希表查找的键

265
00:14:03,145 --> 00:14:04,770
是否真的是你想要找到的键，

266
00:14:05,610 --> 00:14:09,010
这里的值可以是指向 tuple ，指向一个记录 ID 的指针，

267
00:14:09,330 --> 00:14:11,320
或者可能有一些额外的值，

268
00:14:11,820 --> 00:14:13,990
对于我们今天的目的，我们其实并不关心。

269
00:14:16,560 --> 00:14:18,400
那么，这种方法有哪些问题呢？

270
00:14:20,430 --> 00:14:20,830
是的。

271
00:14:26,160 --> 00:14:27,670
他说，如果你有，

272
00:14:28,770 --> 00:14:30,095
好的，我假设它是静态的，

273
00:14:30,095 --> 00:14:31,780
那么，如果你有 n+1 个键，

274
00:14:32,460 --> 00:14:33,610
你怎么调整这个东西的大小，

275
00:14:34,200 --> 00:14:35,540
基本上，在这种情况下，

276
00:14:35,540 --> 00:14:36,610
你必须重新计算所有东西，

277
00:14:37,110 --> 00:14:38,110
所以这太糟糕了。

278
00:14:39,360 --> 00:14:39,995
还有其他什么问题吗？

279
00:14:39,995 --> 00:14:40,330
是的。

280
00:14:41,690 --> 00:14:43,080
它能处理碰撞吗，什么是碰撞？

281
00:14:46,810 --> 00:14:48,230
是的，没错，

282
00:14:48,610 --> 00:14:49,830
两个具有相同值的键，

283
00:14:49,830 --> 00:14:53,210
它们将落在我们数组中的相同位置，

284
00:14:53,440 --> 00:14:54,620
尽管它们不是相同的，

285
00:14:54,670 --> 00:14:58,610
但我假设每个都必须是独一无二的，你不能有冲突，

286
00:14:58,840 --> 00:15:00,410
这个例子不能处理这个。

287
00:15:02,190 --> 00:15:02,720
还有一个问题。

288
00:15:07,800 --> 00:15:11,110
我假设键是唯一的，

289
00:15:11,340 --> 00:15:13,150
我的键值可以等于 1 ，

290
00:15:13,290 --> 00:15:14,860
键值可以等于 2 ，

291
00:15:15,060 --> 00:15:16,210
相同的键，但值不同，

292
00:15:16,620 --> 00:15:21,800
我的玩具例子，不能处理这个。

293
00:15:22,270 --> 00:15:24,225
所以，对于这三个假设，这是不现实的。

294
00:15:24,225 --> 00:15:25,010
所以第一个是，

295
00:15:25,030 --> 00:15:26,540
你必须提前知道所有的键，

296
00:15:27,220 --> 00:15:29,715
在某些情况下，你知道，其他情况下，你不知道，

297
00:15:29,715 --> 00:15:30,950
在缓冲池的情况下，

298
00:15:31,120 --> 00:15:32,460
我们上一节课讨论的，

299
00:15:32,460 --> 00:15:37,550
如果假设缓冲池的大小是固定的，

300
00:15:37,750 --> 00:15:40,160
那么缓冲池中将有固定数量的帧，

301
00:15:40,390 --> 00:15:44,150
这样，你直到你的哈希表中需要的确切槽数，

302
00:15:44,930 --> 00:15:48,030
但是，如果我构建了一个哈希表索引，

303
00:15:48,290 --> 00:15:49,530
我一直插入 tuple ，

304
00:15:49,640 --> 00:15:52,560
那么当我插入新的 tuple 时，键的数量就会增加。

305
00:15:54,010 --> 00:15:55,755
在这个场景中，每个键都是唯一的，

306
00:15:55,755 --> 00:16:01,440
同样，我们需要一种方法来处理具有重复键的键，

307
00:16:01,440 --> 00:16:02,210
我们有不同的值，

308
00:16:02,320 --> 00:16:03,080
得处理好这件事。

309
00:16:03,820 --> 00:16:06,340
然后他提出的事情是，

310
00:16:06,340 --> 00:16:08,520
我们假设我们这里有一个所谓的完美散列函数，

311
00:16:08,960 --> 00:16:10,420
它保证不会发生碰撞，

312
00:16:10,420 --> 00:16:12,690
这在现实世界中是不存在的，

313
00:16:13,820 --> 00:16:14,695
在现实世界中，

314
00:16:14,695 --> 00:16:15,930
但这基本上是玩具[]，

315
00:16:15,950 --> 00:16:17,560
没有数据库系统可以真正做到这一点，

316
00:16:17,560 --> 00:16:21,120
因为同样，你需要提前知道键的域，

317
00:16:21,260 --> 00:16:23,485
没有神奇的哈希函数可以保证，

318
00:16:23,485 --> 00:16:27,720
任何给定的键，你可以生成唯一的哈希值，

319
00:16:29,520 --> 00:16:32,680
实际实现其中之一的方法是通过哈希表，

320
00:16:32,970 --> 00:16:35,710
所以你的哈希表基本上需要一个哈希表来实现这个，

321
00:16:38,230 --> 00:16:40,560
有些系统确实会这样做，

322
00:16:40,560 --> 00:16:41,990
但不会对哈希函数。

323
00:16:44,820 --> 00:16:45,640
所以我们必须变得更聪明，

324
00:16:45,720 --> 00:16:46,685
我们必须确保，

325
00:16:46,685 --> 00:16:49,570
我们与使用数据库操作的环境打交道。

326
00:16:50,680 --> 00:16:52,215
好的，所以我们必须做出两个决定，

327
00:16:52,215 --> 00:16:53,570
当我们运行关于哈希表时，

328
00:16:53,800 --> 00:16:57,560
有人说哈希表有两个部分，

329
00:16:57,580 --> 00:16:58,605
哈希函数本身，

330
00:16:58,605 --> 00:17:03,350
它可以将一个大的键空间映射到一个有限的、较小的域，

331
00:17:04,380 --> 00:17:07,000
根据我的数组中将要包含的槽的数量，

332
00:17:07,560 --> 00:17:08,630
这里有一个权衡，

333
00:17:08,630 --> 00:17:10,565
在我们希望哈希函数的速度，

334
00:17:10,565 --> 00:17:15,940
与两个不同的键发生冲突的可能性之间。

335
00:17:17,210 --> 00:17:20,070
我能构建的最快的哈希函数是什么？

336
00:17:22,270 --> 00:17:22,790
那是什么？

337
00:17:23,440 --> 00:17:24,880
[]，你可以比这个更快，

338
00:17:24,880 --> 00:17:25,645
所以他说的是，

339
00:17:25,645 --> 00:17:27,000
对于一个给定的键，你吐出相同的键，

340
00:17:27,140 --> 00:17:29,155
但是如果你有一个字符串键，而我要把它变成一个整数，

341
00:17:29,155 --> 00:17:29,760
我该怎么做？

342
00:17:32,690 --> 00:17:33,720
拿出第一个位，

343
00:17:36,190 --> 00:17:37,580
是的，那也会很快的，

344
00:17:40,300 --> 00:17:42,940
你可以只返回 1 ，

345
00:17:43,980 --> 00:17:46,600
它们位于寄存器中的堆栈中，速度非常快。

346
00:17:48,120 --> 00:17:49,715
就碰撞而言，这是最糟糕的哈希函数，

347
00:17:49,715 --> 00:17:50,920
因为所有东西都将映射到 1 ，

348
00:17:51,360 --> 00:17:52,420
但它会很快。

349
00:17:53,160 --> 00:17:54,845
所以这是一种权衡试图找出，

350
00:17:54,845 --> 00:17:57,490
而你有点认为完美的哈希函数是另一端，

351
00:17:57,660 --> 00:17:59,980
碰撞率是零，

352
00:18:00,300 --> 00:18:01,235
但它非常慢，

353
00:18:01,235 --> 00:18:02,800
因为你必须进行额外的查找。

354
00:18:03,270 --> 00:18:04,220
所以你想要中间的东西，

355
00:18:04,220 --> 00:18:06,340
既快速又有低碰撞率。

356
00:18:07,420 --> 00:18:09,150
然后，哈希方案将是，

357
00:18:09,150 --> 00:18:13,190
我们在完成哈希之后将用来处理冲突的机制，

358
00:18:13,600 --> 00:18:18,060
这里的权衡方式将是，

359
00:18:18,060 --> 00:18:20,780
计算机科学中经典的存储与计算，

360
00:18:21,070 --> 00:18:24,530
比如我可以分配一个 2TB 的哈希表，

361
00:18:24,820 --> 00:18:28,520
我不太可能有冲突，

362
00:18:28,630 --> 00:18:30,030
因为我的键集非常小，

363
00:18:30,030 --> 00:18:32,270
但我分配了这个巨大的哈希表，

364
00:18:32,720 --> 00:18:33,995
或者我可以有一个更小的，

365
00:18:33,995 --> 00:18:34,925
但我会有很多碰撞，

366
00:18:34,925 --> 00:18:37,450
因此我必须花费更多的计算来处理这些碰撞。

367
00:18:37,710 --> 00:18:40,520
所以，它试图找出如何做正确的权衡，

368
00:18:40,520 --> 00:18:42,310
在不过度分配，

369
00:18:42,480 --> 00:18:45,730
同时也不浪费大量指令来处理碰撞之间。

370
00:18:48,060 --> 00:18:49,060
好的，今天的演讲，

371
00:18:49,110 --> 00:18:50,620
我们将稍微讨论一下哈希函数，

372
00:18:51,030 --> 00:18:53,830
只是为了向你们展示什么是最先进的，

373
00:18:53,850 --> 00:18:54,845
我不会说它们是如何工作的，

374
00:18:54,845 --> 00:18:56,350
来告诉你们它们的存在，

375
00:18:56,640 --> 00:18:57,620
再次，我们是数据库人，

376
00:18:57,620 --> 00:18:58,880
我们不是做编写哈希函数的，

377
00:18:58,880 --> 00:19:00,160
我们会让别人为我们做这件事。

378
00:19:01,080 --> 00:19:05,110
然后我们将讨论经典的静态哈希方案，

379
00:19:05,190 --> 00:19:07,000
在这种方案中，提前知道键的数量。

380
00:19:07,320 --> 00:19:09,365
然后我们将讨论动态哈希方案，

381
00:19:09,365 --> 00:19:11,260
其中哈希表可以增长和缩小，

382
00:19:11,840 --> 00:19:12,870
根据键的数量，

383
00:19:13,430 --> 00:19:13,830
好的？

384
00:19:15,460 --> 00:19:15,980
好的。

385
00:19:17,850 --> 00:19:20,470
再说一次，我们不是在做编写哈希函数的，

386
00:19:20,520 --> 00:19:23,440
在这个领域，其他比我们更聪明的人已经为我们做到了这个，

387
00:19:23,970 --> 00:19:25,030
所以，我们将依靠它们。

388
00:19:25,470 --> 00:19:27,020
哈希函数的基本思想是，

389
00:19:27,020 --> 00:19:27,970
我们有一些输入键，

390
00:19:28,170 --> 00:19:30,340
任何类型的任意数量的字节，

391
00:19:30,570 --> 00:19:33,880
我们需要返回一个表示那个键的整数，

392
00:19:34,140 --> 00:19:35,740
通常是 64 位，

393
00:19:36,420 --> 00:19:38,795
有 128 位的哈希函数，

394
00:19:38,795 --> 00:19:40,420
但我不认为数据库使用这些，

395
00:19:40,620 --> 00:19:42,520
还有 32 位哈希函数，

396
00:19:43,970 --> 00:19:45,420
所以要返回一个整数。

397
00:19:46,220 --> 00:19:49,500
所以在这个方案，或者在这个数据库系统中，

398
00:19:49,580 --> 00:19:55,680
我们不关心哈希函数的任何类型的保护隐私机制，

399
00:19:56,000 --> 00:19:58,680
意味着我们不会使用任何有加密保证的东西，

400
00:19:59,060 --> 00:20:01,105
所以我们没有使用 SHA-256 或其他任何东西，

401
00:20:01,105 --> 00:20:02,620
我们不在乎这些东西，

402
00:20:02,620 --> 00:20:04,800
因为我们在系统内部运行，

403
00:20:06,440 --> 00:20:09,725
我们并不担心会泄露任何东西，

404
00:20:09,725 --> 00:20:11,860
当我们可以构建一个哈希表来进行 JOIN 时，

405
00:20:12,150 --> 00:20:15,070
因为系统外部的任何人都看不到该数据结构，

406
00:20:15,890 --> 00:20:17,850
所以我们不关心任何这些事情，

407
00:20:18,200 --> 00:20:22,310
结果是，我们可以跑得更快，

408
00:20:22,310 --> 00:20:23,690
SHA-256 的速度会非常慢，

409
00:20:23,690 --> 00:20:27,400
相对于 MurmurHash 或 XXHash 之类的东西。

410
00:20:29,270 --> 00:20:30,085
正如我之前说过的，

411
00:20:30,085 --> 00:20:32,070
我们想要的是速度快、碰撞率低的东西。

412
00:20:32,960 --> 00:20:38,415
所以，这只是一个快速的概述，

413
00:20:38,415 --> 00:20:39,860
了解系统使用的是什么哈希函数，

414
00:20:40,870 --> 00:20:43,220
有些像 Postgres 使用他们自己的哈希函数，

415
00:20:43,900 --> 00:20:45,410
但许多更现代的系统，

416
00:20:45,550 --> 00:20:47,180
他们将使用现成的东西，

417
00:20:47,560 --> 00:20:51,500
比如 XXHash 或 MurmurHash 或 SpookyHash 。

418
00:20:52,700 --> 00:20:55,720
所以，从根本上说，这一点的主要结论是，

419
00:20:56,400 --> 00:20:58,430
最先进的一个是 Facebook 的 XXHash ，

420
00:20:59,350 --> 00:21:00,980
第三个版本， XXHash-3 ，

421
00:21:01,210 --> 00:21:07,550
这个版本被证明具有最快的性能和最低的冲突率，

422
00:21:07,980 --> 00:21:14,360
有一些系统使用 CRC-32 或 64 来哈希整数，

423
00:21:14,470 --> 00:21:19,340
因为 x86 中的 CPU 指令会在几个周期内完成它，

424
00:21:21,220 --> 00:21:22,305
有一些系统做这个，

425
00:21:22,305 --> 00:21:26,120
但在随机字符串方面，你通常希望使用这个，

426
00:21:26,760 --> 00:21:27,905
MurmurHash 是[]，

427
00:21:27,905 --> 00:21:30,280
因为 MurmurHash 是由一个[随机的家伙]在互联网上写的，

428
00:21:30,480 --> 00:21:32,320
他有一个好的、快速的通用哈希函数，

429
00:21:32,700 --> 00:21:36,580
Google 采用它，并通过 fork 做了 CityHash ，

430
00:21:36,630 --> 00:21:37,625
然后他们有了一个更新的版本，

431
00:21:37,625 --> 00:21:39,520
我们称之为 FarmHash ，

432
00:21:40,230 --> 00:21:41,380
它的有更好的碰撞率，

433
00:21:41,400 --> 00:21:43,990
有很多不同的哈希函数，

434
00:21:44,520 --> 00:21:46,720
但是 XXHash-3 是你想要使用的。

435
00:21:47,280 --> 00:21:50,120
GitHub 上有一堆这样的存储库，

436
00:21:51,010 --> 00:21:54,080
或者人们[]或基准，

437
00:21:54,160 --> 00:21:57,110
运行所有可能的哈希函数，

438
00:21:57,340 --> 00:21:58,590
看看它们的碰撞率是多少，

439
00:21:58,590 --> 00:21:59,510
看看性能是什么，

440
00:22:00,580 --> 00:22:02,820
这个是 SMhasher ，

441
00:22:02,820 --> 00:22:04,730
这是另一个 MurmurHash 的人写的，

442
00:22:05,140 --> 00:22:07,460
还有一个是这个方面的 fork ，

443
00:22:08,380 --> 00:22:11,450
这只是[]所有密码学的东西，

444
00:22:11,800 --> 00:22:13,605
但对于这里的存储库，

445
00:22:13,605 --> 00:22:15,080
他们在这里有一个很好的总结，

446
00:22:15,160 --> 00:22:18,920
说这些是工作最好的，并且有很好的碰撞率，

447
00:22:19,380 --> 00:22:23,540
然后这里最上面的是 XXHash-3 ， Facebook 的那个。

448
00:22:25,540 --> 00:22:26,990
所以，我们并不关系，

449
00:22:27,460 --> 00:22:29,840
这是一个哈希函数，输入键，输出整型，

450
00:22:30,010 --> 00:22:31,430
我们将使用他们给出的任何东西。

451
00:22:32,120 --> 00:22:35,460
然后这是所有不同哈希函数的完整列表，

452
00:22:35,750 --> 00:22:36,775
有些是为 ARM 量身定制的，

453
00:22:36,775 --> 00:22:38,610
有些是为 x86 量身定制的，或任何（CPU），

454
00:22:38,840 --> 00:22:43,520
你可以根据环境获得更多的低级别细节，

455
00:22:43,520 --> 00:22:46,450
但 XXHash3 将是一个很好的默认选择。

456
00:22:50,050 --> 00:22:50,810
好的，现在。

457
00:22:52,210 --> 00:22:54,200
假设运行 XXHash3 ，

458
00:22:54,400 --> 00:22:57,090
我们想讨论一下哈希表是什么样子的，

459
00:22:57,090 --> 00:22:58,250
以及如何处理碰撞。

460
00:22:59,030 --> 00:23:02,550
所以在这节课上，我将集中讨论两个最常见的问题，

461
00:23:02,840 --> 00:23:06,390
但第一个是所有系统中最常见的一个，

462
00:23:06,560 --> 00:23:07,530
线性探测哈希，

463
00:23:08,480 --> 00:23:09,510
这是最简单的，

464
00:23:10,650 --> 00:23:12,610
在某些方面，它似乎有点脑残，

465
00:23:13,830 --> 00:23:17,950
但因为它是如此简单，它实际上是最快的。

466
00:23:18,570 --> 00:23:20,885
而 Cuckoo 哈希是它的一个变体，

467
00:23:20,885 --> 00:23:22,510
它基本上是执行多个哈希函数。

468
00:23:22,800 --> 00:23:23,980
所以还有很多其他的技术，

469
00:23:24,060 --> 00:23:25,595
Robin Hood 哈希， Hopscotch 哈希，

470
00:23:25,595 --> 00:23:27,250
来自 Google 的 Swiss 表，

471
00:23:27,510 --> 00:23:28,925
这学期我们不会讲这些，

472
00:23:28,925 --> 00:23:30,190
但如果你选了高级课程，

473
00:23:30,300 --> 00:23:31,270
我们会讲这些内容。

474
00:23:31,860 --> 00:23:34,490
我要说的是，目前的研究基本上表明，

475
00:23:34,780 --> 00:23:38,340
线性探测的东西和 Swiss 表是最快的，

476
00:23:38,340 --> 00:23:42,770
所有这些额外的花式版本是，

477
00:23:44,620 --> 00:23:47,340
他们试图提高性能，

478
00:23:47,340 --> 00:23:51,380
因为他们避免了更长的寻找键的时间，

479
00:23:51,610 --> 00:23:53,840
当插入时，移动东西时，

480
00:23:54,070 --> 00:23:57,650
但是所有移动东西的工作都是性能损失，

481
00:23:57,970 --> 00:24:01,280
你最好在哈希中做一些简单的事情。

482
00:24:04,290 --> 00:24:06,640
这个问题，我们不讨论链哈希的原因，

483
00:24:06,690 --> 00:24:08,860
因为它是动态的，它是下一个，

484
00:24:10,850 --> 00:24:12,870
链哈希可以增长，这个是固定大小，

485
00:24:14,030 --> 00:24:15,780
我们会在这学期，这节课的晚些时候讲到，

486
00:24:17,970 --> 00:24:19,480
这些都是静态哈希方案。

487
00:24:21,870 --> 00:24:25,420
有各种各样的线性探测，

488
00:24:26,730 --> 00:24:27,520
让我们简单一点。

489
00:24:28,860 --> 00:24:33,880
好的，所以线性探测哈希很简单，

490
00:24:34,520 --> 00:24:37,960
它是一个巨大的 slot 数组，

491
00:24:38,580 --> 00:24:40,900
我们要哈希到它，

492
00:24:42,670 --> 00:24:44,330
如果我们插入，我们会哈希到它，

493
00:24:44,380 --> 00:24:45,650
如果 slot 是空的，

494
00:24:45,820 --> 00:24:47,240
我们就插入我们要找的东西，

495
00:24:47,410 --> 00:24:48,860
如果 slot 不是空的，

496
00:24:49,150 --> 00:24:53,205
我们只需查看下一个 slot 并插入到那里，

497
00:24:53,205 --> 00:24:55,640
或者我们继续寻找，直到我们有一个空闲的 slot ，

498
00:24:55,660 --> 00:24:56,810
可能会环绕，

499
00:24:57,950 --> 00:24:59,040
直到我们找到一个空闲的地方。

500
00:24:59,840 --> 00:25:02,585
然后如果我们循环回来，

501
00:25:02,585 --> 00:25:05,110
意识到我们在开始的 slot ，

502
00:25:05,130 --> 00:25:06,520
那么我们知道哈希表是满的，

503
00:25:06,780 --> 00:25:10,780
我们必须中止它，

504
00:25:11,070 --> 00:25:12,820
加倍大小，重新哈希所有东西，

505
00:25:13,170 --> 00:25:15,340
这是一种简单的增长方式。

506
00:25:15,900 --> 00:25:21,010
所以我们对这个的实现来自 Google ，

507
00:25:22,500 --> 00:25:27,460
它是 flat_hash_map 类型或数据结构，

508
00:25:28,160 --> 00:25:30,510
他们有非常好的文档来描述它是如何工作的，

509
00:25:30,740 --> 00:25:32,550
并且他们所做的一些优化将涵盖在内。

510
00:25:33,280 --> 00:25:36,560
所以这有时被称为开放寻址哈希，

511
00:25:36,730 --> 00:25:39,290
因为它的思想是，

512
00:25:39,830 --> 00:25:41,850
不能保证对于给定的键，

513
00:25:42,080 --> 00:25:45,180
它将始终位于 slot 中的相同地址或相同位置，

514
00:25:45,500 --> 00:25:47,790
取决于在它之前插入了什么，

515
00:25:47,990 --> 00:25:50,830
它可能会移来移去。

516
00:25:51,640 --> 00:25:53,485
如果你得到一个 Python 的字典，

517
00:25:53,485 --> 00:25:55,380
这基本上也是你要得到的东西。

518
00:25:57,725 --> 00:25:58,270
所以让我们来看看它是如何工作的。

519
00:25:58,680 --> 00:26:01,130
假设我们想要插入键 A ，

520
00:26:01,130 --> 00:26:01,960
所以我们对它进行哈希，

521
00:26:02,160 --> 00:26:03,790
根据我们拥有的 slot 的数量取模，

522
00:26:04,020 --> 00:26:05,710
然后我们到达这个位置，

523
00:26:05,820 --> 00:26:10,520
这样我们就可以插入键，和值一起，

524
00:26:11,080 --> 00:26:12,810
再次，我们需要键的原因是，

525
00:26:12,810 --> 00:26:15,860
如果我们再次查找 A ，

526
00:26:16,210 --> 00:26:18,260
我们需要哈希到相同的位置，

527
00:26:18,550 --> 00:26:20,025
但现在我们必须做一个相等检查，

528
00:26:20,025 --> 00:26:23,300
看看我们正在寻找的键是否是给定 slot 中的键。

529
00:26:25,510 --> 00:26:27,000
一样的东西，如果你想要对 B 进行哈希，

530
00:26:27,000 --> 00:26:29,970
同样的事情，在这里哈希，对 slot 的数量取模，

531
00:26:29,970 --> 00:26:31,910
我们最终在这里，排在顶部。

532
00:26:32,850 --> 00:26:35,080
所以现在我们要插入 C ，

533
00:26:36,180 --> 00:26:37,040
所以我们哈希 C ，

534
00:26:37,040 --> 00:26:38,860
它到达 A 所在的相同位置，

535
00:26:39,300 --> 00:26:41,470
但是那个 slot 被占用了，

536
00:26:41,700 --> 00:26:42,970
所以我们不能把它插入到那里，

537
00:26:43,290 --> 00:26:45,430
所以我们只需往下走到下一个 slot ，

538
00:26:45,660 --> 00:26:48,020
然后在那里插入我们的键。

539
00:26:49,930 --> 00:26:50,700
对于 D 也是同样的事情，

540
00:26:50,700 --> 00:26:51,890
一旦 D 去到 C 所在的地方，

541
00:26:52,030 --> 00:26:53,690
它就不能，因为那个 slot 被占用了，

542
00:26:53,980 --> 00:26:56,330
所以它向下移动到下一个，然后插入到那里。

543
00:26:56,860 --> 00:27:00,370
我们继续，对于我们想要存储的所有其他键。

544
00:27:01,250 --> 00:27:02,215
在这种情况下，

545
00:27:02,215 --> 00:27:05,550
假设 F 这个空间被占用了，

546
00:27:06,280 --> 00:27:09,140
F 绕回，从顶部开始，插入到顶部，

547
00:27:10,520 --> 00:27:12,240
把它想象成一个巨大的圆形缓冲区。

548
00:27:14,450 --> 00:27:15,270
很简单，对吧？

549
00:27:18,460 --> 00:27:19,730
这有哪些潜在的问题？

550
00:27:23,870 --> 00:27:24,865
他说，删除很糟糕，

551
00:27:24,865 --> 00:27:25,675
意味着你失去了整个链，

552
00:27:25,675 --> 00:27:26,190
你是什么意思？

553
00:27:39,720 --> 00:27:40,660
好的，所以他说，

554
00:27:41,010 --> 00:27:42,250
我不认为所有的幻灯片都提前了，

555
00:27:42,420 --> 00:27:44,680
如果删除 C ，会发生什么情况？

556
00:27:46,070 --> 00:27:48,300
所以删除 C ，我们对它进行哈希，

557
00:27:48,380 --> 00:27:50,690
我们落在 A 所在的地方，

558
00:27:50,980 --> 00:27:54,170
现在我们做相等检查，看看 C 是否等于 A ，

559
00:27:54,310 --> 00:27:56,480
不，所以我们知道这不是我们要找的键，

560
00:27:56,650 --> 00:27:57,630
然后我们继续前进，

561
00:27:57,630 --> 00:27:59,720
直到我们找到空的 slot 或我们要找的键，

562
00:27:59,830 --> 00:28:00,585
在这种情况下，

563
00:28:00,585 --> 00:28:02,030
在跳下之后，我们找到 C ，

564
00:28:02,290 --> 00:28:03,560
现在我们需要删除它，

565
00:28:04,470 --> 00:28:06,760
但现在我们有一个空的空间，就像他说的，

566
00:28:07,290 --> 00:28:10,030
所以如果我试着去查找 D ，

567
00:28:10,500 --> 00:28:12,190
D 会哈希到这个空的地方，

568
00:28:14,080 --> 00:28:16,470
它会说，好的，这里什么都没有，

569
00:28:16,470 --> 00:28:18,735
但它真的是，在下一个 slot ，

570
00:28:18,735 --> 00:28:21,140
但因为协议的工作方式，方案的工作方式，

571
00:28:21,430 --> 00:28:25,220
如果我看到一个空的 slot ，我就知道我完成了，

572
00:28:26,840 --> 00:28:27,670
那么，处理这一问题的一种方法是什么？

573
00:28:30,650 --> 00:28:32,610
墓碑，这是一种方法，是的，

574
00:28:33,950 --> 00:28:34,690
我们会到那里，

575
00:28:34,690 --> 00:28:36,030
这就是正确的答案。

576
00:28:37,480 --> 00:28:38,560
所以你可以这样做，

577
00:28:38,560 --> 00:28:41,550
你可以重新哈希，向上移动，

578
00:28:42,490 --> 00:28:43,845
这是个好主意还是坏主意，

579
00:28:43,845 --> 00:28:44,790
显然这是个坏主意，

580
00:28:44,790 --> 00:28:45,800
因为我说过没人会这么做，

581
00:28:46,360 --> 00:28:47,450
但为什么这是个坏主意呢？

582
00:28:49,900 --> 00:28:50,475
移动所有东西，

583
00:28:50,475 --> 00:28:52,190
想象大一点，十亿个键，

584
00:28:52,540 --> 00:28:55,220
我要去重新哈希每一个，那是很糟糕的，

585
00:28:55,720 --> 00:28:58,700
所以它非常昂贵，没有人做这个。

586
00:29:01,640 --> 00:29:02,610
跳过这个。

587
00:29:02,780 --> 00:29:05,125
所以，是的，这没有道理，

588
00:29:05,125 --> 00:29:05,820
你不想做这个。

589
00:29:06,800 --> 00:29:10,110
正确的答案是他说的是墓碑，

590
00:29:10,550 --> 00:29:11,725
这里的想法是，

591
00:29:11,725 --> 00:29:12,600
我删除 C ，

592
00:29:13,550 --> 00:29:15,480
但是不是将其设置为空，

593
00:29:15,890 --> 00:29:17,400
我将在这里放一个小标记，

594
00:29:18,270 --> 00:29:19,840
表示这个 slot ，

595
00:29:20,100 --> 00:29:22,210
曾经有一个键在这里，现在它被删除了。

596
00:29:22,940 --> 00:29:23,650
这样的话，

597
00:29:23,650 --> 00:29:26,040
如果有人过来，比如，做一个查找 D ，

598
00:29:26,420 --> 00:29:28,090
它看到墓碑，

599
00:29:28,090 --> 00:29:29,100
说，嗯，它不是空的，

600
00:29:29,420 --> 00:29:30,390
有东西曾经在这里，

601
00:29:31,130 --> 00:29:32,500
但这里没有我要找的东西，

602
00:29:32,500 --> 00:29:35,490
所以让我往下看，继续扫描，

603
00:29:35,960 --> 00:29:38,500
直到我找到我要找的东西。

604
00:29:40,940 --> 00:29:42,600
所以你可以重复使用这些，

605
00:29:44,420 --> 00:29:47,370
你可以重新使用带有墓碑标记的 slot 给新的键，

606
00:29:48,020 --> 00:29:49,240
你只需要在它上面插入，

607
00:29:49,240 --> 00:29:54,240
这不会打破流程或哈希表中任何内容。

608
00:29:55,080 --> 00:29:57,305
现在，也许你想定期地运行一个垃圾收集，

609
00:29:57,305 --> 00:29:59,075
因为你可以开始积累大量的这些墓碑，

610
00:29:59,075 --> 00:30:00,130
那是在浪费空间，

611
00:30:00,420 --> 00:30:01,540
如果你不重复使用它们，

612
00:30:02,790 --> 00:30:05,650
但是对于我们的目的，我们可以忽略它。

613
00:30:07,530 --> 00:30:09,005
所以我想放入 G ，

614
00:30:09,005 --> 00:30:09,910
G 可以在这里，

615
00:30:10,020 --> 00:30:10,930
这是可以的。

616
00:30:12,900 --> 00:30:15,650
现在，我不打算讨论太多的细节，

617
00:30:15,650 --> 00:30:16,985
但是有一个挑战，

618
00:30:16,985 --> 00:30:18,730
你实际上如何表示这些墓碑，

619
00:30:19,560 --> 00:30:22,330
同时也表示了一种空的东西，

620
00:30:23,200 --> 00:30:25,590
也可能表示我有一个 null 键，

621
00:30:26,400 --> 00:30:29,620
这是你可以在数据库系统中做的。

622
00:30:31,570 --> 00:30:34,755
所以，我们可以使用我们之前讨论过的 slotted pages 的技巧，

623
00:30:34,755 --> 00:30:39,530
我们可以在哈希表中的每个头部或每个页面的顶部前面放置一个 bitmap ，

624
00:30:39,730 --> 00:30:41,955
我没有在这里显示页面之间的划分，

625
00:30:41,955 --> 00:30:42,680
但是考虑，

626
00:30:43,150 --> 00:30:45,380
简单起见，每个页面都是这些 slot ，

627
00:30:45,730 --> 00:30:46,800
所以在页面的头部中，

628
00:30:46,800 --> 00:30:47,715
我可以跟踪，

629
00:30:47,715 --> 00:30:49,005
好的，这里是空的 slot ，

630
00:30:49,005 --> 00:30:50,150
这里是 null slot ，

631
00:30:50,320 --> 00:30:54,710
或者这里是有墓碑标记的 slot 。

632
00:30:55,630 --> 00:30:58,065
所以我需要一些额外的元数据来跟踪这些事情，

633
00:30:58,065 --> 00:31:00,860
你显然不想在每个键的基础上这样做，

634
00:31:01,030 --> 00:31:06,900
因为，这可能会扰乱事物的排列方式，浪费空间。

635
00:31:10,580 --> 00:31:13,950
我们现在要处理的另一件事是非唯一键。

636
00:31:15,240 --> 00:31:15,710
好的。

637
00:31:17,235 --> 00:31:18,290
所以，有两种方法可以做到这个。

638
00:31:19,040 --> 00:31:19,840
其中之一是，

639
00:31:20,220 --> 00:31:27,160
不是将值与键一起存储在我们的大型哈希数组中，

640
00:31:28,040 --> 00:31:31,200
取而代之的是，该值只是一个指针，比如页面 ID ，

641
00:31:32,080 --> 00:31:38,970
到每个其他未知，存储我的键列表，抱歉，值列表，

642
00:31:39,320 --> 00:31:41,100
所以对于键 XYZ ，

643
00:31:41,330 --> 00:31:44,400
有一个指针指向一个链表，

644
00:31:44,540 --> 00:31:45,930
它有所有可能的值，

645
00:31:46,280 --> 00:31:48,090
然后对于另一个键，相同的东西。

646
00:31:49,330 --> 00:31:50,580
这样做的好处是，

647
00:31:50,580 --> 00:31:54,680
当我一次又一次地插入新键、重复键时，

648
00:31:54,880 --> 00:31:57,270
我并没有改变主哈希表，

649
00:31:57,270 --> 00:31:59,150
我在追加到这个链表，

650
00:31:59,760 --> 00:32:01,940
这就像他之前谈到的链哈希表，

651
00:32:01,960 --> 00:32:02,870
或者之前他问到的，

652
00:32:02,890 --> 00:32:03,710
我们稍后会讨论到。

653
00:32:04,870 --> 00:32:09,240
更常见的方法是将冗余键存储在一起，

654
00:32:09,960 --> 00:32:12,980
这并没有打破线性探测哈希方案的开放寻址，

655
00:32:13,210 --> 00:32:16,730
我总是哈希键，

656
00:32:16,870 --> 00:32:17,865
我落在一个地点，

657
00:32:17,865 --> 00:32:21,035
我找到一个空的 slot ，

658
00:32:21,035 --> 00:32:22,270
和我要找的东西。

659
00:32:23,290 --> 00:32:24,740
这确实使它变得有点棘手，

660
00:32:24,970 --> 00:32:25,815
当你查找，

661
00:32:25,815 --> 00:32:30,570
比如给我所有 XYZ 的键，键值对，

662
00:32:30,800 --> 00:32:34,345
因为现在我必须继续扫描，

663
00:32:34,345 --> 00:32:36,415
直到我找到一个空的位置，空的 slot ，

664
00:32:36,415 --> 00:32:38,370
知道我再也见不到 XYZ 了，

665
00:32:38,720 --> 00:32:40,980
而在第一个场景中，

666
00:32:41,880 --> 00:32:43,610
我在哈希表中找到 XYZ ，

667
00:32:43,720 --> 00:32:47,570
然后沿着指向值列表的指针，

668
00:32:47,800 --> 00:32:52,540
我知道这就是我可以为给定键提供的所有可能值。

669
00:32:53,440 --> 00:32:54,555
但为了简单起见，

670
00:32:54,555 --> 00:32:58,920
我没有为非唯一键维护单独的链表，

671
00:32:58,920 --> 00:33:05,620
以及对于唯一键的内联版本，

672
00:33:06,060 --> 00:33:08,620
大多数系统使用冗余键方法，

673
00:33:09,530 --> 00:33:12,360
因为你不需要多重实现。

674
00:33:14,790 --> 00:33:15,190
是的

675
00:33:21,650 --> 00:33:23,700
你的问题是，你如何区分？

676
00:33:32,340 --> 00:33:32,960
所以他的问题是，

677
00:33:32,960 --> 00:33:37,240
你如何区分更新一个值，而不是插入一个值，

678
00:33:39,700 --> 00:33:42,360
是的，对于哈希表，你不应该做更新，

679
00:33:42,360 --> 00:33:44,450
它应该是先删除后插入。

680
00:33:46,620 --> 00:33:47,685
当然，现在棘手的事情是，

681
00:33:47,685 --> 00:33:51,780
如果我想删除键 XYZ 值是 value2 ，

682
00:33:54,660 --> 00:33:58,100
如果我想删除其中一个，

683
00:33:58,540 --> 00:34:04,160
我必须知道它的值，确保是那个，

684
00:34:04,540 --> 00:34:05,480
可能不是我想要的。

685
00:34:13,160 --> 00:34:14,850
问题是，如果你有，

686
00:34:15,920 --> 00:34:17,880
如果你有一个键有多个值，

687
00:34:18,320 --> 00:34:19,465
你只需要哈希整个 tuple ，

688
00:34:19,465 --> 00:34:20,130
你说的是什么意思？

689
00:34:21,020 --> 00:34:31,250
是的，所以就像，

690
00:34:32,080 --> 00:34:33,050
是的，所以声明就像，

691
00:34:34,070 --> 00:34:36,270
如果我在寻找完全匹配，

692
00:34:36,830 --> 00:34:38,185
在这种情况下，我不需要哈希表，

693
00:34:38,185 --> 00:34:39,150
因为如果我有，

694
00:34:39,710 --> 00:34:42,070
但是如果我试图从数据结构中删除它，

695
00:34:42,070 --> 00:34:45,270
就像这个完全匹配键值对，

696
00:34:45,440 --> 00:34:50,910
然后你基本上，

697
00:34:52,660 --> 00:34:54,225
你需要找到确切的对，

698
00:34:54,225 --> 00:34:55,080
你需要有时间，

699
00:34:55,080 --> 00:34:56,780
只是维护数据结构。

700
00:34:56,980 --> 00:35:05,990
问题是为什么要这么做，

701
00:35:06,970 --> 00:35:08,360
如果我做一个 JOIN ，

702
00:35:09,370 --> 00:35:11,990
两个连接表之间的关系是，

703
00:35:12,010 --> 00:35:13,880
一边可能不是唯一的，

704
00:35:16,050 --> 00:35:17,170
所以我需要这个。

705
00:35:17,430 --> 00:35:18,910
所以我想得到所有的，

706
00:35:19,170 --> 00:35:20,450
你基本上有一个迭代器，

707
00:35:20,450 --> 00:35:23,140
给我 key 等于 XYZ 的所有值，

708
00:35:23,460 --> 00:35:27,400
然后在我遍历哈希表的时候把这些东西吐出来，

709
00:35:28,415 --> 00:35:29,110
因为我在做 JOIN 。

710
00:35:30,610 --> 00:35:31,010
是的。

711
00:35:31,180 --> 00:35:34,910
他的问题是，

712
00:35:34,910 --> 00:35:35,720
你会不会重新哈希，

713
00:35:35,720 --> 00:35:37,420
当它 80% 满的时候，

714
00:35:37,590 --> 00:35:39,430
所以不同的系统有不同的，

715
00:35:40,940 --> 00:35:42,130
比如有一个阈值，

716
00:35:42,130 --> 00:35:43,240
如果我超过这个，

717
00:35:43,240 --> 00:35:45,130
我知道我会溢出或用完空间，

718
00:35:45,130 --> 00:35:46,800
我就去触发一个重新哈希，

719
00:35:47,150 --> 00:35:54,300
是的，观点是对的，

720
00:35:54,300 --> 00:35:57,800
你越来越接近最坏的情况，

721
00:35:58,060 --> 00:35:59,960
比如如果它开始变满，

722
00:36:00,190 --> 00:36:02,540
所以，不是等待它 100% 满了，

723
00:36:02,890 --> 00:36:04,370
可能达到 80% ，因为，

724
00:36:04,600 --> 00:36:07,370
最后承担惩罚来调整哈希表的大小，

725
00:36:07,480 --> 00:36:08,445
变为两倍，

726
00:36:08,445 --> 00:36:10,400
重新调真大小哈希是两倍它的大小，

727
00:36:10,810 --> 00:36:11,760
通过你所有的键，

728
00:36:11,760 --> 00:36:13,170
对它们进行重新哈希，放入新的哈希表中，

729
00:36:13,170 --> 00:36:14,090
然后丢弃旧的，

730
00:36:14,200 --> 00:36:16,125
这是很昂贵的，

731
00:36:16,125 --> 00:36:17,090
如果它是一个大的哈希表，

732
00:36:17,380 --> 00:36:18,345
但是有一个权衡，

733
00:36:18,345 --> 00:36:20,090
比如，好的，如果我有 80% 满，

734
00:36:20,350 --> 00:36:22,370
我宁愿承担惩罚来增加一倍的大小，

735
00:36:22,660 --> 00:36:25,010
而不是所有我需要做的额外操作，

736
00:36:25,240 --> 00:36:26,600
需要花费很长时间进行搜索，

737
00:36:27,900 --> 00:36:29,320
没有一个统一答案。

738
00:36:30,390 --> 00:36:34,000
但是，通常有一个可调的阈值，

739
00:36:34,350 --> 00:36:36,430
无论他们是否向你公开，

740
00:36:37,080 --> 00:36:38,650
作为数据库系统的用户，

741
00:36:38,760 --> 00:36:39,670
这取决于实现，

742
00:36:40,020 --> 00:36:41,480
但通常有一个阈值说明，

743
00:36:41,480 --> 00:36:42,700
你希望在什么时候继续并调整大小。

744
00:36:48,450 --> 00:36:50,680
好的，我们还可以做一些其他的优化。

745
00:36:51,610 --> 00:36:56,600
一个是你可以有不同的哈希表实现，

746
00:36:57,010 --> 00:37:00,165
有这些不同的机制，或者决策，

747
00:37:00,165 --> 00:37:02,870
关于何时拆分，如何存储东西，等等，

748
00:37:03,100 --> 00:37:05,360
基于你存储的数据类型。

749
00:37:07,030 --> 00:37:08,570
所以一个显而易见的事情是，

750
00:37:08,800 --> 00:37:12,620
如果我想要的是支持字符串键的哈希表，

751
00:37:13,300 --> 00:37:14,790
如果我的字符串非常小，

752
00:37:14,870 --> 00:37:19,860
比如 64 位或 64 字节或更少，

753
00:37:20,120 --> 00:37:21,900
它们可能会存储我的内联哈希表中，

754
00:37:22,040 --> 00:37:23,515
但如果它是一个非常大的字符串，

755
00:37:23,515 --> 00:37:25,050
我不想将其存储在我的哈希表中，

756
00:37:25,490 --> 00:37:28,200
也许我只想有一个指向实际字符串本身的指针，

757
00:37:28,610 --> 00:37:30,540
所以现在我可以有一个 64 位的指针，

758
00:37:31,940 --> 00:37:34,045
但现在，进行查找成本将会很高，

759
00:37:34,045 --> 00:37:35,275
查看是否有匹配，

760
00:37:35,275 --> 00:37:38,310
可能我真的希望将该字符串的哈希

761
00:37:38,720 --> 00:37:40,710
作为键的一部分存储在哈希表中，

762
00:37:40,940 --> 00:37:43,760
以避免进行那种查找，

763
00:37:46,040 --> 00:37:47,780
我们讨论了存储元数据，

764
00:37:47,780 --> 00:37:54,640
比如墓碑，或者空值，或者空 slot ，

765
00:37:55,110 --> 00:37:56,710
你可以将其存储在页头中，

766
00:37:56,760 --> 00:37:58,450
因为现在你有一堆打包的位，

767
00:37:58,710 --> 00:38:02,070
你会将其存储在整个哈希表本身中。

768
00:38:03,420 --> 00:38:05,270
所以， Google 的 HashMap 做到了这个，

769
00:38:05,270 --> 00:38:07,420
他们有一个单独的哈希表，专门用于元数据，

770
00:38:07,500 --> 00:38:09,220
它更小、更紧凑，

771
00:38:09,390 --> 00:38:10,450
你在它上面进行查找，

772
00:38:10,650 --> 00:38:14,090
告诉你要在真正的哈希表中查找的是什么，

773
00:38:14,090 --> 00:38:17,320
那个东西是否是空值或空的。

774
00:38:19,000 --> 00:38:20,055
然后这个很有趣，

775
00:38:20,055 --> 00:38:21,560
这一个来自 Clickhouse ，

776
00:38:22,600 --> 00:38:25,310
这是俄罗斯的一种基于索引的 OLAP 的系统，

777
00:38:26,560 --> 00:38:28,220
所以他们谈论他们想要成为什么样子，

778
00:38:28,390 --> 00:38:30,620
因为为哈希表分配内存是如此昂贵，

779
00:38:31,060 --> 00:38:33,710
你不会想要分配一堆内存，

780
00:38:33,970 --> 00:38:35,360
使用一次，然后扔掉，

781
00:38:35,770 --> 00:38:38,390
你想要一次又一次地重复使用那个内存，

782
00:38:38,620 --> 00:38:40,310
但你需要一种快速的方法来清理它，

783
00:38:41,240 --> 00:38:44,580
所以，不是遍历并将所有 slot 标记为已删除，

784
00:38:44,870 --> 00:38:47,640
你只需维护一个版本计数器，版本 ID ，

785
00:38:48,460 --> 00:38:52,440
每当你说我想删除该表的内容时，

786
00:38:52,790 --> 00:38:54,990
你只需递增该表上的版本计数器，

787
00:38:55,400 --> 00:38:59,380
现在，如果你在该表内的插槽中执行的任何查找，

788
00:38:59,380 --> 00:39:00,750
如果版本 ID 不匹配，

789
00:39:01,190 --> 00:39:05,700
如果 slot 版本号小于表版本号，

790
00:39:05,750 --> 00:39:07,030
你知道它已经被删除，

791
00:39:07,030 --> 00:39:08,280
你可以忽略其中的所有内容，

792
00:39:08,450 --> 00:39:11,790
这将清除它，然后递增版本 ID 。

793
00:39:13,260 --> 00:39:15,490
所以，你可以在不同的场景中使用一系列不同的技巧

794
00:39:15,510 --> 00:39:16,960
来使这些事情更高效地运行，

795
00:39:17,100 --> 00:39:18,910
不同的系统做不同的事情，

796
00:39:19,350 --> 00:39:20,410
Clickhouse ，在我看来，

797
00:39:20,970 --> 00:39:23,140
那个链接可以把你带到博客文章，

798
00:39:23,460 --> 00:39:26,290
他们声称他们有 30 种不同的哈希表实现，

799
00:39:27,690 --> 00:39:31,210
其中很多都是基于 C++ 模板化的，基于数据类型，

800
00:39:31,350 --> 00:39:33,065
他们做了一系列的编译器技巧，

801
00:39:33,065 --> 00:39:35,290
来删除你不需要的代码，

802
00:39:35,790 --> 00:39:37,505
如果你知道，比如某个东西不能为空，

803
00:39:37,505 --> 00:39:39,820
或者是一个特定大小的字符串，

804
00:39:41,610 --> 00:39:44,110
在我看来，在我研究的所有源系统中，

805
00:39:44,220 --> 00:39:45,640
它们可能是最复杂的，

806
00:39:45,720 --> 00:39:47,200
拥有最复杂的哈希表。

807
00:39:50,570 --> 00:39:55,590
好的，线性探测哈希的一种变体是一种被称为 Cuckoo 哈希的技术。

808
00:39:56,590 --> 00:39:57,920
这里的想法是，

809
00:39:58,450 --> 00:40:00,180
不是只有一个哈希函数，

810
00:40:00,180 --> 00:40:04,310
在我的哈希表中查找一个位置，

811
00:40:05,060 --> 00:40:06,430
如果我有多个哈希函数，

812
00:40:07,230 --> 00:40:09,155
并且我哈希了多个位置，

813
00:40:09,155 --> 00:40:12,790
我找到了任何一个有空闲 slot 的位置，

814
00:40:13,400 --> 00:40:14,200
我就用那个，

815
00:40:14,810 --> 00:40:16,230
而不是必须扫描，

816
00:40:17,180 --> 00:40:19,500
直到我为键找到一个空闲的 slot 。

817
00:40:20,670 --> 00:40:25,090
所以这将保证我所有的查找和删除都是 O(1) ，

818
00:40:25,110 --> 00:40:28,570
因为不管我有多少哈希函数，

819
00:40:30,170 --> 00:40:31,375
我不需要扫一遍，

820
00:40:31,375 --> 00:40:34,980
我会落在我的 HashMap 或哈希表中的某个位置，

821
00:40:35,000 --> 00:40:36,730
那里有我正在寻找的数据，

822
00:40:36,730 --> 00:40:37,650
或者它不存在，

823
00:40:39,330 --> 00:40:40,565
插入将会更昂贵，

824
00:40:40,565 --> 00:40:41,855
因为，我们很快就会看到它，

825
00:40:41,855 --> 00:40:44,170
你可能不得不开始移动东西，重新组织东西。

826
00:40:44,770 --> 00:40:47,625
据我所知，只有一个系统做了 Cuckoo 哈希，

827
00:40:47,625 --> 00:40:48,830
公开谈论它，

828
00:40:48,970 --> 00:40:53,930
这是来自 IBM 的重叠加速器叫做 BLU, B L U ，

829
00:40:54,820 --> 00:40:55,470
在他们的论文中，

830
00:40:55,470 --> 00:40:57,920
他们谈到了是如何大量使用 Cuckoo 哈希的。

831
00:40:58,480 --> 00:40:59,385
根据当前所知，

832
00:40:59,385 --> 00:41:02,565
Cuckoo 哈希表最好的开源实现是，

833
00:41:02,565 --> 00:41:04,700
来自 CMU 的 David Anderson ，

834
00:41:06,140 --> 00:41:09,420
我认为 Google ， David 声称 Google 大量使用了它。

835
00:41:10,320 --> 00:41:12,550
所以名字， Cuckoo 。

836
00:41:16,290 --> 00:41:17,500
好的， Google 发送的。

837
00:41:21,380 --> 00:41:21,780
所以。

838
00:41:23,780 --> 00:41:25,590
所以， Cuckoo 这个名字与这种鸟有关，

839
00:41:25,640 --> 00:41:30,660
它们可以把蛋下到另一个鸟巢里，

840
00:41:30,980 --> 00:41:31,920
所以这个想法是，

841
00:41:31,940 --> 00:41:36,010
我的键可能最终会[窃取]别人在我的哈希表中的位置，

842
00:41:36,010 --> 00:41:38,070
如果我试图去那里，而他们正在使用它。

843
00:41:38,610 --> 00:41:39,380
让我们来看一些例子。

844
00:41:39,380 --> 00:41:41,950
假设我们有一个简单的哈希表，

845
00:41:42,180 --> 00:41:44,260
但现在任何时候我们做一个操作，

846
00:41:44,400 --> 00:41:45,490
我们都会有两个哈希函数，

847
00:41:45,810 --> 00:41:49,640
所以这将是我们之前讨论的相同的哈希函数实现，

848
00:41:49,640 --> 00:41:52,330
比如 XXHash MurmurHash SpookyHash ，这无关紧要，

849
00:41:52,530 --> 00:41:55,720
但我们给哈希函数一个不同的种子，

850
00:41:55,720 --> 00:41:58,105
保证对于给定的键，它并不保证，

851
00:41:58,105 --> 00:42:00,150
但很可能对于给定的键，

852
00:42:00,350 --> 00:42:03,270
它将产生两个不同的哈希值。

853
00:42:04,600 --> 00:42:05,505
所以我哈希 A ，

854
00:42:05,505 --> 00:42:07,050
这里有两个位置，

855
00:42:07,050 --> 00:42:07,830
所以一开始，

856
00:42:07,830 --> 00:42:08,600
我的哈希表是空的，

857
00:42:09,040 --> 00:42:11,510
所以我可以抛硬币，也可以挑第一个，这都无关紧要，

858
00:42:11,740 --> 00:42:14,600
所以我决定，对于插入 A ，

859
00:42:15,130 --> 00:42:16,610
它在这里的第一个 slot ，

860
00:42:17,810 --> 00:42:19,320
现在我想把 b 放进去，

861
00:42:20,480 --> 00:42:22,950
所以第一个哈希函数哈希 A 的位置，

862
00:42:23,060 --> 00:42:24,870
第二个哈希函数是空的 slot ，

863
00:42:25,130 --> 00:42:27,300
因为另一个是空的，

864
00:42:27,440 --> 00:42:29,065
所以我会一直选择空的，

865
00:42:29,065 --> 00:42:30,870
我会把 B 放在最上面，

866
00:42:32,500 --> 00:42:33,810
现在事情变得棘手的是，

867
00:42:33,810 --> 00:42:39,890
我们有两个哈希函数或多个哈希函数哈希到两个位置，

868
00:42:40,960 --> 00:42:42,230
这两个位置都被占用，

869
00:42:43,020 --> 00:42:43,930
所以在这种情况下，

870
00:42:44,190 --> 00:42:46,595
不管什么，不管我们想用什么协议，什么方案，

871
00:42:46,595 --> 00:42:49,330
比如说我们可以抛硬币，我们决定驱逐 B ，

872
00:42:50,290 --> 00:42:53,330
所以我们继续，敲击 B 的头部，

873
00:42:53,410 --> 00:42:55,130
拿取它的位置，把 C 放进去，

874
00:42:55,540 --> 00:42:58,670
但是现在我们要把 B 放回去，

875
00:42:59,340 --> 00:43:03,830
因为 B 落在这里，使用了第二个哈希函数，

876
00:43:04,890 --> 00:43:07,480
在我们将其取出并放回之后，

877
00:43:07,650 --> 00:43:09,310
我们使用第一个哈希函数，

878
00:43:10,330 --> 00:43:12,770
但这就把我们带到了 A 所在的位置，

879
00:43:13,120 --> 00:43:14,750
所以 B 被允许从 A 窃取，

880
00:43:15,040 --> 00:43:17,115
所以 B 去了那里， A 出来了，

881
00:43:17,115 --> 00:43:18,555
我们用第二个哈希函数对 A 进行哈希，

882
00:43:18,555 --> 00:43:20,690
然后我们落到另一个位置。

883
00:43:21,890 --> 00:43:24,040
同样，就像之前的线性探测哈希一样，

884
00:43:24,040 --> 00:43:26,700
你需要跟踪你是否被困在循环中，

885
00:43:26,900 --> 00:43:27,970
所以你要跟踪的是，

886
00:43:27,970 --> 00:43:30,535
这是键，我把同样的键放进去，

887
00:43:30,535 --> 00:43:31,920
我试着首先放在最开始的地方，

888
00:43:32,030 --> 00:43:34,470
我循环回来，我被困在无限循环中，

889
00:43:34,700 --> 00:43:36,000
因此我需要放弃，

890
00:43:36,290 --> 00:43:38,340
两倍哈希表的大小，并重新哈希所有内容。

891
00:43:40,620 --> 00:43:42,400
所以现在当我想要查找 B 时，

892
00:43:43,820 --> 00:43:45,390
我使用 B ，对它进行两次哈希，

893
00:43:45,860 --> 00:43:47,695
我得到了两个不同的位置，

894
00:43:47,695 --> 00:43:49,180
现在我检查一下，

895
00:43:49,180 --> 00:43:51,960
存放在这个 slot 中的键是否是我要找的键，

896
00:43:52,070 --> 00:43:53,760
如果是，那么我就有我要找的东西了。

897
00:43:54,650 --> 00:43:58,680
现在，我不需要执行线性探测扫描，或者查找空的 slot ，

898
00:43:58,790 --> 00:43:59,550
我在查找的键，

899
00:43:59,570 --> 00:44:00,550
因为我可以保证，

900
00:44:00,550 --> 00:44:03,180
哈希之后，要么键就在那里，

901
00:44:03,830 --> 00:44:05,130
要么不在表中。

902
00:44:09,050 --> 00:44:10,350
这是个好主意还是坏主意？

903
00:44:20,080 --> 00:44:21,590
他说，看起来会有更多的碰撞。

904
00:44:29,520 --> 00:44:31,030
好的，不，因为如果，

905
00:44:34,450 --> 00:44:35,330
嗯，就像这样，

906
00:44:36,220 --> 00:44:36,900
这是有取舍的，

907
00:44:37,900 --> 00:44:38,910
是的，可能会有更多的碰撞，

908
00:44:38,910 --> 00:44:40,490
但是，至少在线性探测散列中，

909
00:44:40,660 --> 00:44:43,065
你保证总是会放一些东西在里面，

910
00:44:43,065 --> 00:44:44,085
它可能在最糟糕的 slot ，

911
00:44:44,085 --> 00:44:47,415
也许就在你试图进入的那个 slot 的正上方，

912
00:44:47,415 --> 00:44:48,380
然后你循环回来，

913
00:44:49,060 --> 00:44:51,080
但至少如果有空的 slot ，你就会得到它。

914
00:44:53,350 --> 00:44:53,750
好的。

915
00:44:57,150 --> 00:44:58,745
是的，他说的完全正确，

916
00:44:58,745 --> 00:44:59,950
这是在做随机 IO ，

917
00:45:00,000 --> 00:45:01,000
因为我在跳来跳去，

918
00:45:01,140 --> 00:45:03,350
哈希表本质上是随机 IO ，

919
00:45:03,350 --> 00:45:05,860
但是一旦我落在某个地方，执行随机查找，

920
00:45:06,060 --> 00:45:07,120
那么就是顺序 IO 了，

921
00:45:07,620 --> 00:45:09,950
这永远是随机的。

922
00:45:44,900 --> 00:45:51,040
我是说，这就是生活。

923
00:45:51,480 --> 00:45:53,830
令人印象深刻，

924
00:45:56,040 --> 00:45:58,840
好的，我是说，你是个好 DJ ，

925
00:45:59,760 --> 00:46:01,990
你做的数据库，这是有意义的，对吧？

926
00:46:03,900 --> 00:46:06,890
好的，祝贺你。

927
00:46:11,260 --> 00:46:12,110
所以你的问题是？

928
00:46:27,040 --> 00:46:28,010
是的，所以他的问题是，

929
00:46:28,360 --> 00:46:31,070
有没有可能并行通往不同位置的访问？

930
00:46:33,390 --> 00:46:34,570
是的，你可以这么做，

931
00:46:35,460 --> 00:46:37,930
有两种不同的并行方式，

932
00:46:38,100 --> 00:46:39,010
我们最终会做到这个，

933
00:46:39,420 --> 00:46:40,930
比如你可以有多个线程

934
00:46:41,220 --> 00:46:45,160
或单个线程做向量化指令， SIMD 指令，

935
00:46:46,670 --> 00:46:49,350
对于 SIMD 来说，这不会，

936
00:46:49,840 --> 00:46:50,755
你可以这样做，

937
00:46:50,755 --> 00:46:52,840
但它需要你移动数据的次数有点多，

938
00:46:52,840 --> 00:46:54,000
因为你必须确保数据保持对齐，

939
00:46:55,160 --> 00:46:55,560
但是，

940
00:46:56,220 --> 00:46:59,330
所以，你可以引入带有向量化指令的单个线程，

941
00:47:00,100 --> 00:47:01,425
我知道有技术存在，

942
00:47:01,425 --> 00:47:02,570
我不知道 Cuckoo 哈希[]，

943
00:47:03,400 --> 00:47:05,570
但要使这个变为多线程，

944
00:47:05,950 --> 00:47:09,350
它将太多的工作，

945
00:47:09,550 --> 00:47:12,285
告诉两个线程，

946
00:47:12,285 --> 00:47:13,610
好的，我们在找这个键，

947
00:47:13,690 --> 00:47:14,490
你这样哈希它，

948
00:47:14,490 --> 00:47:15,380
我会这样哈希它，

949
00:47:15,520 --> 00:47:20,570
然后同步谁产生了结果，

950
00:47:20,680 --> 00:47:21,830
不值得这样做。

951
00:47:22,900 --> 00:47:23,300
是的。

952
00:47:40,260 --> 00:47:41,260
所以你的问题是，

953
00:47:41,820 --> 00:47:44,950
你必须保证哈希函数。

954
00:47:54,220 --> 00:47:54,620
是的。

955
00:47:58,310 --> 00:48:01,710
所以，你必须保证你的哈希函数不能这样做，

956
00:48:02,900 --> 00:48:03,900
你不能，

957
00:48:04,340 --> 00:48:08,125
这就是为什么我说你想要选择一个碰撞率低的哈希函数，

958
00:48:08,125 --> 00:48:10,560
你不能保证这不会发生，

959
00:48:10,850 --> 00:48:14,750
但可以保证它会发生的可能性是低的，

960
00:48:16,330 --> 00:48:18,140
你唯一能得到的就是一个完美的哈希函数。

961
00:48:21,450 --> 00:48:21,935
他的问题，

962
00:48:21,935 --> 00:48:23,770
它默认是线性探测哈希吗，你是什么意思？

963
00:48:37,070 --> 00:48:40,830
哦，如果我跑出这个位置，

964
00:48:41,480 --> 00:48:43,200
要么是因为所有的 slot 都满了，

965
00:48:43,340 --> 00:48:46,200
要么是我试图做 Cuckoo 时绕回，

966
00:48:47,330 --> 00:48:48,360
你把它的大小加倍。

967
00:49:02,180 --> 00:49:04,385
是的，所以他的问题是，

968
00:49:04,385 --> 00:49:05,255
是否有一个定义的顺序，

969
00:49:05,255 --> 00:49:09,250
比如你可以总是检查第一个哈希，

970
00:49:09,510 --> 00:49:11,105
我显示的是两行，

971
00:49:11,105 --> 00:49:13,090
但在假设它，不平行的情况下，

972
00:49:13,350 --> 00:49:15,160
它是按顺序执行的，

973
00:49:15,330 --> 00:49:19,800
比如，有什么协议，检查这个，

974
00:49:20,700 --> 00:49:23,145
然后，只获取第二个页面，

975
00:49:23,145 --> 00:49:25,010
如果我知道它不会在那里，

976
00:49:25,240 --> 00:49:26,295
我的意思是，你可以做很多事情，

977
00:49:26,295 --> 00:49:29,010
这样你就可以预取第二页，

978
00:49:29,240 --> 00:49:30,625
因为哈希实际上很便宜。

979
00:49:30,625 --> 00:49:32,370
查找是很昂贵的，

980
00:49:32,870 --> 00:49:36,600
所以也许我我可以选一个，

981
00:49:37,610 --> 00:49:39,810
我有两个页面 ID ，我去查了一下，

982
00:49:40,220 --> 00:49:42,655
所以，如果我有一个方法，首先检查哪个存在，

983
00:49:42,655 --> 00:49:44,670
也许去检查那一下，预取另一个，

984
00:49:44,990 --> 00:49:46,800
同样，这取决于实现。

985
00:49:58,310 --> 00:50:01,510
但是，这取决于插入的是什么和你是如何移动的，

986
00:50:01,510 --> 00:50:06,360
但事实是我们提出了这么多。

987
00:50:10,020 --> 00:50:10,870
有别的女人吗，

988
00:50:12,690 --> 00:50:14,195
是要上厕所吗，

989
00:50:14,195 --> 00:50:14,770
他在干什么？

990
00:50:18,700 --> 00:50:19,725
无论什么，是的。

991
00:50:19,725 --> 00:50:21,495
所以我们有不同的方式来做这件事，

992
00:50:21,495 --> 00:50:23,505
这表明线性探测哈希是多复杂，

993
00:50:23,505 --> 00:50:25,610
你只是有点[]它。

994
00:50:31,760 --> 00:50:32,365
这个问题是，

995
00:50:32,365 --> 00:50:34,165
在一般系统中，默认的是什么，

996
00:50:34,165 --> 00:50:37,140
我不知道，我们可以去查一下 David 的代码，

997
00:50:37,400 --> 00:50:38,280
默认可能是[三]，

998
00:50:39,160 --> 00:50:40,320
我不知道，是的。

999
00:50:41,830 --> 00:50:42,230
好的。

1000
00:50:43,130 --> 00:50:46,660
我想讨论一下链式哈希，

1001
00:50:46,660 --> 00:50:48,960
因为我们的其中一个项目需要这个。

1002
00:50:50,710 --> 00:50:53,130
所以，到目前为止，我展示的所有这些协议，

1003
00:50:53,130 --> 00:50:54,830
都是静态哈希方案，

1004
00:50:55,000 --> 00:50:57,800
如果我们耗尽了空间或循环返回，

1005
00:50:58,060 --> 00:51:01,705
那么我们需要将哈希表的大小加倍并重新填充它，

1006
00:51:01,705 --> 00:51:02,310
这是很昂贵的。

1007
00:51:03,080 --> 00:51:07,500
所以，我们现在将讨论不同的技术来增量地调整哈希表的大小，

1008
00:51:07,760 --> 00:51:09,780
而不必重建整个哈希表。

1009
00:51:10,610 --> 00:51:12,745
最常见的方法是链式哈希，

1010
00:51:12,745 --> 00:51:15,150
当你想到哈希表时，大多数人都会想到这个，

1011
00:51:16,460 --> 00:51:18,360
然后我们看看两种更高级的技术，

1012
00:51:19,010 --> 00:51:21,930
在实际系统中所使用的。

1013
00:51:24,310 --> 00:51:26,420
所以链式哈希的基本思想是，

1014
00:51:27,150 --> 00:51:31,630
不是包含我们插入键的所有 slot 的巨大数组，

1015
00:51:33,300 --> 00:51:39,010
数组将是指向链表或链或桶的指针，

1016
00:51:39,270 --> 00:51:44,060
在我们的哈希表中映射到该 slot 的所有键

1017
00:51:44,290 --> 00:51:47,550
都将在那个链表中的 slot 中找到，

1018
00:51:47,960 --> 00:51:49,740
如果你在 Java 中分配一个 hashmap ，

1019
00:51:49,940 --> 00:51:51,000
这就是你所得到的。

1020
00:51:51,750 --> 00:51:54,730
链表部分基本上可以无限增长，

1021
00:51:55,080 --> 00:51:56,630
因为在最坏的情况下，

1022
00:51:56,630 --> 00:51:58,240
我的所有键都哈希到同一个 slot ，

1023
00:51:58,440 --> 00:52:00,400
我只是添加到这个巨大的列表中，

1024
00:52:00,810 --> 00:52:04,480
我落在，或者最终是以顺序扫描，

1025
00:52:04,860 --> 00:52:07,450
但是，理想情况下，如果我有一个好的哈希函数，

1026
00:52:07,680 --> 00:52:10,660
我不会，我会有一个很好的键分发。

1027
00:52:11,620 --> 00:52:12,740
考虑这一点的方法是，

1028
00:52:12,820 --> 00:52:15,530
我们实际上是在对我们的之前有的巨型哈希表进行分区，

1029
00:52:15,760 --> 00:52:19,760
分成了更小的哈希表本身，或者更小的表，

1030
00:52:20,530 --> 00:52:23,720
我们可以用我们以前做过的同样的技巧来获得唯一的键，

1031
00:52:24,640 --> 00:52:27,410
只要继续把多余的键添加到这个巨大的列表中，

1032
00:52:28,240 --> 00:52:29,360
我们仍然可以使用墓碑，

1033
00:52:29,410 --> 00:52:32,510
但在这种情况下，压缩通常会更快。

1034
00:52:34,300 --> 00:52:36,890
好的，现在我们有了桶指针，

1035
00:52:37,060 --> 00:52:39,680
这就是哈希函数要哈希的地方，

1036
00:52:40,000 --> 00:52:44,120
然后这些只是指向存在的不同桶的指针，

1037
00:52:44,800 --> 00:52:46,160
所以如果我们想把 A 放进去，

1038
00:52:46,240 --> 00:52:49,010
我们哈希它，用我们拥有的桶指针的数量来对它取模，

1039
00:52:49,240 --> 00:52:50,390
然后我们就落在那个桶里，

1040
00:52:50,440 --> 00:52:54,750
我们找到第一个空闲的 slot ，然后将其插入。

1041
00:52:55,520 --> 00:52:56,525
同样的，放入 B ，

1042
00:52:56,525 --> 00:52:58,600
B 就像以前一样放在顶部，

1043
00:52:59,840 --> 00:53:01,470
现在，对于 C 的情况，

1044
00:53:01,790 --> 00:53:05,670
C 哈希到 A 所在的同一个桶，

1045
00:53:05,930 --> 00:53:07,375
我们只需顺序扫描，

1046
00:53:07,375 --> 00:53:09,390
直到找到第一个空闲 slot 。

1047
00:53:12,730 --> 00:53:13,310
接了个电话？

1048
00:53:17,760 --> 00:53:20,930
你放入 D ， D 到了 A 的位置，

1049
00:53:21,100 --> 00:53:23,210
它扫过所有的 slot 都是空的，

1050
00:53:23,380 --> 00:53:24,585
你可以在页头中放一些东西，

1051
00:53:24,585 --> 00:53:25,820
然后说我没有更多的空闲 slot ，

1052
00:53:25,900 --> 00:53:28,490
因此，当你到达我时，总是要扩展我，这不重要，

1053
00:53:28,930 --> 00:53:33,170
然后，这个页面将指向另一个页面，

1054
00:53:33,520 --> 00:53:34,490
在那里你可以找到 D 。

1055
00:53:35,010 --> 00:53:36,040
然后我们想把 E 放在后面，

1056
00:53:36,450 --> 00:53:39,400
直到我们在这里找到 E 。

1057
00:53:40,430 --> 00:53:41,640
F 可以放在这里。

1058
00:53:43,540 --> 00:53:45,210
这样做的好处是，

1059
00:53:45,210 --> 00:53:49,430
我可以在一个桶中增加键列表，

1060
00:53:49,690 --> 00:53:53,560
而不会影响表的其他部分，

1061
00:53:54,260 --> 00:53:57,980
但是，你可以有一个两级的哈希表，

1062
00:53:57,980 --> 00:53:59,450
比如这样是一个哈希表，

1063
00:53:59,450 --> 00:54:01,990
把你带到另一个哈希表的这些桶中，

1064
00:54:02,790 --> 00:54:05,290
但是为了简单起见，我们只是把它显示为一个链表。

1065
00:54:06,890 --> 00:54:07,615
但这样做，

1066
00:54:07,615 --> 00:54:08,220
是的，问题。

1067
00:54:12,240 --> 00:54:12,770
他的问题是，

1068
00:54:12,770 --> 00:54:13,580
当你创建一个新的桶时，

1069
00:54:13,580 --> 00:54:14,920
如何确定它的大小？

1070
00:54:17,780 --> 00:54:18,750
我们不是在讨论，

1071
00:54:19,040 --> 00:54:20,500
在这节课上，我们没有讨论一些东西，

1072
00:54:20,500 --> 00:54:23,580
磁盘上或内存中的页面支持，

1073
00:54:24,020 --> 00:54:25,140
但如果它是，

1074
00:54:25,400 --> 00:54:29,460
假设它是由磁盘上的页面和缓冲池支持的，

1075
00:54:29,750 --> 00:54:31,830
无论数据库中的页面大小是多少，

1076
00:54:32,000 --> 00:54:33,450
都是桶的页面大小，

1077
00:54:34,620 --> 00:54:36,190
在 Postgres 中是 8 千字节，

1078
00:54:36,750 --> 00:54:38,530
MySQL 是 16 千字节。

1079
00:54:41,050 --> 00:54:43,365
我在一个页面展示了两个键，

1080
00:54:43,365 --> 00:54:44,540
因为它是幻灯片。

1081
00:54:46,750 --> 00:54:50,000
再说一次，如果我有很多键，哈希在同一个位置，

1082
00:54:50,320 --> 00:54:52,820
这种线性扫描可能会很昂贵，

1083
00:54:53,350 --> 00:54:55,820
实际上，你可以做一个非常简单的优化是，

1084
00:54:56,290 --> 00:54:57,650
在你的桶指针列表中，

1085
00:54:57,970 --> 00:54:59,600
你还可以存储布隆过滤器，

1086
00:55:00,840 --> 00:55:03,910
这告诉你，在我的链接列表中是否存在一个键，

1087
00:55:04,170 --> 00:55:05,710
所以，如果我现在想要查找 G ，

1088
00:55:06,060 --> 00:55:07,415
我首先检查布隆过滤器，

1089
00:55:07,415 --> 00:55:08,830
我问它是否存在，

1090
00:55:09,400 --> 00:55:12,010
如果是，那么我将继续沿着指针前进，

1091
00:55:12,010 --> 00:55:14,310
然后扫描到我寻找的东西，

1092
00:55:14,570 --> 00:55:16,715
如果不是，如果它说不是，

1093
00:55:16,715 --> 00:55:17,740
那我就不做扫描了，

1094
00:55:19,220 --> 00:55:21,480
这就避免了不得不进行额外的遍历。

1095
00:55:24,260 --> 00:55:25,500
大家都知道布隆过滤器是什么吗？

1096
00:55:26,730 --> 00:55:27,520
不，好的，

1097
00:55:28,930 --> 00:55:29,870
所以我就问了，等一下。

1098
00:55:31,600 --> 00:55:32,550
布隆过滤器很棒，

1099
00:55:32,550 --> 00:55:34,610
对很多东西都很有用。

1100
00:55:36,000 --> 00:55:36,970
好的，快一点，

1101
00:55:37,170 --> 00:55:39,100
布隆过滤器是一种概率数据结构，

1102
00:55:39,390 --> 00:55:42,100
它可以告诉你，可以回答集合成员身份查询，

1103
00:55:42,570 --> 00:55:44,830
过滤器不同于索引，

1104
00:55:44,940 --> 00:55:46,250
索引告诉你，

1105
00:55:46,250 --> 00:55:48,340
对于给定的键，它在哪里，

1106
00:55:48,690 --> 00:55:50,680
在这个记录 ID 中，在这个页面中，

1107
00:55:50,940 --> 00:55:52,300
过滤器只能说，

1108
00:55:52,560 --> 00:55:54,310
键是否存在，是还是不是，

1109
00:55:54,450 --> 00:55:55,570
不能告诉你它在哪里，

1110
00:55:55,590 --> 00:55:57,990
它只能告诉你它是否存在，

1111
00:55:58,610 --> 00:56:01,680
所以布隆过滤器，

1112
00:56:02,480 --> 00:56:04,950
这个人叫布隆，我想是从七十年代开始的，

1113
00:56:05,990 --> 00:56:09,480
所以布隆过滤器是一个概率数据结构，

1114
00:56:09,770 --> 00:56:13,590
这意味着它可以百分之百正确地告诉你，

1115
00:56:13,730 --> 00:56:15,150
一个键不存在，

1116
00:56:15,830 --> 00:56:18,190
但如果你，它可以告诉你键存在，

1117
00:56:18,190 --> 00:56:19,350
它可能实际上是错误的，

1118
00:56:20,120 --> 00:56:21,510
并给你假的肯定，

1119
00:56:22,710 --> 00:56:25,450
你只能在基本的布隆过滤器上做两个操作，

1120
00:56:25,500 --> 00:56:27,530
你可以执行 insert 和 lookup ，

1121
00:56:27,530 --> 00:56:28,600
你不能执行 delete ，

1122
00:56:29,320 --> 00:56:29,990
我们会知道为什么。

1123
00:56:31,200 --> 00:56:34,830
所以基本上可以认为它只是一个位图，

1124
00:56:35,560 --> 00:56:40,710
并且将根据插入的键来设置位，

1125
00:56:41,360 --> 00:56:44,130
假设我开始插入 Wu-Tang Clan 的成员，

1126
00:56:44,960 --> 00:56:45,990
所以我插入 RZA ，

1127
00:56:46,130 --> 00:56:49,050
所以我会有哈希函数，

1128
00:56:49,790 --> 00:56:50,880
我将再次对其进行哈希，

1129
00:56:50,990 --> 00:56:52,950
相同的哈希实现，只是不同的种子，

1130
00:56:53,330 --> 00:56:54,630
我得到了一些哈希值，

1131
00:56:54,920 --> 00:56:59,220
然后根据我的布隆滤器中的位数对其进行取模，

1132
00:56:59,690 --> 00:57:02,850
然后不管这个数字是什么，我都会将这些位设置为 1 ，

1133
00:57:04,210 --> 00:57:05,270
把它从 0 翻转到 1 ，

1134
00:57:06,030 --> 00:57:06,970
我插入 GZA ，

1135
00:57:07,230 --> 00:57:08,650
同样的东西，对其进行哈希，

1136
00:57:09,090 --> 00:57:11,710
对位数取模，并将这些位设置为 1 ，

1137
00:57:12,610 --> 00:57:14,660
现在如果我想查看 RZA ，

1138
00:57:15,790 --> 00:57:17,480
同样的东西，我只是做，

1139
00:57:18,100 --> 00:57:20,910
哈希我要查找的键，对位数取模，

1140
00:57:20,910 --> 00:57:22,245
然后我去检查，

1141
00:57:22,245 --> 00:57:26,720
是否我哈希的所有位的位置，

1142
00:57:26,980 --> 00:57:28,070
它们是否设置为 1 ，

1143
00:57:28,330 --> 00:57:29,390
如果它们设置为 1 ，

1144
00:57:29,440 --> 00:57:32,390
那么我知道这是设置，

1145
00:57:34,960 --> 00:57:35,680
如果它设置为 1 ，

1146
00:57:35,680 --> 00:57:38,170
那么我认为它可能存在，

1147
00:57:38,170 --> 00:57:39,025
但我可能错了，

1148
00:57:39,025 --> 00:57:42,780
因为可能是其他东西设置了这些位，

1149
00:57:42,830 --> 00:57:44,040
所以，对于这个，我会得到 TRUE ，

1150
00:57:44,300 --> 00:57:46,170
如果我查找 Raekwon, Chef ，

1151
00:57:46,920 --> 00:57:48,120
同样，当我进行查找时，

1152
00:57:48,120 --> 00:57:49,580
其中一位被设置为 0 ，

1153
00:57:49,930 --> 00:57:51,645
所以我知道不可能插入，

1154
00:57:51,645 --> 00:57:54,290
因为否则这些位中的一位，所有这些位都会被设置，

1155
00:57:54,400 --> 00:57:55,160
所以我得到了 FALSE ，

1156
00:57:55,540 --> 00:57:57,530
但我查找 ODB ，已经去世了，

1157
00:57:57,970 --> 00:57:59,505
现在我得到一个假的肯定，

1158
00:57:59,505 --> 00:58:00,720
因为我从未插入它，

1159
00:58:00,720 --> 00:58:02,750
但是他的位被设置为 1 ，

1160
00:58:03,310 --> 00:58:07,080
因此，这是 TRUE ，但实际上是错的。

1161
00:58:08,280 --> 00:58:11,650
所以你可以把那个布隆过滤器放在你的[桶链]前面，

1162
00:58:12,400 --> 00:58:16,890
然后，它将填充为实际插入到其中的键设置的位，

1163
00:58:16,940 --> 00:58:18,370
我可以增量地维护它，

1164
00:58:18,370 --> 00:58:22,380
因为每次我在桶列表中插入新的键时，

1165
00:58:22,460 --> 00:58:24,860
我都会更新我的布隆过滤器。

1166
00:58:25,720 --> 00:58:27,240
布隆过滤器有不同的变体，

1167
00:58:27,240 --> 00:58:28,245
你可以有不同级别的它们，

1168
00:58:28,245 --> 00:58:29,240
你有衰减的，

1169
00:58:29,650 --> 00:58:32,300
布隆过滤器的大小可以改变它们的哈希函数，

1170
00:58:32,380 --> 00:58:33,270
有一大堆不同的东西，

1171
00:58:33,270 --> 00:58:35,070
但像这样的数据结构是非常有用的，

1172
00:58:35,070 --> 00:58:36,330
我们在整个系统中使用。

1173
00:58:36,330 --> 00:58:40,360
是的。他的问题是，

1174
00:58:40,360 --> 00:58:41,860
假的肯定率是怎么变化的，

1175
00:58:41,860 --> 00:58:42,625
当你[设置]布隆过滤器时，

1176
00:58:42,625 --> 00:58:43,990
有一些公式说，

1177
00:58:43,990 --> 00:58:46,890
如果你想要 1% 的假的肯定率，

1178
00:58:46,970 --> 00:58:48,540
你需要有一个这种大小的布隆过滤器，

1179
00:58:48,590 --> 00:58:50,395
但这个[]哈希函数。

1180
00:58:50,395 --> 00:58:53,910
他的问题是指数的还是线性的，

1181
00:58:53,990 --> 00:58:55,180
我不知道，我不记得，

1182
00:58:55,180 --> 00:58:55,830
但是这里，

1183
00:58:57,060 --> 00:58:59,230
这个网站在这里，布隆过滤器计算器，

1184
00:58:59,250 --> 00:59:00,790
你说你想要的假的肯定率，

1185
00:59:00,870 --> 00:59:01,655
你有多少个键，

1186
00:59:01,655 --> 00:59:04,060
它就会告诉你想要的布隆过滤器的大小，

1187
00:59:04,290 --> 00:59:06,790
然后是哈希函数的数量。

1188
00:59:07,690 --> 00:59:08,090
是的。

1189
00:59:10,920 --> 00:59:12,670
问题是，布隆过滤器如何删除，

1190
00:59:13,010 --> 00:59:14,950
它们不删除，是的，

1191
00:59:16,850 --> 00:59:20,100
它们有多层次的变体，

1192
00:59:20,270 --> 00:59:21,870
对于基本的那个，它们不删除。

1193
00:59:23,500 --> 00:59:24,860
布隆过滤器非常有用，

1194
00:59:24,970 --> 00:59:27,585
我们会在整个系统中以多种方式使用它，

1195
00:59:27,585 --> 00:59:28,850
我们用它来做哈希 Join 。

1196
00:59:29,880 --> 00:59:31,580
因为，这是一个便宜得多的查找，

1197
00:59:31,580 --> 00:59:33,010
查看它是否在我的布隆过滤器中，

1198
00:59:33,330 --> 00:59:36,380
比实际上跟踪一个页面，并在磁盘上查看，

1199
00:59:36,380 --> 00:59:37,570
看看东西是否存在。

1200
00:59:44,240 --> 00:59:47,040
一个更复杂的方案被称为可扩展哈希，

1201
00:59:47,640 --> 00:59:49,155
这就像链式哈希一样，

1202
00:59:49,155 --> 00:59:53,060
但是，我们将允许，

1203
00:59:53,290 --> 00:59:54,495
我们将能够拆分桶，

1204
00:59:54,495 --> 00:59:57,500
以避免这些无限长的桶列表，

1205
00:59:57,790 --> 00:59:58,875
我们将以这样一种方式拆分它，

1206
00:59:58,875 --> 01:00:03,645
我们只需要在哈希表的一小部分中递增，

1207
01:00:03,645 --> 01:00:05,630
而不必重新哈希所有内容。

1208
01:00:06,560 --> 01:00:08,515
这个方法的关键思想是，

1209
01:00:08,515 --> 01:00:11,100
我们要扩展我们必须查看的位数，

1210
01:00:11,450 --> 01:00:14,400
当我们在桶列表或桶哈希表中查找时，

1211
01:00:14,750 --> 01:00:17,310
以找到我们要查找的桶链，

1212
01:00:17,660 --> 01:00:24,915
我们可以对每个键类型改变它，

1213
01:00:24,915 --> 01:00:30,560
不是键类型，我们可以根据我们看到的桶列表来改变这个，

1214
01:00:30,940 --> 01:00:32,390
所以情况可能是这样的，

1215
01:00:32,980 --> 01:00:36,990
两个不同的位置，在我们的桶数组中的多个位置，将指向同一个桶列表，

1216
01:00:37,220 --> 01:00:38,695
但是它可以扩展和分解，

1217
01:00:38,695 --> 01:00:40,050
随着我们的需要。

1218
01:00:40,810 --> 01:00:42,960
所以我并不认为，

1219
01:00:42,960 --> 01:00:44,300
这有点复杂，

1220
01:00:44,350 --> 01:00:46,370
我不认为任何系统真正使用它，

1221
01:00:46,600 --> 01:00:50,820
但事实是 GDBM ，也就是 GNU 数据库管理器，

1222
01:00:50,820 --> 01:00:53,600
可以认为是一个键值存储，

1223
01:00:54,040 --> 01:00:56,355
比如 RocksDB 或 SQLite ，

1224
01:00:56,355 --> 01:00:57,830
你可以运行这个程序，并嵌入到你的系统中，

1225
01:00:58,720 --> 01:01:00,650
这个数据库将你连接到可扩展哈希表上，

1226
01:01:01,030 --> 01:01:05,060
然后 AsteriskDB 是 UC Irvine 的一个大数据项目，

1227
01:01:05,650 --> 01:01:09,100
他们在他们的实现中使用了可扩展哈希。

1228
01:01:10,240 --> 01:01:10,860
让我们看看这是如何工作的。

1229
01:01:12,090 --> 01:01:13,565
好的，我们首先要做的是，

1230
01:01:13,565 --> 01:01:14,855
我们有 slot 数组，

1231
01:01:14,855 --> 01:01:16,000
它将指向我们的 bucket 列表，

1232
01:01:16,740 --> 01:01:19,670
然后我们将有一个全局标识符，

1233
01:01:19,900 --> 01:01:23,120
它告诉我们需要查找多少位来查找哈希值，

1234
01:01:23,410 --> 01:01:27,020
以确定如何在桶数组中进行查找，

1235
01:01:27,860 --> 01:01:29,940
然后出于[记账]的原因，

1236
01:01:30,230 --> 01:01:34,590
每个桶列表中也将包含我们的本地位大小，

1237
01:01:34,610 --> 01:01:35,760
它们需要查看的位数。

1238
01:01:36,260 --> 01:01:37,390
所以你可以在这里看到，

1239
01:01:38,370 --> 01:01:39,760
这里的前两个 slot ，

1240
01:01:39,840 --> 01:01:42,010
它们都指向相同的桶列表，

1241
01:01:42,150 --> 01:01:43,480
而底部的这两个，

1242
01:01:43,740 --> 01:01:45,250
它们指向不同的位置，

1243
01:01:46,770 --> 01:01:48,160
这是因为，

1244
01:01:50,540 --> 01:01:51,420
我们需要查看，

1245
01:01:51,680 --> 01:01:53,160
全局上，我们将查看两个位，

1246
01:01:53,540 --> 01:01:56,730
但对于前两个条目，

1247
01:01:57,050 --> 01:02:00,060
当位为 0 时，

1248
01:02:00,740 --> 01:02:02,850
它们将重复使用相同的桶列表，

1249
01:02:03,140 --> 01:02:05,760
由本地标识符来标识。

1250
01:02:07,800 --> 01:02:11,050
现在假设我们想要查看这个键，

1251
01:02:11,280 --> 01:02:12,160
我哈希它，

1252
01:02:12,420 --> 01:02:14,315
然后我查看最上面的两位，

1253
01:02:14,315 --> 01:02:17,440
因为它设置了我的全局标识符，全局计数器，

1254
01:02:18,570 --> 01:02:19,865
然后我哈希到这个位置，

1255
01:02:19,865 --> 01:02:20,920
我只需跟随指针，

1256
01:02:20,970 --> 01:02:22,145
然后落在那个桶里，

1257
01:02:22,145 --> 01:02:23,885
我就可以进行线性搜索，

1258
01:02:23,885 --> 01:02:25,060
找到我正在寻找的东西。

1259
01:02:27,360 --> 01:02:28,450
假设现在我想放入 B ，

1260
01:02:30,170 --> 01:02:33,390
B ，再次在全局上，我需要看看上面的两个部分，

1261
01:02:33,770 --> 01:02:37,050
我查找我的桶列表，

1262
01:02:37,640 --> 01:02:38,520
基于这两个位，

1263
01:02:38,900 --> 01:02:40,345
然后我落在这里这个地方，

1264
01:02:40,345 --> 01:02:41,910
我继续并插入它。

1265
01:02:42,850 --> 01:02:44,150
但现在我想放入 C ，

1266
01:02:44,840 --> 01:02:46,990
如果我看最后两个位，

1267
01:02:47,250 --> 01:02:49,270
它落在我插入 B 时的相同位置，

1268
01:02:49,530 --> 01:02:51,160
但现在这个桶是满的，

1269
01:02:51,600 --> 01:02:52,990
我不能再放入更多的条目，

1270
01:02:53,490 --> 01:02:56,045
所以我需要扩展我正在查看的位数，

1271
01:02:56,045 --> 01:02:58,840
以扩展我拥有的选项数，

1272
01:02:59,220 --> 01:03:02,320
所以我要将全局计数器从 2 增加到 3 ，

1273
01:03:03,060 --> 01:03:07,940
我将把桶数组中的指针数增加一倍，

1274
01:03:08,690 --> 01:03:11,340
然后创建新的条目，

1275
01:03:11,510 --> 01:03:15,060
但是当位设置为 0 时，

1276
01:03:15,320 --> 01:03:17,790
它们仍然指向这里的第一个桶，

1277
01:03:17,990 --> 01:03:19,470
因为我还没有那个桶，

1278
01:03:19,610 --> 01:03:21,390
所以我需要为它寻找一个位，

1279
01:03:22,100 --> 01:03:25,620
对于下一个，当位是 111 时，

1280
01:03:26,000 --> 01:03:28,020
它指向下面的另一个桶，

1281
01:03:28,250 --> 01:03:31,000
其他的也是一样的。

1282
01:03:31,690 --> 01:03:33,800
所以现在，当我想要进行查找放入 C 时，

1283
01:03:33,880 --> 01:03:35,090
我需要查看三个位，

1284
01:03:35,380 --> 01:03:36,735
我顺着那个指针，

1285
01:03:36,735 --> 01:03:38,360
走到了这个桶的位置。

1286
01:03:41,270 --> 01:03:42,010
所以回到这里，

1287
01:03:42,010 --> 01:03:42,960
当我进行拆分时，

1288
01:03:43,750 --> 01:03:44,900
我必须调整大小，

1289
01:03:45,490 --> 01:03:47,310
这些家伙滑下去，

1290
01:03:47,310 --> 01:03:50,060
我只需要插入一个新的桶，

1291
01:03:51,070 --> 01:03:52,460
但我获取这里的东西，

1292
01:03:52,600 --> 01:03:53,510
因为这个是满的，

1293
01:03:53,590 --> 01:03:54,690
我只是把那个f拆分，

1294
01:03:54,690 --> 01:03:55,820
然后为它创建了一个新的桶，

1295
01:03:55,930 --> 01:03:57,285
我不需要访问底部的那个，

1296
01:03:57,285 --> 01:03:58,490
也不需要访问顶部的那个，

1297
01:04:00,450 --> 01:04:01,940
我确实要把这个的大小翻倍，

1298
01:04:01,940 --> 01:04:03,010
但那是，

1299
01:04:05,230 --> 01:04:06,765
当你这样做的时候，你必须锁住它，

1300
01:04:06,765 --> 01:04:09,620
因为你必须复制并调整它的大小，

1301
01:04:09,670 --> 01:04:11,450
这没什么大不了的，

1302
01:04:11,770 --> 01:04:12,710
你可以很快做到这个。

1303
01:04:18,220 --> 01:04:19,070
对于这个，有什么问题吗？

1304
01:04:21,760 --> 01:04:22,430
这个好吗？

1305
01:04:25,580 --> 01:04:28,660
所以，调整这种 slot 数组的大小相对便宜，

1306
01:04:30,570 --> 01:04:31,870
这很聪明，这是个好主意，

1307
01:04:33,180 --> 01:04:34,205
这是一个聪明的主意，

1308
01:04:34,205 --> 01:04:35,230
不管它是好是坏，

1309
01:04:36,740 --> 01:04:39,255
它，从工程角度来说，

1310
01:04:39,255 --> 01:04:41,460
跟踪所有元数据的位置有点棘手，

1311
01:04:41,460 --> 01:04:47,130
我需要看什么位，作为对它的哈希，

1312
01:04:48,470 --> 01:04:50,610
但这基本上只是链式哈希，

1313
01:04:50,660 --> 01:04:54,070
所以，我从链式哈希中获得的所有好处都适用于这里，

1314
01:04:54,070 --> 01:04:56,245
我现在有一个额外的机制来拆分东西，

1315
01:04:56,245 --> 01:05:00,770
这样我就不会有无限增长的链表，

1316
01:05:02,380 --> 01:05:05,330
所以，这只是一种处理增量调整大小的方法，

1317
01:05:05,740 --> 01:05:08,720
以一种普通链式哈希中做不到的方法。

1318
01:05:10,530 --> 01:05:10,930
是的。

1319
01:05:13,830 --> 01:05:14,380
我认为。

1320
01:05:14,970 --> 01:05:18,040
是的，线性探测可能是最容易做的事情，

1321
01:05:18,360 --> 01:05:21,280
锁定整个表并使其大小翻倍，

1322
01:05:22,620 --> 01:05:23,180
有时候已经足够好了。

1323
01:05:27,640 --> 01:05:31,190
好的，最后一种是线性哈希，

1324
01:05:32,110 --> 01:05:33,320
这实际上就是 Postgres 所做的，

1325
01:05:34,300 --> 01:05:35,750
非常接近这个的东西。

1326
01:05:36,440 --> 01:05:37,660
为什么 Postgres （这么做）的原因，

1327
01:05:38,610 --> 01:05:40,990
好的，另一个 Bekeley DB 也做了这个，

1328
01:05:42,810 --> 01:05:46,150
创建 Berkeley DB 的公司是一家名为 Sleepycat Software 的公司，

1329
01:05:46,800 --> 01:05:49,030
所以，创建 WiredTiger 的人，

1330
01:05:49,260 --> 01:05:53,495
他们最初创建了 Sleepycat ，后来卖给了 Oracle ，

1331
01:05:53,495 --> 01:05:55,300
所以 Oracle 拥有 Berkeley DB ，

1332
01:05:55,560 --> 01:05:56,980
然后他们走出去，开始了新的公司，

1333
01:05:57,120 --> 01:05:58,955
不是叫 Sleepycat ，而是叫 WiredTiger ，

1334
01:05:58,955 --> 01:06:02,650
就像[]的老虎，

1335
01:06:03,600 --> 01:06:04,895
它试图相反，

1336
01:06:04,895 --> 01:06:09,940
但是，但是在 90 年代早期为 Postgres 编写线性哈希实现的女人，

1337
01:06:10,260 --> 01:06:11,740
是 Berkeley DB 的创始人，

1338
01:06:11,790 --> 01:06:12,860
所以她为 Postgres 写了它，

1339
01:06:12,860 --> 01:06:13,900
然后为 Berkeley DB 写了它，

1340
01:06:14,360 --> 01:06:20,140
她是 Stonebraker 在 Berkeley 的一名学生。

1341
01:06:20,490 --> 01:06:25,900
所以，线性哈希可能比可扩展哈希更复杂，

1342
01:06:25,920 --> 01:06:28,535
但是，基本的想法是，

1343
01:06:28,535 --> 01:06:36,060
我们要跟踪下一个我们要拆分的桶列表，

1344
01:06:36,740 --> 01:06:42,035
并且当任何时候在我们的桶列表链有溢出时，

1345
01:06:42,035 --> 01:06:43,210
在我们的哈希表中的任何地方，

1346
01:06:43,740 --> 01:06:45,670
无论我们拆分指针指向什么，

1347
01:06:45,720 --> 01:06:47,470
那就是我们要拆分的。

1348
01:06:48,100 --> 01:06:49,165
这里的想法是，

1349
01:06:49,165 --> 01:06:50,760
我们想增量地做这件事，

1350
01:06:51,110 --> 01:06:53,280
而不是在调整大小时锁定整个表，

1351
01:06:53,570 --> 01:06:55,920
这样我们就可以在进行时做一些小的修改。

1352
01:06:56,520 --> 01:06:57,330
这里的想法是，

1353
01:06:57,330 --> 01:06:59,060
你摊销了调整大小的成本，

1354
01:06:59,110 --> 01:07:01,500
就像它是在多个 worker 之间分摊的，

1355
01:07:01,500 --> 01:07:04,490
所以只有一个不幸的 worker 出现，

1356
01:07:04,600 --> 01:07:05,570
试图插入一些东西，

1357
01:07:05,950 --> 01:07:08,175
然后，它们抽到了短签，

1358
01:07:08,175 --> 01:07:09,800
它们要对调整整个大小的事情负责，

1359
01:07:09,910 --> 01:07:12,075
你在进行的过程中逐步地做，

1360
01:07:12,075 --> 01:07:13,370
这样会使性能变得平滑。

1361
01:07:14,460 --> 01:07:16,190
所以，这里的想法是，

1362
01:07:16,295 --> 01:07:20,190
我们会拆分，

1363
01:07:21,590 --> 01:07:23,370
拆分下一个我们需要拆分的，

1364
01:07:23,450 --> 01:07:24,940
这可能不是溢出的，

1365
01:07:24,940 --> 01:07:28,320
它应该是按照我们的递增顺序的下一个，

1366
01:07:28,910 --> 01:07:31,540
然后我们需要维护多个哈希函数，

1367
01:07:31,540 --> 01:07:33,060
这些函数将帮助我们确定，

1368
01:07:35,380 --> 01:07:39,560
在我们的桶列表中，我们应该关注哪个位置。

1369
01:07:40,720 --> 01:07:42,380
让我来分享这张图表，让这更有意义。

1370
01:07:43,850 --> 01:07:44,740
所以，在我们开始之前先看看，

1371
01:07:44,740 --> 01:07:46,470
我们这里有我们的桶列表，

1372
01:07:46,640 --> 01:07:49,770
它将映射到桶链，

1373
01:07:50,500 --> 01:07:51,760
然后我们会有一个拆分指针，

1374
01:07:51,760 --> 01:07:52,240
它会说，

1375
01:07:52,240 --> 01:07:54,030
这是我们想要随时拆分的下一个东西，

1376
01:07:54,500 --> 01:07:56,490
我们的哈希表中的会溢出的任何东西，

1377
01:07:57,290 --> 01:07:58,800
然后，在最开始，我们有，

1378
01:07:59,000 --> 01:08:00,250
我们假设我们有一个哈希函数，

1379
01:08:00,250 --> 01:08:07,440
只有键对 n 取模，为了简单起见，

1380
01:08:07,670 --> 01:08:11,575
但再次假设它接受任意字符串或任意字节序列，

1381
01:08:11,575 --> 01:08:13,080
并产生整数。

1382
01:08:14,160 --> 01:08:16,180
假设我想要获取 6 ，

1383
01:08:17,280 --> 01:08:19,940
我在 2 做我的查找，

1384
01:08:19,940 --> 01:08:21,790
我跟随着，找到了我查找的键，

1385
01:08:22,650 --> 01:08:24,430
看起来和以前一样，没有什么特别的，

1386
01:08:25,020 --> 01:08:26,080
但现在我想放 17 ，

1387
01:08:26,760 --> 01:08:29,440
它应该放到这个桶里，

1388
01:08:29,730 --> 01:08:30,850
但那个东西已经满了，

1389
01:08:31,400 --> 01:08:33,040
所以我们只是要做一个溢出，

1390
01:08:33,600 --> 01:08:36,820
就像链哈希一样，用另一个桶来扩展它，

1391
01:08:37,080 --> 01:08:41,530
并将它插入到新页面中，

1392
01:08:42,150 --> 01:08:44,290
但是现在，因为我们已经溢出了，

1393
01:08:45,030 --> 01:08:48,010
我们都需要拆分，无论拆分指针指向哪里，

1394
01:08:48,640 --> 01:08:49,345
所以在本例中，

1395
01:08:49,345 --> 01:08:53,160
它指向桶列表 0 ，

1396
01:08:53,660 --> 01:08:55,050
即使它没有溢出，

1397
01:08:56,080 --> 01:08:57,150
所以我们现在需要做的是，

1398
01:08:57,150 --> 01:08:59,660
查看这个桶列表中的所有条目，

1399
01:09:00,010 --> 01:09:04,460
然后我们将基于 2n 对它们进行重新哈希，

1400
01:09:05,160 --> 01:09:10,210
因为我们每次都会递增一个桶列表的大小，

1401
01:09:10,650 --> 01:09:12,040
所以我们有四个条目，

1402
01:09:12,330 --> 01:09:14,560
现在，在我们拆分之后，我们将有五个，

1403
01:09:15,880 --> 01:09:18,380
所以我们遍历，这个指向那里，

1404
01:09:18,430 --> 01:09:19,335
对于每个单独的键，

1405
01:09:19,335 --> 01:09:20,190
我们将重新哈希它，

1406
01:09:20,190 --> 01:09:22,940
基于，不是对 n ，而是对 2n 取模，

1407
01:09:23,410 --> 01:09:25,200
所以 8 对 8 取模是 0 ，

1408
01:09:25,200 --> 01:09:26,150
所以它停留在它的地方，

1409
01:09:26,650 --> 01:09:28,370
20 对 8 取模现在是 4 ，

1410
01:09:28,570 --> 01:09:32,530
所以它将被移到下面这一页，

1411
01:09:33,820 --> 01:09:36,230
然后现在拆分指针向下移动一位，

1412
01:09:37,180 --> 01:09:38,490
我们将继续执行，

1413
01:09:38,490 --> 01:09:42,070
在哈希表上继续执行操作。

1414
01:09:43,940 --> 01:09:45,000
所以现在执行获取 20 ，

1415
01:09:45,760 --> 01:09:49,470
当我第一次哈希它的时候，我会得到 0 ，

1416
01:09:49,940 --> 01:09:54,750
但我知道那个位置在我的桶列表这里，

1417
01:09:54,950 --> 01:09:57,750
在拆分指针指向的上方，

1418
01:09:57,860 --> 01:10:00,240
我知道我已经把上面的所有东西都拆分了，

1419
01:10:00,640 --> 01:10:02,760
所以在我对 4 取模之后，

1420
01:10:02,960 --> 01:10:04,390
现在我对 8 取模，

1421
01:10:04,390 --> 01:10:05,730
以确定它的实际位置，

1422
01:10:06,170 --> 01:10:08,310
然后就是我如何在底部找到它的方法。

1423
01:10:10,610 --> 01:10:11,520
假设我想获取 9 ，

1424
01:10:11,930 --> 01:10:12,805
在这种情况下，

1425
01:10:12,805 --> 01:10:15,930
它指向拆分指针所指向的桶的位置，

1426
01:10:16,010 --> 01:10:17,400
所以我还没有拆分它，

1427
01:10:17,570 --> 01:10:19,170
所以我只对它进行一次哈希，

1428
01:10:19,400 --> 01:10:21,130
然后沿着链表扫描，

1429
01:10:21,130 --> 01:10:22,380
直到找到我要找的东西。

1430
01:10:27,350 --> 01:10:30,030
在某一时刻，拆分指针将到达底部，

1431
01:10:30,650 --> 01:10:32,370
我将有八个 slot ，

1432
01:10:32,690 --> 01:10:34,740
我只是循环回来，从头开始。

1433
01:10:37,430 --> 01:10:39,190
所以这看起来有点违反直觉，

1434
01:10:39,190 --> 01:10:40,980
好像我没有拆分溢出的东西，

1435
01:10:41,180 --> 01:10:43,110
我拆分到拆分指针所指向的位置，

1436
01:10:43,960 --> 01:10:45,380
但我们的想法是，

1437
01:10:45,490 --> 01:10:49,460
如果你说这个位置 1 ，

1438
01:10:49,660 --> 01:10:50,775
这个东西非常热，

1439
01:10:50,775 --> 01:10:52,250
我不停地溢出，溢出，

1440
01:10:53,710 --> 01:10:55,640
我最终会拆分它，

1441
01:10:56,730 --> 01:11:00,760
最终，所有东西都会被拆分并正确地调整大小。

1442
01:11:04,490 --> 01:11:04,890
是的。

1443
01:11:19,220 --> 01:11:20,500
所以问题是，

1444
01:11:20,500 --> 01:11:22,920
什么时候它会绕回，因为[]1 ，

1445
01:11:23,030 --> 01:11:24,180
你就会到达指针，

1446
01:11:25,230 --> 01:11:27,190
所以它是 5 6 7 ，

1447
01:11:27,360 --> 01:11:28,630
然后你就是 7 ，

1448
01:11:29,100 --> 01:11:32,345
然后你必须循环回到 0 ，

1449
01:11:32,345 --> 01:11:33,100
因为你知道，

1450
01:11:34,320 --> 01:11:36,190
从它在这里的时候，

1451
01:11:36,720 --> 01:11:38,200
当它只从 0 到 3 的时候，

1452
01:11:40,580 --> 01:11:42,305
是的，一旦过了 7 ，

1453
01:11:42,305 --> 01:11:44,060
你就知道你的起点了，

1454
01:11:44,060 --> 01:11:46,660
从你开始的地方算起是 2n ，

1455
01:11:46,740 --> 01:11:47,830
然后你又循环回来。

1456
01:11:53,450 --> 01:11:54,460
你添加了一个新的页面，

1457
01:11:54,460 --> 01:11:56,155
但我知道我应该绕过去，

1458
01:11:56,155 --> 01:11:59,840
当我到达 8 时，在位置 8 ，

1459
01:12:00,070 --> 01:12:02,270
因为我开始的时候，有 4 ，

1460
01:12:02,500 --> 01:12:03,915
所以 2 乘以 4 等于 8 ，

1461
01:12:03,915 --> 01:12:05,540
所以当我超过 8 的时候，我循环回来，

1462
01:12:05,890 --> 01:12:07,370
然后你一直这样做，直到你得到 16 ，

1463
01:12:07,450 --> 01:12:08,360
然后循环回来。

1464
01:12:15,280 --> 01:12:16,400
好主意还是坏主意？

1465
01:12:22,920 --> 01:12:23,920
这很聪明，对吧，

1466
01:12:24,030 --> 01:12:27,220
再说一次，这是一个很好的技巧，增量地做这件事，

1467
01:12:28,440 --> 01:12:31,000
但是，有更多的[簿记]，更多的机器，

1468
01:12:31,660 --> 01:12:32,790
为了真正实现这些。

1469
01:12:33,690 --> 01:12:34,090
是的。

1470
01:12:38,610 --> 01:12:39,800
这个问题是，

1471
01:12:39,800 --> 01:12:40,850
如果你只做查找，

1472
01:12:40,850 --> 01:12:42,280
你最多只做两次哈希，

1473
01:12:42,450 --> 01:12:43,450
在这个场景中，是的。

1474
01:12:45,480 --> 01:12:47,045
如果这个东西很大，

1475
01:12:47,045 --> 01:12:47,920
我可以说，

1476
01:12:48,240 --> 01:12:49,450
是的，所以实际上发生的事情是，

1477
01:12:50,310 --> 01:12:53,650
一旦我说，到达 8 ，我绕回，

1478
01:12:53,820 --> 01:12:55,330
我可以去掉第一个哈希函数，

1479
01:12:55,650 --> 01:12:56,780
是的，那么在这种情况下，

1480
01:12:56,780 --> 01:12:57,670
你最多会哈希两次。

1481
01:13:02,430 --> 01:13:02,830
是的。

1482
01:13:19,830 --> 01:13:20,590
他的问题是，

1483
01:13:22,390 --> 01:13:25,070
现在我试着对 8 取模，

1484
01:13:25,900 --> 01:13:28,070
但如果我获取 7 ，但我没有呢，

1485
01:13:28,270 --> 01:13:30,630
但是，你得不到 7 ，

1486
01:13:30,630 --> 01:13:35,160
因为，你会在拆分指针之下，

1487
01:13:35,160 --> 01:13:39,495
你只会以 4 哈希，而不是 8 ，

1488
01:13:39,495 --> 01:13:41,550
所以，这条分界线是说，

1489
01:13:41,550 --> 01:13:44,090
我把所有东西都拆分到上面，下面什么也没有，

1490
01:13:44,560 --> 01:13:45,380
避免这个问题，

1491
01:13:45,790 --> 01:13:47,070
你不会落在这里，

1492
01:13:47,070 --> 01:13:48,680
你不会，

1493
01:13:49,310 --> 01:13:50,815
你不会先哈希，然后落在这里，

1494
01:13:50,815 --> 01:13:52,255
但如果你对 2n 哈希，

1495
01:13:52,255 --> 01:13:54,000
你落在这里，你还没有拆分，

1496
01:13:54,870 --> 01:13:57,040
拆分指针水位线避免了这个问题。

1497
01:14:04,330 --> 01:14:05,000
好的，所以，

1498
01:14:06,500 --> 01:14:07,830
拆分桶基于拆分指针，

1499
01:14:08,270 --> 01:14:10,200
最终会导致所有桶溢出，

1500
01:14:11,780 --> 01:14:13,940
再次，当你到达底部时，

1501
01:14:13,940 --> 01:14:16,270
你只需丢弃第一个哈希函数，然后循环返回，

1502
01:14:17,880 --> 01:14:21,490
在这个技巧上，

1503
01:14:21,720 --> 01:14:25,840
也能让你做到缩写或合并，

1504
01:14:26,280 --> 01:14:30,250
因为你可以确定桶列表是空的，

1505
01:14:31,130 --> 01:14:32,620
而你可以做相反的事情，

1506
01:14:32,620 --> 01:14:34,410
你可以把它扔掉，

1507
01:14:34,820 --> 01:14:37,510
把空的那个桶[巩固]起来，

1508
01:14:37,510 --> 01:14:39,000
比如你可以扔掉它，

1509
01:14:39,110 --> 01:14:40,530
然后把拆分指针向上移动，

1510
01:14:41,410 --> 01:14:44,860
最后，你实际上缩小了哈希表的大小。

1511
01:14:44,860 --> 01:14:45,720
所以回到这里，

1512
01:14:46,010 --> 01:14:46,980
假设我删除 20 ，

1513
01:14:48,680 --> 01:14:50,010
我把它对 4 取模，

1514
01:14:50,450 --> 01:14:52,495
但我意识到它在拆分指针的下方，

1515
01:14:52,495 --> 01:14:54,240
我必须深入到底部，

1516
01:14:54,560 --> 01:14:55,680
然后继续删除它，

1517
01:14:55,940 --> 01:14:57,150
但现在这一页是空的，

1518
01:14:58,070 --> 01:14:59,035
所以如果我想，

1519
01:14:59,035 --> 01:15:00,930
我可以把指针移回去，

1520
01:15:01,310 --> 01:15:02,800
然后删除最后一个条目，

1521
01:15:02,800 --> 01:15:05,380
删除最后一个哈希表。

1522
01:15:05,940 --> 01:15:07,370
显然你需要聪明点，

1523
01:15:07,370 --> 01:15:09,680
确保我不会振荡，

1524
01:15:09,680 --> 01:15:11,315
比如，插入 20 ，删除 20 ，插入 20 ，

1525
01:15:11,315 --> 01:15:13,030
我不断地拆分和合并，

1526
01:15:13,110 --> 01:15:13,870
那就糟了。

1527
01:15:15,540 --> 01:15:19,520
但你可以在这个基础上压缩数据结构。

1528
01:15:19,780 --> 01:15:21,510
你不想插入 21 ，然后溢出，

1529
01:15:21,510 --> 01:15:22,760
再一次拆分。

1530
01:15:26,220 --> 01:15:30,250
我不认为 Postgres 支持缩小哈希表的大小，

1531
01:15:31,470 --> 01:15:32,075
据我所知，

1532
01:15:32,075 --> 01:15:33,340
没有重建整个东西。

1533
01:15:38,580 --> 01:15:41,260
好的，哈希表非常有用，

1534
01:15:41,820 --> 01:15:44,260
大多数系统只实现了线性探测哈希，

1535
01:15:44,370 --> 01:15:45,785
但是，你仍然可以专门化它，

1536
01:15:45,785 --> 01:15:47,435
根据数据类型以及其他方面，

1537
01:15:47,435 --> 01:15:48,790
关于它如何使用，

1538
01:15:49,140 --> 01:15:51,580
ClickHouse 可能是这方面最好的例子，

1539
01:15:52,830 --> 01:15:53,900
对于很多商业系统来说，

1540
01:15:53,900 --> 01:15:56,170
很难知道他们实际上使用什么哈希表，

1541
01:15:56,880 --> 01:15:58,600
除非有一篇论文讨论它，

1542
01:15:58,770 --> 01:16:00,640
或者我们知道在那里工作的人可以告诉我们，

1543
01:16:01,800 --> 01:16:03,800
这不是一些事情，

1544
01:16:03,800 --> 01:16:06,430
使用 SQL 的人，应用程序开发人员，

1545
01:16:06,690 --> 01:16:07,690
你应该知道或关心的事情，

1546
01:16:08,670 --> 01:16:11,440
但有时知道这些[评估]是如何实现的是很好的。

1547
01:16:14,030 --> 01:16:15,720
哈希函数的好处是，它会很快，

1548
01:16:15,980 --> 01:16:17,790
在最好的情况下，它们将支持 O(1) 查找，

1549
01:16:18,260 --> 01:16:20,850
但同样，我们需要能够确保我们可以，

1550
01:16:22,330 --> 01:16:24,930
我们可能需要有效地增长，

1551
01:16:24,930 --> 01:16:27,680
如果我们错误地估计大小，

1552
01:16:27,760 --> 01:16:30,290
我们稍后将看到我们如何做这些估计。

1553
01:16:31,800 --> 01:16:35,650
所以有些系统会在你调用创建索引的时候给你哈希表，

1554
01:16:36,150 --> 01:16:37,235
Postgres 会让你做这个，

1555
01:16:37,235 --> 01:16:38,390
Postgres 调用创建索引，

1556
01:16:38,390 --> 01:16:39,520
你可以说使用哈希，

1557
01:16:39,630 --> 01:16:40,610
你会得到一个哈希表，

1558
01:16:40,610 --> 01:16:44,500
你会得到他们的线性哈希表实现，

1559
01:16:45,120 --> 01:16:46,160
但这并不是默认的，

1560
01:16:46,910 --> 01:16:48,460
对于几乎所有的系统，

1561
01:16:48,460 --> 01:16:49,860
当你调用创建索引时，

1562
01:16:51,160 --> 01:16:51,980
有没有人知道为什么？

1563
01:16:55,540 --> 01:16:56,900
没有范围[可以]，是的，

1564
01:16:56,980 --> 01:16:59,960
你唯一使用哈希表能做的就是[质量]查找，

1565
01:17:00,160 --> 01:17:02,980
你需要有整个键，

1566
01:17:03,000 --> 01:17:07,145
如果我的键在 A 列和 B 列，

1567
01:17:07,145 --> 01:17:08,290
我可以做组合键，

1568
01:17:08,610 --> 01:17:10,820
如果我没有 A ，我没有 B ，

1569
01:17:10,820 --> 01:17:11,830
我就不能查找了。

1570
01:17:13,130 --> 01:17:14,110
在 B+ 树中，

1571
01:17:14,110 --> 01:17:15,510
我们将在下一节课中讨论，

1572
01:17:16,610 --> 01:17:18,240
你可以做这些前缀查找，

1573
01:17:18,320 --> 01:17:21,630
这是有史以来用于数据库最好的数据结构，

1574
01:17:22,490 --> 01:17:23,790
Trie 实际上也很好，

1575
01:17:24,740 --> 01:17:28,290
但你可以把 Trie 放入 B+ 树中，

1576
01:17:30,800 --> 01:17:33,990
这些系统的默认选择是 B+ 树，

1577
01:17:34,500 --> 01:17:36,480
这就是我们下周要讨论的问题，

1578
01:17:36,480 --> 01:17:39,730
但是，在星期一我们将假设它是单线程的，

1579
01:17:39,810 --> 01:17:42,550
在星期三，我们将了解如何使其成为多线程的。

1580
01:17:44,330 --> 01:17:45,240
好的，开始吧。

