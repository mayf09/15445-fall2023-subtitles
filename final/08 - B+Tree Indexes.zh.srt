1
00:00:42,300 --> 00:00:47,145
好的，今天有很多东西要讨论，

2
00:00:47,145 --> 00:00:48,470
所以我要把所有东西[]。

3
00:00:49,770 --> 00:00:51,455
再次提醒一下，

4
00:00:51,455 --> 00:00:53,140
即将到来的活动现在改正了日期，

5
00:00:53,520 --> 00:00:55,985
所以今天，在 4:30 通过 Zoom ，

6
00:00:55,985 --> 00:00:59,020
我们将有 Postgres ML 的联合创始人，

7
00:00:59,370 --> 00:01:02,990
基本上是 Postgres 的修改版本，

8
00:01:02,990 --> 00:01:04,700
或它不是 Postgres 修改的，

9
00:01:04,700 --> 00:01:08,210
他们建立 Postgres 的扩展系统和 API ，

10
00:01:08,210 --> 00:01:13,875
来直接在 Postgres 内部支持机器学习框架和大型语言模型，

11
00:01:13,875 --> 00:01:15,650
他将在谈论他们在构建的东西，

12
00:01:16,090 --> 00:01:21,020
下周，我们可能有一家更大的矢量数据库公司来做演讲， Weaviate ，

13
00:01:21,160 --> 00:01:23,630
然后在它之后将是 FeatureForm ，

14
00:01:23,860 --> 00:01:26,325
在 FeatureForm 之后是 FeatureBase ，

15
00:01:26,325 --> 00:01:27,470
相同的名字，不同的系统。

16
00:01:28,330 --> 00:01:31,700
再说一次，这是可选的，如果你想参加的话。

17
00:01:32,200 --> 00:01:33,585
然后，我在 Piazza 贴上，

18
00:01:33,585 --> 00:01:35,480
给数据库的朋友们发了一封电子邮件，

19
00:01:35,800 --> 00:01:36,750
像这样的公司，

20
00:01:36,750 --> 00:01:37,770
附着大家的简历，

21
00:01:37,770 --> 00:01:39,440
如果你昨天上传了。

22
00:01:41,840 --> 00:01:42,330
好的。

23
00:01:42,840 --> 00:01:44,510
上一节课，我们讨论了哈希表，

24
00:01:45,430 --> 00:01:48,020
我们讨论了这个重要的数据结构，

25
00:01:48,430 --> 00:01:51,780
它会给我们带来很好的 O(1) 平均时间复杂度，

26
00:01:51,780 --> 00:01:54,650
来查找键和值的匹配。

27
00:01:56,200 --> 00:02:01,940
我们花时间讨论了静态和动态哈希方法之间的区别，

28
00:02:02,830 --> 00:02:05,270
比如静态使用的是固定大小 slot 数量，

29
00:02:05,680 --> 00:02:09,710
而可扩展哈希、链式哈希和线性哈希，

30
00:02:09,970 --> 00:02:12,330
都具有随时间递增增长的能力，

31
00:02:12,330 --> 00:02:14,660
以容纳比你最初设想的更多的键。

32
00:02:15,410 --> 00:02:17,850
所以，上一节课的主要收获应该是，

33
00:02:17,870 --> 00:02:20,370
我们花了大部分时间讨论如何处理这个复杂的问题，

34
00:02:21,230 --> 00:02:24,870
两个键，两个不同的键哈希到相同的位置，你会做什么，

35
00:02:26,000 --> 00:02:27,025
然后我们主要讨论了，

36
00:02:27,025 --> 00:02:32,130
这些哈希表将如何在大多数系统中主要用于内部数据结构，

37
00:02:32,480 --> 00:02:36,275
比如如页表和项目 1 ，或页面目录，

38
00:02:36,275 --> 00:02:39,950
或跟踪数据库系统本身的状态的其他东西，

39
00:02:39,950 --> 00:02:40,600
当我们运行时，

40
00:02:41,250 --> 00:02:42,470
我们将再次看到哈希表，

41
00:02:42,470 --> 00:02:44,350
当我们谈论如何 Join 时，

42
00:02:44,610 --> 00:02:46,220
但是，在大多数情况下，

43
00:02:46,220 --> 00:02:48,310
它们主要用于内部数据结构。

44
00:02:49,530 --> 00:02:51,670
所以今天的课程，我们现在讨论的是 B+ 树，

45
00:02:52,770 --> 00:02:55,930
它们将主要是默认的选择，

46
00:02:56,100 --> 00:02:59,750
当你想要在关系数据库系统中建立索引时。

47
00:02:59,750 --> 00:03:01,000
所以如果你调用 CREATE INDEX ，

48
00:03:01,690 --> 00:03:03,770
是的， 99% 的情况下，在大多数系统中，

49
00:03:03,790 --> 00:03:06,830
你会得到一个看起来像 B+ 树的东西。

50
00:03:07,570 --> 00:03:08,355
然后我们再讨论一下，

51
00:03:08,355 --> 00:03:09,900
我们将首先进行一个高层次的概述，

52
00:03:09,900 --> 00:03:11,390
B+ 树是什么样子的，

53
00:03:12,100 --> 00:03:12,830
它是什么组成的，

54
00:03:13,030 --> 00:03:15,740
B+ 树与常规的 B 树相比。

55
00:03:16,690 --> 00:03:18,405
我将讨论一些基本的设计选择，

56
00:03:18,405 --> 00:03:20,150
当我们想要构建一个系统时，

57
00:03:20,440 --> 00:03:21,510
我们将结束，

58
00:03:21,510 --> 00:03:23,150
直到我们有时间，

59
00:03:23,890 --> 00:03:25,220
直到我们有的最后的时间，

60
00:03:25,450 --> 00:03:26,580
讨论所有不同的方法，

61
00:03:26,580 --> 00:03:30,240
你可以实际优化和提高这些不同系统的性能，

62
00:03:30,240 --> 00:03:33,020
以及真实系统今天在做的例子。

63
00:03:33,610 --> 00:03:34,010
好的？

64
00:03:35,810 --> 00:03:39,060
好的，所以我们首先要讨论的是什么是 B+ 树。

65
00:03:39,710 --> 00:03:44,850
B+ 树属于一种称为 B 树的数据结构，

66
00:03:45,110 --> 00:03:48,180
在数据库文献中，令人困惑的是，

67
00:03:48,890 --> 00:03:50,190
不同的数据库系统中，

68
00:03:50,510 --> 00:03:52,860
有一类数据结构被称为 B 树，

69
00:03:53,300 --> 00:03:55,890
然后是一种特殊的数据结构，称为 B 树，

70
00:03:56,360 --> 00:03:59,310
然后一些数据库系统实际上使用的是 B+ 树，

71
00:03:59,960 --> 00:04:03,120
但他们将自己称为 B 树。

72
00:04:03,120 --> 00:04:04,460
所以如果你去看 Postgres 代码，

73
00:04:04,600 --> 00:04:06,950
他们会把他们的数据结构称为 B 树，

74
00:04:07,270 --> 00:04:09,530
但据我所知，这是一棵 B+ 树，

75
00:04:09,820 --> 00:04:13,970
使用了一些现代技术，比如 B-Link 树。

76
00:04:14,170 --> 00:04:16,610
所以当你说 B+ 树的时候，

77
00:04:17,230 --> 00:04:19,730
它通常指的是其他一些不同的东西。

78
00:04:20,590 --> 00:04:25,450
所以， B+ 树没有原始论文，

79
00:04:25,500 --> 00:04:29,320
大家提到的这个是 1979 年的这个，

80
00:04:29,760 --> 00:04:32,770
由 IBM 的人谈论，

81
00:04:33,270 --> 00:04:35,230
他们称为无处不在的 B 树，

82
00:04:35,610 --> 00:04:36,970
然后他们描述说，

83
00:04:37,050 --> 00:04:39,010
嘿，有这个不同的变种，

84
00:04:39,420 --> 00:04:43,325
但对数据库系统最有用的是 B+ 树，

85
00:04:43,325 --> 00:04:46,535
然后他们引用了某种 IBM 技术报告，

86
00:04:46,535 --> 00:04:47,680
我没有找到，

87
00:04:49,020 --> 00:04:49,805
我没有那么认真地找，

88
00:04:49,805 --> 00:04:51,670
但它在 Google 上没有显示出来，

89
00:04:52,800 --> 00:04:57,510
这是他们谈论的那个原始 B+ 树，

90
00:04:59,500 --> 00:05:05,270
关于 B+ 的原始作者，

91
00:05:05,710 --> 00:05:07,250
这个人承担的责任和功劳，

92
00:05:07,600 --> 00:05:11,810
他们从未真正定义过 B+ 树中 B 的意思，

93
00:05:12,070 --> 00:05:17,090
通常人们说它是，代表平衡，宽广，浓密，

94
00:05:17,170 --> 00:05:19,485
这个人的名字是 Bayer ， b a y er ，

95
00:05:19,485 --> 00:05:20,960
所以可能是以他自己的名字命名的，

96
00:05:22,720 --> 00:05:26,510
这个数据结构实际上是 Boeing 开发的，那个飞机公司，

97
00:05:26,530 --> 00:05:28,670
可能是 Boeing 树，

98
00:05:29,280 --> 00:05:29,915
没有人真正知道，

99
00:05:29,915 --> 00:05:30,940
但通常情况下，

100
00:05:31,440 --> 00:05:33,970
当你说 B 树时，人们通常指的是平衡。

101
00:05:35,320 --> 00:05:37,220
还有另一个变体叫做 B-Link 树，

102
00:05:37,420 --> 00:05:41,000
正如我所说的，有一种经典的 B+ 树，

103
00:05:41,380 --> 00:05:43,550
但没有人实现它的定义，

104
00:05:43,870 --> 00:05:45,420
人们会零星地借用它，

105
00:05:45,420 --> 00:05:48,530
特别是他们会从这篇 B-Link 树论文中借用一些想法，

106
00:05:48,880 --> 00:05:52,070
这篇论文实际上来自 CMU ，在 1981 年，

107
00:05:52,690 --> 00:05:53,990
这个人是 Philip Lehman ，

108
00:05:54,650 --> 00:05:58,260
那个家伙仍在 CMU 五楼的院长办公室工作，

109
00:05:58,760 --> 00:06:00,480
如果你去看 Postgres 源代码，

110
00:06:01,100 --> 00:06:03,835
在他们谈论 B 树的目录中，

111
00:06:03,835 --> 00:06:05,820
注意他们说的是 B 树而不是 B+ 树，

112
00:06:05,990 --> 00:06:07,590
这里有一个 nbtree ，

113
00:06:07,610 --> 00:06:09,480
因为这是一个非平衡 B+ 树，

114
00:06:09,770 --> 00:06:11,040
但我们稍后会谈到这个。

115
00:06:12,170 --> 00:06:13,315
但是，是的，就在这个代码中，

116
00:06:13,315 --> 00:06:15,175
是的，这是一个正确的暗示，

117
00:06:15,175 --> 00:06:16,110
正确总是重要的，

118
00:06:16,400 --> 00:06:21,265
关于 Lehman 和 Yao 的 B-Link 论文，在 1973 年，

119
00:06:21,265 --> 00:06:21,810
这太酷了。

120
00:06:23,370 --> 00:06:25,870
但我们将主要关注这个，

121
00:06:26,040 --> 00:06:27,530
我们将看看是否有时间，

122
00:06:27,530 --> 00:06:29,200
我将在最后讨论 Bε 树，

123
00:06:29,520 --> 00:06:32,165
然后， Bw 树是微软的东西，

124
00:06:32,165 --> 00:06:34,090
一种 B+ 树的无锁版本。

125
00:06:34,620 --> 00:06:36,515
我们实际上在 CMU 实现了这个，

126
00:06:36,515 --> 00:06:37,570
这并不容易，

127
00:06:38,520 --> 00:06:39,970
我们有一个开放源码的实现。

128
00:06:41,150 --> 00:06:41,550
好的。

129
00:06:42,570 --> 00:06:45,910
所以 B+ 树是一个自平衡的排序树，

130
00:06:46,350 --> 00:06:50,740
它允许我们进行搜索和顺序访问，以及插入和删除，

131
00:06:51,000 --> 00:06:54,470
所有这些都在 log n 时间内，

132
00:06:54,730 --> 00:06:56,750
log n 是树的高度。

133
00:06:57,570 --> 00:07:00,370
所以，这里的区别，

134
00:07:00,480 --> 00:07:05,740
我们在这里描述的 B+ 树和一般的二叉搜索树之间的区别是，

135
00:07:06,000 --> 00:07:11,530
我们数据结构中的节点显然可以有两个以上的键，

136
00:07:12,320 --> 00:07:14,380
我们想要这个的原因是，

137
00:07:14,580 --> 00:07:16,085
我们想要转换，

138
00:07:16,085 --> 00:07:17,980
我们想要最小化我们做的随机 I/O 量，

139
00:07:18,180 --> 00:07:20,170
我们想要最大化顺序 I/O 量，

140
00:07:20,610 --> 00:07:22,960
B+ 树是非常适合我们这样做的，

141
00:07:23,250 --> 00:07:25,870
因为当我们到达一个在获取页面的节点时，

142
00:07:26,190 --> 00:07:29,110
我们没有尽可能多的键在里面，

143
00:07:29,610 --> 00:07:34,260
在我们继续，从磁盘中获取下一个页面之前。

144
00:07:35,060 --> 00:07:38,710
所以回想一下，早在 20 世纪 70 年代，

145
00:07:38,710 --> 00:07:40,080
当硬件很糟糕的时候，

146
00:07:40,400 --> 00:07:43,170
比如你有最少的 RAM ，

147
00:07:43,700 --> 00:07:45,180
你的磁盘也超级慢，

148
00:07:45,500 --> 00:07:46,990
所以 B+ 树，

149
00:07:46,990 --> 00:07:48,180
它将允许转换，

150
00:07:48,680 --> 00:07:49,650
当你做这些查找时，

151
00:07:50,030 --> 00:07:52,830
从随机 I/O 转换为顺序访问。

152
00:07:53,500 --> 00:07:55,130
因为一旦你跟随叶节点，

153
00:07:55,210 --> 00:07:58,800
或沿着树向下到叶节点，

154
00:07:58,800 --> 00:07:59,720
一旦你到了那里，

155
00:07:59,770 --> 00:08:00,830
你再也不会回到上面，

156
00:08:01,420 --> 00:08:02,160
不完全正确，

157
00:08:02,160 --> 00:08:02,745
但出于我们的目的，

158
00:08:02,745 --> 00:08:04,010
我们现在假设情况就是这样，

159
00:08:04,180 --> 00:08:06,800
然后我可以沿着叶节点扫描，

160
00:08:06,850 --> 00:08:10,140
以找到我正在寻找的数据。

161
00:08:11,990 --> 00:08:13,405
所以，更具形式性的，我们可以说，

162
00:08:13,405 --> 00:08:16,860
B+ 树是具有以下性质的 M 路搜索树，

163
00:08:18,100 --> 00:08:19,910
对我们来说，它是完全平衡的，

164
00:08:19,990 --> 00:08:25,730
这意味着我们树结构中的每个叶节点都将具有相同的深度，

165
00:08:26,080 --> 00:08:30,860
也就是从根到该叶节点的相同层数，

166
00:08:31,060 --> 00:08:33,990
再次， Postgres 会违反这一点，

167
00:08:33,990 --> 00:08:34,910
有些人是这样做的，

168
00:08:35,020 --> 00:08:37,130
但是从一开始就认为情况是这样。

169
00:08:38,720 --> 00:08:39,970
我们还有一条规则，

170
00:08:39,970 --> 00:08:43,800
除根节点之外的每个节点都必须至少半满，

171
00:08:44,090 --> 00:08:47,970
所以如果我有 M 个键在一个节点中，

172
00:08:48,050 --> 00:08:51,160
我需要至少有一半的节点，

173
00:08:51,160 --> 00:08:56,320
尽可能有最大数量一半的键，

174
00:08:56,520 --> 00:08:58,145
如果我低于这个阈值，

175
00:08:58,145 --> 00:09:00,250
如果我低于半满，

176
00:09:00,690 --> 00:09:02,380
那么我必须进行一些合并，

177
00:09:02,790 --> 00:09:06,840
但是再次，我们可以稍后对这个要求进行调整。

178
00:09:08,310 --> 00:09:10,030
根节点是特殊的，

179
00:09:10,080 --> 00:09:11,530
所以我们现在可以忽略它，

180
00:09:12,510 --> 00:09:17,350
然后每个有 k 个键的内部节点将至少有 k+1 个非空子节点，

181
00:09:18,030 --> 00:09:21,365
这意味着我可以有一些位置，

182
00:09:21,365 --> 00:09:25,655
或者指向我下面的叶节点或节点的可能指针，

183
00:09:25,655 --> 00:09:26,590
当我是内部节点时，

184
00:09:26,670 --> 00:09:28,540
但我不一定要有最大数量。

185
00:09:32,120 --> 00:09:32,875
所以这都是数学问题，

186
00:09:33,040 --> 00:09:33,660
让我们来看一个例子。

187
00:09:34,600 --> 00:09:35,460
所以这里有一个非常简单的，

188
00:09:38,260 --> 00:09:40,370
这里有一个非常简单的 2 阶 B+ 树，

189
00:09:41,710 --> 00:09:43,640
我们可以定义顶部的根节点，

190
00:09:43,960 --> 00:09:45,080
然后是内部节点，

191
00:09:45,310 --> 00:09:46,530
因为我们只有三层，

192
00:09:46,530 --> 00:09:47,720
内部节点就是中间的那些，

193
00:09:48,130 --> 00:09:50,360
然后叶节点就是底部的东西。

194
00:09:51,720 --> 00:09:53,080
所以，在内部节点本身中，

195
00:09:53,370 --> 00:09:56,660
我们将有这种交替模式，

196
00:09:56,660 --> 00:09:59,440
一个指向另一个节点的指针和一个键，

197
00:10:00,840 --> 00:10:02,560
然后在叶节点中，

198
00:10:02,760 --> 00:10:07,480
将有我们试图为给定键存储的值，

199
00:10:08,540 --> 00:10:10,375
目前，我们不会找到值是什么，

200
00:10:10,375 --> 00:10:12,570
但你可以将其视为潜在的记录 ID ，

201
00:10:12,650 --> 00:10:16,350
以指向实际的 tuple ，某个页码和偏移量，

202
00:10:17,360 --> 00:10:19,530
或者，如果这是 MySQL 或 SQLite 的情况，

203
00:10:19,820 --> 00:10:21,420
它可能是 tuple 本身，

204
00:10:21,920 --> 00:10:23,100
但就目前而言，我们可以忽略这个。

205
00:10:24,230 --> 00:10:28,060
所以思考这些内部节点和根节点中的数字的方法是，

206
00:10:28,060 --> 00:10:29,590
这些基本上是路标，

207
00:10:29,590 --> 00:10:32,695
告诉你要走哪条路径。

208
00:10:32,695 --> 00:10:33,565
所以在这里的根节点，

209
00:10:33,565 --> 00:10:34,830
我们只有一个键，它是 20 ，

210
00:10:35,090 --> 00:10:36,450
所以如果你去左边，

211
00:10:36,530 --> 00:10:39,510
它是任何小于 20 的值，

212
00:10:39,830 --> 00:10:43,700
我们去右边，就会得到大于或等于的。

213
00:10:44,140 --> 00:10:46,520
一样的东西，下一个，我这里有 10 ，

214
00:10:47,140 --> 00:10:48,200
小于 10 的到这边，

215
00:10:48,340 --> 00:10:50,120
大于等于 10 的在另一边。

216
00:10:53,370 --> 00:10:54,070
那么什么造成？

217
00:10:55,200 --> 00:10:56,705
这就是我到目前为止所描述的，

218
00:10:56,705 --> 00:10:58,240
这是一个基本的 B+ 树，

219
00:10:58,500 --> 00:11:01,090
但我之前说过，他们有这个，

220
00:11:01,230 --> 00:11:05,230
我们借鉴了其他论文的想法，比如 B-Link 树，

221
00:11:05,460 --> 00:11:10,060
也就是节点也将在每个级别上有兄弟指针，

222
00:11:10,740 --> 00:11:13,610
我认为课本可能只在叶节点上显示，

223
00:11:13,780 --> 00:11:16,460
Postgres 将它们放在中间节点，也是内部节点，

224
00:11:16,780 --> 00:11:19,700
我认为原始的 B-Link 论文也有这些节点。

225
00:11:20,370 --> 00:11:22,580
所以这很重要的原因是，

226
00:11:22,580 --> 00:11:24,400
如果我要进行搜索，

227
00:11:24,510 --> 00:11:26,800
给我所有大于等于 6 的键，

228
00:11:27,150 --> 00:11:31,270
我可以沿着树的这一边遍历，到达底部，

229
00:11:31,590 --> 00:11:35,890
现在我可以沿着叶子节点，不用回到上面了，

230
00:11:36,860 --> 00:11:38,560
我们现在还不会讨论多线程，

231
00:11:38,560 --> 00:11:43,920
但是为了扫描而不得不获取父节点的锁，

232
00:11:44,060 --> 00:11:44,965
这将是昂贵的，

233
00:11:44,965 --> 00:11:47,220
如果我能保持在我需要去的最低层级，

234
00:11:47,570 --> 00:11:48,960
那么我可以移动得更快。

235
00:11:50,480 --> 00:11:52,945
再次，如果它是随机 I/O ，这很糟糕，

236
00:11:52,945 --> 00:11:53,790
但如果我到了这里，

237
00:11:54,020 --> 00:11:58,340
假设所有这些页面都是在磁盘上彼此顺序或连续，

238
00:11:58,360 --> 00:12:00,350
那么所有这些要扫过的都是顺序 I/O 。

239
00:12:01,170 --> 00:12:02,770
是的。

240
00:12:04,130 --> 00:12:04,780
是的，它指向，

241
00:12:04,780 --> 00:12:06,180
在内部节点中这些指向什么，

242
00:12:06,410 --> 00:12:08,800
它在拆分和合并时对你有帮助，

243
00:12:08,800 --> 00:12:09,900
如果我知道我必须，

244
00:12:09,980 --> 00:12:11,400
比如我想偷走某个东西，

245
00:12:12,240 --> 00:12:16,070
比如，如果我删除 10 ，10 被删除，

246
00:12:16,390 --> 00:12:20,060
不是必须重新组织整棵树，

247
00:12:20,140 --> 00:12:21,420
我可以跟随兄弟指针，

248
00:12:21,420 --> 00:12:23,000
也许从这个节点拿出一个键，把它带过来。

249
00:12:24,560 --> 00:12:25,615
是的。

250
00:12:28,710 --> 00:12:29,630
问题是什么，

251
00:12:29,630 --> 00:12:30,970
什么是节点指针，

252
00:12:32,370 --> 00:12:34,325
这些红色的行，

253
00:12:34,325 --> 00:12:36,970
哦，节点指针，

254
00:12:39,530 --> 00:12:40,435
我将播放下一张幻灯片，

255
00:12:40,435 --> 00:12:41,605
你不会完全把这个这样放置，

256
00:12:41,605 --> 00:12:43,795
你不会把这些都完全按我描述的放在磁盘上，

257
00:12:43,795 --> 00:12:44,490
但是考虑它是，

258
00:12:44,870 --> 00:12:47,730
比如我这里有键 20 ，

259
00:12:48,020 --> 00:12:48,990
这就是这部分，

260
00:12:49,190 --> 00:12:51,240
然后节点指针说，

261
00:12:51,620 --> 00:12:53,490
如果你要寻找一个小于 20 的键，

262
00:12:54,020 --> 00:12:56,340
沿着这个指针往下走，你就会找到它，

263
00:12:56,830 --> 00:12:59,700
在我们的世界里，在磁盘上的数据库系统中，

264
00:12:59,700 --> 00:13:00,590
它只是一个页面 ID 。

265
00:13:07,360 --> 00:13:10,220
是的，这是人们通常的视觉化显示。

266
00:13:12,280 --> 00:13:17,870
好的，所以节点本身基本上是键值对的数组，

267
00:13:18,760 --> 00:13:24,530
键将从表中索引所基于的任何属性派生，

268
00:13:24,880 --> 00:13:28,280
所以假设我在表 foo 列 abc 上构建了一个索引，

269
00:13:28,450 --> 00:13:33,050
键本身将是 abc 中每个 tuple 的副本，

270
00:13:33,780 --> 00:13:34,460
所以，你可以在某种程度上认为，

271
00:13:34,460 --> 00:13:38,380
索引就是为你要索引的表的副本，

272
00:13:38,940 --> 00:13:43,750
它是以这样一种有序的方式组织的，

273
00:13:43,920 --> 00:13:47,000
你可以进行高效的 log n 查找，

274
00:13:47,000 --> 00:13:50,380
在关系型模型中，表可能是未排序的，

275
00:13:50,460 --> 00:13:52,240
我们将在几张幻灯片中违反这一点，

276
00:13:52,440 --> 00:13:54,305
但表可能是未排序的，

277
00:13:54,305 --> 00:13:57,430
所以索引是一种快速排序访问的方法。

278
00:13:58,730 --> 00:14:00,565
当然，只有在它涵盖数据库系统的情况下，

279
00:14:00,565 --> 00:14:01,680
我们将在本学期晚些时候看到这一点，

280
00:14:01,970 --> 00:14:05,850
必须确保你的索引与表同步，

281
00:14:05,850 --> 00:14:08,700
意思是如果我更新，在我的表中插入 tuple ，

282
00:14:08,700 --> 00:14:10,910
我想要自动更新我的索引，

283
00:14:11,050 --> 00:14:12,770
数据库系统会为你做这件事，

284
00:14:12,970 --> 00:14:14,930
并确保一切都是同步的。

285
00:14:16,580 --> 00:14:18,270
同样，我们在这节课上不会关注这个。

286
00:14:20,640 --> 00:14:21,040
这个。

287
00:14:22,940 --> 00:14:25,380
这些值可能会有所不同，

288
00:14:26,630 --> 00:14:29,340
值会不同，取决于是内部节点或叶子节点，

289
00:14:29,360 --> 00:14:30,415
如果它是内部节点，

290
00:14:30,415 --> 00:14:32,670
值是指向我们下面某个页面的指针，

291
00:14:33,020 --> 00:14:34,225
如果它是叶子节点，

292
00:14:34,225 --> 00:14:38,005
那么它将是指向 tuple 的指针，

293
00:14:38,005 --> 00:14:40,645
我使用的指针而不是内存地址术语，

294
00:14:40,645 --> 00:14:42,070
我的意思是页面 ID ，

295
00:14:42,070 --> 00:14:45,420
抱歉，记录 ID 可以是 tuple 本身。

296
00:14:46,520 --> 00:14:50,035
节点本身中的数组通常按排序顺序保存，

297
00:14:50,035 --> 00:14:50,940
但不必如此，

298
00:14:51,560 --> 00:14:53,405
然后就有了这个问题，

299
00:14:53,405 --> 00:14:54,610
你如何处理 NULL 键？

300
00:14:55,380 --> 00:14:58,870
因为假设，如果索引尝试构建，

301
00:14:59,640 --> 00:15:02,105
索引尝试使用 B+ 树构建，

302
00:15:02,105 --> 00:15:04,420
如果它不是唯一的，则可能有空值，

303
00:15:04,500 --> 00:15:05,710
我们必须将空值放在某个地方，

304
00:15:06,210 --> 00:15:09,040
所以通常你要么把它们全部放在末尾，要么全部放在开头，

305
00:15:09,480 --> 00:15:11,570
实际上，当你在某些系统中创建索引时，

306
00:15:11,570 --> 00:15:13,025
你实际上定义了想要它们的位置，

307
00:15:13,025 --> 00:15:14,050
你想要第一个还是之后，

308
00:15:14,370 --> 00:15:15,590
因为根据查询内容的不同，

309
00:15:15,590 --> 00:15:17,435
你可能不希望首先看到空值，

310
00:15:17,435 --> 00:15:18,550
而可能希望在最后看到它们，

311
00:15:19,570 --> 00:15:20,750
这取决于应用程序。

312
00:15:22,130 --> 00:15:23,640
另一件重要的事情是，

313
00:15:24,440 --> 00:15:25,200
回到这里，

314
00:15:25,580 --> 00:15:28,230
只有兄弟指针和指针向下移动，

315
00:15:28,580 --> 00:15:30,270
没有回传的指针，

316
00:15:31,250 --> 00:15:32,305
原因是，

317
00:15:32,305 --> 00:15:33,520
我们将在下一节课中看到更多，

318
00:15:33,520 --> 00:15:35,880
当我们开始在这些节点上使用 latch 的时候，

319
00:15:36,950 --> 00:15:40,800
我们不想让一个线程以这种方式运行，自上而下，

320
00:15:41,030 --> 00:15:42,540
另一个线程从自下而上，

321
00:15:42,740 --> 00:15:44,010
因为这将导致死锁，

322
00:15:44,330 --> 00:15:46,270
现在兄弟指针也会有这个问题，

323
00:15:46,270 --> 00:15:47,280
我们将看看如何处理这个问题，

324
00:15:47,540 --> 00:15:51,270
但通过避免指针在不同级别之间的两个方向上移动，

325
00:15:51,500 --> 00:15:53,100
我们需要担心的事情就少了一件。

326
00:15:53,930 --> 00:15:54,660
因为我们不需要，

327
00:15:54,740 --> 00:15:55,975
我们将要进行拆分和合并的方式，

328
00:15:55,975 --> 00:15:57,130
它不像一棵 AVL 树，

329
00:15:57,130 --> 00:15:59,550
你必须做旋转和所有的事情，

330
00:16:00,020 --> 00:16:00,960
我们不会这么做。

331
00:16:02,520 --> 00:16:03,700
可能有人会说，这更容易，

332
00:16:04,350 --> 00:16:05,410
不，不是真的，

333
00:16:07,080 --> 00:16:08,110
它们都很困难。

334
00:16:08,220 --> 00:16:10,420
好的，这又是我们的节点的样子，

335
00:16:10,890 --> 00:16:13,580
假设这是一个页面，

336
00:16:13,580 --> 00:16:17,860
所以我们将有这个键值指针数组，抱歉，键和值，

337
00:16:18,360 --> 00:16:20,560
然后我们在这里有这些指针，

338
00:16:21,200 --> 00:16:25,540
这将是前一个和下一个的页面 ID ，

339
00:16:25,590 --> 00:16:27,880
沿着我们的层级，

340
00:16:29,080 --> 00:16:32,630
键值对可以一个接一个地排序，

341
00:16:33,100 --> 00:16:36,255
如果它是一个内部节点，

342
00:16:36,255 --> 00:16:40,160
那么值就只是指针，记录 ID ，

343
00:16:41,200 --> 00:16:42,740
我们也可以分别对它们进行排序，

344
00:16:43,410 --> 00:16:44,975
这个常见的方法，

345
00:16:44,975 --> 00:16:47,110
你会把键排序放在一个数组中，

346
00:16:47,310 --> 00:16:49,780
然后把值分别放在另一个数组中，

347
00:16:49,920 --> 00:16:54,490
然后无论你在键数组中，

348
00:16:54,630 --> 00:16:57,260
对应于在值数组中的一些偏移量，

349
00:16:57,260 --> 00:16:59,075
它几乎就像我们之前说过的列存储的东西，

350
00:16:59,075 --> 00:17:01,630
你可以用简单的算术来决定如何跳过，

351
00:17:01,890 --> 00:17:03,760
[]，把它搞砸，

352
00:17:03,840 --> 00:17:06,640
但是你只需要维护偏移表，跟踪这些东西。

353
00:17:09,190 --> 00:17:12,135
所以，还有一个额外的[]来跟踪，

354
00:17:12,135 --> 00:17:15,050
比如，这是我的页面上留下的一些 slot ，

355
00:17:15,460 --> 00:17:17,840
我看的是什么层级，

356
00:17:17,980 --> 00:17:19,580
当你向下遍历时，

357
00:17:19,660 --> 00:17:20,865
你可以只看着页面，然后说，

358
00:17:20,865 --> 00:17:23,090
好的，我在树的什么位置，

359
00:17:24,450 --> 00:17:26,620
它对恢复也很有用。

360
00:17:29,010 --> 00:17:29,565
所以我已经说过了，

361
00:17:29,655 --> 00:17:30,330
我只是重复我自己，

362
00:17:30,330 --> 00:17:34,545
但是，叶节点值本身可以是记录 ID ，

363
00:17:34,545 --> 00:17:36,350
也就是页面编号和到某个位置的偏移量，

364
00:17:36,850 --> 00:17:39,560
然后可以是 tuple 数据，

365
00:17:39,670 --> 00:17:41,805
就像索引组织存储，

366
00:17:41,805 --> 00:17:42,590
我们之前讨论过的，

367
00:17:42,610 --> 00:17:45,500
比如 SQLite 和 MySQL 在默认情况下是这样做的，

368
00:17:45,760 --> 00:17:47,820
但在 SQL Server 和 Oracle 中，

369
00:17:47,820 --> 00:17:51,120
你可以说 CREATE TABLE ，我想要索引组织的。

370
00:17:51,120 --> 00:17:54,180
它会生成一个 B+ 树，

371
00:17:54,180 --> 00:17:56,390
然后叶子节点就是 tuple 本身。

372
00:17:58,680 --> 00:18:02,465
对于第二个，你只对主键索引执行这个操作，

373
00:18:02,465 --> 00:18:03,850
否则你将复制数据，

374
00:18:03,900 --> 00:18:04,655
你不会想这么做的。

375
00:18:04,655 --> 00:18:05,675
是的。

376
00:18:10,250 --> 00:18:13,855
问题是，否存储记录 ID 是叶子节点还是内部节点，

377
00:18:13,855 --> 00:18:15,000
它是叶子节点，

378
00:18:15,350 --> 00:18:15,990
因为。

379
00:18:18,820 --> 00:18:19,970
我们马上就会举一个例子。

380
00:18:22,730 --> 00:18:23,700
在这里，

381
00:18:25,210 --> 00:18:27,200
唯一存在的键，

382
00:18:27,520 --> 00:18:29,600
对应于表中，

383
00:18:29,770 --> 00:18:31,340
是在叶子节点中找到的。

384
00:18:31,840 --> 00:18:33,570
所以，我们将在 demo 中看到这个，

385
00:18:33,570 --> 00:18:35,240
当我们删除和插入键时，

386
00:18:35,830 --> 00:18:41,000
被删除的键，可能仍然存在于内部节点中，

387
00:18:41,230 --> 00:18:42,195
所以你不能让它，

388
00:18:42,195 --> 00:18:44,565
你不能让它指向某个东西的记录 ID ，

389
00:18:44,565 --> 00:18:46,760
因为在那个记录可能不存在，

390
00:18:46,990 --> 00:18:49,760
在这种情况中，我在这个内部节点里是 35 ，

391
00:18:50,230 --> 00:18:52,200
但叶子节点中没有 35 ，

392
00:18:52,200 --> 00:18:53,360
这意味着在某个时刻，

393
00:18:53,830 --> 00:18:57,200
这个键插入了 35 ，然后被删除了，

394
00:18:57,250 --> 00:18:59,115
但因为它的组织方式，

395
00:18:59,115 --> 00:19:01,580
以及在维护树的平衡的算法中，

396
00:19:01,720 --> 00:19:03,315
我最终没有删除 35 ，

397
00:19:03,315 --> 00:19:04,035
所以它仍然在那里，

398
00:19:04,035 --> 00:19:06,410
所以它就像互联网人发布的帖子一样，

399
00:19:06,610 --> 00:19:10,070
或者或者交通标志或街道标志，

400
00:19:10,210 --> 00:19:13,430
告诉你如何在叶子中到达你需要去的地方。

401
00:19:14,910 --> 00:19:16,630
是的。

402
00:19:23,120 --> 00:19:23,815
他的说法是，

403
00:19:23,815 --> 00:19:26,550
是否每个内部节点都有一个键，

404
00:19:27,320 --> 00:19:28,750
但是每个叶子节点可以有多个键？

405
00:19:30,610 --> 00:19:31,610
在这里的这个例子中，

406
00:19:31,630 --> 00:19:33,285
我展示了每个节点的两个键，

407
00:19:33,285 --> 00:19:35,150
因为我必须使它适合幻灯片，

408
00:19:36,190 --> 00:19:38,040
这里跟 B+ 树没有任何关系，

409
00:19:38,040 --> 00:19:39,780
说你只能有两个键，

410
00:19:39,780 --> 00:19:40,700
你可以有多个键。

411
00:19:48,970 --> 00:19:49,850
在这个例子中？

412
00:19:50,870 --> 00:19:52,680
在这个例子中，是的，你只需要一个，

413
00:19:53,770 --> 00:19:55,605
但是在真正的 B+ 树中，

414
00:19:55,605 --> 00:19:58,920
你不必每个节点有一个键，

415
00:20:01,940 --> 00:20:03,340
你可以有无限的，

416
00:20:03,840 --> 00:20:05,945
我们很快就会到这里，

417
00:20:05,945 --> 00:20:08,500
磁盘越慢，你想要的节点就越大，

418
00:20:08,970 --> 00:20:10,270
因为这是更多的顺序 I/O ，

419
00:20:11,150 --> 00:20:12,300
你可以有几百个键，

420
00:20:15,980 --> 00:20:17,700
我在幻灯片上展示的内容是有限的，

421
00:20:17,900 --> 00:20:20,520
但我们马上会展示 demo 。

422
00:20:22,250 --> 00:20:22,830
还有其他问题吗？

423
00:20:25,000 --> 00:20:25,700
好的，那么，

424
00:20:27,010 --> 00:20:27,915
我做了一个大的[决定]，

425
00:20:27,915 --> 00:20:30,260
我们说的是 B+ 树，不是 B 树，

426
00:20:31,030 --> 00:20:32,270
你可能不知道什么是 B 树。

427
00:20:33,360 --> 00:20:36,220
所以，源自 1972 年的原始 B 树

428
00:20:36,750 --> 00:20:40,090
将所有键和值存储在整个树中，

429
00:20:40,350 --> 00:20:41,890
比如 AVL 树，

430
00:20:43,090 --> 00:20:44,420
它更节省空间，

431
00:20:44,500 --> 00:20:46,670
因为你从来没有键，

432
00:20:47,620 --> 00:20:50,335
与你的数据库中的实际数据不一致，

433
00:20:50,335 --> 00:20:50,920
就像我之前说的，

434
00:20:50,920 --> 00:20:53,670
我可以删除记录 35 ，键 35 ，

435
00:20:54,200 --> 00:20:57,610
它会从叶子节点中删除，

436
00:20:57,610 --> 00:20:59,580
但它最终可能仍然是一个路标，

437
00:21:00,120 --> 00:21:02,535
或者我可能有多个键的副本，

438
00:21:02,535 --> 00:21:05,390
从内部节点到叶子节点，

439
00:21:05,470 --> 00:21:08,840
这可能会浪费数据或空间。

440
00:21:09,850 --> 00:21:11,240
所以在一个 B 树中，

441
00:21:11,380 --> 00:21:14,540
一个键在整个树的任何地方只出现一次，

442
00:21:15,120 --> 00:21:17,930
但它的问题是，

443
00:21:18,190 --> 00:21:21,440
这些值表示，指向实际 tuple 的记录，

444
00:21:21,550 --> 00:21:23,120
它们可以在树中的任何地方，

445
00:21:23,470 --> 00:21:25,940
现在如果我想按顺序扫描，

446
00:21:26,230 --> 00:21:28,790
得到我需要的所有键，

447
00:21:29,140 --> 00:21:31,005
我可能需要向上，向下遍历，

448
00:21:31,005 --> 00:21:33,640
因为我基本上在做广度优先搜索。

449
00:21:34,450 --> 00:21:36,195
再次，我们现在还不打算讨论 latch ，

450
00:21:36,195 --> 00:21:38,240
但是想想看，我基本上必须锁整个树，

451
00:21:38,560 --> 00:21:39,830
因为我向上和向下移动，

452
00:21:40,420 --> 00:21:41,955
而在一个 B+ 树中，

453
00:21:41,955 --> 00:21:45,555
因为只有叶子节点是值实际存在的地方，

454
00:21:45,555 --> 00:21:48,140
考虑就像是表中（值）的准确副本，

455
00:21:48,860 --> 00:21:50,560
一旦我到达叶子节点，

456
00:21:50,700 --> 00:21:53,710
我不需要维护树中上部的任何 latch ，

457
00:21:53,850 --> 00:21:55,780
我可以沿着叶子扫描，

458
00:21:56,190 --> 00:21:59,105
让其他线程在[]的顶部做任何它们想做的事情，

459
00:21:59,105 --> 00:22:02,180
而不需要我做的事情。

460
00:22:02,900 --> 00:22:08,140
所以 B+ 树相对于 B 树的优势在于，

461
00:22:08,160 --> 00:22:09,790
我们有更好的并发访问，

462
00:22:09,990 --> 00:22:11,440
同样，我们将最大限度地，

463
00:22:12,960 --> 00:22:15,970
提高我们在顺序 I/O 的数量，而不是随机 I/O 。

464
00:22:17,700 --> 00:22:18,100
是的。

465
00:22:24,030 --> 00:22:24,755
他的问题是，

466
00:22:24,755 --> 00:22:29,320
如果，如果内部节点只是路标，

467
00:22:29,320 --> 00:22:32,780
为什么我们会有兄弟指针？

468
00:22:35,130 --> 00:22:37,120
因为在你进行拆分合并时，

469
00:22:37,320 --> 00:22:41,380
你可能需要借东西或与你的相邻节点合并，

470
00:22:42,430 --> 00:22:43,850
他们可能，

471
00:22:43,870 --> 00:22:45,380
你们有相同的父节点，

472
00:22:45,490 --> 00:22:46,260
不是从父节点得到，

473
00:22:46,260 --> 00:22:47,120
你可以绕过并得到它们，

474
00:22:50,385 --> 00:22:52,310
你不需要它，它只是一个优化。

475
00:22:54,820 --> 00:22:55,515
Postgres 实现了它，

476
00:22:55,515 --> 00:22:57,110
我不知道 MySQL 是不是这样的。

477
00:23:03,070 --> 00:23:03,310
所以让我们看看，

478
00:23:03,310 --> 00:23:04,740
我们想要如何做我们的基本操作。

479
00:23:05,930 --> 00:23:06,780
所以，做一个 insert ，

480
00:23:07,220 --> 00:23:07,675
我们想要，

481
00:23:07,675 --> 00:23:09,570
基本上目标是找到正确的叶子节点，

482
00:23:11,990 --> 00:23:14,470
我们基本上要往下走，沿着路标，

483
00:23:14,470 --> 00:23:15,465
到达某个叶子节点，

484
00:23:15,465 --> 00:23:17,160
我们的键应该在那里，

485
00:23:18,530 --> 00:23:19,690
如果它有足够的空间，

486
00:23:19,690 --> 00:23:20,785
很好，我们把它插入，

487
00:23:20,785 --> 00:23:22,165
在那个叶子节点上排序，

488
00:23:22,165 --> 00:23:22,680
我们就完成了，

489
00:23:23,340 --> 00:23:24,620
如果没有足够的空间，

490
00:23:25,480 --> 00:23:28,910
这意味着节点上我们拥有的键的数量是满的，

491
00:23:29,110 --> 00:23:34,580
那么我们必须将我们试图插入的叶子节点拆分为两个节点，

492
00:23:35,240 --> 00:23:36,120
把它一分为二，

493
00:23:36,170 --> 00:23:38,730
一半的键放在一边，一半的键放在另一边，

494
00:23:39,170 --> 00:23:44,700
然后你要复制列表中间的键到你的父节点，

495
00:23:45,710 --> 00:23:48,235
现在我们有了一个新的路标

496
00:23:48,235 --> 00:23:51,750
和一个指向你刚刚创建的新节点的新指针，

497
00:23:51,860 --> 00:23:52,830
新的叶子节点。

498
00:23:53,390 --> 00:23:54,955
当然，这是递归发生的，

499
00:23:54,955 --> 00:23:59,640
如果我把中间的键向上提升到父节点，

500
00:23:59,900 --> 00:24:00,940
而父节点是满的，

501
00:24:00,940 --> 00:24:02,040
那么现在我必须拆分父节点，

502
00:24:03,070 --> 00:24:05,600
而这可能会一直延续到顶端。

503
00:24:08,000 --> 00:24:16,300
所以，在 PowerPoint 中制作这些幻灯片来展示这个，

504
00:24:16,300 --> 00:24:17,040
是一种痛苦，

505
00:24:17,390 --> 00:24:19,230
所以，我要做的，

506
00:24:19,340 --> 00:24:20,590
我要把这个可视化，

507
00:24:20,590 --> 00:24:21,330
所以这是一个，

508
00:24:23,430 --> 00:24:24,100
把它拿到这里，

509
00:24:25,680 --> 00:24:26,950
这是我们要的大小，

510
00:24:27,240 --> 00:24:28,000
这是一个网站，

511
00:24:28,560 --> 00:24:31,840
幻灯片上的链接将你带到错误的地址，

512
00:24:33,740 --> 00:24:34,735
我会更新它，

513
00:24:34,735 --> 00:24:37,720
但如果你搜索 B+ 树可视化，

514
00:24:37,720 --> 00:24:39,000
你会得到这个。

515
00:24:39,590 --> 00:24:43,750
所以我要做一个 B+ 树的 demo ，阶数是 2 ，

516
00:24:43,750 --> 00:24:45,720
所以每个节点的最大键数是 2 ，

517
00:24:45,830 --> 00:24:47,970
最大指针数是 3 。

518
00:24:51,080 --> 00:24:52,195
所以我们要做的第一件事，

519
00:24:52,195 --> 00:24:53,520
我们插入 2 ，

520
00:24:54,170 --> 00:24:55,560
它落在我们的根节点上，

521
00:24:55,880 --> 00:24:56,760
我能把它放大一点吗，

522
00:24:58,220 --> 00:25:04,175
让我们试试这个，高度 200 ，

523
00:25:04,175 --> 00:25:05,650
然后现在我也许可以做这个，

524
00:25:07,120 --> 00:25:07,760
这样好点了吗？

525
00:25:10,360 --> 00:25:13,070
好的，然后我们要插入 6 ，

526
00:25:13,330 --> 00:25:16,365
再次，我们只有一个根节点，

527
00:25:16,365 --> 00:25:17,390
它可以容纳两个键，

528
00:25:17,530 --> 00:25:18,740
所以这里没有什么变化，

529
00:25:18,970 --> 00:25:20,300
所以现在我们要插入 4 。

530
00:25:22,680 --> 00:25:23,620
所以，在这个例中，

531
00:25:23,820 --> 00:25:25,340
我们尝试在根节点中放入三个键，

532
00:25:25,340 --> 00:25:26,170
我们不能这么做，

533
00:25:26,340 --> 00:25:27,700
所以它决定在 4 上分裂，

534
00:25:28,080 --> 00:25:30,190
生成两个新的叶子节点，

535
00:25:31,380 --> 00:25:33,160
然后中间的键是 4 ，

536
00:25:34,320 --> 00:25:35,890
任何小于 4 的在这边，

537
00:25:36,090 --> 00:25:37,565
大于 4 的在另一边，

538
00:25:37,565 --> 00:25:39,400
所以 2 在这个叶子节点，

539
00:25:39,480 --> 00:25:42,400
然后 4 和 8 在另一边。

540
00:25:42,600 --> 00:25:43,630
在这个实现中，

541
00:25:43,740 --> 00:25:45,760
它们只有一个方向的兄弟指针，

542
00:25:46,420 --> 00:25:47,370
有些系统这样做，

543
00:25:47,570 --> 00:25:48,690
Postgres 做了两个方向，

544
00:25:50,340 --> 00:25:52,310
这不是错的，只是做得不同，

545
00:25:54,410 --> 00:25:56,490
所以现在我插入 5 ，

546
00:25:56,630 --> 00:25:57,630
我跟着插入 4 ，

547
00:25:58,220 --> 00:26:00,840
4 小于 5 ，大于等于 4 ，

548
00:26:01,100 --> 00:26:02,725
所以它将向下移动到前一个节点，

549
00:26:02,725 --> 00:26:05,065
但是我已经有两个键了，

550
00:26:05,065 --> 00:26:08,890
所以我必须拆分那个叶子节点，

551
00:26:08,890 --> 00:26:09,780
我做了两个节点，

552
00:26:09,830 --> 00:26:11,400
然后我把 5 放在上面。

553
00:26:12,650 --> 00:26:13,050
好的？

554
00:26:16,800 --> 00:26:17,530
所以第一个，（大家）都还好吗？

555
00:26:22,730 --> 00:26:24,510
所以， delete 本质上是与此相反的，

556
00:26:24,800 --> 00:26:27,670
我们从根节点开始，向下移动，

557
00:26:27,670 --> 00:26:31,860
直到我们找到我们想要删除的条目，

558
00:26:31,940 --> 00:26:33,690
如果它不在那里，我们不会做任何事情，

559
00:26:34,010 --> 00:26:35,940
因为我们不能删除不存在的键，

560
00:26:37,690 --> 00:26:39,470
如果它在那里，那么我们继续并删除它，

561
00:26:39,550 --> 00:26:43,160
如果我们刚刚修改的叶子节点至少有一半是满的，

562
00:26:43,570 --> 00:26:44,240
那么我们就完成了，

563
00:26:45,220 --> 00:26:47,000
我们抛出它，什么都不做，

564
00:26:47,320 --> 00:26:52,540
但如果删除键后的叶子节点低于我们的阈值，

565
00:26:52,560 --> 00:26:54,520
M/2-1 ，

566
00:26:55,380 --> 00:26:56,710
M 是每个节点的键的数量，

567
00:26:57,060 --> 00:26:58,540
那我们就得重新分配，

568
00:26:58,950 --> 00:27:00,695
我们尝试做的第一件事是重新分配，

569
00:27:00,695 --> 00:27:02,590
意味着跟随兄弟指针，

570
00:27:02,880 --> 00:27:06,010
找到与我们相同级别的另一个节点，

571
00:27:06,600 --> 00:27:08,080
并获取它们的一个键，

572
00:27:08,280 --> 00:27:10,540
比如，只要他们不会变得不平衡，那就没问题，

573
00:27:10,860 --> 00:27:14,230
我们可能不得不在父节点上方进行调整，

574
00:27:14,660 --> 00:27:18,370
在父节点中，路标，分割点，

575
00:27:19,470 --> 00:27:21,670
但同样，这并不昂贵，

576
00:27:21,870 --> 00:27:23,230
因为我们已经有了它的 latch ，

577
00:27:24,510 --> 00:27:25,330
我们下一次会讲到。

578
00:27:26,070 --> 00:27:27,370
如果我们不能重新分配，

579
00:27:27,510 --> 00:27:29,890
那么我们必须将 L 与其兄弟项之一合并，

580
00:27:30,450 --> 00:27:32,110
将这两个的键组合在一起，

581
00:27:32,340 --> 00:27:34,870
然后相应地更新父节点。

582
00:27:35,340 --> 00:27:36,770
再次，这是递归的，

583
00:27:36,770 --> 00:27:41,010
所以如果我将两个节点合并在一起，

584
00:27:41,300 --> 00:27:43,570
然后我删除一个父节点上的路标键，

585
00:27:43,570 --> 00:27:45,150
现在父节点不到一半满了，

586
00:27:45,590 --> 00:27:47,760
然后合并将层叠向上。

587
00:27:50,050 --> 00:27:50,790
如果它，

588
00:27:50,790 --> 00:27:55,685
如果我有两个键，

589
00:27:55,685 --> 00:27:56,315
你有一个键，

590
00:27:56,315 --> 00:27:57,460
你是我的兄弟节点，

591
00:27:57,600 --> 00:27:58,550
我删除了一个键，

592
00:27:58,550 --> 00:27:59,620
我不到一半满了，

593
00:28:00,030 --> 00:28:00,755
这是个坏例子，

594
00:28:00,755 --> 00:28:02,800
因为有三个键，

595
00:28:03,390 --> 00:28:04,360
如果你有两个键，

596
00:28:04,470 --> 00:28:05,350
我有两个键，

597
00:28:05,700 --> 00:28:06,620
我删除一个键，

598
00:28:06,620 --> 00:28:08,120
我就像，哦，我没有一半满，

599
00:28:08,120 --> 00:28:09,800
我想拿走你的一个键，

600
00:28:09,800 --> 00:28:11,045
但如果我这么做了，

601
00:28:11,045 --> 00:28:12,070
你就没一半满了，

602
00:28:12,120 --> 00:28:12,850
所以我不能。

603
00:28:15,380 --> 00:28:16,720
好的，让我们回到我们的 demo 。

604
00:28:18,940 --> 00:28:19,760
好的，所以，

605
00:28:21,930 --> 00:28:22,745
我们可以继续并删除，

606
00:28:22,745 --> 00:28:24,340
所以让我们继续并删除 8 ，

607
00:28:25,620 --> 00:28:26,920
8 在这里最远的一端，

608
00:28:27,930 --> 00:28:29,470
它是 6 ，抱歉，

609
00:28:31,570 --> 00:28:34,820
6 ，在这里，删除 6 ，

610
00:28:34,990 --> 00:28:36,350
这是好的，我们仍然是平衡的，

611
00:28:36,700 --> 00:28:40,400
每个节点两个键，仍然是半满的，

612
00:28:41,620 --> 00:28:42,560
在这种情况下，是 1 ，

613
00:28:43,450 --> 00:28:46,730
我们可以去 4 阶，它看起来更好，

614
00:28:46,840 --> 00:28:52,420
但现在说我要删除中间的键 4 ，

615
00:28:52,830 --> 00:28:55,930
它基本上向上传播，并将其从上方移除。

616
00:28:56,760 --> 00:28:57,965
所以让我们来看看 4 阶，

617
00:28:57,965 --> 00:28:59,890
因为这样你就可以更好地看到偷取行为。

618
00:29:00,600 --> 00:29:02,590
所以让我们做同样的事情来插入 1 ，

619
00:29:04,080 --> 00:29:10,670
插入 2 4 5 ，

620
00:29:11,860 --> 00:29:12,860
分裂，现在我们到了这里，

621
00:29:14,410 --> 00:29:17,890
6 8 ，

622
00:29:24,110 --> 00:29:25,200
然后我们插入 9 。

623
00:29:29,030 --> 00:29:32,270
所以，我们将继续，删除这里中间的 5 ，

624
00:29:33,040 --> 00:29:34,800
再次，在这里，

625
00:29:34,850 --> 00:29:37,080
这个叶子节点将变得不到一半满，

626
00:29:37,400 --> 00:29:38,890
所以我们要做的第一件事就是，

627
00:29:38,890 --> 00:29:42,480
试着从它的兄弟节点那里偷取，

628
00:29:43,040 --> 00:29:44,220
所以，让我们继续并删除 5 ，

629
00:29:49,040 --> 00:29:49,770
没有那么做，

630
00:29:54,640 --> 00:29:55,220
为什么不是？

631
00:29:58,210 --> 00:29:58,610
是的。

632
00:30:01,010 --> 00:30:02,005
是什么？

633
00:30:03,560 --> 00:30:04,530
是的，我想是 4 ，

634
00:30:04,970 --> 00:30:06,600
所以我删除 4 ，看看它是怎么做的，

635
00:30:07,040 --> 00:30:08,580
是的，那里有偷取。

636
00:30:09,180 --> 00:30:11,410
是的，所以这个动画并不是完全按照教科书，

637
00:30:13,620 --> 00:30:14,810
但它是没有错的，

638
00:30:14,810 --> 00:30:16,120
这就像是做事情的不同方式，

639
00:30:16,140 --> 00:30:19,420
就像，你想在某些优化上有多积极，

640
00:30:19,950 --> 00:30:22,300
但是你得到了高层次想法，你可以偷取。

641
00:30:24,180 --> 00:30:25,620
但当你偷取时，你仍然必须更新父节点，

642
00:30:25,620 --> 00:30:27,170
因为这将更改边界点。

643
00:30:28,240 --> 00:30:29,925
是的。

644
00:30:36,550 --> 00:30:37,485
在这个例中，

645
00:30:37,485 --> 00:30:38,990
它们有单向的同级指针，

646
00:30:39,670 --> 00:30:42,650
Postgres 和其他系统有双向的链表。

647
00:30:46,230 --> 00:30:47,645
是的。

648
00:30:53,640 --> 00:30:54,430
是的，他的问题是，

649
00:30:56,150 --> 00:30:57,780
事实上，我有一个这样的例子，

650
00:31:02,485 --> 00:31:03,000
有个问题，

651
00:31:05,830 --> 00:31:07,095
实际上，我没有这样的例子，

652
00:31:07,095 --> 00:31:08,510
好的，我知道我在这中间做的，

653
00:31:10,520 --> 00:31:10,990
这些家伙，

654
00:31:11,250 --> 00:31:13,370
是的，所以我认为叶子节点，

655
00:31:13,370 --> 00:31:16,040
你肯定想要指针指向你的兄弟节点，

656
00:31:16,040 --> 00:31:18,970
因为你需要沿着叶子节点前进，

657
00:31:19,890 --> 00:31:23,140
如果这家伙变得更大了，

658
00:31:23,580 --> 00:31:25,210
你能有两个父节点吗，

659
00:31:25,290 --> 00:31:28,340
两个同一级别上的节点必须指着对方，

660
00:31:28,340 --> 00:31:29,800
即使它们有相同的父节点，

661
00:31:30,510 --> 00:31:31,685
你可以，我不知道，

662
00:31:31,685 --> 00:31:33,640
事实上，我不知道 Postgres 做了什么或其他系统做了什么。

663
00:31:42,120 --> 00:31:43,390
在这一点上，你可能不会，

664
00:31:44,560 --> 00:31:47,280
所以，如果你有相同的父节点，还是。

665
00:31:52,620 --> 00:31:55,780
每个节点都来自根节点，就像，

666
00:31:58,440 --> 00:32:01,450
这可能是一个，你必须重新组织一切，

667
00:32:01,740 --> 00:32:02,885
所以这可能会有帮助，

668
00:32:02,885 --> 00:32:05,410
但在这一点上，你在锁住整棵树，谁在乎呢？

669
00:32:08,430 --> 00:32:10,130
是的。

670
00:32:14,050 --> 00:32:14,745
这个问题是，

671
00:32:14,745 --> 00:32:17,895
如果你不存储指向父节点的指针，

672
00:32:17,895 --> 00:32:18,950
如何将数据发送到父节点？

673
00:32:19,820 --> 00:32:21,030
我们将在下一节课中讨论，

674
00:32:21,140 --> 00:32:23,245
因为基本上，当你向下时，

675
00:32:23,245 --> 00:32:26,460
你将跟踪你在向下时访问的节点堆栈，

676
00:32:26,660 --> 00:32:28,860
并跟踪你为哪些节点设置了 latch ，

677
00:32:29,480 --> 00:32:30,660
如果我向下，

678
00:32:31,190 --> 00:32:33,210
如果我从这里向下，

679
00:32:34,170 --> 00:32:37,270
然后比如这个家伙，我必须分裂，

680
00:32:38,460 --> 00:32:41,525
当我下来的时候，到了这里，

681
00:32:41,525 --> 00:32:42,070
我就会意识到，

682
00:32:42,090 --> 00:32:43,360
嘿，我要分裂了，

683
00:32:43,620 --> 00:32:45,125
不要释放我的父节点的 latch ，

684
00:32:45,125 --> 00:32:46,265
所以我还有一个指针，

685
00:32:46,265 --> 00:32:47,330
我还把它放在我的堆栈上，

686
00:32:47,330 --> 00:32:48,070
我可以回去看看。

687
00:32:48,720 --> 00:32:50,205
所以，这是 worker 的内部[簿记]，

688
00:32:50,205 --> 00:32:53,000
当它沿着树向下。

689
00:32:56,320 --> 00:32:56,960
是的，再次。

690
00:32:58,090 --> 00:33:01,670
所以我们将谈论它意味着更安全，更不安全，

691
00:33:01,750 --> 00:33:05,955
比如，当你往下的时候，你会知道，

692
00:33:05,955 --> 00:33:07,460
我在试着删除一些东西，

693
00:33:07,810 --> 00:33:08,730
所以当我往下时，

694
00:33:08,730 --> 00:33:10,530
如果我知道，不管如何，

695
00:33:10,530 --> 00:33:13,845
我下面的键 m ，不管它在哪里，

696
00:33:13,845 --> 00:33:18,390
我知道我不需要对这个节点进行合并或拆分，

697
00:33:18,390 --> 00:33:19,010
我所在的节点，

698
00:33:19,150 --> 00:33:21,710
所以一旦我过了它，我可以释放它的 latch ，

699
00:33:21,760 --> 00:33:23,480
它被认为是安全的，它不会，

700
00:33:23,530 --> 00:33:25,010
不管你下面发生什么，

701
00:33:25,090 --> 00:33:26,270
它永远不会重新组织，

702
00:33:26,350 --> 00:33:27,800
所以你不需要保留最后一个[字]。

703
00:33:28,210 --> 00:33:29,150
这将在下一节课中讲到。

704
00:33:38,010 --> 00:33:40,990
好的，这就是分裂、合并的基本操作，

705
00:33:42,240 --> 00:33:43,210
所以 B+ 树，

706
00:33:43,770 --> 00:33:44,650
只是一般的树，

707
00:33:44,910 --> 00:33:47,170
在数据库中， B+ 树，

708
00:33:47,460 --> 00:33:49,370
将会有一堆其他的东西，

709
00:33:49,370 --> 00:33:52,660
我们不能用哈希表。

710
00:33:53,520 --> 00:33:56,710
所以哈希表，我们唯一能做的操作就是，

711
00:33:58,150 --> 00:33:59,910
某个东西等于这个键，

712
00:33:59,910 --> 00:34:03,260
哈希键是否等于我要找的键，

713
00:34:03,670 --> 00:34:05,750
我们不能做小于，我们不能做大于，

714
00:34:06,160 --> 00:34:07,710
我们不能做任何部分键查找，

715
00:34:07,710 --> 00:34:10,025
你必须拥有完整的键。

716
00:34:10,025 --> 00:34:10,580
所以，如果我说，

717
00:34:10,580 --> 00:34:12,460
我在列 a b c 上构建索引，

718
00:34:12,870 --> 00:34:15,940
如果对于我的键，我只有列 a 和 b ，

719
00:34:16,200 --> 00:34:19,265
我不能哈希它并跳到任何有意义的地方，

720
00:34:19,265 --> 00:34:20,860
因为哈希是完全随机的。

721
00:34:21,820 --> 00:34:23,030
但是在 B+ 树中，

722
00:34:23,290 --> 00:34:24,390
我们可以做一系列的技巧，

723
00:34:24,390 --> 00:34:28,640
我们可能只拥有，或者不可能，

724
00:34:28,810 --> 00:34:30,380
你只能拥有部分键，

725
00:34:31,270 --> 00:34:34,310
或者基于你的键的特定数量的属性，

726
00:34:34,450 --> 00:34:36,890
并且仍然将其用于查询。

727
00:34:37,980 --> 00:34:39,640
再次，比如说 a b c 的索引，

728
00:34:40,200 --> 00:34:44,600
所以很明显，我可以做 a=1 b=2 c=3 ，

729
00:34:44,600 --> 00:34:45,830
这和哈希是一样的，

730
00:34:45,830 --> 00:34:47,830
我有[质量]匹配的所有键，

731
00:34:48,120 --> 00:34:50,960
都在我的，索引所基于的。

732
00:34:51,370 --> 00:34:53,150
我也可以做所谓的前缀搜索，

733
00:34:53,470 --> 00:34:57,570
我只有 a 和 b ，没有 c ，

734
00:34:57,570 --> 00:34:59,700
我们可以进行查找，

735
00:34:59,700 --> 00:35:02,750
定义所有匹配，基于 a 和 b ，而不包括 c 。

736
00:35:03,720 --> 00:35:05,975
但我们也，不是所有的系统都这样做，

737
00:35:05,975 --> 00:35:07,150
因为这样做更棘手，

738
00:35:07,260 --> 00:35:11,825
但我们也可以做后缀搜索，

739
00:35:11,825 --> 00:35:12,905
我们没有前缀，

740
00:35:12,905 --> 00:35:15,790
我们有键的后缀，

741
00:35:15,930 --> 00:35:18,340
所以我没有 a ，但我有 b 和 c ，

742
00:35:18,510 --> 00:35:21,040
我仍然可以使用我的索引，进行查找，

743
00:35:21,910 --> 00:35:23,535
很少有系统做这个，这太难了，

744
00:35:23,535 --> 00:35:24,560
Postgres 没有这么做，

745
00:35:24,910 --> 00:35:27,740
Oracle ，我认为也许 SQL Server 可以做这个。

746
00:35:28,510 --> 00:35:28,910
好的？

747
00:35:29,590 --> 00:35:30,765
再次，如果它是哈希索引，

748
00:35:30,765 --> 00:35:31,970
我们必须拥有整个键，

749
00:35:32,350 --> 00:35:34,280
并且它必须始终在[质量谓词]中。

750
00:35:37,570 --> 00:35:42,770
因为你基本上需要可能多个线程同时向下，

751
00:35:42,790 --> 00:35:44,810
每个线程协调，

752
00:35:45,820 --> 00:35:47,430
Oracle 可能有一个专利，

753
00:35:47,430 --> 00:35:48,740
禁止人们这样做，

754
00:35:48,940 --> 00:35:50,120
不会让我感到惊讶，我不知道，

755
00:35:50,560 --> 00:35:52,130
它们在 Oracle 被称为跳跃扫描，

756
00:35:53,350 --> 00:35:56,390
这可能是为什么没有人这样做的原因。

757
00:35:57,170 --> 00:35:57,930
好的，再次，

758
00:35:58,130 --> 00:36:00,300
我在 a 和 b 上有我的索引，

759
00:36:00,650 --> 00:36:02,250
如果我想找到键 1 和 2 ，

760
00:36:03,200 --> 00:36:04,740
再次，我使用我的路标，

761
00:36:04,910 --> 00:36:06,870
基本上只是查看键，

762
00:36:07,250 --> 00:36:10,230
以顺序模式键的各个部分，

763
00:36:10,400 --> 00:36:13,170
所以，首先我检查的是 1 小于等于 1 ，

764
00:36:13,640 --> 00:36:16,050
然后我检查第二部分是 2 小于等于 3 ，

765
00:36:16,250 --> 00:36:19,710
这告诉我我想沿着这个节点往下，

766
00:36:19,820 --> 00:36:21,450
然后我就可以找到我寻找的条目。

767
00:36:23,320 --> 00:36:24,810
如果我进行前缀搜索，

768
00:36:24,810 --> 00:36:27,710
意味着我有键的第一部分，但没有剩下的部分，

769
00:36:28,090 --> 00:36:31,860
所以我有 a 的键，但是没有 b ，

770
00:36:32,770 --> 00:36:34,305
这样做的方法是，

771
00:36:34,305 --> 00:36:36,230
你基本上查看你有的部分，

772
00:36:36,430 --> 00:36:37,940
然后看 1 是否小于等于 1 ，

773
00:36:38,260 --> 00:36:39,440
是的，继续往下走，

774
00:36:39,670 --> 00:36:41,180
然后我继续扫描，

775
00:36:41,500 --> 00:36:44,430
继续计算我的[谓词]，

776
00:36:44,430 --> 00:36:46,430
对于叶子节点中的所有键，

777
00:36:46,630 --> 00:36:48,050
直到我有违反的东西，

778
00:36:48,580 --> 00:36:52,400
或者我知道现在 1 小于 2 ，

779
00:36:52,510 --> 00:36:54,290
我不能遍历这里，

780
00:36:54,550 --> 00:36:55,380
因为这是一种顺序，

781
00:36:55,380 --> 00:36:57,195
我知道那里永远不会有任何东西，

782
00:36:57,195 --> 00:37:01,000
有一个键，第一部分 a 等于 1 ，

783
00:37:01,260 --> 00:37:02,440
b 后面有其他的东西，

784
00:37:02,580 --> 00:37:03,335
在这个点之后，

785
00:37:03,335 --> 00:37:07,390
因为它们是键的第一部分。

786
00:37:09,940 --> 00:37:11,420
同样，最后一个用于跳跃扫描，

787
00:37:11,650 --> 00:37:12,830
基本上发生的是，

788
00:37:12,880 --> 00:37:15,380
在每个节点上，你评估，

789
00:37:15,550 --> 00:37:17,360
好的，我有键的哪一部分，

790
00:37:17,950 --> 00:37:21,470
然后确定你必须看下面树的哪一部分，

791
00:37:21,580 --> 00:37:22,700
这是一个例子，

792
00:37:22,870 --> 00:37:25,100
因为我没有键的第一部分，

793
00:37:25,150 --> 00:37:26,630
我基本上必须查看所有东西。

794
00:37:27,410 --> 00:37:29,200
同样，我认为在 Oracle 中，

795
00:37:29,200 --> 00:37:30,810
他们可以让多个线程并行，

796
00:37:30,890 --> 00:37:32,190
沿着树的不同部分，

797
00:37:32,420 --> 00:37:34,560
然后在最后将结果组合在一起，

798
00:37:36,515 --> 00:37:37,990
这就像是在进行通配符搜索，

799
00:37:38,100 --> 00:37:41,295
我们最终将在 demo 中看到这个，

800
00:37:41,295 --> 00:37:42,855
在数据集中有这样的权衡，

801
00:37:42,855 --> 00:37:43,940
它会让它变得，

802
00:37:44,600 --> 00:37:45,730
它可能会说，好的，

803
00:37:47,110 --> 00:37:51,350
我知道一些关于我的索引所基于的键的统计数据，

804
00:37:51,670 --> 00:37:55,550
所以可能仍然值得我去看看键，看看索引，

805
00:37:55,870 --> 00:37:56,685
但它可能决定，

806
00:37:56,685 --> 00:37:58,730
好的，我不知道你想让我做什么，

807
00:37:58,960 --> 00:38:00,645
所以索引不会帮助我，

808
00:38:00,645 --> 00:38:02,300
我要对整张表做一个顺序扫描。

809
00:38:02,970 --> 00:38:04,400
这可能快于，

810
00:38:04,400 --> 00:38:06,550
尝试对索引进行多个探测，

811
00:38:06,750 --> 00:38:07,930
并将结果组合在一起。

812
00:38:09,020 --> 00:38:11,575
再次，这不是程序员必须处理的事情，

813
00:38:11,575 --> 00:38:13,090
这是我们使用 SQL 查询，

814
00:38:13,090 --> 00:38:14,910
并尝试自己解决这个。

815
00:38:16,430 --> 00:38:19,350
再次，我们在[]讨论这个。

816
00:38:22,470 --> 00:38:22,870
是的。

817
00:38:25,990 --> 00:38:28,215
这个问题是，

818
00:38:28,215 --> 00:38:30,050
是不是由程序来决定建立什么样的索引，

819
00:38:31,180 --> 00:38:32,150
大多数系统，是的。

820
00:38:33,150 --> 00:38:36,070
所以，这是数据库中的一个老问题，

821
00:38:37,350 --> 00:38:40,100
我谈到关系模型的抽象有多棒，

822
00:38:40,100 --> 00:38:42,610
你不必担心东西实际上是如何物理存储的等等，

823
00:38:42,960 --> 00:38:44,075
但是最终，

824
00:38:44,075 --> 00:38:46,330
总得有人来决定你到底需要什么样的索引，

825
00:38:46,940 --> 00:38:50,525
所以我自己在 CMU 有一长串的研究，

826
00:38:50,525 --> 00:38:52,400
但是，回到 1970 年代，

827
00:38:52,400 --> 00:38:54,910
人们试图自动找出你想要什么索引，

828
00:38:56,420 --> 00:38:59,560
所以，商业系统内置了工具，

829
00:38:59,560 --> 00:39:00,600
可以帮助你解决这一问题，

830
00:39:01,160 --> 00:39:02,700
MySQL 和 Postgres 没有这个，

831
00:39:03,390 --> 00:39:06,335
Postgres 将构建你告诉它需要的任何索引，

832
00:39:06,335 --> 00:39:08,330
为你做这些，

833
00:39:08,330 --> 00:39:08,800
所以你想，

834
00:39:09,060 --> 00:39:10,535
如果你告诉，我想要一千个索引，

835
00:39:10,535 --> 00:39:12,550
它就会这样做，

836
00:39:12,840 --> 00:39:17,250
在 Azure 的 SQL Server 中，

837
00:39:17,510 --> 00:39:18,670
它们实际上所做的是，

838
00:39:18,670 --> 00:39:22,500
它们为你的数据库系统启动一个单独的实例，

839
00:39:23,060 --> 00:39:24,990
尝试某种基本的机器算法，

840
00:39:25,700 --> 00:39:27,300
来找出你实际需要的索引，

841
00:39:27,440 --> 00:39:29,660
然后向你推荐它们，

842
00:39:30,430 --> 00:39:32,295
SQL Server 还做了其他有趣的事情，

843
00:39:32,295 --> 00:39:34,430
尽管在查询优化器中，

844
00:39:35,020 --> 00:39:36,830
我们将在期中之后讨论，

845
00:39:37,120 --> 00:39:38,150
你的查询会出现，

846
00:39:38,230 --> 00:39:40,400
它会开始根据你拥有的任何索引来计划它，

847
00:39:40,660 --> 00:39:42,020
但在某种程度上，你也可以说，

848
00:39:42,160 --> 00:39:43,455
伙计，这很好，

849
00:39:43,455 --> 00:39:46,310
如果我现在有一个索引在这个树上，在这个表上，

850
00:39:46,600 --> 00:39:49,130
它可能不能为你构建它，

851
00:39:49,360 --> 00:39:52,920
它可能可以只为那个查询构建，

852
00:39:52,920 --> 00:39:54,015
但它也会回来告诉你，

853
00:39:54,015 --> 00:39:54,650
嘿，顺便说一句，

854
00:39:54,850 --> 00:39:56,750
如果你给我这个索引，我会跑得更快。

855
00:39:57,610 --> 00:39:59,210
你可能必须的原因，

856
00:39:59,290 --> 00:40:01,640
你可以只为查询构建它，然后丢弃它，

857
00:40:01,900 --> 00:40:03,290
因为这只会影响该查询，

858
00:40:03,550 --> 00:40:06,110
你可能不想构建它，然后保留它，

859
00:40:06,220 --> 00:40:08,240
因为正如我所说的，你必须维护它，

860
00:40:08,260 --> 00:40:09,800
你必须使其与表保持同步，

861
00:40:10,210 --> 00:40:12,945
所以你不希望你的数据库添加大量索引，

862
00:40:12,945 --> 00:40:15,260
这将使我的所有插入、更新和删除变得更慢。

863
00:40:16,160 --> 00:40:18,990
此外，它们占用存储空间、内存空间，

864
00:40:19,280 --> 00:40:21,090
还有物理硬件的成本，

865
00:40:22,270 --> 00:40:25,185
这完全是另一个马蜂窝，

866
00:40:25,185 --> 00:40:25,730
我们可以进入。

867
00:40:29,640 --> 00:40:30,040
好的。

868
00:40:31,950 --> 00:40:33,310
所以，我们接下来要处理的事情是，

869
00:40:33,660 --> 00:40:35,710
在这一点上，我们知道如何做插入、更新和删除，

870
00:40:36,090 --> 00:40:37,570
我们知道做插入和删除，

871
00:40:37,830 --> 00:40:39,845
我们知道如何进行基本的查找

872
00:40:39,845 --> 00:40:41,015
来找到我们寻找的键，

873
00:40:41,015 --> 00:40:43,870
无论是前缀搜索、全键搜索还是跳跃扫描。

874
00:40:44,830 --> 00:40:47,720
我们要处理的下一个挑战是如何处理重复的键？

875
00:40:51,170 --> 00:40:52,980
所以，有两种方法可以做到这个。

876
00:40:54,250 --> 00:40:55,710
再说一次，问题会是这样的，

877
00:40:55,710 --> 00:40:57,110
因为我希望能够，

878
00:40:58,910 --> 00:41:01,410
让每件事都是 log(n) ，

879
00:41:01,550 --> 00:41:02,550
我该如何处理，

880
00:41:03,230 --> 00:41:07,120
有能力一遍又一遍地插入键和复制键，

881
00:41:07,120 --> 00:41:09,600
而不违反这一要求。

882
00:41:10,450 --> 00:41:11,865
所以，最常见的方法是，

883
00:41:11,865 --> 00:41:16,850
在键中维护某种隐藏列或隐藏属性，

884
00:41:17,410 --> 00:41:19,880
其中包含它所指向的 tuple 的记录 ID ，

885
00:41:20,970 --> 00:41:25,305
然后，这保证了每个键最终都是唯一的，

886
00:41:25,305 --> 00:41:26,520
如果你有一个键在 4 上，

887
00:41:26,520 --> 00:41:27,500
我有一个键在 4 上，

888
00:41:27,910 --> 00:41:29,385
但是你有一个 tuple ，我有一个 tuple ，

889
00:41:29,385 --> 00:41:32,660
如果我们把我们的记录 ID 作为键的一部分，

890
00:41:33,250 --> 00:41:35,300
除了基于他们的索引的列，

891
00:41:35,680 --> 00:41:37,820
那么你的 4 ，我的 4 ，最终是唯一的。

892
00:41:38,760 --> 00:41:40,690
因为我可以做前缀搜索，

893
00:41:41,220 --> 00:41:44,350
我不需要拥有键的所有元素来进行查找，

894
00:41:44,700 --> 00:41:46,180
所以这个方案仍然有效。

895
00:41:48,890 --> 00:41:51,930
另一种方法是溢出叶子节点，

896
00:41:52,370 --> 00:41:53,640
基本思想是，

897
00:41:53,990 --> 00:41:55,470
叶子节点本身，

898
00:41:55,550 --> 00:41:56,875
如果我太满，

899
00:41:56,875 --> 00:41:58,320
但我知道我插入的是相同的键，

900
00:41:58,640 --> 00:42:00,630
那么我可能会继续构建一个链表，

901
00:42:01,040 --> 00:42:04,410
我会再次深入树的深处，

902
00:42:04,730 --> 00:42:09,430
但这违反了我们的 log(n) 保证。

903
00:42:10,020 --> 00:42:13,870
好的，所以这就是我们如何做记录，

904
00:42:14,340 --> 00:42:16,450
现在的键不只是数字 1 ，

905
00:42:16,740 --> 00:42:19,690
它是 1 ，然后跟着是记录 ID ，

906
00:42:20,160 --> 00:42:21,520
也就是页码和偏移量。

907
00:42:22,440 --> 00:42:23,930
所以现在，如果我想插入 6 ，

908
00:42:23,930 --> 00:42:24,910
而 6 已经存在，

909
00:42:25,380 --> 00:42:29,470
那么，任何时候，即使你可能调用 SQL ， INSERT 6 ，

910
00:42:29,730 --> 00:42:31,865
数据库做的就是将其转换为，

911
00:42:31,865 --> 00:42:36,310
插入 6 ，后面跟着页码和 slot 编号。

912
00:42:37,000 --> 00:42:38,190
所以现在当我向下的时候，

913
00:42:39,050 --> 00:42:40,110
因为这个节点已经满了，

914
00:42:41,450 --> 00:42:44,490
我做一个分裂，滑动。

915
00:42:50,370 --> 00:42:51,650
所以节点滑动过去，

916
00:42:51,650 --> 00:42:55,150
现在我可以在这里插入 6 。

917
00:42:55,650 --> 00:42:58,055
从表面上看，它像是一个重复键，

918
00:42:58,055 --> 00:43:00,790
但是，实际的位本身是唯一的。

919
00:43:03,050 --> 00:43:05,610
当然，现在如果我想要再次删除 6 ，

920
00:43:06,350 --> 00:43:07,380
我将不得不，

921
00:43:07,460 --> 00:43:09,520
在内部，数据库系统将知道，

922
00:43:09,520 --> 00:43:14,840
好的，删除 6 跟着这个记录 ID 和页面偏移量，

923
00:43:14,840 --> 00:43:15,220
是的。

924
00:43:19,410 --> 00:43:21,100
问题是，如果键不是数字会发生什么，

925
00:43:21,450 --> 00:43:21,970
你是什么意思？

926
00:43:26,850 --> 00:43:28,420
所以，是的， 6 是键。

927
00:43:36,230 --> 00:43:37,770
因为我插入到一个表中，

928
00:43:38,360 --> 00:43:42,180
那个表在列 foo ，列 a 上有一个索引，

929
00:43:43,060 --> 00:43:48,300
我插入那个属性的 tuple 将值设置为 6 ，

930
00:43:48,350 --> 00:43:50,280
但是不是只放入 6 ，

931
00:43:50,660 --> 00:43:52,920
它会说，我已经插入了表中，

932
00:43:53,150 --> 00:43:54,270
现在我有了一个记录 ID ，

933
00:43:54,470 --> 00:43:55,690
所以当我插入索引时，

934
00:43:55,690 --> 00:43:58,980
它是 6 ，跟着记录 ID 的位，

935
00:43:59,980 --> 00:44:02,400
这保证了很多次我插入 6 ，

936
00:44:02,400 --> 00:44:03,770
它是唯一的，

937
00:44:04,000 --> 00:44:06,885
如果它是唯一索引，

938
00:44:06,885 --> 00:44:08,430
比如主键索引，

939
00:44:08,430 --> 00:44:09,890
或者我可以声明它是唯一索引，

940
00:44:10,180 --> 00:44:12,230
那么我不想这样做，

941
00:44:12,490 --> 00:44:14,330
但这一机制仍然有效。

942
00:44:25,180 --> 00:44:25,940
他的说法是，

943
00:44:26,140 --> 00:44:26,810
他是正确的，

944
00:44:26,860 --> 00:44:28,850
这本质上是一个隐藏的属性，

945
00:44:29,640 --> 00:44:33,880
保证了重复键在物理上是唯一的，

946
00:44:34,650 --> 00:44:35,735
因为它是记录 ID ，

947
00:44:35,735 --> 00:44:37,410
是的，这是个技巧。

948
00:44:42,820 --> 00:44:46,190
所以，溢出叶子节点如下所示，

949
00:44:46,420 --> 00:44:47,270
我插入 6 ，

950
00:44:47,440 --> 00:44:50,985
我发现它在我的叶子节点上已经满了，

951
00:44:50,985 --> 00:44:52,005
但我也认识到，

952
00:44:52,005 --> 00:44:53,955
你试图插入的东西已经存在于这里，

953
00:44:53,955 --> 00:44:55,040
因此它是一个重复的，

954
00:44:55,210 --> 00:45:00,000
所以我做了这个溢出页面，并将其插入到这里。

955
00:45:00,790 --> 00:45:02,640
我不断地插入新的东西，

956
00:45:02,640 --> 00:45:04,220
我一直像这样追加它。

957
00:45:06,510 --> 00:45:10,000
所以，这看起来类似于前面的链哈希表，

958
00:45:11,120 --> 00:45:11,560
就像是，

959
00:45:12,670 --> 00:45:16,610
不是让哈希函数告诉我我在链表的开始位置，

960
00:45:17,140 --> 00:45:18,530
而是在它前面有一个树结构，

961
00:45:18,640 --> 00:45:20,420
但本质上做的是相同的事情，

962
00:45:21,680 --> 00:45:24,330
当然，现在，再一次，这违反了 log(n) ，

963
00:45:24,710 --> 00:45:25,770
我们必须处理，

964
00:45:26,030 --> 00:45:27,430
如果我们真的想要拆分和合并，

965
00:45:27,430 --> 00:45:28,080
我们要移动什么东西，

966
00:45:28,850 --> 00:45:31,890
这使得事情比记录 ID 方法复杂得多，

967
00:45:33,235 --> 00:45:34,800
我不认为任何真正的系统会做到这个。

968
00:45:37,260 --> 00:45:38,890
问题是，这种方法的好处是什么，

969
00:45:39,030 --> 00:45:40,330
现在，我不需要保存记录 ID ，

970
00:45:41,100 --> 00:45:45,700
在每个键中保存一部分，

971
00:45:48,530 --> 00:45:50,170
这可能是更容易的工程设计，

972
00:45:51,270 --> 00:45:52,300
事实上，不是很清楚，这让它变得更难了。

973
00:45:53,330 --> 00:45:54,600
是的，这是个坏想法，别这么做，

974
00:45:55,610 --> 00:45:56,250
但是你可以，

975
00:45:56,480 --> 00:45:57,960
所以你可以，它是坏的。

976
00:46:05,380 --> 00:46:06,900
我想谈谈聚集索引，

977
00:46:07,125 --> 00:46:07,550
这些不是，

978
00:46:08,820 --> 00:46:10,325
我是说，至少你们知道这个对你们是有好处的，

979
00:46:10,325 --> 00:46:10,865
这是存在的，

980
00:46:10,865 --> 00:46:12,190
但我不想在上面花费太多时间，

981
00:46:12,270 --> 00:46:13,130
其基本思想是，

982
00:46:13,130 --> 00:46:18,250
有一些数据库系统允许你在表上定义所谓的聚集索引，

983
00:46:19,740 --> 00:46:23,920
你可以允许实际的表本身，实际的 tuple 本身，

984
00:46:24,180 --> 00:46:25,930
即使关系型模型没有排序，

985
00:46:26,070 --> 00:46:29,345
你可以说我希望磁盘上的物理 tuple 排序，

986
00:46:29,345 --> 00:46:32,110
基于某个索引定义的排序。

987
00:46:33,630 --> 00:46:34,580
在这个例子中，

988
00:46:34,580 --> 00:46:36,430
如果我有一个真正的聚集索引，

989
00:46:38,620 --> 00:46:40,670
无论我在哪里插入新记录，

990
00:46:41,170 --> 00:46:46,910
实际的堆文件本身都将保证按这种顺序排序，

991
00:46:47,660 --> 00:46:49,000
你可以再次考虑这个，

992
00:46:49,000 --> 00:46:50,965
MySQL SQLite 方法，

993
00:46:50,965 --> 00:46:52,560
叶子节点实际存储了 tuple ，

994
00:46:52,820 --> 00:46:54,420
这是自动聚集索引，

995
00:46:54,890 --> 00:46:56,160
但在一些数据库系统中，

996
00:46:56,330 --> 00:46:59,430
它不是一个有组织的表，

997
00:46:59,600 --> 00:47:05,130
你可以通过这种索引来强制执行。

998
00:47:06,720 --> 00:47:08,450
这样做的好处是，

999
00:47:08,450 --> 00:47:09,280
当我开始这样做，

1000
00:47:11,080 --> 00:47:12,240
当我想要开始扫描时，

1001
00:47:13,430 --> 00:47:14,970
假设我不是在进行索引、有组织的存储，

1002
00:47:15,380 --> 00:47:16,945
当我沿着叶子节点扫描，

1003
00:47:16,945 --> 00:47:18,180
以找到我正在寻找的所有 tuple ，

1004
00:47:18,440 --> 00:47:21,330
那么我肯定会得到页面，

1005
00:47:22,280 --> 00:47:26,430
在键定义的排序基础上。

1006
00:47:26,840 --> 00:47:30,060
所以，当我再一次扫描的时候，

1007
00:47:30,880 --> 00:47:32,110
我得到了我所有的条目，

1008
00:47:32,110 --> 00:47:32,920
我得到了我所有的页面，

1009
00:47:32,920 --> 00:47:34,830
我按顺序[撕开]它，事情变得很快。

1010
00:47:37,250 --> 00:47:38,640
如果你没有聚集索引，

1011
00:47:38,690 --> 00:47:41,850
那么你有时会得到一堆随机 I/O ，

1012
00:47:42,290 --> 00:47:46,590
再次，叶子节点可以按顺序存储在磁盘上，

1013
00:47:46,700 --> 00:47:51,420
但当我开始查找以获得叶子节点所指向的实际数据时，

1014
00:47:51,940 --> 00:47:55,085
最终可能是随机的。

1015
00:47:55,085 --> 00:47:56,555
所以，如果我做了一些非常愚蠢的事情，

1016
00:47:56,555 --> 00:47:59,110
比如我的缓冲池中有一个空闲的 frame ，

1017
00:47:59,580 --> 00:48:02,320
如果我按顺序扫描，

1018
00:48:03,120 --> 00:48:06,040
如果我按照页面从索引中出来的顺序获取页面，

1019
00:48:06,420 --> 00:48:09,500
我可能会得到一大堆冗余的 I/O ，

1020
00:48:09,500 --> 00:48:11,960
比如获取页面，在它上面运行，

1021
00:48:11,960 --> 00:48:13,295
因为这是我现在正在查看的键，

1022
00:48:13,295 --> 00:48:15,100
或者我指向的，

1023
00:48:15,330 --> 00:48:17,410
然后我扔掉它，获得下一页，

1024
00:48:17,610 --> 00:48:19,205
但是再几个键之后，

1025
00:48:19,205 --> 00:48:20,650
我会获取之前相同的页面。

1026
00:48:22,810 --> 00:48:25,130
所以，有一个非常简单的优化方法是，

1027
00:48:25,480 --> 00:48:31,250
当你沿着叶子节点扫描时，你不会检索到 tuple ，

1028
00:48:31,720 --> 00:48:32,630
当你查找它们时，

1029
00:48:32,830 --> 00:48:35,210
你首先扫描叶子节点，

1030
00:48:35,830 --> 00:48:37,130
获取所有页面的列表，

1031
00:48:38,070 --> 00:48:41,680
然后根据页面 ID 对它们进行排序，

1032
00:48:42,000 --> 00:48:43,690
然后根据这个进行检索，

1033
00:48:43,710 --> 00:48:45,215
现在你仍然需要[记账]，

1034
00:48:45,215 --> 00:48:47,860
以确保你跟随 tuple ，

1035
00:48:48,240 --> 00:48:49,940
按照索引定义的顺序，

1036
00:48:49,940 --> 00:48:51,190
这就是你所关心的。

1037
00:48:51,740 --> 00:48:53,510
同样，这是一种获得更多顺序 I/O ，

1038
00:48:53,510 --> 00:48:55,120
并减少随机访问量的方法。

1039
00:49:04,670 --> 00:49:06,480
所以，所以他的说法是，

1040
00:49:06,650 --> 00:49:08,740
为什么我不能跟踪我已经获取的页面，

1041
00:49:08,740 --> 00:49:09,510
然后我不再获取它。

1042
00:49:09,590 --> 00:49:10,765
我举了一个玩具例子，

1043
00:49:10,765 --> 00:49:12,480
比如，我只有一个 frame ，

1044
00:49:13,420 --> 00:49:14,805
所以我只能获取一页，

1045
00:49:14,805 --> 00:49:16,160
我把它扔掉，然后获取下一页，

1046
00:49:16,540 --> 00:49:17,990
在这个玩具例子中。

1047
00:49:20,400 --> 00:49:21,790
但是，考虑在一个真实的系统中，

1048
00:49:22,560 --> 00:49:23,690
不要考虑一页，

1049
00:49:23,690 --> 00:49:27,220
考虑，比如我可能有 10G 的空间，

1050
00:49:27,630 --> 00:49:31,130
但我的数据库是 1TB ，表是 1TB ，

1051
00:49:31,130 --> 00:49:32,980
然后你就会耗尽空间。

1052
00:49:35,840 --> 00:49:36,805
你想要对它们进行排序，

1053
00:49:36,805 --> 00:49:37,570
你想让它们出现在页面上，

1054
00:49:37,570 --> 00:49:41,220
你想要以它们在磁盘上的物理存在的顺序来访问它们，

1055
00:49:41,570 --> 00:49:43,165
然后仍然这样做，只是记账，

1056
00:49:43,165 --> 00:49:45,240
以确保你生成的结果的顺序

1057
00:49:45,560 --> 00:49:48,340
与的索引中排序顺序相匹配，

1058
00:49:50,880 --> 00:49:52,630
再次，为了减少浪费 I/O 的数量。

1059
00:49:57,810 --> 00:49:58,210
好的。

1060
00:49:58,890 --> 00:50:01,270
所以我想在这里快速介绍一些设计选择，

1061
00:50:02,010 --> 00:50:03,040
如何处理某些事情。

1062
00:50:03,150 --> 00:50:05,375
所以这些想法很多都来自这本书，

1063
00:50:05,375 --> 00:50:07,540
这本书被认为是 B+ 树的圣经，

1064
00:50:08,760 --> 00:50:10,030
来自 Goetz Graefe 这个人，

1065
00:50:11,130 --> 00:50:12,800
他发明了一系列不同的技术，

1066
00:50:12,800 --> 00:50:13,990
我们将在本学期讨论。

1067
00:50:15,380 --> 00:50:17,570
再次，这被称为现代 B 树技术，

1068
00:50:17,570 --> 00:50:18,860
再说一次，他说的是 B+ 树，

1069
00:50:18,860 --> 00:50:19,840
但他称之为 B 树，

1070
00:50:20,850 --> 00:50:22,790
事实上，如果你在 Google 上搜索这本书的名字，

1071
00:50:22,790 --> 00:50:24,140
它是 2010 年出版的，

1072
00:50:24,140 --> 00:50:24,455
这是一本很棒的书，

1073
00:50:24,455 --> 00:50:26,740
涵盖了很多这些技巧，甚至更多，

1074
00:50:27,710 --> 00:50:29,550
如果你用 Google 搜索，你会找到 PDF ，

1075
00:50:30,500 --> 00:50:31,465
如果你喜欢这种东西，

1076
00:50:31,465 --> 00:50:32,100
这是一本很好的读物。

1077
00:50:32,450 --> 00:50:33,930
因为它是理论，

1078
00:50:33,980 --> 00:50:36,180
这是如何在实际系统中实现它的方法。

1079
00:50:38,090 --> 00:50:39,010
好的，第一个问题是，

1080
00:50:39,010 --> 00:50:40,050
节点的大小是多少。

1081
00:50:40,790 --> 00:50:42,450
所以，你可以假设，

1082
00:50:42,500 --> 00:50:43,735
在这里的所有图表中，

1083
00:50:43,735 --> 00:50:45,480
一个节点对应于一个页面，

1084
00:50:46,700 --> 00:50:50,160
在我们的数据库文件中，在我们的缓冲池中，

1085
00:50:51,320 --> 00:50:54,150
但在某些系统中，例如在 IBM DB2 中，

1086
00:50:54,410 --> 00:50:56,095
你实际上可以修改，

1087
00:50:56,095 --> 00:51:00,240
你为不同的表和不同的索引配置数据库页的大小。

1088
00:51:00,830 --> 00:51:03,090
所以，根据硬件的不同，

1089
00:51:03,260 --> 00:51:04,560
你可能希望设置大小，

1090
00:51:04,640 --> 00:51:07,890
B+ 树节点的页面大小不同，

1091
00:51:08,700 --> 00:51:10,770
所以，磁盘速度越慢，

1092
00:51:10,770 --> 00:51:12,300
通常你想要的页面越大，

1093
00:51:12,300 --> 00:51:16,190
因为这将更有利于最大化顺序 I/O 。

1094
00:51:16,960 --> 00:51:18,890
所以，如果你是一个旧的旋转磁盘硬盘，

1095
00:51:19,180 --> 00:51:21,080
你想要页面大小大约为 1 兆字节，

1096
00:51:21,430 --> 00:51:23,955
现在，键的数量适应 1 兆字节，

1097
00:51:23,955 --> 00:51:26,505
将被定义你的键的大小，

1098
00:51:26,505 --> 00:51:27,675
如果它们都是 8 位整数，

1099
00:51:27,675 --> 00:51:29,210
那么你可以存储很多它们，

1100
00:51:30,160 --> 00:51:32,180
可能比你实际拥有的更多。

1101
00:51:33,570 --> 00:51:35,020
但是对于快速的 SSD ，

1102
00:51:35,310 --> 00:51:38,860
它大约是 8 到 10 千字节被认为是合适的大小，

1103
00:51:38,910 --> 00:51:40,220
如果你是在内存中，

1104
00:51:40,220 --> 00:51:43,690
512 个字节被认为是合适的大小，

1105
00:51:43,920 --> 00:51:44,890
在一个缓存行中，

1106
00:51:44,970 --> 00:51:47,240
你让事情变得非常高效。

1107
00:51:50,720 --> 00:51:51,750
我们讨论了，

1108
00:51:51,860 --> 00:51:54,415
一些系统实际上可能会违反这一要求，

1109
00:51:54,415 --> 00:51:56,070
每个节点都必须是半满的，

1110
00:51:56,510 --> 00:51:57,900
显然，你不能更多，

1111
00:51:58,460 --> 00:51:59,875
不能拥有比你实际存储的更多的键，

1112
00:51:59,875 --> 00:52:00,930
因为你的空间用完了，

1113
00:52:02,320 --> 00:52:04,470
但你能认出这个，

1114
00:52:04,910 --> 00:52:06,240
好的，大部分，

1115
00:52:07,140 --> 00:52:08,260
也许我不想拆分，

1116
00:52:08,460 --> 00:52:11,050
或者我想一直合并我的节点，

1117
00:52:12,360 --> 00:52:16,920
这样我就可以暂时低于这个阈值，

1118
00:52:17,920 --> 00:52:20,220
看看是否会插入一些东西，

1119
00:52:20,870 --> 00:52:22,570
然后让我超过这个阈值，

1120
00:52:22,570 --> 00:52:24,660
以避免过早地这样做。

1121
00:52:26,570 --> 00:52:28,500
这就是为什么 Postgres 称他们的平衡，

1122
00:52:28,970 --> 00:52:32,100
他们把他们的 B+ 树称为非平衡 B+ 树，

1123
00:52:33,680 --> 00:52:35,880
因为他们可能会违反这个要求。

1124
00:52:38,930 --> 00:52:39,445
下一个问题是，

1125
00:52:39,445 --> 00:52:40,890
你希望如何处理可变长度键，

1126
00:52:41,600 --> 00:52:43,020
我想是有人提起了这件事。

1127
00:52:43,460 --> 00:52:44,250
所以，

1128
00:52:45,430 --> 00:52:48,435
我们可以试着像一个列存储一样处理它，

1129
00:52:48,435 --> 00:52:49,730
我们希望每个东西都是固定长度的。

1130
00:52:51,010 --> 00:52:52,200
要做到这个的一种方法是，

1131
00:52:52,200 --> 00:52:55,160
实际上你不在每个节点中存储键本身，

1132
00:52:55,420 --> 00:52:57,860
而是存储一个指向键的指针，比如记录 ID ，

1133
00:52:58,810 --> 00:53:03,020
因为这将始终是 32 位或 64 位，

1134
00:53:03,430 --> 00:53:05,355
实际上，这也将节省空间，

1135
00:53:05,355 --> 00:53:07,640
因为，如果我的键都很大，

1136
00:53:08,230 --> 00:53:09,180
我就不会存储它们，

1137
00:53:09,180 --> 00:53:12,470
再次， B+ 树是表格中的副本，

1138
00:53:12,970 --> 00:53:15,380
我只需存储到指向记录 ID 的指针，

1139
00:53:15,760 --> 00:53:17,900
在节点中。

1140
00:53:19,430 --> 00:53:20,970
这是个好主意还是坏主意？

1141
00:53:26,780 --> 00:53:30,325
他是对的，听起来不是个好主意，

1142
00:53:30,325 --> 00:53:32,160
因为它会导致很多非顺序的 I/O 。

1143
00:53:32,840 --> 00:53:35,635
考虑我正在向下遍历我的节点，

1144
00:53:35,635 --> 00:53:37,140
我必须弄清楚我是向左还是向右，

1145
00:53:37,860 --> 00:53:39,735
我的节点上没有那些路标，

1146
00:53:39,735 --> 00:53:43,470
我必须沿着指针去获取页面中的那个 tuple ，

1147
00:53:43,470 --> 00:53:45,740
然后进行查找以找到我需要的东西。

1148
00:53:46,270 --> 00:53:47,310
再次，当我这样做的时候，

1149
00:53:47,310 --> 00:53:49,490
我在我的数据结构中持有 latch ，

1150
00:53:49,750 --> 00:53:50,930
这将是非常缓慢的。

1151
00:53:51,100 --> 00:53:54,080
是的，所以没人会在数据库系统中这样做。

1152
00:53:54,860 --> 00:53:57,300
这种 B+ 树的变体称为 T 树，

1153
00:53:58,850 --> 00:53:59,890
我弄清楚 T 代表什么，

1154
00:53:59,890 --> 00:54:01,050
我想这表示这家伙的名字，

1155
00:54:03,640 --> 00:54:06,560
在图表中，节点看起来像 [T] ，

1156
00:54:06,820 --> 00:54:08,130
但我想电子邮件说的是，

1157
00:54:08,130 --> 00:54:09,530
哦，是的，那个人的名字，但是无论什么。

1158
00:54:10,720 --> 00:54:12,645
内存数据库在 80 年代做了这个，

1159
00:54:12,645 --> 00:54:13,695
因为他们想要节省空间，

1160
00:54:13,695 --> 00:54:15,540
你想在你的 B+ 树上有重复的键，

1161
00:54:15,540 --> 00:54:16,430
因为他们没有太多的内存。

1162
00:54:16,630 --> 00:54:19,190
但再说一次，现在没有人在真正的系统中这样做，

1163
00:54:19,210 --> 00:54:21,555
因为执行其他查找的成本太高了，

1164
00:54:21,555 --> 00:54:23,270
只是复制键更容易。

1165
00:54:24,340 --> 00:54:26,150
你可以支持可变长度节点，

1166
00:54:27,660 --> 00:54:31,450
或者，节点的大小在索引中可能会有所不同，

1167
00:54:31,950 --> 00:54:32,810
你必须这样做，

1168
00:54:32,810 --> 00:54:34,360
因为你不知道大小，

1169
00:54:35,250 --> 00:54:37,990
你希望在每个节点中都有相同的潜在数量的键，

1170
00:54:38,100 --> 00:54:38,890
但是没有人，

1171
00:54:40,320 --> 00:54:44,540
你可能没有足够的空间在节点中存储所有这些键。

1172
00:54:46,160 --> 00:54:48,985
据我所知，只有学术系统才会这样做，

1173
00:54:48,985 --> 00:54:50,400
在现实世界中，没有人会这样做。

1174
00:54:51,240 --> 00:54:52,900
填充是处理这个问题的另一种方法，

1175
00:54:52,950 --> 00:54:55,240
正如我们之前在列存储中讨论的那样，

1176
00:54:56,160 --> 00:54:57,340
再次，我认为这是罕见的，

1177
00:54:57,480 --> 00:54:58,730
大多数人会做的是，

1178
00:54:58,730 --> 00:55:02,740
他们基本上会有一个 slot array ，

1179
00:55:03,920 --> 00:55:08,100
像我们在表页中看到的那样的 slot 页方法，

1180
00:55:08,510 --> 00:55:10,710
你有这个指针数组，

1181
00:55:11,150 --> 00:55:14,760
它在你查看的页面中或者另一个溢出页面。

1182
00:55:18,530 --> 00:55:20,425
再次，怎么说这个，

1183
00:55:20,425 --> 00:55:22,975
它就像我们之前看到的溢出值一样，

1184
00:55:22,975 --> 00:55:23,520
你只是，

1185
00:55:24,120 --> 00:55:26,235
你知道我要找的东西不是我的页面，

1186
00:55:26,235 --> 00:55:27,590
我得去别的地方去获取它。

1187
00:55:30,610 --> 00:55:32,720
现在我们要谈谈到底如何查找键，

1188
00:55:33,580 --> 00:55:35,620
一旦我们到了节点上，

1189
00:55:35,620 --> 00:55:36,450
我们把它带到内存中，

1190
00:55:36,530 --> 00:55:38,395
我们寻找一个键，决定向左还是向右，

1191
00:55:38,395 --> 00:55:41,665
或者我们是否在叶子节点中找到我们想要的匹配，

1192
00:55:41,665 --> 00:55:44,040
我们必须决定如何进行匹配。

1193
00:55:45,030 --> 00:55:47,260
所以最简单的方法就是做一个线性扫描。

1194
00:55:47,880 --> 00:55:48,970
考虑一个数组，

1195
00:55:49,440 --> 00:55:51,100
无论它是否排序，

1196
00:55:51,330 --> 00:55:52,300
我只是从头开始，

1197
00:55:52,530 --> 00:55:54,530
一直往看，直到找到我要找的东西，

1198
00:55:54,530 --> 00:55:55,990
在这个情况下，我在找键 8 ，

1199
00:55:57,365 --> 00:56:00,070
这很简单，这太傻了，这很管用，是吧？

1200
00:56:01,260 --> 00:56:02,240
不过，我们可以做得更好一些，

1201
00:56:02,240 --> 00:56:02,950
使用 SIMD ，

1202
00:56:03,690 --> 00:56:04,355
实际上它是，

1203
00:56:04,355 --> 00:56:06,160
在座的谁学过 418/618 ？

1204
00:56:07,540 --> 00:56:08,480
没有人，好的，

1205
00:56:09,040 --> 00:56:10,370
在座的谁不知道 SIMD 是什么？

1206
00:56:12,070 --> 00:56:15,350
好的，好的， SIMD 代表单指令流多数据流，

1207
00:56:15,550 --> 00:56:18,165
这是现代 CPU 上有的一类指令，

1208
00:56:18,165 --> 00:56:21,560
它允许你有一个向量寄存器，

1209
00:56:22,030 --> 00:56:23,420
你把一堆值放进去，

1210
00:56:23,470 --> 00:56:26,370
然后有一条指令，在上面做一些事情，

1211
00:56:26,370 --> 00:56:28,670
比如你可以把一堆数字放进一个向量，

1212
00:56:28,780 --> 00:56:29,970
一堆数字和另一个向量，

1213
00:56:29,970 --> 00:56:32,630
然后把它们加在一起，输出到另一个向量，

1214
00:56:33,040 --> 00:56:34,850
我们将在讨论查询执行时讨论这个，

1215
00:56:35,020 --> 00:56:37,760
但这是现代系统中使用的一种非常常见的技术，

1216
00:56:38,140 --> 00:56:40,710
这就是 10 年前让 Snowflake 变得特别的地方。

1217
00:56:41,720 --> 00:56:43,975
好的，所以我能做的是，

1218
00:56:43,975 --> 00:56:49,230
不是一个接一个地查看每个键，试着找到 8 ，

1219
00:56:49,730 --> 00:56:53,125
我可以使用 SIMD 内部函数，

1220
00:56:53,125 --> 00:56:53,710
在这个例中，

1221
00:56:53,710 --> 00:56:55,090
这是对于 x86 ，

1222
00:56:55,090 --> 00:57:02,650
在 128 位寄存器上对 32 位整数进行求值。

1223
00:57:02,730 --> 00:57:04,240
所以我查找 8 ，

1224
00:57:04,440 --> 00:57:05,780
我存储八个（应该是四个） 8 的副本，

1225
00:57:05,780 --> 00:57:07,420
我的 SIMD 寄存器有 4 个通道，

1226
00:57:07,740 --> 00:57:09,080
现在，在一条指令中，

1227
00:57:09,080 --> 00:57:15,430
我可以用数组中的键对这八个 8 或四个 8 求值，

1228
00:57:15,720 --> 00:57:16,820
然后我会得到位 mask ，

1229
00:57:16,820 --> 00:57:19,330
如果没有匹配，则为 0 ，

1230
00:57:19,530 --> 00:57:20,410
如果匹配，则为 1 。

1231
00:57:20,730 --> 00:57:21,610
所以在这种情况下，

1232
00:57:21,630 --> 00:57:23,620
现在只有一条指令来进行求值，

1233
00:57:24,280 --> 00:57:26,460
我可以用这种方式比一个接一个地做更有效率。

1234
00:57:26,720 --> 00:57:27,310
在这种情况下，

1235
00:57:27,310 --> 00:57:28,780
对于这个，我没有匹配，

1236
00:57:28,780 --> 00:57:29,700
所以我把它滑过去，

1237
00:57:29,990 --> 00:57:31,410
看看下一个，

1238
00:57:31,580 --> 00:57:34,465
我必须认识到我只有三个键，而不是四个，

1239
00:57:34,465 --> 00:57:35,695
所以我必须玩一些小把戏来确保，

1240
00:57:35,695 --> 00:57:37,230
就像我不会得到假的确定。

1241
00:57:37,700 --> 00:57:38,560
但在这种情况下，

1242
00:57:38,560 --> 00:57:41,040
现在我在第一个通道上有 8 等于 8 ，

1243
00:57:41,060 --> 00:57:41,760
我有一个匹配。

1244
00:57:42,890 --> 00:57:44,020
所以我可以更有效地这样做，

1245
00:57:44,020 --> 00:57:44,700
然后做这个，

1246
00:57:45,050 --> 00:57:46,170
它仍然是线性的，

1247
00:57:46,460 --> 00:57:47,910
但我是分批进行的，

1248
00:57:48,170 --> 00:57:49,380
硬件可以支持它。

1249
00:57:52,220 --> 00:57:53,880
下一个方法，显然是进行二分搜索，

1250
00:57:54,350 --> 00:57:55,650
假设它是排序的，这很容易，

1251
00:57:55,670 --> 00:57:56,460
你跳到中间，

1252
00:57:56,960 --> 00:57:57,990
我的值大于，

1253
00:57:58,220 --> 00:58:01,590
键大于，小于我要找的那个，

1254
00:58:01,670 --> 00:58:03,160
我跳到下一边，以此类推，

1255
00:58:03,160 --> 00:58:03,900
直到我找到我匹配的，

1256
00:58:04,610 --> 00:58:05,250
然后我就完成了。

1257
00:58:05,760 --> 00:58:07,130
这是大多数系统都会做的事情。

1258
00:58:09,660 --> 00:58:10,810
这取决于硬件，

1259
00:58:11,460 --> 00:58:14,130
所以在 Postgres 中是 8 千字节，

1260
00:58:14,130 --> 00:58:16,890
但是同样，你可以在节点中存储的键的数量

1261
00:58:16,890 --> 00:58:19,130
取决于键的类型。

1262
00:58:20,640 --> 00:58:21,070
好的。

1263
00:58:22,870 --> 00:58:24,560
所以，二分搜索是最常见的一种。

1264
00:58:25,570 --> 00:58:25,970
这个，

1265
00:58:27,550 --> 00:58:28,460
你可以做这个，

1266
00:58:28,510 --> 00:58:29,150
我不认为任何，

1267
00:58:30,190 --> 00:58:31,700
学术界之外，没有人这样做。

1268
00:58:32,230 --> 00:58:33,500
你可以做插值搜索，

1269
00:58:33,850 --> 00:58:34,650
这个方法可行，

1270
00:58:34,650 --> 00:58:36,620
如果你的键中没有间隔，

1271
00:58:36,910 --> 00:58:39,110
并且它们总是按单调递增的顺序排列，

1272
00:58:39,310 --> 00:58:40,695
如果你有一个主键，

1273
00:58:40,695 --> 00:58:43,640
那就像自动增量值，

1274
00:58:43,810 --> 00:58:45,560
比如加一，加一，加一，

1275
00:58:46,150 --> 00:58:47,750
再次，我假设我没有任何间隔，

1276
00:58:48,130 --> 00:58:49,170
那么这只是一个简单的数学运算，

1277
00:58:49,170 --> 00:58:51,410
在我的数组中准确地计算出，

1278
00:58:51,610 --> 00:58:52,785
我知道最低点，

1279
00:58:52,785 --> 00:58:54,290
我知道最小值，最大值，

1280
00:58:54,960 --> 00:58:56,450
我知道键的数量，

1281
00:58:56,650 --> 00:58:58,185
我只需要做一个简单的公式，

1282
00:58:58,185 --> 00:59:00,380
跳到我需要的偏移量，

1283
00:59:00,610 --> 00:59:01,220
我就完成了。

1284
00:59:02,160 --> 00:59:03,320
这是最快的方法，

1285
00:59:03,320 --> 00:59:04,355
比二分搜索快，

1286
00:59:04,355 --> 00:59:05,320
比 SIMD 快，

1287
00:59:05,940 --> 00:59:08,080
但是再次，你不能有间隔来做这个。

1288
00:59:09,370 --> 00:59:09,930
所以，这是很罕见的。

1289
00:59:13,160 --> 00:59:16,315
我们还有 20 分钟来完成所有这些优化，

1290
00:59:16,315 --> 00:59:17,580
让我们看看我们能走多远，好吧。

1291
00:59:18,470 --> 00:59:19,800
其中一些应该是非常明显的，

1292
00:59:21,350 --> 00:59:24,060
Pointer Swizzling 和 Buffered Updates ，

1293
00:59:24,350 --> 00:59:25,380
这些可能是最重要的。

1294
00:59:26,240 --> 00:59:26,640
Deduplication 也是。

1295
00:59:27,810 --> 00:59:31,630
好的，所以，就像在列存储中一样，

1296
00:59:31,800 --> 00:59:32,900
我们应该认识到，

1297
00:59:32,900 --> 00:59:35,680
将在我们 B+ 树中的键，

1298
00:59:36,210 --> 00:59:37,990
它们将位于相同的值域中，

1299
00:59:39,270 --> 00:59:41,230
因为它们都来自相同的属性，

1300
00:59:41,670 --> 00:59:43,220
此外，它们是经过排序的，

1301
00:59:43,220 --> 00:59:45,490
这对于压缩来说更好。

1302
00:59:45,990 --> 00:59:47,555
所以，我们可以利用很多东西，

1303
00:59:47,555 --> 00:59:50,860
来认识到这些值将非常相似，

1304
00:59:51,360 --> 00:59:55,240
以减小我们存储的键的大小。

1305
00:59:55,930 --> 00:59:56,835
在这种情况下，

1306
00:59:56,835 --> 00:59:58,160
我们可以进行前缀压缩，

1307
00:59:58,600 --> 00:59:59,925
我们可以确定，

1308
00:59:59,925 --> 01:00:04,070
我们将拥有一组在物理顺序上彼此非常接近的键，

1309
01:00:04,090 --> 01:00:06,740
它们将具有重叠的数据部分。

1310
01:00:07,150 --> 01:00:09,170
所以我们不是存储密钥的完整副本，

1311
01:00:09,670 --> 01:00:12,050
我们存储公共前缀，在这里是 rob ，

1312
01:00:12,580 --> 01:00:16,780
然后我们存储剩余的后缀，那是唯一的。

1313
01:00:18,160 --> 01:00:19,140
这很容易，这很好。

1314
01:00:21,220 --> 01:00:22,880
下一项技术是重复数据删除，

1315
01:00:23,620 --> 01:00:24,950
这里的想法是，

1316
01:00:25,480 --> 01:00:28,870
我们将拥有一堆键，

1317
01:00:28,980 --> 01:00:33,490
以相同的值结束，

1318
01:00:33,810 --> 01:00:38,270
在相同的节点中，

1319
01:00:38,860 --> 01:00:44,870
再次，忽略前缀，将记录 ID 放在末尾，

1320
01:00:45,130 --> 01:00:47,280
因为系统知道它做的，

1321
01:00:47,280 --> 01:00:48,530
它可以取出那一块，

1322
01:00:48,700 --> 01:00:50,235
但如果我有一堆非唯一的键，

1323
01:00:50,235 --> 01:00:52,400
它们最终将在同一个节点中，

1324
01:00:53,240 --> 01:00:55,440
这就像前缀排序或前缀压缩，

1325
01:00:55,880 --> 01:00:58,440
我只需存储一次重复的键，

1326
01:00:58,790 --> 01:01:00,520
然后拥有一个[发布]列表，

1327
01:01:00,520 --> 01:01:03,960
或与该键对应的所有值的列表，

1328
01:01:04,640 --> 01:01:08,720
现在我只需存储那个键的一个副本。

1329
01:01:09,610 --> 01:01:14,840
Postgres 添加这个，我想是 Postgres 15 ，

1330
01:01:14,840 --> 01:01:15,850
我想它是去年发布的，

1331
01:01:16,200 --> 01:01:19,690
它对你的节点大小有了很大的下降。

1332
01:01:26,780 --> 01:01:27,575
好的，所以他的问题是，

1333
01:01:27,575 --> 01:01:29,585
我们怎么知道，

1334
01:01:29,585 --> 01:01:31,420
我们应该解释这是什么，

1335
01:01:31,950 --> 01:01:32,980
这些是值，而不是键，

1336
01:01:33,450 --> 01:01:34,450
这只是一个模型，

1337
01:01:34,530 --> 01:01:37,330
你不会完全像这样对页面进行排序，

1338
01:01:37,500 --> 01:01:40,690
显然，你将拥有存储的元素数量的长度，

1339
01:01:41,320 --> 01:01:42,140
不只是显示的这样，

1340
01:01:42,190 --> 01:01:43,245
你有其他元数据，

1341
01:01:43,245 --> 01:01:44,180
它们知道偏移量在哪里。

1342
01:01:47,960 --> 01:01:49,380
我们还可以进行后缀截断，

1343
01:01:50,000 --> 01:01:53,995
因为内部节点不必是键的完全副本，

1344
01:01:53,995 --> 01:01:55,920
因为那些键可能不存在于叶子节点中，

1345
01:01:56,360 --> 01:01:58,350
所以我们可能不必存储整个键，

1346
01:01:59,040 --> 01:02:03,830
我们只需要足够的键前缀，

1347
01:02:03,830 --> 01:02:06,040
来区分我们需要向左还是向右。

1348
01:02:07,250 --> 01:02:08,260
所以在这种情况下，

1349
01:02:08,260 --> 01:02:10,705
我有键 abc 到 k ，

1350
01:02:10,705 --> 01:02:12,870
然后 lmno 到 v ，

1351
01:02:13,690 --> 01:02:17,030
在本例中，真正重要的东西是，

1352
01:02:17,410 --> 01:02:20,240
比如这两个字符串的前三个字符，

1353
01:02:21,170 --> 01:02:24,570
所以我的内部节点只需要存储最小前缀，

1354
01:02:25,100 --> 01:02:27,240
我们需要决定是向左还是向右。

1355
01:02:29,780 --> 01:02:31,375
当然，现在的挑战是，

1356
01:02:31,375 --> 01:02:33,150
如果我插入一个键，

1357
01:02:33,890 --> 01:02:35,040
如果我插入一个键，

1358
01:02:35,930 --> 01:02:37,740
可能在它们之间，

1359
01:02:37,910 --> 01:02:39,600
也许我得回去，获取原始键，

1360
01:02:39,800 --> 01:02:41,370
来决定前缀应该是什么，

1361
01:02:43,000 --> 01:02:45,210
但在某些环境中，这可能是正确的。

1362
01:02:48,970 --> 01:02:51,290
所以， Pointer Swizzling 是一种常见的技术，

1363
01:02:51,370 --> 01:02:56,545
它将允许我们最大限度地减少查找量，

1364
01:02:56,545 --> 01:02:58,530
我们必须在缓冲池页表中所做的。

1365
01:02:59,510 --> 01:03:03,090
因为同样，当我们遍历节点，遍历树结构时，

1366
01:03:04,910 --> 01:03:06,930
我一直叫做指针，

1367
01:03:07,040 --> 01:03:08,370
它们实际上是页面 ID 。

1368
01:03:09,000 --> 01:03:10,275
所以我要去页面表说，

1369
01:03:10,275 --> 01:03:11,640
好的，如果这个页面存在，

1370
01:03:11,640 --> 01:03:14,470
给我指向它的指针。

1371
01:03:15,450 --> 01:03:17,830
所以，如果我想说查找大于 3 的键，

1372
01:03:18,240 --> 01:03:19,510
我从这里的根节点开始，

1373
01:03:20,400 --> 01:03:21,800
我查看键，

1374
01:03:21,800 --> 01:03:23,135
并决定是否要向左和向右移动，

1375
01:03:23,135 --> 01:03:25,660
在这种情况下，我想向左，

1376
01:03:26,400 --> 01:03:31,200
但是，这个节点中的值将是页码，

1377
01:03:31,200 --> 01:03:31,940
所以页 #2 ，

1378
01:03:32,290 --> 01:03:33,555
现在我要去我的缓冲池，

1379
01:03:33,555 --> 01:03:36,440
然后说，好的，给我指向页 #2 的指针，

1380
01:03:37,360 --> 01:03:38,940
同样在底部，

1381
01:03:38,940 --> 01:03:40,940
我想沿着兄弟节点扫描，

1382
01:03:41,380 --> 01:03:42,680
从页 #2 转到页 #3 ，

1383
01:03:42,730 --> 01:03:43,940
我必须回到缓冲池。

1384
01:03:45,330 --> 01:03:47,830
所以这个技术， Pointer Swizzling 的想法是，

1385
01:03:48,500 --> 01:03:50,470
如果你将页固定在缓冲池中，

1386
01:03:50,820 --> 01:03:53,920
比如这个页不能被驱逐，

1387
01:03:54,770 --> 01:03:59,280
然后，任何指向你固定的页面的页面，

1388
01:03:59,360 --> 01:04:00,330
你也必须固定，

1389
01:04:01,340 --> 01:04:04,830
你将其内容替换为内存中的实际指针，

1390
01:04:06,870 --> 01:04:09,850
所以现在当我扫描，当我遍历我的树时，

1391
01:04:10,020 --> 01:04:11,465
我不会去缓冲池说，

1392
01:04:11,465 --> 01:04:12,850
去做这个，帮我查找这个页，

1393
01:04:13,260 --> 01:04:15,130
我有我寻找的东西。

1394
01:04:15,700 --> 01:04:17,145
所以，像根节点一样，

1395
01:04:17,145 --> 01:04:20,370
每个都会去你的 B+ 树，然后说，

1396
01:04:20,370 --> 01:04:22,490
然后它们总是会下到下一层，

1397
01:04:22,990 --> 01:04:25,880
所以，不必在缓冲池中进行页面查找，

1398
01:04:26,560 --> 01:04:27,510
会进入下一级，

1399
01:04:27,620 --> 01:04:29,940
我有知道直接去哪里的指针。

1400
01:04:31,770 --> 01:04:34,840
显然，你不希望将这个指针存储在磁盘上，

1401
01:04:35,040 --> 01:04:36,425
如果页面被刷新，

1402
01:04:36,425 --> 01:04:37,670
因为现在你重新加载它，

1403
01:04:37,670 --> 01:04:39,010
你就会得到这个指针，它不会指向任何地方，

1404
01:04:39,620 --> 01:04:40,280
这将是糟糕的，

1405
01:04:40,280 --> 01:04:41,435
所以你必须做记账，

1406
01:04:41,435 --> 01:04:41,915
以确保，

1407
01:04:41,915 --> 01:04:47,410
好的，你要去磁盘，取消这个交换，

1408
01:04:48,690 --> 01:04:50,080
以确保没有人指向它，

1409
01:04:50,190 --> 01:04:51,160
然后也是，

1410
01:04:54,200 --> 01:04:57,540
你不想这个页面被驱逐，

1411
01:04:57,830 --> 01:04:59,095
这个东西有一个交换指针，

1412
01:04:59,095 --> 01:05:00,480
现在它指向一些其他页面，

1413
01:05:00,680 --> 01:05:02,040
交换到 frame 中，

1414
01:05:02,450 --> 01:05:04,300
它不是 B+ 树的一部分，

1415
01:05:04,300 --> 01:05:05,280
然后你会有一个段错误，

1416
01:05:05,330 --> 01:05:07,530
因为它开始解释字节，

1417
01:05:07,640 --> 01:05:09,060
开始以它应该解释的方式来解释字节。

1418
01:05:10,340 --> 01:05:12,655
所以我之所以为 B+ 树讨论这个，

1419
01:05:12,655 --> 01:05:13,975
而不是哈希表的东西，

1420
01:05:13,975 --> 01:05:15,670
或者不是常规的堆的东西，

1421
01:05:15,670 --> 01:05:19,350
是因为我们在这里的树结构中已经有了这个层次结构，

1422
01:05:19,640 --> 01:05:23,220
我们会知道，如果我们交换我们下面的任何东西，

1423
01:05:23,390 --> 01:05:26,460
我们想要确保这个东西不会被取消固定，

1424
01:05:26,960 --> 01:05:28,585
这个东西不会被取消固定，

1425
01:05:28,585 --> 01:05:30,750
在它的子节点被取消固定之前，

1426
01:05:31,140 --> 01:05:32,540
这样，指针总是有效的。

1427
01:05:37,790 --> 01:05:38,790
好的，又是这个东西，

1428
01:05:38,810 --> 01:05:40,200
当你在做项目 #1 时，

1429
01:05:40,460 --> 01:05:43,270
这个东西，你要做的所有工作都要，去查看页面，

1430
01:05:43,270 --> 01:05:44,590
你会找到你要找的东西，

1431
01:05:44,590 --> 01:05:45,385
frame ，不在那里，

1432
01:05:45,385 --> 01:05:46,710
然后去驱逐一些东西，

1433
01:05:46,910 --> 01:05:48,030
你可以跳过所有这些，

1434
01:05:48,660 --> 01:05:51,245
你更新 LRU-K 的东西，

1435
01:05:51,245 --> 01:05:51,950
你跳过所有这些，

1436
01:05:51,950 --> 01:05:53,500
只需直接转到指针。

1437
01:05:54,140 --> 01:05:56,365
当然，你会丢失访问模式的元数据，

1438
01:05:56,365 --> 01:05:58,830
有关如何使用这些页面，

1439
01:05:59,060 --> 01:06:01,800
但同样，如果它足够重要，可以将其固定和交换，

1440
01:06:02,060 --> 01:06:03,780
那么你可能应该留在内存中。

1441
01:06:07,890 --> 01:06:09,970
好的，为了快速插入，

1442
01:06:10,380 --> 01:06:13,145
最常见的技巧是对所有内容进行预排序，

1443
01:06:13,145 --> 01:06:15,820
我们将在下周讨论这个，

1444
01:06:16,740 --> 01:06:17,710
你对键进行排序，

1445
01:06:18,150 --> 01:06:21,025
并将它们作为叶子节点放置，

1446
01:06:21,025 --> 01:06:21,880
使用兄弟指针，

1447
01:06:21,880 --> 01:06:26,560
然后自下而上构建数据结构。

1448
01:06:27,320 --> 01:06:27,880
这是不同的，

1449
01:06:27,990 --> 01:06:30,605
如果我一个接一个地插入键，

1450
01:06:30,605 --> 01:06:32,570
我就会从上面开始，然后向下，

1451
01:06:32,570 --> 01:06:34,540
必须做所有的拆分，等等，

1452
01:06:34,980 --> 01:06:36,640
我跳过所有这些，只是预先排序，

1453
01:06:37,350 --> 01:06:38,680
在上面搭建脚手架，

1454
01:06:41,430 --> 01:06:43,630
这种技术也很常见。

1455
01:06:47,210 --> 01:06:49,560
好的，我想讨论的最后一个优化是，

1456
01:06:52,440 --> 01:06:55,270
我们很看重怎么做，

1457
01:06:56,480 --> 01:06:58,210
B+ 树的好处在于，

1458
01:06:58,210 --> 01:06:59,910
它是平衡的，所有东西都是 log(n) ，

1459
01:07:01,130 --> 01:07:03,000
我们的查找可以非常快，

1460
01:07:03,110 --> 01:07:06,505
因为，所有东西都是 log(n) 获得叶子节点，

1461
01:07:06,505 --> 01:07:09,660
然后我们可以尝试获得尽可能多的顺序访问，顺序 I/O 。

1462
01:07:10,810 --> 01:07:13,150
但是，当然，挑战是，

1463
01:07:13,620 --> 01:07:15,065
更新对我们来说将是昂贵的，

1464
01:07:15,065 --> 01:07:18,790
因为我们必须保持这种平衡属性，

1465
01:07:19,410 --> 01:07:22,300
当线程出现并插入或删除时，

1466
01:07:22,500 --> 01:07:23,930
它们可能会抽中短签，

1467
01:07:23,930 --> 01:07:26,410
负责重新组织整个数据结构。

1468
01:07:28,040 --> 01:07:30,160
所以，理想情况下，我们需要的是，

1469
01:07:30,160 --> 01:07:34,320
一种延迟数据结构更新的方法。

1470
01:07:35,120 --> 01:07:35,690
以这样一种方式，

1471
01:07:35,690 --> 01:07:36,980
我们可以累积它们，

1472
01:07:36,980 --> 01:07:38,045
然后在以后的某个点上，

1473
01:07:38,045 --> 01:07:38,555
我们有足够的，

1474
01:07:38,555 --> 01:07:39,250
我们说，好的，

1475
01:07:39,300 --> 01:07:41,380
让我继续并批量应用我的所有修改，

1476
01:07:42,310 --> 01:07:44,150
然后，是的，我可能不得不重新组织东西，

1477
01:07:45,130 --> 01:07:46,515
但我所有只做一次，

1478
01:07:46,515 --> 01:07:50,060
我可以摊销做这些修改的花费，

1479
01:07:50,650 --> 01:07:52,490
现在你的写入可能会更快，

1480
01:07:52,510 --> 01:07:54,740
因为你不必担心，

1481
01:07:55,030 --> 01:07:57,080
每次我插入新的东西，我都得拆分。

1482
01:07:59,850 --> 01:08:01,460
所以，有一系列的工作，

1483
01:08:01,460 --> 01:08:04,390
称为写入优化 B 树或 B+ 树，

1484
01:08:05,580 --> 01:08:08,050
这些有时也被称为 Bε 树，

1485
01:08:09,030 --> 01:08:11,690
你会看到它有一个小写 ε 符号，

1486
01:08:12,880 --> 01:08:16,335
Tokutek 的人有一种商业变体叫分形树，

1487
01:08:16,335 --> 01:08:17,985
但它基本上是品牌，

1488
01:08:17,985 --> 01:08:19,310
它的想法是一样的。

1489
01:08:20,750 --> 01:08:21,900
这个想法基本上是，

1490
01:08:21,950 --> 01:08:24,900
现在在每个根节点和内部节点，

1491
01:08:25,280 --> 01:08:26,520
我将有一个 mod 日志，

1492
01:08:27,310 --> 01:08:29,145
就像 MySQL 在他们的页面所做的，

1493
01:08:29,145 --> 01:08:30,080
在他们做压缩时，

1494
01:08:30,980 --> 01:08:32,850
无论何时出现新的更新，

1495
01:08:33,380 --> 01:08:36,810
不是将这些修改一直传播到叶子节点，

1496
01:08:37,190 --> 01:08:39,720
我会违反我们在 B+ 树中讨论过的属性，

1497
01:08:40,400 --> 01:08:42,420
叶子节点必须是实际值所在的，

1498
01:08:42,830 --> 01:08:45,480
我可以将我的条目插入到 mod 日志中。

1499
01:08:46,930 --> 01:08:48,080
所以，如果我想插入 7 ，

1500
01:08:48,550 --> 01:08:49,965
再次，不是向下遍历，

1501
01:08:49,965 --> 01:08:51,350
并计算出 7 应该放在哪里，

1502
01:08:51,760 --> 01:08:53,300
我只是将它放在根中，

1503
01:08:54,760 --> 01:08:56,870
同样的事情，我想删除 10 ，

1504
01:08:57,880 --> 01:08:59,690
不是把它放入，

1505
01:09:00,160 --> 01:09:03,200
向下，删除它，然后可能进行合并，

1506
01:09:03,400 --> 01:09:04,850
我只会把它放到 mod 日志中。

1507
01:09:06,420 --> 01:09:06,950
好的？

1508
01:09:07,960 --> 01:09:10,340
所以，现在如果出现一个查询，并希望找到 10 ，

1509
01:09:11,540 --> 01:09:12,850
好的，当我向下遍历时，

1510
01:09:12,850 --> 01:09:15,190
我查看 mod 日志，并说，

1511
01:09:15,190 --> 01:09:16,500
好的，我要找的东西在这里。

1512
01:09:17,180 --> 01:09:17,945
所以在这个例子中，

1513
01:09:17,945 --> 01:09:19,810
我删除 10 ，

1514
01:09:20,550 --> 01:09:21,545
它在我的 mod 日志中，

1515
01:09:21,545 --> 01:09:22,430
所以当我查找的时候，

1516
01:09:22,430 --> 01:09:24,365
我会在这里找到条目，然后就完成了，

1517
01:09:24,365 --> 01:09:25,480
我不需要去底部，

1518
01:09:26,350 --> 01:09:29,840
真正看到变化。

1519
01:09:32,490 --> 01:09:33,880
当然，这有什么明显的问题？

1520
01:09:37,090 --> 01:09:38,660
缓冲区会满，是吧。

1521
01:09:39,520 --> 01:09:40,450
所以当这种情况发生时，

1522
01:09:40,450 --> 01:09:43,380
你必须级联修改，

1523
01:09:43,550 --> 01:09:44,365
但这里的想法是，

1524
01:09:44,365 --> 01:09:46,050
你增量地、批量地做这些，

1525
01:09:46,400 --> 01:09:49,740
你不必应用任何修改，

1526
01:09:50,270 --> 01:09:52,530
直到你到达数据结构，

1527
01:09:53,090 --> 01:09:55,830
直到你到达叶子节点。

1528
01:09:56,280 --> 01:09:57,260
所以如果我插入 40 ，

1529
01:09:57,490 --> 01:09:59,240
我只需要移动之前的修改，

1530
01:09:59,980 --> 01:10:01,760
插入 7 ，在这里插入 10 ，

1531
01:10:02,830 --> 01:10:06,460
然后把插入 40 放在这里。

1532
01:10:07,160 --> 01:10:07,700
在某个时候，

1533
01:10:07,700 --> 01:10:09,190
如果我继续这样做，

1534
01:10:09,510 --> 01:10:10,690
这个东西级联下来，

1535
01:10:11,910 --> 01:10:12,860
这个东西是满的，

1536
01:10:12,860 --> 01:10:14,680
然后我继续，应用我的修改。

1537
01:10:16,410 --> 01:10:16,810
是的。

1538
01:10:17,040 --> 01:10:24,280
是的，所以问题是，

1539
01:10:24,330 --> 01:10:26,090
这是否可能会导致读取很慢，

1540
01:10:26,090 --> 01:10:29,170
因为，当我在这里扫描时，

1541
01:10:29,170 --> 01:10:32,230
我必须在 mod 日志中进行顺序扫描，

1542
01:10:32,230 --> 01:10:34,530
以找到为什么我要找的东西在那里。

1543
01:10:35,130 --> 01:10:40,480
是的，但是就像，这些不同的 Bε 树的实现，

1544
01:10:40,710 --> 01:10:43,400
它们在这些东西前面有布隆过滤器，

1545
01:10:43,400 --> 01:10:45,125
说是否是我寻找的键，

1546
01:10:45,125 --> 01:10:46,510
甚至在我的 mod 日志中，

1547
01:10:46,620 --> 01:10:48,550
如果是，那就去查找它，

1548
01:10:50,370 --> 01:10:52,090
布隆过滤器很容易维护，

1549
01:10:52,170 --> 01:10:53,440
而且它们也不是很大。

1550
01:10:55,990 --> 01:10:59,560
所以这是一个老的想法， 2003 年，

1551
01:11:00,720 --> 01:11:01,970
B+ 树是 1972 年，

1552
01:11:01,970 --> 01:11:03,070
所以可能没有那么老，

1553
01:11:03,120 --> 01:11:04,990
但是一个老的想法，

1554
01:11:06,660 --> 01:11:07,930
这个看起来像什么，

1555
01:11:08,160 --> 01:11:09,040
我们之前讨论过的，

1556
01:11:09,300 --> 01:11:11,320
日志结构存储，

1557
01:11:11,700 --> 01:11:14,440
同样的想法，我们可以附加这些日志条目，

1558
01:11:15,090 --> 01:11:15,905
然后批量处理它们，

1559
01:11:15,905 --> 01:11:17,740
并在稍后的某个时候应用它们。

1560
01:11:18,930 --> 01:11:21,670
所以我说，我们已经一遍又一遍地看到了这个想法。

1561
01:11:21,720 --> 01:11:26,230
所以 Tokutek ，他们将他们的 Bε 树的实现重新命名为分形树，

1562
01:11:26,550 --> 01:11:30,460
然后他们有了一个用于 MySQL 的存储引擎，

1563
01:11:31,250 --> 01:11:34,065
我想想，被 Percona 收购，

1564
01:11:34,065 --> 01:11:36,480
我想我去年被废弃了，

1565
01:11:36,480 --> 01:11:40,820
所以，它们可能是几年前最健壮的实现，

1566
01:11:40,960 --> 01:11:42,470
那已经死了，

1567
01:11:42,850 --> 01:11:47,360
SplinterDB 是一个 VMware 编写的嵌入式键值存储，

1568
01:11:48,550 --> 01:11:50,180
实际上是由这里的人编写的，

1569
01:11:50,640 --> 01:11:52,220
他是 VMware 的一名研究人员，

1570
01:11:52,360 --> 01:11:56,420
但他是在 CMU 的 Tepper 获得 MBA 的，

1571
01:11:57,340 --> 01:11:58,335
另一个致力于此的人，

1572
01:11:58,335 --> 01:11:59,330
他现在是康奈尔大学的教授，

1573
01:11:59,470 --> 01:12:05,000
但这基本上是一种超级优化的版本。

1574
01:12:05,290 --> 01:12:10,260
RelationAI 是一个基于关系型知识的，

1575
01:12:11,390 --> 01:12:15,930
关系型数据库之上的知识图谱[]，

1576
01:12:16,310 --> 01:12:19,320
实现了 Bε 树，进行快速更新。

1577
01:12:20,070 --> 01:12:21,550
所以这并不常见，

1578
01:12:23,260 --> 01:12:26,130
但是，这是，

1579
01:12:26,130 --> 01:12:28,700
我怀疑我们在未来会看到越来越多，

1580
01:12:29,080 --> 01:12:30,570
我的意思是， RocksDB 不需要这个，

1581
01:12:30,570 --> 01:12:32,540
因为 RocksDB 已经是一个日志结构合并树，

1582
01:12:32,920 --> 01:12:37,580
你基本上得到了相同的概念、相同的属性。

1583
01:12:39,440 --> 01:12:43,140
好的，所以我们还剩六分钟。

1584
01:12:44,085 --> 01:12:45,860
所以，让我们打开 Postgres ，

1585
01:12:49,230 --> 01:12:50,110
做一个快速的 demo 。

1586
01:12:52,040 --> 01:12:54,330
所以，在这里我将演示两者的区别，

1587
01:12:55,580 --> 01:12:56,290
我关掉灯，

1588
01:12:57,060 --> 01:12:58,580
演示 MySQL 的区别，

1589
01:12:58,580 --> 01:12:59,470
抱歉，不是 MySQL 。

1590
01:13:04,870 --> 01:13:05,870
不，抱歉，

1591
01:13:07,290 --> 01:13:07,690
可以了。

1592
01:13:09,350 --> 01:13:11,095
好了，我第一次关这个灯。

1593
01:13:11,095 --> 01:13:11,845
所以，我想演示，

1594
01:13:11,845 --> 01:13:18,475
哈希索引和 B+ 树在数据上的区别，

1595
01:13:18,475 --> 01:13:23,730
我们可以看到数据库系统将选择使用什么来运行查询。

1596
01:13:29,370 --> 01:13:32,290
所以我要使用的数据集是，

1597
01:13:35,700 --> 01:13:43,715
我想是，几年前的 2100 万个电子邮件地址，

1598
01:13:43,715 --> 01:13:44,410
因为所有都在，

1599
01:13:46,290 --> 01:13:49,540
是的， 2700 万个电子邮件地址。

1600
01:13:49,950 --> 01:13:53,465
所以，我不打算实时运行它，

1601
01:13:53,465 --> 01:13:55,540
但我已经创建了两个索引，

1602
01:13:57,210 --> 01:13:59,770
我在电子邮件使用 B+ 创建了一个，

1603
01:14:00,270 --> 01:14:00,670
抱歉，

1604
01:14:02,600 --> 01:14:03,870
它的工作方式类似于，

1605
01:14:03,950 --> 01:14:08,560
在 Postgres 中，你说 CREATE INDEX ，加上这个表上的索引名，

1606
01:14:08,560 --> 01:14:11,670
然后 USING ，你可以指定所需的数据结构，

1607
01:14:11,900 --> 01:14:14,310
所以默认情况下，如果你在 Postgres 中没有 USING 子句，

1608
01:14:14,810 --> 01:14:16,710
你会得到一个 B+ 树，

1609
01:14:16,910 --> 01:14:18,370
但这里我明确地告诉你，

1610
01:14:18,370 --> 01:14:19,320
我想要一个 B+ 树，

1611
01:14:19,430 --> 01:14:21,055
索引已经存在了，

1612
01:14:21,055 --> 01:14:21,990
我不需要这么做。

1613
01:14:23,500 --> 01:14:27,540
然后，我使用在相同的列上构建相同的内容，

1614
01:14:27,770 --> 01:14:29,730
使用哈希表构建，

1615
01:14:29,900 --> 01:14:31,170
我只是说 USING HASH ，

1616
01:14:31,190 --> 01:14:32,340
再次，我已经有了。

1617
01:14:33,600 --> 01:14:36,760
所以，让我关闭 Postgres 中一系列其他优化，

1618
01:14:37,200 --> 01:14:38,410
我们不需要担心，

1619
01:14:39,240 --> 01:14:41,760
所以我可以像这样进行查询，

1620
01:14:41,760 --> 01:14:43,350
SELECT MIN(email) FROM emails ，

1621
01:14:43,350 --> 01:14:45,110
我会得到一些随机的东西，

1622
01:14:45,900 --> 01:14:48,340
但同样，如果我把 EXPLAIN 关键字放在它前面，

1623
01:14:49,710 --> 01:14:52,050
Postgres 会告诉我查询计划是什么。

1624
01:14:52,490 --> 01:14:53,760
这里它将告诉我，

1625
01:14:53,870 --> 01:14:56,970
我将使用 B+ 树进行仅索引扫描，

1626
01:14:57,740 --> 01:14:59,730
它会告诉我条件是什么，

1627
01:15:01,070 --> 01:15:03,000
我们没有讨论仅索引扫描，

1628
01:15:03,020 --> 01:15:05,010
有时是覆盖扫描或覆盖索引，

1629
01:15:05,180 --> 01:15:07,060
基本上， Postgres 认识到，

1630
01:15:07,060 --> 01:15:11,520
回答这个查询所需的所有数据或列都可以在索引中找到，

1631
01:15:11,900 --> 01:15:15,510
所以，即使它们将记录 ID 存储在叶子节点中，

1632
01:15:15,940 --> 01:15:17,575
我不需要跟踪这些记录 ID

1633
01:15:17,575 --> 01:15:19,230
来获得实际 tuple 的数据，

1634
01:15:19,490 --> 01:15:23,700
这个查询所需的所有内容都可以从索引中得到回答。

1635
01:15:24,140 --> 01:15:25,900
因为，再次回到我的查询，

1636
01:15:25,900 --> 01:15:31,155
它只是从电子邮件地址中选择了最小的 email ，

1637
01:15:31,155 --> 01:15:32,100
索引在 email 上，

1638
01:15:32,100 --> 01:15:36,920
所以，一旦我一直走到树的右侧或树的左侧，

1639
01:15:37,000 --> 01:15:38,300
就有了我要寻找的所有数据。

1640
01:15:39,070 --> 01:15:41,180
这就是为什么它告诉我它可以进行仅索引扫描，

1641
01:15:41,740 --> 01:15:42,440
所以这很好。

1642
01:15:43,200 --> 01:15:43,775
让我们来看看，

1643
01:15:43,775 --> 01:15:45,050
现在，如果我们想做这样的事情，

1644
01:15:45,050 --> 01:15:45,670
我们想说，

1645
01:15:46,870 --> 01:15:51,590
给我所有第一个字母是 a 的 email ，

1646
01:15:51,850 --> 01:15:53,085
但我做了一个 LIMIT 1 ，

1647
01:15:53,085 --> 01:15:54,440
你得到像这样的。

1648
01:15:57,520 --> 01:15:58,275
我可以做 EXPLAIN ，

1649
01:15:58,275 --> 01:16:00,020
看看它告诉了我做了什么，

1650
01:16:00,160 --> 01:16:00,975
所以在这种情况下，

1651
01:16:00,975 --> 01:16:01,760
Postgres 说，

1652
01:16:02,470 --> 01:16:05,660
即使我有 B+ 树索引，它在 emails 上进行排序，

1653
01:16:06,100 --> 01:16:07,940
Postgres 说，它想要进行顺序扫描，

1654
01:16:08,380 --> 01:16:10,610
因为它注意到我寻找的东西，

1655
01:16:11,710 --> 01:16:14,360
我寻找所有以 a 开头的电子邮件，

1656
01:16:14,860 --> 01:16:17,000
位于树的某个中间点，

1657
01:16:18,540 --> 01:16:20,240
由于它是无界的，

1658
01:16:20,350 --> 01:16:21,590
我没有指定，

1659
01:16:23,500 --> 01:16:24,590
至少在扫描大小上，

1660
01:16:24,700 --> 01:16:26,475
我没有指定结束标记，

1661
01:16:26,475 --> 01:16:28,700
它会说，好的，你必须扫描到整个[末端]，

1662
01:16:28,780 --> 01:16:29,730
现在，它还不够聪明，

1663
01:16:29,730 --> 01:16:31,970
意识到我有一个 LIMIT 1 ，

1664
01:16:32,350 --> 01:16:33,495
所以，它真正应该做的是，

1665
01:16:33,495 --> 01:16:36,920
深入索引，找到第一个，然后弹出，完成，

1666
01:16:37,090 --> 01:16:37,830
但在这件事上，

1667
01:16:37,830 --> 01:16:41,090
Postgres 还不够聪明来解决这个。

1668
01:16:41,680 --> 01:16:43,670
它不能选择哈希索引，

1669
01:16:43,720 --> 01:16:46,320
因为我执行通配符搜索，

1670
01:16:46,320 --> 01:16:50,300
我没有实际的完整键。

1671
01:16:51,840 --> 01:16:53,135
所以你可以从其他方面来看这个，

1672
01:16:53,135 --> 01:16:54,400
所以在这个例子中，

1673
01:16:54,630 --> 01:16:58,540
我想找出所有比 andy 大的电子邮件，

1674
01:16:58,920 --> 01:17:01,270
再次，做顺序扫描，

1675
01:17:01,530 --> 01:17:02,860
但现在如果我做这样的事情，

1676
01:17:03,700 --> 01:17:04,920
找出所有电子邮件，

1677
01:17:05,750 --> 01:17:11,280
找出所有以 zzzz 开头的电子邮件字符串，

1678
01:17:11,570 --> 01:17:13,110
现在我在树的右侧，

1679
01:17:13,780 --> 01:17:15,810
Postgres 注意到，根据分布情况，

1680
01:17:15,950 --> 01:17:18,130
好的，你在树上走得够远了，

1681
01:17:18,130 --> 01:17:19,060
我要扫描，

1682
01:17:19,060 --> 01:17:21,090
所以我可以进行索引扫描，

1683
01:17:21,410 --> 01:17:27,270
因为这仍然会比完全顺序扫描的数据量要少。

1684
01:17:28,140 --> 01:17:30,665
没有任何时候， Postgres 没有决定使用哈希索引，

1685
01:17:30,665 --> 01:17:33,250
因为再次，我做的是小于等于通配符的匹配。

1686
01:17:34,550 --> 01:17:35,670
所以我们可以做这样的事情，

1687
01:17:37,240 --> 01:17:38,150
现在我们可以说，

1688
01:17:39,670 --> 01:17:43,280
使用 IN 子句查找完全相等匹配的电子邮件，

1689
01:17:44,430 --> 01:17:45,920
现在，你可以看到 Postgres 说，

1690
01:17:45,920 --> 01:17:49,010
在这里使用哈希索引，

1691
01:17:51,220 --> 01:17:52,260
位图索引扫描，

1692
01:17:52,260 --> 01:17:52,905
我会解释，

1693
01:17:52,905 --> 01:17:55,220
这不是真正的位图索引，

1694
01:17:57,100 --> 01:17:57,950
你可以更好地查看它，

1695
01:17:59,200 --> 01:18:00,020
不是使用 IN ，

1696
01:18:00,900 --> 01:18:03,440
你可以使用很多 OR ，

1697
01:18:03,790 --> 01:18:05,090
现在你看到的是，

1698
01:18:05,320 --> 01:18:08,655
Postgres 有多个索引扫描条目，

1699
01:18:08,655 --> 01:18:11,445
其中每个电子邮件地址，

1700
01:18:11,445 --> 01:18:13,605
我在 WHERE 子句中的，

1701
01:18:13,605 --> 01:18:16,370
比如，某个东西等于某个东西 OR 某个东西等于某个东西，

1702
01:18:16,870 --> 01:18:19,340
每个都将分别探测到哈希索引，

1703
01:18:20,070 --> 01:18:22,690
然后他们维护一个位图，

1704
01:18:23,370 --> 01:18:25,570
我认为这是实际的 tuple ID ， tuple 偏移量，

1705
01:18:25,890 --> 01:18:27,040
不是页面的，

1706
01:18:27,210 --> 01:18:30,790
它们为每个索引探测维护匹配值的位图，

1707
01:18:30,900 --> 01:18:32,410
然后他们把它们或在一起，

1708
01:18:32,700 --> 01:18:35,920
然后产生你需要的两个确切的 tuple 。

1709
01:18:36,940 --> 01:18:38,930
这和我之前说的有点类似，

1710
01:18:38,950 --> 01:18:44,060
你首先从索引中找出你需要的页面，

1711
01:18:44,710 --> 01:18:45,990
然后去真正去获取它们，

1712
01:18:45,990 --> 01:18:46,830
所以他们在这里这样做，

1713
01:18:46,830 --> 01:18:48,320
他们在索引中执行许多探测，

1714
01:18:48,520 --> 01:18:50,750
没有实际上从表中获得真正的数据，

1715
01:18:52,190 --> 01:18:53,430
在位图上做 OR ，

1716
01:18:53,510 --> 01:18:58,490
然后，你就有了需要获取的记录列表。

1717
01:19:00,930 --> 01:19:04,480
好的，接下来我想讨论一下聚集表。

1718
01:19:04,590 --> 01:19:06,040
所以， Postgres 没有，

1719
01:19:06,300 --> 01:19:07,960
Postgres 支持聚集命令，

1720
01:19:08,520 --> 01:19:09,490
但它实际上并不，

1721
01:19:09,930 --> 01:19:11,260
它将对你的表进行排序，

1722
01:19:11,670 --> 01:19:13,490
但实际上并不维护排序，

1723
01:19:13,490 --> 01:19:15,520
因为它不会被组织起来，

1724
01:19:15,870 --> 01:19:16,990
它不在索引组织中，

1725
01:19:17,250 --> 01:19:18,940
所以，你使用聚集命令，

1726
01:19:19,080 --> 01:19:20,290
Postgres 将对数据进行排序，

1727
01:19:20,490 --> 01:19:21,950
但是当你开始修改表时，

1728
01:19:21,950 --> 01:19:23,140
它的排序可能会打乱。

1729
01:19:23,910 --> 01:19:24,935
所以我不会现场演示，

1730
01:19:24,935 --> 01:19:25,840
因为这会花太长时间，

1731
01:19:26,070 --> 01:19:27,245
我意识到我们有点超时了，

1732
01:19:27,245 --> 01:19:28,210
但命令是，

1733
01:19:29,130 --> 01:19:31,545
基本上是这样的，

1734
01:19:31,545 --> 01:19:34,130
你会说， CLUSTER 我们需要聚集的表，

1735
01:19:35,290 --> 01:19:37,640
然后让索引聚集在一起，

1736
01:19:38,260 --> 01:19:40,140
这大约需要一分钟运行，

1737
01:19:40,140 --> 01:19:41,540
所以在我们上课之前我已经运行过了，

1738
01:19:41,770 --> 01:19:42,680
所以我不会这么做，

1739
01:19:43,030 --> 01:19:44,115
但是我们可以去看看，

1740
01:19:44,115 --> 01:19:48,985
比如第一个页面里面有什么，

1741
01:19:48,985 --> 01:19:51,630
再次， ctid 是记录 ID ， Postgres 中的偏移量，

1742
01:19:52,070 --> 01:19:52,830
所以你这样做，

1743
01:19:53,750 --> 01:19:55,980
实际上这是未排序的，

1744
01:19:56,120 --> 01:19:57,150
所以它看起来都是随机的，

1745
01:19:57,800 --> 01:20:00,330
但如果我将表名改为 clustered ，

1746
01:20:07,680 --> 01:20:08,560
因为这个，抱歉，

1747
01:20:14,050 --> 01:20:15,195
好的，现在你可以看到，

1748
01:20:15,195 --> 01:20:17,000
在第一个页面或第一个偏移量，

1749
01:20:17,440 --> 01:20:21,100
tuple 按那个顺序排序，

1750
01:20:23,540 --> 01:20:24,565
基于索引，

1751
01:20:24,565 --> 01:20:26,430
所以，如果我继续，删除其中一个条目，

1752
01:20:26,510 --> 01:20:29,370
删除他们虚假电子邮件地址中的第一个人，

1753
01:20:29,930 --> 01:20:34,620
我返回，并在表上做同样的扫描，

1754
01:20:34,880 --> 01:20:37,705
Postgres 没有填充第一个 slot ，

1755
01:20:37,705 --> 01:20:38,370
它是空的，

1756
01:20:38,780 --> 01:20:40,770
但现在如果我把这个假人放回去，

1757
01:20:42,130 --> 01:20:45,150
做同样的扫描，

1758
01:20:45,150 --> 01:20:49,210
它们仍然不在第一页上。

1759
01:20:50,310 --> 01:20:51,200
所以，为了找到它们，

1760
01:20:51,200 --> 01:20:57,790
我们做 SELECT *, SELECT ctid FROM emails_clustered ，

1761
01:21:01,950 --> 01:21:07,910
WHERE email = 这个，

1762
01:21:08,140 --> 01:21:09,740
现在它们在页面 299 上，

1763
01:21:10,870 --> 01:21:12,285
我不知道它在哪里，一些随机的东西，

1764
01:21:12,285 --> 01:21:13,550
但同样，它不是按排序顺序的，

1765
01:21:13,660 --> 01:21:16,370
因为 Postgres 不能维护顺序，

1766
01:21:16,960 --> 01:21:18,590
因为它没有真正的聚集索引。

1767
01:21:19,440 --> 01:21:19,840
好的。

1768
01:21:22,430 --> 01:21:26,210
所以， B+ 树很重要。

1769
01:21:26,440 --> 01:21:28,880
它可能是你的数据库系统的最佳选择，

1770
01:21:29,020 --> 01:21:29,960
Trie 是相当不错的，

1771
01:21:30,850 --> 01:21:32,810
就像我之前说的，你可以有 B+ 树或 Trie ，

1772
01:21:33,550 --> 01:21:35,810
但是 B+ 树是，

1773
01:21:36,010 --> 01:21:37,400
有很多更快的方法。

1774
01:21:37,810 --> 01:21:39,075
所以下一节课，

1775
01:21:39,075 --> 01:21:41,510
我们讨论如何让你的 B+ 树线程安全，

1776
01:21:42,040 --> 01:21:43,140
通过向下遍历，

1777
01:21:43,140 --> 01:21:44,870
甚至当你做分裂和合并的时候，

1778
01:21:45,160 --> 01:21:45,560
好的，开始。

