1
00:00:34,900 --> 00:00:35,300
好的。

2
00:00:37,690 --> 00:00:42,240
好的，上节课的一些快速的东西，行政的东西，

3
00:00:42,240 --> 00:00:45,260
才过了一天，我们已经收到电子邮件了，

4
00:00:45,520 --> 00:00:47,810
第一件事是，

5
00:00:47,860 --> 00:00:49,215
上节课我犯了一个错误，

6
00:00:49,215 --> 00:00:51,950
我说 Ted Codd 在宾夕法尼亚大学获得了博士学位，

7
00:00:52,360 --> 00:00:53,330
他实际是在密歇根获得博士学位，

8
00:00:53,740 --> 00:00:55,760
所有优秀的数据人都在那里获得了博士学位，

9
00:00:56,560 --> 00:00:59,490
Michael Stonebraker 在那里获得了他的博士学位，

10
00:00:59,490 --> 00:01:00,525
Ted Codd 在那里得到了他的博士学位，

11
00:01:00,525 --> 00:01:01,940
David Dewitt 也是，另一个著名的 David ，

12
00:01:02,110 --> 00:01:04,820
所以不是宾夕法尼亚，而是密歇根。

13
00:01:05,290 --> 00:01:08,150
另一件事是人们对音频有这样的抱怨，

14
00:01:08,530 --> 00:01:10,245
亲爱的 Andy ，你课上的音频很烂，

15
00:01:10,245 --> 00:01:12,290
所以我看你请不起音响工程师，是这样吗，

16
00:01:12,490 --> 00:01:14,160
Andy ，我喜欢这门课，但我听不下去，

17
00:01:14,160 --> 00:01:14,985
因为音频太混乱了，

18
00:01:14,985 --> 00:01:16,245
你这么做的时候发生了什么，

19
00:01:16,245 --> 00:01:17,120
我失去了活下去的方式。

20
00:01:18,070 --> 00:01:20,460
所以上次是我的错，

21
00:01:20,460 --> 00:01:21,345
所以我们正在重复录制，

22
00:01:21,345 --> 00:01:25,310
所以希望这次我们在发布它时不会有任何问题。

23
00:01:25,330 --> 00:01:27,110
然后我们收到了关于你的电子邮件，

24
00:01:27,790 --> 00:01:29,270
这很令人惊讶，对吗，

25
00:01:29,950 --> 00:01:35,145
我上个月在匹兹堡的 [21桥表演] 中看了 DJ 2PL 的表演，

26
00:01:35,145 --> 00:01:35,720
这是真的吗？

27
00:01:36,460 --> 00:01:36,860
好的。

28
00:01:37,270 --> 00:01:39,530
你很幸运得到像他这样的 DJ ，他很贵，

29
00:01:40,840 --> 00:01:41,960
[]有很多钱，

30
00:01:43,270 --> 00:01:44,510
[]没有很多钱，好的，

31
00:01:45,670 --> 00:01:49,010
哟，DJ 2PL 很搞笑，他是单身吗，

32
00:01:49,090 --> 00:01:49,970
我在为我的朋友问，

33
00:01:54,040 --> 00:01:56,805
然后她就像没有拇指的 Taylor Swift ，

34
00:01:56,805 --> 00:01:57,590
我不知道是什么意思，

35
00:01:59,560 --> 00:02:01,340
那么你是单身吗？

36
00:02:01,900 --> 00:02:02,640
我不是。

37
00:02:03,020 --> 00:02:09,960
好的，不管怎样，那是他们的问题。

38
00:02:11,900 --> 00:02:14,100
所以今天的课，我们来讲讲 SQL ，

39
00:02:14,240 --> 00:02:17,790
上一节课我们花时间讨论了关系模型，

40
00:02:18,170 --> 00:02:19,110
我们讨论了，

41
00:02:19,190 --> 00:02:23,185
在我看来，它是对于每个可能的数据库的高级数据模型，

42
00:02:23,185 --> 00:02:24,060
你可以认为，

43
00:02:24,200 --> 00:02:28,020
关系数据模型可以用来表示

44
00:02:28,550 --> 00:02:30,990
几乎所有不同的模式。

45
00:02:31,490 --> 00:02:33,870
然后，我们展示了关系代数如何构建块，

46
00:02:34,130 --> 00:02:40,350
关于我们如何在关系数据库上执行查询或定义查询。

47
00:02:40,910 --> 00:02:43,405
所以，今天的课程真正要讨论的是 SQL ，

48
00:02:43,405 --> 00:02:50,100
它是一种用于与数据库系统交互的声明性或非过程性语言。

49
00:02:50,560 --> 00:02:53,550
我们将看到，随着时间的推移， SQL 已经发展，

50
00:02:53,630 --> 00:02:56,905
在最初的时候，在 1970 年代，当它第一次被定义时，

51
00:02:56,905 --> 00:03:00,420
它对关系数据库应该是什么样子有非常严格的要求，

52
00:03:00,830 --> 00:03:03,030
但在过去的 40 年里，

53
00:03:03,080 --> 00:03:07,230
它得到了扩展，以支持看起来不像是关系的东西，例如 json 。

54
00:03:07,820 --> 00:03:10,700
所以，让我们从头开始，谈谈 SQL 是如何开始的，

55
00:03:10,700 --> 00:03:16,810
然后我们将讨论在它的现代版本中可以做的更有趣的事情。

56
00:03:17,700 --> 00:03:22,210
所以 SQL 回到 1970 年代，

57
00:03:22,590 --> 00:03:25,450
Ted Codd ，当他写第一篇论文时，

58
00:03:25,800 --> 00:03:29,300
他还没有定义用于操作关系数据库的编程语言，

59
00:03:29,300 --> 00:03:30,370
这一切都是数学上的，

60
00:03:30,840 --> 00:03:35,890
人们说，哦，这篇论文是如此深不可测，

61
00:03:35,890 --> 00:03:36,840
没有人能理解它，

62
00:03:37,550 --> 00:03:38,305
如果你真的读了，

63
00:03:38,305 --> 00:03:39,985
它实际上是很容易理解的，

64
00:03:39,985 --> 00:03:42,150
我想，那时候人们只是不喜欢数学而已。

65
00:03:43,010 --> 00:03:43,950
然后他，

66
00:03:45,610 --> 00:03:47,220
一些 IBM 的人看着论文，

67
00:03:47,220 --> 00:03:50,430
试图开始建立实验性的关系数据库，

68
00:03:50,430 --> 00:03:54,680
看看他们是否真的能把他的数学思想付诸实践。

69
00:03:55,240 --> 00:03:58,110
最早的关系数据库语言，

70
00:03:58,110 --> 00:04:01,650
据我所知是这个称为 SQUARE 的东西，

71
00:04:01,650 --> 00:04:04,070
IBM 在 1971 年发明的，

72
00:04:05,080 --> 00:04:07,125
这是为了一个更早的项目，

73
00:04:07,125 --> 00:04:10,550
IBM 为最早的关系数据库系统之一开发的，

74
00:04:10,570 --> 00:04:11,660
可能是第一个，

75
00:04:12,550 --> 00:04:14,990
听起来像是一支奇怪的实验性摇滚乐队，

76
00:04:15,280 --> 00:04:17,420
它被称为 Peterlee Relational Test Vehicle ，

77
00:04:17,890 --> 00:04:20,775
但这是他们建造的第一件作为早期原型的东西，

78
00:04:20,775 --> 00:04:24,770
表明你可以将 Ted Codd 的想法实际应用到真实系统中。

79
00:04:25,400 --> 00:04:27,400
然而， SQUARE 的问题是，

80
00:04:27,510 --> 00:04:29,225
你永远不能真正重用它，

81
00:04:29,225 --> 00:04:32,770
因为你必须垂直编写奇怪的符号，

82
00:04:33,000 --> 00:04:35,020
而你实际上不能这样做，

83
00:04:35,340 --> 00:04:39,365
这是论文中的一篇，

84
00:04:39,365 --> 00:04:39,970
你需要写，

85
00:04:40,620 --> 00:04:44,120
这就是如何按部门在 sales 表上进行扫描，

86
00:04:44,230 --> 00:04:46,350
你会用这种奇怪的垂直方式编写，

87
00:04:46,350 --> 00:04:48,860
使用即使在今天你也不会在键盘上使用的字符，

88
00:04:49,390 --> 00:04:50,810
所以实际上从来没有人这样做过。

89
00:04:51,500 --> 00:04:54,265
然后 IBM 抛弃了这个，

90
00:04:54,265 --> 00:04:57,570
他们开始构建一种新的查询语言，名为 SEQUEL ，

91
00:04:57,680 --> 00:04:59,220
拼写为 S E Q U E L ，

92
00:04:59,570 --> 00:05:01,285
对于 System R 项目，

93
00:05:01,285 --> 00:05:03,600
这是我们将在整个学期中讨论的。

94
00:05:03,770 --> 00:05:07,060
但这是 IBM 开始构建的第二个关系数据库系统，

95
00:05:07,060 --> 00:05:10,320
试图证明 Ted Codd 的工作实际上是可以完成的。

96
00:05:10,700 --> 00:05:12,475
Peter Lee 团队是在英国，

97
00:05:12,475 --> 00:05:13,350
那是一个很小的团队，

98
00:05:13,460 --> 00:05:17,455
System R 项目在圣何塞的 IBM 研究中心，

99
00:05:17,455 --> 00:05:19,200
这是一项非常重要的任务。

100
00:05:19,760 --> 00:05:23,005
所以他们早在 1972 年就定义了 SQL ，

101
00:05:23,005 --> 00:05:25,440
这是 Don Chamberlin 和 Boyce ，

102
00:05:25,760 --> 00:05:26,760
他们使用这种查询语言，

103
00:05:27,980 --> 00:05:30,900
他们的想法是结构化英语查询语言，

104
00:05:31,690 --> 00:05:33,195
但是在 1980 年代，

105
00:05:33,195 --> 00:05:36,045
当 IBM 推出商业关系数据库系统时，

106
00:05:36,045 --> 00:05:39,740
他们被起诉使用术语 SEQUEL ，比如名字 SEQUEL ，

107
00:05:39,760 --> 00:05:43,670
因为有其他系统或其他软件在使用它，

108
00:05:43,750 --> 00:05:48,370
所以他们就将其[恢复]为 SQL ，

109
00:05:48,370 --> 00:05:50,670
只有字母，结构化查询语言。

110
00:05:52,530 --> 00:05:55,895
同一时间还有另一个非常著名的项目，

111
00:05:55,895 --> 00:05:57,740
在 1970 年代的伯克利，

112
00:05:57,740 --> 00:05:58,810
当 System R 刚刚开始时，

113
00:05:59,580 --> 00:06:00,310
这个项目叫做 Ingres ，

114
00:06:00,810 --> 00:06:01,960
这里有人听说过 Ingres 吗？

115
00:06:03,720 --> 00:06:05,800
没人，有人听说过 Postgres ？

116
00:06:07,080 --> 00:06:08,810
你想知道为什么 Postgres 被称为 Postgres ，

117
00:06:08,810 --> 00:06:10,330
因为它是 Post-Ingres ，

118
00:06:10,620 --> 00:06:12,850
Stonebraker 当他构建 Ingres 时，

119
00:06:13,560 --> 00:06:16,220
他在 1970 年代末将其商业化，

120
00:06:16,220 --> 00:06:17,930
然后在 1980 年代回到伯克利，

121
00:06:17,930 --> 00:06:18,820
他们建立了一个新的系统，

122
00:06:19,200 --> 00:06:20,620
这个系统应该是 Post-Ingres ，

123
00:06:21,030 --> 00:06:22,180
这就是为什么它被称为 Postgres 。

124
00:06:23,580 --> 00:06:27,880
Postgres ，抱歉， Ingres 有另一种查询语言，称为 QUEL ，

125
00:06:28,600 --> 00:06:32,250
所以 SQL 单词的[计划]是， SQL 到 QUEL ，

126
00:06:32,920 --> 00:06:35,290
因为 IBM 的人知道伯克利的人在做什么，

127
00:06:35,290 --> 00:06:36,930
他们会试图构建一种更好的查询语言。

128
00:06:37,430 --> 00:06:39,000
Stonebraker 会辩称 QUEL 更好，

129
00:06:40,010 --> 00:06:41,670
但当然今天没有人使用它。

130
00:06:42,320 --> 00:06:44,340
IBM 发布了几款，

131
00:06:46,130 --> 00:06:49,375
在 1970 年代， IBM 从 IMS 上赚了很多钱，

132
00:06:49,375 --> 00:06:52,080
这是一个非关系型系统，不支持 SQL ，

133
00:06:52,280 --> 00:06:54,805
然后他们意识到 SQL 会有用武之地，

134
00:06:54,805 --> 00:06:55,920
关系数据库也会有用武之地，

135
00:06:56,150 --> 00:07:00,030
所以，他们发布了更早的原型，比如 System/38 SQL/DS ，

136
00:07:00,560 --> 00:07:04,135
但真正成功的是 DB2 ，

137
00:07:04,135 --> 00:07:05,310
它至今仍在使用。

138
00:07:06,530 --> 00:07:09,235
IBM 是计算机界的巨头，

139
00:07:09,235 --> 00:07:11,485
所以无论 IBM 说他们要做什么，

140
00:07:11,485 --> 00:07:13,230
这都成了事实上的标准，

141
00:07:13,580 --> 00:07:16,410
所以，当 IBM 推出支持 SQL 的关系数据库时，

142
00:07:16,640 --> 00:07:18,600
尽管存在像 QUEL 这样的竞争语言，

143
00:07:19,160 --> 00:07:22,830
但每个人都聚集在 SQL 周围。

144
00:07:24,400 --> 00:07:26,895
所以， SQL 成为了 ANSI 标准，

145
00:07:26,895 --> 00:07:28,110
它是美国国家标准学会，

146
00:07:28,110 --> 00:07:29,420
在 1986 年，

147
00:07:29,680 --> 00:07:34,020
并于 1987 年成为国际标准。

148
00:07:34,020 --> 00:07:38,540
尽管它现在是一个有 50 60 年历史的语言，

149
00:07:38,950 --> 00:07:41,090
但它已经随着时间的推移而演变和扩展。

150
00:07:41,530 --> 00:07:45,980
最新版本的 SQL 标准是在今年 3 月于 2023 年发布的，

151
00:07:47,020 --> 00:07:48,105
看看她的列表，

152
00:07:48,105 --> 00:07:49,340
所有更新的历史，

153
00:07:49,540 --> 00:07:51,320
以及他们随着时间的推移添加的各种功能，

154
00:07:51,840 --> 00:07:54,890
从这份清单中得到的主要结论是，

155
00:07:55,780 --> 00:07:58,920
随着程序的发展，应用程序的发展，

156
00:07:58,920 --> 00:08:01,970
或者软件开发中的趋势的发展，

157
00:08:02,380 --> 00:08:05,205
SQL 已经一直在跟随它，

158
00:08:05,205 --> 00:08:07,910
采用了这些想法，并采用了新的功能。

159
00:08:08,770 --> 00:08:12,470
所以，在 2023 年，已经推出的两大功能是

160
00:08:12,760 --> 00:08:16,220
现在你可以直接在 SQL 中进行属性图查询。

161
00:08:16,590 --> 00:08:18,790
所以上节课有人提到了 Neo4j ，

162
00:08:19,140 --> 00:08:23,500
那就是一个特殊用途的图形数据模型数据库系统，

163
00:08:24,160 --> 00:08:25,270
但是现在你不再需要它了，

164
00:08:25,270 --> 00:08:28,045
因为你现在可以直接在 SQL 中运行图形查询，

165
00:08:28,045 --> 00:08:29,490
因为 SQL 标准支持它。

166
00:08:30,010 --> 00:08:32,570
它们还添加了对多维数组的支持，

167
00:08:33,070 --> 00:08:33,795
我之前说过，

168
00:08:33,795 --> 00:08:36,980
很多机器学习的东西都是基于数组或矩阵的，

169
00:08:37,270 --> 00:08:39,650
现在你可以直接在 SQL 上操作这些东西。

170
00:08:40,000 --> 00:08:42,105
现在，仅仅因为标准有定义，

171
00:08:42,105 --> 00:08:43,820
并不意味着每个系统都会支持它，

172
00:08:45,430 --> 00:08:49,490
我不认为任何系统真正支持多维数组的东西，

173
00:08:49,570 --> 00:08:51,015
Oracle 支持属性图之类的东西，

174
00:08:51,015 --> 00:08:51,975
Postgres 最终将到达那里，

175
00:08:51,975 --> 00:08:54,140
DuckDB 最终会到达， DuckdB 有一个原型。

176
00:08:54,400 --> 00:08:55,980
但是因为它在标准中，

177
00:08:56,270 --> 00:08:58,050
现在每个数据库都将去支持它。

178
00:08:59,000 --> 00:09:00,210
所以，在我看来，

179
00:09:00,650 --> 00:09:04,800
要说你的数据库支持 SQL 的最小支持

180
00:09:04,940 --> 00:09:07,020
是在 SQL-92 标准中定义的，

181
00:09:07,700 --> 00:09:10,140
比如 SELECT INSERT UPDATE DELETE CREATE 表，

182
00:09:10,490 --> 00:09:12,360
这是基本的功能。

183
00:09:13,070 --> 00:09:15,145
再说一次，尽管 SQL 已经有 50 多年的历史，

184
00:09:15,145 --> 00:09:16,110
但它并不是一种过时的语言，

185
00:09:16,190 --> 00:09:17,580
而且一直在更新。

186
00:09:18,220 --> 00:09:20,460
当然，每隔十年，每隔五年，

187
00:09:20,600 --> 00:09:22,075
就会有一些新技术问世，

188
00:09:22,075 --> 00:09:24,240
人们说 SQL 已经死了，

189
00:09:24,890 --> 00:09:25,890
它即将被取代，

190
00:09:27,020 --> 00:09:28,500
10 年前，它是 NoSQL ，

191
00:09:28,730 --> 00:09:32,640
现在最热门的是 ChatGPT 或矢量数据库，

192
00:09:32,930 --> 00:09:36,850
所以你在 Twitter 或社交媒体上看到很多这样的事情，

193
00:09:36,850 --> 00:09:38,310
他们声称 SQL 将会消亡，

194
00:09:38,450 --> 00:09:40,615
因为 ChatGPT 将取代它，

195
00:09:40,615 --> 00:09:41,970
或者自然语言将取代它，

196
00:09:42,710 --> 00:09:45,060
这都是一堆炒作，

197
00:09:45,680 --> 00:09:47,970
这很有趣，但它不会替代 SQL ，

198
00:09:48,290 --> 00:09:49,650
在你出生之前， SQL 就在这里了，

199
00:09:50,000 --> 00:09:51,210
当你死的时候， SQL 仍在这里。

200
00:09:53,990 --> 00:09:57,250
我已经就此发表了公开声明，

201
00:09:57,250 --> 00:10:03,120
他们去年在杂志上引用了我的一篇文章。

202
00:10:03,170 --> 00:10:04,720
我说，你需要指导 SQL ，

203
00:10:04,720 --> 00:10:06,630
如果你想在计算机科学中做任何事情。

204
00:10:07,520 --> 00:10:08,010
好的，

205
00:10:09,440 --> 00:10:12,485
所以，在像 SQL 这样的关系语言中，

206
00:10:12,485 --> 00:10:14,320
它将由三个部分组成，

207
00:10:14,790 --> 00:10:17,530
将会有 DML ，数据操作语言，

208
00:10:17,790 --> 00:10:21,500
这就是我们的 SELECT INSERT UPDATE DELETE 查询，

209
00:10:21,500 --> 00:10:22,900
在我们的数据库中与之交互，

210
00:10:23,430 --> 00:10:25,355
将会有 DDL ，数据定义语言，

211
00:10:25,355 --> 00:10:27,280
即 CREATE TABLE 语句， CREATE VIEW 语句，

212
00:10:27,600 --> 00:10:31,030
用于创建我们数据库中的对象实体，

213
00:10:31,800 --> 00:10:33,650
然后会有，我们不会真的讨论这一点，

214
00:10:33,650 --> 00:10:35,470
但将会有 DCL ，数据控制语言，

215
00:10:35,790 --> 00:10:37,930
用于类似安全和访问控制，

216
00:10:38,340 --> 00:10:39,530
有些系统允许你，

217
00:10:39,530 --> 00:10:42,230
你可以指定允许哪些用户可以查看

218
00:10:42,230 --> 00:10:44,560
哪些行、哪些列或哪些表等，

219
00:10:44,760 --> 00:10:47,050
所以， SQL 标准为这些内容指定了（标准）。

220
00:10:48,250 --> 00:10:48,945
另一个重要的东西，

221
00:10:48,945 --> 00:10:51,980
我们将在本学期晚些时候看到的是事务的定义，

222
00:10:53,200 --> 00:10:58,040
如何定义一组你希望以隔离方式原子发生的 SQL 语句，

223
00:10:58,210 --> 00:11:00,290
同样， SQL 标准支持这一点。

224
00:11:00,700 --> 00:11:03,500
我们会在这学期看到这些零星的东西，

225
00:11:03,580 --> 00:11:04,850
但在今天的课程中，

226
00:11:05,170 --> 00:11:07,550
我们真正要关注的是第一个， DML 。

227
00:11:08,350 --> 00:11:12,650
从我们上节课讲到的提醒一下，

228
00:11:13,450 --> 00:11:14,630
SQL 基于袋子的，

229
00:11:14,740 --> 00:11:16,760
这意味着可能会有重复的，

230
00:11:17,110 --> 00:11:19,610
而关系代数是基于集合的，

231
00:11:20,080 --> 00:11:21,150
我们看到了一些情况，

232
00:11:21,150 --> 00:11:26,630
我们必须在 SQL 语句中添加额外的东西来处理这个问题。

233
00:11:28,480 --> 00:11:31,485
所以，今天应该是一个关于现代 SQL 的速成课程，

234
00:11:31,485 --> 00:11:34,190
我假设每个人，无论你是否知道，

235
00:11:34,390 --> 00:11:36,470
你已经足够了解 SQL-92 标准，

236
00:11:37,090 --> 00:11:38,210
SELECT INSERT UPDATE DELETE,

237
00:11:38,560 --> 00:11:40,040
我想谈谈，

238
00:11:40,900 --> 00:11:44,430
我想谈谈你可以用它们做的更复杂的事情，

239
00:11:44,960 --> 00:11:48,300
但是最重要的主题将是，

240
00:11:48,300 --> 00:11:49,520
我们将会打开终端，

241
00:11:49,630 --> 00:11:51,830
我们将在不同的数据库系统中尝试一系列这样的查询，

242
00:11:52,270 --> 00:11:53,265
我们将看到，

243
00:11:53,265 --> 00:11:55,010
即使有一个 SQL 标准，

244
00:11:55,240 --> 00:11:57,930
也有一个国际公认的文档，

245
00:11:57,930 --> 00:11:59,510
说明了 SQL 应该是什么样子的，

246
00:12:00,440 --> 00:12:03,350
没有人会完全以这种方式实现它，

247
00:12:03,520 --> 00:12:05,430
每个人都会有这些奇怪的细微差别和怪癖，

248
00:12:05,430 --> 00:12:09,440
他们有不同的功能或不同的命名或语法来做某些事情，

249
00:12:10,720 --> 00:12:13,940
在某些情况下，不同操作的不同语义，

250
00:12:14,800 --> 00:12:16,510
即使有一个 SQL 标准，

251
00:12:16,510 --> 00:12:18,240
但每个系统都会有所不同。

252
00:12:19,650 --> 00:12:20,890
猜猜是谁，

253
00:12:20,910 --> 00:12:24,095
我认为谁是最糟糕的 SQL 实现的最大罪魁祸首，

254
00:12:24,095 --> 00:12:25,010
更糟糕的不是正确的词，

255
00:12:25,010 --> 00:12:27,670
而是像最偏离标准的那个，

256
00:12:28,740 --> 00:12:29,500
让我猜猜。

257
00:12:31,850 --> 00:12:32,920
前四名是。

258
00:12:32,920 --> 00:12:33,690
好的，后面的，好的。

259
00:12:34,550 --> 00:12:35,515
MySQL ，他是对的，

260
00:12:35,515 --> 00:12:38,610
是的， MySQL 将会是所有这些中[]，

261
00:12:38,840 --> 00:12:40,230
他们会做各种奇怪的事情，

262
00:12:41,420 --> 00:12:43,540
最近，他们有了一个标志，

263
00:12:43,540 --> 00:12:44,760
可以让它更严格，

264
00:12:44,930 --> 00:12:47,940
并试图更接近 SQL 标准，

265
00:12:48,140 --> 00:12:50,040
但在很长一段时间里，他们做了一系列奇怪的事情。

266
00:12:50,150 --> 00:12:51,390
我的问题是，

267
00:12:51,560 --> 00:12:54,270
我第一次开始使用关系数据库是在，

268
00:12:54,500 --> 00:12:55,975
90 年代，我上高中的时候，

269
00:12:55,975 --> 00:12:57,300
我们使用的是 MySQL 3 ，

270
00:12:57,680 --> 00:12:59,070
所以我有所有的坏习惯，

271
00:12:59,240 --> 00:13:00,880
我从 MySQL 中学到的，

272
00:13:00,880 --> 00:13:02,250
我想，哦，是的，这就是 SQL ，

273
00:13:02,270 --> 00:13:02,935
然后你意识到，

274
00:13:02,935 --> 00:13:04,375
当你开始使用其他系统时，

275
00:13:04,375 --> 00:13:06,690
这太疯狂了，他们在做一些奇怪的事情，

276
00:13:07,760 --> 00:13:08,800
但一切都变好了，

277
00:13:08,850 --> 00:13:11,620
MySQL 8 确实改进了很多。

278
00:13:11,790 --> 00:13:15,010
好的，我们来看一下所有这些 Aggregations, Group by ，

279
00:13:15,420 --> 00:13:16,955
字符串、日期和时间操作，

280
00:13:16,955 --> 00:13:18,610
这将是我们看到所有问题的地方，

281
00:13:18,900 --> 00:13:22,480
然后是一系列其他与 SQL 查询交互的不同方式。

282
00:13:22,740 --> 00:13:25,240
我们将要讨论的另一个主题是，

283
00:13:25,650 --> 00:13:28,510
编写 SQL 语句的目标常常是

284
00:13:28,710 --> 00:13:32,465
尝试在数据库服务器本身上完成所有的计算，

285
00:13:32,465 --> 00:13:35,110
在一种主要的 SQL 查询中。

286
00:13:35,520 --> 00:13:37,340
这意味着我们不必执行 SELECT 操作，

287
00:13:37,340 --> 00:13:39,770
将一些数据返回到一个 Python 程序或其他程序中，

288
00:13:39,770 --> 00:13:41,405
然后对其进行操作，

289
00:13:41,405 --> 00:13:42,700
然后将其推回并执行更多查询，

290
00:13:42,750 --> 00:13:44,140
我们希望尽可能做任何事，

291
00:13:44,430 --> 00:13:47,680
在服务器端，在数据库系统之中，

292
00:13:48,180 --> 00:13:50,270
因为我们希望能够将查询推送到数据，

293
00:13:50,270 --> 00:13:52,600
而不是拉取数据到查询。

294
00:13:53,890 --> 00:13:55,820
随着我们的前进，这更有意义。

295
00:13:57,170 --> 00:14:00,480
好的，今天我们将使用一个简单的示例数据库，

296
00:14:00,830 --> 00:14:04,480
有三张表， student enrolled 和 course ，

297
00:14:04,480 --> 00:14:06,750
它基本上是在模仿一所大学，

298
00:14:06,770 --> 00:14:10,330
有学生，他们参加课程，他们被录取，

299
00:14:10,330 --> 00:14:12,390
他们在那里的各种课程中获得分数。

300
00:14:12,950 --> 00:14:16,770
好的，我们将使用它作为示例数据库。

301
00:14:18,230 --> 00:14:19,440
好的，第一件事是聚合，

302
00:14:20,120 --> 00:14:24,085
聚合函数是一种方式，

303
00:14:24,085 --> 00:14:31,530
对一个数据序列或一个 tuple 袋子进行数学计算，

304
00:14:31,850 --> 00:14:34,830
你是要把它合并成一个单一值。

305
00:14:35,500 --> 00:14:40,920
所以经典的东西是 AVG MIN MAX SUM COUNT ，

306
00:14:41,390 --> 00:14:45,600
你尝试计算一个列的最小值，

307
00:14:46,070 --> 00:14:48,720
在一个关系中所有 tuple 中。

308
00:14:50,420 --> 00:14:51,625
举个简单的例子，

309
00:14:51,625 --> 00:14:52,380
比如我们想要，

310
00:14:52,790 --> 00:14:55,765
对于学生，我们要计算学生的数量，

311
00:14:55,765 --> 00:15:00,960
如果 login 以 @cs 结尾，

312
00:15:01,040 --> 00:15:03,330
是否有 @cs 电子邮件地址。

313
00:15:03,900 --> 00:15:06,680
所以我们把 COUNT 函数放在这里，

314
00:15:07,210 --> 00:15:09,345
然后放在它里面，实际上对 COUNT 没有影响，

315
00:15:09,345 --> 00:15:11,300
但我们计算 logins ，

316
00:15:11,500 --> 00:15:12,425
然后我们有 where 子句，

317
00:15:12,425 --> 00:15:15,590
指定哪个 tuple 应该符合条件。

318
00:15:16,840 --> 00:15:19,160
再说一次，在我的示例中，我放入了 login ，

319
00:15:19,270 --> 00:15:20,390
你实际上不必这样做，

320
00:15:20,530 --> 00:15:23,180
你可以放入一个星号，那是等同的，

321
00:15:23,650 --> 00:15:26,150
因为，它只是计算条目的数量。

322
00:15:26,840 --> 00:15:27,670
你也可以放入 1 ，

323
00:15:28,290 --> 00:15:30,490
也是等同的，没有关系。

324
00:15:31,490 --> 00:15:32,550
在里面，你可以放任何东西，

325
00:15:32,870 --> 00:15:34,200
你可以放入 1+1+1 。

326
00:15:35,000 --> 00:15:37,380
数据库系统应该足够智能，能够意识到这一点，

327
00:15:37,670 --> 00:15:39,180
在这里的最后一个例子中，

328
00:15:39,820 --> 00:15:42,360
我不关心 COUNT 内部的表达式是什么，

329
00:15:42,590 --> 00:15:43,860
我也不会真正做那个数学运算，

330
00:15:44,210 --> 00:15:47,310
因为我只关心我得到的 tuple 的数。

331
00:15:49,310 --> 00:15:51,780
你可以在一个 SELECT 输出中可以有多个聚合，

332
00:15:51,980 --> 00:15:57,840
所以现在我们要计算平均绩点和学生人数，

333
00:15:58,250 --> 00:16:02,460
同样，使用 @cs 匹配 login 。

334
00:16:03,060 --> 00:16:08,090
然后，你将在输出结果中得到单个条目或单个记录，

335
00:16:08,890 --> 00:16:09,920
对于这两次计算。

336
00:16:13,050 --> 00:16:15,005
对于聚合，需要理解的重要一点是，

337
00:16:15,005 --> 00:16:20,710
虽然你尝试合并多个 tuple 到单个标量值，

338
00:16:21,360 --> 00:16:25,490
但是你不能引用 SELECT 输出的任何内容，

339
00:16:25,690 --> 00:16:28,310
那不是聚合的一部分。

340
00:16:28,930 --> 00:16:30,060
所以我不能做这样的事，

341
00:16:30,060 --> 00:16:31,910
我不能 SELECT AVG(s.gpa) ，

342
00:16:32,860 --> 00:16:34,880
在你 JOIN student 表和 enrolled 表之后，

343
00:16:35,230 --> 00:16:41,730
然后还获取 enrolled 表的 cid ，

344
00:16:42,480 --> 00:16:45,980
因为这没有定义，这没有任何意义，

345
00:16:46,210 --> 00:16:47,090
这里没有，

346
00:16:47,830 --> 00:16:49,400
你使用多行，

347
00:16:49,420 --> 00:16:53,330
你[压缩]它，以获得平均值，

348
00:16:53,800 --> 00:16:57,000
在这个上下文中的 cid 是什么，

349
00:16:57,050 --> 00:16:57,600
它什么都不是。

350
00:16:58,830 --> 00:17:00,320
所以，在这个例子中，

351
00:17:00,320 --> 00:17:02,000
你看这个，

352
00:17:02,000 --> 00:17:03,040
你真正想做的是，

353
00:17:03,120 --> 00:17:06,040
你试图得到每个 cid ，得到 gpa 平均值，

354
00:17:07,890 --> 00:17:10,390
所以，你需要做的是 GROUP BY 子句，

355
00:17:11,240 --> 00:17:15,230
你将 tuple 投影到桶中，

356
00:17:15,230 --> 00:17:18,070
根据 GROUP BY 子句中的参数，

357
00:17:18,820 --> 00:17:21,900
然后计算每个单独桶的聚合。

358
00:17:23,030 --> 00:17:23,980
所以你大概是这样想的，

359
00:17:23,980 --> 00:17:28,320
如果我首先在 enrolled 表和 student 表之间进行 JOIN ，

360
00:17:28,730 --> 00:17:31,950
我就有了基于 JOIN 的所有可能的组合，

361
00:17:32,510 --> 00:17:35,470
然后我将根据 cid 将它们分开，

362
00:17:35,470 --> 00:17:38,640
因为这就在我的 GROUP BY 子句中，

363
00:17:39,370 --> 00:17:44,600
然后现在我对每个桶计算平均绩点。

364
00:17:46,730 --> 00:17:47,250
能理解吗？

365
00:17:50,660 --> 00:17:51,750
就像这样匹配。

366
00:17:53,510 --> 00:17:54,970
所以，这里的主要观点是，

367
00:17:54,970 --> 00:17:56,790
你必须有任何东西在一个，

368
00:17:58,690 --> 00:18:02,660
不属于聚合的任何东西必须出现在 GROUP BY 子句中。

369
00:18:02,920 --> 00:18:03,990
再说一次，在这里，

370
00:18:03,990 --> 00:18:05,150
我没有 s.name ，

371
00:18:05,380 --> 00:18:07,100
我不能把它放在那里，

372
00:18:07,180 --> 00:18:09,080
我必须把它放在 GROUP BY 子句中。

373
00:18:10,530 --> 00:18:11,615
如果你希望，我们可以打开终端。

374
00:18:11,615 --> 00:18:13,870
MySQL 允许你做一些例子，

375
00:18:16,460 --> 00:18:18,120
让我们试着看看会发生什么。

376
00:18:20,750 --> 00:18:23,610
我讨厌在我的 Surface 上打字，

377
00:18:23,610 --> 00:18:25,160
我将使用这台笔记本电脑，

378
00:18:25,880 --> 00:18:26,680
我会登录进去。

379
00:18:33,870 --> 00:18:37,160
好的，我们要做的是 Postgres ，

380
00:18:37,160 --> 00:18:38,440
我有很多数据库系统在运行，

381
00:18:38,880 --> 00:18:40,660
所以我们要做的查询是，

382
00:18:45,730 --> 00:18:48,825
本质上是这样的，

383
00:18:48,825 --> 00:18:53,700
SELECT AVG(s.gpa), e.cid FROM enrolled AS e JOIN student AS s ON e.sid = s.sid; 。

384
00:18:53,840 --> 00:18:55,270
所以 Postgres 不允许你这样做，

385
00:18:55,270 --> 00:18:58,410
因为它规定 cid 必须出现在 GROUP BY 子句中，

386
00:18:58,550 --> 00:19:00,270
这很好，这正是我们所期待的。

387
00:19:01,085 --> 00:19:01,930
让我们来看看 MySQL ，

388
00:19:03,570 --> 00:19:04,780
MySQL 不允许你这样做，

389
00:19:06,120 --> 00:19:09,220
但让我看看，在默认情况下是否将其设置为正确的模式，

390
00:19:11,670 --> 00:19:12,680
是的，不允许你这样做，

391
00:19:12,680 --> 00:19:13,660
但有一种方法可以，

392
00:19:14,400 --> 00:19:19,455
它会强制执行某种模式，

393
00:19:19,455 --> 00:19:20,450
如果我转到传统模式，

394
00:19:22,670 --> 00:19:23,910
然后，现在运行相同的查询，

395
00:19:24,560 --> 00:19:25,470
它会让我这么做，

396
00:19:26,250 --> 00:19:28,750
它输出 cid 15-445 ，

397
00:19:29,360 --> 00:19:30,100
这是正确的吗？

398
00:19:32,410 --> 00:19:33,705
不对，是吧，因为那是什么意思，

399
00:19:33,705 --> 00:19:35,180
这是所有课程的平均绩点，

400
00:19:35,530 --> 00:19:36,920
但是它却输出了其中的一个，

401
00:19:37,300 --> 00:19:38,240
所以这很糟糕。

402
00:19:39,400 --> 00:19:41,000
所以我们现在开始，使用同样的查询，

403
00:19:41,560 --> 00:19:45,810
我们将转到 SQLite 。

404
00:19:48,250 --> 00:19:49,160
谁认为它会工作，

405
00:19:50,010 --> 00:19:50,980
如果你回答是的，请举手，

406
00:19:51,860 --> 00:19:54,090
而工作意味着它将运行查询，

407
00:19:54,170 --> 00:19:55,350
我不是在说结果正确，

408
00:19:56,290 --> 00:19:56,810
谁认为？

409
00:19:57,580 --> 00:19:58,860
我们有一个，两个是的。

410
00:19:58,860 --> 00:19:59,480
谁认为不会？

411
00:20:01,120 --> 00:20:01,910
大多数人说不会。

412
00:20:03,370 --> 00:20:05,510
它完成了，

413
00:20:06,160 --> 00:20:07,910
它还输出了 15-445 ，

414
00:20:08,020 --> 00:20:09,440
这和 MySQL 的值一样吗？

415
00:20:10,290 --> 00:20:14,530
是的，绩点看起来，抱歉，绩点看起来是一样的。

416
00:20:16,120 --> 00:20:17,610
好的，我们转到 Oracle ，

417
00:20:20,210 --> 00:20:21,210
Oracle 不喜欢这样。

418
00:20:21,655 --> 00:20:22,440
我们转到 DuckDB ，

419
00:20:25,350 --> 00:20:26,080
DuckDB 不喜欢这样。

420
00:20:26,220 --> 00:20:27,580
所以 MySQL ，你可以这样做，

421
00:20:27,690 --> 00:20:29,260
你可以让它这样做，

422
00:20:29,280 --> 00:20:30,940
比如在 MySQL 5.7 和 8 上，

423
00:20:31,080 --> 00:20:32,110
但是 SQLite 会这样做。

424
00:20:32,760 --> 00:20:35,550
所以，这是第一个例子，

425
00:20:35,550 --> 00:20:36,350
我们会看到很多次，

426
00:20:37,390 --> 00:20:39,020
SQL 标准说的一件事情，

427
00:20:39,280 --> 00:20:41,210
但是不同的系统做不同的事情。

428
00:20:45,170 --> 00:20:46,200
接下来你要做的是，

429
00:20:46,370 --> 00:20:47,460
你可以有一个 HAVING 子句，

430
00:20:47,780 --> 00:20:52,500
比如，如果你想要在你生成的这些聚合列上过滤，

431
00:20:53,660 --> 00:20:56,190
你可以添加一个 HAVING 子句来指定，

432
00:20:57,230 --> 00:20:59,250
什么人应该匹配，

433
00:21:00,200 --> 00:21:02,300
在你完成聚合之后，

434
00:21:02,300 --> 00:21:03,580
比如，我只想要，

435
00:21:04,920 --> 00:21:10,080
展示那些平均绩点大于 3.9 的学生，

436
00:21:10,460 --> 00:21:11,470
所以在本例中，

437
00:21:11,470 --> 00:21:16,140
我计算的是聚合 SELECT AVG(s.gpa) AS avg_gpa ，

438
00:21:16,220 --> 00:21:19,500
并且我试图在 WHERE 子句中引用它，

439
00:21:19,730 --> 00:21:20,680
我不能这样做，

440
00:21:20,680 --> 00:21:24,060
因为此时系统正在计算查询，

441
00:21:24,820 --> 00:21:26,610
它一边运行，一边计算聚合，

442
00:21:26,900 --> 00:21:29,310
它不知道最后的结果是什么，

443
00:21:30,790 --> 00:21:33,230
所以，解决这一问题的简单方法是有一个 HAVING 子句，

444
00:21:34,040 --> 00:21:35,230
这基本上是在告诉系统，

445
00:21:35,790 --> 00:21:40,260
[形成聚合]是生成在 SELECT 语句中定义的输出，

446
00:21:40,760 --> 00:21:44,040
然后应用这个 HAVING 额外的过滤器。

447
00:21:46,310 --> 00:21:48,210
在某些情况下，这其实也是不对的，

448
00:21:48,320 --> 00:21:50,830
我也不认为 SQL 标准允许你这样做，

449
00:21:50,830 --> 00:21:53,580
因为即使我在这里有一个平均绩点的别名，

450
00:21:54,490 --> 00:21:57,590
数据系统会说，我不知道这是什么，

451
00:21:58,630 --> 00:22:01,920
MySQL 可以这样做， Postgres 不能，

452
00:22:01,920 --> 00:22:06,560
除非你必须重新编写聚合子句，

453
00:22:07,240 --> 00:22:09,830
同样，数据库应该足够智能，能够识别，

454
00:22:10,000 --> 00:22:12,980
这个 gpa 上的平均值与上面的 avg_gpa 相同，

455
00:22:13,060 --> 00:22:17,690
因此计算相同的计算，而不是执行两次相同的计算。

456
00:22:20,030 --> 00:22:21,265
所以，本质上只是再次执行此操作，

457
00:22:21,265 --> 00:22:24,780
计算聚合，然后进行额外的过滤，以丢弃不需要的内容。

458
00:22:26,510 --> 00:22:27,030
能理解吗？

459
00:22:29,550 --> 00:22:34,085
好的，字符串和时间戳或日期，

460
00:22:34,085 --> 00:22:36,665
在这里事情变得非常奇怪，

461
00:22:36,665 --> 00:22:39,730
不是奇怪，但是非常不一致。

462
00:22:40,470 --> 00:22:43,750
对于字符串函数或字符串数据类型，

463
00:22:44,190 --> 00:22:46,775
SQL 标准规定，

464
00:22:46,775 --> 00:22:49,690
值中字符串的大小写，

465
00:22:49,770 --> 00:22:51,245
我指的不是字符串和 SELECT 语句，

466
00:22:51,245 --> 00:22:52,810
我指的是你存储的实际数据，

467
00:22:53,460 --> 00:22:54,680
它们应该区分大小写，

468
00:22:55,240 --> 00:22:59,570
当你希望在 SQL 语句中包含常量字符串时，

469
00:22:59,980 --> 00:23:01,370
你应该使用单引号，

470
00:23:02,260 --> 00:23:05,210
Postgres, SQL Server 和 Oracle 都遵循标准，

471
00:23:05,620 --> 00:23:10,470
而 MySQL 是，默认情况下，不区分大小写，

472
00:23:11,600 --> 00:23:14,520
然后 SQLite 和 MySQL 都支持

473
00:23:14,660 --> 00:23:20,160
使用单引号和双引号来表示常量和字符串。

474
00:23:21,325 --> 00:23:22,200
所以让我们操作 MySQL ，

475
00:23:22,370 --> 00:23:23,430
看看这有多奇怪。

476
00:23:25,100 --> 00:23:30,670
所以让我们回到这里，

477
00:23:30,670 --> 00:23:36,210
所以你可以像这样表示一个常量，

478
00:23:36,210 --> 00:23:40,100
你可以在 MySQL 中使用不带 FROM 子句的 SELECT 语句，

479
00:23:40,690 --> 00:23:41,420
我可以表示，

480
00:23:42,190 --> 00:23:43,880
它基本上接受任何输入，

481
00:23:43,990 --> 00:23:45,450
我可以，它会把它输出出来，

482
00:23:45,450 --> 00:23:46,280
所以我加了一个逗号，

483
00:23:46,630 --> 00:23:51,700
比如，我可以做 1 2 3 ，像这样，

484
00:23:51,960 --> 00:23:54,490
它将对输出中的所有内容进行[排列]。

485
00:23:55,100 --> 00:23:56,305
所以对于字符串，

486
00:23:56,305 --> 00:24:01,690
我可以放在单引号或双引号中，

487
00:24:03,060 --> 00:24:09,110
在 Postgres 中，它不允许我使用双引号，

488
00:24:09,760 --> 00:24:10,330
无法执行这个操作，

489
00:24:10,330 --> 00:24:12,130
因为它在尝试查找名为 tupac 的列，

490
00:24:12,130 --> 00:24:14,400
这是你转义列名的方式，

491
00:24:14,750 --> 00:24:18,570
但它将支持单引号。

492
00:24:19,550 --> 00:24:22,020
在 SQLite 中，它们两者都支持，

493
00:24:24,070 --> 00:24:25,460
可以像这样获取 tupac ，

494
00:24:26,820 --> 00:24:28,960
我也可以用这样的单引号。

495
00:24:29,900 --> 00:24:34,820
在 Oracle 中，它是单引号，

496
00:24:36,780 --> 00:24:38,830
但它没有没有 FROM 子句的查询，

497
00:24:40,690 --> 00:24:44,150
在 Oracle 中，他们有一个奇怪的东西，叫做 DUAL 表，

498
00:24:44,530 --> 00:24:47,940
这是一个 Oracle 中假的表，

499
00:24:48,230 --> 00:24:53,310
允许你对实际不存在的表编写查询，

500
00:24:53,310 --> 00:24:54,350
然后我可以得到，

501
00:24:55,180 --> 00:24:57,470
如果你尝试， SELECT * FROM DUAL ，

502
00:25:01,710 --> 00:25:02,860
你只会得到一个 X ，

503
00:25:04,870 --> 00:25:05,730
我认为更新的版本，

504
00:25:05,730 --> 00:25:07,065
他们避免了 DUAL ，你不再需要，

505
00:25:07,065 --> 00:25:08,985
这是 Oracle 21 ，

506
00:25:08,985 --> 00:25:11,090
所以它是一个相当新的版本，

507
00:25:12,850 --> 00:25:16,285
比如你不能这样做，

508
00:25:16,285 --> 00:25:18,630
但在 Postgres 或任何其他数据库系统中，

509
00:25:18,950 --> 00:25:20,880
你可以将 SQL 当作计算器，

510
00:25:21,050 --> 00:25:23,010
你可以把任何你想要的东西放在子句中。

511
00:25:24,350 --> 00:25:26,040
好的，让我们回到 MySQL ，

512
00:25:27,530 --> 00:25:29,010
让我们来看一些字符串函数。

513
00:25:30,030 --> 00:25:33,920
所以，我现在可以调用，

514
00:25:36,870 --> 00:25:39,700
我可以做 SELECT * FROM student WHERE name = 'TuPaC';

515
00:25:39,720 --> 00:25:41,320
带有奇怪的大小写，

516
00:25:41,610 --> 00:25:45,925
然后它与字符串 Tupac 匹配，

517
00:25:45,925 --> 00:25:50,280
因为在内部 MySQL 将 varchar 视为不区分大小写。

518
00:25:51,510 --> 00:25:52,840
所以如果你现在想要，

519
00:25:56,110 --> 00:26:00,045
如果你想像对待任何其他数据库系统一样对待它，

520
00:26:00,045 --> 00:26:02,570
它的大小写视为 TuPaC ，

521
00:26:02,860 --> 00:26:07,970
你可以在列名前面添加这个 BINARY 标志或关键字，

522
00:26:08,200 --> 00:26:10,890
这将把它视为一个 BINARY 字符串，

523
00:26:10,890 --> 00:26:11,780
就像任何其他系统一样，

524
00:26:12,610 --> 00:26:13,995
在这种情况下，现在它不匹配，

525
00:26:13,995 --> 00:26:15,620
但现在它告诉我有一个警告。

526
00:26:16,460 --> 00:26:18,430
所以现在我要调用 show warnings ，

527
00:26:18,540 --> 00:26:20,230
这是 MySQL 特有的，

528
00:26:20,820 --> 00:26:21,940
所以现在他们告诉我，

529
00:26:22,350 --> 00:26:25,480
BINARY 表达式已被弃用并被删除，

530
00:26:26,040 --> 00:26:28,240
他们至少告诉我如何正确编写它，

531
00:26:29,350 --> 00:26:33,590
所以现在我必须 CAST(name AS BINARY) ，

532
00:26:33,790 --> 00:26:34,820
然后我就可以调用它了。

533
00:26:35,500 --> 00:26:36,860
所以如果我再换一次大小写，

534
00:26:37,420 --> 00:26:38,270
我就会得到 Tupac 。

535
00:26:39,660 --> 00:26:40,820
这会让很多人感到痛苦，

536
00:26:40,820 --> 00:26:42,400
因为他们会想，

537
00:26:42,420 --> 00:26:46,900
哦，如果你不知道 varchar 不区分大小写，

538
00:26:47,070 --> 00:26:48,670
你可以多次存储东西，

539
00:26:51,300 --> 00:26:52,815
以为情况会不同，

540
00:26:52,815 --> 00:26:53,600
因为大小写不同，

541
00:26:53,920 --> 00:26:55,610
但是 MySQL 说它们是一样的。

542
00:26:56,580 --> 00:26:57,800
再说一次，这只是 MySQL ，

543
00:26:57,800 --> 00:26:59,800
我不知道有任何其他数据这样做，

544
00:27:00,330 --> 00:27:01,360
所以这是一个奇怪的特性。

545
00:27:11,240 --> 00:27:13,830
问题是，为什么这个名字要大写？

546
00:27:22,280 --> 00:27:23,280
所以他的问题是，

547
00:27:25,280 --> 00:27:26,190
我告诉你，

548
00:27:26,270 --> 00:27:29,130
数据是以区分大小写的方式存储的，

549
00:27:29,660 --> 00:27:34,140
比较运算符，当它实际使用 WHERE 子句时忽略了大小写，

550
00:27:36,130 --> 00:27:39,630
所以它不会调用 libc 中的字符串比较，

551
00:27:40,550 --> 00:27:42,565
它要么调用自己的版本，

552
00:27:42,565 --> 00:27:44,430
或者大小写不敏感的版本，

553
00:27:45,610 --> 00:27:48,080
因为这是 1990 年代某人做出一些决定，

554
00:27:48,310 --> 00:27:49,760
至今仍在延续。

555
00:27:51,090 --> 00:27:51,490
好的。

556
00:27:53,170 --> 00:27:54,110
他们为什么要做出这样的决定？

557
00:27:55,460 --> 00:27:58,650
最后再问我那个问题，

558
00:27:58,790 --> 00:28:01,180
从头到尾再说一遍，

559
00:28:01,180 --> 00:28:03,505
这可能是因为有人只是以一种方式做了，

560
00:28:03,505 --> 00:28:05,100
决定了怎么做，

561
00:28:05,480 --> 00:28:10,470
或者 MySQL 在很多情况下试图效仿 Oracle 在某些情况下所做的事情，

562
00:28:10,670 --> 00:28:11,730
但是 Oracle 没有这么做，

563
00:28:12,140 --> 00:28:14,465
我没有头绪，

564
00:28:14,465 --> 00:28:17,140
我们可以给他还活着的人发邮件。

565
00:28:21,140 --> 00:28:25,060
所以，是的，我认为很多时候，人们只是做一些事情，

566
00:28:25,060 --> 00:28:28,380
因为，就像一个人做了事情，没有真正考虑它的含义，

567
00:28:29,780 --> 00:28:31,360
或者他们试图复制其他系统，

568
00:28:31,360 --> 00:28:34,500
他们喜欢其他一些特定的功能。

569
00:28:39,330 --> 00:28:39,850
还有其他问题吗？

570
00:28:42,340 --> 00:28:46,160
我们会看看很多例子，为什么有人会这样做。

571
00:28:47,400 --> 00:28:49,400
好的，我想我之前展示了一个类似这样的查询，

572
00:28:49,420 --> 00:28:50,420
只是确保你看到它。

573
00:28:50,500 --> 00:28:54,200
在 SQL 中有这样的 LIKE 操作，

574
00:28:54,280 --> 00:28:58,100
你可以使用它来进行基本字符串匹配或和模式匹配，

575
00:28:58,750 --> 00:29:02,000
所以你调用 LIKE ，然后你说，

576
00:29:02,900 --> 00:29:05,690
你可以有一个百分号来表示通配符，

577
00:29:05,690 --> 00:29:07,720
如果你来自 Unix 世界，

578
00:29:07,740 --> 00:29:11,530
星号正则表达式通常意味着匹配任何内容，或者点号，

579
00:29:12,410 --> 00:29:14,850
在 SQL 中，它是百分号，

580
00:29:15,080 --> 00:29:18,810
可以匹配任何子字符串，包括空字符串，

581
00:29:18,980 --> 00:29:22,260
但是如果你想匹配一个字符，你可以使用下划线，

582
00:29:22,740 --> 00:29:24,770
而且还支持正则表达式，

583
00:29:24,770 --> 00:29:27,320
我忘记了这是否在 SQL 标准中，

584
00:29:27,320 --> 00:29:28,870
但每个人的做法略有不同，

585
00:29:29,820 --> 00:29:34,210
你可以编写更复杂的字符串匹配模式。

586
00:29:36,040 --> 00:29:38,120
在 SQL 标准中也有许多字符串函数，

587
00:29:38,290 --> 00:29:39,770
可以做你所期望的事情，

588
00:29:39,790 --> 00:29:40,800
如果你熟悉 Python ，

589
00:29:40,800 --> 00:29:41,900
那么所有的 Python 函数，

590
00:29:43,270 --> 00:29:46,340
大写字母，小写字母，子字符串，替换字符串，

591
00:29:46,840 --> 00:29:48,410
所有这些都在 SQL 标准中，

592
00:29:48,760 --> 00:29:49,935
而且在很大程度上，

593
00:29:49,935 --> 00:29:54,210
这些都将在各种系统中保持一致。

594
00:29:55,750 --> 00:29:57,890
不一样的地方是，

595
00:29:57,940 --> 00:30:00,740
我们认为最简单的操作，连接两个字符串，

596
00:30:01,120 --> 00:30:03,080
这是每个人喜欢做一些略有不同的事情的地方。

597
00:30:03,880 --> 00:30:05,080
所以 SQL 标准说，

598
00:30:05,080 --> 00:30:09,120
双竖线是连接字符串的方式，

599
00:30:10,640 --> 00:30:14,340
在 SQL Server 中，他们使用加号，

600
00:30:15,790 --> 00:30:21,060
在 MySQL 中，他们在默认模式下没有，

601
00:30:21,060 --> 00:30:23,570
他们没有双竖线，他们不支持加号，

602
00:30:23,740 --> 00:30:28,165
你必须使用 CONCAT 函数，

603
00:30:28,165 --> 00:30:29,130
我们很快能看到这一点。

604
00:30:30,430 --> 00:30:32,790
所以，回到 MySQL ，

605
00:30:38,070 --> 00:30:43,520
所以，想要做这样的事情，

606
00:30:44,780 --> 00:30:45,600
我又得到了一个警告，

607
00:30:45,710 --> 00:30:46,560
我显示警告，

608
00:30:50,750 --> 00:30:52,800
它告诉我它不喜欢我的语法，

609
00:30:54,960 --> 00:30:56,200
这是第一个，抱歉，

610
00:30:56,940 --> 00:30:59,060
我收到了两个警告，

611
00:30:59,320 --> 00:31:04,040
说双竖线是 OR 的同义词，因此它将被弃用，

612
00:31:05,580 --> 00:31:06,510
他们不喜欢我的方式，

613
00:31:06,510 --> 00:31:11,840
我发送的 @cs ，

614
00:31:12,370 --> 00:31:14,420
所以我们现在尝试调用，

615
00:31:14,500 --> 00:31:16,880
我们修改 MySQL 的 sql_mode ，

616
00:31:17,580 --> 00:31:19,460
为了遵循 SQL 标准，

617
00:31:19,780 --> 00:31:22,970
现在我可以得到我想要的连接。

618
00:31:26,110 --> 00:31:27,800
所以再说一次，它是连接，

619
00:31:27,820 --> 00:31:31,065
它非常（多），每个系统都应该做同样的事情，

620
00:31:31,065 --> 00:31:33,405
但又一次，在 MySQL 的情况下，

621
00:31:33,405 --> 00:31:34,980
是 90 年代遗留下来的东西，

622
00:31:34,980 --> 00:31:36,710
他们试图慢慢撤销。

623
00:31:39,150 --> 00:31:42,920
好的，日期和时间可能是最糟糕的。

624
00:31:43,660 --> 00:31:45,955
SQL 标准定义了一系列方法，

625
00:31:45,955 --> 00:31:52,020
定义日期类型、时间类型以及时间戳，

626
00:31:52,600 --> 00:31:55,830
不同的日历类型，儒略历，格里高利历，

627
00:31:56,450 --> 00:32:01,680
但是，再一次，语法如何变化，是相当恼人的。

628
00:32:02,220 --> 00:32:03,260
所以我现在想给它一个 demo ，

629
00:32:03,310 --> 00:32:08,480
试着做一个看起来很简单的计算，

630
00:32:08,890 --> 00:32:10,520
我们只想数一数天数，

631
00:32:11,550 --> 00:32:14,020
从今天起到年初，

632
00:32:14,740 --> 00:32:17,120
好像是 230 天， 240 天，

633
00:32:17,260 --> 00:32:19,610
只是天数，日历上的总天数。

634
00:32:20,390 --> 00:32:22,260
我们将首先在 Postgres 中执行此操作，

635
00:32:22,640 --> 00:32:25,980
然后在 MySQL 中执行此操作，

636
00:32:26,000 --> 00:32:27,630
然后在 SQL Server 中执行此操作。

637
00:32:28,420 --> 00:32:29,805
所以，我们需要做的第一件事是

638
00:32:29,805 --> 00:32:34,080
如何获得当前日期，当前时间。

639
00:32:34,670 --> 00:32:38,520
好的，在 Postgres 中有一个名为 NOW 的函数，

640
00:32:39,260 --> 00:32:44,690
这会给你一个时间戳以及当前日期，

641
00:32:45,410 --> 00:32:51,130
在 MySQL 中，你可以做同样的事情，

642
00:32:51,920 --> 00:32:55,890
在 SQLite 中，他们没有 NOW 函数，

643
00:32:56,840 --> 00:33:01,015
在 DuckDB 中， DuckDB 在很多方面几乎都会遵循 Postgres ，

644
00:33:01,015 --> 00:33:04,320
因为它们使用相同的 SQL 语法，

645
00:33:04,900 --> 00:33:05,840
所以它们有 NOW 函数，

646
00:33:07,000 --> 00:33:07,970
我切换到 Oracle ，

647
00:33:09,970 --> 00:33:11,300
Oracle 没有 NOW 函数。

648
00:33:12,200 --> 00:33:14,350
好的，还有另一种方法可以得到时间戳，

649
00:33:14,350 --> 00:33:15,390
在 SQL 标准中，

650
00:33:15,740 --> 00:33:21,060
有一个叫做 CURRENT_TIMESTAMP 的函数，

651
00:33:21,320 --> 00:33:23,930
只是它不是一个函数，它是个关键词，

652
00:33:25,620 --> 00:33:30,790
然后在 MySQL 中，它们有这个函数，它们有这个关键字，

653
00:33:32,300 --> 00:33:39,060
在 SQLite 中，他们没有这个函数，他们有这个关键词，

654
00:33:39,840 --> 00:33:43,290
在 Oracle 中，没有，

655
00:33:43,880 --> 00:33:45,725
给了我们一个奇怪的错误，

656
00:33:45,725 --> 00:33:46,510
我们一会儿回来，

657
00:33:47,010 --> 00:33:48,605
他们没有关键词，

658
00:33:48,605 --> 00:33:50,800
所以他们有这个函数，但我们得到了一个奇怪的错误，

659
00:33:51,090 --> 00:33:53,530
日期时间，间隔精度超出范围，

660
00:33:54,250 --> 00:33:55,070
好的，那是什么，

661
00:33:56,650 --> 00:33:58,490
所以现在我们可能得回去，

662
00:33:59,470 --> 00:34:01,400
哦，因为它是 Oracle ，

663
00:34:01,570 --> 00:34:05,150
它没有没有 FROM 子句的 SELECT 语句，

664
00:34:05,530 --> 00:34:07,190
所以让我们添加我们的假表 DUAL ，

665
00:34:08,680 --> 00:34:10,160
然后我们就正确了，

666
00:34:10,270 --> 00:34:14,180
但它是关键字，而不是时间戳。

667
00:34:15,030 --> 00:34:20,050
好了，至少现在我们可以得到当天的当前时间了，

668
00:34:21,560 --> 00:34:22,625
现在我们可以做的是，

669
00:34:22,625 --> 00:34:27,040
我们可以开始将字符串或变量转换为日期类型，

670
00:34:27,450 --> 00:34:29,555
然后在 SQL 标准中有这个 EXTRACT 函数，

671
00:34:29,555 --> 00:34:33,160
它允许我们提取数据时间戳的一部分，

672
00:34:33,300 --> 00:34:34,660
这就是，先提取日期，

673
00:34:35,700 --> 00:34:40,960
然后将今天的日期作为字符串转换为日期类型。

674
00:34:41,570 --> 00:34:45,695
好的，再次，这些不同的系统有语法糖，

675
00:34:45,695 --> 00:34:46,930
它们是非标准的。

676
00:34:47,310 --> 00:34:48,700
在 Postgres 中，

677
00:34:48,960 --> 00:34:51,245
如果我试图给出字符串，它会抛出一个错误，

678
00:34:51,245 --> 00:34:52,175
因为它说它不能，

679
00:34:52,175 --> 00:34:54,530
EXTRACT 函数需要要在日期上操作，

680
00:34:54,530 --> 00:34:55,780
但你给了一个 varchar ，

681
00:34:56,190 --> 00:34:58,270
但我可以把这两个冒号加在最后，

682
00:34:58,740 --> 00:35:00,010
然后把 date 放在最后，

683
00:35:00,600 --> 00:35:04,460
然后，这将把它转换为日期类型。

684
00:35:05,320 --> 00:35:06,270
你能看到这吗，抱歉，

685
00:35:14,060 --> 00:35:15,370
让我这么做，是的，

686
00:35:18,090 --> 00:35:19,540
我知道这是不对的，抱歉，让我们再试一次。

687
00:35:22,690 --> 00:35:26,770
好的，所以这里，我可以给它一个字符串，

688
00:35:26,880 --> 00:35:28,535
然后我放上 ::date ，

689
00:35:28,535 --> 00:35:30,790
这就把它转换成了日期，

690
00:35:31,170 --> 00:35:34,880
但这只是在 Postgres 中，

691
00:35:35,940 --> 00:35:39,335
我不能在任何其他系统中这样做，除了 DuckDB ，

692
00:35:39,335 --> 00:35:41,465
因为它们遵循相同的标准。

693
00:35:41,465 --> 00:35:43,855
所以如果我去 MySQL ，

694
00:35:43,855 --> 00:35:44,670
尝试做同样的事情，

695
00:35:45,200 --> 00:35:45,960
不像那样。

696
00:35:46,400 --> 00:35:48,570
去 SQLite ，不像那样。

697
00:35:49,490 --> 00:35:51,570
去 Oracle ，不像那样。

698
00:35:51,920 --> 00:35:52,650
FROM DUAL ，

699
00:35:55,030 --> 00:35:56,000
不知道 DATE 是什么。

700
00:35:56,230 --> 00:35:59,120
这个 DuckDB 应该这样做，

701
00:35:59,680 --> 00:36:01,640
因为 DuckDB 遵循相同的语法。

702
00:36:02,320 --> 00:36:08,630
所以我们可以使用 EXTRACT 函数来提取当前日期，

703
00:36:08,630 --> 00:36:12,640
或者试着计算出从现在到年初有多少天。

704
00:36:13,020 --> 00:36:14,080
那么让我们从 Postgres 开始吧，

705
00:36:15,690 --> 00:36:18,580
所以事实证明， Postgres 的情况很简单，

706
00:36:19,790 --> 00:36:27,350
我们可以将今天的当前日期字符串转换为日期类型

707
00:36:27,970 --> 00:36:34,900
然后减去年初时的日期字符串，

708
00:36:35,070 --> 00:36:38,270
我们可以使用，我们想要，我们可以回到这里，

709
00:36:38,270 --> 00:36:40,870
使用 CURRENT_TIMESTAMP 或使用 NOW 函数，

710
00:36:42,060 --> 00:36:44,040
这应该会工作。

711
00:36:44,680 --> 00:36:48,660
所以获取今天，把它转换成日期，减去，

712
00:36:49,940 --> 00:36:53,040
获取今天的日期，然后减去年初的。

713
00:36:53,090 --> 00:36:55,680
我们得到 241 ，我认为这是正确的。

714
00:36:58,490 --> 00:37:03,510
现在让我们来尝试同样的事情，在 MySQL 中，

715
00:37:04,500 --> 00:37:06,605
因为它们没有 NOW 函数，

716
00:37:06,605 --> 00:37:08,350
所以我们将在转换时这样做，

717
00:37:09,330 --> 00:37:11,290
现在我们得到了一个奇怪的数字，我们得到了 729 ，

718
00:37:13,660 --> 00:37:13,950
那是什么，

719
00:37:16,100 --> 00:37:16,960
令人惊讶的是，

720
00:37:16,960 --> 00:37:19,350
YouTube 上的一个人在[]地方的评论中，

721
00:37:20,240 --> 00:37:21,000
告诉了我这是什么，

722
00:37:22,430 --> 00:37:23,140
这很奇怪，

723
00:37:23,140 --> 00:37:28,530
所以第一个数字是今天的当月减去一月，

724
00:37:28,910 --> 00:37:31,500
所以 8 减 1 等于 7 ，

725
00:37:32,500 --> 00:37:35,450
然后今天是 30 号，

726
00:37:36,160 --> 00:37:40,400
所以今天的日期减去 1 月 1 日，

727
00:37:40,690 --> 00:37:41,535
所以这是 29 ，

728
00:37:41,535 --> 00:37:42,740
你得到 729 ，

729
00:37:45,100 --> 00:37:46,370
这是错误的，我不能这么做。

730
00:37:48,330 --> 00:37:49,540
所以我们能做的是，

731
00:37:49,800 --> 00:37:54,870
我们可以，抱歉，抱歉，

732
00:37:56,500 --> 00:37:57,290
我们可以，

733
00:38:04,850 --> 00:38:05,340
我们到了，

734
00:38:06,200 --> 00:38:07,915
所以，我们现在要做的是，

735
00:38:07,915 --> 00:38:12,810
获取今天的日期和年初，

736
00:38:13,190 --> 00:38:14,640
将其转换为 UNIX_TIMESTAMP ，

737
00:38:15,410 --> 00:38:21,240
UNIX_TIMESTAMP 是自 Unix epoch 1970 年 1 月 1 日以来的秒数，

738
00:38:22,610 --> 00:38:27,620
所以我们现在将其转换为从 1970 年到今天的秒数，

739
00:38:28,150 --> 00:38:31,670
然后我们减去从 1 月 1 日以来的数字，

740
00:38:32,200 --> 00:38:36,650
再除以 60 秒乘以 60 分钟乘以 24 小时，

741
00:38:38,200 --> 00:38:39,060
我们得到二百四十一。

742
00:38:40,550 --> 00:38:42,660
所以，这是我最初的想法，

743
00:38:43,160 --> 00:38:48,870
然后发现 MySQL 中有一个 DATEDIFF 函数，

744
00:38:48,920 --> 00:38:49,620
你可以这么做，

745
00:38:51,420 --> 00:38:52,790
但是 Postgres 没有这个，

746
00:38:53,950 --> 00:38:54,975
DuckDB 没有这个，

747
00:38:54,975 --> 00:39:00,830
看看 Oracle 有没有这个， DUAL ，

748
00:39:00,910 --> 00:39:01,640
他们没有这个。

749
00:39:03,190 --> 00:39:04,850
好的，所以这是 MySQL 的东西。

750
00:39:05,550 --> 00:39:08,410
好的，现在让我们在 SQLite 中尝试，

751
00:39:08,970 --> 00:39:10,420
所以， SQLite 没有 DATEDIFF ，

752
00:39:11,310 --> 00:39:13,870
我们不能做在 Postgres 中的减法，

753
00:39:15,660 --> 00:39:18,050
我能想到的最好的解决方案是，

754
00:39:18,370 --> 00:39:23,450
将今天和年初的时间戳转换为儒略历，

755
00:39:23,980 --> 00:39:26,780
这是自 Julian Caesar 生日以来的天数，

756
00:39:26,950 --> 00:39:28,070
在公元前什么时候，

757
00:39:29,530 --> 00:39:33,680
你笑了，但直到上世纪 80 年代，很多银行都在用，

758
00:39:34,960 --> 00:39:36,440
然后你得到 241 ，

759
00:39:36,850 --> 00:39:40,960
但我们得到的是一个浮点数，

760
00:39:41,310 --> 00:39:44,020
所以我们可以将它转换为一个整数，然后我们得到 241 。

761
00:39:45,380 --> 00:39:48,340
我忘了如何在 Oracle 中做到这一点，

762
00:39:48,340 --> 00:39:49,200
我不在 Oracle 中做了。

763
00:39:51,320 --> 00:39:53,910
主要的观点是，这似乎是一件简单的事情，

764
00:39:54,080 --> 00:39:57,810
但所有这些时间戳的东西都有很大的不同。

765
00:39:59,120 --> 00:40:00,240
到目前为止，对此有什么问题吗？

766
00:40:06,970 --> 00:40:08,150
为什么想要一个小写函数？

767
00:40:14,230 --> 00:40:14,750
好问题。

768
00:40:15,860 --> 00:40:17,310
我的意思是，你可能需要它来清理数据，

769
00:40:19,100 --> 00:40:20,460
你可能需要它来做。

770
00:40:22,710 --> 00:40:23,500
是的，这是个好问题，

771
00:40:23,610 --> 00:40:25,180
保持标准，

772
00:40:26,260 --> 00:40:26,960
它可能会，

773
00:40:27,280 --> 00:40:28,035
并不一定非得如此，

774
00:40:28,035 --> 00:40:28,860
也可以在 WHERE 子句中，

775
00:40:28,860 --> 00:40:30,050
你也可以在 FROM 子句中使用它。

776
00:40:30,670 --> 00:40:33,590
所以如果我回到 MySQL ，

777
00:40:33,590 --> 00:40:41,340
SELECT * FROM students WHERE name = 'Tupac';

778
00:40:43,740 --> 00:40:45,400
student ，

779
00:40:45,720 --> 00:40:50,260
所以，也许我想在输出中这么做，

780
00:40:50,880 --> 00:40:51,880
得到一个这样的小写字母。

781
00:40:55,110 --> 00:40:55,900
是的，抱歉，是的。

782
00:41:10,300 --> 00:41:11,630
是的，所以她的问题是，

783
00:41:12,580 --> 00:41:16,640
为什么人们在他们的 SQL 中有所有这些奇怪的习语，

784
00:41:18,380 --> 00:41:21,085
在高级别上，他们似乎都在做同样的事情，

785
00:41:21,085 --> 00:41:22,800
但这是[一次性的]事情不同，

786
00:41:22,850 --> 00:41:23,920
这与他的问题有关，

787
00:41:23,920 --> 00:41:27,800
为什么这些不同的系统有这么多不同的细微差别，

788
00:41:28,390 --> 00:41:31,130
因为有人在编写，觉得它很酷，

789
00:41:31,600 --> 00:41:32,925
然后向他们的朋友们展示，

790
00:41:32,925 --> 00:41:33,740
是的，这很酷，

791
00:41:33,880 --> 00:41:35,385
所以双冒号和 Postgres ，

792
00:41:35,385 --> 00:41:36,120
我同意，这很酷，

793
00:41:36,120 --> 00:41:39,360
转换的事情，但他们只做这件事，

794
00:41:40,850 --> 00:41:42,570
DUAL 表，我不知道是什么。

795
00:41:47,720 --> 00:41:49,570
是的，那么再举一个例子，

796
00:41:49,570 --> 00:41:52,620
在 SQL 中有一条捷径，

797
00:41:53,000 --> 00:41:54,210
执行 SELECT * ，

798
00:41:54,560 --> 00:42:00,180
所以， SELECT * FROM student; 给你所有的 tuple ，

799
00:42:00,410 --> 00:42:02,890
但是在 Postgres 中，我认为它也在 SQL 标准中，

800
00:42:02,890 --> 00:42:05,100
我只需要写 TABLE 就可以了，

801
00:42:06,110 --> 00:42:11,470
在 MySQL 中，我可以这样做，这很酷，

802
00:42:12,270 --> 00:42:16,560
在 SQLite 中，不是这样，

803
00:42:17,220 --> 00:42:21,960
在 DuckDB 中，可以这样做，

804
00:42:21,960 --> 00:42:22,970
但他们也有另一个，

805
00:42:23,200 --> 00:42:26,490
我想你只需要 FETCH ，

806
00:42:26,750 --> 00:42:32,450
不是，或者是 FROM ，

807
00:42:32,920 --> 00:42:33,770
你可以这么做。

808
00:42:35,670 --> 00:42:37,355
所以他们都有自己奇怪的习语，

809
00:42:37,355 --> 00:42:40,940
我的意思是，其中一些事情东西基于客户的反馈，

810
00:42:40,940 --> 00:42:44,020
比如客户说，我需要在 json 上操作的函数，

811
00:42:44,040 --> 00:42:45,250
所以有人加了这个，

812
00:42:45,690 --> 00:42:51,175
而且很多时候，这些特性在它们出现在标准中之前就被添加了，

813
00:42:51,175 --> 00:42:53,430
json xml 就是一个很好的例子，

814
00:42:54,670 --> 00:42:56,640
这来自在 2006 年 SQL 标准，

815
00:42:56,640 --> 00:42:57,920
但有很多关系型数据库，

816
00:42:57,940 --> 00:43:00,980
在 2000 年早期已经有了 xml 的支持。

817
00:43:01,740 --> 00:43:02,690
所以发生的事情是，

818
00:43:02,690 --> 00:43:06,230
标准机构是一群陌生人，

819
00:43:06,230 --> 00:43:07,510
它是不同公司的人，

820
00:43:07,950 --> 00:43:09,095
所以，在 SQL 标准机构中，

821
00:43:09,095 --> 00:43:10,295
有来自 Oracle 的人，

822
00:43:10,295 --> 00:43:11,735
有来自 Sybase 的人，

823
00:43:11,735 --> 00:43:13,360
有来自 IBM 的人，

824
00:43:14,210 --> 00:43:15,870
然后他们出现在标准委员会，

825
00:43:16,100 --> 00:43:19,020
他们都试图获得他们拥有的任何东西，

826
00:43:19,070 --> 00:43:21,520
他们试图将其纳入标准，

827
00:43:21,960 --> 00:43:22,900
Oracle 可能会这么做，

828
00:43:24,210 --> 00:43:25,220
最好的例子是，最近的，

829
00:43:25,220 --> 00:43:29,770
Oracle 在 SQL 标准中得到了他们版本的属性图查询，

830
00:43:30,330 --> 00:43:33,010
他们基于他们的密码，这是 Neo4j ，

831
00:43:33,210 --> 00:43:36,910
现在是 SQL 标准中的 PGQ ，

832
00:43:37,560 --> 00:43:42,100
所以，他们的图形查询扩展获得了 SQL 标准，

833
00:43:42,180 --> 00:43:44,170
因为他们当时是唯一领先的。

834
00:43:44,280 --> 00:43:46,025
这就是这些东西在 SQL 标准中的显示方式，

835
00:43:46,025 --> 00:43:49,960
如果每个人都对如何做某事有相互竞争的想法，

836
00:43:50,160 --> 00:43:52,715
你最终会得到最小的公分母，或者可以尝试支持每个人的东西，

837
00:43:52,715 --> 00:43:55,870
但是，没有人确切地支持标准。

838
00:43:57,875 --> 00:43:59,200
我不是说这是一件好事，而是像，

839
00:43:59,900 --> 00:44:01,955
我们也生活在一个不同的时代，

840
00:44:01,955 --> 00:44:05,020
有这么多不同的数据库公司，

841
00:44:05,490 --> 00:44:09,280
但没有一家公司，我说它拥有市场，

842
00:44:09,300 --> 00:44:13,660
可以根据意愿让人屈服。

843
00:44:13,740 --> 00:44:18,425
所以，我之前说过，在 1980 年代之前， IBM 是大公司，

844
00:44:18,425 --> 00:44:20,260
IBM 是那个计算公司，

845
00:44:20,490 --> 00:44:23,890
所以无论 IBM 说什么，这都被认为是事实上的标准，

846
00:44:24,540 --> 00:44:27,350
这就是我们今天使用 SQL 的原因。

847
00:44:28,130 --> 00:44:29,640
但是现在没有一家公司像这样，

848
00:44:29,930 --> 00:44:35,370
最接近的事情是 Google 推出他们的 SQL 标准，名为 ZetaSQL ，

849
00:44:35,510 --> 00:44:36,520
它在内部被称为其他东西，

850
00:44:36,520 --> 00:44:41,970
但他们开放了一个解析器以及语法文件和规范，

851
00:44:42,140 --> 00:44:43,920
用于他们的 SQL 版本，

852
00:44:44,750 --> 00:44:45,720
没有人使用它，

853
00:44:46,040 --> 00:44:47,190
而且谷歌很大，

854
00:44:48,090 --> 00:44:49,895
你今天能得到的最接近的是 Postgres ，

855
00:44:49,895 --> 00:44:50,990
很多这样的数据库公司，

856
00:44:50,990 --> 00:44:51,770
当你开始时，

857
00:44:51,770 --> 00:44:53,830
不是从头开始构建语法文件，

858
00:44:54,060 --> 00:44:55,400
而是使用 Postgres 的，

859
00:44:55,400 --> 00:44:57,520
将其修改并注入到系统中，

860
00:44:57,750 --> 00:44:58,660
我们就是这么做的，

861
00:44:59,250 --> 00:45:01,540
而 DuckDB 拿走了我们的代码，他们把它放到 DuckDB 中，

862
00:45:02,070 --> 00:45:05,020
这一堆系统是基于 Postgres 语法的，

863
00:45:05,040 --> 00:45:06,910
因为这个开放源码，他们使用它，

864
00:45:06,930 --> 00:45:09,190
这是你今天最接近通用标准的地方。

865
00:45:09,620 --> 00:45:13,410
再说一次，我刚才向你们展示了 FROM 在 DuckDB 中，

866
00:45:13,640 --> 00:45:17,550
但那不在 Postgres 中，

867
00:45:18,700 --> 00:45:19,410
他们对其进行了调整。

868
00:45:22,190 --> 00:45:22,590
是的。

869
00:45:27,580 --> 00:45:28,215
他的问题是，

870
00:45:28,215 --> 00:45:30,050
如果没有人遵循标准，那么有一个标准有什么意义？

871
00:45:31,860 --> 00:45:34,125
我是说，这里有限速，但是每个人开车都会超过它，

872
00:45:34,125 --> 00:45:34,460
就像，

873
00:45:39,180 --> 00:45:41,770
我向你展示了许多 SELECT 语句，比如，

874
00:45:42,780 --> 00:45:45,020
这在不同的系统之间略有不同，

875
00:45:45,280 --> 00:45:47,130
但你知道它在做什么，

876
00:45:47,130 --> 00:45:49,640
不同系统的细微差别，

877
00:45:49,810 --> 00:45:52,700
是的，你可能必须去阅读文档或询问 ChatGPT 要做什么，

878
00:45:52,930 --> 00:45:57,300
但就像在高级别上一样，这些概念是相同的，

879
00:46:00,370 --> 00:46:04,310
只是你知道特性，每个系统都将是不同的。

880
00:46:06,550 --> 00:46:07,665
Snowflake 是一个很好的[异类]，

881
00:46:07,665 --> 00:46:09,900
Snowflake 是在 2013 年从头开始的，

882
00:46:09,900 --> 00:46:10,500
他们没有选择 Postgres ，

883
00:46:10,500 --> 00:46:14,120
他们说，他们想出了自己的语法， Snowflake 语法，

884
00:46:14,140 --> 00:46:15,800
有其他系统不支持的东西。

885
00:46:16,960 --> 00:46:19,425
如果我今天从头开始构建一个新的数据库系统，

886
00:46:19,425 --> 00:46:21,420
我不会像 Snowflake 一样做，

887
00:46:21,420 --> 00:46:22,280
那是一个不同的时间，

888
00:46:22,570 --> 00:46:23,720
我会从 Postgres 开始，

889
00:46:24,240 --> 00:46:26,210
然后像 DuckDB 那样对其进行扩展。

890
00:46:30,180 --> 00:46:33,860
好的，继续前进，因为还有很多事情要做，

891
00:46:36,130 --> 00:46:39,020
为了节省时间，我将跳过输出重定向，

892
00:46:41,070 --> 00:46:43,150
因为你在家庭作业中不会需要它，

893
00:46:44,040 --> 00:46:45,610
所以让我们跳到窗口函数。

894
00:46:47,660 --> 00:46:49,890
好的，在我们展示聚合之前，

895
00:46:51,110 --> 00:46:58,990
他们计算整个输入集的一次计算，

896
00:46:58,990 --> 00:47:07,030
对于输入到聚合函数的关系，

897
00:47:07,200 --> 00:47:08,440
那个你在操作的 FROM 子句（的函数），

898
00:47:09,090 --> 00:47:10,730
但也有一些时候，

899
00:47:10,730 --> 00:47:13,480
你可能需要进行所谓的滑动计算，

900
00:47:13,860 --> 00:47:17,335
想象一下滚动计票，

901
00:47:17,335 --> 00:47:19,135
当你从一个 tuple 到下一个，

902
00:47:19,135 --> 00:47:20,100
在你进行扫描时，

903
00:47:20,420 --> 00:47:23,010
你希望更新一些聚合函数，

904
00:47:23,660 --> 00:47:28,080
对于从 SELECT 语句输出的每个单独的 tuple ，

905
00:47:28,430 --> 00:47:34,080
聚合是处理 tuple 时的某种快照，

906
00:47:34,080 --> 00:47:35,520
它就像一个聚合函数，

907
00:47:35,520 --> 00:47:40,630
你不会将它们分组到单个最终输出中，

908
00:47:40,770 --> 00:47:44,290
对于每个 tuple ，它对该聚合进行自己的计算。

909
00:47:45,330 --> 00:47:46,220
所以，按照这种方式，

910
00:47:46,220 --> 00:47:48,670
你会在这里有一个函数，

911
00:47:48,990 --> 00:47:50,105
这将是你的所有聚合函数，

912
00:47:50,105 --> 00:47:53,290
Min Max Count Avg ，正如我们之前看到的，

913
00:47:54,000 --> 00:47:55,240
以及一些额外的函数，

914
00:47:55,800 --> 00:48:02,920
然后你将指定要计算此计算的范围或范围的类型，

915
00:48:03,360 --> 00:48:06,920
基本上是如何分割数据并对它进行分类。

916
00:48:09,020 --> 00:48:10,860
让我们来看一些这样的例子，

917
00:48:11,450 --> 00:48:14,190
我可以拥有我以前拥有的所有聚合函数，

918
00:48:16,530 --> 00:48:17,690
Min Max Count ，等等，

919
00:48:17,690 --> 00:48:18,950
但是我有这些额外的函数，

920
00:48:18,950 --> 00:48:23,830
比如 ROW_NUMBER ，告诉我 tuple 在输出中的第几行，

921
00:48:24,180 --> 00:48:26,440
还有 RANK ，如果我对它们排序，

922
00:48:26,670 --> 00:48:30,610
所以，如果我有一个 ORDER BY 子句，对学生按 gpa 排序，

923
00:48:30,900 --> 00:48:33,670
我可以使用 RANK 函数告诉你所在的位置，

924
00:48:36,150 --> 00:48:37,880
你不能使用聚合函数来做到这一点，

925
00:48:37,880 --> 00:48:40,060
因为有些东西会崩溃。

926
00:48:41,520 --> 00:48:43,070
所以，在本例中，

927
00:48:43,070 --> 00:48:47,110
我可以做 SELECT *, ROW_NUMBER() OVER ，然后是空括号，

928
00:48:47,730 --> 00:48:48,910
因为我没有对其进行分区，

929
00:48:49,080 --> 00:48:50,390
这会给我这样的输出，

930
00:48:50,390 --> 00:48:51,220
它会告诉我，

931
00:48:51,900 --> 00:48:53,300
对于我所有的 tuple ，

932
00:48:53,740 --> 00:48:57,360
我在列表中的位置是什么，

933
00:49:02,170 --> 00:49:03,270
如果你有 OVER 子句，

934
00:49:03,270 --> 00:49:07,610
你可以指定希望如何将 tuple 分组在一起，

935
00:49:07,750 --> 00:49:08,870
在计算窗口函数时，

936
00:49:09,370 --> 00:49:14,480
然后可以使用 PARTITION BY ，就像 GROUP BY ，来说明如何对它们进行分组，

937
00:49:15,000 --> 00:49:16,550
所以，对于这里的查询，

938
00:49:16,550 --> 00:49:19,060
我们从 enrolled 表中 SELECT cid, sid ，

939
00:49:19,530 --> 00:49:25,030
我想要得到每个学生记录在 enrolled 表中的 ROW_NUMBER ，

940
00:49:25,860 --> 00:49:28,400
然后我想把它按 cid 划分，

941
00:49:28,720 --> 00:49:29,970
这样我会得到这样的输出，

942
00:49:29,970 --> 00:49:32,480
对于每个课程，它会告诉我，

943
00:49:33,700 --> 00:49:37,850
对于每个 sid ，他们在那个组中处于什么位置，

944
00:49:39,130 --> 00:49:40,670
像这样的[课程]。

945
00:49:42,810 --> 00:49:44,045
然后，如果你有一个 ORDER BY 子句，

946
00:49:44,045 --> 00:49:46,720
那么你就可以控制 tuple 如何排序，

947
00:49:46,770 --> 00:49:50,595
在分区内或窗口内，

948
00:49:50,595 --> 00:49:51,410
所以在这种情况下，

949
00:49:51,700 --> 00:49:54,130
现在我对学生进行排序，

950
00:49:55,560 --> 00:49:57,230
在 enrolled 表上，通过 cid （进行排序）。

951
00:49:58,890 --> 00:50:00,320
这里有一个更复杂的例子，

952
00:50:00,320 --> 00:50:04,510
我们想找出每门课成绩第二高的学生。

953
00:50:05,420 --> 00:50:07,015
对于这里的这个，

954
00:50:07,015 --> 00:50:09,000
我们将有一个嵌套的查询，我们稍后会讨论它，

955
00:50:09,260 --> 00:50:13,210
但基本上我有一个 SELECT 语句，它有一个 FROM 子句，

956
00:50:13,210 --> 00:50:16,260
在那个 FROM 子句中，我还有另一个查询，

957
00:50:17,080 --> 00:50:19,315
在这个内部查询中，

958
00:50:19,315 --> 00:50:24,210
我在 enrolled 表上进行查找，

959
00:50:24,290 --> 00:50:26,395
然后外部查询可以进行过滤，

960
00:50:26,395 --> 00:50:28,830
根据这个嵌套查询的输出，

961
00:50:29,030 --> 00:50:30,600
我会在稍后讲到嵌套查询。

962
00:50:31,860 --> 00:50:32,945
所以我们要做的第一件事是，

963
00:50:32,945 --> 00:50:35,080
按照 cid 对这 tuple 进行分组，

964
00:50:35,920 --> 00:50:37,920
然后按成绩排序，

965
00:50:38,150 --> 00:50:39,210
然后我们就会得到排名，

966
00:50:39,410 --> 00:50:45,040
他们在成绩列表中的位置是什么，

967
00:50:45,040 --> 00:50:46,075
然后在我的 WHERE 子句中，

968
00:50:46,075 --> 00:50:54,930
我现在可以引用窗口函数对列的计算。

969
00:50:56,000 --> 00:50:57,150
对此有什么问题吗？

970
00:51:05,940 --> 00:51:06,500
问题是，

971
00:51:06,500 --> 00:51:08,470
我能用 GROUP BY 制作一个窗口函数吗，

972
00:51:13,400 --> 00:51:14,760
让我们试一试你说的。

973
00:51:17,180 --> 00:51:18,000
好的，那么。

974
00:51:25,870 --> 00:51:31,300
好的，在 Postgres 中，

975
00:51:31,300 --> 00:51:33,870
同样， SELECT FROM enrolled 表，

976
00:51:34,190 --> 00:51:38,700
然后我们获得每个学生出现的 ROW_NUMBER 。

977
00:51:41,490 --> 00:51:44,260
然后第二个例子是，

978
00:51:45,120 --> 00:51:47,590
cid sid ，然后是 ROW_NUMBER ，

979
00:51:47,820 --> 00:51:49,990
我们将按 cid 对其进行划分，

980
00:51:50,370 --> 00:51:54,970
然后，我们将按 cid 对它们和输出进行排序，

981
00:51:55,640 --> 00:51:57,820
所以，这个例子我们看到，

982
00:51:58,410 --> 00:52:01,330
对于每门课， 15-445, 721, 826 ，

983
00:52:01,980 --> 00:52:03,520
这是注册的学生，

984
00:52:03,630 --> 00:52:06,220
然后这是他们在每一组中的位置。

985
00:52:08,740 --> 00:52:10,280
然后我的最后一个例子是这样的，

986
00:52:10,600 --> 00:52:13,010
这就是你问的，是否可以使用一个 GROUP BY ，

987
00:52:14,960 --> 00:52:15,680
我们现在又来了，

988
00:52:15,680 --> 00:52:17,645
这样我就能拿到第一个，

989
00:52:17,645 --> 00:52:22,540
内部查询将为我获取每条记录的排名位置，

990
00:52:22,860 --> 00:52:25,030
你在排序输出中所处的排名，

991
00:52:26,460 --> 00:52:31,215
让我先删除这里的这一部分，

992
00:52:31,215 --> 00:52:35,540
下面是 SELECT RANK 的内部查询的输出，

993
00:52:35,920 --> 00:52:37,400
所以对于每门课程，

994
00:52:37,900 --> 00:52:41,780
我都会拿到分数，我会按分数排序，

995
00:52:42,010 --> 00:52:44,030
然后，排名就是他们所处的位置，

996
00:52:44,440 --> 00:52:48,000
在成绩列表中，

997
00:52:48,620 --> 00:52:49,930
rank 可以有重复的，

998
00:52:49,930 --> 00:52:52,630
如果我在这里插入另一条记录，

999
00:52:52,630 --> 00:52:56,890
INSERT INTO enrolled VALUES ，

1000
00:52:57,420 --> 00:53:04,350
所以我们需要一个 sid ，我们做 tupac 所使用的，

1001
00:53:07,540 --> 00:53:11,480
VALUES ， cid 是 15-721 ，

1002
00:53:12,010 --> 00:53:17,200
他获得，给他一个 A ，他是[]。

1003
00:53:23,290 --> 00:53:24,080
我创建的在哪，

1004
00:53:25,760 --> 00:53:27,630
也许是按 rank 排序，

1005
00:53:28,410 --> 00:53:40,200
好吧，那把分区破坏了，抱歉。

1006
00:53:40,200 --> 00:53:43,120
所以，这里我们做的是，

1007
00:53:44,250 --> 00:53:48,370
每一门课程，我们获得分数，然后按 rank 排序，

1008
00:53:48,630 --> 00:53:52,210
我们在这里插入了这条记录 Tupac ，给了他 A ，

1009
00:53:52,230 --> 00:53:55,280
但是这里还有另一个学生在同一门课程中得到 A ，

1010
00:53:55,510 --> 00:53:57,710
所以他们都有相同的排名位置 1 ，

1011
00:53:58,400 --> 00:54:00,450
然后，对于拿到 C 的学生，

1012
00:54:00,710 --> 00:54:02,190
他们的排名位置是 3 ，

1013
00:54:02,330 --> 00:54:04,290
所以你可以有重复的排名，行号则不会。

1014
00:54:07,240 --> 00:54:08,960
所以，是的，你打算做什么，

1015
00:54:09,130 --> 00:54:10,010
rank 分组，

1016
00:54:11,940 --> 00:54:12,340
哪里，

1017
00:54:15,760 --> 00:54:17,390
在内部查询，还是什么，抱歉。

1018
00:54:24,300 --> 00:54:24,830
问题是，

1019
00:54:24,830 --> 00:54:26,620
是否可以使用 GROUP BY 重新创建相同的查询，

1020
00:54:29,200 --> 00:54:30,830
你不会得到 rank ，

1021
00:54:32,260 --> 00:54:34,740
因为你不能得到我的排序位置是什么，

1022
00:54:34,740 --> 00:54:41,640
在 SQL 中没有这方面的概念，

1023
00:54:41,870 --> 00:54:44,700
所以 ROW_NUMBER 很有趣，因为它，

1024
00:54:46,620 --> 00:54:47,930
让我们来做 ROW_NUMBER ，

1025
00:54:56,260 --> 00:54:58,000
换个地方，换成 ROW_NUMBER ，

1026
00:54:58,000 --> 00:54:59,070
ROW_NUMBER ，

1027
00:55:00,990 --> 00:55:02,410
所以 ROW_NUMBER 很有趣，因为，

1028
00:55:03,060 --> 00:55:05,470
它叫做 rank ，但相信我，它是 row_number ，

1029
00:55:06,090 --> 00:55:08,930
这是因为它是袋子代数，

1030
00:55:08,930 --> 00:55:11,020
在这些关系中没有排序顺序，

1031
00:55:11,190 --> 00:55:12,400
这是一个奇怪的概念，

1032
00:55:12,810 --> 00:55:13,940
我们对编程的思考是，

1033
00:55:13,940 --> 00:55:14,480
你在那里是什么意思，

1034
00:55:14,480 --> 00:55:15,400
这里没有排序，

1035
00:55:15,600 --> 00:55:17,720
因为我们习惯于在 x86 下编程，

1036
00:55:17,720 --> 00:55:19,625
那里有排序，

1037
00:55:19,625 --> 00:55:20,770
内存操作是如何发生的，

1038
00:55:21,240 --> 00:55:22,415
这里没有任何这些，

1039
00:55:22,415 --> 00:55:23,380
任何东西都可以是无序的，

1040
00:55:23,730 --> 00:55:27,770
所以如果没有窗口函数，你就不能得到 row_number ，

1041
00:55:27,770 --> 00:55:29,315
因为没有办法说，

1042
00:55:29,315 --> 00:55:32,980
我在我的输出中的这个位置，

1043
00:55:35,100 --> 00:55:36,620
Oracle 确实有 row_number ，

1044
00:55:36,620 --> 00:55:37,445
他们对你隐藏了，

1045
00:55:37,445 --> 00:55:41,040
你不能得到它，但它只是 Oracle 的事情。

1046
00:55:42,710 --> 00:55:45,090
所以，窗函数允许你，

1047
00:55:45,170 --> 00:55:47,520
对平均值和所有其他聚合进行条件调整，

1048
00:55:47,630 --> 00:55:50,850
它允许你获得事物的顺序，

1049
00:55:50,930 --> 00:55:52,650
以一种你不能以其他方式做到的方式。

1050
00:56:03,310 --> 00:56:04,740
我应该在前面展示了嵌套查询，

1051
00:56:04,740 --> 00:56:06,410
但只是展示更多的细节。

1052
00:56:06,730 --> 00:56:09,200
所以嵌套查询是一个非常强大的概念，

1053
00:56:09,700 --> 00:56:10,940
有时称为子查询，

1054
00:56:11,080 --> 00:56:14,355
它允许你在查询内有一个查询，

1055
00:56:14,355 --> 00:56:15,690
在查询内，

1056
00:56:15,690 --> 00:56:18,620
你可以在总体调用查询内有多个查询，

1057
00:56:19,220 --> 00:56:19,970
你需要这个，

1058
00:56:19,970 --> 00:56:22,000
因为你想要表达某些计算，

1059
00:56:22,890 --> 00:56:25,720
如果没有这些嵌套查询，就很难表达某些计算，

1060
00:56:25,980 --> 00:56:28,130
除非取出数据，进行一些计算，

1061
00:56:28,130 --> 00:56:29,830
然后将其放回数据库系统中，

1062
00:56:30,150 --> 00:56:31,655
所以，它允许我们把这些东西放在一起，

1063
00:56:31,655 --> 00:56:34,870
创造出更复杂的逻辑，

1064
00:56:35,190 --> 00:56:37,060
而不是其他方式。

1065
00:56:37,800 --> 00:56:41,420
这些内部查询几乎可以出现在 SELECT []中的任何地方，

1066
00:56:41,420 --> 00:56:42,940
实际上，可以出现在任何查询，

1067
00:56:43,170 --> 00:56:45,850
比如，你可以在 SELECT 输出， FROM 子句， WHERE 子句，

1068
00:56:46,230 --> 00:56:49,090
你可以放入 UPDATE 查询和 DELETE 查询，

1069
00:56:50,390 --> 00:56:52,950
现在，它们可以引用你自己的查询中的所有表，

1070
00:56:53,420 --> 00:56:54,810
这是一个非常强大的[构造]。

1071
00:56:55,680 --> 00:56:56,985
所以基本的想法是这样的，

1072
00:56:56,985 --> 00:56:59,270
这里，我们做 SELECT FROM student 表，

1073
00:56:59,800 --> 00:57:03,440
然后我想要获取学生的姓名，

1074
00:57:03,460 --> 00:57:05,420
他至少注册了一门课程。

1075
00:57:05,740 --> 00:57:07,020
所以你可以想到，

1076
00:57:07,020 --> 00:57:09,090
这是上面部分的 SELECT ，

1077
00:57:09,090 --> 00:57:10,100
称为外部查询，

1078
00:57:10,330 --> 00:57:12,650
然后这个内部部分，我们称之为内部查询。

1079
00:57:13,670 --> 00:57:18,860
所以，众所周知，数据库系统很难优化嵌套查询，

1080
00:57:21,070 --> 00:57:23,600
因为你认为执行此查询最愚蠢的方法是，

1081
00:57:23,920 --> 00:57:27,770
对于我的 student 表中的每个 tuple ，重新运行这个东西，

1082
00:57:29,040 --> 00:57:31,630
获取所有 sid 的列表，然后计算 IN ，

1083
00:57:32,510 --> 00:57:33,985
真正执行此操作的方法是，

1084
00:57:33,985 --> 00:57:36,480
这只是 JOIN ，对于这里的例子，

1085
00:57:38,140 --> 00:57:39,145
这个很容易做，

1086
00:57:39,145 --> 00:57:43,290
因为，你在寻找这个东西来匹配这里的东西，

1087
00:57:43,580 --> 00:57:46,020
所以，你可以将其转换为[质量]谓词，

1088
00:57:46,340 --> 00:57:47,280
事情会变得更加复杂，

1089
00:57:47,510 --> 00:57:51,180
当内部查询和外部查询之间存在非平凡的关系时，

1090
00:57:51,380 --> 00:57:53,965
我们会在本学期晚些时候讨论这个，

1091
00:57:53,965 --> 00:58:00,110
但是，这是数据库系统中最难的部分，

1092
00:58:00,490 --> 00:58:05,450
唯一正确嵌套查询的系统是名为 Umbra 的系统，

1093
00:58:05,800 --> 00:58:08,810
这是德国的一个学术系统，

1094
00:58:10,450 --> 00:58:12,350
DuckDB 现在做得很正确，

1095
00:58:12,520 --> 00:58:13,220
原因有两个，

1096
00:58:13,270 --> 00:58:16,130
一是因为他们复制了 Umbra 所做的，

1097
00:58:16,180 --> 00:58:18,380
它在论文上，并不是说他们偷走了创意，

1098
00:58:19,180 --> 00:58:21,525
然后我们上个学期 721 课程之后也给他们发了补丁，

1099
00:58:21,525 --> 00:58:22,580
所以我们为他们修复了它，

1100
00:58:22,960 --> 00:58:26,450
他们可以正确地执行其中一些嵌套查询，

1101
00:58:27,640 --> 00:58:29,390
DuckDB 可能是对这一点的最好模仿，

1102
00:58:29,530 --> 00:58:32,120
很多时候，有一堆启发式的 hack ，

1103
00:58:32,410 --> 00:58:33,500
同样，我们将在稍后讨论这个问题。

1104
00:58:34,910 --> 00:58:35,970
MySQL 总是最差的，

1105
00:58:36,050 --> 00:58:37,080
不过，情况已经好多了。

1106
00:58:38,510 --> 00:58:40,720
所以这里有一个类似这样的查询，

1107
00:58:40,720 --> 00:58:43,470
我们想要得到在 15-445 注册的学生的名字，

1108
00:58:43,760 --> 00:58:45,180
所以我们有一个外部查询，

1109
00:58:45,530 --> 00:58:47,670
我们说我们想要从学生表中获得名字，

1110
00:58:48,050 --> 00:58:49,375
然后我们想要这个 WHERE 子句，

1111
00:58:49,375 --> 00:58:50,610
我们想要指定一个逻辑，

1112
00:58:50,810 --> 00:58:55,440
它会让我们得到参加 445 课程的那组人的 sid ，

1113
00:58:55,610 --> 00:58:56,815
所以这是一种思考方式，

1114
00:58:56,815 --> 00:58:57,955
你想要如何实际构建它，

1115
00:58:57,955 --> 00:58:58,645
从外部查询开始，

1116
00:58:58,645 --> 00:59:01,800
你希望输出的总体计算是什么，

1117
00:59:02,000 --> 00:59:05,040
然后得到内部部分单独需要的是什么。

1118
00:59:05,650 --> 00:59:06,435
在本例中，

1119
00:59:06,435 --> 00:59:10,610
我们可以将这里的英语部分转换为这样的查询，

1120
00:59:10,990 --> 00:59:12,530
但现在我们需要引用它，

1121
00:59:12,880 --> 00:59:15,260
或执行我们想要的检查，

1122
00:59:15,520 --> 00:59:16,940
在外部查询的 WHERE 子句中，

1123
00:59:17,290 --> 00:59:19,850
并使用之前的 IN 子句。

1124
00:59:21,560 --> 00:59:22,560
所以在这个例子中，

1125
00:59:23,360 --> 00:59:25,800
现在我们看到这个 sid ，

1126
00:59:26,640 --> 00:59:28,230
在外部查询中的 WHERE 子句中，

1127
00:59:28,230 --> 00:59:30,770
它引用外部查询中的 sid ，

1128
00:59:30,940 --> 00:59:32,810
但第二个在内部查询中的 sid ，

1129
00:59:32,890 --> 00:59:36,260
引用 enrolled 表中的 sid 。

1130
00:59:36,840 --> 00:59:39,930
所以，数据库系统中的解析器足够智能，

1131
00:59:39,930 --> 00:59:43,280
能够识别列被引用的上下文，

1132
00:59:43,360 --> 00:59:46,190
从而知道你正在查看的是哪个表，

1133
00:59:46,780 --> 00:59:48,495
在它不知道的情况下，

1134
00:59:48,495 --> 00:59:50,540
两个事物具有相同名称，

1135
00:59:50,650 --> 00:59:51,495
它将抛出一个错误，

1136
00:59:51,495 --> 00:59:56,240
并使你限定列所在的表名。

1137
00:59:58,820 --> 01:00:01,500
所以，你可以通过多种不同的方式与嵌套查询进行交互，

1138
01:00:01,940 --> 01:00:03,270
你可以设置 WHERE 子句，

1139
01:00:03,650 --> 01:00:06,630
你可以有 ALL 命令或 ALL 操作符，

1140
01:00:06,860 --> 01:00:10,650
嵌套查询中的每一行都必须满足某种约束，

1141
01:00:11,000 --> 01:00:11,730
你可以有 ANY ，

1142
01:00:12,500 --> 01:00:15,910
或者有时称为 SOME ，它是别名， SOME ，

1143
01:00:16,050 --> 01:00:19,750
你可以说至少有一行与我的子查询匹配，

1144
01:00:20,190 --> 01:00:22,160
IN 子句是我之前展示过的，

1145
01:00:22,160 --> 01:00:24,310
它等同于 ANY ，

1146
01:00:24,810 --> 01:00:25,580
然后是 EXISTS ，

1147
01:00:25,580 --> 01:00:27,200
意思是我想要找到，

1148
01:00:27,200 --> 01:00:29,590
我知道至少有一个匹配的东西，

1149
01:00:29,910 --> 01:00:31,775
抱歉，只有一行返回，

1150
01:00:31,775 --> 01:00:33,040
但我并不关心里面有什么。

1151
01:00:35,300 --> 01:00:37,690
所以我可以重写我之前的例子，

1152
01:00:37,690 --> 01:00:39,870
不是使用 IN ，我可以使用 ANY ，

1153
01:00:40,040 --> 01:00:41,280
它被认为是等价的。

1154
01:00:42,590 --> 01:00:44,005
所以，我们可以很快地展示，

1155
01:00:44,005 --> 01:00:46,410
Postgres 是如何为此选择不同的计划的，

1156
01:00:46,970 --> 01:00:48,510
你可以看到实际它是如何执行的。

1157
01:00:57,510 --> 01:00:58,510
好的，这是我们的查询，

1158
01:01:00,010 --> 01:01:01,490
我们有 RZA 和 Tupac 选择了课程，

1159
01:01:02,770 --> 01:01:03,735
所以在 SQL 中，

1160
01:01:03,735 --> 01:01:05,660
你可以把这个 EXPLAIN 关键字放在它前面，

1161
01:01:06,070 --> 01:01:07,040
放在任何查询前面，

1162
01:01:07,480 --> 01:01:08,630
它会执行，

1163
01:01:08,860 --> 01:01:09,975
如果系统支持它，

1164
01:01:09,975 --> 01:01:11,690
它会返回查询计划，

1165
01:01:11,830 --> 01:01:15,230
告诉你它会执行什么操作，

1166
01:01:15,340 --> 01:01:17,930
如果它试图执行这个东西。

1167
01:01:19,510 --> 01:01:20,295
所以当我们运行它时，

1168
01:01:20,295 --> 01:01:21,260
我们会得到类似这样的东西，

1169
01:01:21,670 --> 01:01:24,710
它会告诉我们基本上是一个树形结构，

1170
01:01:25,060 --> 01:01:26,505
所以这些是叶节点，

1171
01:01:26,505 --> 01:01:28,160
然后它建立了这个最终输出，

1172
01:01:28,360 --> 01:01:29,480
所以这告诉我们，

1173
01:01:29,890 --> 01:01:31,940
Postgres 想要对 enrolled 表进行强制扫描，

1174
01:01:32,440 --> 01:01:33,620
然后它会对它进行散列，

1175
01:01:33,850 --> 01:01:35,220
因为它在那里进行散列，

1176
01:01:35,220 --> 01:01:36,920
我们稍后会讨论什么是散列，

1177
01:01:37,240 --> 01:01:39,800
然后扫描 student 表，

1178
01:01:40,210 --> 01:01:42,800
然后通过匹配 sid ，

1179
01:01:44,890 --> 01:01:46,430
sid 和 enrolled 的 sid 。

1180
01:01:46,750 --> 01:01:48,060
所以 Postgres 足够聪明，

1181
01:01:48,060 --> 01:01:51,635
转换这个嵌套查询到 JOIN ，

1182
01:01:51,635 --> 01:01:53,890
这始终是执行某些操作的最快方式，

1183
01:01:54,540 --> 01:01:55,780
当你拥有这些类型的引用时。

1184
01:01:57,010 --> 01:01:58,670
我们可以在 MySQL 中尝试相同的操作，

1185
01:02:06,410 --> 01:02:08,430
但你得到，他们解释的输出很糟糕，

1186
01:02:10,370 --> 01:02:11,250
有一种方法可以得到，

1187
01:02:12,740 --> 01:02:13,690
我忘记了语法，

1188
01:02:13,690 --> 01:02:15,570
你必须放入一个 EXTENDED 或类似的东西，

1189
01:02:17,170 --> 01:02:18,345
我忘记了如何在 MySQL 中这样做，

1190
01:02:18,345 --> 01:02:20,120
有一种方法可以让事情变得更好。

1191
01:02:22,200 --> 01:02:24,520
在 SQLite 中，我不认为你可以做到这个，

1192
01:02:25,170 --> 01:02:25,930
你可以做到，

1193
01:02:32,165 --> 01:02:32,470
那是什么，

1194
01:02:38,370 --> 01:02:40,060
好的， SQLite ，

1195
01:02:43,660 --> 01:02:44,930
他们不喜欢 SELECT 语句，

1196
01:02:48,640 --> 01:02:49,460
这是令人惊讶的，

1197
01:02:49,720 --> 01:02:50,540
为什么这不管用。

1198
01:02:50,920 --> 01:02:51,920
看看 DuckDB 是否能做到这个，

1199
01:02:53,550 --> 01:02:54,310
它给出输出，

1200
01:02:54,420 --> 01:02:55,510
DuckDB 有很漂亮的，

1201
01:02:57,470 --> 01:02:59,040
它们给你漂亮的树，

1202
01:03:04,040 --> 01:03:05,220
你们很容易被逗乐，

1203
01:03:07,340 --> 01:03:09,690
这给你留下了深刻的印象， unicode 输出，

1204
01:03:10,070 --> 01:03:10,710
我的天，

1205
01:03:12,560 --> 01:03:15,570
但是，是的，它你展示了什么是物理计划。

1206
01:03:17,390 --> 01:03:20,370
然后，我们可以在 Oracle 上尝试，

1207
01:03:22,640 --> 01:03:23,970
好的，有正确的输出，

1208
01:03:27,710 --> 01:03:30,190
好吧，我们其他时间再看这个，

1209
01:03:30,190 --> 01:03:33,805
获得 Oracle 和 SQL Server 的计划是一个巨大的痛苦。

1210
01:03:33,805 --> 01:03:35,160
但我对此感到惊讶，

1211
01:03:36,870 --> 01:03:38,020
SQLLite 不支持这个，

1212
01:03:44,510 --> 01:03:45,600
我不会现场调试，

1213
01:03:48,150 --> 01:03:49,450
我不知道它为什么不喜欢那样，

1214
01:03:49,560 --> 01:03:50,290
让我们试试 IN ，

1215
01:03:55,030 --> 01:03:55,710
啊，来了，

1216
01:03:55,710 --> 01:03:56,960
他们不喜欢 ANY ，喜欢 IN 。

1217
01:03:57,520 --> 01:03:59,205
好的，在 SQLite 中，

1218
01:03:59,205 --> 01:04:00,050
如果我运行 EXPLAIN ，

1219
01:04:04,670 --> 01:04:05,310
我得到这个，

1220
01:04:08,910 --> 01:04:10,160
所以， SQLite 所做的方式，

1221
01:04:10,160 --> 01:04:12,780
是这样的，

1222
01:04:15,230 --> 01:04:16,585
它处理查询计划的方式是，

1223
01:04:16,585 --> 01:04:21,115
将查询计划转换为自己的 DSL 操作码，

1224
01:04:21,115 --> 01:04:24,000
它有自己的虚拟机来运行操作码，

1225
01:04:24,290 --> 01:04:25,150
就像是 JVM ，

1226
01:04:25,150 --> 01:04:27,390
你获取 Java 代码，将其转换为 Java 字节码，

1227
01:04:27,500 --> 01:04:29,640
然后 JVM 执行它或解释它，

1228
01:04:29,840 --> 01:04:30,900
这就是 SQLite 所做的。

1229
01:04:32,300 --> 01:04:35,170
好的，我们将在本学期晚些时候讨论查询编译。

1230
01:04:36,930 --> 01:04:38,530
所以你把 EXPLAIN PLAN,

1231
01:04:41,090 --> 01:04:43,230
PLAN ， EXTENDED ，

1232
01:04:44,280 --> 01:04:46,300
有一些语法可以获得真正的计划，

1233
01:04:46,320 --> 01:04:47,050
相信我，它就在那里。

1234
01:04:47,070 --> 01:04:47,560
好的，

1235
01:04:51,390 --> 01:04:54,100
所以，是的，所以它们都做一些略有不同的事情，

1236
01:04:55,020 --> 01:04:56,240
然后如果系统是智能的，

1237
01:04:56,240 --> 01:04:57,880
你可以尝试将其转换为 JOIN 。

1238
01:04:59,960 --> 01:05:01,450
所以跳过这段时间，

1239
01:05:01,450 --> 01:05:02,760
因为我们要完成，

1240
01:05:05,470 --> 01:05:10,190
我想完成 LATERAL JOIN 和 CTE 。

1241
01:05:10,960 --> 01:05:14,480
横向连接是一个较新的概念，

1242
01:05:14,650 --> 01:05:17,490
但是，并不是所有的系统都会支持它，

1243
01:05:17,720 --> 01:05:19,470
但基本的想法是，

1244
01:05:19,610 --> 01:05:21,390
它将允许你拥有一个，

1245
01:05:22,300 --> 01:05:31,380
嵌套查询引用与其相邻的另一个查询中的数据。

1246
01:05:31,820 --> 01:05:32,790
所以，通常情况下，

1247
01:05:33,350 --> 01:05:34,620
如果你有两个嵌套查询，

1248
01:05:34,880 --> 01:05:37,290
一个嵌套查询不能引用另一个嵌套查询中的内容，

1249
01:05:37,490 --> 01:05:39,360
因为它不知道其中的内容，

1250
01:05:39,830 --> 01:05:41,010
但是具有横向连接，

1251
01:05:41,840 --> 01:05:42,730
它允许你这样做，

1252
01:05:42,730 --> 01:05:44,760
你可以认为这是一个 for 循环，

1253
01:05:45,230 --> 01:05:51,535
一张表，每一个外部 for 循环中的 tuple ，

1254
01:05:51,535 --> 01:05:53,560
你可以做一些查询，

1255
01:05:53,560 --> 01:05:54,540
在这里做一些计算。

1256
01:05:55,410 --> 01:05:56,680
所以在这个简单的例子中，

1257
01:05:57,390 --> 01:06:00,100
我有两个嵌套查询，

1258
01:06:00,360 --> 01:06:02,000
我有 SELECT 1 AS x ，

1259
01:06:02,000 --> 01:06:04,690
所以这返回一个 tuple ，它有一个值为 1 的列，

1260
01:06:05,070 --> 01:06:07,000
然后我的横向连接，

1261
01:06:07,380 --> 01:06:11,920
现在可以引用这个第一个查询的输出，

1262
01:06:12,150 --> 01:06:14,360
只需在它上加 1 ，

1263
01:06:14,360 --> 01:06:16,300
所以我使用这种方法得到了 1 和 2 。

1264
01:06:17,830 --> 01:06:19,400
如果没有横向连接，你无法执行此操作，

1265
01:06:19,990 --> 01:06:23,120
因为这将被视为两个完全独立的查询，

1266
01:06:23,620 --> 01:06:25,580
我们可以在 Postgres 中执行此操作，并快速查看。

1267
01:06:30,840 --> 01:06:32,380
所以， SELECT * FROM ，

1268
01:06:33,980 --> 01:06:35,610
在一个内部查询中，比如 1 AS ，

1269
01:06:39,960 --> 01:06:42,250
抱歉，是的，是的，是的，

1270
01:06:43,340 --> 01:06:43,860
AS x ，

1271
01:06:45,400 --> 01:06:46,220
AS t1 。

1272
01:06:48,720 --> 01:06:51,880
好的，所以我可以得到一个 tuple ，里面有 1 ，

1273
01:06:52,530 --> 01:06:55,150
但如果我尝试将另一个嵌套查询放在它旁边，

1274
01:06:57,270 --> 01:07:03,810
SELECT 2 AS y ， AS t2 ，

1275
01:07:04,040 --> 01:07:05,110
我得到了笛卡尔乘积，

1276
01:07:05,110 --> 01:07:06,970
但我不能引用这个内部的东西，

1277
01:07:06,970 --> 01:07:11,820
我不能做 t1.x+1 ，

1278
01:07:12,410 --> 01:07:14,140
因为它不知道 t1 ，

1279
01:07:14,140 --> 01:07:17,040
因为这些查询是分开运行的，

1280
01:07:17,550 --> 01:07:19,060
如果我加上 LATERAL 关键字，

1281
01:07:22,630 --> 01:07:27,950
现在，我的第二个嵌套查询可以引用第一个查询中的任何内容，

1282
01:07:28,820 --> 01:07:32,580
你可以将这些东西链接在一起，想链接多少次就链接多少次。

1283
01:07:33,650 --> 01:07:34,495
让我们快速返回它，

1284
01:07:34,495 --> 01:07:35,850
看看这个查询计划是什么，

1285
01:07:35,960 --> 01:07:37,470
从理论上讲，你应该将其转换为 JOIN ，

1286
01:07:40,640 --> 01:07:44,580
哦，好吧，它走了一条捷径，忽略它，

1287
01:07:45,590 --> 01:07:48,055
因为它基本上是在说，我知道答案是什么，

1288
01:07:48,055 --> 01:07:49,585
我不需要运行任何东西，只需输出答案即可，

1289
01:07:49,585 --> 01:07:50,220
这就是它所做的，

1290
01:07:50,660 --> 01:07:53,940
比如 SELECT 1+1 ，它知道如何进行计算，在不运行查询的情况下。

1291
01:07:54,990 --> 01:07:56,900
好的，让我们举一个更复杂的例子，

1292
01:07:56,900 --> 01:07:59,740
假设我想要计算每门课程的注册人数，

1293
01:08:00,630 --> 01:08:03,250
然后我想计算每门课程的注册人数，

1294
01:08:03,300 --> 01:08:08,110
然后我还想知道这门课上所有学生的平均绩点。

1295
01:08:09,630 --> 01:08:11,930
是的，你可以不使用 LATERAL JOIN 来编写这个，

1296
01:08:11,930 --> 01:08:13,450
我只是想向你展示如何使用 LATERAL JOIN 来实现。

1297
01:08:13,680 --> 01:08:15,250
所以，将有两个嵌套查询，

1298
01:08:15,800 --> 01:08:18,190
我们在外部有一个 SELECT 语句，

1299
01:08:18,480 --> 01:08:21,310
对于 course 表中的每个 tuple ，

1300
01:08:21,720 --> 01:08:23,530
我要计算注册学生的数量，

1301
01:08:24,120 --> 01:08:26,110
然后，对于 course 表中的每个学生，

1302
01:08:26,310 --> 01:08:30,925
我想计算所有注册学生的平均绩点。

1303
01:08:30,925 --> 01:08:31,945
所以，我可以这样写，

1304
01:08:31,945 --> 01:08:33,960
我们有两个嵌套查询，

1305
01:08:34,040 --> 01:08:36,000
带有 LATERAL 关键字，

1306
01:08:36,590 --> 01:08:40,500
再次，这里的第一个查询，我计算 COUNT ，

1307
01:08:40,880 --> 01:08:45,900
在它的内部，我能够引用外部查询，相邻的查询，

1308
01:08:46,220 --> 01:08:48,220
下面这个也是一样的，

1309
01:08:48,220 --> 01:08:50,100
我可以使用这个引用那个，

1310
01:08:50,180 --> 01:08:51,870
现在我不在这里展示这个例子，

1311
01:08:52,160 --> 01:08:53,575
因为你可以尝试，

1312
01:08:53,575 --> 01:08:55,665
但是，在第二个 LATERAL 查询中，

1313
01:08:55,665 --> 01:08:57,530
我也可以引用第一个，

1314
01:08:57,730 --> 01:08:59,570
这些东西被改变，会一起改变。

1315
01:09:00,040 --> 01:09:02,220
再说一次，当你考虑 SQL 时，这是一个不同的概念，

1316
01:09:02,220 --> 01:09:03,240
因为 SQL 是无序的，

1317
01:09:03,240 --> 01:09:08,300
我们没有指定数据库系统应该执行任何操作的顺序，

1318
01:09:08,830 --> 01:09:09,960
我们并没有这么做，

1319
01:09:09,960 --> 01:09:11,055
我们只是告诉它[]，

1320
01:09:11,055 --> 01:09:14,400
我们想要的计算执行的顺序，

1321
01:09:14,400 --> 01:09:15,680
来计算我们想要的答案。

1322
01:09:16,320 --> 01:09:18,185
所以，数据库系统可以决定，

1323
01:09:18,185 --> 01:09:20,165
我是要将其重写为一组 JOIN ，

1324
01:09:20,165 --> 01:09:21,790
并同时执行它们，

1325
01:09:22,470 --> 01:09:24,640
还是决定一个接一个地执行，

1326
01:09:26,340 --> 01:09:28,040
我们可以快速地测试 Postgres ，

1327
01:09:28,040 --> 01:09:28,660
看看它是怎么做的。

1328
01:09:29,510 --> 01:09:30,520
我不认为我在这里复制过，

1329
01:09:35,270 --> 01:09:37,620
是的，抱歉，我没有很快地复制粘贴它，

1330
01:09:39,330 --> 01:09:40,390
你可以稍后在[网上]试一下。

1331
01:09:42,520 --> 01:09:44,990
我想向你展示的最后一件事是公用表表达式，

1332
01:09:46,140 --> 01:09:50,290
所以， CTE 是在 10 20 年前添加的，

1333
01:09:51,660 --> 01:09:55,640
这类似于嵌套查询，或者类似于，

1334
01:09:57,060 --> 01:09:59,480
如果你要将数据写入临时表或类似的东西，

1335
01:09:59,920 --> 01:10:03,105
这是我们指定查询的一种方式，

1336
01:10:03,105 --> 01:10:04,340
我们希望实现，

1337
01:10:05,220 --> 01:10:06,080
也许我们不想用这个词，

1338
01:10:06,400 --> 01:10:07,635
我们希望指定一个查询，

1339
01:10:07,635 --> 01:10:12,330
该查询可以存储在某个虚拟表中，

1340
01:10:13,200 --> 01:10:16,250
然后我们可以有另一个查询，可以引用它里面的任何东西。

1341
01:10:18,790 --> 01:10:20,390
在我非常简单的例子中，

1342
01:10:20,620 --> 01:10:22,850
我有这个 WITH 子句，

1343
01:10:23,320 --> 01:10:25,190
我给我的 CTE 一个名字，

1344
01:10:25,750 --> 01:10:27,480
然后我有我的 AS 语句，

1345
01:10:27,480 --> 01:10:29,060
然后这个圆括号里的任何东西，

1346
01:10:29,350 --> 01:10:30,350
这里的任何 SELECT 查询，

1347
01:10:30,550 --> 01:10:35,410
都将绑定到这个名字，

1348
01:10:35,910 --> 01:10:39,040
然后在 WITH 语句后面的任何东西，

1349
01:10:39,800 --> 01:10:46,070
然后可以引用它，就好像它是一个表。

1350
01:10:46,990 --> 01:10:49,070
再说一次，就像这样，

1351
01:10:49,300 --> 01:10:54,705
所以， AS 子句绑定在名字上，

1352
01:10:54,705 --> 01:10:56,990
无论我的 WITH 语句里是什么。

1353
01:10:57,160 --> 01:10:59,880
所以，我又有一个无表查询，

1354
01:10:59,880 --> 01:11:00,615
SELECT 1, 2 ，

1355
01:11:00,615 --> 01:11:01,560
将产生 1, 2 ，

1356
01:11:01,560 --> 01:11:04,100
有一列 1 ，一列 2 ，

1357
01:11:04,480 --> 01:11:08,195
但是在我的 WITH 子句中，

1358
01:11:08,195 --> 01:11:09,850
我现在可以给列命名，

1359
01:11:10,080 --> 01:11:12,940
然后可以在下面的查询中引用。

1360
01:11:16,270 --> 01:11:17,415
你也可以做一些奇怪的事情，

1361
01:11:17,415 --> 01:11:21,350
比如，在 Postgres 中，你可以给列命名相同的东西，

1362
01:11:22,420 --> 01:11:24,560
但是当你在下面尝试引用它时，

1363
01:11:24,580 --> 01:11:25,460
它会抛出一个错误。

1364
01:11:26,770 --> 01:11:31,395
同样，这个示例中的语法大致相同，

1365
01:11:31,395 --> 01:11:34,220
但语义在不同的系统中可能会有所不同。

1366
01:11:35,370 --> 01:11:35,855
让我们看看，

1367
01:11:35,855 --> 01:11:37,220
让我们来看看我们真正想要如何使用它，

1368
01:11:37,220 --> 01:11:38,080
再次，对于这个问题，

1369
01:11:38,400 --> 01:11:42,070
我们想找出注册了至少一门课程的最高 id 的学生记录，

1370
01:11:42,570 --> 01:11:46,270
同样，给你展示了如何使用嵌套查询，使用 JOIN 来实现，

1371
01:11:47,160 --> 01:11:48,670
但现在我们可以使用 CTE ，

1372
01:11:49,080 --> 01:11:50,330
在 CTE 中，

1373
01:11:50,330 --> 01:11:51,550
我要做的第一件事是，

1374
01:11:51,900 --> 01:11:55,600
从 enrolled 表中计算 MAX(sid) ，

1375
01:11:56,220 --> 01:11:58,040
现在，在下面的 SELECT 语句中，

1376
01:11:58,450 --> 01:12:01,520
我可以引用我的 CTE ，来获取 maxID ，

1377
01:12:02,230 --> 01:12:04,280
然后对其进行 JOIN ，

1378
01:12:07,020 --> 01:12:09,310
同样，数据库应该足够智能，能够意识到，

1379
01:12:09,570 --> 01:12:13,630
哦，我只需运行 CTE 一次，具体化它，

1380
01:12:13,710 --> 01:12:16,540
然后现在我就可以像临时表一样引用它，

1381
01:12:16,860 --> 01:12:19,420
在后面的任何调用它的查询中。

1382
01:12:23,130 --> 01:12:24,340
还有任何关于 CTE 的问题吗？

1383
01:12:27,930 --> 01:12:30,595
好的，就这样结束了。

1384
01:12:30,595 --> 01:12:32,920
所以，希望从这一切中得到的主要结论是，

1385
01:12:32,920 --> 01:12:33,760
SQL 不是一种已死的语言，

1386
01:12:33,760 --> 01:12:35,100
你可以用它做很多很酷的事情，

1387
01:12:36,260 --> 01:12:40,770
你希望尝试在一条语句中进行尽可能多的计算，

1388
01:12:41,150 --> 01:12:42,535
现在它可以是嵌套的查询，

1389
01:12:42,535 --> 01:12:44,070
可以做里面的许多奇怪的事情，

1390
01:12:44,750 --> 01:12:48,840
我们无法避免在客户端和服务器之间来回往返，

1391
01:12:49,010 --> 01:12:52,480
因为从理论上讲，数据库系统应该足够智能，

1392
01:12:52,480 --> 01:12:55,620
知道执行你提供给它的查询的最佳方式是什么，

1393
01:12:56,270 --> 01:12:57,690
一旦你从数据库中取出一些东西，

1394
01:12:58,700 --> 01:12:59,755
在上面做一些 Python 代码，

1395
01:12:59,755 --> 01:13:01,860
这显然超出了数据库系统的范围，

1396
01:13:02,150 --> 01:13:04,740
所以我们无法对其进行优化，优化那个 Python 代码，

1397
01:13:05,120 --> 01:13:06,600
如果你把所有的东西都放在数据库系统里，

1398
01:13:07,010 --> 01:13:09,960
它应该能够很好地努力如何进一步优化它。

1399
01:13:10,380 --> 01:13:12,110
再说一次，所有这一切的主要结论是，

1400
01:13:12,580 --> 01:13:15,020
这里有一个 SQL 标准，但是没有人确切地遵循，

1401
01:13:15,370 --> 01:13:17,420
每个独立的数据库系统都略有不同，

1402
01:13:19,220 --> 01:13:21,685
人们声称，哦，如果你支持 SQL 就太好了，

1403
01:13:21,685 --> 01:13:23,140
因为这样你就是可移植的，

1404
01:13:23,140 --> 01:13:25,920
比如如果我在 MySQL 上编写我的应用程序，

1405
01:13:26,150 --> 01:13:27,960
我可以很容易地将它移植到 Postgres ，

1406
01:13:28,190 --> 01:13:29,070
并不是这样的，

1407
01:13:30,410 --> 01:13:32,670
很多时候，无论你一开始选择什么数据库系统，

1408
01:13:32,960 --> 01:13:36,990
你将在很长一段时间内被困住，

1409
01:13:37,520 --> 01:13:38,040
[] 。

1410
01:13:39,140 --> 01:13:40,530
好的，最后一件事，

1411
01:13:40,700 --> 01:13:42,270
家庭作业一，它将在今天放出，

1412
01:13:42,740 --> 01:13:43,915
它将编写 SQL 查询，

1413
01:13:43,915 --> 01:13:44,850
进行基本数据分析，

1414
01:13:45,740 --> 01:13:48,690
今年，我们将要求你在 SQLite 和 DuckDB 上做，

1415
01:13:53,210 --> 01:13:54,310
原因是，

1416
01:13:54,310 --> 01:13:55,710
因为你编写相同的查询，

1417
01:13:55,850 --> 01:13:57,660
语法会略有不同，不会太差，

1418
01:13:57,950 --> 01:14:01,320
但是你运行相同的查询在 SQLite ，在 DuckDB ，

1419
01:14:01,490 --> 01:14:02,610
你将看到哪个速度更快，

1420
01:14:05,450 --> 01:14:08,550
你会有这个顿悟，一个比另一个快得多，

1421
01:14:09,890 --> 01:14:10,890
猜猜哪个更快？

1422
01:14:16,800 --> 01:14:17,410
更有效率。

1423
01:14:17,670 --> 01:14:23,020
他说查询更有效率，可能是部分原因。

1424
01:14:26,820 --> 01:14:28,120
这也不是答案。

1425
01:14:35,375 --> 01:14:35,890
这不是原因，

1426
01:14:35,910 --> 01:14:38,950
好的，所以你运行这些查询时， DuckDB 应该会更快，

1427
01:14:40,120 --> 01:14:41,130
你会说，好吧，为什么，

1428
01:14:41,330 --> 01:14:42,480
这就是这学期剩下的时间，

1429
01:14:45,950 --> 01:14:46,560
这节课是 SQL ，

1430
01:14:47,810 --> 01:15:10,285
下节课我们将谈论如何构建一个系统。

