1
00:00:29,860 --> 00:00:31,940
I'll send you guys some information on Wednesday,

2
00:00:32,200 --> 00:00:33,530
so if you free come down,

3
00:00:33,730 --> 00:00:36,380
gonna be 11 to 1, at night.

4
00:00:38,010 --> 00:00:40,895
Okay, and you, you said you have a bouncer,

5
00:00:40,895 --> 00:00:43,625
that's gonna ignore the IDs or you have like fake IDs,

6
00:00:43,625 --> 00:00:45,280
that you're going to hand out on the side as a business,

7
00:00:45,960 --> 00:00:48,640
and all of that information I cannot say in this class.

8
00:00:48,660 --> 00:00:50,980
Okay, please don't do that, please don't do that.

9
00:00:51,800 --> 00:00:52,945
Okay, great, excellent,

10
00:00:52,945 --> 00:00:55,975
and we'll have a trip report for some of you guys make it to that,

11
00:00:55,975 --> 00:00:57,030
so.

12
00:00:57,410 --> 00:00:59,875
Alright, sorry about taking a little bit of time to get started,

13
00:00:59,875 --> 00:01:01,680
I had a bunch of people at the office hours,

14
00:01:02,750 --> 00:01:05,910
but we're going to talk about the concurrency control today.

15
00:01:06,480 --> 00:01:09,140
And let's just jump right into it.

16
00:01:09,160 --> 00:01:11,330
Alright, so let's get into this.

17
00:01:11,860 --> 00:01:15,860
You've seen this diagram of what a database engine looks like,

18
00:01:15,880 --> 00:01:18,350
as a modular architecture for the different components.

19
00:01:18,880 --> 00:01:23,840
We are going to talk today about concurrency control mechanisms,

20
00:01:23,950 --> 00:01:25,950
that hit across these different layers,

21
00:01:25,950 --> 00:01:29,360
which largely hits the operator execution and the access method layers.

22
00:01:29,800 --> 00:01:30,925
In two classes from now,

23
00:01:30,925 --> 00:01:32,305
we'll talk about recovery methods,

24
00:01:32,305 --> 00:01:34,920
which is at the buffer pool and disk manager layers.

25
00:01:35,120 --> 00:01:37,135
Now all of this will become a lot more clear,

26
00:01:37,135 --> 00:01:40,230
as we jump into what that transaction management mean,

27
00:01:40,490 --> 00:01:41,700
what does recovery mean.

28
00:01:41,840 --> 00:01:44,280
So let's go straight to that.

29
00:01:45,370 --> 00:01:50,960
So transaction management allows us to do things safely in a database system,

30
00:01:51,580 --> 00:01:56,330
in situations where multiple things are getting updated all at the same time.

31
00:01:57,080 --> 00:01:58,270
Let's start with a simple example.

32
00:01:59,260 --> 00:02:03,920
Here is a schematic of database operations,

33
00:02:04,060 --> 00:02:05,900
These could be fired through a SQL query,

34
00:02:06,340 --> 00:02:08,960
from the perspective of the transaction management component,

35
00:02:09,280 --> 00:02:13,700
we are largely going to look at the operations that happen at the object level.

36
00:02:13,840 --> 00:02:15,260
So imagine we fired up a transaction

37
00:02:15,850 --> 00:02:17,840
and that ends up reading an object,

38
00:02:17,950 --> 00:02:19,650
could be a record, could be a page,

39
00:02:19,650 --> 00:02:22,700
we're just going to refer to them as objects here in this class,

40
00:02:22,960 --> 00:02:24,830
does some checking of that value,

41
00:02:25,360 --> 00:02:26,690
does some action like pay

42
00:02:26,770 --> 00:02:30,135
and then updates that A by subtracting 25 from it

43
00:02:30,135 --> 00:02:31,880
and eventually writes that,

44
00:02:32,710 --> 00:02:35,240
for the purpose of the discussion for transaction management,

45
00:02:35,740 --> 00:02:39,495
we are largely concerned with the read and write operations,

46
00:02:39,495 --> 00:02:42,290
that happen with each of these database objects,

47
00:02:42,550 --> 00:02:45,975
you can think of them as records, pages, tables, what have you,

48
00:02:45,975 --> 00:02:46,520
it won't matter,

49
00:02:46,900 --> 00:02:51,860
just assume the read and writes for objects that are in the database is what we care about.

50
00:02:52,200 --> 00:02:55,185
And we want to have certain properties about these read and write,

51
00:02:55,185 --> 00:02:58,645
to ensure notions of correctness as we define it,

52
00:02:58,645 --> 00:03:00,510
and that's what transaction management does.

53
00:03:01,160 --> 00:03:02,350
So what could go wrong,

54
00:03:02,430 --> 00:03:04,540
this is a simple set of actions,

55
00:03:04,680 --> 00:03:05,980
that are presented to the database

56
00:03:06,360 --> 00:03:10,420
in response to a query that an application might have sent,

57
00:03:10,830 --> 00:03:12,515
and a couple things could go wrong.

58
00:03:12,515 --> 00:03:14,555
So here on the right side,

59
00:03:14,555 --> 00:03:18,360
you see the bank balance starts out, has a value of 100,

60
00:03:18,950 --> 00:03:21,450
the first thing that happens is does that check

61
00:03:21,680 --> 00:03:23,070
and everything looks okay,

62
00:03:23,330 --> 00:03:25,470
it says yes, that check passes,

63
00:03:25,490 --> 00:03:28,210
so there's sufficient balance to pay 25 dollars,

64
00:03:28,210 --> 00:03:31,290
so this is you going to an ATM asking for a withdrawal,

65
00:03:32,070 --> 00:03:34,340
and pays you that 25 dollars,

66
00:03:34,340 --> 00:03:35,320
so you now have it

67
00:03:35,520 --> 00:03:37,690
and the new balance is calculated,

68
00:03:38,010 --> 00:03:40,300
and that balance now gets written to your bank account.

69
00:03:40,590 --> 00:03:42,580
Okay, so after the new balance gets calculated,

70
00:03:42,750 --> 00:03:45,620
that last action of bank balance of 75

71
00:03:45,620 --> 00:03:49,540
is that write operation, that you see in that code on the left side.

72
00:03:50,120 --> 00:03:52,140
But now, what if,

73
00:03:52,780 --> 00:03:55,830
after the ATM machine spitted out the 25 dollars,

74
00:03:57,650 --> 00:04:00,130
you went and yanked that ATM machine power cord,

75
00:04:00,130 --> 00:04:01,560
so that it could not send the write back,

76
00:04:02,450 --> 00:04:03,715
okay, imagine you were that fast,

77
00:04:03,715 --> 00:04:05,400
or there's a natural power failure,

78
00:04:05,870 --> 00:04:07,980
so the paying action,

79
00:04:09,070 --> 00:04:11,840
and the write to the database is not atomic,

80
00:04:11,860 --> 00:04:13,140
they're happening in different systems,

81
00:04:13,140 --> 00:04:15,140
they might even be geographically spread across,

82
00:04:15,400 --> 00:04:18,260
and bad things could happen in between those actions.

83
00:04:18,850 --> 00:04:21,830
So how do we make sure that this transaction is correct,

84
00:04:22,090 --> 00:04:23,265
obviously, we don't want that,

85
00:04:23,265 --> 00:04:24,510
Your bank would be very upset,

86
00:04:24,510 --> 00:04:26,120
if that's how database systems work,

87
00:04:26,500 --> 00:04:29,010
because they would be losing money, if this happens.

88
00:04:29,450 --> 00:04:31,435
So we want this type of stuff to be protected

89
00:04:31,435 --> 00:04:32,490
and we'll talk about how.

90
00:04:33,130 --> 00:04:34,130
Here's another scenario,

91
00:04:34,240 --> 00:04:35,120
a different scenario,

92
00:04:35,980 --> 00:04:38,900
showing a different type of problems that we also need to worry about.

93
00:04:39,160 --> 00:04:42,110
So this is not a power failure or things of that sort,

94
00:04:42,190 --> 00:04:43,340
but concurrent actions.

95
00:04:44,050 --> 00:04:44,580
So imagine,

96
00:04:44,580 --> 00:04:47,145
you and your significant other both shared this bank account

97
00:04:47,145 --> 00:04:49,130
and you have individual debit cards,

98
00:04:49,390 --> 00:04:51,890
that allow you to debit from that same bank account,

99
00:04:52,320 --> 00:04:54,390
and you both go to two separate ATMs

100
00:04:54,390 --> 00:04:57,390
and simultaneously run this transaction,

101
00:04:57,590 --> 00:05:02,130
so both of you are running these sequence of actions to withdraw 25 dollars,

102
00:05:02,960 --> 00:05:06,240
and, sufficient balance is checked on both sides,

103
00:05:06,800 --> 00:05:09,270
you get paid, ATM spits out 25 dollars,

104
00:05:09,770 --> 00:05:11,310
your significant other gets paid,

105
00:05:11,570 --> 00:05:14,680
but now, because both of them read the original bank balance,

106
00:05:14,680 --> 00:05:17,430
both of them have calculated the new balance as being 75,

107
00:05:18,780 --> 00:05:20,290
because everything looks correct,

108
00:05:20,610 --> 00:05:22,990
and then the first one writes,

109
00:05:23,610 --> 00:05:25,235
the second one overwrites that,

110
00:05:25,235 --> 00:05:27,160
and now the bank is short 25 dollars.

111
00:05:27,870 --> 00:05:30,960
Again, this is not, ideal situation for the banks,

112
00:05:31,100 --> 00:05:32,605
banks would never use database systems,

113
00:05:32,605 --> 00:05:34,650
or enterprises wouldn't use database systems,

114
00:05:34,940 --> 00:05:36,780
if these types of things are allowed to happen.

115
00:05:37,400 --> 00:05:38,150
So semantically,

116
00:05:38,150 --> 00:05:39,170
what we wanted is that,

117
00:05:39,170 --> 00:05:41,110
we wanted the database,

118
00:05:41,850 --> 00:05:44,890
application was sending this read and write request,

119
00:05:45,060 --> 00:05:46,930
that was written by some application code,

120
00:05:47,370 --> 00:05:50,080
that is firing up the SQL queries to the database system

121
00:05:50,370 --> 00:05:53,320
and now to no fault of the application code writer,

122
00:05:53,640 --> 00:05:55,570
that's what the application code writer is doing,

123
00:05:55,770 --> 00:05:56,915
effectively writing the code,

124
00:05:56,915 --> 00:05:59,860
that ends up, sending those read write operations to the database,

125
00:06:00,210 --> 00:06:02,710
it feels the database system is just corrupting the data,

126
00:06:02,940 --> 00:06:06,155
so that's obviously not what we want of a database system,

127
00:06:06,155 --> 00:06:07,660
we want it to be well behaved,

128
00:06:07,800 --> 00:06:10,900
we want the final balance, in this case, to be 50 dollars.

129
00:06:11,540 --> 00:06:16,410
Okay, so how do we deal with these bad system's, system's behavior,

130
00:06:17,250 --> 00:06:19,340
and have the database be coherent,

131
00:06:19,340 --> 00:06:22,085
because ultimately the database is the keeper of the records,

132
00:06:22,085 --> 00:06:25,250
That's the master copy of what you have in the bank account,

133
00:06:25,250 --> 00:06:26,530
and it has to be consistent,

134
00:06:26,730 --> 00:06:29,080
in spite of all these different failure scenarios.

135
00:06:29,820 --> 00:06:31,180
So, one system way,

136
00:06:31,260 --> 00:06:32,800
assuming that you don't have power failure,

137
00:06:33,060 --> 00:06:36,460
is to say, okay, the second type of option that I had were,

138
00:06:36,540 --> 00:06:38,350
concurrent actions were corrupting each other,

139
00:06:39,080 --> 00:06:39,785
is to say,

140
00:06:39,785 --> 00:06:41,620
I'm going to have a very simple database system,

141
00:06:42,350 --> 00:06:44,890
even if two people requested the queries at the same time,

142
00:06:44,890 --> 00:06:47,320
I will only run the one query at a time,

143
00:06:47,320 --> 00:06:49,980
I'm going to queue everything up, all the requests I get,

144
00:06:50,120 --> 00:06:51,660
I will run one query at a time

145
00:06:51,920 --> 00:06:55,860
and I can get a sensible, correct behavior

146
00:06:56,120 --> 00:06:57,750
for the scenario we just talked about.

147
00:06:58,140 --> 00:06:59,475
I can also start to do things,

148
00:06:59,475 --> 00:07:00,870
like before a transaction starts,

149
00:07:00,870 --> 00:07:02,750
I can make a copy of the entire database,

150
00:07:03,310 --> 00:07:04,580
make all the changes there,

151
00:07:04,930 --> 00:07:07,010
and if the transaction complete successfully,

152
00:07:07,660 --> 00:07:10,340
so didn't have a power failure, all of that other kinds of stuff,

153
00:07:10,780 --> 00:07:12,410
I will overwrite it with a new copy.

154
00:07:13,020 --> 00:07:14,290
Both of these are really bad,

155
00:07:14,580 --> 00:07:17,170
from they will give you some form of correctness,

156
00:07:17,250 --> 00:07:19,420
but they're really bad from a performance perspective,

157
00:07:19,920 --> 00:07:24,370
because it would be a very, very slow database system

158
00:07:24,720 --> 00:07:27,290
and you won't be able to quite use that, right.

159
00:07:27,290 --> 00:07:28,580
Today, when you go to Amazon

160
00:07:28,580 --> 00:07:30,730
and you're checking out your shopping cart,

161
00:07:30,840 --> 00:07:34,720
you know ultimately something going and issuing database transaction records

162
00:07:34,740 --> 00:07:35,890
to debit from your,

163
00:07:36,180 --> 00:07:37,720
to add to your shopping cart,

164
00:07:37,830 --> 00:07:39,640
eventually another transaction gets there,

165
00:07:39,780 --> 00:07:42,185
sent to your credit card account to record that,

166
00:07:42,185 --> 00:07:43,600
that amount needs to be debted

167
00:07:43,680 --> 00:07:45,095
and all of that works correctly,

168
00:07:45,095 --> 00:07:46,270
even if multiple people,

169
00:07:46,840 --> 00:07:48,960
multiple account holders on the same credit card

170
00:07:49,190 --> 00:07:51,270
are doing the transactions at the same time,

171
00:07:51,350 --> 00:07:53,100
multiple shopping carts are getting created.

172
00:07:53,330 --> 00:07:55,410
So we really want to be able to do this at scale,

173
00:07:55,640 --> 00:07:57,660
we don't want to do one transactions at a time,

174
00:07:57,770 --> 00:08:00,025
you want to be doing thousands, tens of thousands,

175
00:08:00,025 --> 00:08:02,400
if not millions or billions of transactions at a time.

176
00:08:02,870 --> 00:08:03,835
Okay, so how do we do that,

177
00:08:03,835 --> 00:08:05,010
that's a really hard problem.

178
00:08:05,420 --> 00:08:08,280
Okay, if we want better utilization for the database hardware,

179
00:08:08,600 --> 00:08:11,160
we want higher throughput, better response times,

180
00:08:11,330 --> 00:08:13,080
and of course, we want it to be correct,

181
00:08:13,630 --> 00:08:14,930
so that the right thing happens,

182
00:08:14,950 --> 00:08:17,150
and we'll define what that notion of correctness is.

183
00:08:18,190 --> 00:08:20,270
And in many cases, you also want it to be fair,

184
00:08:20,830 --> 00:08:23,210
so if multiple transactions come at the same time,

185
00:08:23,260 --> 00:08:26,280
you want all of them to be given that equal chance to complete

186
00:08:26,280 --> 00:08:29,270
and not just say I'm going to hold two of you in the back forever

187
00:08:29,410 --> 00:08:31,755
and just let the other others go forward, right,

188
00:08:31,755 --> 00:08:32,420
that's not fair,

189
00:08:32,530 --> 00:08:34,850
you want to have some notion of fairness.

190
00:08:36,090 --> 00:08:37,625
And some systems may not have that,

191
00:08:37,625 --> 00:08:38,620
sometimes you have priorities,

192
00:08:38,730 --> 00:08:41,360
where you say I want high priorities transactions to go through,

193
00:08:41,360 --> 00:08:43,115
but assuming you want fairness,

194
00:08:43,115 --> 00:08:45,160
you at least want the capability of having fairness,

195
00:08:45,180 --> 00:08:46,205
how you balance that,

196
00:08:46,205 --> 00:08:49,630
in terms of partitioning your workload, to let higher priority stuff go

197
00:08:50,100 --> 00:08:51,040
is a different issue,

198
00:08:51,120 --> 00:08:55,660
but you do want the mechanism of fairness to be built into the database system.

199
00:08:56,870 --> 00:08:57,910
Okay, questions so far,

200
00:08:57,910 --> 00:08:59,340
in terms of what we are trying to achieve.

201
00:09:02,240 --> 00:09:02,640
Yep.

202
00:09:05,950 --> 00:09:06,705
We will try to,

203
00:09:06,705 --> 00:09:08,240
we will solve all the issues

204
00:09:08,290 --> 00:09:09,620
except the power failure issue

205
00:09:10,030 --> 00:09:12,465
and the power failure issue will be solved,

206
00:09:12,465 --> 00:09:14,835
and we get to all of that solution later on

207
00:09:14,835 --> 00:09:18,770
where the, there's a very subtle issue in the power failure stuff,

208
00:09:18,940 --> 00:09:21,750
which is with all the stuff we'll talk about in the next few lectures,

209
00:09:21,750 --> 00:09:25,400
we can make sure that the database record ends up in the right state.

210
00:09:25,860 --> 00:09:27,980
But if the bank has paid you 25 dollars

211
00:09:28,030 --> 00:09:29,240
and there's a power failure,

212
00:09:29,980 --> 00:09:31,610
there's extra action that is needed,

213
00:09:32,080 --> 00:09:34,910
because that 25 dollars has been a physical action,

214
00:09:35,290 --> 00:09:36,620
everything else is a digital action,

215
00:09:36,970 --> 00:09:40,140
and to undo that action of paying you 25 dollars,

216
00:09:40,140 --> 00:09:41,150
when they should not have paid,

217
00:09:41,500 --> 00:09:45,090
the bank would have to then do a separate transaction in physical space

218
00:09:45,090 --> 00:09:46,110
where they'll send you a letter saying,

219
00:09:46,110 --> 00:09:48,110
whoops, we accidentally paid you 25 dollars,

220
00:09:48,370 --> 00:09:50,360
but here's what what your bank account is.

221
00:09:50,680 --> 00:09:52,040
So there are other ways to do that,

222
00:09:52,120 --> 00:09:52,820
we won't,

223
00:09:52,900 --> 00:09:55,275
we will be able to undo all the read and writes,

224
00:09:55,275 --> 00:09:57,200
if we don't want them to happen.

225
00:09:57,670 --> 00:09:59,505
But, you know, if the transaction is,

226
00:09:59,505 --> 00:10:01,215
pay 25 dollars is a physical action,

227
00:10:01,215 --> 00:10:02,180
you can't undo it,

228
00:10:02,380 --> 00:10:05,390
you'll undo that by doing other physical actions in the physical world.

229
00:10:05,770 --> 00:10:06,435
Okay, similarly,

230
00:10:06,435 --> 00:10:08,220
if there's a transaction that fired a missile,

231
00:10:08,220 --> 00:10:09,210
you can't undo that missile,

232
00:10:09,210 --> 00:10:10,370
you can't bring that missile back,

233
00:10:10,510 --> 00:10:13,185
you have to send an apology letter or something else like that, right.

234
00:10:13,185 --> 00:10:15,495
So, or something really bad,

235
00:10:15,495 --> 00:10:16,460
so it's like,

236
00:10:16,880 --> 00:10:22,180
the undo for physical actions in transactions will require undo in the physical world,

237
00:10:22,530 --> 00:10:23,440
which we won't cover,

238
00:10:23,700 --> 00:10:25,145
and there are mechanisms to do that,

239
00:10:25,145 --> 00:10:26,650
that are business related actions,

240
00:10:26,790 --> 00:10:29,270
you'll sometimes get a letter from your company saying,

241
00:10:29,270 --> 00:10:31,210
whoops, we made a mistake, sorry about that,

242
00:10:31,350 --> 00:10:32,435
here's what really happened,

243
00:10:32,435 --> 00:10:35,830
oh, and by the way, here's a 10 dollars gift card to make up for a mistake.

244
00:10:36,270 --> 00:10:38,980
But all the digital actions that reads and writes,

245
00:10:39,180 --> 00:10:41,500
we will cast them into a very strict structure

246
00:10:41,820 --> 00:10:46,300
to guarantee very well defined properties of correctness that we will hold,

247
00:10:46,530 --> 00:10:49,930
through the mechanisms we'll talk about today and going into the next few lectures.

248
00:10:50,700 --> 00:10:51,340
Great question.

249
00:10:52,770 --> 00:10:53,410
Other questions?

250
00:10:55,970 --> 00:10:56,520
All right.

251
00:10:57,270 --> 00:11:03,250
So, we want these arbitrary interleaving of operations and be correct.

252
00:11:03,880 --> 00:11:05,430
So before we go a little bit further,

253
00:11:05,990 --> 00:11:08,160
just want to solidify the notion of transactions,

254
00:11:08,840 --> 00:11:10,440
you're going to carry out these operations

255
00:11:10,940 --> 00:11:13,615
and the database that we just talked about

256
00:11:13,615 --> 00:11:17,185
is only concerned about the read and write operations to the database objects,

257
00:11:17,185 --> 00:11:18,810
these physical world actions

258
00:11:19,340 --> 00:11:20,910
of paying an amount

259
00:11:21,140 --> 00:11:25,980
or you know, starting fighting for missiles, stuff like that,

260
00:11:26,270 --> 00:11:28,950
those we won't be able to repair,

261
00:11:29,180 --> 00:11:30,810
if bad things happen, okay.

262
00:11:32,290 --> 00:11:34,340
And there's in the advanced database class,

263
00:11:34,420 --> 00:11:35,520
depending upon the material,

264
00:11:35,520 --> 00:11:37,530
that says sometimes we'll talk about stuff like that

265
00:11:37,530 --> 00:11:40,460
and what are compensating transactions and stuff like that that might happen

266
00:11:40,780 --> 00:11:43,185
and what people might do as other ways.

267
00:11:43,185 --> 00:11:44,760
So, but for the purpose of this class,

268
00:11:44,760 --> 00:11:47,490
we'll just look at in this in this many ways,

269
00:11:47,490 --> 00:11:48,830
a more limited scope.

270
00:11:49,770 --> 00:11:51,130
Reiterating what we talked about,

271
00:11:51,270 --> 00:11:54,250
we think primarily about read and write operations,

272
00:11:54,690 --> 00:11:56,330
you notice that in the code that I had,

273
00:11:56,330 --> 00:11:58,490
there was also a check, there was a subtraction,

274
00:11:58,490 --> 00:11:59,920
there was math and stuff like that,

275
00:12:00,180 --> 00:12:03,280
from the perspective of what we want to cover today for transaction management,

276
00:12:03,690 --> 00:12:04,685
all we care about is,

277
00:12:04,685 --> 00:12:06,850
did an object get written, did it get read,

278
00:12:07,280 --> 00:12:10,900
and do those reads and writes end up interfering with each other in bad ways,

279
00:12:11,190 --> 00:12:12,140
what are those bad ways

280
00:12:12,140 --> 00:12:13,600
and how do we prevent those bad ways?

281
00:12:15,510 --> 00:12:18,100
And how do we prevent those bad ways,

282
00:12:18,270 --> 00:12:22,475
while allowing the maximum number of transactions to work on the system concurrently,

283
00:12:22,475 --> 00:12:23,350
that's the hard part.

284
00:12:24,170 --> 00:12:25,840
Because you already saw there's an easy way,

285
00:12:25,840 --> 00:12:27,810
which is to just do one transaction at a time,

286
00:12:28,280 --> 00:12:29,500
you want to do better than that.

287
00:12:30,420 --> 00:12:32,180
So it's only these objects,

288
00:12:32,180 --> 00:12:34,600
which we'll just refer to as variables A, B and C,

289
00:12:34,950 --> 00:12:36,545
but if you want to have a simple model,

290
00:12:36,545 --> 00:12:37,810
you can think of it as a record,

291
00:12:38,580 --> 00:12:40,030
but inside a database system,

292
00:12:40,140 --> 00:12:42,220
in this we cover in the advanced database class,

293
00:12:42,450 --> 00:12:43,660
that a could be a column,

294
00:12:43,890 --> 00:12:47,390
which is doing things at a finer level of granularity

295
00:12:47,390 --> 00:12:50,620
or it could be a page or it could be a file or it could be a database,

296
00:12:51,090 --> 00:12:52,900
some earlier versions of databases,

297
00:12:53,490 --> 00:12:57,430
like Mongo at one point to do concurrency would lock the entire database,

298
00:12:57,780 --> 00:12:58,780
they don't do that now,

299
00:12:59,070 --> 00:13:03,200
but the the, the, the set of that object

300
00:13:03,200 --> 00:13:07,070
or the A B and C just referred to database objects, right.

301
00:13:07,070 --> 00:13:08,045
For the purpose of today,

302
00:13:08,045 --> 00:13:09,730
you can think about them as records.

303
00:13:10,300 --> 00:13:13,210
And everything today in the next two classes will make a lot more sense,

304
00:13:13,210 --> 00:13:15,060
if you wanted to pick a [] model for that.

305
00:13:17,210 --> 00:13:17,790
All right.

306
00:13:19,710 --> 00:13:23,920
How does the database system know that a transaction is started and transaction is ended,

307
00:13:24,930 --> 00:13:29,440
in SQL, you can explicitly put a begin transaction statement and an end transaction statement

308
00:13:29,670 --> 00:13:30,905
to tell the database system,

309
00:13:30,905 --> 00:13:33,730
all the stuff that happened in between is a transaction

310
00:13:34,170 --> 00:13:36,250
and in between could be multiple SQL queries.

311
00:13:37,890 --> 00:13:39,460
If you don't have a begin and end transaction,

312
00:13:39,570 --> 00:13:41,440
like all the stuff you've been doing in your homework,

313
00:13:41,820 --> 00:13:43,115
when you fire up a SQL query,

314
00:13:43,115 --> 00:13:44,660
implicitly, the database system will

315
00:13:44,660 --> 00:13:46,610
put a begin at the beginning of the query

316
00:13:46,610 --> 00:13:48,070
and an end at the end of the query.

317
00:13:48,520 --> 00:13:50,395
But a transaction could be multi queries, right,

318
00:13:50,395 --> 00:13:52,050
you can explicitly put begin and end.

319
00:13:52,620 --> 00:13:55,020
You could also put an explicit ABORT statement,

320
00:13:55,020 --> 00:13:55,875
which is to say,

321
00:13:55,875 --> 00:13:57,920
so, and instead of end, it is called a COMMIT,

322
00:13:58,950 --> 00:14:01,630
which is to say everything I've done from the BEGIN to here,

323
00:14:01,950 --> 00:14:04,270
please commit it and make its changes permanent,

324
00:14:04,900 --> 00:14:07,320
the other way to end that transaction is to say ABORT,

325
00:14:07,920 --> 00:14:08,570
so it may be,

326
00:14:08,740 --> 00:14:10,365
I'm trying to make vacation plans,

327
00:14:10,365 --> 00:14:12,590
so I do a transaction to book flight tickets,

328
00:14:13,180 --> 00:14:14,985
then I do a little bit of search in the code

329
00:14:14,985 --> 00:14:16,575
to find hotel reservations

330
00:14:16,575 --> 00:14:18,200
and find, whoops, don't have a hotel,

331
00:14:18,520 --> 00:14:19,095
so I could say,

332
00:14:19,095 --> 00:14:20,120
oh, ABORT this transaction

333
00:14:20,380 --> 00:14:21,320
and ABORT says,

334
00:14:21,340 --> 00:14:23,090
I did some work, reads and writes,

335
00:14:23,720 --> 00:14:25,480
but I don't think I can go further,

336
00:14:25,530 --> 00:14:26,650
something doesn't look right,

337
00:14:26,670 --> 00:14:27,580
ABORT this transaction

338
00:14:27,630 --> 00:14:29,980
and you could, the application could be trying again.

339
00:14:30,300 --> 00:14:32,200
You could explicitly abort the transaction

340
00:14:32,850 --> 00:14:35,690
and sometimes it may be that the database abort for you,

341
00:14:35,690 --> 00:14:37,960
because multiple transactions are happening at the same time,

342
00:14:38,190 --> 00:14:40,060
it detects some unsafe condition

343
00:14:40,320 --> 00:14:42,650
and says, whoops, I'm going to abort this transaction for you

344
00:14:42,650 --> 00:14:44,020
and you get an ABORT code.

345
00:14:45,000 --> 00:14:47,105
From the transaction manager's perspective,

346
00:14:47,105 --> 00:14:49,840
the module that we are trying to understand and build today,

347
00:14:50,990 --> 00:14:52,770
it will be presented with a BEGIN transaction,

348
00:14:53,180 --> 00:14:54,240
bunch of read write actions

349
00:14:54,740 --> 00:14:58,440
and eventually it will get a COMMIT or an ABORT action.

350
00:14:59,200 --> 00:15:01,980
And that's what we have to build in the system code

351
00:15:02,180 --> 00:15:03,870
to, to do transactions,

352
00:15:04,310 --> 00:15:06,030
so transactions could end by committing

353
00:15:06,320 --> 00:15:07,705
or they could end by aborting,

354
00:15:07,705 --> 00:15:09,750
aborting means undo everything that might be done,

355
00:15:09,920 --> 00:15:11,970
commit says everything I did make it permanent.

356
00:15:14,210 --> 00:15:15,660
So they can end in those two ways.

357
00:15:16,300 --> 00:15:18,040
And the ABORT could be self inflicted,

358
00:15:18,040 --> 00:15:18,900
as we talked about,

359
00:15:19,370 --> 00:15:21,510
application could have explicitly put an ABORT call,

360
00:15:21,680 --> 00:15:22,480
or it could be that,

361
00:15:22,480 --> 00:15:24,510
the database system has to abort for some reason

362
00:15:24,890 --> 00:15:27,730
to do all this safety guarantee that we talked about.

363
00:15:27,730 --> 00:15:29,380
And we'll look at different ways

364
00:15:29,380 --> 00:15:31,290
in which ABORT happens inside a database system

365
00:15:31,400 --> 00:15:32,700
over the next couple of lectures.

366
00:15:34,600 --> 00:15:38,060
Okay, many of you might have heard of this thing called ACID,

367
00:15:38,440 --> 00:15:39,680
it's a cool acronym,

368
00:15:39,910 --> 00:15:41,510
that was,

369
00:15:42,370 --> 00:15:43,455
that the community came up,

370
00:15:43,455 --> 00:15:45,170
with a couple guys who came up with,

371
00:15:45,280 --> 00:15:50,510
to, say what are the properties we want of these transactions.

372
00:15:52,140 --> 00:15:57,130
And the properties are atomicity consistency, isolation and durability.

373
00:15:57,750 --> 00:15:59,920
So let's go through each one of those,

374
00:16:00,480 --> 00:16:01,660
atomicity says,

375
00:16:02,560 --> 00:16:04,920
I have a transaction that did a whole bunch of read writes,

376
00:16:05,700 --> 00:16:08,430
and, when I say COMMIT,

377
00:16:08,720 --> 00:16:11,220
everything should have committed to the database

378
00:16:11,450 --> 00:16:12,400
or if I say ABORT,

379
00:16:12,400 --> 00:16:13,225
nothing should have happened.

380
00:16:13,225 --> 00:16:16,230
So it's like I want this all or nothing property of this transaction,

381
00:16:16,640 --> 00:16:18,570
even though lots of reads and writes might have happened,

382
00:16:19,010 --> 00:16:21,565
in this, in this transaction, right,

383
00:16:21,565 --> 00:16:23,620
it it should feel like it's atomic, right,

384
00:16:23,620 --> 00:16:24,510
so it's very much like,

385
00:16:24,560 --> 00:16:29,275
what you see with atomic instructions in, in, in processors,

386
00:16:29,275 --> 00:16:31,260
but now this is for multiple reads and writes,

387
00:16:31,370 --> 00:16:34,240
those reads and writes may be spilling data to disk,

388
00:16:34,240 --> 00:16:36,190
so it's a much higher granularity, right,

389
00:16:36,190 --> 00:16:37,110
so much harder problem.

390
00:16:38,640 --> 00:16:39,640
Consistency says,

391
00:16:40,910 --> 00:16:42,390
consistency is a little weird one,

392
00:16:42,560 --> 00:16:45,090
and I'm actually going to go to that last,

393
00:16:45,140 --> 00:16:46,150
let me go to isolation

394
00:16:46,150 --> 00:16:47,700
and I'll come back to consistency.

395
00:16:47,960 --> 00:16:49,080
Isolation says,

396
00:16:49,550 --> 00:16:51,150
if two transactions,

397
00:16:51,290 --> 00:16:53,250
like we have those two debit transactions happening,

398
00:16:53,810 --> 00:16:57,630
withdrawal of 25 dollars from the bank account for you and your significant other,

399
00:16:58,340 --> 00:17:00,625
we want those to not interfere with each other,

400
00:17:00,625 --> 00:17:02,940
it should feel like each transaction happened by itself.

401
00:17:03,490 --> 00:17:06,020
So even though we don't want to run one transaction at a time,

402
00:17:06,160 --> 00:17:10,095
we want the illusion of the system running one transaction at a time,

403
00:17:10,095 --> 00:17:10,935
it should feel like,

404
00:17:10,935 --> 00:17:12,200
when my transaction ran,

405
00:17:12,250 --> 00:17:13,820
I had the whole system to myself,

406
00:17:14,340 --> 00:17:15,980
and nothing else interfered with me.

407
00:17:17,310 --> 00:17:18,100
Does that make sense?

408
00:17:18,420 --> 00:17:21,100
So it's like I should feel no one interfered with my work.

409
00:17:22,620 --> 00:17:24,010
Durability says that,

410
00:17:24,420 --> 00:17:26,825
if the database comes back to me and says,

411
00:17:26,825 --> 00:17:27,880
I've committed your transaction,

412
00:17:29,650 --> 00:17:30,410
after that,

413
00:17:30,580 --> 00:17:34,370
even if there's some failure, the disk fails or the memory fails,

414
00:17:34,750 --> 00:17:38,090
I should be able to recover that state of the database,

415
00:17:39,000 --> 00:17:43,690
with all the commit information in that.

416
00:17:43,690 --> 00:17:47,250
So if I had changed the final value of the bank account to 75,

417
00:17:47,750 --> 00:17:50,350
the database said I've committed your transaction, right,

418
00:17:50,350 --> 00:17:52,560
that commit call came back with a green signal

419
00:17:53,000 --> 00:17:54,360
and then there's a power failure,

420
00:17:54,920 --> 00:17:56,665
when I bring back the machine,

421
00:17:56,665 --> 00:17:58,320
I should see 75 in there,

422
00:17:58,460 --> 00:18:00,720
not 100 which was the value it started with.

423
00:18:02,880 --> 00:18:04,760
Now, going back to consistency,

424
00:18:04,760 --> 00:18:06,125
and I waited for that,

425
00:18:06,125 --> 00:18:07,810
because I'll just put a little labels around,

426
00:18:07,980 --> 00:18:10,150
how we go about doing things like that.

427
00:18:10,470 --> 00:18:12,550
Consistency is this weird thing, that says,

428
00:18:13,400 --> 00:18:16,720
if the database starts consistent, as for some definition,

429
00:18:18,460 --> 00:18:21,230
then it should end in that same consistent state.

430
00:18:21,810 --> 00:18:23,680
Now, that also seems vague, right?

431
00:18:24,260 --> 00:18:26,740
So what does it mean that the database started consistent,

432
00:18:27,500 --> 00:18:29,000
in SQL, there are things,

433
00:18:29,000 --> 00:18:31,325
like you can define a primary key, foreign key, right,

434
00:18:31,325 --> 00:18:32,260
you've already done that,

435
00:18:32,550 --> 00:18:34,715
SQL also has these things called constraints,

436
00:18:34,715 --> 00:18:39,130
where you can say, at all and things called checks,

437
00:18:39,210 --> 00:18:40,240
so a check might say,

438
00:18:40,380 --> 00:18:43,000
the price, I've got a price field in a table,

439
00:18:43,640 --> 00:18:45,850
and that price should never be greater than a hundred,

440
00:18:47,470 --> 00:18:48,800
and the database is required,

441
00:18:49,300 --> 00:18:51,420
whenever any updates happen to the database system

442
00:18:51,420 --> 00:18:53,360
to make sure those things hold true.

443
00:18:53,650 --> 00:18:55,250
So consistently really says,

444
00:18:56,080 --> 00:19:00,000
if the application has specified in the SQL DDL,

445
00:19:00,380 --> 00:19:03,450
all the things that they want the database to hold correct,

446
00:19:05,340 --> 00:19:08,410
then, the database transaction shouldn't mess that up.

447
00:19:09,030 --> 00:19:11,980
And the main ways in which that happens is by checks, primary keys,

448
00:19:12,090 --> 00:19:15,710
and you can also define, ah, ah, checks outside

449
00:19:15,710 --> 00:19:18,790
tables and other ways of defining constraints,

450
00:19:18,930 --> 00:19:21,010
and you really want all of that to hold.

451
00:19:21,960 --> 00:19:23,030
So it's sort of weird,

452
00:19:23,030 --> 00:19:28,565
but it says if the application has defined the structure of the database correctly,

453
00:19:28,565 --> 00:19:31,270
using everything that SQL allows with these checks,

454
00:19:31,700 --> 00:19:32,860
the transaction management,

455
00:19:33,990 --> 00:19:35,890
everything that we do here, shouldn't mess that up.

456
00:19:36,060 --> 00:19:38,710
If I said A plus B must always equal to 100

457
00:19:38,940 --> 00:19:40,270
and someone modified A,

458
00:19:41,270 --> 00:19:43,380
and modified B in the appropriate way,

459
00:19:44,210 --> 00:19:47,130
so that it is still equal to 100 in a single transaction,

460
00:19:47,390 --> 00:19:51,580
the transaction shouldn't violate anything and, and change that constraint,

461
00:19:51,580 --> 00:19:53,280
so it should maintain that correctness.

462
00:19:54,100 --> 00:19:55,035
And we'll come back to it,

463
00:19:55,035 --> 00:19:56,000
it sounds a little vague,

464
00:19:56,170 --> 00:19:57,720
but in many ways,

465
00:19:57,720 --> 00:19:59,660
that C was fitted into that ACID definition,

466
00:20:00,070 --> 00:20:02,880
because the real key things that the database done is AID,

467
00:20:02,880 --> 00:20:04,500
but if the acronym was AID,

468
00:20:04,500 --> 00:20:06,050
then it didn't sound as good as ACID,

469
00:20:06,550 --> 00:20:10,215
and this was done when hippies were ruling the Bay Area and Europe

470
00:20:10,215 --> 00:20:11,990
and they wanted acid everywhere.

471
00:20:12,310 --> 00:20:17,660
So that's the, that's my understanding of how C was plugged in.

472
00:20:18,580 --> 00:20:20,175
We'll talk about different mechanisms,

473
00:20:20,175 --> 00:20:22,790
and those are what you see in those blue bubble.

474
00:20:23,380 --> 00:20:27,710
Autonomity and durability will require this mechanism to redo and undo stuff,

475
00:20:27,970 --> 00:20:30,450
oh, I've changed A and I've pushed it out to disk,

476
00:20:30,450 --> 00:20:32,390
I've pushed it out from my buffer pool to disk,

477
00:20:32,410 --> 00:20:34,580
oh, but I need to abort that transaction,

478
00:20:35,620 --> 00:20:36,830
so how do I undo that?

479
00:20:37,400 --> 00:20:40,330
Oh, I committed a transaction with a new value of A,

480
00:20:40,330 --> 00:20:41,620
but it's still sitting my buffer pool,

481
00:20:41,620 --> 00:20:42,685
it didn't make it to disk,

482
00:20:42,685 --> 00:20:44,160
I need to redo the disk copy,

483
00:20:44,420 --> 00:20:48,190
so the redo and undo mechanisms is what the A and D provides,

484
00:20:48,190 --> 00:20:51,600
we'll use things that we'll see today and in the next lecture that cover that.

485
00:20:52,090 --> 00:20:52,790
As I said,

486
00:20:53,260 --> 00:20:58,040
consistency is provided by making sure there are integrity constraints defined in your SQL DDL

487
00:20:58,150 --> 00:21:01,070
and the transaction management system shouldn't violate that.

488
00:21:01,390 --> 00:21:04,100
Isolation is done by something called concurrency control,

489
00:21:04,210 --> 00:21:06,225
which we, which we will also look at,

490
00:21:06,225 --> 00:21:09,170
and locking and other mechanisms will come into play there.

491
00:21:09,220 --> 00:21:10,950
So we're going to dig into each one of these,

492
00:21:10,950 --> 00:21:11,810
so let's get started.

493
00:21:12,570 --> 00:21:13,960
Alright, so that's our agenda,

494
00:21:14,460 --> 00:21:16,330
dive into each of these four components.

495
00:21:17,500 --> 00:21:19,100
So, atomicity of transactions,

496
00:21:20,990 --> 00:21:24,400
there are two possible outcomes for executing a transaction,

497
00:21:24,900 --> 00:21:27,065
it either commits or it aborts, right,

498
00:21:27,065 --> 00:21:28,720
and the aborts could be explicitly,

499
00:21:29,360 --> 00:21:30,570
triggered by the application,

500
00:21:30,920 --> 00:21:34,555
or it could be something that the database is something unsafe,

501
00:21:34,555 --> 00:21:35,550
I need to abort you

502
00:21:35,810 --> 00:21:39,480
and then that transaction could restart and reissue that SQL statement,

503
00:21:40,070 --> 00:21:45,240
and the DBMS needs to provide this all or nothing [] atomic property of these transactions.

504
00:21:46,900 --> 00:21:48,555
So let's make it a little bit more concrete,

505
00:21:48,555 --> 00:21:49,730
we've been playing around with examples,

506
00:21:49,780 --> 00:21:52,820
so we look at a couple scenarios as we dig into this.

507
00:21:52,900 --> 00:21:54,590
We take 100 dollars out of an account,

508
00:21:55,270 --> 00:21:59,265
but the database system aborts the transaction before we transfer it, right,

509
00:21:59,265 --> 00:22:03,410
so we want to make sure, that that is reflected correctly.

510
00:22:03,850 --> 00:22:04,695
Scenario two is,

511
00:22:04,695 --> 00:22:06,230
we take 100 dollars out of an account,

512
00:22:06,280 --> 00:22:07,470
but then there's a power failure,

513
00:22:07,470 --> 00:22:08,570
before we transfer that.

514
00:22:08,590 --> 00:22:10,100
We've kind of seen both of these transactions,

515
00:22:10,300 --> 00:22:13,545
but just giving you more examples of what that should be,

516
00:22:13,545 --> 00:22:16,400
and, you know, we have to determine what's the correct state of the account

517
00:22:16,420 --> 00:22:18,530
after both these transaction aborts.

518
00:22:19,280 --> 00:22:22,180
So, how can we do some of this stuff,

519
00:22:23,010 --> 00:22:25,510
the atomity part can be done in one of two ways,

520
00:22:25,800 --> 00:22:27,100
logging and shadowing,

521
00:22:27,510 --> 00:22:29,860
one way is to log everything that we do,

522
00:22:30,210 --> 00:22:32,500
so if I'm recording all my actions,

523
00:22:33,330 --> 00:22:36,800
the minute I change a value from 100 to 75,

524
00:22:36,880 --> 00:22:39,570
I can record that my value was 100,

525
00:22:39,570 --> 00:22:40,515
I change it to 75,

526
00:22:40,515 --> 00:22:43,580
my before value was 100, after value is 75,

527
00:22:43,870 --> 00:22:45,350
now I can take those logs

528
00:22:45,370 --> 00:22:47,120
and I can maintain those log records

529
00:22:47,620 --> 00:22:51,530
and I can store those log records in memory

530
00:22:51,790 --> 00:22:54,350
and then appropriate points move it out to disk,

531
00:22:54,490 --> 00:22:55,860
once it moves into disk,

532
00:22:55,860 --> 00:22:57,225
I know it is going to be there,

533
00:22:57,225 --> 00:22:58,610
it will survive that power failure.

534
00:22:59,280 --> 00:23:02,120
If I don't think I can trust a single disk to hold that log,

535
00:23:02,170 --> 00:23:04,280
many times people will use disk mirroring,

536
00:23:04,450 --> 00:23:06,980
remember, we talked about disk mirroring a couple lectures ago,

537
00:23:07,090 --> 00:23:10,970
so if there are two disks that will have a copy of that same file I write,

538
00:23:11,170 --> 00:23:13,580
but it's actually being written in twice in two places,

539
00:23:13,900 --> 00:23:16,040
so that if one fails, I still have that other copy,

540
00:23:16,360 --> 00:23:19,050
that if both fail, you'd have to make a third copy and so on,

541
00:23:19,050 --> 00:23:21,320
so you have to decide what failure you can tolerate.

542
00:23:21,430 --> 00:23:23,895
But once a log hits the disk,

543
00:23:23,895 --> 00:23:25,665
you kind of know you can recover from that

544
00:23:25,665 --> 00:23:27,410
and reconstruct the state of the database.

545
00:23:28,300 --> 00:23:32,630
And we'll talk about the protocol as, as in two lectures from now,

546
00:23:32,770 --> 00:23:34,605
how we go and make that happen.

547
00:23:34,605 --> 00:23:38,360
But logging is the mechanism that most database systems will use,

548
00:23:39,160 --> 00:23:41,220
to go and record the changes that are happening.

549
00:23:43,710 --> 00:23:44,110
All right.

550
00:23:45,160 --> 00:23:46,220
Does that make sense? Questions?

551
00:23:54,415 --> 00:23:57,160
No, don't confuse this with log structured file system,

552
00:23:57,160 --> 00:23:58,110
is that what you are thinking,

553
00:23:58,400 --> 00:23:59,820
it will look like, that way is different.

554
00:23:59,840 --> 00:24:03,000
So a lot of this origin, origin in the 70 and 80s,

555
00:24:03,640 --> 00:24:05,460
it's a file of records,

556
00:24:05,930 --> 00:24:07,860
but the records are going to be variable length

557
00:24:08,180 --> 00:24:11,730
and the structure will have a certain set of common fields,

558
00:24:12,650 --> 00:24:14,640
but think of it as a file,

559
00:24:14,660 --> 00:24:16,730
with a bunch of variable,

560
00:24:17,710 --> 00:24:20,430
with some fixed length components and a whole bunch of variable,

561
00:24:20,430 --> 00:24:23,270
and it's sitting in a file that will often be called a log file

562
00:24:23,620 --> 00:24:27,255
and it's basically going to be written sequentially from first to the end,

563
00:24:27,255 --> 00:24:29,600
and it will be, it will have its own buffer management,

564
00:24:29,860 --> 00:24:33,110
so it, the recent pages will be in the buffer pool,

565
00:24:33,220 --> 00:24:35,480
at certain points, we will have to tell that,

566
00:24:35,920 --> 00:24:36,940
the buffer pool,

567
00:24:36,940 --> 00:24:37,440
to say,

568
00:24:37,520 --> 00:24:41,460
I cannot commit this transaction to this page you have here in memory,

569
00:24:41,780 --> 00:24:43,590
that needs to hit to disk,

570
00:24:44,040 --> 00:24:45,920
before I can commit this transaction,

571
00:24:46,060 --> 00:24:48,135
so we might hold the transactions commit,

572
00:24:48,135 --> 00:24:49,590
we won't return it, utill we have,

573
00:24:49,590 --> 00:24:51,860
but you can think of it as a file of records,

574
00:24:52,630 --> 00:24:55,340
just like a regular file,

575
00:24:55,450 --> 00:24:57,200
but it's got its special structure.

576
00:24:57,580 --> 00:25:04,390
Yeah, so the question is,

577
00:25:04,410 --> 00:25:06,790
if I have a log structured file system,

578
00:25:07,380 --> 00:25:08,500
do I need logging,

579
00:25:08,640 --> 00:25:10,970
a log structured file system just works for that file,

580
00:25:10,970 --> 00:25:11,885
so in a database system,

581
00:25:11,885 --> 00:25:12,970
I may have 100 tables,

582
00:25:13,170 --> 00:25:15,550
a transaction we have updated in five different places,

583
00:25:15,810 --> 00:25:19,330
I need a global log logging mechanism to deal with that.

584
00:25:19,590 --> 00:25:20,810
So traditionally what will be done,

585
00:25:20,810 --> 00:25:21,790
I have a log file,

586
00:25:21,930 --> 00:25:23,950
which is going to keep these changes,

587
00:25:24,060 --> 00:25:26,300
for all the changes that are happening across,

588
00:25:26,300 --> 00:25:27,430
not just for a single file.

589
00:25:27,750 --> 00:25:29,945
So log structured file system does make sense,

590
00:25:29,945 --> 00:25:32,590
they have similar elements to the types of mechanisms,

591
00:25:32,700 --> 00:25:35,050
that you're trying to do redo and undo type of things,

592
00:25:35,310 --> 00:25:37,060
but they are on a pool file basis,

593
00:25:37,080 --> 00:25:39,005
they may not be the right structure for it,

594
00:25:39,005 --> 00:25:40,610
they don't necessarily have all the buffer stuff,

595
00:25:40,610 --> 00:25:42,910
so it's good for certain applications and file system,

596
00:25:43,050 --> 00:25:45,130
but for database systems, we're going to need something different

597
00:25:45,330 --> 00:25:47,290
and we need it across different files, right.

598
00:25:49,200 --> 00:25:50,780
You might [pull] all our operations, too,

599
00:25:50,780 --> 00:25:52,655
so we'll talk about all of that as we go into details,

600
00:25:52,655 --> 00:25:53,560
but that's a good point,

601
00:25:53,640 --> 00:25:57,820
why am I, you know, why do the operating systems guys talk about log structured file systems,

602
00:25:57,960 --> 00:25:59,735
they're very similar elements to that,

603
00:25:59,735 --> 00:26:00,580
can we use that,

604
00:26:01,860 --> 00:26:07,205
we need to worry about transactions that update records across multiple different tables,

605
00:26:07,205 --> 00:26:09,640
which may be in multiple different files sitting in the file system,

606
00:26:09,750 --> 00:26:11,860
and still be atomic across those files,

607
00:26:11,970 --> 00:26:12,605
so it's different.

608
00:26:12,605 --> 00:26:13,595
So in many ways,

609
00:26:13,595 --> 00:26:14,465
we have to do a little bit,

610
00:26:14,465 --> 00:26:15,880
we have a harder problem to solve.

611
00:26:17,110 --> 00:26:18,020
Great question, though,

612
00:26:18,130 --> 00:26:18,770
other questions?

613
00:26:21,400 --> 00:26:21,800
Okay.

614
00:26:22,430 --> 00:26:27,570
All right, so logging is used, by nearly every database system,

615
00:26:27,800 --> 00:26:29,430
what's the alternative, you might ask,

616
00:26:29,720 --> 00:26:32,610
in the very early days before logging

617
00:26:32,810 --> 00:26:35,490
and all the details about logging where it really worked out,

618
00:26:35,870 --> 00:26:39,870
a very easy way to kind of do this stuff was to do shadow paging,

619
00:26:39,950 --> 00:26:41,910
it's like copy-on-write type of thing, right,

620
00:26:41,930 --> 00:26:45,480
and you'll see that in many applications, you'll see similar concepts by the way,

621
00:26:45,620 --> 00:26:47,050
those of you've taken operating systems

622
00:26:47,050 --> 00:26:48,445
or I've dug into that,

623
00:26:48,445 --> 00:26:52,710
I going to find a lot of common things between database systems and operating systems,

624
00:26:52,730 --> 00:26:54,715
we already hit latches and locks,

625
00:26:54,715 --> 00:26:55,810
they try to do different things,

626
00:26:55,810 --> 00:26:58,920
but a lot of database systems are going to be on larger things,

627
00:26:59,270 --> 00:27:01,050
lots of files, lots of data,

628
00:27:01,310 --> 00:27:05,400
and in some set, the mechanisms are going to be different than, in my view, often richer.

629
00:27:06,560 --> 00:27:07,890
So shadowing is,

630
00:27:08,060 --> 00:27:11,650
okay, I'm gonna make change to a record on a page,

631
00:27:11,850 --> 00:27:12,365
you know what,

632
00:27:12,365 --> 00:27:14,240
I'm just going to make a new copy of the page

633
00:27:14,240 --> 00:27:15,310
and make the changes there,

634
00:27:15,510 --> 00:27:16,925
that way, if I need to undo stuff,

635
00:27:16,925 --> 00:27:18,220
I'll just go back to the old page,

636
00:27:18,840 --> 00:27:21,710
and I've got both my before and after copy for the entire page.

637
00:27:21,970 --> 00:27:25,310
Now, of course, some systems still do that,

638
00:27:25,420 --> 00:27:26,595
but it's not a good idea,

639
00:27:26,595 --> 00:27:27,500
it's less efficient,

640
00:27:27,880 --> 00:27:31,580
if I just wanted to change one byte in one page,

641
00:27:31,660 --> 00:27:33,765
I'm going to make an entire copy of the page,

642
00:27:33,765 --> 00:27:35,090
so that's obviously wasteful.

643
00:27:35,500 --> 00:27:37,230
I still need to go and clean things up

644
00:27:37,310 --> 00:27:38,910
and merge things up others before,

645
00:27:39,110 --> 00:27:42,300
you know it, if I've got one page which has got a hot record,

646
00:27:42,800 --> 00:27:44,935
and let's say it's the counter,

647
00:27:44,935 --> 00:27:48,700
that says how many SKUs do I have for the pink Barbie doll,

648
00:27:48,700 --> 00:27:49,530
that's really popular,

649
00:27:49,850 --> 00:27:51,750
every time someone buys that Barbie doll,

650
00:27:51,830 --> 00:27:52,930
that counter will change,

651
00:27:52,930 --> 00:27:55,120
I'm going to make copies and copies of the page, right,

652
00:27:55,120 --> 00:27:56,665
so if I've got a million Barbie dolls,

653
00:27:56,665 --> 00:27:57,690
I'll have a million copies.

654
00:27:58,860 --> 00:28:01,400
By the way, counters in database systems aren't kept that way,

655
00:28:01,400 --> 00:28:04,840
they are done with more semantic components using commutative action,

656
00:28:05,100 --> 00:28:06,310
that's just a side comment,

657
00:28:06,660 --> 00:28:08,800
also an encouragement to take the advanced database class

658
00:28:09,120 --> 00:28:12,095
to talk about more complex mechanisms

659
00:28:12,095 --> 00:28:14,020
to make transactions go even faster and better.

660
00:28:15,520 --> 00:28:18,975
But you get the idea that shadow paging can very quickly,

661
00:28:18,975 --> 00:28:19,910
it's a cheap mechanism,

662
00:28:20,020 --> 00:28:22,490
easy to implement, but is problematic,

663
00:28:22,570 --> 00:28:23,510
logging is superior,

664
00:28:23,740 --> 00:28:25,580
and that's what most database systems use.

665
00:28:27,190 --> 00:28:28,650
So let's get to the C part,

666
00:28:28,650 --> 00:28:31,530
which has always been a little difficult to explain,

667
00:28:31,530 --> 00:28:33,920
but hopefully with this slide, it will start to become better.

668
00:28:34,180 --> 00:28:35,130
It's essentially saying,

669
00:28:35,130 --> 00:28:38,205
I have a contract between the database system and I

670
00:28:38,205 --> 00:28:39,860
as an application programmer.

671
00:28:40,730 --> 00:28:42,550
have a contract with you, the database system,

672
00:28:42,550 --> 00:28:44,760
that I'll tell you what I want in the application

673
00:28:45,050 --> 00:28:48,760
through my sql statement, my primary key constraints, my checks

674
00:28:48,760 --> 00:28:50,670
and other things that I want in the system

675
00:28:51,080 --> 00:28:52,770
and don't mess it up.

676
00:28:53,330 --> 00:28:55,980
if those constraint held before the transaction started,

677
00:28:56,690 --> 00:28:57,835
then the transaction ran,

678
00:28:57,835 --> 00:29:00,180
and it may have touched a million objects,

679
00:29:00,320 --> 00:29:03,270
read and write millions of objects across hundreds of tables,

680
00:29:03,860 --> 00:29:05,280
once you say it's committed,

681
00:29:05,540 --> 00:29:07,380
all those constraints must still be true.

682
00:29:08,860 --> 00:29:10,670
Okay, if one of my constraints was,

683
00:29:10,990 --> 00:29:18,780
the sum of all the columns in this, the in the price field is less than 100,

684
00:29:18,780 --> 00:29:19,610
that should still be true,

685
00:29:19,720 --> 00:29:23,250
if I say all the column A should add up to be a million

686
00:29:23,250 --> 00:29:24,470
and exactly be a million

687
00:29:24,610 --> 00:29:31,370
and lots of changes happen to different, to different values in that column A,

688
00:29:31,420 --> 00:29:32,610
that should still hold true

689
00:29:32,610 --> 00:29:34,425
that sum should still be a million at the end of it.

690
00:29:34,425 --> 00:29:36,440
And I've specified that through my constraint,

691
00:29:36,520 --> 00:29:38,030
that should still still hold true.

692
00:29:39,760 --> 00:29:44,375
Now, the transaction management is not going to do anything different,

693
00:29:44,375 --> 00:29:45,250
as you'll see,

694
00:29:45,330 --> 00:29:48,520
we just have to make sure that the atomicity holds,

695
00:29:48,870 --> 00:29:50,630
the AID components hold

696
00:29:50,630 --> 00:29:53,560
and constraint consistency will just get taken care of, right,

697
00:29:53,670 --> 00:29:54,950
if we don't mess that up.

698
00:29:54,950 --> 00:29:58,360
So that's why C kind of like plugged into this asset stuff,

699
00:29:58,530 --> 00:30:01,450
the transaction mechanisms we'll talk about today in the next two lectures,

700
00:30:01,620 --> 00:30:03,140
aren't going to directly address C,

701
00:30:03,140 --> 00:30:07,180
it's the responsibility of the application programmer to define those constraints correctly.

702
00:30:08,420 --> 00:30:10,170
To make matters even more confusing,

703
00:30:11,580 --> 00:30:13,870
a little while back close to a decade ago,

704
00:30:14,010 --> 00:30:19,900
there's all this excitement about this thing called eventual consistency,

705
00:30:20,600 --> 00:30:22,180
even though it has the word consistency,

706
00:30:22,180 --> 00:30:25,440
has nothing to do with the consistency that we just defined here as a C in acid,

707
00:30:26,530 --> 00:30:28,460
that consistency was a model saying,

708
00:30:28,690 --> 00:30:31,545
oh these transactions are hard in distributed systems,

709
00:30:31,545 --> 00:30:33,140
it becomes very tough to do that,

710
00:30:33,250 --> 00:30:34,725
though now we have figured things out

711
00:30:34,725 --> 00:30:36,920
and how to do things in distributed systems well too,

712
00:30:37,060 --> 00:30:37,755
but at that time,

713
00:30:37,755 --> 00:30:39,860
when people were building these systems

714
00:30:39,940 --> 00:30:43,760
and largely the systems were being built by people who hadn't taken a database course,

715
00:30:43,960 --> 00:30:44,780
that was the problem.

716
00:30:45,430 --> 00:30:48,470
They said the best way we can make this happen is to be eventually consistent,

717
00:30:48,790 --> 00:30:50,150
so let the changes happen

718
00:30:50,500 --> 00:30:55,010
and then eventually if a two transactions make changes to A,

719
00:30:55,240 --> 00:30:56,780
eventually they would be the same.

720
00:30:56,800 --> 00:31:00,735
So if that 25 dollars withdrawal from two accounts happening simultaneously,

721
00:31:00,735 --> 00:31:02,930
it's like eventually they will end up to be 50,

722
00:31:03,160 --> 00:31:06,110
but for a while even though both have been paid 25 dollars,

723
00:31:06,280 --> 00:31:08,180
you read the value, you will see 75,

724
00:31:08,200 --> 00:31:10,070
so the eventual consistency model is,

725
00:31:10,970 --> 00:31:13,380
don't trust the value, eventually it'll be right,

726
00:31:13,520 --> 00:31:15,660
but the question from the application perspective is,

727
00:31:15,800 --> 00:31:17,400
how long do I have to wait for it,

728
00:31:17,480 --> 00:31:20,130
and how do I know when something is right or not,

729
00:31:20,360 --> 00:31:24,010
and there were early days when people were building these applications,

730
00:31:24,010 --> 00:31:26,640
with the venture consistency where you'd have your Facebook APP,

731
00:31:26,960 --> 00:31:27,900
you'd post a message,

732
00:31:28,580 --> 00:31:30,110
and your friend would see it,

733
00:31:30,110 --> 00:31:32,170
you would refresh here and it would be gone,

734
00:31:32,220 --> 00:31:33,670
because eventually it would be there,

735
00:31:34,050 --> 00:31:36,910
but just fetched from a different server that hadn't gotten your message,

736
00:31:37,320 --> 00:31:39,190
your first connection was made to server one,

737
00:31:39,360 --> 00:31:41,380
second connection for refreshment is something else,

738
00:31:41,400 --> 00:31:42,790
it hasn't gotten the update.

739
00:31:43,260 --> 00:31:43,910
So as you can imagine,

740
00:31:44,110 --> 00:31:46,965
that became very hard for application programmers to do,

741
00:31:46,965 --> 00:31:51,840
the whole point of having database systems or data platforms deal with transactions is,

742
00:31:51,840 --> 00:31:54,620
so I, as an application programmer, don't have to deal with it.

743
00:31:55,110 --> 00:31:58,990
So it's now universally accepted, that it's a pretty bad idea,

744
00:31:59,310 --> 00:32:02,525
unless there you have very strict requirements for performance,

745
00:32:02,525 --> 00:32:04,660
that require you to do nothing but just that.

746
00:32:06,030 --> 00:32:09,430
But it is not the go to way to build data platforms by saying,

747
00:32:09,570 --> 00:32:11,920
you, the application person, start worrying about transactions.

748
00:32:15,530 --> 00:32:17,490
Bunch of systems still use eventual consistency,

749
00:32:17,720 --> 00:32:20,190
but I'll briefly flash the Spanner paper,

750
00:32:20,420 --> 00:32:22,975
which globally is using things,

751
00:32:22,975 --> 00:32:24,300
that are even stronger than ACID.

752
00:32:24,960 --> 00:32:27,230
And then again, if you take the advanced database class,

753
00:32:27,310 --> 00:32:29,990
we talk about stuff like that over there, is there.

754
00:32:30,010 --> 00:32:32,690
So it's not that systems don't use that today,

755
00:32:32,980 --> 00:32:33,920
I'm just saying,

756
00:32:34,330 --> 00:32:35,780
in my view, it's not a good idea,

757
00:32:35,980 --> 00:32:38,450
to use that as a default way to build a data platform.

758
00:32:39,120 --> 00:32:41,090
There's still some reasons why you may want to do that,

759
00:32:41,090 --> 00:32:42,560
but it's not the way you should say,

760
00:32:42,560 --> 00:32:45,605
I'm going to make my database by design eventual consistency,

761
00:32:45,605 --> 00:32:49,180
because, I didn't think of doing other ways of doing full transactions,

762
00:32:49,800 --> 00:32:50,500
their performance,

763
00:32:50,550 --> 00:32:52,835
obviously you can get more performance with eventual consistency,

764
00:32:52,835 --> 00:32:53,830
there's no doubt about that.

765
00:32:54,300 --> 00:32:55,970
Sorry for this question, but.

766
00:32:56,330 --> 00:32:58,465
I close my ears, everyone close their ears, no.

767
00:32:58,465 --> 00:33:03,445
Basically, so what is eventual consistency?

768
00:33:03,445 --> 00:33:04,290
Eventual consistency says,

769
00:33:04,490 --> 00:33:06,570
eventually all the values will be the right values.

770
00:33:07,510 --> 00:33:09,020
So, it'll feel like you got your transactions,

771
00:33:09,190 --> 00:33:11,190
but for a while, you may see inconsistent value,

772
00:33:11,190 --> 00:33:12,950
so that's what eventual consistency is.

773
00:33:13,060 --> 00:33:16,725
So an application gets there, like reaching in the []

774
00:33:16,725 --> 00:33:17,540
and it might just be wrong.

775
00:33:17,590 --> 00:33:18,450
Yeah, as I said,

776
00:33:18,450 --> 00:33:19,830
you may see 75 for a while,

777
00:33:19,830 --> 00:33:20,600
then it should be 50,

778
00:33:21,100 --> 00:33:24,920
both of you, you're standing next to each other on two side by side ATM machines,

779
00:33:25,090 --> 00:33:26,910
both of you got your 25 bucks

780
00:33:26,910 --> 00:33:29,030
and you will say, oh, 75 is in the bank,

781
00:33:29,480 --> 00:33:30,275
which is not true,

782
00:33:30,275 --> 00:33:31,280
and the bank will say,

783
00:33:31,280 --> 00:33:33,530
you know what, it was actually 50 we sent you that,

784
00:33:33,530 --> 00:33:34,870
eventually it will be the right amount.

785
00:33:35,800 --> 00:33:37,400
But as you can see, it's hard, right,

786
00:33:37,510 --> 00:33:39,060
you don't want that in your application.

787
00:33:39,060 --> 00:33:39,440
Yep.

788
00:33:40,460 --> 00:33:41,790
Yeah, another question?

789
00:33:46,210 --> 00:33:48,555
No, there are other [] has eventual consistency,

790
00:33:48,555 --> 00:33:51,350
other systems, too, have eventual consistency models.

791
00:33:56,350 --> 00:33:57,620
Put this term out, yes.

792
00:33:57,790 --> 00:34:01,580
Ah, but, but there there was a whole time where people were saying,

793
00:34:01,660 --> 00:34:02,700
we don't need SQL,

794
00:34:02,700 --> 00:34:03,470
we don't need transactions,

795
00:34:04,000 --> 00:34:08,240
no SQL, eventual consistency that hasn't quite worked out for those people.

796
00:34:09,830 --> 00:34:12,730
So I'm not saying there's no call for eventual consistency,

797
00:34:12,730 --> 00:34:15,480
I'm saying that's not what you should design for by default,

798
00:34:16,010 --> 00:34:17,250
unless you know what you're getting into,

799
00:34:17,450 --> 00:34:19,710
and now you're going to have to put the complexity in the application.

800
00:34:20,850 --> 00:34:21,250
Okay?

801
00:34:22,670 --> 00:34:24,100
So there is still some place for it,

802
00:34:24,100 --> 00:34:25,860
but not like that's not the default setting.

803
00:34:26,450 --> 00:34:29,640
So, alright, let's go find my mouse again,

804
00:34:29,720 --> 00:34:30,360
there we go.

805
00:34:32,650 --> 00:34:34,760
All right, so isolation of transactions.

806
00:34:34,930 --> 00:34:35,960
So we are still on I,

807
00:34:36,310 --> 00:34:37,220
users submit transaction,

808
00:34:37,420 --> 00:34:39,950
each transaction executes as if it is running by itself,

809
00:34:40,630 --> 00:34:43,340
and obviously it's an easier programming model as we talked about,

810
00:34:43,600 --> 00:34:45,770
and the DBMS is going to do its stuff

811
00:34:45,910 --> 00:34:50,150
to give this one-at-a-time or isolation as a principle.

812
00:34:50,320 --> 00:34:53,580
So, how does it do that?

813
00:34:54,590 --> 00:34:56,725
There are two classes of methods,

814
00:34:56,725 --> 00:34:59,710
and again today I'm just going to outline it at a high level,

815
00:34:59,710 --> 00:35:02,310
we'll get into the details of it in the next lecture.

816
00:35:02,660 --> 00:35:03,450
The two classes,

817
00:35:03,500 --> 00:35:05,820
one is pessimistic, which is to say,

818
00:35:06,520 --> 00:35:08,340
even before I let a read and write happen,

819
00:35:08,540 --> 00:35:09,865
I'm going to be pessimistic,

820
00:35:09,865 --> 00:35:11,430
if I think something bad's going to happen,

821
00:35:11,510 --> 00:35:12,640
I'm going to hold you back,

822
00:35:12,640 --> 00:35:16,080
hold you that transaction that I think is going to start this bad action back,

823
00:35:16,730 --> 00:35:20,610
and we'll see how that happens in a little bit with, with a couple of mechanisms.

824
00:35:21,600 --> 00:35:30,605
The second way is basically to do something called optimistic concurrency,

825
00:35:30,605 --> 00:35:31,210
which is to say,

826
00:35:31,470 --> 00:35:33,370
I think every life is good,

827
00:35:33,750 --> 00:35:35,830
I'm going to let every transaction go through,

828
00:35:36,400 --> 00:35:37,950
I'll still provide the isolation principle,

829
00:35:38,000 --> 00:35:40,200
so that they don't interfere with each other,

830
00:35:40,670 --> 00:35:42,390
but I'm going to do that by checking,

831
00:35:42,590 --> 00:35:44,110
assuming everything is going to go well,

832
00:35:44,110 --> 00:35:45,970
so it's like everyone go to your reads and writes,

833
00:35:45,970 --> 00:35:47,730
I'll keep track of it, go make your changes,

834
00:35:48,230 --> 00:35:49,470
but before you're ready to commit,

835
00:35:49,520 --> 00:35:50,545
I will do some checks

836
00:35:50,545 --> 00:35:52,195
to see if you guys interfered with each other,

837
00:35:52,195 --> 00:35:52,920
all of you guys,

838
00:35:53,030 --> 00:35:55,890
all of you transactions that were running together simultaneously.

839
00:35:56,340 --> 00:36:00,220
So optimistic is most transactions don't conflict with each other,

840
00:36:00,390 --> 00:36:03,910
so I can get a higher performance system by being optimistic,

841
00:36:04,110 --> 00:36:05,500
that most things will work out,

842
00:36:05,640 --> 00:36:06,730
It will still be correct,

843
00:36:07,050 --> 00:36:08,530
so it will make sure bad things don't happen,

844
00:36:08,640 --> 00:36:09,640
but it's a different philosophy.

845
00:36:12,890 --> 00:36:14,680
All right, so.

846
00:36:20,440 --> 00:36:22,190
Let's start digging into a couple of examples.

847
00:36:22,300 --> 00:36:27,020
Now, as we know, transactions are going to be cast in terms of these read write operations

848
00:36:27,280 --> 00:36:31,170
and now you're starting to see some of the BEGIN and COMMIT calls that are coming in.

849
00:36:31,170 --> 00:36:32,210
So, T1 is a transaction,

850
00:36:32,740 --> 00:36:33,855
that subtracting,

851
00:36:33,855 --> 00:36:36,890
that moving 100 dollars from bank account A to bank account B,

852
00:36:37,210 --> 00:36:39,110
and T2 is a transaction,

853
00:36:39,220 --> 00:36:42,540
that's adding 6% interest to all the bank accounts

854
00:36:42,540 --> 00:36:44,310
and assume this is a small bank,

855
00:36:44,310 --> 00:36:45,680
so it just has two bank accounts,

856
00:36:47,860 --> 00:36:49,100
also keeps the example simple.

857
00:36:50,300 --> 00:36:52,440
What's the possible outcome of running these two?

858
00:36:53,320 --> 00:36:54,620
The two possible outcomes.

859
00:36:55,340 --> 00:36:55,950
One is,

860
00:36:57,780 --> 00:36:59,770
assume both A and B, start with 1000 dollars,

861
00:37:00,660 --> 00:37:05,410
if I run A followed by B or B followed by A,

862
00:37:05,550 --> 00:37:09,610
I'm going to get two different execution strategies,

863
00:37:10,110 --> 00:37:15,050
but eventually A plus B should be 2000 and 6%,

864
00:37:15,050 --> 00:37:17,800
of that means that the total bank account,

865
00:37:18,380 --> 00:37:19,380
across those two banks,

866
00:37:20,170 --> 00:37:22,160
should be 2120.

867
00:37:23,470 --> 00:37:26,290
So, that's what we want to end up with.

868
00:37:26,740 --> 00:37:30,790
Now, what we are going to look at next,

869
00:37:30,810 --> 00:37:32,770
I'm just going to jump into this is,

870
00:37:34,080 --> 00:37:35,530
with just these two transactions,

871
00:37:36,420 --> 00:37:39,760
I could have a correct isolation property being held

872
00:37:40,200 --> 00:37:43,210
by either running the first transaction first,

873
00:37:43,920 --> 00:37:46,390
and running the second transaction first,

874
00:37:46,440 --> 00:37:47,570
there are two possible outcomes,

875
00:37:47,570 --> 00:37:50,710
T1 runs first followed by T2 or vice versa.

876
00:37:50,880 --> 00:37:52,240
And so here you can see,

877
00:37:52,350 --> 00:37:57,820
one example, where the value of A is 954 and B is 1166,

878
00:37:57,900 --> 00:38:02,230
that will correspond to having done the 100 dollars transfer first, then adding 6%,

879
00:38:02,790 --> 00:38:04,930
and the other one is doing it the other way around.

880
00:38:06,350 --> 00:38:09,490
So either one of those by the isolation principle is correct,

881
00:38:09,490 --> 00:38:12,210
if both transactions are in the system at the same time,

882
00:38:12,530 --> 00:38:13,350
we are okay,

883
00:38:13,370 --> 00:38:15,030
we as a transaction management system

884
00:38:15,140 --> 00:38:16,465
are okay in picking that order,

885
00:38:16,465 --> 00:38:18,900
so let's just look at it more visually

886
00:38:19,070 --> 00:38:20,220
and that might make sense.

887
00:38:21,320 --> 00:38:23,280
There is this notion of a serial execution,

888
00:38:23,940 --> 00:38:27,860
and the serial execution diagram that we'll see in the next 10 or 15 slides,

889
00:38:28,150 --> 00:38:31,400
all are going to have time going from top to the bottom,

890
00:38:31,840 --> 00:38:33,470
so, imagine you are the machine

891
00:38:33,640 --> 00:38:35,570
and you're watching transactions come at you.

892
00:38:36,100 --> 00:38:38,300
And isolation basically says,

893
00:38:38,470 --> 00:38:40,580
if this execution is such that,

894
00:38:40,840 --> 00:38:43,035
you can show me, prove to me,

895
00:38:43,035 --> 00:38:44,180
that no matter what you do,

896
00:38:44,500 --> 00:38:45,840
whichever order you allowed the transaction,

897
00:38:45,840 --> 00:38:47,780
it feels like one happened before the other

898
00:38:48,040 --> 00:38:49,910
and that one happened before the other could be,

899
00:38:49,930 --> 00:38:52,640
all of T1 happened followed by T2, in this case,

900
00:38:53,020 --> 00:38:54,300
which is the example on the left,

901
00:38:54,300 --> 00:38:58,280
which is when you end up with A equal to 954 and B is 1166

902
00:38:58,540 --> 00:39:00,240
or T2 followed by that,

903
00:39:00,240 --> 00:39:01,160
both of them are correct.

904
00:39:01,580 --> 00:39:04,980
But if you are going to intervene these reads and writes for these two transactions,

905
00:39:05,810 --> 00:39:09,870
the database better end up with one of these two correct end states,

906
00:39:10,500 --> 00:39:12,750
which one, doesn't matter,

907
00:39:12,860 --> 00:39:14,160
but it should be one of those two,

908
00:39:14,210 --> 00:39:15,510
not, not something else.

909
00:39:15,800 --> 00:39:16,200
Question?

910
00:39:16,340 --> 00:39:28,770
No, that's the whole point.

911
00:39:28,770 --> 00:39:29,510
So the question is,

912
00:39:29,620 --> 00:39:30,945
why are we doing this in parallel,

913
00:39:30,945 --> 00:39:31,760
that's the whole point.

914
00:39:32,230 --> 00:39:33,720
Right now, this a serial execution,

915
00:39:33,720 --> 00:39:35,600
so T1 happening after T2 in time,

916
00:39:35,680 --> 00:39:36,780
but what we want to do is,

917
00:39:36,780 --> 00:39:40,520
to imagine I've got two cores in this server

918
00:39:40,750 --> 00:39:42,435
and today's servers have 40 cores

919
00:39:42,435 --> 00:39:44,690
and database machines sometimes have hundreds of machines,

920
00:39:45,210 --> 00:39:47,180
I don't want to be just running one transaction at a time,

921
00:39:47,180 --> 00:39:50,890
I want to be able to do as many actions at any given point in time,

922
00:39:51,030 --> 00:39:52,540
I want to do as many things as possible,

923
00:39:53,590 --> 00:39:55,815
because I want to use all the hardware I have access to,

924
00:39:55,815 --> 00:39:57,800
that way I can get more transactions in the system,

925
00:39:58,030 --> 00:40:00,530
higher throughput and lower latency potentially.

926
00:40:03,660 --> 00:40:05,330
No, no, no, we will not lower the standard,

927
00:40:05,330 --> 00:40:07,270
so hold on, we will not lower the standard,

928
00:40:07,620 --> 00:40:11,230
we are definitely changing the standard a little bit

929
00:40:11,280 --> 00:40:16,180
to say any permutation of T1 followed by T2 is allowed, T2,

930
00:40:16,320 --> 00:40:17,750
T1 and T2 can be interchanged,

931
00:40:17,750 --> 00:40:21,980
as long as we can prove one did all of its work before the other.

932
00:40:21,980 --> 00:40:23,170
So hold on for two slides,

933
00:40:23,400 --> 00:40:26,630
you're right, it's like why is it not only one possible way,

934
00:40:26,630 --> 00:40:28,330
that T1 should be followed by T2,

935
00:40:28,470 --> 00:40:29,315
if we did that,

936
00:40:29,315 --> 00:40:32,530
then we would allow less parallelism in the system.

937
00:40:33,090 --> 00:40:36,425
So you're going to relax the strict notion of what is correct

938
00:40:36,425 --> 00:40:41,290
and this is where there's this notion of strict serializable,

939
00:40:41,370 --> 00:40:42,130
which will say,

940
00:40:42,360 --> 00:40:44,375
the transactions should feel like,

941
00:40:44,375 --> 00:40:47,890
they [] in the way in which they happen in the physical world,

942
00:40:47,940 --> 00:40:50,650
we'll talk about that in the next class a little bit,

943
00:40:50,760 --> 00:40:53,590
and we'll talk about it a lot more in the advanced database class.

944
00:40:54,560 --> 00:40:56,460
First, let's get a little bit write,

945
00:40:56,930 --> 00:40:59,460
and this is, by the way, of what most database systems do today,

946
00:40:59,630 --> 00:41:03,055
they will take this slight liberty of [] it,

947
00:41:03,055 --> 00:41:05,275
because it's also like T1 and T2 issued at the same time,

948
00:41:05,275 --> 00:41:07,650
what does it even mean for it to be issued at the same time,

949
00:41:07,700 --> 00:41:09,510
they may be in different cities,

950
00:41:09,710 --> 00:41:10,945
if you're sitting next to each other,

951
00:41:10,945 --> 00:41:14,125
it's not as if you would be pressing the button exactly at the same second,

952
00:41:14,125 --> 00:41:15,180
because that doesn't happen,

953
00:41:15,950 --> 00:41:17,640
so it's like what does simultaneous mean.

954
00:41:17,780 --> 00:41:19,375
So we're going to be a little bit more relaxed,

955
00:41:19,375 --> 00:41:20,815
all we have is to say

956
00:41:20,815 --> 00:41:23,070
for us to be have this proper isolation,

957
00:41:23,180 --> 00:41:25,350
the final values should be one of these two,

958
00:41:25,800 --> 00:41:26,555
not a third value.

959
00:41:26,555 --> 00:41:28,210
Look at this slide here first, yep,

960
00:41:28,800 --> 00:41:34,390
so here T T1 starts and does its subtraction of 100,

961
00:41:34,710 --> 00:41:37,690
so now A has the 100 dollars already removed,

962
00:41:37,860 --> 00:41:42,310
T2 starts and gives 6% interest to the two bank accounts,

963
00:41:42,600 --> 00:41:47,770
but the bank account value for A that it is looking at is 100 dollars short,

964
00:41:48,030 --> 00:41:51,790
and so it ends up with a value of 2114 as the sum total,

965
00:41:52,200 --> 00:41:55,750
which is 6 dollars off from what that original about should be.

966
00:41:56,550 --> 00:41:58,810
So what we want to allow is these two,

967
00:41:58,830 --> 00:42:01,720
the interleaving in the previous slide that is safe,

968
00:42:01,950 --> 00:42:04,900
where you end up with the correct value, even though there's interleaving,

969
00:42:04,980 --> 00:42:08,020
but this is an example of an unsafe interleaving,

970
00:42:08,040 --> 00:42:10,525
where you ended up with the wrong value, right.

971
00:42:10,525 --> 00:42:11,790
So this is fine,

972
00:42:12,320 --> 00:42:15,330
sorry, I was here on the wrong slide here,

973
00:42:16,160 --> 00:42:16,825
this is fine,

974
00:42:16,825 --> 00:42:19,500
and the question is how do we determine that this is okay,

975
00:42:20,160 --> 00:42:23,770
this type of interleaving of actions across different transactions is okay,

976
00:42:24,090 --> 00:42:25,420
but this one is not.

977
00:42:27,070 --> 00:42:27,470
Okay?

978
00:42:28,205 --> 00:42:29,770
So let's look at, how we go about doing that.

979
00:42:30,300 --> 00:42:32,360
So there's this formal notion of serial schedule,

980
00:42:32,740 --> 00:42:36,870
that says a schedule that does not interleave any of the action.

981
00:42:36,870 --> 00:42:37,890
So we saw that, right,

982
00:42:37,890 --> 00:42:40,935
a serial example of, a serial schedule was one,

983
00:42:40,935 --> 00:42:44,030
where you just had all the T1s,

984
00:42:44,410 --> 00:42:45,890
like here is a serial schedule,

985
00:42:46,210 --> 00:42:46,965
so if we go back,

986
00:42:46,965 --> 00:42:48,020
this is a serial schedule,

987
00:42:48,310 --> 00:42:52,460
T1 followed by T2 or T2 followed by T T1.

988
00:42:53,090 --> 00:42:56,800
Okay, now the thing that we are trying to get to,

989
00:42:56,800 --> 00:42:59,970
the harder part is an equivalent schedule.

990
00:43:01,800 --> 00:43:06,550
So here was a schedule that we saw that was correct,

991
00:43:07,260 --> 00:43:08,270
it is not serial,

992
00:43:08,940 --> 00:43:10,160
but as you'll see, this is correct

993
00:43:10,480 --> 00:43:12,470
and we want to look at this schedule

994
00:43:12,790 --> 00:43:18,675
and say the one on the left is equivalent to the serial schedule on the right,

995
00:43:18,675 --> 00:43:21,420
we want to be able to show that happens

996
00:43:21,420 --> 00:43:22,215
and in which case,

997
00:43:22,215 --> 00:43:24,290
we'll say that schedule is safe and that's allowed.

998
00:43:24,550 --> 00:43:27,830
So the notion of equivalent schedule says,

999
00:43:27,940 --> 00:43:29,090
allow some interleaving,

1000
00:43:30,330 --> 00:43:32,950
and as long as you can prove that the interleaving is safe,

1001
00:43:34,450 --> 00:43:36,740
and the proof of safety is going to be by saying

1002
00:43:36,970 --> 00:43:40,400
all these actions are equivalent to some serial schedule,

1003
00:43:40,660 --> 00:43:42,285
in this case, one of those two,

1004
00:43:42,285 --> 00:43:44,900
T1 followed by T2, or T2 followed by T1,

1005
00:43:45,160 --> 00:43:45,945
you are okay,

1006
00:43:45,945 --> 00:43:47,300
you will end up with the correct answer.

1007
00:43:48,250 --> 00:43:49,400
So it sounds like magic,

1008
00:43:50,020 --> 00:43:54,740
but there's a very simple way to go figure that out.

1009
00:43:55,510 --> 00:43:57,465
And this is the part that you were asking about,

1010
00:43:57,465 --> 00:44:00,170
is like, okay, but why are the two correct states of the database,

1011
00:44:00,670 --> 00:44:04,880
and that's really what we are relaxing a little bit in this notion of serializable,

1012
00:44:04,900 --> 00:44:05,535
and as I said,

1013
00:44:05,535 --> 00:44:07,140
there's a two sort of strict serializable,

1014
00:44:07,140 --> 00:44:09,050
where that real world effect is taken into place,

1015
00:44:09,190 --> 00:44:10,190
it's stricter,

1016
00:44:10,330 --> 00:44:12,525
but for the purpose of this class,

1017
00:44:12,525 --> 00:44:14,000
we're going to work with this notion,

1018
00:44:14,380 --> 00:44:18,990
that we just have to prove it equivalent to one of the many equivalent serial schedules.

1019
00:44:18,990 --> 00:44:19,790
And if you have two transactions,

1020
00:44:20,200 --> 00:44:21,740
there only two possible outcomes,

1021
00:44:21,790 --> 00:44:23,930
if there were three, T1, T2, T3,

1022
00:44:24,070 --> 00:44:24,830
it could be,

1023
00:44:25,310 --> 00:44:27,270
first transaction could be either one of those,

1024
00:44:27,530 --> 00:44:28,830
there are three possible combinations,

1025
00:44:29,240 --> 00:44:30,895
then two, then one, right,

1026
00:44:30,895 --> 00:44:33,120
so you you get that factorial effect.

1027
00:44:34,300 --> 00:44:36,110
We're going to think about these reads writes

1028
00:44:36,160 --> 00:44:41,470
in terms of conflicting actions, that can happen between these objects,

1029
00:44:42,090 --> 00:44:43,960
like the As and the Bs and the Cs.

1030
00:44:44,520 --> 00:44:46,090
So we are going to have,

1031
00:44:46,880 --> 00:44:48,810
we call these things anomalies,

1032
00:44:49,160 --> 00:44:50,880
and there are three different types,

1033
00:44:51,230 --> 00:44:52,630
a read could interfere,

1034
00:44:52,630 --> 00:44:57,210
with a transaction, reads an object and something else writes to it,

1035
00:44:57,810 --> 00:45:01,570
or a transaction writes an object and someone else reads that object,

1036
00:45:02,140 --> 00:45:03,980
the third one is two transaction,

1037
00:45:04,120 --> 00:45:08,180
transaction one writes to an object and the other transaction also writes to that object.

1038
00:45:08,640 --> 00:45:10,640
What is missing from this combination is read, read,

1039
00:45:11,260 --> 00:45:12,560
which is obviously not a conflict,

1040
00:45:12,880 --> 00:45:14,660
if I'm just reading this two transactions,

1041
00:45:14,830 --> 00:45:16,550
if I've just got a copy that's read only,

1042
00:45:17,080 --> 00:45:18,405
many transactions could read it,

1043
00:45:18,405 --> 00:45:19,880
you're not going to conflict with each other,

1044
00:45:20,080 --> 00:45:21,560
it's, it's a read only copy.

1045
00:45:22,350 --> 00:45:27,940
Alright, so let's take these read-write conflicts and go look at that.

1046
00:45:28,540 --> 00:45:29,220
Here is a schedule,

1047
00:45:30,060 --> 00:45:33,320
in which there is a read of an object A,

1048
00:45:33,460 --> 00:45:35,640
followed by a write of an object A,

1049
00:45:35,640 --> 00:45:37,580
as these actions got interleaved,

1050
00:45:37,720 --> 00:45:43,880
and so that would be an example of a read write conflict.

1051
00:45:44,560 --> 00:45:46,440
There are other conflicts in the schedule, too,

1052
00:45:47,090 --> 00:45:51,000
but, but what's the downside of this read-write object conflict,

1053
00:45:51,530 --> 00:45:53,550
transaction one read the value A,

1054
00:45:54,680 --> 00:45:55,470
T2 run,

1055
00:45:56,850 --> 00:45:59,410
and then T1 reads that value and got a different value,

1056
00:45:59,550 --> 00:46:00,700
So it was 10 before,

1057
00:46:01,170 --> 00:46:02,290
T2 made it 19,

1058
00:46:03,000 --> 00:46:04,240
T1 reads it again.

1059
00:46:04,260 --> 00:46:06,730
And obviously it has not seen the isolation principle,

1060
00:46:06,960 --> 00:46:07,810
in the same transaction,

1061
00:46:08,250 --> 00:46:09,610
if I read the value twice,

1062
00:46:09,750 --> 00:46:10,960
I should see the same value

1063
00:46:11,100 --> 00:46:12,700
unless someone else interfered with me.

1064
00:46:12,780 --> 00:46:15,220
So it violates the isolation principle.

1065
00:46:15,750 --> 00:46:16,810
And so this is that.

1066
00:46:21,190 --> 00:46:24,920
Alright, let's a look at the,

1067
00:46:25,990 --> 00:46:27,735
and so that's called unrepeatable read,

1068
00:46:27,735 --> 00:46:29,090
because when you have a read-write conflict,

1069
00:46:29,440 --> 00:46:31,200
same transaction reads the value twice,

1070
00:46:31,200 --> 00:46:32,330
it's going to see different values.

1071
00:46:33,100 --> 00:46:34,135
A dirty read is,

1072
00:46:34,135 --> 00:46:36,240
I read a value, let's say this 10,

1073
00:46:36,650 --> 00:46:38,100
write it to be 12,

1074
00:46:38,600 --> 00:46:40,950
someone else reads the value, which is 12,

1075
00:46:41,960 --> 00:46:42,900
so far, no problem,

1076
00:46:43,310 --> 00:46:45,580
but what happens a little bit later is that,

1077
00:46:45,580 --> 00:46:46,770
transaction T1 aborts

1078
00:46:47,240 --> 00:46:48,925
and when transaction T1 aborts,

1079
00:46:48,925 --> 00:46:50,815
that value 12 should never have been read,

1080
00:46:50,815 --> 00:46:52,555
because it didn't get committed to the database,

1081
00:46:52,555 --> 00:46:55,720
it was an intermediate value, which is getting thrown away, right,

1082
00:46:55,720 --> 00:46:57,360
that's what abort should do.

1083
00:46:57,560 --> 00:46:59,880
And so now transaction T2,

1084
00:47:00,050 --> 00:47:01,560
when it was reading the value A,

1085
00:47:01,700 --> 00:47:03,000
read a dirty value,

1086
00:47:03,230 --> 00:47:04,860
which should have never been in the database,

1087
00:47:06,170 --> 00:47:07,020
because of that abort.

1088
00:47:07,040 --> 00:47:08,280
So that's called a dirty read.

1089
00:47:10,350 --> 00:47:11,740
A write-write conflict is,

1090
00:47:11,970 --> 00:47:13,540
T1 is writing a value,

1091
00:47:14,760 --> 00:47:17,260
T2 is also writing that value

1092
00:47:17,730 --> 00:47:22,915
and when T1 writes another value B,

1093
00:47:22,915 --> 00:47:25,200
T1 it feels like it's writing 10 dollars,

1094
00:47:25,730 --> 00:47:27,780
imagine A and B are now columns

1095
00:47:27,980 --> 00:47:32,010
and it's updating a record where dollar 10 is in Alice's account,

1096
00:47:32,700 --> 00:47:37,900
and it's column one is 10, the account, yeah, amount,

1097
00:47:38,070 --> 00:47:39,580
and B is the name of the person,

1098
00:47:39,810 --> 00:47:41,260
it thinks it's adding 10 to Alice,

1099
00:47:41,490 --> 00:47:43,700
but the other conflict over there is

1100
00:47:43,700 --> 00:47:45,700
writing to that same record, 19 and Bob.

1101
00:47:45,810 --> 00:47:47,500
So you have 10 in there,

1102
00:47:47,580 --> 00:47:50,320
19 and Bob got written to that same record,

1103
00:47:50,550 --> 00:47:53,800
and then you have this Alice, B that is written,

1104
00:47:53,910 --> 00:47:56,770
that update of 19 and Bob just got overwritten.

1105
00:47:57,460 --> 00:47:59,625
So transaction two did its work,

1106
00:47:59,625 --> 00:48:01,310
but its values just got overwritten,

1107
00:48:01,390 --> 00:48:02,820
so it lost its update,

1108
00:48:02,820 --> 00:48:04,520
it never got made, it made it to the database.

1109
00:48:06,050 --> 00:48:06,450
Okay?

1110
00:48:08,040 --> 00:48:13,180
So we use these properties to then define,

1111
00:48:13,710 --> 00:48:17,950
how to go make this equivalent schedule work.

1112
00:48:18,550 --> 00:48:23,240
The two types of serializability, conflict serializability,

1113
00:48:23,240 --> 00:48:24,340
which we'll talk about next,

1114
00:48:24,750 --> 00:48:26,440
something called View serializability,

1115
00:48:26,760 --> 00:48:27,815
since we are running out of time,

1116
00:48:27,815 --> 00:48:29,870
I might just totally go skip that piece,

1117
00:48:29,870 --> 00:48:31,720
but I'll briefly allude to what that does.

1118
00:48:31,980 --> 00:48:36,160
Okay, won't grill you with exam questions on view serializability, okay,

1119
00:48:36,360 --> 00:48:38,300
so it's okay, if you don't totally get that,

1120
00:48:38,300 --> 00:48:41,170
conflict serializabilities was database systems implement

1121
00:48:41,430 --> 00:48:42,850
and let's just jump into that.

1122
00:48:44,190 --> 00:48:46,505
Let me just go with this graph form here

1123
00:48:46,505 --> 00:48:48,640
to make it even more easier to understand.

1124
00:48:48,840 --> 00:48:50,230
So what we'll do is the following.

1125
00:48:50,920 --> 00:48:52,740
We take operations that we have,

1126
00:48:53,620 --> 00:48:56,490
and here is the schedule that we have,

1127
00:48:57,210 --> 00:48:58,700
we will start going through that

1128
00:48:58,700 --> 00:49:01,690
and enumerate all possible conflicts,

1129
00:49:02,040 --> 00:49:04,810
read-write, write-write and write-read,

1130
00:49:05,160 --> 00:49:06,430
okay, those three conflicts.

1131
00:49:06,720 --> 00:49:10,070
We create a graph called the dependence graph,

1132
00:49:10,640 --> 00:49:13,000
so I've got two nodes in that graph, T1 and T2,

1133
00:49:13,080 --> 00:49:15,400
every time a transaction comes in, a new node will be added,

1134
00:49:15,660 --> 00:49:17,080
so the graph will have as many transactions,

1135
00:49:17,220 --> 00:49:19,840
that are active in the system at any point in time.

1136
00:49:20,610 --> 00:49:22,960
Now I'll just start going through the schedule

1137
00:49:23,460 --> 00:49:25,720
and start marking all the conflicts,

1138
00:49:26,280 --> 00:49:29,940
and I start with the first conflict that I see,

1139
00:49:29,940 --> 00:49:30,830
which is a read-write,

1140
00:49:31,850 --> 00:49:33,480
doesn't matter what the conflict is,

1141
00:49:33,530 --> 00:49:36,060
as soon as I have one of those three types of conflict,

1142
00:49:36,230 --> 00:49:38,250
read-write, write-write or write-read,

1143
00:49:38,600 --> 00:49:40,290
I'm going to put an arrow there,

1144
00:49:40,670 --> 00:49:45,920
so the first conflict A is on this object A

1145
00:49:46,150 --> 00:49:48,645
and it goes from T1 to T2,

1146
00:49:48,645 --> 00:49:51,830
because T1 happens before T2 in the schedule, right,

1147
00:49:52,340 --> 00:49:55,180
so I'll draw a directed arc from T1 to T2.

1148
00:49:56,360 --> 00:49:57,180
Does that make sense?

1149
00:49:57,530 --> 00:49:58,440
So, really simple,

1150
00:49:58,760 --> 00:50:01,350
I'm going to just walk through this,

1151
00:50:01,490 --> 00:50:03,000
for every conflict that I have,

1152
00:50:03,050 --> 00:50:06,600
I'll draw a directed graph in the order in which this conflict is happening.

1153
00:50:09,130 --> 00:50:13,190
Now I go and find the next conflict,

1154
00:50:14,040 --> 00:50:16,160
which is this write followed by read,

1155
00:50:16,510 --> 00:50:18,110
and I will do that.

1156
00:50:19,610 --> 00:50:21,870
So the proof is really simple,

1157
00:50:22,890 --> 00:50:23,890
you take a schedule,

1158
00:50:25,130 --> 00:50:26,670
if you walk through it

1159
00:50:26,930 --> 00:50:33,450
and draw a line for every read-write, write-write or write-read conflict,

1160
00:50:35,150 --> 00:50:38,270
and if it, there's a cycle in that graph,

1161
00:50:38,560 --> 00:50:40,700
you have a bad schedule,

1162
00:50:41,550 --> 00:50:44,710
that schedule will violate the isolation principle,

1163
00:50:45,180 --> 00:50:49,180
that schedule should never have been allowed to run in the database system.

1164
00:50:49,790 --> 00:50:50,605
In the next class,

1165
00:50:50,605 --> 00:50:54,300
we'll see mechanisms that you can use to prevent that from ever happening.

1166
00:50:55,980 --> 00:50:56,830
Does that make sense,

1167
00:50:57,180 --> 00:50:59,645
if you didn't get anything else because of that bug in the slide,

1168
00:50:59,645 --> 00:51:02,740
that's the main thing I want you to get from this isolation principle.

1169
00:51:03,740 --> 00:51:04,360
What direction?

1170
00:51:05,960 --> 00:51:08,215
The edges go in the time order,

1171
00:51:08,215 --> 00:51:10,930
see, so look at the write followed by read,

1172
00:51:10,930 --> 00:51:12,720
the red line that is shown here right now,

1173
00:51:13,910 --> 00:51:15,895
it's going from T1 to T2, right,

1174
00:51:15,895 --> 00:51:19,380
the read, the write in A happened before the read in T2,

1175
00:51:20,110 --> 00:51:22,725
so I will draw a directed line from T1 to T2,

1176
00:51:22,725 --> 00:51:27,820
saying some action in T1 happens before the action in T2,

1177
00:51:28,320 --> 00:51:30,755
which means T2 better not do stuff,

1178
00:51:30,755 --> 00:51:31,835
that is the other way around,

1179
00:51:31,835 --> 00:51:34,400
because now I've got a contradictory state,

1180
00:51:34,400 --> 00:51:35,560
that I'm going to end up with.

1181
00:51:36,460 --> 00:51:36,860
Okay?

1182
00:51:37,460 --> 00:51:40,030
So the serial schedule is, the schedule is the,

1183
00:51:40,050 --> 00:51:41,345
the time on the left side is

1184
00:51:41,345 --> 00:51:43,420
the order in which a database is seeing those actions.

1185
00:51:43,920 --> 00:51:45,440
And let's come to construct this graph,

1186
00:51:45,440 --> 00:51:47,110
and what we'll see in the next class is,

1187
00:51:47,460 --> 00:51:48,940
the [] is starts to say,

1188
00:51:48,960 --> 00:51:51,785
the second stuff which is going to cause this graph to complete,

1189
00:51:51,785 --> 00:51:52,445
it will stop,

1190
00:51:52,445 --> 00:51:53,470
it won't let,

1191
00:51:53,640 --> 00:51:56,530
it will basically not let this thing proceed,

1192
00:51:57,060 --> 00:51:58,100
beyond the write of B,

1193
00:51:58,100 --> 00:52:00,250
because it says, if I allow this write to happen,

1194
00:52:00,780 --> 00:52:02,060
this arc to form,

1195
00:52:02,140 --> 00:52:03,030
I will have a conflict,

1196
00:52:03,030 --> 00:52:03,890
so this line,

1197
00:52:03,910 --> 00:52:04,935
it will pause that,

1198
00:52:04,935 --> 00:52:08,265
it will stop transaction T1 from proceeding

1199
00:52:08,265 --> 00:52:10,220
with the techniques we'll talk about in the next class.

1200
00:52:13,030 --> 00:52:13,350
Yep.

1201
00:52:13,350 --> 00:52:16,680
Does it need to what?

1202
00:52:18,800 --> 00:52:21,630
Yeah, and then it may need to abort something or delay something,

1203
00:52:21,680 --> 00:52:23,280
so we'll, we'll talk about that, right,

1204
00:52:23,360 --> 00:52:25,405
so there are sometimes where it may just say,

1205
00:52:25,405 --> 00:52:26,550
you know what, I need to abort

1206
00:52:27,440 --> 00:52:28,710
and I can't go any further.

1207
00:52:29,640 --> 00:52:31,240
Alright, so it's really that simple.

1208
00:52:31,940 --> 00:52:33,935
We will construct this graph and

1209
00:52:33,935 --> 00:52:36,395
now we have this beautiful proof that says,

1210
00:52:36,395 --> 00:52:40,420
how do I have correct isolation property.

1211
00:52:41,860 --> 00:52:44,390
All right, so here is three transactions,

1212
00:52:45,760 --> 00:52:48,650
just to show this in a slightly more complicated way.

1213
00:52:50,530 --> 00:52:51,500
As I walk down,

1214
00:52:51,520 --> 00:52:54,470
the first conflict is that read to write,

1215
00:52:54,520 --> 00:52:55,845
there are other conflicts in there,

1216
00:52:55,845 --> 00:52:58,280
there's a W(A) at T1 to read an A,

1217
00:52:58,420 --> 00:53:00,830
I'm not showing every possible conflict in there,

1218
00:53:01,000 --> 00:53:04,730
but both of them induce arc from T1 to T2,

1219
00:53:06,040 --> 00:53:07,190
it's just a hazard,

1220
00:53:07,930 --> 00:53:09,870
and then there are other conflicts,

1221
00:53:09,870 --> 00:53:11,570
but that will just redo that same line,

1222
00:53:11,770 --> 00:53:13,820
you don't have to redraw that line multiple times,

1223
00:53:14,020 --> 00:53:16,245
one arc is, one arc is enough, right.

1224
00:53:16,245 --> 00:53:17,240
That's all this is showing,

1225
00:53:17,530 --> 00:53:18,590
as you go further down,

1226
00:53:18,730 --> 00:53:22,100
we see another conflict from T2 to T1,

1227
00:53:25,420 --> 00:53:27,640
and that's all there is in here.

1228
00:53:28,570 --> 00:53:29,840
So this basically says,

1229
00:53:30,750 --> 00:53:32,110
in this schedule,

1230
00:53:33,450 --> 00:53:37,120
even though there's a bunch of interleaving going on between the three transactions,

1231
00:53:37,830 --> 00:53:39,490
this you can prove to be correct.

1232
00:53:40,890 --> 00:53:44,050
And can you guess what's the correct serial schedule,

1233
00:53:46,950 --> 00:53:47,740
look at the graph.

1234
00:53:49,970 --> 00:53:52,350
Yeah, it's going to be the order of that graph,

1235
00:53:52,670 --> 00:53:55,370
T2, it's like T2 happened first,

1236
00:53:56,600 --> 00:53:58,050
then T1 happened,

1237
00:53:58,850 --> 00:53:59,920
then T3 happened,

1238
00:53:59,920 --> 00:54:04,675
whoops, it's as if that was the serial order in which they were executed

1239
00:54:04,675 --> 00:54:06,810
and we were just running one transaction at a time.

1240
00:54:08,310 --> 00:54:09,580
And that's the whole idea,

1241
00:54:10,020 --> 00:54:11,870
now, if you get why this graph makes sense,

1242
00:54:11,870 --> 00:54:12,485
it's trivial,

1243
00:54:12,485 --> 00:54:14,315
but it took a little while for people to figure this out,

1244
00:54:14,315 --> 00:54:15,340
it wasn't that trivial,

1245
00:54:15,480 --> 00:54:17,500
and that's what many of these beautiful ideas are,

1246
00:54:17,550 --> 00:54:19,360
they seem simple only in retrospect.

1247
00:54:22,170 --> 00:54:24,640
So, forget everything I said with that bug in the slide,

1248
00:54:24,990 --> 00:54:26,030
this, if you get it,

1249
00:54:26,030 --> 00:54:27,850
you understand how isolation works.

1250
00:54:39,790 --> 00:54:43,010
Yeah, and we'll talk about aborts and other kinds of special handling in there,

1251
00:54:43,030 --> 00:54:44,270
but what is true is that,

1252
00:54:44,290 --> 00:54:45,510
even before the abort,

1253
00:54:45,510 --> 00:54:46,590
if you start to see a cycle,

1254
00:54:46,590 --> 00:54:48,530
you know you will end up in a bad situation,

1255
00:54:48,640 --> 00:54:49,700
so you need to stop it.

1256
00:54:52,960 --> 00:54:54,530
Because time is evolving,

1257
00:54:54,880 --> 00:54:56,960
I as the database transaction manager,

1258
00:54:57,670 --> 00:54:59,300
if I'm at this point in time

1259
00:54:59,470 --> 00:55:00,270
and I've been told,

1260
00:55:00,270 --> 00:55:01,575
should I admit this read of B,

1261
00:55:01,575 --> 00:55:02,570
I have to make a decision,

1262
00:55:03,040 --> 00:55:05,660
if I'm this pessimistic transaction management system,

1263
00:55:05,890 --> 00:55:07,400
pessimistic isolation management,

1264
00:55:07,690 --> 00:55:10,935
if I I will have to decide whether to let that happen or not,

1265
00:55:10,935 --> 00:55:12,615
if I'm optimistic, I'll let it go,

1266
00:55:12,615 --> 00:55:13,950
and in the end I will figure out, right,

1267
00:55:13,950 --> 00:55:16,550
so that's the difference between the pessimistic and the optimistic.

1268
00:55:21,760 --> 00:55:23,790
It has been created while it's happening, right,

1269
00:55:23,840 --> 00:55:26,580
so you can imagine something like this is happening in the system,

1270
00:55:26,960 --> 00:55:28,800
[] step is run,

1271
00:55:29,510 --> 00:55:31,735
we start with begin on T1,

1272
00:55:31,735 --> 00:55:34,105
then read of A is done, write of A is done,

1273
00:55:34,105 --> 00:55:35,340
system says I can let you go,

1274
00:55:35,840 --> 00:55:37,930
then when the write of A comes,

1275
00:55:38,160 --> 00:55:40,810
system is say, you know what, I need to put an arc in this graph,

1276
00:55:40,860 --> 00:55:42,230
so as time is progressing,

1277
00:55:42,230 --> 00:55:43,595
these arcs are being done,

1278
00:55:43,595 --> 00:55:48,010
the reads and writes are being presented to the system that evolves.

1279
00:55:51,890 --> 00:55:55,500
And that's the difference between the pessimistic method and the optimistic,

1280
00:55:55,700 --> 00:55:56,880
pessimistic will say,

1281
00:55:57,050 --> 00:55:59,250
first time I think there's a problem, I'm going to stop you,

1282
00:56:00,490 --> 00:56:02,450
and we'll see how in the next class,

1283
00:56:02,800 --> 00:56:04,635
and optimistic is I let everything go,

1284
00:56:04,635 --> 00:56:06,330
but I know how to get you back to a safe place,

1285
00:56:06,330 --> 00:56:07,250
if bad things had happened.

1286
00:56:10,490 --> 00:56:11,440
This is not optimistic,

1287
00:56:11,440 --> 00:56:12,100
it's just saying,

1288
00:56:12,100 --> 00:56:14,430
how do I detect that something is good or bad,

1289
00:56:14,600 --> 00:56:15,540
but this is the mechanism.

1290
00:56:15,920 --> 00:56:16,320
Yep.

1291
00:56:16,400 --> 00:56:22,630
If it is a cycle, it is not okay,

1292
00:56:22,630 --> 00:56:23,970
how do I find the cycle,

1293
00:56:24,110 --> 00:56:27,240
when do I find the cycle is where the difference is,

1294
00:56:27,260 --> 00:56:29,520
do I find the cycle as soon as it is formed,

1295
00:56:29,720 --> 00:56:32,460
or do I find the cycle after I let everything go.

1296
00:56:34,190 --> 00:56:36,540
So that's basically the whole theory of saying,

1297
00:56:36,680 --> 00:56:39,660
is this equivalent to that order or not.

1298
00:56:40,260 --> 00:56:43,940
So here is another example,

1299
00:56:44,080 --> 00:56:46,850
and this is where we are getting into this new serializability

1300
00:56:47,320 --> 00:56:50,300
and kind of what is happening over here in,

1301
00:56:51,370 --> 00:56:52,520
here what's happening is,

1302
00:56:52,630 --> 00:56:55,550
A is getting 10 dollars removed from it

1303
00:56:55,720 --> 00:57:00,590
and there's a sum that is being calculated that's getting printed out over here,

1304
00:57:00,640 --> 00:57:03,650
of course, there are problems with this transaction,

1305
00:57:03,970 --> 00:57:06,650
because that one causes the arc from T1 to T2,

1306
00:57:07,000 --> 00:57:08,510
and then you have this transaction,

1307
00:57:08,650 --> 00:57:10,400
so this is not serializable,

1308
00:57:10,600 --> 00:57:11,480
but if instead of,

1309
00:57:11,920 --> 00:57:14,340
the second transactions doing a sum of the two transactions,

1310
00:57:14,600 --> 00:57:17,020
if the code in there was only about saying,

1311
00:57:17,020 --> 00:57:21,120
find the number of transactions that have values account values greater than 100,

1312
00:57:21,500 --> 00:57:23,490
the fact that it is a cycle,

1313
00:57:23,810 --> 00:57:26,220
doesn't matter from the semantics of that second transaction,

1314
00:57:26,750 --> 00:57:27,670
at a very high level,

1315
00:57:27,670 --> 00:57:30,030
that's what view serializability is it.

1316
00:57:30,110 --> 00:57:33,000
If you knew something about the semantics of what was happening,

1317
00:57:33,380 --> 00:57:36,960
you will admit a few more types of schedules that you would not otherwise.

1318
00:57:37,370 --> 00:57:38,005
And as I said,

1319
00:57:38,005 --> 00:57:40,045
that's all I wanted to know for this class,

1320
00:57:40,045 --> 00:57:41,820
if you didn't get that, that's okay.

1321
00:57:41,960 --> 00:57:42,660
Let it go,

1322
00:57:42,800 --> 00:57:45,480
we're not going to talk too much about view serializability,

1323
00:57:45,980 --> 00:57:48,685
it will just allow certain types of cycles,

1324
00:57:48,685 --> 00:57:50,910
because it says I think the application is okay.

1325
00:57:51,570 --> 00:57:52,120
All right.

1326
00:57:52,620 --> 00:57:54,300
And there's a formal definition of it,

1327
00:57:54,300 --> 00:57:57,225
if you're interested in looking at it in terms of what it allows,

1328
00:57:57,225 --> 00:58:02,330
it basically allows a few more schedules than a strictly serial schedule will allow.

1329
00:58:03,080 --> 00:58:08,550
Alright, so conflict serializability is the main thing that we want you to know about.

1330
00:58:09,850 --> 00:58:11,330
Alright, pictorially,

1331
00:58:12,040 --> 00:58:14,150
here's the universe of all possible schedules,

1332
00:58:14,230 --> 00:58:15,230
including the bad ones,

1333
00:58:15,550 --> 00:58:16,880
the ones we don't want to happen.

1334
00:58:18,290 --> 00:58:21,430
Sorry, yeah, serial schedule is that strict serial stuff which you talked about,

1335
00:58:21,430 --> 00:58:22,450
T1 followed by T2,

1336
00:58:22,450 --> 00:58:25,090
and that's the only thing that allow conflict serializable is,

1337
00:58:25,090 --> 00:58:27,210
if we are allowing a few more combinations

1338
00:58:27,590 --> 00:58:31,860
and view serializable is where you might have a little bit more by way of this application performance.

1339
00:58:34,650 --> 00:58:36,665
And there are many more layers in there,

1340
00:58:36,665 --> 00:58:38,915
and we'll uncover some of those in later classes

1341
00:58:38,915 --> 00:58:41,050
and again, a lot more in the detail class.

1342
00:58:42,340 --> 00:58:44,330
So we still have one more letter to cover,

1343
00:58:44,500 --> 00:58:46,305
which is the D, which is the durability,

1344
00:58:46,305 --> 00:58:49,960
right, we did atomicity, consistency, isolation,

1345
00:58:50,130 --> 00:58:51,940
which is where we spend most of the time today,

1346
00:58:52,170 --> 00:58:53,590
and the last one is durability,

1347
00:58:53,760 --> 00:58:55,090
which will cover really fast.

1348
00:58:55,720 --> 00:58:58,830
Durability, we have a full lecture coming on it,

1349
00:58:58,910 --> 00:59:01,980
on this in the second class now,

1350
00:59:02,420 --> 00:59:08,600
which is about making sure that the changes that we make to the system,

1351
00:59:09,160 --> 00:59:13,190
we're making changes to A, the Bs and the Cs and stuff like that,

1352
00:59:13,540 --> 00:59:14,390
just in memory,

1353
00:59:15,010 --> 00:59:17,270
if you're updating a column value or a record,

1354
00:59:17,470 --> 00:59:18,800
that's sitting in the buffer pool,

1355
00:59:19,630 --> 00:59:22,670
but what happens if you have a power loss

1356
00:59:22,720 --> 00:59:25,370
and memory is volatile,

1357
00:59:25,600 --> 00:59:27,225
so those changes never made it to disk,

1358
00:59:27,225 --> 00:59:28,700
but you might have committed that transaction.

1359
00:59:29,670 --> 00:59:31,780
So durability is the aspect that says,

1360
00:59:32,370 --> 00:59:35,180
if the database commits the transaction,

1361
00:59:35,980 --> 00:59:38,715
oh, by the way, the database is allowed to use a buffer pool,

1362
00:59:38,715 --> 00:59:42,290
because that's an efficient way to build data processing systems,

1363
00:59:42,940 --> 00:59:44,400
you don't want to go to disk every time

1364
00:59:44,400 --> 00:59:45,330
you want a buffer pool,

1365
00:59:45,330 --> 00:59:50,090
because buffer pool, accessing data in buffer pool is just so much faster than accessing things on disk.

1366
00:59:51,050 --> 00:59:53,485
But if the database is, it's committed,

1367
00:59:53,485 --> 00:59:55,050
you want to make sure that,

1368
00:59:55,190 --> 00:59:56,550
if there's power failure,

1369
00:59:57,050 --> 00:59:59,545
you can get the right values in the database.

1370
00:59:59,545 --> 01:00:00,900
So durability will do that,

1371
01:00:01,280 --> 01:00:04,260
by making sure when the commit happens,

1372
01:00:04,970 --> 01:00:07,795
it's going to make sure certain things get written to disk

1373
01:00:07,795 --> 01:00:11,940
and it'll try to do very small amounts of [] write to disk,

1374
01:00:12,110 --> 01:00:14,460
so that it can provide this durability property.

1375
01:00:15,950 --> 01:00:16,930
And as I said,

1376
01:00:16,930 --> 01:00:18,780
in two lectures from now, we'll talk about that.

1377
01:00:19,610 --> 01:00:24,210
So that's basically what ACID looks like.

1378
01:00:24,720 --> 01:00:27,650
Yeah, we can talk about that offline,

1379
01:00:27,650 --> 01:00:30,160
the answer is the principles will probably apply,

1380
01:00:30,420 --> 01:00:33,520
is like I have volatile storage and non volatile storage

1381
01:00:33,900 --> 01:00:37,480
and I can apply this principle of durability across any of those systems.

1382
01:00:37,740 --> 01:00:39,950
Yeah, yeah, the same principles to apply.

1383
01:00:39,950 --> 01:00:40,295
Yep.

1384
01:00:40,295 --> 01:00:44,050
The logs, sorry.

1385
01:00:46,440 --> 01:00:48,005
Yeah, the logs will be kept in memory,

1386
01:00:48,005 --> 01:00:49,720
we'll get to that in two lectures from now,

1387
01:00:49,890 --> 01:00:52,720
the log records that we create will be kept in memory too,

1388
01:00:52,860 --> 01:00:54,110
but at appropriate times,

1389
01:00:54,110 --> 01:00:55,775
we will actually flush them out to disk

1390
01:00:55,775 --> 01:00:57,640
to guarantee the durability property.

1391
01:01:00,370 --> 01:01:01,305
We'll talk about that,

1392
01:01:01,305 --> 01:01:02,730
what happens if the log fails,

1393
01:01:02,730 --> 01:01:05,210
that's the whole lecture, two lectures from now.

1394
01:01:05,350 --> 01:01:06,105
It's a full lecture,

1395
01:01:06,105 --> 01:01:07,580
I can give you a ten second answer,

1396
01:01:07,870 --> 01:01:09,135
the ten second answer is,

1397
01:01:09,135 --> 01:01:13,370
that we will make sure that absolutely what must be written to disk is written,

1398
01:01:13,720 --> 01:01:15,060
and if we write the wrong thing,

1399
01:01:15,060 --> 01:01:17,330
we will look at the value and undo if we need to,

1400
01:01:17,350 --> 01:01:19,635
we'll do one of two things with stuff we write on disk,

1401
01:01:19,635 --> 01:01:23,595
either redo the operation, because it's inconsistent with what was in memory

1402
01:01:23,595 --> 01:01:26,750
or undo it, because we wrote something that we should not have written.

1403
01:01:28,180 --> 01:01:31,070
So we'll do redo and undo logic on on those.

1404
01:01:32,400 --> 01:01:34,235
Okay, so here's the conclusions.

1405
01:01:34,235 --> 01:01:38,380
Concurrency control and recovery amongst the most important functions that transactions,

1406
01:01:39,000 --> 01:01:39,970
are super important,

1407
01:01:40,800 --> 01:01:44,480
but that's a putit, definitional component of database systems,

1408
01:01:44,480 --> 01:01:46,690
and if you go back to the early days of database systems,

1409
01:01:47,010 --> 01:01:49,750
that's why they started getting adopted in enterprises,

1410
01:01:50,070 --> 01:01:51,790
because they allowed all this record keeping.

1411
01:01:52,270 --> 01:01:55,515
I need five minutes to go over a couple of things,

1412
01:01:55,515 --> 01:01:57,800
but before that, we've talked about this a few times,

1413
01:01:58,270 --> 01:02:02,630
that there are, there's still a lot more things you can do with transactions,

1414
01:02:03,220 --> 01:02:06,320
there's this breakthrough paper that came out from Google called Spanner,

1415
01:02:06,580 --> 01:02:09,810
by the way, before that, they were doing eventual consistency stuff in many parts,

1416
01:02:09,810 --> 01:02:13,220
and they realized, wow, application programmers can't quite do that,

1417
01:02:13,420 --> 01:02:15,800
so they actually build a very hard thing,

1418
01:02:16,260 --> 01:02:19,280
which is a globally distributed system that can do transactions,

1419
01:02:19,960 --> 01:02:24,730
where the transactions could be touching objects in the database, which is distributed,

1420
01:02:25,140 --> 01:02:28,030
so it might touch an object in London, touch an object in the US

1421
01:02:28,470 --> 01:02:32,020
and commit that transaction across the globe as one transaction

1422
01:02:32,520 --> 01:02:34,300
and do that fast and efficiently.

1423
01:02:34,580 --> 01:02:36,155
And the reason they did that is,

1424
01:02:36,155 --> 01:02:38,380
if they kept the eventual consistency stuff,

1425
01:02:38,460 --> 01:02:41,470
all kinds of application programmer bugs was showing unp,

1426
01:02:41,580 --> 01:02:43,490
like the AD system would report wrong things,

1427
01:02:43,490 --> 01:02:47,170
it would tell the same advertiser, Proctor and Gamble, for example, in London,

1428
01:02:47,430 --> 01:02:49,030
this is how many impressions we showed,

1429
01:02:49,200 --> 01:02:51,550
and the same campaign in US would show a different number

1430
01:02:51,750 --> 01:02:53,360
and these two guys get on the phone and say,

1431
01:02:53,360 --> 01:02:54,100
what the heck is happening,

1432
01:02:54,680 --> 01:02:56,200
what impressions did we really show,

1433
01:02:56,250 --> 01:02:57,580
you want that answer to be precise,

1434
01:02:57,900 --> 01:02:59,320
because someone's paying money for it,

1435
01:03:00,120 --> 01:03:02,410
that was one of the big reasons why they went and built that.

1436
01:03:02,490 --> 01:03:03,550
It's a beautiful system,

1437
01:03:03,840 --> 01:03:05,260
requires atomic clocks,

1438
01:03:05,400 --> 01:03:07,960
where you need satellite syncing across the data centers,

1439
01:03:08,370 --> 01:03:10,480
so that the two clocks are not out of sync.

1440
01:03:10,560 --> 01:03:16,090
CockroachDB was formed by people from Google who worked on this

1441
01:03:16,140 --> 01:03:19,475
and have a version of it that doesn't require satellite clocks,

1442
01:03:19,475 --> 01:03:20,770
but fascinating feel,

1443
01:03:20,940 --> 01:03:22,960
there's still a lot of new things that are happening.

1444
01:03:24,140 --> 01:03:26,820
Bonus round, I leave this link in the slides if you want to.

1445
01:03:26,870 --> 01:03:30,565
We've talked about all kinds of different models and levels of consistency,

1446
01:03:30,565 --> 01:03:31,440
but there's a lot more,

1447
01:03:31,670 --> 01:03:33,175
and you can play around with that chart.

1448
01:03:33,175 --> 01:03:36,445
But I want to spend a couple minutes on the project #3,

1449
01:03:36,445 --> 01:03:37,920
which is on query execution.

1450
01:03:38,560 --> 01:03:41,640
And the overview of this project is,

1451
01:03:42,140 --> 01:03:43,320
we essentially have,

1452
01:03:45,200 --> 01:03:46,980
these are the different components of Bustub,

1453
01:03:47,060 --> 01:03:49,140
as you've gotten to know and love over time,

1454
01:03:49,460 --> 01:03:53,850
project #3 is related to the optimizer and the query execution

1455
01:03:54,080 --> 01:03:58,050
and project #4 that's coming will be query execution in the transaction management piece.

1456
01:03:58,640 --> 01:04:00,270
Okay, so what is project #3,

1457
01:04:00,590 --> 01:04:02,970
you're going to add access methods,

1458
01:04:03,020 --> 01:04:04,170
two different access methods,

1459
01:04:04,280 --> 01:04:05,880
sequential scan and index scan,

1460
01:04:06,880 --> 01:04:10,280
you will also do insert, delete and updates,

1461
01:04:10,300 --> 01:04:12,735
so these are the operators stuff that you're going to add,

1462
01:04:12,735 --> 01:04:16,700
you're going to add these as new operators that are in the system,

1463
01:04:17,480 --> 01:04:20,820
two different types of Join, nested loops Join and hash Join

1464
01:04:21,320 --> 01:04:26,430
and there's some miscellaneous window aggregation function, Limit Sort and Top-k.

1465
01:04:27,010 --> 01:04:28,965
You'll also touch the optimizer,

1466
01:04:28,965 --> 01:04:31,040
so there's already an optimizer in Bustub

1467
01:04:31,360 --> 01:04:34,130
and to convert a query,

1468
01:04:34,150 --> 01:04:36,470
if a query has both an ORDER BY and a LIMIT,

1469
01:04:36,670 --> 01:04:40,400
you can convert it to a with a simple transformation into a Top-k query.

1470
01:04:40,780 --> 01:04:44,060
So that will give you a chance to look at how do optimizers work.

1471
01:04:44,870 --> 01:04:46,060
If you see a nested loops,

1472
01:04:46,060 --> 01:04:47,220
that's often a bad idea,

1473
01:04:47,450 --> 01:04:48,355
so in the optimizer,

1474
01:04:48,355 --> 01:04:50,910
you will write a rule to convert nested loops to hash Join,

1475
01:04:51,950 --> 01:04:53,340
because those are typically much faster.

1476
01:04:53,870 --> 01:04:55,990
And similarly with sequential scan to index scan,

1477
01:04:55,990 --> 01:04:58,345
if an index exists, don't do a sequential scan,

1478
01:04:58,345 --> 01:04:59,430
go use an index scan.

1479
01:04:59,630 --> 01:05:00,100
These is,

1480
01:05:00,100 --> 01:05:01,765
think of it as the heuristic stuff,

1481
01:05:01,765 --> 01:05:04,600
that we talked about in the optimization stuff, right,

1482
01:05:04,600 --> 01:05:07,500
not cost based heuristics, just rules based.

1483
01:05:09,390 --> 01:05:13,805
The leaderboard will require making deeper changes to the optimizer,

1484
01:05:13,805 --> 01:05:16,390
so even if you have awesome code from project #1 and project #2,

1485
01:05:16,530 --> 01:05:19,630
you're guaranteed not to get good high stats on the leaderboard,

1486
01:05:19,860 --> 01:05:21,850
unless you go add new optimization rules

1487
01:05:22,200 --> 01:05:24,760
and that's all described in the project,

1488
01:05:24,810 --> 01:05:28,120
you'll be adding rules to window aggregation and and top-k.

1489
01:05:28,610 --> 01:05:31,750
Quick tips, start with the easy stuff,

1490
01:05:31,750 --> 01:05:33,340
the insert and sequential scan,

1491
01:05:33,340 --> 01:05:34,470
that's the easiest stuff,

1492
01:05:34,700 --> 01:05:35,400
get it right,

1493
01:05:35,720 --> 01:05:39,210
before you go do other things with it.

1494
01:05:39,470 --> 01:05:41,940
And the key thing is,

1495
01:05:42,830 --> 01:05:50,230
now you can actually go and run Bustub in, in the browser.

1496
01:05:50,880 --> 01:05:52,900
So I'm going to close this here.

1497
01:05:53,700 --> 01:06:00,120
And whoops, Powerpoint don't need that anymore.

1498
01:06:00,800 --> 01:06:04,900
And if you go look at Bustub now,

1499
01:06:05,040 --> 01:06:09,870
you can actually go and run Bustub in the browser.

1500
01:06:10,670 --> 01:06:12,300
let me go find the link here.

1501
01:06:13,500 --> 01:06:13,900
Yep.

1502
01:06:15,360 --> 01:06:17,710
[Chi], who's just an awesome programmer,

1503
01:06:18,220 --> 01:06:19,945
has written this version,

1504
01:06:19,945 --> 01:06:22,320
which completely runs in VASM code in the browser

1505
01:06:22,880 --> 01:06:25,440
and it's already loaded with some tables in there,

1506
01:06:25,670 --> 01:06:27,145
and you can start to do things,

1507
01:06:27,145 --> 01:06:32,070
like SELECT * FROM _mock_table_,

1508
01:06:32,450 --> 01:06:33,750
and do things like that,

1509
01:06:33,770 --> 01:06:35,310
whoops, where's my semicolon,

1510
01:06:35,510 --> 01:06:36,970
and you can start to run stuff.

1511
01:06:36,970 --> 01:06:38,970
You can use this to test if your code works,

1512
01:06:39,520 --> 01:06:41,005
our solution is sitting behind that.

1513
01:06:41,005 --> 01:06:41,340
Yep.

1514
01:06:59,560 --> 01:07:01,220
Yeah, so the,

1515
01:07:02,280 --> 01:07:03,310
use this as a reference,

1516
01:07:03,960 --> 01:07:07,090
don't use great scope as a way of doing your debugging,

1517
01:07:07,260 --> 01:07:08,080
write your tests,

1518
01:07:08,490 --> 01:07:10,810
otherwise, you will not do well in this project.

1519
01:07:12,350 --> 01:07:13,560
So hopefully it's a fun project,

1520
01:07:13,700 --> 01:07:14,755
start with the simple stuff,

1521
01:07:14,755 --> 01:07:15,720
it may seem like a lot,

1522
01:07:15,770 --> 01:07:16,735
start with the simple stuff

1523
01:07:16,735 --> 01:07:18,930
and you'll be surprised how quickly you start knocking things off.

1524
01:07:19,250 --> 01:07:22,410
Okay, all right, thank you, DJ, [] hit it.

